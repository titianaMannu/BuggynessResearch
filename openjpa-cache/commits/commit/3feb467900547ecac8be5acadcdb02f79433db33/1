{"sha":"3feb467900547ecac8be5acadcdb02f79433db33","node_id":"MDY6Q29tbWl0MjA2MzY0OjNmZWI0Njc5MDA1NDdlY2FjOGJlNWFjYWRjZGIwMmY3OTQzM2RiMzM=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-12T01:32:26Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-12T01:32:26Z"},"message":"removed serp fork; replaced with new maven-based serp access. also updated poms to use the Geronimo versions of JTA etc. until we get closure on the plan going forward with the authoritative Glassfish jars\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@421069 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a369232be62d272dd1a3cb814d639d485e9ff878","url":"https://api.github.com/repos/apache/openjpa/git/trees/a369232be62d272dd1a3cb814d639d485e9ff878"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/3feb467900547ecac8be5acadcdb02f79433db33","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/3feb467900547ecac8be5acadcdb02f79433db33","html_url":"https://github.com/apache/openjpa/commit/3feb467900547ecac8be5acadcdb02f79433db33","comments_url":"https://api.github.com/repos/apache/openjpa/commits/3feb467900547ecac8be5acadcdb02f79433db33/comments","author":null,"committer":null,"parents":[{"sha":"7a6d34e95f66e916e44b844b1ce6551ba8169539","url":"https://api.github.com/repos/apache/openjpa/commits/7a6d34e95f66e916e44b844b1ce6551ba8169539","html_url":"https://github.com/apache/openjpa/commit/7a6d34e95f66e916e44b844b1ce6551ba8169539"}],"stats":{"total":23116,"additions":30,"deletions":23086},"files":[{"sha":"99ec5902df3c942318683071171eb2eba7e6683a","filename":"openjpa-kernel-5/pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/3feb467900547ecac8be5acadcdb02f79433db33/openjpa-kernel-5/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/3feb467900547ecac8be5acadcdb02f79433db33/openjpa-kernel-5/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/pom.xml?ref=3feb467900547ecac8be5acadcdb02f79433db33","patch":"@@ -22,7 +22,7 @@\n \n             <groupId>org.apache.openjpa</groupId>\n             <artifactId>openjpa-kernel</artifactId>\n-            <version>0.0.1</version>\n+            <version>${pom.version}</version>\n             <scope>compile</scope>\n \n         </dependency>"},{"sha":"31df1e4266c281f80f7e128992ca57d98d7038b9","filename":"openjpa-kernel/pom.xml","status":"modified","additions":14,"deletions":10,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/3feb467900547ecac8be5acadcdb02f79433db33/openjpa-kernel/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/3feb467900547ecac8be5acadcdb02f79433db33/openjpa-kernel/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/pom.xml?ref=3feb467900547ecac8be5acadcdb02f79433db33","patch":"@@ -22,35 +22,39 @@\n \n             <groupId>org.apache.openjpa</groupId>\n             <artifactId>openjpa-lib</artifactId>\n-            <version>0.0.1</version>\n+            <version>${pom.version}</version>\n             <scope>compile</scope>\n \n         </dependency>\n+\n+\n         <dependency>\n \n-            <groupId>javax.jms</groupId>\n-            <artifactId>jms</artifactId>\n-            <version>1.1</version>\n+            <groupId>org.apache.geronimo.specs</groupId>\n+            <artifactId>geronimo-jms_1.1_spec</artifactId>\n+            <version>1.0.1</version>\n             <scope>compile</scope>\n \n         </dependency>\n         <dependency>\n \n-            <groupId>javax.resource</groupId>\n-            <artifactId>connector</artifactId>\n-            <version>1.0</version>\n+            <groupId>org.apache.geronimo.specs</groupId>\n+            <artifactId>geronimo-j2ee-connector_1.5_spec</artifactId>\n+            <version>1.0.1</version>\n             <scope>compile</scope>\n \n         </dependency>\n+\n         <dependency>\n \n-            <groupId>javax.transaction</groupId>\n-            <artifactId>jta</artifactId>\n-            <version>1.0.1B</version>\n+            <groupId>org.apache.geronimo.specs</groupId>\n+            <artifactId>geronimo-jta_1.0.1B_spec</artifactId>\n+            <version>1.0.1</version>\n             <scope>compile</scope>\n \n         </dependency>\n \n+\n     </dependencies>\n     <build>\n "},{"sha":"051d523828473ba9d4e828563ac5bbb7a4342c65","filename":"openjpa-lib/pom.xml","status":"modified","additions":4,"deletions":11,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/3feb467900547ecac8be5acadcdb02f79433db33/openjpa-lib/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/3feb467900547ecac8be5acadcdb02f79433db33/openjpa-lib/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/pom.xml?ref=3feb467900547ecac8be5acadcdb02f79433db33","patch":"@@ -18,14 +18,6 @@\n     </parent>\n     <dependencies>\n \n-        <dependency>\n-\n-            <groupId>org.apache.openjpa</groupId>\n-            <artifactId>serp</artifactId>\n-            <version>0.0.1</version>\n-            <scope>compile</scope>\n-\n-        </dependency>\n         <dependency>\n \n             <groupId>jakarta-regexp</groupId>\n@@ -98,11 +90,12 @@\n             <scope>compile</scope>\n \n         </dependency>\n+\n         <dependency>\n \n-            <groupId>jdbc</groupId>\n-            <artifactId>jdbc-stdext</artifactId>\n-            <version>2.0</version>\n+            <groupId>net.sourceforge.serp</groupId>\n+            <artifactId>serp</artifactId>\n+            <version>1.11.0</version>\n             <scope>compile</scope>\n \n         </dependency>"},{"sha":"a1b1df6d3806bfb242b51bac784226eeeb286ad2","filename":"openjpa-persistence/pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/3feb467900547ecac8be5acadcdb02f79433db33/openjpa-persistence/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/3feb467900547ecac8be5acadcdb02f79433db33/openjpa-persistence/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/pom.xml?ref=3feb467900547ecac8be5acadcdb02f79433db33","patch":"@@ -22,7 +22,7 @@\n \n             <groupId>org.apache.openjpa</groupId>\n             <artifactId>openjpa-kernel-5</artifactId>\n-            <version>0.0.1</version>\n+            <version>${pom.version}</version>\n             <scope>compile</scope>\n \n         </dependency>"},{"sha":"717db75952658f94f07fd760b1065c9da043b4f1","filename":"openjpa-xmlstore/pom.xml","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/3feb467900547ecac8be5acadcdb02f79433db33/openjpa-xmlstore/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/3feb467900547ecac8be5acadcdb02f79433db33/openjpa-xmlstore/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/pom.xml?ref=3feb467900547ecac8be5acadcdb02f79433db33","patch":"@@ -6,8 +6,8 @@\n     <artifactId>openjpa-xmlstore</artifactId>\n     <packaging>jar</packaging>\n \n-    <name>JPA</name>\n-    <description>JPA</description>\n+    <name>XML Store</name>\n+    <description>XML Store for OpenJPA</description>\n     <url>http://incubator.apache.org/projects/openjpa</url>\n     <parent>\n \n@@ -22,7 +22,7 @@\n \n             <groupId>org.apache.openjpa</groupId>\n             <artifactId>openjpa-kernel</artifactId>\n-            <version>0.0.1</version>\n+            <version>${pom.version}</version>\n             <scope>compile</scope>\n \n         </dependency>"},{"sha":"ac47169270799b0f3046adc8d468a9dd610260c0","filename":"pom.xml","status":"modified","additions":7,"deletions":8,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/3feb467900547ecac8be5acadcdb02f79433db33/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/3feb467900547ecac8be5acadcdb02f79433db33/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/pom.xml?ref=3feb467900547ecac8be5acadcdb02f79433db33","patch":"@@ -84,7 +84,6 @@\n     <modules>\n \n         <module>openjpa-lib</module>\n-        <module>serp</module>\n         <module>openjpa-kernel</module>\n         <module>openjpa-kernel-5</module>\n         <module>openjpa-persistence</module>\n@@ -100,20 +99,20 @@\n         </repository>\n \n \n-        <repository>\n-            <id>swami</id>\n-            <name>Swami repository</name>\n-            <url>http://m2.ngbw.org</url>\n-        </repository>\n-\n-\n         <repository>\n             <id>java-net</id>\n             <name>dev.java.net repository</name>\n             <url>https://maven-repository.dev.java.net/nonav/repository</url>\n             <layout>legacy</layout>\n         </repository>\n \n+\n+        <repository>\n+            <id>serp</id>\n+            <name>Serp Project Repository</name>\n+            <url>http://serp.sourceforge.net/m2repo</url>\n+        </repository>\n+\n     </repositories>\n     <dependencies>\n "},{"sha":"10d6085e2340419f87e11f202440142d9683a13b","filename":"serp/pom.xml","status":"removed","additions":0,"deletions":43,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/pom.xml?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,43 +0,0 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n-         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-    <modelVersion>4.0.0</modelVersion>\n-    <groupId>org.apache.openjpa</groupId>\n-    <artifactId>serp</artifactId>\n-    <packaging>jar</packaging>\n-\n-    <name>Serp</name>\n-    <description>Serp</description>\n-    <url>http://incubator.apache.org/projects/openjpa</url>\n-    <parent>\n-\n-        <groupId>org.apache.openjpa</groupId>\n-        <artifactId>openjpa</artifactId>\n-        <version>0.0.1</version>\n-\n-    </parent>\n-    <dependencies>\n-\n-\n-    </dependencies>\n-    <build>\n-\n-        <plugins>\n-\n-            <plugin>\n-\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>1.3</source>\n-                    <target>1.3</target>\n-                </configuration>\n-\n-            </plugin>\n-\n-        </plugins>\n-\n-    </build>\n-\n-\n-</project>"},{"sha":"933dc6d09c908bf749fc3afa39d12c4c4c8b0b52","filename":"serp/src/main/java/serp/bytecode/ArrayInstruction.java","status":"removed","additions":0,"deletions":31,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ArrayInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ArrayInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ArrayInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,31 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-/**\n- * Any array load or store instruction. This class has\n- * no functionality beyond the {@link TypedInstruction} but is provided\n- * so that users can easily identify array instructions in code if need be.\n- *\n- * @author Abe White\n- */\n-public abstract class ArrayInstruction extends TypedInstruction {\n-\n-    ArrayInstruction(Code owner) {\n-        super(owner);\n-    }\n-\n-    ArrayInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-}"},{"sha":"c8427fbb13a056027154f3d0c3883b6de1df035e","filename":"serp/src/main/java/serp/bytecode/ArrayLoadInstruction.java","status":"removed","additions":0,"deletions":108,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ArrayLoadInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ArrayLoadInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ArrayLoadInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,108 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Loads a value from an array onto the stack.\n- *\n- * @author Abe White\n- */\n-public class ArrayLoadInstruction extends ArrayInstruction {\n-\n-    private static final Class[][] _mappings = new Class[][]{\n-        { boolean.class, int.class }, { void.class, int.class }, };\n-\n-    ArrayLoadInstruction(Code owner) {\n-        super(owner);\n-    }\n-\n-    ArrayLoadInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    public int getLogicalStackChange() {\n-        switch (getOpcode()) {\n-            case Constants.NOP:\n-                return 0;\n-            default:\n-                return -1;\n-        }\n-    }\n-\n-    public int getStackChange() {\n-        switch (getOpcode()) {\n-            case Constants.DALOAD:\n-            case Constants.LALOAD:\n-            case Constants.NOP:\n-                return 0;\n-            default:\n-                return -1;\n-        }\n-    }\n-\n-    public String getTypeName() {\n-        switch (getOpcode()) {\n-            case Constants.IALOAD:\n-                return int.class.getName();\n-            case Constants.LALOAD:\n-                return long.class.getName();\n-            case Constants.FALOAD:\n-                return float.class.getName();\n-            case Constants.DALOAD:\n-                return double.class.getName();\n-            case Constants.AALOAD:\n-                return Object.class.getName();\n-            case Constants.BALOAD:\n-                return byte.class.getName();\n-            case Constants.CALOAD:\n-                return char.class.getName();\n-            case Constants.SALOAD:\n-                return short.class.getName();\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    public TypedInstruction setType(String type) {\n-        type = mapType(type, _mappings, true);\n-\n-        if (type == null)\n-            return (TypedInstruction) setOpcode(Constants.NOP);\n-\n-        switch (type.charAt(0)) {\n-            case 'i':\n-                return (TypedInstruction) setOpcode(Constants.IALOAD);\n-            case 'l':\n-                return (TypedInstruction) setOpcode(Constants.LALOAD);\n-            case 'f':\n-                return (TypedInstruction) setOpcode(Constants.FALOAD);\n-            case 'd':\n-                return (TypedInstruction) setOpcode(Constants.DALOAD);\n-            case 'b':\n-                return (TypedInstruction) setOpcode(Constants.BALOAD);\n-            case 'c':\n-                return (TypedInstruction) setOpcode(Constants.CALOAD);\n-            case 's':\n-                return (TypedInstruction) setOpcode(Constants.SALOAD);\n-            default:\n-                return (TypedInstruction) setOpcode(Constants.AALOAD);\n-        }\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterArrayLoadInstruction(this);\n-        visit.exitArrayLoadInstruction(this);\n-    }\n-}"},{"sha":"af9202077e4f57ec5eddb80b28ad96564874e2de","filename":"serp/src/main/java/serp/bytecode/ArrayState.java","status":"removed","additions":0,"deletions":92,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ArrayState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ArrayState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ArrayState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,92 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.util.Collection;\n-import java.util.Collections;\n-\n-/**\n- * State implementing the behavior of an array class.\n- *\n- * @author Abe White\n- */\n-class ArrayState extends State {\n-\n-    private String _name = null;\n-    private String _componentName = null;\n-\n-    public ArrayState(String name, String componentName) {\n-        _name = name;\n-        _componentName = componentName;\n-    }\n-\n-    public int getMagic() {\n-        return Constants.VALID_MAGIC;\n-    }\n-\n-    public int getMajorVersion() {\n-        return Constants.MAJOR_VERSION;\n-    }\n-\n-    public int getMinorVersion() {\n-        return Constants.MINOR_VERSION;\n-    }\n-\n-    public int getAccessFlags() {\n-        return Constants.ACCESS_PUBLIC | Constants.ACCESS_FINAL;\n-    }\n-\n-    public int getIndex() {\n-        return 0;\n-    }\n-\n-    public int getSuperclassIndex() {\n-        return 0;\n-    }\n-\n-    public Collection getInterfacesHolder() {\n-        return Collections.EMPTY_LIST;\n-    }\n-\n-    public Collection getFieldsHolder() {\n-        return Collections.EMPTY_LIST;\n-    }\n-\n-    public Collection getMethodsHolder() {\n-        return Collections.EMPTY_LIST;\n-    }\n-\n-    public Collection getAttributesHolder() {\n-        return Collections.EMPTY_LIST;\n-    }\n-\n-    public String getName() {\n-        return _name;\n-    }\n-\n-    public String getSuperclassName() {\n-        return Object.class.getName();\n-    }\n-\n-    public String getComponentName() {\n-        return _componentName;\n-    }\n-\n-    public boolean isPrimitive() {\n-        return false;\n-    }\n-\n-    public boolean isArray() {\n-        return true;\n-    }\n-}"},{"sha":"0ace3f0a876dc91ff951ec02494aa69c8c33896e","filename":"serp/src/main/java/serp/bytecode/ArrayStoreInstruction.java","status":"removed","additions":0,"deletions":108,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ArrayStoreInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ArrayStoreInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ArrayStoreInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,108 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Store a value from the stack into an array.\n- *\n- * @author Abe White\n- */\n-public class ArrayStoreInstruction extends ArrayInstruction {\n-\n-    private static final Class[][] _mappings = new Class[][]{\n-        { boolean.class, int.class }, { void.class, int.class }, };\n-\n-    ArrayStoreInstruction(Code owner) {\n-        super(owner);\n-    }\n-\n-    ArrayStoreInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    public int getLogicalStackChange() {\n-        switch (getOpcode()) {\n-            case Constants.NOP:\n-                return 0;\n-            default:\n-                return -3;\n-        }\n-    }\n-\n-    public int getStackChange() {\n-        switch (getOpcode()) {\n-            case Constants.DASTORE:\n-            case Constants.LASTORE:\n-                return -4;\n-            case Constants.NOP:\n-                return 0;\n-            default:\n-                return -3;\n-        }\n-    }\n-\n-    public String getTypeName() {\n-        switch (getOpcode()) {\n-            case Constants.IASTORE:\n-                return int.class.getName();\n-            case Constants.LASTORE:\n-                return long.class.getName();\n-            case Constants.FASTORE:\n-                return float.class.getName();\n-            case Constants.DASTORE:\n-                return double.class.getName();\n-            case Constants.AASTORE:\n-                return Object.class.getName();\n-            case Constants.BASTORE:\n-                return byte.class.getName();\n-            case Constants.CASTORE:\n-                return char.class.getName();\n-            case Constants.SASTORE:\n-                return short.class.getName();\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    public TypedInstruction setType(String type) {\n-        type = mapType(type, _mappings, true);\n-        if (type == null)\n-            return (TypedInstruction) setOpcode(Constants.NOP);\n-\n-        switch (type.charAt(0)) {\n-            case 'i':\n-                return (TypedInstruction) setOpcode(Constants.IASTORE);\n-            case 'l':\n-                return (TypedInstruction) setOpcode(Constants.LASTORE);\n-            case 'f':\n-                return (TypedInstruction) setOpcode(Constants.FASTORE);\n-            case 'd':\n-                return (TypedInstruction) setOpcode(Constants.DASTORE);\n-            case 'b':\n-                return (TypedInstruction) setOpcode(Constants.BASTORE);\n-            case 'c':\n-                return (TypedInstruction) setOpcode(Constants.CASTORE);\n-            case 's':\n-                return (TypedInstruction) setOpcode(Constants.SASTORE);\n-            default:\n-                return (TypedInstruction) setOpcode(Constants.AASTORE);\n-        }\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterArrayStoreInstruction(this);\n-        visit.exitArrayStoreInstruction(this);\n-    }\n-}"},{"sha":"1c2cb74bae6a4110317f708f1c01b80353c57890","filename":"serp/src/main/java/serp/bytecode/Attribute.java","status":"removed","additions":0,"deletions":142,"changes":142,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Attribute.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Attribute.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Attribute.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,142 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.lang.reflect.Constructor;\n-import java.util.Collection;\n-import java.util.Collections;\n-\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.bytecode.lowlevel.UTF8Entry;\n-import serp.bytecode.visitor.VisitAcceptor;\n-import serp.util.Numbers;\n-\n-/**\n- * In bytecode attributes are used to represent anything that is not\n- * part of the class structure. This includes the source file name, code of\n- * methods, the line number table, etc. All attributes contain at a minimum\n- * an immutable name that also determines the attribute's type.\n- *\n- * @author Abe White\n- */\n-public abstract class Attribute extends Attributes implements VisitAcceptor {\n-\n-    private int _nameIndex = 0;\n-    private Attributes _owner = null;\n-\n-    /**\n-     * Create an attribute of the appropriate type based on the\n-     * the attribute name.\n-     */\n-    static Attribute create(String name, Attributes owner) {\n-        int nameIndex = owner.getPool().findUTF8Entry(name, true);\n-        try {\n-            Class type = Class.forName(\"serp.bytecode.\" + name);\n-            Constructor cons = type.getDeclaredConstructor(new Class[]\n-                { int.class, Attributes.class });\n-\n-            return (Attribute) cons.newInstance(new Object[]\n-                { Numbers.valueOf(nameIndex), owner });\n-        } catch (Throwable t) {\n-            return new UnknownAttribute(nameIndex, owner);\n-        }\n-    }\n-\n-    Attribute(int nameIndex, Attributes owner) {\n-        _owner = owner;\n-        _nameIndex = nameIndex;\n-    }\n-\n-    /**\n-     * Return the {@link Attributes} that owns this attribute. The entity\n-     * might be a {@link BCClass}, {@link BCField}, {@link BCMethod}, or other\n-     * attribute.\n-     */\n-    public Attributes getOwner() {\n-        return _owner;\n-    }\n-\n-    /**\n-     * Return the index in the {@link ConstantPool} of the {@link UTF8Entry}\n-     * holding the name of this attribute.\n-     */\n-    public int getNameIndex() {\n-        return _nameIndex;\n-    }\n-\n-    /**\n-     * Return the name of this attribute.\n-     */\n-    public String getName() {\n-        return ((UTF8Entry) getPool().getEntry(_nameIndex)).getValue();\n-    }\n-\n-    public Project getProject() {\n-        return _owner.getProject();\n-    }\n-\n-    public ConstantPool getPool() {\n-        return _owner.getPool();\n-    }\n-\n-    public ClassLoader getClassLoader() {\n-        return _owner.getClassLoader();\n-    }\n-\n-    public boolean isValid() {\n-        return _owner != null;\n-    }\n-\n-    Collection getAttributesHolder() {\n-        return Collections.EMPTY_LIST;\n-    }\n-\n-    /**\n-     * Invalidate this attribute.\n-     */\n-    void invalidate() {\n-        _owner = null;\n-    }\n-\n-    /**\n-     * Return the length of the bytecode representation of this attribute\n-     * in bytes, excluding the name index.\n-     */\n-    int getLength() {\n-        return 0;\n-    }\n-\n-    /**\n-     * Copy the information from the given attribute to this one. Does\n-     * nothing by default.\n-     */\n-    void read(Attribute other) {\n-    }\n-\n-    /**\n-     * Read the attribute bytecode from the given stream, up to length\n-     * bytes, excluding the name index. Does nothing by default.\n-     */\n-    void read(DataInput in, int length) throws IOException {\n-    }\n-\n-    /**\n-     * Write the attribute bytecode to the given stream, up to length bytes,\n-     * excluding the name index. Does nothing by default.\n-     */\n-    void write(DataOutput out, int length) throws IOException {\n-    }\n-}"},{"sha":"b5e091ce10de2b73a55695ddcb558cb1bd08c893","filename":"serp/src/main/java/serp/bytecode/Attributes.java","status":"removed","additions":0,"deletions":199,"changes":199,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Attributes.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Attributes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Attributes.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,199 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import serp.bytecode.lowlevel.UTF8Entry;\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Abstract superclass for all bytecode entities that hold attributes.\n- *\n- * @author Abe White\n- */\n-public abstract class Attributes implements BCEntity {\n-\n-    /**\n-     * Return all the attributes owned by this entity.\n-     *\n-     * @return all owned attributes, or empty array if none\n-     */\n-    public Attribute[] getAttributes() {\n-        Collection attrs = getAttributesHolder();\n-        return (Attribute[]) attrs.toArray(new Attribute[attrs.size()]);\n-    }\n-\n-    /**\n-     * Return the attribute with the given name. If multiple attributes\n-     * share the name, which is returned is undefined.\n-     */\n-    public Attribute getAttribute(String name) {\n-        Collection attrs = getAttributesHolder();\n-        Attribute attr;\n-        for (Iterator itr = attrs.iterator(); itr.hasNext();) {\n-            attr = (Attribute) itr.next();\n-            if (attr.getName().equals(name))\n-                return attr;\n-        }\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Return all attributes with the given name.\n-     *\n-     * @return the matching attributes, or empty array if none\n-     */\n-    public Attribute[] getAttributes(String name) {\n-        List matches = new LinkedList();\n-\n-        Collection attrs = getAttributesHolder();\n-        Attribute attr;\n-        for (Iterator itr = attrs.iterator(); itr.hasNext();) {\n-            attr = (Attribute) itr.next();\n-            if (attr.getName().equals(name))\n-                matches.add(attr);\n-        }\n-        return (Attribute[]) matches.toArray(new Attribute[matches.size()]);\n-    }\n-\n-    /**\n-     * Set the attributes for this entity; this method is useful for importing\n-     * all attributes from another entity. Set to null or empty array if none.\n-     */\n-    public void setAttributes(Attribute[] attrs) {\n-        clearAttributes();\n-        if (attrs != null)\n-            for (int i = 0; i < attrs.length; i++)\n-                addAttribute(attrs[i]);\n-    }\n-\n-    /**\n-     * Import an attribute from another entity, or make a copy of one\n-     * on this entity.\n-     */\n-    public Attribute addAttribute(Attribute attr) {\n-        Attribute newAttr = addAttribute(attr.getName());\n-        newAttr.read(attr);\n-        return newAttr;\n-    }\n-\n-    /**\n-     * Add an attribute of the given type.\n-     */\n-    public Attribute addAttribute(String name) {\n-        Attribute attr = Attribute.create(name, this);\n-        getAttributesHolder().add(attr);\n-        return attr;\n-    }\n-\n-    /**\n-     * Clear all attributes from this entity.\n-     */\n-    public void clearAttributes() {\n-        Collection attrs = getAttributesHolder();\n-        Attribute attr;\n-        for (Iterator itr = attrs.iterator(); itr.hasNext();) {\n-            attr = (Attribute) itr.next();\n-            itr.remove();\n-            attr.invalidate();\n-        }\n-    }\n-\n-    /**\n-     * Remove all attributes with the given name from this entity.\n-     *\n-     * @return true if an attribute was removed, false otherwise\n-     */\n-    public boolean removeAttribute(String name) {\n-        return removeAttribute(getAttribute(name));\n-    }\n-\n-    /**\n-     * Remove the given attribute. After being removed, the attribute\n-     * is invalid, and the result of any operations on it are undefined.\n-     *\n-     * @return true if the attribute was removed, false otherwise\n-     */\n-    public boolean removeAttribute(Attribute attribute) {\n-        if (attribute == null || !getAttributesHolder().remove(attribute))\n-            return false;\n-        attribute.invalidate();\n-        return true;\n-    }\n-\n-    /**\n-     * Convenience method to be called by BCEntities when being visited\n-     * by a {@link BCVisitor}; this method will allow the visitor to visit all\n-     * attributes of this entity.\n-     */\n-    void visitAttributes(BCVisitor visit) {\n-        Attribute attr;\n-        for (Iterator itr = getAttributesHolder().iterator(); itr.hasNext();) {\n-            attr = (Attribute) itr.next();\n-            visit.enterAttribute(attr);\n-            attr.acceptVisit(visit);\n-            visit.exitAttribute(attr);\n-        }\n-    }\n-\n-    /**\n-     * Build the attribute list from the given stream.\n-     * Relies on the ability of attributes to read themselves, and\n-     * requires access to the constant pool, which must already by read.\n-     */\n-    void readAttributes(DataInput in) throws IOException {\n-        Collection attrs = getAttributesHolder();\n-        attrs.clear();\n-\n-        Attribute attribute;\n-        String name;\n-        for (int i = in.readUnsignedShort(); i > 0; i--) {\n-            name = ((UTF8Entry) getPool().getEntry(in.readUnsignedShort())).\n-                getValue();\n-            attribute = addAttribute(name);\n-            attribute.read(in, in.readInt());\n-        }\n-    }\n-\n-    /**\n-     * Writes all the owned attributes to the given stream.\n-     * Relies on the ability of attributes to write themselves.\n-     */\n-    void writeAttributes(DataOutput out) throws IOException {\n-        Collection attrs = getAttributesHolder();\n-        out.writeShort(attrs.size());\n-\n-        Attribute attribute;\n-        int length;\n-        for (Iterator itr = attrs.iterator(); itr.hasNext();) {\n-            attribute = (Attribute) itr.next();\n-            out.writeShort(attribute.getNameIndex());\n-            length = attribute.getLength();\n-            out.writeInt(length);\n-            attribute.write(out, length);\n-        }\n-    }\n-\n-    /**\n-     * Return the collection used to hold the attributes of this entity.\n-     */\n-    abstract Collection getAttributesHolder();\n-}"},{"sha":"4dbb01585ff17611f7d780c5dc18fdd455461b73","filename":"serp/src/main/java/serp/bytecode/BCClass.java","status":"removed","additions":0,"deletions":1672,"changes":1672,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCClass.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCClass.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,1672 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataInput;\n-import java.io.DataInputStream;\n-import java.io.DataOutput;\n-import java.io.DataOutputStream;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.net.URLDecoder;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import serp.bytecode.lowlevel.ClassEntry;\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.bytecode.visitor.VisitAcceptor;\n-import serp.util.Numbers;\n-import serp.util.Strings;\n-\n-/**\n- * The BCClass represents a class object in the bytecode framework, in many\n- * ways mirroring the {@link Class} class of Java reflection. The represented\n- * class might be a primitive, array, existing object type, or some new user-\n- * defined type. As with most entities in the bytecode framework, the BCClass\n- * contains methods to manipulate the low-level state of the class(constant\n- * pool indexes, etc), but these can and should be ignored in\n- * favor of the available high-level methods.\n- * A BCClass instance is loaded from a {@link Project} and remains\n- * attached to that project for its lifetime. If a BCClass is removed from\n- * its project, the result of any further operations on the class are undefined.\n- * Note that if a BCClass represents a primitive or array type, all of the\n- * available mutator methods and any methods that access the constant pool\n- * will throw {@link UnsupportedOperationException}s.\n- *\n- * @author Abe White\n- */\n-public class BCClass extends Attributes implements VisitAcceptor {\n-\n-    private Project _project = null;\n-    private State _state = null;\n-    private ClassLoader _loader = null;\n-\n-    /**\n-     * Hide constructor. For use by the owning project only.\n-     */\n-    BCClass(Project project) {\n-        _project = project;\n-    }\n-\n-    /**\n-     * Set the class state. For use by the owning project only.\n-     */\n-    void setState(State state) {\n-        _state = state;\n-    }\n-\n-    /**\n-     * Invalidate this class.\n-     */\n-    void invalidate() {\n-        _project = null;\n-        _state = State.INVALID;\n-    }\n-\n-    //////////////////\n-    // I/O operations\n-    //////////////////\n-\n-    /**\n-     * Initialize from the class definition in the given file. For use by\n-     * the owning project only.\n-     */\n-    void read(File classFile, ClassLoader loader) throws IOException {\n-        InputStream in = new FileInputStream(classFile);\n-        try {\n-            read(in, loader);\n-        } finally {\n-            in.close();\n-        }\n-    }\n-\n-    /**\n-     * Initialize from the class definition in the given stream. For use by\n-     * the owning project only.\n-     */\n-    void read(InputStream instream, ClassLoader loader) throws IOException {\n-        DataInput in = new DataInputStream(instream);\n-\n-        // header information\n-        _state.setMagic(in.readInt());\n-        _state.setMinorVersion(in.readUnsignedShort());\n-        _state.setMajorVersion(in.readUnsignedShort());\n-\n-        // constant pool\n-        _state.getPool().read(in);\n-\n-        // access flags\n-        _state.setAccessFlags(in.readUnsignedShort());\n-\n-        // class, super class, interfaces\n-        _state.setIndex(in.readUnsignedShort());\n-        _state.setSuperclassIndex(in.readUnsignedShort());\n-\n-        Collection interfaces = _state.getInterfacesHolder();\n-        interfaces.clear();\n-        int interfaceCount = in.readUnsignedShort();\n-        for (int i = 0; i < interfaceCount; i++)\n-            interfaces.add(Numbers.valueOf(in.readUnsignedShort()));\n-\n-        // fields\n-        Collection fields = _state.getFieldsHolder();\n-        fields.clear();\n-        int fieldCount = in.readUnsignedShort();\n-        BCField field;\n-        for (int i = 0; i < fieldCount; i++) {\n-            field = new BCField(this);\n-            fields.add(field);\n-            field.read(in);\n-        }\n-\n-        // methods\n-        Collection methods = _state.getMethodsHolder();\n-        methods.clear();\n-        int methodCount = in.readUnsignedShort();\n-        BCMethod method;\n-        for (int i = 0; i < methodCount; i++) {\n-            method = new BCMethod(this);\n-            methods.add(method);\n-            method.read(in);\n-        }\n-\n-        readAttributes(in);\n-        _loader = loader;\n-    }\n-\n-    /**\n-     * Initialize from the bytecode of the definition of the given class.\n-     * For use by the owning project only.\n-     */\n-    void read(Class type) throws IOException {\n-        // find out the length of the package name\n-        int dotIndex = type.getName().lastIndexOf('.') + 1;\n-\n-        // strip the package off of the class name\n-        String className = type.getName().substring(dotIndex);\n-\n-        // attempt to get the class file for the class as a stream\n-        InputStream in = type.getResourceAsStream(className + \".class\");\n-        try {\n-            read(in, type.getClassLoader());\n-        } finally {\n-            in.close();\n-        }\n-    }\n-\n-    /**\n-     * Initialize from the given parsed bytecode.\n-     * For use by the owning project only.\n-     */\n-    void read(BCClass orig) {\n-        try {\n-            ByteArrayInputStream in = new ByteArrayInputStream\n-                (orig.toByteArray());\n-            read(in, orig.getClassLoader());\n-            in.close();\n-        } catch (IOException ioe) {\n-            throw new RuntimeException(ioe.toString());\n-        }\n-    }\n-\n-    /**\n-     * Write the class bytecode to the .class file in the proper directory of\n-     * the CLASSPATH. The file must exist already, so this method only works\n-     * on existing classes.\n-     */\n-    public void write() throws IOException {\n-        String name = getName();\n-        int dotIndex = name.lastIndexOf('.') + 1;\n-        name = name.substring(dotIndex);\n-\n-        Class type = getType();\n-\n-        // attempt to get the class file for the class as a stream;\n-        // we need to use the url decoder in case the target directory\n-        // has spaces in it\n-        OutputStream out = new FileOutputStream(URLDecoder.decode\n-            (type.getResource(name + \".class\").getFile()));\n-        try {\n-            write(out);\n-        } finally {\n-            out.close();\n-        }\n-    }\n-\n-    /**\n-     * Write the class bytecode to the specified file.\n-     */\n-    public void write(File classFile) throws IOException {\n-        OutputStream out = new FileOutputStream(classFile);\n-        try {\n-            write(out);\n-        } finally {\n-            out.close();\n-        }\n-    }\n-\n-    /**\n-     * Write the class bytecode to the specified stream.\n-     */\n-    public void write(OutputStream outstream) throws IOException {\n-        DataOutput out = new DataOutputStream(outstream);\n-\n-        // header information\n-        out.writeInt(_state.getMagic());\n-        out.writeShort(_state.getMinorVersion());\n-        out.writeShort(_state.getMajorVersion());\n-\n-        // constant pool\n-        _state.getPool().write(out);\n-\n-        // access flags\n-        out.writeShort(_state.getAccessFlags());\n-\n-        // class, super class\n-        out.writeShort(_state.getIndex());\n-        out.writeShort(_state.getSuperclassIndex());\n-\n-        // interfaces\n-        Collection interfaces = _state.getInterfacesHolder();\n-        out.writeShort(interfaces.size());\n-        for (Iterator itr = interfaces.iterator(); itr.hasNext();)\n-            out.writeShort(((Number) itr.next()).intValue());\n-\n-        // fields\n-        Collection fields = _state.getFieldsHolder();\n-        out.writeShort(fields.size());\n-        for (Iterator itr = fields.iterator(); itr.hasNext();)\n-            ((BCField) itr.next()).write(out);\n-\n-        // methods\n-        Collection methods = _state.getMethodsHolder();\n-        out.writeShort(methods.size());\n-        for (Iterator itr = methods.iterator(); itr.hasNext();)\n-            ((BCMethod) itr.next()).write(out);\n-\n-        // attributes\n-        writeAttributes(out);\n-    }\n-\n-    /**\n-     * Return the bytecode of this class as a byte array, possibly for use\n-     * in a custom {@link ClassLoader}.\n-     */\n-    public byte[] toByteArray() {\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        try {\n-            write(out);\n-            out.flush();\n-            return out.toByteArray();\n-        } catch (IOException ioe) {\n-            throw new RuntimeException(ioe.toString());\n-        }\n-        finally {\n-            try {\n-                out.close();\n-            } catch (IOException ioe) {\n-            }\n-        }\n-    }\n-\n-    /////////////////////\n-    // Access operations\n-    /////////////////////\n-\n-    /**\n-     * Return the magic number for this class; if this is a valid type, this\n-     * should be equal to {@link Constants#VALID_MAGIC} (the default value).\n-     */\n-    public int getMagic() {\n-        return _state.getMagic();\n-    }\n-\n-    /**\n-     * Set the magic number for this class; if this is a valid type, this\n-     * should be equal to {@link Constants#VALID_MAGIC} (the default value).\n-     */\n-    public void setMagic(int magic) {\n-        _state.setMagic(magic);\n-    }\n-\n-    /**\n-     * Return the major version of the bytecode spec used for this class.\n-     * JVMs are only required to operate with versions that they understand;\n-     * leaving the default value of {@link Constants#MAJOR_VERSION} is safe.\n-     */\n-    public int getMajorVersion() {\n-        return _state.getMajorVersion();\n-    }\n-\n-    /**\n-     * Set the major version of the bytecode spec used for this class.\n-     * JVMs are only required to operate with versions that they understand;\n-     * leaving the default value of {@link Constants#MAJOR_VERSION} is safe.\n-     */\n-    public void setMajorVersion(int majorVersion) {\n-        _state.setMajorVersion(majorVersion);\n-    }\n-\n-    /**\n-     * Get the minor version of the bytecode spec used for this class.\n-     * JVMs are only required to operate with versions that they understand;\n-     * leaving the default value of {@link Constants#MINOR_VERSION} is safe.\n-     */\n-    public int getMinorVersion() {\n-        return _state.getMinorVersion();\n-    }\n-\n-    /**\n-     * Set the minor version of the bytecode spec used for this class.\n-     * JVMs are only required to operate with versions that they understand;\n-     * leaving the default value of {@link Constants#MINOR_VERSION} is safe.\n-     */\n-    public void setMinorVersion(int minorVersion) {\n-        _state.setMinorVersion(minorVersion);\n-    }\n-\n-    /**\n-     * Return the access flags for this class as a bit array of\n-     * ACCESS_XXX constants from {@link Constants}. This can be used to\n-     * transfer access flags between classes without getting/setting each\n-     * possible flag.\n-     */\n-    public int getAccessFlags() {\n-        return _state.getAccessFlags();\n-    }\n-\n-    /**\n-     * Set the access flags for this class as a bit array of\n-     * ACCESS_XXX constants from {@link Constants}. This can be used to\n-     * transfer access flags between classes without getting/setting each\n-     * possible flag.\n-     */\n-    public void setAccessFlags(int access) {\n-        _state.setAccessFlags(access);\n-    }\n-\n-    /**\n-     * Manipulate the class access flags.\n-     */\n-    public boolean isPublic() {\n-        return (getAccessFlags() & Constants.ACCESS_PUBLIC) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the class access flags.\n-     */\n-    public void makePublic() {\n-        setAccessFlags(getAccessFlags() | Constants.ACCESS_PUBLIC);\n-    }\n-\n-    /**\n-     * Manipulate the class access flags.\n-     */\n-    public boolean isPackage() {\n-        return !isPublic();\n-    }\n-\n-    /**\n-     * Manipulate the class access flags.\n-     */\n-    public void makePackage() {\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PUBLIC);\n-    }\n-\n-    /**\n-     * Manipulate the class access flags.\n-     */\n-    public boolean isFinal() {\n-        return (getAccessFlags() & Constants.ACCESS_FINAL) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the class access flags.\n-     */\n-    public void setFinal(boolean on) {\n-        if (on)\n-            setAccessFlags(getAccessFlags() | Constants.ACCESS_FINAL);\n-        else\n-            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_FINAL);\n-    }\n-\n-    /**\n-     * Manipulate the class access flags.\n-     */\n-    public boolean isInterface() {\n-        return (getAccessFlags() & Constants.ACCESS_INTERFACE) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the class access flags.\n-     */\n-    public void setInterface(boolean on) {\n-        if (on) {\n-            setAccessFlags(getAccessFlags() | Constants.ACCESS_INTERFACE);\n-            setAbstract(true);\n-        } else\n-            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_INTERFACE);\n-    }\n-\n-    /**\n-     * Manipulate the class access flags.\n-     */\n-    public boolean isAbstract() {\n-        return (getAccessFlags() & Constants.ACCESS_ABSTRACT) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the class access flags.\n-     */\n-    public void setAbstract(boolean on) {\n-        if (on)\n-            setAccessFlags(getAccessFlags() | Constants.ACCESS_ABSTRACT);\n-        else\n-            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_ABSTRACT);\n-    }\n-\n-    /**\n-     * Return true if this class is a primitive type.\n-     */\n-    public boolean isPrimitive() {\n-        return _state.isPrimitive();\n-    }\n-\n-    /**\n-     * Return true if this class is an array type.\n-     */\n-    public boolean isArray() {\n-        return _state.isArray();\n-    }\n-\n-    /////////////////////////\n-    // Class name operations\n-    /////////////////////////\n-\n-    /**\n-     * Return the {@link ConstantPool} index of the\n-     * {@link ClassEntry} for this class. Returns 0 if the class does not\n-     * have a constant pool(such as a primitive or array).\n-     */\n-    public int getIndex() {\n-        return _state.getIndex();\n-    }\n-\n-    /**\n-     * Set the {@link ConstantPool} index of the {@link ClassEntry} for this\n-     * class. Unlike most other low-level methods, the index\n-     * will be checked against the pool immediately;\n-     * classes must have a valid name at all times.\n-     */\n-    public void setIndex(int index) {\n-        String oldName = getName();\n-        String newName = ((ClassEntry) getPool().getEntry(index)).\n-            getNameEntry().getValue();\n-\n-        beforeRename(oldName, newName);\n-        _state.setIndex(index);\n-    }\n-\n-    /**\n-     * Return the name of this class, including package name. The name will\n-     * be in a form suitable for a {@link Class#forName} call.\n-     */\n-    public String getName() {\n-        return _state.getName();\n-    }\n-\n-    /**\n-     * Return the name of the class only, without package.\n-     */\n-    public String getClassName() {\n-        String name = _project.getNameCache(). getExternalForm(getName(), true);\n-        return name.substring(name.lastIndexOf('.') + 1);\n-    }\n-\n-    /**\n-     * Return the package name only, without class, or null if none.\n-     */\n-    public String getPackageName() {\n-        String name = _project.getNameCache(). getExternalForm(getName(), true);\n-        int index = name.lastIndexOf('.');\n-        if (index == -1)\n-            return null;\n-        return name.substring(0, index);\n-    }\n-\n-    /**\n-     * Set the name of this class, including package name.\n-     */\n-    public void setName(String name) {\n-        name = _project.getNameCache().getExternalForm(name, false);\n-        String oldName = getName();\n-\n-        // get a reference to the class entry for this class\n-        int index = getIndex();\n-        if (index == 0)\n-            index = getPool().findClassEntry(name, true);\n-        ClassEntry entry = (ClassEntry) getPool().getEntry(index);\n-\n-        // make sure the rename is ok with the project\n-        beforeRename(oldName, name);\n-\n-        // reset the name index of the class entry to the new name\n-        int nameIndex = getPool().findUTF8Entry(_project.getNameCache().\n-            getInternalForm(name, false), true);\n-        entry.setNameIndex(nameIndex);\n-\n-        // we might have just added a new entry; set the index\n-        _state.setIndex(index);\n-    }\n-\n-    /**\n-     * Return the {@link Class} object for this class, if it is loadable.\n-     */\n-    public Class getType() {\n-        return Strings.toClass(getName(), getClassLoader());\n-    }\n-\n-    /**\n-     * Return the component type name of this class, or null if not an array.\n-     * The name will be in a form suitable for a {@link Class#forName} call.\n-     */\n-    public String getComponentName() {\n-        return _state.getComponentName();\n-    }\n-\n-    /**\n-     * Return the component type of this class, or null if not an array.\n-     */\n-    public Class getComponentType() {\n-        String componentName = getComponentName();\n-        if (componentName == null)\n-            return null;\n-        return Strings.toClass(componentName, getClassLoader());\n-    }\n-\n-    /**\n-     * Return the component type of this class, or null if not an array.\n-     */\n-    public BCClass getComponentBC() {\n-        String componentName = getComponentName();\n-        if (componentName == null)\n-            return null;\n-        return getProject().loadClass(componentName, getClassLoader());\n-    }\n-\n-    /////////////////////////\n-    // Superclass operations\n-    /////////////////////////\n-\n-    /**\n-     * Return the {@link ConstantPool} index of the\n-     * {@link ClassEntry} for the superclass of this class. Returns -1 if\n-     * the class does not have a constant pool(such as a primitive or array).\n-     */\n-    public int getSuperclassIndex() {\n-        return _state.getSuperclassIndex();\n-    }\n-\n-    /**\n-     * Set the {@link ConstantPool} index of the\n-     * {@link ClassEntry} for the superclass of this class.\n-     */\n-    public void setSuperclassIndex(int index) {\n-        _state.setSuperclassIndex(index);\n-    }\n-\n-    /**\n-     * Return the name of the superclass for this class, including package\n-     * name. The name will be in a form suitable for a\n-     * {@link Class#forName} call, or null for types without superclasses.\n-     */\n-    public String getSuperclassName() {\n-        return _state.getSuperclassName();\n-    }\n-\n-    /**\n-     * Return the {@link Class} object for the superclass of this class, if it\n-     * is loadable. Returns null for types without superclasses.\n-     */\n-    public Class getSuperclassType() {\n-        String name = getSuperclassName();\n-        if (name == null)\n-            return null;\n-        return Strings.toClass(name, getClassLoader());\n-    }\n-\n-    /**\n-     * Return the bytecode of the superclass of this class, or\n-     * null for types without superclasses.\n-     */\n-    public BCClass getSuperclassBC() {\n-        String name = getSuperclassName();\n-        if (name == null)\n-            return null;\n-        return getProject().loadClass(name, getClassLoader());\n-    }\n-\n-    /**\n-     * Set the superclass of this class.\n-     */\n-    public void setSuperclass(String name) {\n-        if (name == null)\n-            setSuperclassIndex(0);\n-        else\n-            setSuperclassIndex(getPool().findClassEntry(_project.\n-                getNameCache().getInternalForm(name, false), true));\n-    }\n-\n-    /**\n-     * Set the superclass of this class.\n-     */\n-    public void setSuperclass(Class type) {\n-        if (type == null)\n-            setSuperclass((String) null);\n-        else\n-            setSuperclass(type.getName());\n-    }\n-\n-    /**\n-     * Set the superclass of this class.\n-     */\n-    public void setSuperclass(BCClass type) {\n-        if (type == null)\n-            setSuperclass((String) null);\n-        else\n-            setSuperclass(type.getName());\n-    }\n-\n-    ////////////////////////\n-    // Interface operations\n-    ////////////////////////\n-\n-    /**\n-     * Return the list of {@link ConstantPool} indexes of the\n-     * {@link ClassEntry}s describing all the interfaces this class declares\n-     * that it implements/extends.\n-     *\n-     * @return the implmented interfaces, or an empty array if none\n-     */\n-    public int[] getDeclaredInterfaceIndexes() {\n-        Collection interfaces = _state.getInterfacesHolder();\n-        int[] indexes = new int[interfaces.size()];\n-\n-        Iterator itr = interfaces.iterator();\n-        for (int i = 0, max = interfaces.size(); i < max; i++)\n-            indexes[i] = ((Number) itr.next()).intValue();\n-        return indexes;\n-    }\n-\n-    /**\n-     * Set the list of {@link ConstantPool} indexes of the\n-     * {@link ClassEntry}s describing all the interfaces this class declares\n-     * it implements/extends; set to null or an empty array if none.\n-     */\n-    public void setDeclaredInterfaceIndexes(int[] interfaceIndexes) {\n-        Collection stateIndexes = _state.getInterfacesHolder();\n-        stateIndexes.clear();\n-        for (int i = 0; i < interfaceIndexes.length; i++)\n-            stateIndexes.add(Numbers.valueOf(interfaceIndexes[i]));\n-    }\n-\n-    /**\n-     * Return the names of the interfaces declared for this class, including\n-     * package names, or an empty array if none. The names will be in a form\n-     * suitable for a {@link Class#forName} call.\n-     */\n-    public String[] getDeclaredInterfaceNames() {\n-        int[] indexes = getDeclaredInterfaceIndexes();\n-        String[] names = new String[indexes.length];\n-\n-        ClassEntry entry;\n-        for (int i = 0; i < indexes.length; i++) {\n-            entry = (ClassEntry) getPool().getEntry(indexes[i]);\n-            names[i] = _project.getNameCache().getExternalForm\n-                (entry.getNameEntry().getValue(), false);\n-        }\n-        return names;\n-    }\n-\n-    /**\n-     * Return the {@link Class} objects for the declared interfaces of this\n-     * class, or an empty array if none.\n-     */\n-    public Class[] getDeclaredInterfaceTypes() {\n-        String[] names = getDeclaredInterfaceNames();\n-        Class[] types = new Class[names.length];\n-\n-        for (int i = 0; i < names.length; i++)\n-            types[i] = Strings.toClass(names[i], getClassLoader());\n-        return types;\n-    }\n-\n-    /**\n-     * Return the bytecode for the declared interfaces of this class, or an\n-     * empty array if none.\n-     */\n-    public BCClass[] getDeclaredInterfaceBCs() {\n-        String[] names = getDeclaredInterfaceNames();\n-        BCClass[] types = new BCClass[names.length];\n-\n-        for (int i = 0; i < names.length; i++)\n-            types[i] = getProject().loadClass(names[i], getClassLoader());\n-        return types;\n-    }\n-\n-    /**\n-     * Set the interfaces declared implemented/extended by this class; set to\n-     * null or an empty array if none.\n-     */\n-    public void setDeclaredInterfaces(String[] interfaces) {\n-        clearDeclaredInterfaces();\n-        if (interfaces != null)\n-            for (int i = 0; i < interfaces.length; i++)\n-                declareInterface(interfaces[i]);\n-    }\n-\n-    /**\n-     * Set the interfaces declared implemented/extended by this class; set to\n-     * null or an empty array if none.\n-     */\n-    public void setDeclaredInterfaces(Class[] interfaces) {\n-        String[] names = null;\n-        if (interfaces != null) {\n-            names = new String[interfaces.length];\n-            for (int i = 0; i < interfaces.length; i++)\n-                names[i] = interfaces[i].getName();\n-        }\n-        setDeclaredInterfaces(names);\n-    }\n-\n-    /**\n-     * Set the interfaces declared implemented/extended by this class; set to\n-     * null or an empty array if none.\n-     */\n-    public void setDeclaredInterfaces(BCClass[] interfaces) {\n-        String[] names = null;\n-        if (interfaces != null) {\n-            names = new String[interfaces.length];\n-            for (int i = 0; i < interfaces.length; i++)\n-                names[i] = interfaces[i].getName();\n-        }\n-        setDeclaredInterfaces(names);\n-    }\n-\n-    /**\n-     * Return the names of all unique interfaces implemented by this class,\n-     * including those of all superclasses. The names will be returned in a\n-     * form suitable for a {@link Class#forName} call.\n-     * This method does not recurse into interfaces-of-interfaces.\n-     */\n-    public String[] getInterfaceNames() {\n-        Collection allNames = new LinkedList();\n-        String[] names;\n-        for (BCClass type = this; type != null; type = type.getSuperclassBC()) {\n-            names = type.getDeclaredInterfaceNames();\n-            for (int i = 0; i < names.length; i++)\n-                allNames.add(names[i]);\n-        }\n-        return (String[]) allNames.toArray(new String[allNames.size()]);\n-    }\n-\n-    /**\n-     * Return the {@link Class} objects of all unique interfaces implemented\n-     * by this class, including those of all superclasses.\n-     * This method does not recurse into interfaces-of-interfaces.\n-     */\n-    public Class[] getInterfaceTypes() {\n-        Collection allTypes = new LinkedList();\n-        Class[] types;\n-        for (BCClass type = this; type != null; type = type.getSuperclassBC()) {\n-            types = type.getDeclaredInterfaceTypes();\n-            for (int i = 0; i < types.length; i++)\n-                allTypes.add(types[i]);\n-        }\n-        return (Class[]) allTypes.toArray(new Class[allTypes.size()]);\n-    }\n-\n-    /**\n-     * Return the bytecode of all unique interfaces implemented by this class,\n-     * including those of all superclasses.\n-     * This method does not recurse into interfaces-of-interfaces.\n-     */\n-    public BCClass[] getInterfaceBCs() {\n-        Collection allTypes = new LinkedList();\n-        BCClass[] types;\n-        for (BCClass type = this; type != null; type = type.getSuperclassBC()) {\n-            types = type.getDeclaredInterfaceBCs();\n-            for (int i = 0; i < types.length; i++)\n-                allTypes.add(types[i]);\n-        }\n-        return (BCClass[]) allTypes.toArray(new BCClass[allTypes.size()]);\n-    }\n-\n-    /**\n-     * Clear this class of all interface declarations.\n-     */\n-    public void clearDeclaredInterfaces() {\n-        _state.getInterfacesHolder().clear();\n-    }\n-\n-    /**\n-     * Remove an interface declared by this class.\n-     *\n-     * @return true if the class had the interface, false otherwise\n-     */\n-    public boolean removeDeclaredInterface(String name) {\n-        String[] names = getDeclaredInterfaceNames();\n-        Iterator itr = _state.getInterfacesHolder().iterator();\n-        for (int i = 0; i < names.length; i++) {\n-            itr.next();\n-            if (names[i].equals(name)) {\n-                itr.remove();\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Remove an interface declared by this class.\n-     *\n-     * @return true if the class had the interface, false otherwise\n-     */\n-    public boolean removeDeclaredInterface(Class type) {\n-        if (type == null)\n-            return false;\n-        return removeDeclaredInterface(type.getName());\n-    }\n-\n-    /**\n-     * Remove an interface declared by this class.\n-     *\n-     * @return true if the class had the interface, false otherwise\n-     */\n-    public boolean removeDeclaredInterface(BCClass type) {\n-        if (type == null)\n-            return false;\n-        return removeDeclaredInterface(type.getName());\n-    }\n-\n-    /**\n-     * Add an interface to those declared by this class.\n-     */\n-    public void declareInterface(String name) {\n-        int index = getPool().findClassEntry(_project.getNameCache().\n-            getInternalForm(name, false), true);\n-        _state.getInterfacesHolder().add(Numbers.valueOf(index));\n-    }\n-\n-    /**\n-     * Add an interface to those declared by this class.\n-     */\n-    public void declareInterface(Class type) {\n-        declareInterface(type.getName());\n-    }\n-\n-    /**\n-     * Add an interface to those declared by this class.\n-     */\n-    public void declareInterface(BCClass type) {\n-        declareInterface(type.getName());\n-    }\n-\n-    /**\n-     * Return true if this class or any of its superclasses implement/extend\n-     * the given interface/class.\n-     * This method does not recurse into interfaces-of-interfaces.\n-     */\n-    public boolean isInstanceOf(String name) {\n-        name = _project.getNameCache().getExternalForm(name, false);\n-        String[] interfaces = getInterfaceNames();\n-        for (int i = 0; i < interfaces.length; i++)\n-            if (interfaces[i].equals(name))\n-                return true;\n-        for (BCClass type = this; type != null; type = type.getSuperclassBC())\n-            if (type.getName().equals(name))\n-                return true;\n-        return false;\n-    }\n-\n-    /**\n-     * Return true if this class or any of its superclasses implement/extend\n-     * the given interface/class.\n-     * This method does not recurse into interfaces-of-interfaces.\n-     */\n-    public boolean isInstanceOf(Class type) {\n-        if (type == null)\n-            return false;\n-        return isInstanceOf(type.getName());\n-    }\n-\n-    /**\n-     * Return true if this class or any of its superclasses implement/extend\n-     * the given interface/class.\n-     * This method does not recurse into interfaces-of-interfaces.\n-     */\n-    public boolean isInstanceOf(BCClass type) {\n-        if (type == null)\n-            return false;\n-        return isInstanceOf(type.getName());\n-    }\n-\n-    //////////////////////\n-    // Field operations\n-    //////////////////////\n-\n-    /**\n-     * Return all the declared fields of this class, or an empty array if none.\n-     */\n-    public BCField[] getDeclaredFields() {\n-        Collection fields = _state.getFieldsHolder();\n-        return (BCField[]) fields.toArray(new BCField[fields.size()]);\n-    }\n-\n-    /**\n-     * Return the declared field with the given name, or null if none.\n-     */\n-    public BCField getDeclaredField(String name) {\n-        BCField[] fields = getDeclaredFields();\n-        for (int i = 0; i < fields.length; i++)\n-            if (fields[i].getName().equals(name))\n-                return fields[i];\n-        return null;\n-    }\n-\n-    /**\n-     * Return all the fields of this class, including those of all\n-     * superclasses, or an empty array if none.\n-     */\n-    public BCField[] getFields() {\n-        Collection allFields = new LinkedList();\n-        BCField[] fields;\n-        for (BCClass type = this; type != null; type = type.getSuperclassBC()) {\n-            fields = type.getDeclaredFields();\n-            for (int i = 0; i < fields.length; i++)\n-                allFields.add(fields[i]);\n-        }\n-        return (BCField[]) allFields.toArray(new BCField[allFields.size()]);\n-    }\n-\n-    /**\n-     * Return all fields with the given name, including those of all\n-     * superclasses, or an empty array if none.\n-     */\n-    public BCField[] getFields(String name) {\n-        List matches = new LinkedList();\n-        BCField[] fields = getFields();\n-        for (int i = 0; i < fields.length; i++)\n-            if (fields[i].getName().equals(name))\n-                matches.add(fields[i]);\n-        return (BCField[]) matches.toArray(new BCField[matches.size()]);\n-    }\n-\n-    /**\n-     * Set the fields for this class; this method is useful for importing all\n-     * fields from another class. Set to null or empty array if none.\n-     */\n-    public void setDeclaredFields(BCField[] fields) {\n-        clearDeclaredFields();\n-        if (fields != null)\n-            for (int i = 0; i < fields.length; i++)\n-                declareField(fields[i]);\n-    }\n-\n-    /**\n-     * Import the information from given field as a new field in this class.\n-     *\n-     * @return the added field\n-     */\n-    public BCField declareField(BCField field) {\n-        BCField newField = declareField(field.getName(), field.getTypeName());\n-        newField.setAccessFlags(field.getAccessFlags());\n-        newField.setAttributes(field.getAttributes());\n-        return newField;\n-    }\n-\n-    /**\n-     * Add a field to this class.\n-     *\n-     * @return the added field\n-     */\n-    public BCField declareField(String name, String type) {\n-        BCField field = new BCField(this);\n-        _state.getFieldsHolder().add(field);\n-        field.initialize(name, _project.getNameCache().\n-            getInternalForm(type, true));\n-        return field;\n-    }\n-\n-    /**\n-     * Add a field to this class.\n-     *\n-     * @return the added field\n-     */\n-    public BCField declareField(String name, Class type) {\n-        String typeName = (type == null) ? null : type.getName();\n-        return declareField(name, typeName);\n-    }\n-\n-    /**\n-     * Add a field to this class.\n-     *\n-     * @return the added field\n-     */\n-    public BCField declareField(String name, BCClass type) {\n-        String typeName = (type == null) ? null : type.getName();\n-        return declareField(name, typeName);\n-    }\n-\n-    /**\n-     * Clear all fields from this class.\n-     */\n-    public void clearDeclaredFields() {\n-        Collection fields = _state.getFieldsHolder();\n-        BCField field;\n-        for (Iterator itr = fields.iterator(); itr.hasNext();) {\n-            field = (BCField) itr.next();\n-            itr.remove();\n-            field.invalidate();\n-        }\n-    }\n-\n-    /**\n-     * Remove a field from this class. After this method, the removed field\n-     * will be invalid, and the result of any operations on it is undefined.\n-     *\n-     * @return true if this class contained the field, false otherwise\n-     */\n-    public boolean removeDeclaredField(String name) {\n-        Collection fields = _state.getFieldsHolder();\n-        BCField field;\n-        for (Iterator itr = fields.iterator(); itr.hasNext();) {\n-            field = (BCField) itr.next();\n-            if (field.getName().equals(name)) {\n-                itr.remove();\n-                field.invalidate();\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Remove a field from this class. After this method, the removed field\n-     * will be invalid, and the result of any operations on it is undefined.\n-     *\n-     * @return true if this class contained the field, false otherwise\n-     */\n-    public boolean removeDeclaredField(BCField field) {\n-        if (field == null)\n-            return false;\n-        return removeDeclaredField(field.getName());\n-    }\n-\n-    //////////////////////\n-    // Method operations\n-    //////////////////////\n-\n-    /**\n-     * Return all methods declared by this class. Constructors and static\n-     * initializers are included.\n-     */\n-    public BCMethod[] getDeclaredMethods() {\n-        Collection methods = _state.getMethodsHolder();\n-        return (BCMethod[]) methods.toArray(new BCMethod[methods.size()]);\n-    }\n-\n-    /**\n-     * Return the declared method with the given name, or null if none.\n-     * If multiple methods are declared with the given name, which is returned\n-     * is undefined.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     */\n-    public BCMethod getDeclaredMethod(String name) {\n-        BCMethod[] methods = getDeclaredMethods();\n-        for (int i = 0; i < methods.length; i++)\n-            if (methods[i].getName().equals(name))\n-                return methods[i];\n-        return null;\n-    }\n-\n-    /**\n-     * Return all the declared methods with the given name, or an empty array\n-     * if none.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     */\n-    public BCMethod[] getDeclaredMethods(String name) {\n-        Collection matches = new LinkedList();\n-        BCMethod[] methods = getDeclaredMethods();\n-        for (int i = 0; i < methods.length; i++)\n-            if (methods[i].getName().equals(name))\n-                matches.add(methods[i]);\n-        return (BCMethod[]) matches.toArray(new BCMethod[matches.size()]);\n-    }\n-\n-    /**\n-     * Return the declared method with the given name and parameter types,\n-     * or null if none.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     */\n-    public BCMethod getDeclaredMethod(String name, String[] paramTypes) {\n-        if (paramTypes == null)\n-            paramTypes = new String[0];\n-\n-        String[] curParams;\n-        boolean match;\n-        BCMethod[] methods = getDeclaredMethods();\n-        for (int i = 0; i < methods.length; i++) {\n-            if (methods[i].getName().equals(name)) {\n-                curParams = methods[i].getParamNames();\n-                if (curParams.length != paramTypes.length)\n-                    continue;\n-\n-                match = true;\n-                for (int j = 0; j < paramTypes.length; j++) {\n-                    if (!curParams[j].equals(_project.getNameCache().\n-                        getExternalForm(paramTypes[j], false))) {\n-                        match = false;\n-                        break;\n-                    }\n-                }\n-\n-                if (match)\n-                    return methods[i];\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Return the declared method with the given name and parameter types,\n-     * or null if none.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     */\n-    public BCMethod getDeclaredMethod(String name, Class[] paramTypes) {\n-        if (paramTypes == null)\n-            return getDeclaredMethod(name, (String[]) null);\n-\n-        String[] paramNames = new String[paramTypes.length];\n-        for (int i = 0; i < paramTypes.length; i++)\n-            paramNames[i] = paramTypes[i].getName();\n-        return getDeclaredMethod(name, paramNames);\n-    }\n-\n-    /**\n-     * Return the declared method with the given name and parameter types,\n-     * or null if none.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     */\n-    public BCMethod getDeclaredMethod(String name, BCClass[] paramTypes) {\n-        if (paramTypes == null)\n-            return getDeclaredMethod(name, (String[]) null);\n-\n-        String[] paramNames = new String[paramTypes.length];\n-        for (int i = 0; i < paramTypes.length; i++)\n-            paramNames[i] = paramTypes[i].getName();\n-        return getDeclaredMethod(name, paramNames);\n-    }\n-\n-    /**\n-     * Return the methods of this class, including those of all superclasses,\n-     * or an empty array if none.\n-     * The base version of methods that are overridden will be included, as\n-     * will all constructors and static initializers.\n-     * The methods will be ordered from those in the most-specific type up to\n-     * those in {@link Object}.\n-     */\n-    public BCMethod[] getMethods() {\n-        Collection allMethods = new LinkedList();\n-        BCMethod[] methods;\n-        for (BCClass type = this; type != null; type = type.getSuperclassBC()) {\n-            methods = type.getDeclaredMethods();\n-            for (int i = 0; i < methods.length; i++)\n-                allMethods.add(methods[i]);\n-        }\n-        return (BCMethod[]) allMethods.toArray(new BCMethod[allMethods.size()]);\n-    }\n-\n-    /**\n-     * Return the methods with the given name, including those of all\n-     * superclasses, or an empty array if none.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     */\n-    public BCMethod[] getMethods(String name) {\n-        Collection matches = new LinkedList();\n-        BCMethod[] methods = getMethods();\n-        for (int i = 0; i < methods.length; i++)\n-            if (methods[i].getName().equals(name))\n-                matches.add(methods[i]);\n-        return (BCMethod[]) matches.toArray(new BCMethod[matches.size()]);\n-    }\n-\n-    /**\n-     * Return the methods with the given name and parameter types, including\n-     * those of all superclasses, or an empty array if none.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     */\n-    public BCMethod[] getMethods(String name, String[] paramTypes) {\n-        if (paramTypes == null)\n-            paramTypes = new String[0];\n-\n-        String[] curParams;\n-        boolean match;\n-        BCMethod[] methods = getMethods();\n-        Collection matches = new LinkedList();\n-        for (int i = 0; i < methods.length; i++) {\n-            if (methods[i].getName().equals(name)) {\n-                curParams = methods[i].getParamNames();\n-                if (curParams.length != paramTypes.length)\n-                    continue;\n-\n-                match = true;\n-                for (int j = 0; j < paramTypes.length; j++) {\n-                    if (!curParams[j].equals(_project.getNameCache().\n-                        getExternalForm(paramTypes[j], false))) {\n-                        match = false;\n-                        break;\n-                    }\n-                }\n-\n-                if (match)\n-                    matches.add(methods[i]);\n-            }\n-        }\n-        return (BCMethod[]) matches.toArray(new BCMethod[matches.size()]);\n-    }\n-\n-    /**\n-     * Return the methods with the given name and parameter types, including\n-     * those of all superclasses, or an empty array if none.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     */\n-    public BCMethod[] getMethods(String name, Class[] paramTypes) {\n-        if (paramTypes == null)\n-            return getMethods(name, (String[]) null);\n-\n-        String[] paramNames = new String[paramTypes.length];\n-        for (int i = 0; i < paramTypes.length; i++)\n-            paramNames[i] = paramTypes[i].getName();\n-        return getMethods(name, paramNames);\n-    }\n-\n-    /**\n-     * Return the methods with the given name and parameter types, including\n-     * those of all superclasses, or an empty array if none.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     */\n-    public BCMethod[] getMethods(String name, BCClass[] paramTypes) {\n-        if (paramTypes == null)\n-            return getMethods(name, (String[]) null);\n-\n-        String[] paramNames = new String[paramTypes.length];\n-        for (int i = 0; i < paramTypes.length; i++)\n-            paramNames[i] = paramTypes[i].getName();\n-        return getMethods(name, paramNames);\n-    }\n-\n-    /**\n-     * Set the methods for this class; this method is useful for importing all\n-     * methods from another class. Set to null or empty array if none.\n-     */\n-    public void setDeclaredMethods(BCMethod[] methods) {\n-        clearDeclaredMethods();\n-        if (methods != null)\n-            for (int i = 0; i < methods.length; i++)\n-                declareMethod(methods[i]);\n-    }\n-\n-    /**\n-     * Import the information in the given method as a new method of this class.\n-     *\n-     * @return the added method\n-     */\n-    public BCMethod declareMethod(BCMethod method) {\n-        BCMethod newMethod = declareMethod(method.getName(),\n-            method.getReturnName(), method.getParamNames());\n-        newMethod.setAccessFlags(method.getAccessFlags());\n-        newMethod.setAttributes(method.getAttributes());\n-        return newMethod;\n-    }\n-\n-    /**\n-     * Add a method to this class.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     *\n-     * @return the added method\n-     */\n-    public BCMethod declareMethod(String name, String returnType,\n-        String[] paramTypes) {\n-        BCMethod method = new BCMethod(this);\n-        _state.getMethodsHolder().add(method);\n-        method.initialize(name, _project.getNameCache().getDescriptor\n-            (returnType, paramTypes));\n-        return method;\n-    }\n-\n-    /**\n-     * Add a method to this class.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     *\n-     * @return the added method\n-     */\n-    public BCMethod declareMethod(String name, Class returnType,\n-        Class[] paramTypes) {\n-        String[] paramNames = null;\n-        if (paramTypes != null) {\n-            paramNames = new String[paramTypes.length];\n-            for (int i = 0; i < paramTypes.length; i++)\n-                paramNames[i] = paramTypes[i].getName();\n-        }\n-        String returnName = (returnType == null) ? null : returnType.getName();\n-        return declareMethod(name, returnName, paramNames);\n-    }\n-\n-    /**\n-     * Add a method to this class.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     *\n-     * @return the added method\n-     */\n-    public BCMethod declareMethod(String name, BCClass returnType,\n-        BCClass[] paramTypes) {\n-        String[] paramNames = null;\n-        if (paramTypes != null) {\n-            paramNames = new String[paramTypes.length];\n-            for (int i = 0; i < paramTypes.length; i++)\n-                paramNames[i] = paramTypes[i].getName();\n-        }\n-        String returnName = (returnType == null) ? null : returnType.getName();\n-        return declareMethod(name, returnName, paramNames);\n-    }\n-\n-    /**\n-     * Clear all declared methods from this class.\n-     */\n-    public void clearDeclaredMethods() {\n-        Collection methods = _state.getMethodsHolder();\n-        BCMethod method;\n-        for (Iterator itr = methods.iterator(); itr.hasNext();) {\n-            method = (BCMethod) itr.next();\n-            itr.remove();\n-            method.invalidate();\n-        }\n-    }\n-\n-    /**\n-     * Remove a method from this class. After this method, the removed method\n-     * will be invalid, and the result of any operations on it is undefined.\n-     * If multiple methods match the given name, which is removed is undefined.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     *\n-     * @return true if this class contained the method, false otherwise\n-     */\n-    public boolean removeDeclaredMethod(String name) {\n-        Collection methods = _state.getMethodsHolder();\n-        BCMethod method;\n-        for (Iterator itr = methods.iterator(); itr.hasNext();) {\n-            method = (BCMethod) itr.next();\n-            if (method.getName().equals(name)) {\n-                itr.remove();\n-                method.invalidate();\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Removes a method from this class. After this method, the removed method\n-     * will be invalid, and the result of any operations on it is undefined.\n-     *\n-     * @return true if this class contained the method, false otherwise\n-     */\n-    public boolean removeDeclaredMethod(BCMethod method) {\n-        if (method == null)\n-            return false;\n-        return removeDeclaredMethod(method.getName(), method.getParamNames());\n-    }\n-\n-    /**\n-     * Removes a method from this class. After this method, the removed method\n-     * will be invalid, and the result of any operations on it is undefined.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     *\n-     * @return true if this class contained the method, false otherwise\n-     */\n-    public boolean removeDeclaredMethod(String name, String[] paramTypes) {\n-        if (paramTypes == null)\n-            paramTypes = new String[0];\n-\n-        String[] curParams;\n-        boolean match;\n-        Collection methods = _state.getMethodsHolder();\n-        BCMethod method;\n-        for (Iterator itr = methods.iterator(); itr.hasNext();) {\n-            method = (BCMethod) itr.next();\n-            if (method.getName().equals(name)) {\n-                curParams = method.getParamNames();\n-                if (curParams.length != paramTypes.length)\n-                    continue;\n-\n-                match = true;\n-                for (int j = 0; j < paramTypes.length; j++) {\n-                    if (!curParams[j].equals(_project.getNameCache().\n-                        getExternalForm(paramTypes[j], false))) {\n-                        match = false;\n-                        break;\n-                    }\n-                }\n-\n-                if (match) {\n-                    itr.remove();\n-                    method.invalidate();\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Removes a method from this class. After this method, the removed method\n-     * will be invalid, and the result of any operations on it is undefined.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     *\n-     * @return true if this class contained the method, false otherwise\n-     */\n-    public boolean removeDeclaredMethod(String name, Class[] paramTypes) {\n-        if (paramTypes == null)\n-            return removeDeclaredMethod(name, (String[]) null);\n-\n-        String[] paramNames = new String[paramTypes.length];\n-        for (int i = 0; i < paramTypes.length; i++)\n-            paramNames[i] = paramTypes[i].getName();\n-        return removeDeclaredMethod(name, paramNames);\n-    }\n-\n-    /**\n-     * Removes a method from this class. After this method, the removed method\n-     * will be invalid, and the result of any operations on it is undefined.\n-     * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n-     * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     *\n-     * @return true if this class contained the method, false otherwise\n-     */\n-    public boolean removeDeclaredMethod(String name, BCClass[] paramTypes) {\n-        if (paramTypes == null)\n-            return removeDeclaredMethod(name, (String[]) null);\n-\n-        String[] paramNames = new String[paramTypes.length];\n-        for (int i = 0; i < paramTypes.length; i++)\n-            paramNames[i] = paramTypes[i].getName();\n-        return removeDeclaredMethod(name, paramNames);\n-    }\n-\n-    ///////////////////////\n-    // Convenience methods\n-    ///////////////////////\n-\n-    /**\n-     * Convenience method to add a default constructor to this class.\n-     * If a default constructor already exists, this method will return it\n-     * without modification.\n-     * This method can only be called if the superclass has been set.\n-     *\n-     * @return the default constructor\n-     */\n-    public BCMethod addDefaultConstructor() {\n-        BCMethod method = getDeclaredMethod(\"<init>\", (String[]) null);\n-        if (method != null)\n-            return method;\n-\n-        method = declareMethod(\"<init>\", void.class, null);\n-        Code code = method.getCode(true);\n-        code.setMaxStack(1);\n-        code.setMaxLocals(1);\n-\n-        code.xload().setThis();\n-        code.invokespecial().setMethod(getSuperclassName(), \"<init>\",\n-            \"void\", null);\n-        code.vreturn();\n-        return method;\n-    }\n-\n-    /**\n-     * Return source file information for the class.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @param add if true, a new source file attribute will be added\n-     * if not already present\n-     * @return the source file information, or null if none and the\n-     *         <code>add</code> param is set to false\n-     */\n-    public SourceFile getSourceFile(boolean add) {\n-        SourceFile source = (SourceFile) getAttribute(Constants.ATTR_SOURCE);\n-        if (!add || source != null)\n-            return source;\n-        return (SourceFile) addAttribute(Constants.ATTR_SOURCE);\n-    }\n-\n-    /**\n-     * Remove the source file attribute for the class.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @return true if there was a file to remove\n-     */\n-    public boolean removeSourceFile() {\n-        return removeAttribute(Constants.ATTR_SOURCE);\n-    }\n-\n-    /**\n-     * Return inner classes information for the class.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @param add if true, a new inner classes attribute will be added\n-     * if not already present\n-     * @return the inner classes information, or null if none and the\n-     *         <code>add</code> param is set to false\n-     */\n-    public InnerClasses getInnerClasses(boolean add) {\n-        InnerClasses inner = (InnerClasses) getAttribute\n-            (Constants.ATTR_INNERCLASS);\n-        if (!add || inner != null)\n-            return inner;\n-        return (InnerClasses) addAttribute(Constants.ATTR_INNERCLASS);\n-    }\n-\n-    /**\n-     * Remove the inner classes attribute for the class.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @return true if there was an attribute to remove\n-     */\n-    public boolean removeInnerClasses() {\n-        return removeAttribute(Constants.ATTR_INNERCLASS);\n-    }\n-\n-    /**\n-     * Convenience method to return deprecation information for the class.\n-     * Acts internally through the {@link Attributes} interface.\n-     */\n-    public boolean isDeprecated() {\n-        return getAttribute(Constants.ATTR_DEPRECATED) != null;\n-    }\n-\n-    /**\n-     * Convenience method to set whether this class should be considered\n-     * deprecated. Acts internally through the {@link Attributes} interface.\n-     */\n-    public void setDeprecated(boolean on) {\n-        if (!on)\n-            removeAttribute(Constants.ATTR_DEPRECATED);\n-        else if (!isDeprecated())\n-            addAttribute(Constants.ATTR_DEPRECATED);\n-    }\n-\n-    ///////////////////////////////////\n-    // Implementation of VisitAcceptor\n-    ///////////////////////////////////\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterBCClass(this);\n-\n-        ConstantPool pool = null;\n-        try {\n-            pool = _state.getPool();\n-        } catch (UnsupportedOperationException uoe) {\n-        }\n-        if (pool != null)\n-            pool.acceptVisit(visit);\n-\n-        BCField[] fields = getDeclaredFields();\n-        for (int i = 0; i < fields.length; i++) {\n-            visit.enterBCMember(fields[i]);\n-            fields[i].acceptVisit(visit);\n-            visit.exitBCMember(fields[i]);\n-        }\n-\n-        BCMethod[] methods = getDeclaredMethods();\n-        for (int i = 0; i < methods.length; i++) {\n-            visit.enterBCMember(methods[i]);\n-            methods[i].acceptVisit(visit);\n-            visit.exitBCMember(methods[i]);\n-        }\n-\n-        visitAttributes(visit);\n-        visit.exitBCClass(this);\n-    }\n-\n-    ////////////////////////////////\n-    // Implementation of Attributes\n-    ////////////////////////////////\n-\n-    public Project getProject() {\n-        return _project;\n-    }\n-\n-    public ConstantPool getPool() {\n-        return _state.getPool();\n-    }\n-\n-    public ClassLoader getClassLoader() {\n-        if (_loader != null)\n-            return _loader;\n-\n-        return Thread.currentThread().getContextClassLoader();\n-    }\n-\n-    public boolean isValid() {\n-        return _project != null;\n-    }\n-\n-    Collection getAttributesHolder() {\n-        return _state.getAttributesHolder();\n-    }\n-\n-    /**\n-     * Attempts to change the class name with the owning project. The project\n-     * can reject the change if a class with the given new name already\n-     * exists; therefore this method should be called before the change is\n-     * recorded in the class.\n-     */\n-    private void beforeRename(String oldName, String newName) {\n-        if (_project != null && oldName != null)\n-            _project.renameClass(oldName, newName, this);\n-    }\n-}"},{"sha":"491793cc2af5dc6b3abed6b4b1d46e0fbafb6d7d","filename":"serp/src/main/java/serp/bytecode/BCClassLoader.java","status":"removed","additions":0,"deletions":74,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCClassLoader.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCClassLoader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCClassLoader.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,74 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-/**\n- * Class loader that will attempt to find requested classes in a given\n- * {@link Project}.\n- *\n- * @author Abe White\n- */\n-public class BCClassLoader extends ClassLoader {\n-\n-    private Project _project = null;\n-\n-    /**\n-     * Constructor. Supply the project to use when looking for classes.\n-     */\n-    public BCClassLoader(Project project) {\n-        _project = project;\n-    }\n-\n-    /**\n-     * Constructor. Supply the project to use when looking for classes.\n-     *\n-     * @param parent the parent classoader\n-     */\n-    public BCClassLoader(Project project, ClassLoader loader) {\n-        super(loader);\n-        _project = project;\n-    }\n-\n-    /**\n-     * Return this class loader's project.\n-     */\n-    public Project getProject() {\n-        return _project;\n-    }\n-\n-    protected Class findClass(String name) throws ClassNotFoundException {\n-        byte[] bytes;\n-        try {\n-            BCClass type;\n-            if (!_project.containsClass(name))\n-                type = createClass(name);\n-            else\n-                type = _project.loadClass(name);\n-            if (type == null)\n-                throw new ClassNotFoundException(name);\n-\n-            bytes = type.toByteArray();\n-        } catch (RuntimeException re) {\n-            throw new ClassNotFoundException(re.toString());\n-        }\n-        return defineClass(name, bytes, 0, bytes.length);\n-    }\n-\n-    /**\n-     * Override this method if unfound classes should be created on-the-fly.\n-     * Returns null by default.\n-     */\n-    protected BCClass createClass(String name) {\n-        return null;\n-    }\n-}"},{"sha":"ff5e6da90985b53426368220e2e5ab04ca0f5f64","filename":"serp/src/main/java/serp/bytecode/BCEntity.java","status":"removed","additions":0,"deletions":45,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCEntity.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCEntity.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,45 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.lowlevel.ConstantPool;\n-\n-/**\n- * Interface implemented by all bytecode entities. Entities must be able\n- * to access the project, constant pool, and class loader of the current class.\n- *\n- * @author Abe White\n- */\n-public interface BCEntity {\n-\n-    /**\n-     * Return the project of the current class.\n-     */\n-    public Project getProject();\n-\n-    /**\n-     * Return the constant pool of the current class.\n-     */\n-    public ConstantPool getPool();\n-\n-    /**\n-     * Return the class loader to use when loading related classes.\n-     */\n-    public ClassLoader getClassLoader();\n-\n-    /**\n-     * Return false if this entity has been removed from its parent; in this\n-     * case the results of any operations on the entity are undefined.\n-     */\n-    public boolean isValid();\n-}"},{"sha":"fe33dd0580d42a6da29d7cb081124c36b0bded55","filename":"serp/src/main/java/serp/bytecode/BCField.java","status":"removed","additions":0,"deletions":156,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCField.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCField.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCField.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,156 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.bytecode.visitor.VisitAcceptor;\n-import serp.util.Strings;\n-\n-/**\n- * A field of a class.\n- *\n- * @author Abe White\n- */\n-public class BCField extends BCMember implements VisitAcceptor {\n-\n-    BCField(BCClass owner) {\n-        super(owner);\n-    }\n-\n-    /**\n-     * Manipulate the field access flags.\n-     */\n-    public boolean isVolatile() {\n-        return (getAccessFlags() & Constants.ACCESS_VOLATILE) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the field access flags.\n-     */\n-    public void setVolatile(boolean on) {\n-        if (on)\n-            setAccessFlags(getAccessFlags() | Constants.ACCESS_VOLATILE);\n-        else\n-            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_VOLATILE);\n-    }\n-\n-    /**\n-     * Manipulate the field access flags.\n-     */\n-    public boolean isTransient() {\n-        return (getAccessFlags() & Constants.ACCESS_TRANSIENT) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the field access flags.\n-     */\n-    public void setTransient(boolean on) {\n-        if (on)\n-            setAccessFlags(getAccessFlags() | Constants.ACCESS_TRANSIENT);\n-        else\n-            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_TRANSIENT);\n-    }\n-\n-    /**\n-     * Return the name of the type of this field. The name will be given in\n-     * a form suitable for a {@link Class#forName} call.\n-     *\n-     * @see BCMember#getDescriptor\n-     */\n-    public String getTypeName() {\n-        return getProject().getNameCache().getExternalForm\n-            (getDescriptor(), false);\n-    }\n-\n-    /**\n-     * Return the {@link Class} object for the type of this field.\n-     */\n-    public Class getType() {\n-        return Strings.toClass(getTypeName(), getClassLoader());\n-    }\n-\n-    /**\n-     * Return the bytecode for the type of this field.\n-     */\n-    public BCClass getTypeBC() {\n-        return getProject().loadClass(getTypeName(), getClassLoader());\n-    }\n-\n-    /**\n-     * Set the name of the type of this field.\n-     *\n-     * @see BCMember#setDescriptor\n-     */\n-    public void setType(String type) {\n-        setDescriptor(type);\n-    }\n-\n-    /**\n-     * Set the type of this field.\n-     *\n-     * @see BCMember#setDescriptor\n-     */\n-    public void setType(Class type) {\n-        setType(type.getName());\n-    }\n-\n-    /**\n-     * Set the type of this field.\n-     *\n-     * @see BCMember#setDescriptor\n-     */\n-    public void setType(BCClass type) {\n-        setType(type.getName());\n-    }\n-\n-    /**\n-     * Return the constant value information for the field.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @param add if true, a new constant value attribute will be added\n-     * if not already present\n-     * @return the constant value information, or null if none and the\n-     *         <code>add</code> param is set to false\n-     */\n-    public ConstantValue getConstantValue(boolean add) {\n-        ConstantValue constant = (ConstantValue) getAttribute\n-            (Constants.ATTR_CONST);\n-        if (!add || constant != null)\n-            return constant;\n-\n-        if (constant == null)\n-            constant = (ConstantValue) addAttribute(Constants.ATTR_CONST);\n-        return constant;\n-    }\n-\n-    /**\n-     * Remove the constant value attribute for the field.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @return true if there was a value to remove\n-     */\n-    public boolean removeConstantValue() {\n-        return removeAttribute(Constants.ATTR_CONST);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterBCField(this);\n-        visitAttributes(visit);\n-        visit.exitBCField(this);\n-    }\n-\n-    void initialize(String name, String descriptor) {\n-        super.initialize(name, descriptor);\n-        makePrivate();\n-    }\n-}"},{"sha":"d8719da8f13102772c7bf3c59725e7a3b8972cb7","filename":"serp/src/main/java/serp/bytecode/BCMember.java","status":"removed","additions":0,"deletions":392,"changes":392,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCMember.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCMember.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCMember.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,392 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-\n-import serp.bytecode.lowlevel.ComplexEntry;\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.bytecode.lowlevel.UTF8Entry;\n-\n-/**\n- * A member field or method of a class.\n- *\n- * @author Abe White\n- */\n-public abstract class BCMember extends Attributes {\n-\n-    private BCClass _owner = null;\n-    private int _access = Constants.ACCESS_PRIVATE;\n-    private int _nameIndex = 0;\n-    private int _descriptorIndex = 0;\n-    private Collection _attrs = new LinkedList();\n-\n-    BCMember(BCClass owner) {\n-        _owner = owner;\n-    }\n-\n-    /**\n-     * Return the {@link BCClass} that declares this member.\n-     */\n-    public BCClass getDeclarer() {\n-        return _owner;\n-    }\n-\n-    /////////////////////\n-    // Access operations\n-    /////////////////////\n-\n-    /**\n-     * Return the access flags for this member as a bit array of\n-     * ACCESS_XXX constants from {@link Constants}. This can be used to\n-     * transfer access flags between members without getting/setting each\n-     * possible access flag. Defaults to {@link Constants#ACCESS_PRIVATE}\n-     */\n-    public int getAccessFlags() {\n-        return _access;\n-    }\n-\n-    /**\n-     * Set the access flags for this member as a bit array of\n-     * ACCESS_XXX constants from {@link Constants}. This can be used to\n-     * transfer access flags between members without getting/setting each\n-     * possible access flag. Defaults to {@link Constants#ACCESS_PRIVATE}\n-     */\n-    public void setAccessFlags(int access) {\n-        _access = access;\n-    }\n-\n-    /**\n-     * Manipulate the member access flags.\n-     */\n-    public boolean isPublic() {\n-        return (getAccessFlags() & Constants.ACCESS_PUBLIC) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the member access flags.\n-     */\n-    public void makePublic() {\n-        setAccessFlags(getAccessFlags() | Constants.ACCESS_PUBLIC);\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PRIVATE);\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PROTECTED);\n-    }\n-\n-    /**\n-     * Manipulate the member access flags.\n-     */\n-    public boolean isProtected() {\n-        return (getAccessFlags() & Constants.ACCESS_PROTECTED) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the member access flags.\n-     */\n-    public void makeProtected() {\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PUBLIC);\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PRIVATE);\n-        setAccessFlags(getAccessFlags() | Constants.ACCESS_PROTECTED);\n-    }\n-\n-    /**\n-     * Manipulate the member access flags.\n-     */\n-    public boolean isPrivate() {\n-        return (getAccessFlags() & Constants.ACCESS_PRIVATE) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the member access flags.\n-     */\n-    public void makePrivate() {\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PUBLIC);\n-        setAccessFlags(getAccessFlags() | Constants.ACCESS_PRIVATE);\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PROTECTED);\n-    }\n-\n-    /**\n-     * Manipulate the member access flags.\n-     */\n-    public boolean isPackage() {\n-        boolean hasAccess = false;\n-        hasAccess = hasAccess\n-            || (getAccessFlags() & Constants.ACCESS_PRIVATE) > 0;\n-        hasAccess = hasAccess\n-            || (getAccessFlags() & Constants.ACCESS_PROTECTED) > 0;\n-        hasAccess = hasAccess\n-            || (getAccessFlags() & Constants.ACCESS_PUBLIC) > 0;\n-        return !hasAccess;\n-    }\n-\n-    /**\n-     * Manipulate the member access flags.\n-     */\n-    public void makePackage() {\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PUBLIC);\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PRIVATE);\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PROTECTED);\n-    }\n-\n-    /**\n-     * Manipulate the member access flags.\n-     */\n-    public boolean isFinal() {\n-        return (getAccessFlags() & Constants.ACCESS_FINAL) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the member access flags.\n-     */\n-    public void setFinal(boolean on) {\n-        if (on)\n-            setAccessFlags(getAccessFlags() | Constants.ACCESS_FINAL);\n-        else\n-            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_FINAL);\n-    }\n-\n-    /**\n-     * Manipulate the member access flags.\n-     */\n-    public boolean isStatic() {\n-        return (getAccessFlags() & Constants.ACCESS_STATIC) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the member access flags.\n-     */\n-    public void setStatic(boolean on) {\n-        if (on)\n-            setAccessFlags(getAccessFlags() | Constants.ACCESS_STATIC);\n-        else\n-            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_STATIC);\n-    }\n-\n-    /////////////////////////\n-    // Descriptor operations\n-    /////////////////////////\n-\n-    /**\n-     * Return the index in the class {@link ConstantPool} of the\n-     * {@link UTF8Entry} holding the name of this member.\n-     */\n-    public int getNameIndex() {\n-        return _nameIndex;\n-    }\n-\n-    /**\n-     * Set the index in the class {@link ConstantPool} of the\n-     * {@link UTF8Entry} holding the name of this member.\n-     */\n-    public void setNameIndex(int index) {\n-        String origName = getName();\n-        _nameIndex = index;\n-\n-        // change all the references in the owning class\n-        setEntry(origName, getDescriptor());\n-    }\n-\n-    /**\n-     * Return the index in the class {@link ConstantPool} of the\n-     * {@link UTF8Entry} holding the descriptor of this member.\n-     */\n-    public int getDescriptorIndex() {\n-        return _descriptorIndex;\n-    }\n-\n-    /**\n-     * Set the index in the class {@link ConstantPool} of the\n-     * {@link UTF8Entry} holding the descriptor of this member.\n-     */\n-    public void setDescriptorIndex(int index) {\n-        String origDesc = getDescriptor();\n-        _descriptorIndex = index;\n-\n-        // change all the references in the owning class\n-        setEntry(getName(), origDesc);\n-    }\n-\n-    /**\n-     * Return the name of this member.\n-     */\n-    public String getName() {\n-        return ((UTF8Entry) getPool().getEntry(_nameIndex)).getValue();\n-    }\n-\n-    /**\n-     * Set the name of this member.\n-     */\n-    public void setName(String name) {\n-        String origName = getName();\n-\n-        // reset the name\n-        _nameIndex = getPool().findUTF8Entry(name, true);\n-\n-        // change all references in the owning class\n-        setEntry(origName, getDescriptor());\n-    }\n-\n-    /**\n-     * Return the descriptor of this member, in internal form.\n-     */\n-    public String getDescriptor() {\n-        return ((UTF8Entry) getPool().getEntry(_descriptorIndex)).getValue();\n-    }\n-\n-    /**\n-     * Set the descriptor of this member.\n-     */\n-    public void setDescriptor(String desc) {\n-        String origDesc = getDescriptor();\n-\n-        // reset the desc\n-        desc = getProject().getNameCache().getInternalForm(desc, true);\n-        _descriptorIndex = getPool().findUTF8Entry(desc, true);\n-\n-        // change all the references in the owning class\n-        setEntry(getName(), origDesc);\n-    }\n-\n-    /**\n-     * Resets the {@link ComplexEntry} of the owning class corresponding to\n-     * this member. Changes in the member will therefore propogate to all\n-     * code in the class.\n-     */\n-    private void setEntry(String origName, String origDesc) {\n-        // find the entry matching this member, if any\n-        String owner = getProject().getNameCache().getInternalForm\n-            (_owner.getName(), false);\n-        ConstantPool pool = getPool();\n-\n-        int index;\n-        if (this instanceof BCField)\n-            index = pool.findFieldEntry(origName, origDesc, owner, false);\n-        else if (!_owner.isInterface())\n-            index = pool.findMethodEntry(origName, origDesc, owner, false);\n-        else\n-            index = pool.findInterfaceMethodEntry(origName, origDesc,\n-                owner, false);\n-\n-        // change the entry to match the new info; this is dones so\n-        // that refs to the member in code will still be valid after the\n-        // change, without changing any other constants that happened to match\n-        // the old name and/or descriptor\n-        if (index != 0) {\n-            ComplexEntry complex = (ComplexEntry) pool.getEntry(index);\n-            int ntIndex = pool.findNameAndTypeEntry(getName(),\n-                getDescriptor(), true);\n-            complex.setNameAndTypeIndex(ntIndex);\n-        }\n-    }\n-\n-    ///////////////////////\n-    // Convenience methods\n-    ///////////////////////\n-\n-    /**\n-     * Convenience method to return deprecation information for the member.\n-     * Acts internally through the {@link Attributes} interface.\n-     */\n-    public boolean isDeprecated() {\n-        return getAttribute(Constants.ATTR_DEPRECATED) != null;\n-    }\n-\n-    /**\n-     * Convenience method to set whether this member should be considered\n-     * deprecated. Acts internally through the {@link Attributes} interface.\n-     */\n-    public void setDeprecated(boolean on) {\n-        if (!on)\n-            removeAttribute(Constants.ATTR_DEPRECATED);\n-        else if (!isDeprecated())\n-            addAttribute(Constants.ATTR_DEPRECATED);\n-    }\n-\n-    /**\n-     * Convenience method to return synthetic information for the member.\n-     * Acts internally through the {@link Attributes} interface.\n-     */\n-    public boolean isSynthetic() {\n-        return getAttribute(Constants.ATTR_SYNTHETIC) != null;\n-    }\n-\n-    /**\n-     * Convenience method to set whether this member should be considered\n-     * synthetic. Acts internally through the {@link Attributes} interface.\n-     */\n-    public void setSynthetic(boolean on) {\n-        if (!on)\n-            removeAttribute(Constants.ATTR_SYNTHETIC);\n-        else if (!isSynthetic())\n-            addAttribute(Constants.ATTR_SYNTHETIC);\n-    }\n-\n-    ////////////////////////////////\n-    // Implementation of Attributes\n-    ////////////////////////////////\n-\n-    public Project getProject() {\n-        return _owner.getProject();\n-    }\n-\n-    public ConstantPool getPool() {\n-        return _owner.getPool();\n-    }\n-\n-    public ClassLoader getClassLoader() {\n-        return _owner.getClassLoader();\n-    }\n-\n-    public boolean isValid() {\n-        return _owner != null;\n-    }\n-\n-    Collection getAttributesHolder() {\n-        return _attrs;\n-    }\n-\n-    /**\n-     * Either this method or {@link #read} must be called prior to use\n-     * of this class. The given descriptor must be in internal form.\n-     */\n-    void initialize(String name, String descriptor) {\n-        _nameIndex = getPool().findUTF8Entry(name, true);\n-        _descriptorIndex = getPool().findUTF8Entry(descriptor, true);\n-    }\n-\n-    /**\n-     * Used when this member is deleted from its class.\n-     */\n-    void invalidate() {\n-        _owner = null;\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        _access = in.readUnsignedShort();\n-        _nameIndex = in.readUnsignedShort();\n-        _descriptorIndex = in.readUnsignedShort();\n-\n-        readAttributes(in);\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        out.writeShort(_access);\n-        out.writeShort(_nameIndex);\n-        out.writeShort(_descriptorIndex);\n-\n-        writeAttributes(out);\n-    }\n-}"},{"sha":"4d05719a8d05bbd344339dbf033efb6858f44db6","filename":"serp/src/main/java/serp/bytecode/BCMethod.java","status":"removed","additions":0,"deletions":455,"changes":455,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCMethod.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCMethod.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCMethod.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,455 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.bytecode.visitor.VisitAcceptor;\n-import serp.util.Strings;\n-\n-/**\n- * A method of a class.\n- *\n- * @author Abe White\n- */\n-public class BCMethod extends BCMember implements VisitAcceptor {\n-\n-    BCMethod(BCClass owner) {\n-        super(owner);\n-    }\n-\n-    /////////////////////\n-    // Access operations\n-    /////////////////////\n-\n-    /**\n-     * Manipulate the method access flags.\n-     */\n-    public boolean isSynchronized() {\n-        return (getAccessFlags() & Constants.ACCESS_SYNCHRONIZED) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the method access flags.\n-     */\n-    public void setSynchronized(boolean on) {\n-        if (on)\n-            setAccessFlags(getAccessFlags() | Constants.ACCESS_SYNCHRONIZED);\n-        else\n-            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_SYNCHRONIZED);\n-    }\n-\n-    /**\n-     * Manipulate the method access flags.\n-     */\n-    public boolean isNative() {\n-        return (getAccessFlags() & Constants.ACCESS_NATIVE) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the method access flags.\n-     */\n-    public void setNative(boolean on) {\n-        if (on)\n-            setAccessFlags(getAccessFlags() | Constants.ACCESS_NATIVE);\n-        else\n-            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_NATIVE);\n-    }\n-\n-    /**\n-     * Manipulate the method access flags.\n-     */\n-    public boolean isAbstract() {\n-        return (getAccessFlags() & Constants.ACCESS_ABSTRACT) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the method access flags.\n-     */\n-    public void setAbstract(boolean on) {\n-        if (on)\n-            setAccessFlags(getAccessFlags() | Constants.ACCESS_ABSTRACT);\n-        else\n-            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_ABSTRACT);\n-    }\n-\n-    /**\n-     * Manipulate the method access flags.\n-     */\n-    public boolean isStrict() {\n-        return (getAccessFlags() & Constants.ACCESS_STRICT) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the method access flags.\n-     */\n-    public void setStrict(boolean on) {\n-        if (on)\n-            setAccessFlags(getAccessFlags() | Constants.ACCESS_STRICT);\n-        else\n-            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_STRICT);\n-    }\n-\n-    /////////////////////\n-    // Return operations\n-    /////////////////////\n-\n-    /**\n-     * Return the name of the type returned by this method. The name\n-     * will be given in a form suitable for a {@link Class#forName} call.\n-     *\n-     * @see BCMember#getDescriptor\n-     */\n-    public String getReturnName() {\n-        return getProject().getNameCache().getExternalForm(getProject().\n-            getNameCache().getDescriptorReturnName(getDescriptor()), false);\n-    }\n-\n-    /**\n-     * Return the {@link Class} object for the return type of this method.\n-     *\n-     * @see BCMember#getDescriptor\n-     */\n-    public Class getReturnType() {\n-        return Strings.toClass(getReturnName(), getClassLoader());\n-    }\n-\n-    /**\n-     * Return the bytecode for the return type of this method.\n-     *\n-     * @see BCMember#getDescriptor\n-     */\n-    public BCClass getReturnBC() {\n-        return getProject().loadClass(getReturnName(), getClassLoader());\n-    }\n-\n-    /**\n-     * Set the return type of this method.\n-     */\n-    public void setReturn(String name) {\n-        setDescriptor(getProject().getNameCache().getDescriptor(name,\n-            getParamNames()));\n-    }\n-\n-    /**\n-     * Set the return type of this method.\n-     */\n-    public void setReturn(Class type) {\n-        setReturn(type.getName());\n-    }\n-\n-    /**\n-     * Set the return type of this method.\n-     */\n-    public void setReturn(BCClass type) {\n-        setReturn(type.getName());\n-    }\n-\n-    ////////////////////////\n-    // Parameter operations\n-    ////////////////////////\n-\n-    /**\n-     * Return the names of all the parameter types for this method. The names\n-     * will be returned in a form suitable for a {@link Class#forName} call.\n-     *\n-     * @see BCMember#getDescriptor\n-     */\n-    public String[] getParamNames() {\n-        // get the parameter types from the descriptor\n-        String[] params = getProject().getNameCache().\n-            getDescriptorParamNames(getDescriptor());\n-\n-        // convert them to external form\n-        for (int i = 0; i < params.length; i++)\n-            params[i] = getProject().getNameCache().\n-                getExternalForm(params[i], false);\n-        return params;\n-    }\n-\n-    /**\n-     * Return the {@link Class} objects for all the parameter types for this\n-     * method.\n-     *\n-     * @see BCMember#getDescriptor\n-     */\n-    public Class[] getParamTypes() {\n-        String[] paramNames = getParamNames();\n-        Class[] params = new Class[paramNames.length];\n-        for (int i = 0; i < paramNames.length; i++)\n-            params[i] = Strings.toClass(paramNames[i], getClassLoader());\n-        return params;\n-    }\n-\n-    /**\n-     * Return the bytecode for all the parameter types for this method.\n-     *\n-     * @see BCMember#getDescriptor\n-     */\n-    public BCClass[] getParamBCs() {\n-        String[] paramNames = getParamNames();\n-        BCClass[] params = new BCClass[paramNames.length];\n-        for (int i = 0; i < paramNames.length; i++)\n-            params[i] = getProject().loadClass(paramNames[i], getClassLoader());\n-        return params;\n-    }\n-\n-    /**\n-     * Set the parameter types of this method.\n-     *\n-     * @see BCMember#setDescriptor\n-     */\n-    public void setParams(String[] names) {\n-        if (names == null)\n-            names = new String[0];\n-        setDescriptor(getProject().getNameCache().\n-            getDescriptor(getReturnName(), names));\n-    }\n-\n-    /**\n-     * Set the parameter type of this method.\n-     *\n-     * @see BCMember#setDescriptor\n-     */\n-    public void setParams(Class[] types) {\n-        if (types == null)\n-            setParams((String[]) null);\n-        else {\n-            String[] names = new String[types.length];\n-            for (int i = 0; i < types.length; i++)\n-                names[i] = types[i].getName();\n-            setParams(names);\n-        }\n-    }\n-\n-    /**\n-     * Set the parameter type of this method.\n-     *\n-     * @see BCMember#setDescriptor\n-     */\n-    public void setParams(BCClass[] types) {\n-        if (types == null)\n-            setParams((String[]) null);\n-        else {\n-            String[] names = new String[types.length];\n-            for (int i = 0; i < types.length; i++)\n-                names[i] = types[i].getName();\n-            setParams(names);\n-        }\n-    }\n-\n-    /**\n-     * Add a parameter type to this method.\n-     */\n-    public void addParam(String type) {\n-        String[] origParams = getParamNames();\n-        String[] params = new String[origParams.length + 1];\n-\n-        for (int i = 0; i < origParams.length; i++)\n-            params[i] = origParams[i];\n-        params[origParams.length] = type;\n-        setParams(params);\n-    }\n-\n-    /**\n-     * Add a parameter type to this method.\n-     */\n-    public void addParam(Class type) {\n-        addParam(type.getName());\n-    }\n-\n-    /**\n-     * Add a parameter type to this method.\n-     */\n-    public void addParam(BCClass type) {\n-        addParam(type.getName());\n-    }\n-\n-    /**\n-     * Add a parameter type to this method.\n-     *\n-     * @see java.util.List#add(int,Object)\n-     */\n-    public void addParam(int pos, String type) {\n-        String[] origParams = getParamNames();\n-        if (pos < 0 || pos >= origParams.length)\n-            throw new IndexOutOfBoundsException(\"pos = \" + pos);\n-\n-        String[] params = new String[origParams.length + 1];\n-        for (int i = 0, index = 0; i < params.length; i++) {\n-            if (i == pos)\n-                params[i] = type;\n-            else\n-                params[i] = origParams[index++];\n-        }\n-        setParams(params);\n-    }\n-\n-    /**\n-     * Add a parameter type to this method.\n-     *\n-     * @see java.util.List#add(int,Object)\n-     */\n-    public void addParam(int pos, Class type) {\n-        addParam(pos, type.getName());\n-    }\n-\n-    /**\n-     * Add a parameter type to this method.\n-     *\n-     * @see java.util.List#add(int,Object)\n-     */\n-    public void addParam(int pos, BCClass type) {\n-        addParam(pos, type.getName());\n-    }\n-\n-    /**\n-     * Change a parameter type of this method.\n-     *\n-     * @see java.util.List#set(int,Object)\n-     */\n-    public void setParam(int pos, String type) {\n-        String[] origParams = getParamNames();\n-        if (pos < 0 || pos >= origParams.length)\n-            throw new IndexOutOfBoundsException(\"pos = \" + pos);\n-\n-        String[] params = new String[origParams.length];\n-        for (int i = 0; i < params.length; i++) {\n-            if (i == pos)\n-                params[i] = type;\n-            else\n-                params[i] = origParams[i];\n-        }\n-        setParams(params);\n-    }\n-\n-    /**\n-     * Change a parameter type of this method.\n-     *\n-     * @see java.util.List#set(int,Object)\n-     */\n-    public void setParam(int pos, Class type) {\n-        setParam(pos, type.getName());\n-    }\n-\n-    /**\n-     * Change a parameter type of this method.\n-     *\n-     * @see java.util.List#set(int,Object)\n-     */\n-    public void setParam(int pos, BCClass type) {\n-        setParam(pos, type.getName());\n-    }\n-\n-    /**\n-     * Clear all parameters from this method.\n-     */\n-    public void clearParams() {\n-        setParams((String[]) null);\n-    }\n-\n-    /**\n-     * Remove a parameter from this method.\n-     */\n-    public void removeParam(int pos) {\n-        String[] origParams = getParamNames();\n-        if (pos < 0 || pos >= origParams.length)\n-            throw new IndexOutOfBoundsException(\"pos = \" + pos);\n-\n-        String[] params = new String[origParams.length - 1];\n-        for (int i = 0, index = 0; i < origParams.length; i++)\n-            if (i != pos)\n-                params[index++] = origParams[i];\n-        setParams(params);\n-    }\n-\n-    ///////////////////////\n-    // Convenience methods\n-    ///////////////////////\n-\n-    /**\n-     * Return the checked exceptions information for the method.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @param add if true, a new exceptions attribute will be added\n-     * if not already present\n-     * @return the exceptions information, or null if none and the\n-     *         <code>add</code> param is set to false\n-     */\n-    public Exceptions getExceptions(boolean add) {\n-        Exceptions exceptions = (Exceptions) getAttribute\n-            (Constants.ATTR_EXCEPTIONS);\n-        if (!add || exceptions != null)\n-            return exceptions;\n-\n-        if (exceptions == null)\n-            exceptions = (Exceptions) addAttribute(Constants.ATTR_EXCEPTIONS);\n-        return exceptions;\n-    }\n-\n-    /**\n-     * Remove the exceptions attribute for the method.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @return true if there was a value to remove\n-     */\n-    public boolean removeExceptions() {\n-        return removeAttribute(Constants.ATTR_EXCEPTIONS);\n-    }\n-\n-    /**\n-     * Return the code for the method. If the code already exists, its\n-     * iterator will be reset to the first instruction.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @param add if true, a new code attribute will be added\n-     * if not already present\n-     * @return the code for the metohd, or null if none and the\n-     *         <code>add</code> param is set to false\n-     */\n-    public Code getCode(boolean add) {\n-        Code code = (Code) getAttribute(Constants.ATTR_CODE);\n-        if (code != null) {\n-            code.beforeFirst();\n-            return code;\n-        }\n-        if (!add)\n-            return null;\n-\n-        return (Code) addAttribute(Constants.ATTR_CODE);\n-    }\n-\n-    /**\n-     * Remove the code attribute from the method.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @return true if there was a value to remove\n-     */\n-    public boolean removeCode() {\n-        return removeAttribute(Constants.ATTR_CODE);\n-    }\n-\n-    ////////////////////////////////\n-    // VisitAcceptor implementation\n-    ////////////////////////////////\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterBCMethod(this);\n-        visitAttributes(visit);\n-        visit.exitBCMethod(this);\n-    }\n-\n-    void initialize(String name, String descriptor) {\n-        super.initialize(name, descriptor);\n-        makePublic();\n-    }\n-}"},{"sha":"1251050bc87a380aa5751eebfb60e82c5551b97e","filename":"serp/src/main/java/serp/bytecode/ClassConstantInstruction.java","status":"removed","additions":0,"deletions":202,"changes":202,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ClassConstantInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ClassConstantInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ClassConstantInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,202 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-/**\n- * Pseudo-instruction used to place {@link Class} objects onto the stack.\n- * This logical instruction may actually involve a large chunk of code, and\n- * may even add static synthetic fields and methods to the owning class.\n- * Therefore, once the type of class being loaded is set, it cannot\n- * be changed. Also, this instruction is invalid as the target of\n- * any jump instruction or exception handler.\n- *\n- * @author Abe White\n- */\n-public class ClassConstantInstruction {\n-\n-    private static final Class[] _params = new Class[]{ String.class };\n-    private static final Map _wrappers = new HashMap();\n-\n-    static {\n-        _wrappers.put(byte.class.getName(), Byte.class);\n-        _wrappers.put(boolean.class.getName(), Boolean.class);\n-        _wrappers.put(char.class.getName(), Character.class);\n-        _wrappers.put(double.class.getName(), Double.class);\n-        _wrappers.put(float.class.getName(), Float.class);\n-        _wrappers.put(int.class.getName(), Integer.class);\n-        _wrappers.put(long.class.getName(), Long.class);\n-        _wrappers.put(short.class.getName(), Short.class);\n-    }\n-\n-    private Instruction _ins = null;\n-    private Code _code = null;\n-    private BCClass _class = null;\n-    private boolean _invalid = false;\n-\n-    ClassConstantInstruction(BCClass bc, Code code, Instruction nop) {\n-        _class = bc;\n-        _code = code;\n-        _ins = nop;\n-    }\n-\n-    /**\n-     * Set the type of class being loaded.\n-     *\n-     * @return the first Instruction of the block added by setting the type\n-     * @throws IllegalStateException if type has already been set\n-     */\n-    public Instruction setClass(String name) {\n-        name = _class.getProject().getNameCache(). getExternalForm(name, false);\n-        setClassName(name, getWrapperClass(name));\n-        return _ins;\n-    }\n-\n-    /**\n-     * Set the type of class being loaded.\n-     *\n-     * @return the first Instruction of the block added by setting the type\n-     * @throws IllegalStateException if type has already been set\n-     */\n-    public Instruction setClass(Class type) {\n-        return setClass(type.getName());\n-    }\n-\n-    /**\n-     * Set the type of class being loaded.\n-     *\n-     * @return the first Instruction of the block added by setting the type\n-     * @throws IllegalStateException if type has already been set\n-     */\n-    public Instruction setClass(BCClass type) {\n-        return setClass(type.getName());\n-    }\n-\n-    /**\n-     * Set the name of the class to load.\n-     */\n-    private void setClassName(String name, Class wrapper) {\n-        if (_invalid)\n-            throw new IllegalStateException();\n-\n-        // remember the position of the code iterator\n-        Instruction before = (_code.hasNext()) ? _code.next() : null;\n-        _code.before(_ins);\n-        _code.next();\n-\n-        if (wrapper != null)\n-            _code.getstatic().setField(wrapper, \"TYPE\", Class.class);\n-        else\n-            setObject(name);\n-\n-        // move to the old position\n-        if (before != null)\n-            _code.before(before);\n-        else\n-            _code.afterLast();\n-\n-        _invalid = true;\n-    }\n-\n-    /**\n-     * Adds fields and methods as necessary to load a class constant of\n-     * an object type.\n-     */\n-    private void setObject(String name) {\n-        BCField field = addClassField(name);\n-        BCMethod method = addClassLoadMethod();\n-\n-        // copied from the way jikes loads classes\n-        _code.getstatic().setField(field);\n-        JumpInstruction ifnull = _code.ifnull();\n-\n-        _code.getstatic().setField(field);\n-        JumpInstruction go2 = _code.go2();\n-\n-        ifnull.setTarget(_code.constant().setValue(name));\n-        _code.invokestatic().setMethod(method);\n-        _code.dup();\n-        _code.putstatic().setField(field);\n-\n-        go2.setTarget(_code.nop());\n-    }\n-\n-    /**\n-     * Adds a static field to hold the loaded class constant.\n-     */\n-    private BCField addClassField(String name) {\n-        String fieldName = \"class$L\" + name.replace('.', '$').\n-            replace('[', '$').replace(';', '$');\n-\n-        BCField field = _class.getDeclaredField(fieldName);\n-        if (field == null) {\n-            field = _class.declareField(fieldName, Class.class);\n-            field.makePackage();\n-            field.setStatic(true);\n-            field.setSynthetic(true);\n-        }\n-        return field;\n-    }\n-\n-    /**\n-     * Adds the standard <code>class$<code> method used inernally by classes\n-     * to load class constants for object types.\n-     */\n-    private BCMethod addClassLoadMethod() {\n-        BCMethod method = _class.getDeclaredMethod(\"class$\", _params);\n-        if (method != null)\n-            return method;\n-\n-        // add the special synthetic method\n-        method = _class.declareMethod(\"class$\", Class.class, _params);\n-        method.setStatic(true);\n-        method.makePackage();\n-        method.setSynthetic(true);\n-\n-        // copied directly from the output of the jikes compiler\n-        Code code = method.getCode(true);\n-        code.setMaxStack(3);\n-        code.setMaxLocals(2);\n-\n-        Instruction tryStart = code.aload().setLocal(0);\n-        code.invokestatic().setMethod(Class.class, \"forName\", Class.class,\n-            _params);\n-        Instruction tryEnd = code.areturn();\n-        Instruction handlerStart = code.astore().setLocal(1);\n-        code.anew().setType(NoClassDefFoundError.class);\n-        code.dup();\n-        code.aload().setLocal(1);\n-        code.invokevirtual().setMethod(Throwable.class, \"getMessage\",\n-            String.class, null);\n-        code.invokespecial().setMethod(NoClassDefFoundError.class, \"<init>\",\n-            void.class, _params);\n-        code.athrow();\n-\n-        code.addExceptionHandler(tryStart, tryEnd, handlerStart,\n-            ClassNotFoundException.class);\n-        return method;\n-    }\n-\n-    /**\n-     * Return the wrapper type for the given primitive class, or null\n-     * if the given name is not a primitive type. The given name should\n-     * be in external form.\n-     */\n-    private static Class getWrapperClass(String name) {\n-        if (name == null)\n-            return null;\n-        return (Class) _wrappers.get(name);\n-    }\n-}"},{"sha":"e2b0aea5e5ee14218b8c807870bc8d76595f9086","filename":"serp/src/main/java/serp/bytecode/ClassInstruction.java","status":"removed","additions":0,"deletions":123,"changes":123,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ClassInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ClassInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ClassInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,123 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.lowlevel.ClassEntry;\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * An instruction that takes as an argument a class to operate\n- * on. Examples include <code>anewarray, checkcast, instance, anew</code>, etc.\n- *\n- * @author Abe White\n- */\n-public class ClassInstruction extends TypedInstruction {\n-\n-    private int _index = 0;\n-\n-    ClassInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    public int getLogicalStackChange() {\n-        return getStackChange();\n-    }\n-\n-    public int getStackChange() {\n-        if (getOpcode() == Constants.NEW)\n-            return 1;\n-        return 0;\n-    }\n-\n-    int getLength() {\n-        return super.getLength() + 2;\n-    }\n-\n-    /**\n-     * Return the {@link ConstantPool} index of the\n-     * {@link ClassEntry} describing the class for this instruction.\n-     */\n-    public int getTypeIndex() {\n-        return _index;\n-    }\n-\n-    /**\n-     * Set the {@link ConstantPool} index of the\n-     * {@link ClassEntry} describing the class for this instruction.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ClassInstruction setTypeIndex(int index) {\n-        _index = index;\n-        return this;\n-    }\n-\n-    public String getTypeName() {\n-        if (_index == 0)\n-            return null;\n-\n-        ClassEntry entry = (ClassEntry) getPool().getEntry(_index);\n-        return getProject().getNameCache().getExternalForm\n-            (entry.getNameEntry().getValue(), false);\n-    }\n-\n-    public TypedInstruction setType(String type) {\n-        if (type == null)\n-            setTypeIndex(0);\n-        else {\n-            type = getProject().getNameCache().getInternalForm(type, false);\n-            setTypeIndex(getPool().findClassEntry(type, true));\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * ClassInstructions are equal if the type they reference is the same or\n-     * unset and if their opcodes are equal.\n-     */\n-    public boolean equalsInstruction(Instruction other) {\n-        if (other == this)\n-            return true;\n-        if (!super.equalsInstruction(other))\n-            return false;\n-\n-        String type = getTypeName();\n-        String otherType = ((ClassInstruction) other).getTypeName();\n-        return type == null || otherType == null || type.equals(otherType);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterClassInstruction(this);\n-        visit.exitClassInstruction(this);\n-    }\n-\n-    void read(Instruction other) {\n-        super.read(other);\n-        setType(((ClassInstruction) other).getTypeName());\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        super.read(in);\n-        setTypeIndex(in.readUnsignedShort());\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        super.write(out);\n-        out.writeShort(getTypeIndex());\n-    }\n-}"},{"sha":"936a8c00789dcdb92068f03580e6ec71e6c8e89b","filename":"serp/src/main/java/serp/bytecode/CmpInstruction.java","status":"removed","additions":0,"deletions":155,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/CmpInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/CmpInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/CmpInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,155 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * An instruction comparing two stack values. Examples include\n- * <code>lcmp, fcmpl</code>, etc.\n- *\n- * @author Abe White\n- */\n-public class CmpInstruction extends TypedInstruction {\n-\n-    private static Class[][] _mappings = new Class[][]{\n-        { int.class, long.class }, { byte.class, long.class },\n-        { char.class, long.class }, { short.class, long.class },\n-        { boolean.class, long.class }, { void.class, long.class },\n-        { Object.class, long.class }, };\n-\n-    CmpInstruction(Code owner) {\n-        super(owner);\n-    }\n-\n-    CmpInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    public int getLogicalStackChange() {\n-        switch (getOpcode()) {\n-            case Constants.NOP:\n-                return 0;\n-            default:\n-                return -1;\n-        }\n-    }\n-\n-    public int getStackChange() {\n-        switch (getOpcode()) {\n-            case Constants.LCMP:\n-            case Constants.DCMPL:\n-            case Constants.DCMPG:\n-                return -3;\n-            case Constants.NOP:\n-                return 0;\n-            default:\n-                return -1;\n-        }\n-    }\n-\n-    public String getTypeName() {\n-        switch (getOpcode()) {\n-            case Constants.LCMP:\n-                return long.class.getName();\n-            case Constants.FCMPL:\n-            case Constants.FCMPG:\n-                return float.class.getName();\n-            case Constants.DCMPL:\n-            case Constants.DCMPG:\n-                return double.class.getName();\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    public TypedInstruction setType(String type) {\n-        type = mapType(type, _mappings, true);\n-\n-        if (type == null)\n-            return (TypedInstruction) setOpcode(Constants.NOP);\n-\n-        int opcode = getOpcode();\n-        switch (type.charAt(0)) {\n-            case 'l':\n-                return (TypedInstruction) setOpcode(Constants.LCMP);\n-            case 'f':\n-                if (opcode == Constants.FCMPL || opcode == Constants.DCMPL)\n-                    return (TypedInstruction) setOpcode(Constants.FCMPL);\n-                return (TypedInstruction) setOpcode(Constants.FCMPG);\n-            case 'd':\n-                if (opcode == Constants.FCMPL || opcode == Constants.DCMPL)\n-                    return (TypedInstruction) setOpcode(Constants.DCMPL);\n-                return (TypedInstruction) setOpcode(Constants.DCMPG);\n-            default:\n-                throw new IllegalStateException();\n-        }\n-    }\n-\n-    /**\n-     * Return the number that will be placed on the stack if this instruction\n-     * is of type float or double and one of the operands is NaN. For\n-     * FCMPG or DCMPG, this value will be 1; for FCMPL or DCMPL this value\n-     * will be -1. For LCMP or if the type is unset, this value will be 0.\n-     */\n-    public int getNaNValue() {\n-        switch (getOpcode()) {\n-            case Constants.FCMPL:\n-            case Constants.DCMPL:\n-                return -1;\n-            case Constants.FCMPG:\n-            case Constants.DCMPG:\n-                return 1;\n-            default:\n-                return 0;\n-        }\n-    }\n-\n-    /**\n-     * Set the number that will be placed on the stack if this instruction\n-     * is of type float or double and one of the operands is NaN. For\n-     * FCMPG or DCMPG, this value should be 1; for FCMPL or DCMPL this value\n-     * should be -1. For LCMP, this value should be 0.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public CmpInstruction setNaNValue(int nan) {\n-        switch (getOpcode()) {\n-            case Constants.FCMPL:\n-            case Constants.FCMPG:\n-                if (nan == 1)\n-                    setOpcode(Constants.FCMPG);\n-                else if (nan == -1)\n-                    setOpcode(Constants.FCMPL);\n-                else\n-                    throw new IllegalArgumentException(\"Invalid nan for type\");\n-            case Constants.DCMPL:\n-            case Constants.DCMPG:\n-                if (nan == 1)\n-                    setOpcode(Constants.DCMPG);\n-                else if (nan == -1)\n-                    setOpcode(Constants.DCMPL);\n-                else\n-                    throw new IllegalArgumentException(\"Invalid nan for type\");\n-            default:\n-                if (nan != 0)\n-                    throw new IllegalArgumentException(\"Invalid nan for type\");\n-        }\n-        return this;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterCmpInstruction(this);\n-        visit.exitCmpInstruction(this);\n-    }\n-}"},{"sha":"51eed6f84ffd6cd1177a08fb4466b985a2a2af71","filename":"serp/src/main/java/serp/bytecode/Code.java","status":"removed","additions":0,"deletions":2635,"changes":2635,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Code.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Code.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Code.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,2635 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataInput;\n-import java.io.DataInputStream;\n-import java.io.DataOutput;\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.NoSuchElementException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Representation of a code block of a class.\n- * The methods of this class mimic those of the same name in the\n- * {@link java.util.ListIterator} class. Note that the size and index\n- * information of the code block will change as opcodes are added.\n- * Code blocks are usually obtained from a {@link BCMethod}, but can also\n- * be constructed via the default constructor. Blocks created this way can\n- * be used to provide template instructions to the various search/replace\n- * methods in this class.\n- * The code class contains methods named after most JVM instructions, each\n- * of which adds the matching opcode to the code block at the\n- * current iterator position. It also contains generic versions of various\n- * JVM instructions whose opcodes are not set until their properties are set\n- * with additional information. Almost all instruction types are able to\n- * 'morph' their opcode on the fly as the arguments to the instruction change.\n- * Thus the developer can initially call, for example, the <code>aload</code>\n- * opcode, but later change the type to load to <code>int</code> and the\n- * opcode will automatically morph to the <code>iload</code> opcode.\n- *\n- * @author Abe White\n- */\n-public class Code extends Attribute {\n-\n-    private final CodeEntry _head;\n-    private final CodeEntry _tail;\n-    private CodeIterator _ci;\n-\n-    private int _maxStack = 0;\n-    private int _maxLocals = 0;\n-    private int _size = 0;\n-    private Collection _handlers = new LinkedList();\n-    private Collection _attrs = new LinkedList();\n-\n-    Code(int nameIndex, Attributes owner) {\n-        super(nameIndex, owner);\n-\n-        _head = new CodeEntry();\n-        _tail = new CodeEntry();\n-        _head.next = _tail;\n-        _tail.prev = _head;\n-\n-        _ci = new CodeIterator(_head, -1);\n-    }\n-\n-    /**\n-     * The public constructor is for creating template code modules\n-     * that produce {@link Instruction}s used in matching through\n-     * the various <code>search</code> and <code>replace</code> methods.\n-     */\n-    public Code() {\n-        this(0, new Project().loadClass(\"\", null).\n-            declareMethod(\"\", void.class, null));\n-    }\n-\n-    /**\n-     * The owning method.\n-     */\n-    public BCMethod getMethod() {\n-        return (BCMethod) getOwner();\n-    }\n-\n-    Collection getAttributesHolder() {\n-        return _attrs;\n-    }\n-\n-    ////////////////////////////\n-    // Stack, Locals operations\n-    ////////////////////////////\n-\n-    /**\n-     * Return the maximum stack depth set for this code block.\n-     */\n-    public int getMaxStack() {\n-        return _maxStack;\n-    }\n-\n-    /**\n-     * Set the maximum stack depth for this code block.\n-     */\n-    public void setMaxStack(int max) {\n-        _maxStack = max;\n-    }\n-\n-    /**\n-     * Return the maximum number of local variables(including params)\n-     * set for this method.\n-     */\n-    public int getMaxLocals() {\n-        return _maxLocals;\n-    }\n-\n-    /**\n-     * Set the maximum number of local variables(including params) in\n-     * this method.\n-     */\n-    public void setMaxLocals(int max) {\n-        _maxLocals = max;\n-    }\n-\n-    /**\n-     * Return the local variable index for the paramIndex'th parameter to\n-     * the method. Local variable indexes differ from parameter indexes because:\n-     * a) non-static methods use the 0th local variable for the 'this' ptr, and\n-     * b) double and long values occupy two spots in the local variable array.\n-     * Returns -1 if the given index is not valid.\n-     */\n-    public int getLocalsIndex(int paramIndex) {\n-        if (paramIndex < 0)\n-            return -1;\n-\n-        int pos = 0;\n-        if (!getMethod().isStatic())\n-            pos = 1;\n-\n-        String[] params = getMethod().getParamNames();\n-        for (int i = 0; i < paramIndex; i++, pos++) {\n-            if (i == params.length)\n-                return -1;\n-            if (params[i].equals(long.class.getName())\n-                || params[i].equals(double.class.getName()))\n-                pos++;\n-        }\n-\n-        return pos;\n-    }\n-\n-    /**\n-     * Return the parameter index for the given local index, or -1 if\n-     * the given local does not reference a param.\n-     *\n-     * @see #getLocalsIndex\n-     */\n-    public int getParamsIndex(int localIndex) {\n-        int pos = 0;\n-        if (!getMethod().isStatic())\n-            pos = 1;\n-\n-        String[] params = getMethod().getParamNames();\n-        for (int i = 0; i < params.length; i++, pos++) {\n-            if (localIndex == pos)\n-                return i;\n-            if (params[i].equals(long.class.getName())\n-                || params[i].equals(double.class.getName()))\n-                pos++;\n-        }\n-\n-        return -1;\n-    }\n-\n-    /**\n-     * Return the next available local variable index.\n-     */\n-    public int getNextLocalsIndex() {\n-        calculateMaxLocals();\n-        return getMaxLocals();\n-    }\n-\n-    /**\n-     * Calculate and set the number of locals needed based on\n-     * the instructions used and the parameters of the method this code\n-     * block is a part of.\n-     *\n-     * @see #setMaxLocals\n-     */\n-    public void calculateMaxLocals() {\n-        // start off assuming the max number needed is the\n-        // number for all the params\n-        String[] params = getMethod().getParamNames();\n-        int max = 0;\n-        if (params.length == 0 && !getMethod().isStatic())\n-            max = 1;\n-        else if (params.length > 0) {\n-            max = getLocalsIndex(params.length - 1) + 1;\n-            if (params[params.length - 1].equals(long.class.getName())\n-                || params[params.length - 1].equals(double.class.getName()))\n-                max++;\n-        }\n-\n-        // check to see if there are any store instructions that\n-        // try to reference beyond that point\n-        StoreInstruction store;\n-        int current;\n-        for (CodeEntry entry = _head.next; entry != _tail; entry = entry.next) {\n-            current = 0;\n-            if (entry instanceof StoreInstruction) {\n-                store = (StoreInstruction) entry;\n-                current = store.getLocal() + 1;\n-                if (store.getType().equals(long.class)\n-                    || store.getType().equals(double.class))\n-                    current++;\n-\n-                if (current > max)\n-                    max = current;\n-            }\n-        }\n-\n-        setMaxLocals(max);\n-    }\n-\n-    /**\n-     * Calculate and set the maximum stack depth needed for\n-     * the instructions used.\n-     *\n-     * @see #setMaxStack\n-     */\n-    public void calculateMaxStack() {\n-        int stack = 0;\n-        int max = 0;\n-\n-        ExceptionHandler[] handlers = getExceptionHandlers();\n-        Instruction ins;\n-        for (CodeEntry entry = _head.next; entry != _tail; entry = entry.next) {\n-            ins = (Instruction) entry;\n-            stack += ins.getStackChange();\n-\n-            // if this is the start of a try, the exception will be placed\n-            // on the stack\n-            for (int j = 0; j < handlers.length; j++)\n-                if (handlers[j].getTryStart() == ins)\n-                    stack++;\n-\n-            if (stack > max)\n-                max = stack;\n-        }\n-\n-        setMaxStack(max);\n-    }\n-\n-    ///////////////////////////////\n-    // ExceptionHandler operations\n-    ///////////////////////////////\n-\n-    /**\n-     * Return the exception handlers active in this code block, or an\n-     * empty array if none.\n-     */\n-    public ExceptionHandler[] getExceptionHandlers() {\n-        return (ExceptionHandler[]) _handlers.toArray\n-            (new ExceptionHandler[_handlers.size()]);\n-    }\n-\n-    /**\n-     * Return the exception handler that catches the given exception type;\n-     * if multiple handlers catch the given type, which is returned is\n-     * undefined.\n-     */\n-    public ExceptionHandler getExceptionHandler(String catchType) {\n-        catchType = getProject().getNameCache().\n-            getExternalForm(catchType, false);\n-\n-        String type;\n-        ExceptionHandler[] handlers = getExceptionHandlers();\n-        for (int i = 0; i < handlers.length; i++) {\n-            type = handlers[i].getCatchName();\n-\n-            if ((type == null && catchType == null)\n-                || (type != null && type.equals(catchType)))\n-                return handlers[i];\n-        }\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Return the exception handler that catches the given exception type;\n-     * if multiple handlers catch the given type, which is returned is\n-     * undefined.\n-     */\n-    public ExceptionHandler getExceptionHandler(Class catchType) {\n-        if (catchType == null)\n-            return getExceptionHandler((String) null);\n-        return getExceptionHandler(catchType.getName());\n-    }\n-\n-    /**\n-     * Return the exception handler that catches the given exception type;\n-     * if multiple handlers catch the given type, which is returned is\n-     * undefined.\n-     */\n-    public ExceptionHandler getExceptionHandler(BCClass catchType) {\n-        if (catchType == null)\n-            return getExceptionHandler((String) null);\n-        return getExceptionHandler(catchType.getName());\n-    }\n-\n-    /**\n-     * Return all exception handlers that catch the given exception type,\n-     * or an empty array if none.\n-     */\n-    public ExceptionHandler[] getExceptionHandlers(String catchType) {\n-        catchType = getProject().getNameCache().\n-            getExternalForm(catchType, false);\n-\n-        List matches = new LinkedList();\n-        String type;\n-        ExceptionHandler[] handlers = getExceptionHandlers();\n-        for (int i = 0; i < handlers.length; i++) {\n-            type = handlers[i].getCatchName();\n-\n-            if ((type == null && catchType == null)\n-                || (type != null && type.equals(catchType)))\n-                matches.add(handlers[i]);\n-        }\n-\n-        return (ExceptionHandler[]) matches.toArray\n-            (new ExceptionHandler[matches.size()]);\n-    }\n-\n-    /**\n-     * Return all exception handlers that catch the given exception type,\n-     * or an empty array if none.\n-     */\n-    public ExceptionHandler[] getExceptionHandlers(Class catchType) {\n-        if (catchType == null)\n-            return getExceptionHandlers((String) null);\n-        return getExceptionHandlers(catchType.getName());\n-    }\n-\n-    /**\n-     * Return all exception handlers that catch the given exception type,\n-     * or an empty array if none.\n-     */\n-    public ExceptionHandler[] getExceptionHandlers(BCClass catchType) {\n-        if (catchType == null)\n-            return getExceptionHandlers((String) null);\n-        return getExceptionHandlers(catchType.getName());\n-    }\n-\n-    /**\n-     * Set the exception handlers for this code block. This method is useful\n-     * for importing all handlers from another code block. Set to null or\n-     * empty array if none.\n-     */\n-    public void setExceptionHandlers(ExceptionHandler[] handlers) {\n-        clearExceptionHandlers();\n-        if (handlers != null)\n-            for (int i = 0; i < handlers.length; i++)\n-                addExceptionHandler(handlers[i]);\n-    }\n-\n-    /**\n-     * Import the given exception handler from another code block.\n-     */\n-    public ExceptionHandler addExceptionHandler(ExceptionHandler handler) {\n-        ExceptionHandler newHandler = addExceptionHandler();\n-        newHandler.read(handler);\n-        return newHandler;\n-    }\n-\n-    /**\n-     * Add an exception handler to this code block.\n-     */\n-    public ExceptionHandler addExceptionHandler() {\n-        ExceptionHandler handler = new ExceptionHandler(this);\n-        _handlers.add(handler);\n-        return handler;\n-    }\n-\n-    /**\n-     * Add an exception handler to this code block.\n-     *\n-     * @param tryStart the first instruction of the try {} block\n-     * @param tryEnd the last instruction of the try {} block\n-     * @param handlerStart the first instruction of the catch {} block\n-     * @param catchType the type of exception being caught\n-     */\n-    public ExceptionHandler addExceptionHandler(Instruction tryStart,\n-        Instruction tryEnd, Instruction handlerStart, String catchType) {\n-        ExceptionHandler handler = addExceptionHandler();\n-        handler.setTryStart(tryStart);\n-        handler.setTryEnd(tryEnd);\n-        handler.setHandlerStart(handlerStart);\n-        handler.setCatch(catchType);\n-        return handler;\n-    }\n-\n-    /**\n-     * Add an exception handler to this code block.\n-     *\n-     * @param tryStart the first instruction of the try {} block\n-     * @param tryEnd the last instruction of the try {} block\n-     * @param handlerStart the first instruction of the catch {} block\n-     * @param catchType the type of exception being caught\n-     */\n-    public ExceptionHandler addExceptionHandler(Instruction tryStart,\n-        Instruction tryEnd, Instruction handlerStart, Class catchType) {\n-        String catchName = null;\n-        if (catchType != null)\n-            catchName = catchType.getName();\n-        return addExceptionHandler(tryStart, tryEnd, handlerStart, catchName);\n-    }\n-\n-    /**\n-     * Add an exception handler to this code block.\n-     *\n-     * @param tryStart the first instruction of the try {} block\n-     * @param tryEnd the last instruction of the try {} block\n-     * @param handlerStart the first instruction of the catch {} block\n-     * @param catchType the type of exception being caught\n-     */\n-    public ExceptionHandler addExceptionHandler(Instruction tryStart,\n-        Instruction tryEnd, Instruction handlerStart, BCClass catchType) {\n-        String catchName = null;\n-        if (catchType != null)\n-            catchName = catchType.getName();\n-        return addExceptionHandler(tryStart, tryEnd, handlerStart, catchName);\n-    }\n-\n-    /**\n-     * Clear all exception handlers.\n-     */\n-    public void clearExceptionHandlers() {\n-        ExceptionHandler handler;\n-        for (Iterator itr = _handlers.iterator(); itr.hasNext();) {\n-            handler = (ExceptionHandler) itr.next();\n-            itr.remove();\n-            handler.invalidate();\n-        }\n-    }\n-\n-    /**\n-     * Remove the exception handler that catches the given type.\n-     */\n-    public boolean removeExceptionHandler(String catchType) {\n-        return removeExceptionHandler(getExceptionHandler(catchType));\n-    }\n-\n-    /**\n-     * Remove the exception handler that catches the given type.\n-     *\n-     * @return true if the handler was removed, false otherwise\n-     */\n-    public boolean removeExceptionHandler(Class catchType) {\n-        if (catchType == null)\n-            return removeExceptionHandler((String) null);\n-        return removeExceptionHandler(catchType.getName());\n-    }\n-\n-    /**\n-     * Remove the exception handler that catches the given type.\n-     *\n-     * @return true if the handler was removed, false otherwise\n-     */\n-    public boolean removeExceptionHandler(BCClass catchType) {\n-        if (catchType == null)\n-            return removeExceptionHandler((String) null);\n-        return removeExceptionHandler(catchType.getName());\n-    }\n-\n-    /**\n-     * Remove an exception handler from this code block. The given handler\n-     * must belong to this code block.\n-     */\n-    public boolean removeExceptionHandler(ExceptionHandler handler) {\n-        if (handler == null || !_handlers.remove(handler))\n-            return false;\n-\n-        handler.invalidate();\n-        return true;\n-    }\n-\n-    /////////////////////////\n-    // Code block operations\n-    /////////////////////////\n-\n-    /**\n-     * Return the number of instructions in the method.\n-     */\n-    public int size() {\n-        return _size;\n-    }\n-\n-    /**\n-     * Reset the position of the instruction iterator to the first opcode.\n-     */\n-    public void beforeFirst() {\n-        _ci = new CodeIterator(_head, -1);\n-    }\n-\n-    /**\n-     * Set the position of the instruction iterator to after the last opcode.\n-     */\n-    public void afterLast() {\n-        if (_size == 0)\n-            _ci = new CodeIterator(_head, -1);\n-        else\n-            _ci = new CodeIterator(_tail.prev, _size - 1);\n-    }\n-\n-    /**\n-     * Position the iterator just before the given instruction. The\n-     * instruction must belong to this method.\n-     */\n-    public void before(Instruction ins) {\n-        if (ins.getCode() != this)\n-            throw new IllegalArgumentException(\"ins.code != this\");\n-        _ci = new CodeIterator(ins.prev, CodeIterator.UNSET);\n-    }\n-\n-    /**\n-     * Position the iterator just after the given instruction. The\n-     * instruction must belong to this method.\n-     */\n-    public void after(Instruction ins) {\n-        before(ins);\n-        next();\n-    }\n-\n-    /**\n-     * Return true if a subsequent call to {@link #next} will return an\n-     * instruction.\n-     */\n-    public boolean hasNext() {\n-        return _ci.hasNext();\n-    }\n-\n-    /**\n-     * Return true if a subsequent call to {@link #previous} will return an\n-     * instruction.\n-     */\n-    public boolean hasPrevious() {\n-        return _ci.hasPrevious();\n-    }\n-\n-    /**\n-     * Return the next instruction.\n-     */\n-    public Instruction next() {\n-        return (Instruction) _ci.next();\n-    }\n-\n-    /**\n-     * Return the index of the next instruction, or {@link #size} if at end.\n-     */\n-    public int nextIndex() {\n-        return _ci.nextIndex();\n-    }\n-\n-    /**\n-     * Return the previous instruction.\n-     */\n-    public Instruction previous() {\n-        return (Instruction) _ci.previous();\n-    }\n-\n-    /**\n-     * Return the index of the previous instruction, or -1 if at beginning.\n-     */\n-    public int previousIndex() {\n-        return _ci.previousIndex();\n-    }\n-\n-    /**\n-     * Place the iterator before the given list index.\n-     */\n-    public void before(int index) {\n-        if (index < 0 || index >= _size)\n-            throw new IndexOutOfBoundsException(String.valueOf(index));\n-\n-        CodeEntry entry = _head;\n-        for (int i = 0; i < index; entry = entry.next, i++) ;\n-        _ci = new CodeIterator(entry, index - 1);\n-    }\n-\n-    /**\n-     * Place the iterator after the given list index.\n-     */\n-    public void after(int index) {\n-        before(index);\n-        next();\n-    }\n-\n-    /**\n-     * Find the next instruction from the current iterator position that\n-     * matches the given one, according to the {@link Object#equals} methods of\n-     * the instruction types. This allows for matching based on template\n-     * instructions, as the equals methods of most instructions return\n-     * true if the information for the given instruction has not been filled\n-     * in. If a match is found, the iterator is placed after the matching\n-     * Instruction. If no match is found, moves the iterator to\n-     * {@link #afterLast}.\n-     *\n-     * @return true if match found\n-     */\n-    public boolean searchForward(Instruction template) {\n-        if (template == null)\n-            return false;\n-        while (hasNext())\n-            if (template.equalsInstruction(next()))\n-                return true;\n-        return false;\n-    }\n-\n-    /**\n-     * Find the closest previous instruction from the current iterator\n-     * position that matches the given one, according to the\n-     * {@link Object#equals} methods of the instruction types. This allows\n-     * for matching based on template instructions, as the equals methods of\n-     * most instructions return true if the information for the given\n-     * instruction has not been filled in. If a match is found, the iterator\n-     * is placed before the matching Instruction. If no match is found,\n-     * moves the iterator to {@link #beforeFirst}.\n-     *\n-     * @return true if match found\n-     */\n-    public boolean searchBackward(Instruction template) {\n-        if (template == null)\n-            return false;\n-        while (hasPrevious())\n-            if (template.equalsInstruction(previous()))\n-                return true;\n-        return false;\n-    }\n-\n-    /**\n-     * Adds a copy of the given instruction.\n-     *\n-     * @return the newly added instruction\n-     */\n-    public Instruction add(Instruction ins) {\n-        Instruction newIns = createInstruction(ins.getOpcode());\n-        newIns.read(ins);\n-        _ci.add(newIns);\n-        return newIns;\n-    }\n-\n-    /**\n-     * Replaces the last iterated instruction with a copy of the given one.\n-     * This method will also make sure that all jump points\n-     * that referenced the old opcode are updated correctly.\n-     *\n-     * @return the newly added instruction\n-     * @see ListIterator#set\n-     */\n-    public Instruction set(Instruction ins) {\n-        Instruction newIns = createInstruction(ins.getOpcode());\n-        newIns.read(ins);\n-        _ci.set(newIns);\n-        return newIns;\n-    }\n-\n-    /**\n-     * Replaces all the instructions in this code block that match the\n-     * given template with the given instruction. After this method,\n-     * the iterator will be {@link #afterLast}.\n-     *\n-     * @return the number of substitutions made\n-     */\n-    public int replace(Instruction template, Instruction with) {\n-        beforeFirst();\n-        int count;\n-        for (count = 0; searchForward(template); count++)\n-            set(with);\n-        return count;\n-    }\n-\n-    /**\n-     * Equivalent to looping over each given template/replacement\n-     * pair and calling {@link #replace(Instruction,Instruction)} for each.\n-     */\n-    public int replace(Instruction[] templates, Instruction[] with) {\n-        if (templates == null || with == null)\n-            return 0;\n-\n-        int count = 0;\n-        for (int i = 0; i < templates.length; i++) {\n-            if (with == null)\n-                count += replace(templates[i], null);\n-            else\n-                count += replace(templates[i], with[i]);\n-        }\n-        return count;\n-    }\n-\n-    /**\n-     * Remove the last iterated instruction.\n-     *\n-     * @see ListIterator#remove\n-     */\n-    public void remove() {\n-        _ci.remove();\n-    }\n-\n-    //////////////////////////\n-    // Instruction operations\n-    //////////////////////////\n-\n-    /**\n-     * Load a class constant onto the stack.\n-     * For primitive types, this translates into a\n-     * getstatic for the TYPE field of the primitive's wrapper type.\n-     * For non-primitives, things get much more complex. Suffice it to\n-     * say that the operation involves adding synthetic static fields\n-     * and even methods to the class. Note that this instruction requires\n-     * up to 3 stack positions to execute.\n-     */\n-    public ClassConstantInstruction classconstant() {\n-        return new ClassConstantInstruction(getMethod().getDeclarer(),\n-            this, nop());\n-    }\n-\n-    /**\n-     * Add the <code>nop</code> opcode.\n-     */\n-    public Instruction nop() {\n-        return addInstruction(Constants.NOP);\n-    }\n-\n-    /**\n-     * Load some constant onto the stack. The {@link ConstantInstruction}\n-     * type takes any constant and correctly translates it into the proper\n-     * opcode, depending on the constant type and value. For example,\n-     * if the constant value is set to 0L, the opcode will be set to\n-     * <code>lconst0</code>.\n-     */\n-    public ConstantInstruction constant() {\n-        return (ConstantInstruction) addInstruction\n-            (new ConstantInstruction(this));\n-    }\n-\n-    /**\n-     * Load a local variable onto the stack. This instruction will result\n-     * in a <code>nop</code> until its type and local index are set.\n-     */\n-    public LoadInstruction xload() {\n-        return (LoadInstruction) addInstruction(new LoadInstruction(this));\n-    }\n-\n-    /**\n-     * Load an int local variable onto the stack. This instruction will\n-     * result in a <code>nop</code> until its local index is set.\n-     */\n-    public LoadInstruction iload() {\n-        return (LoadInstruction) addInstruction(new LoadInstruction(this).\n-            setType(int.class));\n-    }\n-\n-    /**\n-     * Load a long local variable onto the stack. This instruction will\n-     * result in a <code>nop</code> until its local index is set.\n-     */\n-    public LoadInstruction lload() {\n-        return (LoadInstruction) addInstruction(new LoadInstruction(this).\n-            setType(long.class));\n-    }\n-\n-    /**\n-     * Load a float local variable onto the stack. This instruction will\n-     * result in a <code>nop</code> until its local index is set.\n-     */\n-    public LoadInstruction fload() {\n-        return (LoadInstruction) addInstruction(new LoadInstruction(this).\n-            setType(float.class));\n-    }\n-\n-    /**\n-     * Load a double local variable onto the stack. This instruction will\n-     * result in a <code>nop</code> until its local index is set.\n-     */\n-    public LoadInstruction dload() {\n-        return (LoadInstruction) addInstruction(new LoadInstruction(this).\n-            setType(double.class));\n-    }\n-\n-    /**\n-     * Load an object local variable onto the stack. This instruction will\n-     * result in a <code>nop</code> until its local index is set.\n-     */\n-    public LoadInstruction aload() {\n-        return (LoadInstruction) addInstruction(new LoadInstruction(this).\n-            setType(Object.class));\n-    }\n-\n-    /**\n-     * Store a value from the stack into a local variable. This instruction\n-     * will result in a <code>nop</code> until its type and local index are set.\n-     */\n-    public StoreInstruction xstore() {\n-        return (StoreInstruction) addInstruction(new StoreInstruction(this));\n-    }\n-\n-    /**\n-     * Store an int value from the stack into a local variable. This\n-     * instruction will result in a <code>nop</code> until its local index is\n-     * set.\n-     */\n-    public StoreInstruction istore() {\n-        return (StoreInstruction) addInstruction(new StoreInstruction(this).\n-            setType(int.class));\n-    }\n-\n-    /**\n-     * Store a long value from the stack into a local variable. This\n-     * instruction will result in a <code>nop</code> until its local index is\n-     * set.\n-     */\n-    public StoreInstruction lstore() {\n-        return (StoreInstruction) addInstruction(new StoreInstruction(this).\n-            setType(long.class));\n-    }\n-\n-    /**\n-     * Store a float value from the stack into a local variable. This\n-     * instruction will result in a <code>nop</code> until its local index is\n-     * set.\n-     */\n-    public StoreInstruction fstore() {\n-        return (StoreInstruction) addInstruction(new StoreInstruction(this).\n-            setType(float.class));\n-    }\n-\n-    /**\n-     * Store a double value from the stack into a local variable. This\n-     * instruction will result in a <code>nop</code> until its local index is\n-     * set.\n-     */\n-    public StoreInstruction dstore() {\n-        return (StoreInstruction) addInstruction(new StoreInstruction(this).\n-            setType(double.class));\n-    }\n-\n-    /**\n-     * Store an object value from the stack into a local variable. This\n-     * instruction will result in a <code>nop</code> until its local index is\n-     * set.\n-     */\n-    public StoreInstruction astore() {\n-        return (StoreInstruction) addInstruction(new StoreInstruction(this).\n-            setType(Object.class));\n-    }\n-\n-    /**\n-     * Add the <code>ret</code> opcode, used in implementing\n-     * <code>finally</code> clauses.\n-     */\n-    public RetInstruction ret() {\n-        return (RetInstruction) addInstruction(Constants.RET);\n-    }\n-\n-    /**\n-     * Add the <code>iinc</code> opcode.\n-     */\n-    public IIncInstruction iinc() {\n-        return (IIncInstruction) addInstruction(Constants.IINC);\n-    }\n-\n-    /**\n-     * Add the <code>wide</code> opcode.\n-     */\n-    public WideInstruction wide() {\n-        return (WideInstruction) addInstruction(Constants.WIDE);\n-    }\n-\n-    /**\n-     * Load an array value onto the stack. This instruction will result\n-     * in a <code>nop</code> until its type is set.\n-     */\n-    public ArrayLoadInstruction xaload() {\n-        return (ArrayLoadInstruction) addInstruction\n-            (new ArrayLoadInstruction(this));\n-    }\n-\n-    /**\n-     * Load an int array value onto the stack; the <code>iaload</code> opcode.\n-     */\n-    public ArrayLoadInstruction iaload() {\n-        return (ArrayLoadInstruction) addInstruction(Constants.IALOAD);\n-    }\n-\n-    /**\n-     * Load a long array value onto the stack; the <code>laload</code> opcode.\n-     */\n-    public ArrayLoadInstruction laload() {\n-        return (ArrayLoadInstruction) addInstruction(Constants.LALOAD);\n-    }\n-\n-    /**\n-     * Load a float array value onto the stack; the <code>faload</code> opcode.\n-     */\n-    public ArrayLoadInstruction faload() {\n-        return (ArrayLoadInstruction) addInstruction(Constants.FALOAD);\n-    }\n-\n-    /**\n-     * Load a double array value onto the stack; the <code>daload</code> opcode.\n-     */\n-    public ArrayLoadInstruction daload() {\n-        return (ArrayLoadInstruction) addInstruction(Constants.DALOAD);\n-    }\n-\n-    /**\n-     * Load an object array value onto the stack; the <code>aaload</code>\n-     * opcode.\n-     */\n-    public ArrayLoadInstruction aaload() {\n-        return (ArrayLoadInstruction) addInstruction(Constants.AALOAD);\n-    }\n-\n-    /**\n-     * Load a byte array value onto the stack; the <code>baload</code> opcode.\n-     */\n-    public ArrayLoadInstruction baload() {\n-        return (ArrayLoadInstruction) addInstruction(Constants.BALOAD);\n-    }\n-\n-    /**\n-     * Load a char array value onto the stack; the <code>caload</code> opcode.\n-     */\n-    public ArrayLoadInstruction caload() {\n-        return (ArrayLoadInstruction) addInstruction(Constants.CALOAD);\n-    }\n-\n-    /**\n-     * Load a short array value onto the stack; the <code>saload</code> opcode.\n-     */\n-    public ArrayLoadInstruction saload() {\n-        return (ArrayLoadInstruction) addInstruction(Constants.SALOAD);\n-    }\n-\n-    /**\n-     * Store a value from the stack into an array. This instruction\n-     * will result in a <code>nop</code> until its type is set.\n-     */\n-    public ArrayStoreInstruction xastore() {\n-        return (ArrayStoreInstruction) addInstruction\n-            (new ArrayStoreInstruction(this));\n-    }\n-\n-    /**\n-     * Store an int value from the stack into an array; the\n-     * <code>iastore</code> opcode.\n-     */\n-    public ArrayStoreInstruction iastore() {\n-        return (ArrayStoreInstruction) addInstruction(Constants.IASTORE);\n-    }\n-\n-    /**\n-     * Store a long value from the stack into an array; the\n-     * <code>lastore</code> opcode.\n-     */\n-    public ArrayStoreInstruction lastore() {\n-        return (ArrayStoreInstruction) addInstruction(Constants.LASTORE);\n-    }\n-\n-    /**\n-     * Store a float value from the stack into an array; the\n-     * <code>fastore</code> opcode.\n-     */\n-    public ArrayStoreInstruction fastore() {\n-        return (ArrayStoreInstruction) addInstruction(Constants.FASTORE);\n-    }\n-\n-    /**\n-     * Store a double value from the stack into an array; the\n-     * <code>dastore</code> opcode.\n-     */\n-    public ArrayStoreInstruction dastore() {\n-        return (ArrayStoreInstruction) addInstruction(Constants.DASTORE);\n-    }\n-\n-    /**\n-     * Store an object value from the stack into an array; the\n-     * <code>aastore</code> opcode.\n-     */\n-    public ArrayStoreInstruction aastore() {\n-        return (ArrayStoreInstruction) addInstruction(Constants.AASTORE);\n-    }\n-\n-    /**\n-     * Store a byte value from the stack into an array; the\n-     * <code>bastore</code> opcode.\n-     */\n-    public ArrayStoreInstruction bastore() {\n-        return (ArrayStoreInstruction) addInstruction(Constants.BASTORE);\n-    }\n-\n-    /**\n-     * Store a char value from the stack into an array; the\n-     * <code>castore</code> opcode.\n-     */\n-    public ArrayStoreInstruction castore() {\n-        return (ArrayStoreInstruction) addInstruction(Constants.CASTORE);\n-    }\n-\n-    /**\n-     * Store a short value from the stack into an array; the\n-     * <code>sastore</code> opcode.\n-     */\n-    public ArrayStoreInstruction sastore() {\n-        return (ArrayStoreInstruction) addInstruction(Constants.SASTORE);\n-    }\n-\n-    /**\n-     * The <code>pop</code> opcode.\n-     */\n-    public StackInstruction pop() {\n-        return (StackInstruction) addInstruction(Constants.POP);\n-    }\n-\n-    /**\n-     * The <code>pop2</code> opcode.\n-     */\n-    public StackInstruction pop2() {\n-        return (StackInstruction) addInstruction(Constants.POP2);\n-    }\n-\n-    /**\n-     * The <code>dup</code> opcode.\n-     */\n-    public StackInstruction dup() {\n-        return (StackInstruction) addInstruction(Constants.DUP);\n-    }\n-\n-    /**\n-     * The <code>dupx1</code> opcode.\n-     */\n-    public StackInstruction dupx1() {\n-        return (StackInstruction) addInstruction(Constants.DUPX1);\n-    }\n-\n-    /**\n-     * The <code>dupx2</code> opcode.\n-     */\n-    public StackInstruction dupx2() {\n-        return (StackInstruction) addInstruction(Constants.DUPX2);\n-    }\n-\n-    /**\n-     * The <code>dup2</code> opcode.\n-     */\n-    public StackInstruction dup2() {\n-        return (StackInstruction) addInstruction(Constants.DUP2);\n-    }\n-\n-    /**\n-     * The <code>dup2x1</code> opcode.\n-     */\n-    public StackInstruction dup2x1() {\n-        return (StackInstruction) addInstruction(Constants.DUP2X1);\n-    }\n-\n-    /**\n-     * The <code>dup2x2</code> opcode.\n-     */\n-    public StackInstruction dup2x2() {\n-        return (StackInstruction) addInstruction(Constants.DUP2X2);\n-    }\n-\n-    /**\n-     * The <code>swap</code> opcode.\n-     */\n-    public StackInstruction swap() {\n-        return (StackInstruction) addInstruction(Constants.SWAP);\n-    }\n-\n-    /**\n-     * Perform some math operation on the stack items. This instruction will\n-     * result in a <code>nop</code> until its operation and type are set.\n-     */\n-    public MathInstruction math() {\n-        return (MathInstruction) addInstruction(new MathInstruction(this));\n-    }\n-\n-    /**\n-     * Add the top two stack values. This instruction will result in\n-     * a <code>nop</code> until its type is set.\n-     */\n-    public MathInstruction xadd() {\n-        MathInstruction mi = math();\n-        return mi.setOperation(Constants.MATH_ADD);\n-    }\n-\n-    /**\n-     * Add the top two stack int values; the <code>iadd</code> opcode.\n-     */\n-    public MathInstruction iadd() {\n-        return (MathInstruction) addInstruction(Constants.IADD);\n-    }\n-\n-    /**\n-     * Add the top two stack long values; the <code>ladd</code> opcode.\n-     */\n-    public MathInstruction ladd() {\n-        return (MathInstruction) addInstruction(Constants.LADD);\n-    }\n-\n-    /**\n-     * Add the top two stack float values; the <code>fadd</code> opcode.\n-     */\n-    public MathInstruction fadd() {\n-        return (MathInstruction) addInstruction(Constants.FADD);\n-    }\n-\n-    /**\n-     * Add the top two stack double values; the <code>dadd</code> opcode.\n-     */\n-    public MathInstruction dadd() {\n-        return (MathInstruction) addInstruction(Constants.DADD);\n-    }\n-\n-    /**\n-     * Subtract the top two stack values. This instruction will result in\n-     * a <code>nop</code> until its type is set.\n-     */\n-    public MathInstruction xsub() {\n-        MathInstruction mi = math();\n-        return mi.setOperation(Constants.MATH_SUB);\n-    }\n-\n-    /**\n-     * Subtract the top two stack int values; the <code>isub</code> opcode.\n-     */\n-    public MathInstruction isub() {\n-        return (MathInstruction) addInstruction(Constants.ISUB);\n-    }\n-\n-    /**\n-     * Subtract the top two stack long values; the <code>lsub</code> opcode.\n-     */\n-    public MathInstruction lsub() {\n-        return (MathInstruction) addInstruction(Constants.LSUB);\n-    }\n-\n-    /**\n-     * Subtract the top two stack float values; the <code>fsub</code> opcode.\n-     */\n-    public MathInstruction fsub() {\n-        return (MathInstruction) addInstruction(Constants.FSUB);\n-    }\n-\n-    /**\n-     * Subtract the top two stack double values; the <code>dsub</code> opcode.\n-     */\n-    public MathInstruction dsub() {\n-        return (MathInstruction) addInstruction(Constants.DSUB);\n-    }\n-\n-    /**\n-     * Multiply the top two stack values. This instruction will result in\n-     * a <code>nop</code> until its type is set.\n-     */\n-    public MathInstruction xmul() {\n-        MathInstruction mi = math();\n-        return mi.setOperation(Constants.MATH_MUL);\n-    }\n-\n-    /**\n-     * Multiply the top two stack int values; the <code>imul</code> opcode.\n-     */\n-    public MathInstruction imul() {\n-        return (MathInstruction) addInstruction(Constants.IMUL);\n-    }\n-\n-    /**\n-     * Multiply the top two stack long values; the <code>lmul</code> opcode.\n-     */\n-    public MathInstruction lmul() {\n-        return (MathInstruction) addInstruction(Constants.LMUL);\n-    }\n-\n-    /**\n-     * Multiply the top two stack float values; the <code>fmul</code> opcode.\n-     */\n-    public MathInstruction fmul() {\n-        return (MathInstruction) addInstruction(Constants.FMUL);\n-    }\n-\n-    /**\n-     * Multiply the top two stack double values; the <code>dmul</code> opcode.\n-     */\n-    public MathInstruction dmul() {\n-        return (MathInstruction) addInstruction(Constants.DMUL);\n-    }\n-\n-    /**\n-     * Divide the top two stack values. This instruction will result in\n-     * a <code>nop</code> until its type is set.\n-     */\n-    public MathInstruction xdiv() {\n-        MathInstruction mi = math();\n-        return mi.setOperation(Constants.MATH_DIV);\n-    }\n-\n-    /**\n-     * Divide the top two stack int values; the <code>idiv</code> opcode.\n-     */\n-    public MathInstruction idiv() {\n-        return (MathInstruction) addInstruction(Constants.IDIV);\n-    }\n-\n-    /**\n-     * Divide the top two stack long values; the <code>ldiv</code> opcode.\n-     */\n-    public MathInstruction ldiv() {\n-        return (MathInstruction) addInstruction(Constants.LDIV);\n-    }\n-\n-    /**\n-     * Divide the top two stack float values; the <code>fdiv</code> opcode.\n-     */\n-    public MathInstruction fdiv() {\n-        return (MathInstruction) addInstruction(Constants.FDIV);\n-    }\n-\n-    /**\n-     * Divide the top two stack double values; the <code>ddiv</code> opcode.\n-     */\n-    public MathInstruction ddiv() {\n-        return (MathInstruction) addInstruction(Constants.DDIV);\n-    }\n-\n-    /**\n-     * Take the remainder of the top two stack values. This instruction will\n-     * result in a <code>nop</code> until its type is set.\n-     */\n-    public MathInstruction xrem() {\n-        MathInstruction mi = math();\n-        return mi.setOperation(Constants.MATH_REM);\n-    }\n-\n-    /**\n-     * Take the remainder of the top two int stack values; the\n-     * <code>irem</code> opcode.\n-     */\n-    public MathInstruction irem() {\n-        return (MathInstruction) addInstruction(Constants.IREM);\n-    }\n-\n-    /**\n-     * Take the remainder of the top two long stack values; the\n-     * <code>lrem</code> opcode.\n-     */\n-    public MathInstruction lrem() {\n-        return (MathInstruction) addInstruction(Constants.LREM);\n-    }\n-\n-    /**\n-     * Take the remainder of the top two float stack values; the\n-     * <code>frem</code> opcode.\n-     */\n-    public MathInstruction frem() {\n-        return (MathInstruction) addInstruction(Constants.FREM);\n-    }\n-\n-    /**\n-     * Take the remainder of the top two double stack values; the\n-     * <code>drem</code> opcode.\n-     */\n-    public MathInstruction drem() {\n-        return (MathInstruction) addInstruction(Constants.DREM);\n-    }\n-\n-    /**\n-     * Negate the top stack value. This instruction will result in a\n-     * <code>nop</code> until its type is set.\n-     */\n-    public MathInstruction xneg() {\n-        MathInstruction mi = math();\n-        return mi.setOperation(Constants.MATH_NEG);\n-    }\n-\n-    /**\n-     * Negate the top stack int value; the <code>ineg</code> opcode.\n-     */\n-    public MathInstruction ineg() {\n-        return (MathInstruction) addInstruction(Constants.INEG);\n-    }\n-\n-    /**\n-     * Negate the top stack long value; the <code>lneg</code> opcode.\n-     */\n-    public MathInstruction lneg() {\n-        return (MathInstruction) addInstruction(Constants.LNEG);\n-    }\n-\n-    /**\n-     * Negate the top stack float value; the <code>fneg</code> opcode.\n-     */\n-    public MathInstruction fneg() {\n-        return (MathInstruction) addInstruction(Constants.FNEG);\n-    }\n-\n-    /**\n-     * Negate the top stack double value; the <code>dneg</code> opcode.\n-     */\n-    public MathInstruction dneg() {\n-        return (MathInstruction) addInstruction(Constants.DNEG);\n-    }\n-\n-    /**\n-     * Shift the top stack values. This instruction will result in a\n-     * <code>nop</code> until its type is set.\n-     */\n-    public MathInstruction xshl() {\n-        MathInstruction mi = math();\n-        return mi.setOperation(Constants.MATH_SHL);\n-    }\n-\n-    /**\n-     * Shift the top stack int values; the <code>ishl</code> opcode.\n-     */\n-    public MathInstruction ishl() {\n-        return (MathInstruction) addInstruction(Constants.ISHL);\n-    }\n-\n-    /**\n-     * Shift the top stack long values; the <code>lshl</code> opcode.\n-     */\n-    public MathInstruction lshl() {\n-        return (MathInstruction) addInstruction(Constants.LSHL);\n-    }\n-\n-    /**\n-     * Shift the top stack values. This instruction will result in a\n-     * <code>nop</code> until its type is set.\n-     */\n-    public MathInstruction xshr() {\n-        MathInstruction mi = math();\n-        return mi.setOperation(Constants.MATH_SHR);\n-    }\n-\n-    /**\n-     * Shift the top stack int values; the <code>ishr</code> opcode.\n-     */\n-    public MathInstruction ishr() {\n-        return (MathInstruction) addInstruction(Constants.ISHR);\n-    }\n-\n-    /**\n-     * Shift the top stack long values; the <code>lshr</code> opcode.\n-     */\n-    public MathInstruction lshr() {\n-        return (MathInstruction) addInstruction(Constants.LSHR);\n-    }\n-\n-    /**\n-     * Shift the top stack values. This instruction will result in a\n-     * <code>nop</code> until its type is set.\n-     */\n-    public MathInstruction xushr() {\n-        MathInstruction mi = math();\n-        return mi.setOperation(Constants.MATH_USHR);\n-    }\n-\n-    /**\n-     * Shift the top stack int values; the <code>iushr</code> opcode.\n-     */\n-    public MathInstruction iushr() {\n-        return (MathInstruction) addInstruction(Constants.IUSHR);\n-    }\n-\n-    /**\n-     * Shift the top stack long values; the <code>lushr</code> opcode.\n-     */\n-    public MathInstruction lushr() {\n-        return (MathInstruction) addInstruction(Constants.LUSHR);\n-    }\n-\n-    /**\n-     * Take the mathematical and of the top two stack values. This instruction\n-     * results in a <code>nop</code> until its type is set.\n-     */\n-    public MathInstruction xand() {\n-        MathInstruction mi = math();\n-        return mi.setOperation(Constants.MATH_AND);\n-    }\n-\n-    /**\n-     * Take the mathematical and of the top two stack int values; the\n-     * <code>iand</code> opcode.\n-     */\n-    public MathInstruction iand() {\n-        return (MathInstruction) addInstruction(Constants.IAND);\n-    }\n-\n-    /**\n-     * Take the mathematical and of the top two stack long values; the\n-     * <code>land</code> opcode.\n-     */\n-    public MathInstruction land() {\n-        return (MathInstruction) addInstruction(Constants.LAND);\n-    }\n-\n-    /**\n-     * Take the mathematical or of the top two stack values. This instruction\n-     * results in a <code>nop</code> until its type is set.\n-     */\n-    public MathInstruction xor() {\n-        MathInstruction mi = math();\n-        return mi.setOperation(Constants.MATH_OR);\n-    }\n-\n-    /**\n-     * Take the mathematical or of the top two stack int values; the\n-     * <code>ior</code> opcode.\n-     */\n-    public MathInstruction ior() {\n-        return (MathInstruction) addInstruction(Constants.IOR);\n-    }\n-\n-    /**\n-     * Take the mathematical or of the top two stack long values; the\n-     * <code>lor</code> opcode.\n-     */\n-    public MathInstruction lor() {\n-        return (MathInstruction) addInstruction(Constants.LOR);\n-    }\n-\n-    /**\n-     * Take the mathematical xor of the top two stack values. This instruction\n-     * results in a <code>nop</code> until its type is set.\n-     */\n-    public MathInstruction xxor() {\n-        MathInstruction mi = math();\n-        return mi.setOperation(Constants.MATH_XOR);\n-    }\n-\n-    /**\n-     * Take the mathematical xor of the top two stack int values; the\n-     * <code>ixor</code> opcode.\n-     */\n-    public MathInstruction ixor() {\n-        return (MathInstruction) addInstruction(Constants.IXOR);\n-    }\n-\n-    /**\n-     * Take the mathematical xor of the top two stack long values; the\n-     * <code>lxor</code> opcode.\n-     */\n-    public MathInstruction lxor() {\n-        return (MathInstruction) addInstruction(Constants.LXOR);\n-    }\n-\n-    /**\n-     * Convert the top stack value to another type. This instruction\n-     * will result in a <code>nop</code> until the types to convert\n-     * between are set.\n-     */\n-    public ConvertInstruction convert() {\n-        return (ConvertInstruction) addInstruction\n-            (new ConvertInstruction(this));\n-    }\n-\n-    /**\n-     * Compare the top two stack values. This instruction will result in a\n-     * <code>nop</code> until its type is set.\n-     */\n-    public CmpInstruction xcmp() {\n-        return (CmpInstruction) addInstruction(new CmpInstruction(this));\n-    }\n-\n-    /**\n-     * Compare the top two stack values; the <code>lcmp</code> opcode.\n-     */\n-    public CmpInstruction lcmp() {\n-        return (CmpInstruction) addInstruction(Constants.LCMP);\n-    }\n-\n-    /**\n-     * Compare the top two stack values; the <code>fcmpl</code> opcode.\n-     */\n-    public CmpInstruction fcmpl() {\n-        return (CmpInstruction) addInstruction(Constants.FCMPL);\n-    }\n-\n-    /**\n-     * Compare the top two stack values; the <code>fcmpg</code> opcode.\n-     */\n-    public CmpInstruction fcmpg() {\n-        return (CmpInstruction) addInstruction(Constants.FCMPG);\n-    }\n-\n-    /**\n-     * Compare the top two stack values; the <code>dcmpl</code> opcode.\n-     */\n-    public CmpInstruction dcmpl() {\n-        return (CmpInstruction) addInstruction(Constants.DCMPL);\n-    }\n-\n-    /**\n-     * Compare the top two stack values; the <code>dcmpg</code> opcode.\n-     */\n-    public CmpInstruction dcmpg() {\n-        return (CmpInstruction) addInstruction(Constants.DCMPG);\n-    }\n-\n-    /**\n-     * The <code>ifeq</code> opcode.\n-     */\n-    public IfInstruction ifeq() {\n-        return (IfInstruction) addInstruction(Constants.IFEQ);\n-    }\n-\n-    /**\n-     * The <code>ifne</code> opcode.\n-     */\n-    public IfInstruction ifne() {\n-        return (IfInstruction) addInstruction(Constants.IFNE);\n-    }\n-\n-    /**\n-     * The <code>iflt</code> opcode.\n-     */\n-    public IfInstruction iflt() {\n-        return (IfInstruction) addInstruction(Constants.IFLT);\n-    }\n-\n-    /**\n-     * The <code>ifge</code> opcode.\n-     */\n-    public IfInstruction ifge() {\n-        return (IfInstruction) addInstruction(Constants.IFGE);\n-    }\n-\n-    /**\n-     * The <code>ifgt</code> opcode.\n-     */\n-    public IfInstruction ifgt() {\n-        return (IfInstruction) addInstruction(Constants.IFGT);\n-    }\n-\n-    /**\n-     * The <code>ifle</code> opcode.\n-     */\n-    public IfInstruction ifle() {\n-        return (IfInstruction) addInstruction(Constants.IFLE);\n-    }\n-\n-    /**\n-     * The <code>ificmpeq</code> opcode.\n-     */\n-    public IfInstruction ificmpeq() {\n-        return (IfInstruction) addInstruction(Constants.IFICMPEQ);\n-    }\n-\n-    /**\n-     * The <code>ificmpne</code> opcode.\n-     */\n-    public IfInstruction ificmpne() {\n-        return (IfInstruction) addInstruction(Constants.IFICMPNE);\n-    }\n-\n-    /**\n-     * The <code>ificmplt</code> opcode.\n-     */\n-    public IfInstruction ificmplt() {\n-        return (IfInstruction) addInstruction(Constants.IFICMPLT);\n-    }\n-\n-    /**\n-     * The <code>ificmpge</code> opcode.\n-     */\n-    public IfInstruction ificmpge() {\n-        return (IfInstruction) addInstruction(Constants.IFICMPGE);\n-    }\n-\n-    /**\n-     * The <code>ificmpgt</code> opcode.\n-     */\n-    public IfInstruction ificmpgt() {\n-        return (IfInstruction) addInstruction(Constants.IFICMPGT);\n-    }\n-\n-    /**\n-     * The <code>ificmple</code> opcode.\n-     */\n-    public IfInstruction ificmple() {\n-        return (IfInstruction) addInstruction(Constants.IFICMPLE);\n-    }\n-\n-    /**\n-     * The <code>ifacmpeq</code> opcode.\n-     */\n-    public IfInstruction ifacmpeq() {\n-        return (IfInstruction) addInstruction(Constants.IFACMPEQ);\n-    }\n-\n-    /**\n-     * The <code>ifacmpne</code> opcode.\n-     */\n-    public IfInstruction ifacmpne() {\n-        return (IfInstruction) addInstruction(Constants.IFACMPNE);\n-    }\n-\n-    /**\n-     * The <code>ifnull</code> opcode.\n-     */\n-    public IfInstruction ifnull() {\n-        return (IfInstruction) addInstruction(Constants.IFNULL);\n-    }\n-\n-    /**\n-     * The <code>ifnonnull</code> opcode.\n-     */\n-    public IfInstruction ifnonnull() {\n-        return (IfInstruction) addInstruction(Constants.IFNONNULL);\n-    }\n-\n-    /**\n-     * The <code>go2</code> opcode.\n-     */\n-    public JumpInstruction go2() {\n-        return (JumpInstruction) addInstruction(Constants.GOTO);\n-    }\n-\n-    /**\n-     * The <code>jsr</code> opcode used in implementing <code>finally</code>\n-     * clauses.\n-     */\n-    public JumpInstruction jsr() {\n-        return (JumpInstruction) addInstruction(Constants.JSR);\n-    }\n-\n-    /**\n-     * The <code>tableswitch</code> opcode.\n-     */\n-    public TableSwitchInstruction tableswitch() {\n-        return (TableSwitchInstruction) addInstruction(Constants.TABLESWITCH);\n-    }\n-\n-    /**\n-     * The <code>lookupswitch</code> opcode.\n-     */\n-    public LookupSwitchInstruction lookupswitch() {\n-        return (LookupSwitchInstruction) addInstruction(Constants.LOOKUPSWITCH);\n-    }\n-\n-    /**\n-     * Return from a method. This method will result in a\n-     * <code>nop</code> until its type is set.\n-     */\n-    public ReturnInstruction xreturn() {\n-        return (ReturnInstruction) addInstruction(new ReturnInstruction(this));\n-    }\n-\n-    /**\n-     * Return void from a method; the <code>return</code> opcode.\n-     */\n-    public ReturnInstruction vreturn() {\n-        return (ReturnInstruction) addInstruction(Constants.RETURN);\n-    }\n-\n-    /**\n-     * Return an int from a method; the <code>ireturn</code> opcode.\n-     */\n-    public ReturnInstruction ireturn() {\n-        return (ReturnInstruction) addInstruction(Constants.IRETURN);\n-    }\n-\n-    /**\n-     * Return a long from a method; the <code>lreturn</code> opcode.\n-     */\n-    public ReturnInstruction lreturn() {\n-        return (ReturnInstruction) addInstruction(Constants.LRETURN);\n-    }\n-\n-    /**\n-     * Return a float from a method; the <code>freturn</code> opcode.\n-     */\n-    public ReturnInstruction freturn() {\n-        return (ReturnInstruction) addInstruction(Constants.FRETURN);\n-    }\n-\n-    /**\n-     * Return a double from a method; the <code>dreturn</code> opcode.\n-     */\n-    public ReturnInstruction dreturn() {\n-        return (ReturnInstruction) addInstruction(Constants.DRETURN);\n-    }\n-\n-    /**\n-     * Return an object from a method; the <code>areturn</code> opcode.\n-     */\n-    public ReturnInstruction areturn() {\n-        return (ReturnInstruction) addInstruction(Constants.ARETURN);\n-    }\n-\n-    /**\n-     * Load the value from a field onto the stack; the <code>getfield</code>\n-     * opcode.\n-     */\n-    public GetFieldInstruction getfield() {\n-        return (GetFieldInstruction) addInstruction(Constants.GETFIELD);\n-    }\n-\n-    /**\n-     * Load the value from a static field onto the stack; the\n-     * <code>getstatic</code> opcode.\n-     */\n-    public GetFieldInstruction getstatic() {\n-        return (GetFieldInstruction) addInstruction(Constants.GETSTATIC);\n-    }\n-\n-    /**\n-     * Place the value of a field onto the stack; the <code>putfield</code>\n-     * opcode.\n-     */\n-    public PutFieldInstruction putfield() {\n-        return (PutFieldInstruction) addInstruction(Constants.PUTFIELD);\n-    }\n-\n-    /**\n-     * Place the value of a static field onto the stack; the\n-     * <code>putstatic</code> opcode.\n-     */\n-    public PutFieldInstruction putstatic() {\n-        return (PutFieldInstruction) addInstruction(Constants.PUTSTATIC);\n-    }\n-\n-    /**\n-     * Invoke a virtual method; the <code>invokevirtual</code> opcode.\n-     */\n-    public MethodInstruction invokevirtual() {\n-        return (MethodInstruction) addInstruction(Constants.INVOKEVIRTUAL);\n-    }\n-\n-    /**\n-     * Invoke a method non-virtually, as for constructors and superclass\n-     * methods; the <code>invokespecial</code> opcode.\n-     */\n-    public MethodInstruction invokespecial() {\n-        return (MethodInstruction) addInstruction(Constants.INVOKESPECIAL);\n-    }\n-\n-    /**\n-     * Invoke a method on an interface; the <code>invokeinterface</code> opcode.\n-     */\n-    public MethodInstruction invokeinterface() {\n-        return (MethodInstruction) addInstruction(Constants.INVOKEINTERFACE);\n-    }\n-\n-    /**\n-     * Invoke a static method; the <code>invokestatic</code> opcode.\n-     */\n-    public MethodInstruction invokestatic() {\n-        return (MethodInstruction) addInstruction(Constants.INVOKESTATIC);\n-    }\n-\n-    /**\n-     * Create a new instance of an object; the <code>new</code> opcode.\n-     */\n-    public ClassInstruction anew() {\n-        return (ClassInstruction) addInstruction(Constants.NEW);\n-    }\n-\n-    /**\n-     * Create a new instance of an object array; the <code>anew</code> opcode.\n-     */\n-    public ClassInstruction anewarray() {\n-        return (ClassInstruction) addInstruction(Constants.ANEWARRAY);\n-    }\n-\n-    /**\n-     * Cast an object on the stack to another type; the <code>checkcast</code>\n-     * opcode.\n-     */\n-    public ClassInstruction checkcast() {\n-        return (ClassInstruction) addInstruction(Constants.CHECKCAST);\n-    }\n-\n-    /**\n-     * Test if a stack object is an instance of a class; the\n-     * <code>instanceof</code> opcode.\n-     */\n-    public ClassInstruction isinstance() {\n-        return (ClassInstruction) addInstruction(Constants.INSTANCEOF);\n-    }\n-\n-    /**\n-     * Create a new multidimensional array; the <code>multianewarray</code>\n-     * opcode.\n-     */\n-    public MultiANewArrayInstruction multianewarray() {\n-        return (MultiANewArrayInstruction) addInstruction\n-            (Constants.MULTIANEWARRAY);\n-    }\n-\n-    /**\n-     * Create a new array of a primitive type; the <code>newarray</code> opcode.\n-     */\n-    public NewArrayInstruction newarray() {\n-        return (NewArrayInstruction) addInstruction(Constants.NEWARRAY);\n-    }\n-\n-    /**\n-     * Get the length of an array on the stack; the <code>arraylength</code>\n-     * opcode.\n-     */\n-    public Instruction arraylength() {\n-        return addInstruction(Constants.ARRAYLENGTH);\n-    }\n-\n-    /**\n-     * Throw an exception; the <code>athrow</code> opcode.\n-     */\n-    public Instruction athrow() {\n-        return addInstruction(Constants.ATHROW);\n-    }\n-\n-    /**\n-     * The <code>monitorenter</code> opcode.\n-     */\n-    public MonitorEnterInstruction monitorenter() {\n-        return (MonitorEnterInstruction) addInstruction(Constants.MONITORENTER);\n-    }\n-\n-    /**\n-     * The <code>monitorexit</code> opcode.\n-     */\n-    public MonitorExitInstruction monitorexit() {\n-        return (MonitorExitInstruction) addInstruction(Constants.MONITOREXIT);\n-    }\n-\n-    /////////////////////////\n-    // Wholisitic operations\n-    /////////////////////////\n-\n-    /**\n-     * Return all the Instructions of this method.\n-     */\n-    public Instruction[] getInstructions() {\n-        Instruction[] arr = new Instruction[_size];\n-        int i = 0;\n-        for (CodeEntry entry = _head.next; entry != _tail; entry = entry.next)\n-            arr[i++] = (Instruction) entry;\n-        return arr;\n-    }\n-\n-    int getLength() {\n-        // covers maxStack, maxLocals, codeLength, exceptionTableLength,\n-        // attributeCount\n-        int length = 12;\n-\n-        // add code\n-        try {\n-            length += toByteArray().length;\n-        } catch (IOException ioe) {\n-            throw new RuntimeException(ioe.toString());\n-        }\n-\n-        // add exception reps; each is 8 bytes\n-        length += 8 * _handlers.size();\n-\n-        // add all attribute lengths\n-        Attribute[] attrs = getAttributes();\n-        for (int i = 0; i < attrs.length; i++)\n-            length += attrs[i].getLength() + 6;\n-        return length;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterCode(this);\n-\n-        Instruction ins;\n-        for (CodeEntry entry = _head.next; entry != _tail; entry = entry.next) {\n-            ins = (Instruction) entry;\n-            visit.enterInstruction(ins);\n-            ins.acceptVisit(visit);\n-            visit.exitInstruction(ins);\n-        }\n-        for (Iterator i = _handlers.iterator(); i.hasNext();)\n-            ((ExceptionHandler) i.next()).acceptVisit(visit);\n-        visitAttributes(visit);\n-\n-        visit.exitCode(this);\n-    }\n-\n-    //////////////////////////\n-    // Convenience operations\n-    //////////////////////////\n-\n-    /**\n-     * Return line number information for the code.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @param add if true, a new line number table will be added\n-     * if not already present\n-     * @return the line number information, or null if none\n-     *         and the <code>add</code> param is set to false\n-     */\n-    public LineNumberTable getLineNumberTable(boolean add) {\n-        LineNumberTable attr = (LineNumberTable) getAttribute\n-            (Constants.ATTR_LINENUMBERS);\n-        if (!add || attr != null)\n-            return attr;\n-\n-        return (LineNumberTable) addAttribute(Constants.ATTR_LINENUMBERS);\n-    }\n-\n-    /**\n-     * Remove the line number table for the code.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @return true if there was a table to remove\n-     */\n-    public boolean removeLineNumberTable() {\n-        return removeAttribute(Constants.ATTR_LINENUMBERS);\n-    }\n-\n-    /**\n-     * Return local variable information for the code.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @param add if true, a new local variable table will be\n-     * added if not already present\n-     * @return the local variable information, or null if none\n-     *         and the <code>add</code> param is set to false\n-     */\n-    public LocalVariableTable getLocalVariableTable(boolean add) {\n-        LocalVariableTable attr = (LocalVariableTable) getAttribute\n-            (Constants.ATTR_LOCALS);\n-        if (!add || attr != null)\n-            return attr;\n-\n-        return (LocalVariableTable) addAttribute(Constants.ATTR_LOCALS);\n-    }\n-\n-    /**\n-     * Remove the local variable table for the code.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @return true if there was a table to remove\n-     */\n-    public boolean removeLocalVariableTables() {\n-        return removeAttribute(Constants.ATTR_LOCALS);\n-    }\n-\n-    /**\n-     * Return local variable generics information for the code.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @param add if true, a new local variable type table will be\n-     * added if not already present\n-     * @return the local variable type information, or null if none\n-     *         and the <code>add</code> param is set to false\n-     */\n-    public LocalVariableTypeTable getLocalVariableTypeTable(boolean add) {\n-        LocalVariableTypeTable attr = (LocalVariableTypeTable) getAttribute\n-            (Constants.ATTR_LOCAL_TYPES);\n-        if (!add || attr != null)\n-            return attr;\n-\n-        return (LocalVariableTypeTable) addAttribute\n-            (Constants.ATTR_LOCAL_TYPES);\n-    }\n-\n-    /**\n-     * Remove the local variable type table for the code.\n-     * Acts internally through the {@link Attributes} interface.\n-     *\n-     * @return true if there was a table to remove\n-     */\n-    public boolean removeLocalVariableTypeTables() {\n-        return removeAttribute(Constants.ATTR_LOCAL_TYPES);\n-    }\n-\n-    //////////////////\n-    // I/O operations\n-    //////////////////\n-\n-    void read(Attribute attr) {\n-        Code orig = (Code) attr;\n-\n-        _maxStack = orig.getMaxStack();\n-        _maxLocals = orig.getMaxLocals();\n-\n-        // clear existing code\n-        _head.next = _tail;\n-        _tail.prev = _head;\n-        _size = 0;\n-        beforeFirst();\n-        _handlers.clear();\n-\n-        // copy all instructions; don't set constant instruction values until\n-        // instruction ptrs have been updated in case the instruction width\n-        // changes because of differences in the constant pool(LDC vs LDCW)\n-        Instruction ins;\n-        Instruction origIns;\n-        for (CodeEntry entry = orig._head.next; entry != orig._tail;\n-            entry = entry.next) {\n-            origIns = (Instruction) entry;\n-            ins = addInstruction(origIns.getOpcode());\n-            if (!(ins instanceof ConstantInstruction))\n-                ins.read(origIns);\n-        }\n-\n-        // copy exception handlers\n-        ExceptionHandler[] origHandlers = orig.getExceptionHandlers();\n-        ExceptionHandler handler;\n-        for (int i = 0; i < origHandlers.length; i++) {\n-            handler = addExceptionHandler();\n-            handler.read(origHandlers[i]);\n-            handler.updateTargets();\n-        }\n-\n-        // reset all opcode ptrs to the new copied opcodes\n-        updateInstructionPointers();\n-        setAttributes(orig.getAttributes());\n-\n-        // setup local variable markers\n-        LocalVariableTable locals = getLocalVariableTable(false);\n-        if (locals != null)\n-            locals.updateTargets();\n-\n-        // setup local variable markers\n-        LocalVariableTypeTable localTypes = getLocalVariableTypeTable(false);\n-        if (localTypes != null)\n-            localTypes.updateTargets();\n-\n-        // setup line number markers\n-        LineNumberTable lines = getLineNumberTable(false);\n-        if (lines != null)\n-            lines.updateTargets();\n-\n-        // now copy constant instruction values\n-        CodeEntry copy = _head.next;\n-        for (CodeEntry entry = orig._head.next; entry != orig._tail;\n-            entry = entry.next, copy = copy.next) {\n-            if (entry instanceof ConstantInstruction)\n-                ((ConstantInstruction) copy).read((Instruction) entry);\n-        }\n-\n-        beforeFirst();\n-    }\n-\n-    void read(DataInput in, int length) throws IOException {\n-        _maxStack = in.readUnsignedShort();\n-        _maxLocals = in.readUnsignedShort();\n-\n-        readCode(in, in.readInt());\n-\n-        _handlers.clear();\n-        int exceptionCount = in.readUnsignedShort();\n-        ExceptionHandler excep;\n-        for (int i = 0; i < exceptionCount; i++) {\n-            excep = addExceptionHandler();\n-            excep.read(in);\n-            excep.updateTargets();\n-        }\n-\n-        readAttributes(in);\n-\n-        // setup local variable markers\n-        LocalVariableTable locals = getLocalVariableTable(false);\n-        if (locals != null)\n-            locals.updateTargets();\n-\n-        // setup local variable markers\n-        LocalVariableTypeTable localTypes = getLocalVariableTypeTable(false);\n-        if (localTypes != null)\n-            localTypes.updateTargets();\n-\n-        // setup line number markers\n-        LineNumberTable lines = getLineNumberTable(false);\n-        if (lines != null)\n-            lines.updateTargets();\n-    }\n-\n-    void write(DataOutput out, int length) throws IOException {\n-        out.writeShort(_maxStack);\n-        out.writeShort(_maxLocals);\n-\n-        byte[] code = toByteArray();\n-        out.writeInt(code.length);\n-        out.write(code);\n-\n-        out.writeShort(_handlers.size());\n-        for (Iterator itr = _handlers.iterator(); itr.hasNext();)\n-            ((ExceptionHandler) itr.next()).write(out);\n-\n-        writeAttributes(out);\n-    }\n-\n-    private void readCode(DataInput in, int len) throws IOException {\n-        _head.next = _tail;\n-        _tail.prev = _head;\n-        _size = 0;\n-        beforeFirst();\n-\n-        Instruction ins;\n-        for (int byteIndex = 0; byteIndex < len;) {\n-            ins = addInstruction(in.readUnsignedByte());\n-            ins.read(in);\n-            byteIndex += ins.getLength();\n-        }\n-\n-        updateInstructionPointers();\n-        beforeFirst();\n-    }\n-\n-    /**\n-     * Ensures that all the opcode targets are set up correctly.\n-     */\n-    private void updateInstructionPointers() {\n-        for (CodeEntry entry = _head.next; entry != _tail; entry = entry.next)\n-            if (entry instanceof InstructionPtr)\n-                ((InstructionPtr) entry).updateTargets();\n-    }\n-\n-    /**\n-     * Returns the byteIndex of the given instruction.\n-     */\n-    int getByteIndex(Instruction ins) {\n-        int byteIndex = 0;\n-        for (CodeEntry entry = _head.next; entry != _tail; entry = entry.next) {\n-            if (entry == ins)\n-                return byteIndex;\n-            byteIndex += ((Instruction) entry).getLength();\n-        }\n-        throw new IllegalArgumentException(\"ins.owner != this\");\n-    }\n-\n-    /**\n-     * Returns the instruction in this code block found at the given byte index.\n-     */\n-    Instruction getInstruction(int byteIndex) {\n-        if (byteIndex < 0)\n-            return null;\n-        int curIndex = 0;\n-        for (CodeEntry entry = _head.next; entry != _tail; entry = entry.next) {\n-            if (byteIndex == curIndex)\n-                return (Instruction) entry;\n-            curIndex += ((Instruction) entry).getLength();\n-        }\n-        throw new IllegalArgumentException(String.valueOf(byteIndex));\n-    }\n-\n-    /**\n-     * Returns the number of instructions that occur before 'ins'\n-     * in this code block that 'ins' is a part of.\n-     *\n-     * @throws IllegalArgumentException if this code block is not the owner\n-     * of ins\n-     */\n-    private int indexOf(Instruction ins) {\n-        int i = 0;\n-        for (CodeEntry entry = _head.next; entry != _tail;\n-            entry = entry.next, i++)\n-            if (entry == ins)\n-                return i;\n-        throw new IllegalArgumentException(\"ins.code != this\");\n-    }\n-\n-    private void writeCode(DataOutput out) throws IOException {\n-        Instruction ins;\n-        for (CodeEntry entry = _head.next; entry != _tail; entry = entry.next) {\n-            ins = (Instruction) entry;\n-            out.writeByte(ins.getOpcode());\n-            ins.write(out);\n-        }\n-    }\n-\n-    private byte[] toByteArray() throws IOException {\n-        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n-        DataOutputStream stream = new DataOutputStream(byteStream);\n-        try {\n-            writeCode(stream);\n-            return byteStream.toByteArray();\n-        }\n-        finally {\n-            try {\n-                stream.close();\n-            } catch (Exception e) {\n-            }\n-        }\n-    }\n-\n-    private void fromByteArray(byte[] code) throws IOException {\n-        if (code == null) {\n-            _head.next = _tail;\n-            _tail.prev = _head;\n-            _size = 0;\n-        } else {\n-            DataInputStream stream = new DataInputStream\n-                (new ByteArrayInputStream(code));\n-            try {\n-                readCode(stream, code.length);\n-            }\n-            finally {\n-                try {\n-                    stream.close();\n-                } catch (Exception e) {\n-                }\n-            }\n-        }\n-    }\n-\n-    private Instruction addInstruction(Instruction ins) {\n-        _ci.add(ins);\n-        return ins;\n-    }\n-\n-    private Instruction addInstruction(int opcode) {\n-        return addInstruction(createInstruction(opcode));\n-    }\n-\n-    /**\n-     * Creates an Instruction, with this code block as the owner.\n-     * Note that the Instruction is not added to this Code block.\n-     */\n-    private Instruction createInstruction(int opcode) {\n-        switch (opcode) {\n-            case Constants.NOP:\n-            case Constants.ARRAYLENGTH:\n-            case Constants.ATHROW:\n-                return new Instruction(this, opcode);\n-            case Constants.ACONSTNULL:\n-            case Constants.ICONSTM1:\n-            case Constants.ICONST0:\n-            case Constants.ICONST1:\n-            case Constants.ICONST2:\n-            case Constants.ICONST3:\n-            case Constants.ICONST4:\n-            case Constants.ICONST5:\n-            case Constants.LCONST0:\n-            case Constants.LCONST1:\n-            case Constants.FCONST0:\n-            case Constants.FCONST1:\n-            case Constants.FCONST2:\n-            case Constants.DCONST0:\n-            case Constants.DCONST1:\n-            case Constants.BIPUSH:\n-            case Constants.SIPUSH:\n-            case Constants.LDC:\n-            case Constants.LDCW:\n-            case Constants.LDC2W:\n-                return new ConstantInstruction(this, opcode);\n-            case Constants.ILOAD:\n-            case Constants.LLOAD:\n-            case Constants.FLOAD:\n-            case Constants.DLOAD:\n-            case Constants.ALOAD:\n-            case Constants.ILOAD0:\n-            case Constants.ILOAD1:\n-            case Constants.ILOAD2:\n-            case Constants.ILOAD3:\n-            case Constants.LLOAD0:\n-            case Constants.LLOAD1:\n-            case Constants.LLOAD2:\n-            case Constants.LLOAD3:\n-            case Constants.FLOAD0:\n-            case Constants.FLOAD1:\n-            case Constants.FLOAD2:\n-            case Constants.FLOAD3:\n-            case Constants.DLOAD0:\n-            case Constants.DLOAD1:\n-            case Constants.DLOAD2:\n-            case Constants.DLOAD3:\n-            case Constants.ALOAD0:\n-            case Constants.ALOAD1:\n-            case Constants.ALOAD2:\n-            case Constants.ALOAD3:\n-                return new LoadInstruction(this, opcode);\n-            case Constants.IALOAD:\n-            case Constants.LALOAD:\n-            case Constants.FALOAD:\n-            case Constants.DALOAD:\n-            case Constants.AALOAD:\n-            case Constants.BALOAD:\n-            case Constants.CALOAD:\n-            case Constants.SALOAD:\n-                return new ArrayLoadInstruction(this, opcode);\n-            case Constants.ISTORE:\n-            case Constants.LSTORE:\n-            case Constants.FSTORE:\n-            case Constants.DSTORE:\n-            case Constants.ASTORE:\n-            case Constants.ISTORE0:\n-            case Constants.ISTORE1:\n-            case Constants.ISTORE2:\n-            case Constants.ISTORE3:\n-            case Constants.LSTORE0:\n-            case Constants.LSTORE1:\n-            case Constants.LSTORE2:\n-            case Constants.LSTORE3:\n-            case Constants.FSTORE0:\n-            case Constants.FSTORE1:\n-            case Constants.FSTORE2:\n-            case Constants.FSTORE3:\n-            case Constants.DSTORE0:\n-            case Constants.DSTORE1:\n-            case Constants.DSTORE2:\n-            case Constants.DSTORE3:\n-            case Constants.ASTORE0:\n-            case Constants.ASTORE1:\n-            case Constants.ASTORE2:\n-            case Constants.ASTORE3:\n-                return new StoreInstruction(this, opcode);\n-            case Constants.IASTORE:\n-            case Constants.LASTORE:\n-            case Constants.FASTORE:\n-            case Constants.DASTORE:\n-            case Constants.AASTORE:\n-            case Constants.BASTORE:\n-            case Constants.CASTORE:\n-            case Constants.SASTORE:\n-                return new ArrayStoreInstruction(this, opcode);\n-            case Constants.POP:\n-            case Constants.POP2:\n-            case Constants.DUP:\n-            case Constants.DUPX1:\n-            case Constants.DUPX2:\n-            case Constants.DUP2:\n-            case Constants.DUP2X1:\n-            case Constants.DUP2X2:\n-            case Constants.SWAP:\n-                return new StackInstruction(this, opcode);\n-            case Constants.IADD:\n-            case Constants.LADD:\n-            case Constants.FADD:\n-            case Constants.DADD:\n-            case Constants.ISUB:\n-            case Constants.LSUB:\n-            case Constants.FSUB:\n-            case Constants.DSUB:\n-            case Constants.IMUL:\n-            case Constants.LMUL:\n-            case Constants.FMUL:\n-            case Constants.DMUL:\n-            case Constants.IDIV:\n-            case Constants.LDIV:\n-            case Constants.FDIV:\n-            case Constants.DDIV:\n-            case Constants.IREM:\n-            case Constants.LREM:\n-            case Constants.FREM:\n-            case Constants.DREM:\n-            case Constants.INEG:\n-            case Constants.LNEG:\n-            case Constants.FNEG:\n-            case Constants.DNEG:\n-            case Constants.ISHL:\n-            case Constants.LSHL:\n-            case Constants.ISHR:\n-            case Constants.LSHR:\n-            case Constants.IUSHR:\n-            case Constants.LUSHR:\n-            case Constants.IAND:\n-            case Constants.LAND:\n-            case Constants.IOR:\n-            case Constants.LOR:\n-            case Constants.IXOR:\n-            case Constants.LXOR:\n-                return new MathInstruction(this, opcode);\n-            case Constants.IINC:\n-                return new IIncInstruction(this);\n-            case Constants.I2L:\n-            case Constants.I2F:\n-            case Constants.I2D:\n-            case Constants.L2I:\n-            case Constants.L2F:\n-            case Constants.L2D:\n-            case Constants.F2I:\n-            case Constants.F2L:\n-            case Constants.F2D:\n-            case Constants.D2I:\n-            case Constants.D2L:\n-            case Constants.D2F:\n-            case Constants.I2B:\n-            case Constants.I2C:\n-            case Constants.I2S:\n-                return new ConvertInstruction(this, opcode);\n-            case Constants.LCMP:\n-            case Constants.FCMPL:\n-            case Constants.FCMPG:\n-            case Constants.DCMPL:\n-            case Constants.DCMPG:\n-                return new CmpInstruction(this, opcode);\n-            case Constants.IFEQ:\n-            case Constants.IFNE:\n-            case Constants.IFLT:\n-            case Constants.IFGE:\n-            case Constants.IFGT:\n-            case Constants.IFLE:\n-            case Constants.IFICMPEQ:\n-            case Constants.IFICMPNE:\n-            case Constants.IFICMPLT:\n-            case Constants.IFICMPGE:\n-            case Constants.IFICMPGT:\n-            case Constants.IFICMPLE:\n-            case Constants.IFACMPEQ:\n-            case Constants.IFACMPNE:\n-            case Constants.IFNULL:\n-            case Constants.IFNONNULL:\n-                return new IfInstruction(this, opcode);\n-            case Constants.GOTO:\n-            case Constants.JSR:\n-            case Constants.GOTOW:\n-            case Constants.JSRW:\n-                return new JumpInstruction(this, opcode);\n-            case Constants.RET:\n-                return new RetInstruction(this);\n-            case Constants.TABLESWITCH:\n-                return new TableSwitchInstruction(this);\n-            case Constants.LOOKUPSWITCH:\n-                return new LookupSwitchInstruction(this);\n-            case Constants.IRETURN:\n-            case Constants.LRETURN:\n-            case Constants.FRETURN:\n-            case Constants.DRETURN:\n-            case Constants.ARETURN:\n-            case Constants.RETURN:\n-                return new ReturnInstruction(this, opcode);\n-            case Constants.GETSTATIC:\n-            case Constants.GETFIELD:\n-                return new GetFieldInstruction(this, opcode);\n-            case Constants.PUTSTATIC:\n-            case Constants.PUTFIELD:\n-                return new PutFieldInstruction(this, opcode);\n-            case Constants.INVOKEVIRTUAL:\n-            case Constants.INVOKESPECIAL:\n-            case Constants.INVOKESTATIC:\n-            case Constants.INVOKEINTERFACE:\n-                return new MethodInstruction(this, opcode);\n-            case Constants.NEW:\n-            case Constants.ANEWARRAY:\n-            case Constants.CHECKCAST:\n-            case Constants.INSTANCEOF:\n-                return new ClassInstruction(this, opcode);\n-            case Constants.NEWARRAY:\n-                return new NewArrayInstruction(this);\n-            case Constants.MONITORENTER:\n-                return new MonitorEnterInstruction(this);\n-            case Constants.MONITOREXIT:\n-                return new MonitorExitInstruction(this);\n-            case Constants.WIDE:\n-                return new WideInstruction(this);\n-            case Constants.MULTIANEWARRAY:\n-                return new MultiANewArrayInstruction(this);\n-            default:\n-                throw new IllegalArgumentException(\"Illegal opcode: \" + opcode);\n-        }\n-    }\n-\n-    /**\n-     * Returns another listIterator view of the Instructions in this\n-     * code block. Useful for performing read-only searches through\n-     * Instructions without effecting the pointer location of the main\n-     * code block.\n-     */\n-    public ListIterator listIterator() {\n-        return new CodeIterator(_head, -1);\n-    }\n-\n-    /**\n-     * Helper class to handle invalidation of instructions on removal\n-     * and notification of modification on addition.\n-     */\n-    private class CodeIterator implements ListIterator {\n-\n-        public static final int UNSET = -99;\n-\n-        private CodeEntry _bn = null; // \"before next\" entry\n-        private Instruction _last = null; // last entry returned\n-        private int _index = UNSET; // index of _bn\n-\n-        public CodeIterator(CodeEntry entry, int index) {\n-            _bn = entry;\n-            _index = index;\n-        }\n-\n-        public boolean hasNext() {\n-            return _bn.next != _tail;\n-        }\n-\n-        public boolean hasPrevious() {\n-            return _bn != _head;\n-        }\n-\n-        public Object next() {\n-            if (!hasNext())\n-                throw new NoSuchElementException();\n-            _bn = _bn.next;\n-            _last = (Instruction) _bn;\n-            if (_index != UNSET)\n-                _index++;\n-            return _last;\n-        }\n-\n-        public int nextIndex() {\n-            return initIndex() + 1;\n-        }\n-\n-        public Object previous() {\n-            if (!hasPrevious())\n-                throw new NoSuchElementException();\n-            _last = (Instruction) _bn;\n-            _bn = _bn.prev;\n-            if (_index != UNSET)\n-                _index--;\n-            return _last;\n-        }\n-\n-        public int previousIndex() {\n-            return initIndex();\n-        }\n-\n-        private int initIndex() {\n-            if (_index == UNSET) {\n-                if (_bn == _head)\n-                    _index = -1;\n-                else\n-                    _index = indexOf((Instruction) _bn);\n-            }\n-            return _index;\n-        }\n-\n-        public void add(Object obj) {\n-            if (obj == null)\n-                throw new NullPointerException(\"obj = null\");\n-\n-            Instruction ins = (Instruction) obj;\n-            if (_size == 0) {\n-                _head.next = ins;\n-                _tail.prev = ins;\n-                ins.prev = _head;\n-                ins.next = _tail;\n-                _index = 0;\n-            } else {\n-                CodeEntry next = _bn.next;\n-                _bn.next = ins;\n-                next.prev = ins;\n-                ins.prev = _bn;\n-                ins.next = next;\n-                if (_index != UNSET)\n-                    _index++;\n-            }\n-\n-            _bn = ins;\n-            _last = ins;\n-            _size++;\n-        }\n-\n-        public void set(Object obj) {\n-            if (obj == null)\n-                throw new NullPointerException(\"obj = null\");\n-            if (_last == null)\n-                throw new IllegalStateException();\n-\n-            Instruction ins = (Instruction) obj;\n-            ins.prev = _last.prev;\n-            ins.next = _last.next;\n-            ins.prev.next = ins;\n-            ins.next.prev = ins;\n-\n-            replaceTarget(_last, ins);\n-            _last.invalidate();\n-\n-            if (_bn == _last)\n-                _bn = ins;\n-            _last = ins;\n-        }\n-\n-        public void remove() {\n-            if (_last == null)\n-                throw new IllegalStateException();\n-\n-            if (_bn == _last)\n-                _bn = _last.prev;\n-            _index--;\n-\n-            _last.prev.next = _last.next;\n-            _last.next.prev = _last.prev;\n-            _size--;\n-\n-            Instruction orig = _last;\n-            Instruction replace = null;\n-            if (orig.next != _tail)\n-                replace = (Instruction) orig.next;\n-            else\n-                replace = nop();\n-            replaceTarget(orig, replace);\n-\n-            orig.invalidate();\n-            _last = null;\n-        }\n-\n-        private void replaceTarget(Instruction orig, Instruction replace) {\n-            for (CodeEntry entry = _head.next; entry != _tail;\n-                entry = entry.next)\n-                if (entry instanceof InstructionPtr)\n-                    ((InstructionPtr) entry).replaceTarget(orig, replace);\n-\n-            // update the ExceptionHandler pointers\n-            ExceptionHandler[] handlers = getExceptionHandlers();\n-            for (int i = 0; i < handlers.length; i++)\n-                handlers[i].replaceTarget(orig, replace);\n-\n-            // update LineNumber pointers\n-            LineNumberTable lineNumbers = getLineNumberTable(false);\n-            if (lineNumbers != null)\n-                lineNumbers.replaceTarget(orig, replace);\n-\n-            // update LocalVariable pointers\n-            LocalVariableTable variables = getLocalVariableTable(false);\n-            if (variables != null)\n-                variables.replaceTarget(orig, replace);\n-\n-            // update LocalVariableType pointers\n-            LocalVariableTypeTable types = getLocalVariableTypeTable(false);\n-            if (types != null)\n-                types.replaceTarget(orig, replace);\n-        }\n-    }\n-}"},{"sha":"94bd16aa5bbbfa7887affd497464ea10270cdc3a","filename":"serp/src/main/java/serp/bytecode/CodeEntry.java","status":"removed","additions":0,"deletions":24,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/CodeEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/CodeEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/CodeEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,24 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-/**\n- * An entry in a code block.\n- *\n- * @author Abe White\n- */\n-class CodeEntry {\n-\n-    CodeEntry next = null;\n-    CodeEntry prev = null;\n-}"},{"sha":"c733e84602d34080876c3370cd3dcdbb6c1c5d32","filename":"serp/src/main/java/serp/bytecode/ConstantInstruction.java","status":"removed","additions":0,"deletions":471,"changes":471,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ConstantInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ConstantInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ConstantInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,471 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.lowlevel.ClassEntry;\n-import serp.bytecode.lowlevel.ConstantEntry;\n-import serp.bytecode.lowlevel.Entry;\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.util.Numbers;\n-\n-/**\n- * An instruction that that loads a constant onto the stack.\n- * The opcode represented by this instruction may change depending on the\n- * type and value of the constant set. For example, if the constant value\n- * is initially set to 5, the opcode will be <code>iconst5</code>; if later\n- * incremented to 6, the opcode will be changed to <code>bipush(6)</code>.\n- *\n- * @author Abe White\n- */\n-public class ConstantInstruction extends TypedInstruction {\n-\n-    private int _arg = -1;\n-\n-    ConstantInstruction(Code owner) {\n-        super(owner);\n-    }\n-\n-    ConstantInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    int getLength() {\n-        switch (getOpcode()) {\n-            case Constants.BIPUSH:\n-            case Constants.LDC:\n-                return super.getLength() + 1;\n-            case Constants.SIPUSH:\n-            case Constants.LDCW:\n-            case Constants.LDC2W:\n-                return super.getLength() + 2;\n-            default:\n-                return super.getLength();\n-        }\n-    }\n-\n-    public int getStackChange() {\n-        String type = getTypeName();\n-        if (double.class.getName().equals(type)\n-            || long.class.getName().equals(type))\n-            return 2;\n-        return 1;\n-    }\n-\n-    public int getLogicalStackChange() {\n-        return 1;\n-    }\n-\n-    public String getTypeName() {\n-        int opcode = getOpcode();\n-        switch (opcode) {\n-            case Constants.NOP:\n-                return null;\n-            case Constants.ACONSTNULL:\n-                return Object.class.getName();\n-            case Constants.ICONSTM1:\n-            case Constants.ICONST0:\n-            case Constants.ICONST1:\n-            case Constants.ICONST2:\n-            case Constants.ICONST3:\n-            case Constants.ICONST4:\n-            case Constants.ICONST5:\n-            case Constants.BIPUSH:\n-            case Constants.SIPUSH:\n-                return int.class.getName();\n-            case Constants.LCONST0:\n-            case Constants.LCONST1:\n-                return long.class.getName();\n-            case Constants.FCONST0:\n-            case Constants.FCONST1:\n-            case Constants.FCONST2:\n-                return float.class.getName();\n-            case Constants.DCONST0:\n-            case Constants.DCONST1:\n-                return double.class.getName();\n-        }\n-\n-        Entry entry = getPool().getEntry(_arg);\n-        switch (entry.getType()) {\n-            case Entry.UTF8:\n-            case Entry.STRING:\n-                return String.class.getName();\n-            case Entry.INT:\n-                return int.class.getName();\n-            case Entry.FLOAT:\n-                return float.class.getName();\n-            case Entry.LONG:\n-                return long.class.getName();\n-            case Entry.DOUBLE:\n-                return double.class.getName();\n-            case Entry.CLASS:\n-                return Class.class.getName();\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    public TypedInstruction setType(String type) {\n-        throw new UnsupportedOperationException(\"Use setValue\");\n-    }\n-\n-    /**\n-     * Return the value of the constant as its wrapper type, or null if\n-     * not set. Returns class values as the class name.\n-     */\n-    public Object getValue() {\n-        int opcode = getOpcode();\n-        switch (opcode) {\n-            case Constants.NOP:\n-            case Constants.ACONSTNULL:\n-                return null;\n-            case Constants.ICONSTM1:\n-            case Constants.ICONST0:\n-            case Constants.ICONST1:\n-            case Constants.ICONST2:\n-            case Constants.ICONST3:\n-            case Constants.ICONST4:\n-            case Constants.ICONST5:\n-                return Numbers.valueOf(opcode - Constants.ICONST0);\n-            case Constants.LCONST0:\n-            case Constants.LCONST1:\n-                return Numbers.valueOf((long) (opcode - Constants.LCONST0));\n-            case Constants.FCONST0:\n-            case Constants.FCONST1:\n-            case Constants.FCONST2:\n-                return new Float(opcode - Constants.FCONST0);\n-            case Constants.DCONST0:\n-            case Constants.DCONST1:\n-                return new Double(opcode - Constants.DCONST0);\n-            case Constants.BIPUSH:\n-            case Constants.SIPUSH:\n-                return Numbers.valueOf(_arg);\n-            default:\n-                Entry entry = getPool().getEntry(_arg);\n-                Object val = ((ConstantEntry) entry).getConstant();\n-                if (entry.getType() == Entry.CLASS)\n-                    return getProject().getNameCache().getExternalForm\n-                        ((String) val, false);\n-                return val;\n-        }\n-    }\n-\n-    /**\n-     * Set the constant to the given value. The value should be\n-     * an instance of String, Integer, Long, Double, Float, Class, BCClass, or\n-     * null depending on the constant type. If the given value is not\n-     * supported directly, it will be converted accordingly.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ConstantInstruction setValue(Object value) {\n-        if (value instanceof Boolean)\n-            value = Numbers.valueOf((((Boolean) value).booleanValue())\n-                ? 1 : 0);\n-        else if (value instanceof Character)\n-            value = Numbers.valueOf((int) ((Character) value).charValue());\n-        else if (value instanceof Byte)\n-            value = Numbers.valueOf(((Byte) value).intValue());\n-        else if (value instanceof Short)\n-            value = Numbers.valueOf(((Short) value).intValue());\n-        else if (value != null && !(value instanceof Number)\n-            && !(value instanceof String)\n-            && !(value instanceof Class)\n-            && !(value instanceof BCClass))\n-            throw new IllegalArgumentException(\"value = \" + value);\n-\n-        calculateOpcode(value, false);\n-        return this;\n-    }\n-\n-    /**\n-     * Return the string value of this constant, or null if not set.\n-     */\n-    public String getStringValue() {\n-        return (String) getValue();\n-    }\n-\n-    /**\n-     * Return the int value of this constant, or 0 if not set.\n-     */\n-    public int getIntValue() {\n-        Object value = getValue();\n-        return (value == null) ? 0 : ((Number) value).intValue();\n-    }\n-\n-    /**\n-     * Return the long value of this constant, or 0 if not set.\n-     */\n-    public long getLongValue() {\n-        Object value = getValue();\n-        return (value == null) ? 0L : ((Number) value).longValue();\n-    }\n-\n-    /**\n-     * Return the float value of this constant, or 0 if not set.\n-     */\n-    public float getFloatValue() {\n-        Object value = getValue();\n-        return (value == null) ? 0F : ((Number) value).floatValue();\n-    }\n-\n-    /**\n-     * Return the double value of this constant, or 0 if not set.\n-     */\n-    public double getDoubleValue() {\n-        Object value = getValue();\n-        return (value == null) ? 0D : ((Number) value).doubleValue();\n-    }\n-\n-    /**\n-     * Return the class value of this constant, or null if not set.\n-     */\n-    public String getClassNameValue() {\n-        return (String) getValue();\n-    }\n-\n-    /**\n-     * Set this constant to null.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ConstantInstruction setNull() {\n-        calculateOpcode(null, false);\n-        return this;\n-    }\n-\n-    /**\n-     * Set the value of this constant.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ConstantInstruction setValue(String value) {\n-        calculateOpcode(value, false);\n-        return this;\n-    }\n-\n-    /**\n-     * Set the value of this constant.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ConstantInstruction setValue(Class value) {\n-        calculateOpcode(value, false);\n-        return this;\n-    }\n-\n-    /**\n-     * Set the value of this constant.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ConstantInstruction setValue(BCClass value) {\n-        calculateOpcode(value, false);\n-        return this;\n-    }\n-\n-    /**\n-     * Set the value of this constant.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ConstantInstruction setValue(int value) {\n-        calculateOpcode(Numbers.valueOf(value), false);\n-        return this;\n-    }\n-\n-    /**\n-     * Set the value of this constant.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ConstantInstruction setValue(long value) {\n-        calculateOpcode(Numbers.valueOf(value), false);\n-        return this;\n-    }\n-\n-    /**\n-     * Set the value of this constant.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ConstantInstruction setValue(float value) {\n-        calculateOpcode(new Float(value), false);\n-        return this;\n-    }\n-\n-    /**\n-     * Set the value of this constant.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ConstantInstruction setValue(double value) {\n-        calculateOpcode(new Double(value), false);\n-        return this;\n-    }\n-\n-    /**\n-     * Set the value of this constant; note that this type is converted to int.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ConstantInstruction setValue(boolean value) {\n-        return setValue((value) ? 1 : 0);\n-    }\n-\n-    /**\n-     * Set the value of this constant; note that this type is converted to int.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ConstantInstruction setValue(short value) {\n-        return setValue((int) value);\n-    }\n-\n-    /**\n-     * Set the value of this constant; note that this type is converted to int.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ConstantInstruction setValue(char value) {\n-        return setValue((int) value);\n-    }\n-\n-    /**\n-     * ConstantInstructions are equal if the const they reference is the same,\n-     * or if the const of either is unset.\n-     */\n-    public boolean equalsInstruction(Instruction other) {\n-        if (this == other)\n-            return true;\n-        if (!(other instanceof ConstantInstruction))\n-            return false;\n-\n-        Object value = getValue();\n-        Object otherValue = ((ConstantInstruction) other).getValue();\n-\n-        return value == null || otherValue == null || value.equals(otherValue);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterConstantInstruction(this);\n-        visit.exitConstantInstruction(this);\n-    }\n-\n-    void read(Instruction orig) {\n-        super.read(orig);\n-        ConstantInstruction ci = (ConstantInstruction) orig;\n-        calculateOpcode(ci.getValue(), ci.getOpcode() == Constants.LDCW);\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        super.read(in);\n-\n-        switch (getOpcode()) {\n-            case Constants.BIPUSH:\n-            case Constants.LDC:\n-                _arg = in.readUnsignedByte();\n-                break;\n-            case Constants.SIPUSH:\n-            case Constants.LDCW:\n-            case Constants.LDC2W:\n-                _arg = in.readUnsignedShort();\n-        }\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        super.write(out);\n-\n-        switch (getOpcode()) {\n-            case Constants.BIPUSH:\n-            case Constants.LDC:\n-                out.writeByte(_arg);\n-                break;\n-            case Constants.SIPUSH:\n-            case Constants.LDCW:\n-            case Constants.LDC2W:\n-                out.writeShort(_arg);\n-                break;\n-        }\n-    }\n-\n-    private void calculateOpcode(Object value, boolean wide) {\n-        _arg = -1;\n-\n-        if (value == null)\n-            setOpcode(Constants.ACONSTNULL);\n-        else if (value instanceof Float) {\n-            float floatVal = ((Float) value).floatValue();\n-            if (floatVal == 0 || floatVal == 1 || floatVal == 2)\n-                setOpcode(Constants.FCONST0 + (int) floatVal);\n-            else {\n-                _arg = getPool().findFloatEntry((float) floatVal, true);\n-                setOpcode((_arg > 255 || wide) ? Constants.LDCW\n-                    : Constants.LDC);\n-            }\n-        } else if (value instanceof Long) {\n-            long longVal = ((Long) value).longValue();\n-            if (longVal == 0 || longVal == 1)\n-                setOpcode(Constants.LCONST0 + (int) longVal);\n-            else {\n-                _arg = getPool().findLongEntry(longVal, true);\n-                setOpcode(Constants.LDC2W);\n-            }\n-        } else if (value instanceof Double) {\n-            double doubleVal = ((Double) value).doubleValue();\n-            if (doubleVal == 0 || doubleVal == 1)\n-                setOpcode(Constants.DCONST0 + (int) doubleVal);\n-            else {\n-                _arg = getPool().findDoubleEntry(doubleVal, true);\n-                setOpcode(Constants.LDC2W);\n-            }\n-        } else if (value instanceof Integer) {\n-            int intVal = ((Integer) value).intValue();\n-            if (intVal >= -1 && intVal <= 5)\n-                setOpcode(Constants.ICONST0 + intVal);\n-            else if (intVal >= -(2 << 6) && intVal < (2 << 6)) {\n-                setOpcode(Constants.BIPUSH);\n-                _arg = intVal;\n-            } else if (intVal >= -(2 << 14) && intVal < (2 << 14)) {\n-                setOpcode(Constants.SIPUSH);\n-                _arg = intVal;\n-            } else {\n-                _arg = getPool().findIntEntry(intVal, true);\n-                setOpcode((_arg > 255 || wide) ? Constants.LDCW\n-                    : Constants.LDC);\n-            }\n-        } else if (value instanceof String) {\n-            _arg = getPool().findStringEntry((String) value, true);\n-            setOpcode((_arg > 255 || wide) ? Constants.LDCW : Constants.LDC);\n-        } else if (value instanceof Class) {\n-            String name = getProject().getNameCache().getInternalForm\n-                (((Class) value).getName(), false);\n-            _arg = getPool().findClassEntry(name, true);\n-            setOpcode(Constants.LDCW);\n-        } else if (value instanceof BCClass) {\n-            BCClass bc = (BCClass) value;\n-            ClassEntry entry = (ClassEntry) bc.getPool().\n-                getEntry(bc.getIndex());\n-            if (bc.getPool() == getPool())\n-                _arg = getPool().indexOf(entry);\n-            else\n-                _arg = getPool().findClassEntry((String) entry.getConstant(),\n-                    true);\n-            setOpcode(Constants.LDCW);\n-        } else\n-            throw new IllegalArgumentException(String.valueOf(value));\n-    }\n-}"},{"sha":"44b508b40ed7ee8e74db3823540be999c08f30b2","filename":"serp/src/main/java/serp/bytecode/ConstantValue.java","status":"removed","additions":0,"deletions":239,"changes":239,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ConstantValue.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ConstantValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ConstantValue.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,239 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.lowlevel.ConstantEntry;\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.bytecode.lowlevel.DoubleEntry;\n-import serp.bytecode.lowlevel.FloatEntry;\n-import serp.bytecode.lowlevel.IntEntry;\n-import serp.bytecode.lowlevel.LongEntry;\n-import serp.bytecode.lowlevel.StringEntry;\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * A constant value for a member field.\n- *\n- * @author Abe White\n- */\n-public class ConstantValue extends Attribute {\n-\n-    int _valueIndex = 0;\n-\n-    ConstantValue(int nameIndex, Attributes owner) {\n-        super(nameIndex, owner);\n-    }\n-\n-    int getLength() {\n-        return 2;\n-    }\n-\n-    /**\n-     * Return the owning field.\n-     */\n-    public BCField getField() {\n-        return (BCField) getOwner();\n-    }\n-\n-    /**\n-     * Return the {@link ConstantPool} index of the {@link ConstantEntry}\n-     * holding the value of this constant. Defaults to 0.\n-     */\n-    public int getValueIndex() {\n-        return _valueIndex;\n-    }\n-\n-    /**\n-     * Set the {@link ConstantPool} of the {@link ConstantEntry}\n-     * holding the value of this constant.\n-     */\n-    public void setValueIndex(int valueIndex) {\n-        _valueIndex = valueIndex;\n-    }\n-\n-    /**\n-     * Return the type of constant this attribute represents, or null if\n-     * not set.\n-     */\n-    public String getTypeName() {\n-        Class type = getType();\n-        if (type == null)\n-            return null;\n-        return type.getName();\n-    }\n-\n-    /**\n-     * Return the type of constant this attribute represents(String.class,\n-     * int.class, etc), or null if not set.\n-     */\n-    public Class getType() {\n-        Object value = getValue();\n-        if (value == null)\n-            return null;\n-\n-        Class type = value.getClass();\n-        if (type == Integer.class)\n-            return int.class;\n-        if (type == Float.class)\n-            return float.class;\n-        if (type == Double.class)\n-            return double.class;\n-        if (type == Long.class)\n-            return long.class;\n-        return String.class;\n-    }\n-\n-    /**\n-     * Return the bytecode for the type of constant this attribute represents.\n-     */\n-    public BCClass getTypeBC() {\n-        return getProject().loadClass(getType());\n-    }\n-\n-    /**\n-     * Return the value of this constant as an Object of the appropriate\n-     * type(String, Integer, Double, etc), or null if not set.\n-     */\n-    public Object getValue() {\n-        if (_valueIndex <= 0)\n-            return null;\n-        return ((ConstantEntry) getPool().getEntry(_valueIndex)). getConstant();\n-    }\n-\n-    /**\n-     * Set the value of this constant using the appropriate wrapper Object\n-     * type(String, Integer, Double, etc). Types that are not directly\n-     * supported will be converted accordingly if possible.\n-     */\n-    public void setValue(Object value) {\n-        Class type = value.getClass();\n-\n-        if (type == Boolean.class)\n-            setIntValue((((Boolean) value).booleanValue()) ? 1 : 0);\n-        else if (type == Character.class)\n-            setIntValue((int) ((Character) value).charValue());\n-        else if (type == Byte.class || type == Integer.class\n-            || type == Short.class)\n-            setIntValue(((Number) value).intValue());\n-        else if (type == Float.class)\n-            setFloatValue(((Number) value).floatValue());\n-        else if (type == Double.class)\n-            setDoubleValue(((Number) value).doubleValue());\n-        else if (type == Long.class)\n-            setLongValue(((Number) value).longValue());\n-        else\n-            setStringValue(value.toString());\n-    }\n-\n-    /**\n-     * Get the value of this int constant, or 0 if not set.\n-     */\n-    public int getIntValue() {\n-        if (getValueIndex() <= 0)\n-            return 0;\n-        return ((IntEntry) getPool().getEntry(getValueIndex())).getValue();\n-    }\n-\n-    /**\n-     * Set the value of this int constant.\n-     */\n-    public void setIntValue(int value) {\n-        setValueIndex(getPool().findIntEntry(value, true));\n-    }\n-\n-    /**\n-     * Get the value of this float constant.\n-     */\n-    public float getFloatValue() {\n-        if (getValueIndex() <= 0)\n-            return 0F;\n-        return ((FloatEntry) getPool().getEntry(getValueIndex())).getValue();\n-    }\n-\n-    /**\n-     * Set the value of this float constant.\n-     */\n-    public void setFloatValue(float value) {\n-        setValueIndex(getPool().findFloatEntry(value, true));\n-    }\n-\n-    /**\n-     * Get the value of this double constant.\n-     */\n-    public double getDoubleValue() {\n-        if (getValueIndex() <= 0)\n-            return 0D;\n-        return ((DoubleEntry) getPool().getEntry(getValueIndex())). getValue();\n-    }\n-\n-    /**\n-     * Set the value of this double constant.\n-     */\n-    public void setDoubleValue(double value) {\n-        setValueIndex(getPool().findDoubleEntry(value, true));\n-    }\n-\n-    /**\n-     * Get the value of this long constant.\n-     */\n-    public long getLongValue() {\n-        if (getValueIndex() <= 0)\n-            return 0L;\n-        return ((LongEntry) getPool().getEntry(getValueIndex())).getValue();\n-    }\n-\n-    /**\n-     * Set the value of this long constant.\n-     */\n-    public void setLongValue(long value) {\n-        setValueIndex(getPool().findLongEntry(value, true));\n-    }\n-\n-    /**\n-     * Get the value of this string constant.\n-     */\n-    public String getStringValue() {\n-        if (getValueIndex() <= 0)\n-            return null;\n-        return ((StringEntry) getPool().getEntry(getValueIndex())).\n-            getStringEntry().getValue();\n-    }\n-\n-    /**\n-     * Set the value of this string constant.\n-     */\n-    public void setStringValue(String value) {\n-        setValueIndex(getPool().findStringEntry(value, true));\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterConstantValue(this);\n-        visit.exitConstantValue(this);\n-    }\n-\n-    void read(Attribute other) {\n-        setValue(((ConstantValue) other).getValue());\n-    }\n-\n-    void read(DataInput in, int length) throws IOException {\n-        setValueIndex(in.readUnsignedShort());\n-    }\n-\n-    void write(DataOutput out, int length) throws IOException {\n-        out.writeShort(getValueIndex());\n-    }\n-}"},{"sha":"874eb35ffaf7245cc12b72e3fec0a6b5b5dbd7b5","filename":"serp/src/main/java/serp/bytecode/Constants.java","status":"removed","additions":0,"deletions":318,"changes":318,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Constants.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Constants.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Constants.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,318 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-/**\n- * Interface to track constants used in bytecode. Entities can access these\n- * constants using the static <code>Constants.</code> field prefix,\n- * or implement this interface themselves to conveniently import the\n- * constants into their own namespace.\n- *\n- * @author Abe White\n- */\n-public interface Constants {\n-\n-    // class magic number\n-    public static final int VALID_MAGIC = 0xcafebabe;\n-\n-    // standard major, minor versions\n-    public static final int MAJOR_VERSION = 45;\n-    public static final int MINOR_VERSION = 3;\n-\n-    // access constants for classes, fields, methods\n-    public static final int ACCESS_PUBLIC = 0x0001;\n-    public static final int ACCESS_PRIVATE = 0x0002;\n-    public static final int ACCESS_PROTECTED = 0x0004;\n-    public static final int ACCESS_STATIC = 0x0008;\n-    public static final int ACCESS_FINAL = 0x0010;\n-    public static final int ACCESS_SUPER = 0x0020;\n-    public static final int ACCESS_SYNCHRONIZED = 0x0020;\n-    public static final int ACCESS_VOLATILE = 0x0040;\n-    public static final int ACCESS_TRANSIENT = 0x0080;\n-    public static final int ACCESS_NATIVE = 0x0100;\n-    public static final int ACCESS_INTERFACE = 0x0200;\n-    public static final int ACCESS_ABSTRACT = 0x0400;\n-    public static final int ACCESS_STRICT = 0x0800;\n-\n-    // attribute types the compiler must support\n-    public static final String ATTR_CODE = \"Code\";\n-    public static final String ATTR_CONST = \"ConstantValue\";\n-    public static final String ATTR_DEPRECATED = \"Deprecated\";\n-    public static final String ATTR_EXCEPTIONS = \"Exceptions\";\n-    public static final String ATTR_INNERCLASS = \"InnerClasses\";\n-    public static final String ATTR_LINENUMBERS = \"LineNumberTable\";\n-    public static final String ATTR_LOCALS = \"LocalVariableTable\";\n-    public static final String ATTR_LOCAL_TYPES = \"LocalVariableTypeTable\";\n-    public static final String ATTR_SOURCE = \"SourceFile\";\n-    public static final String ATTR_SYNTHETIC = \"Synthetic\";\n-    public static final String ATTR_UNKNOWN = \"Unknown\";\n-\n-    // opcodes\n-    public static final int NOP = 0;\n-    public static final int ACONSTNULL = 1;\n-    public static final int ICONSTM1 = 2;\n-    public static final int ICONST0 = 3;\n-    public static final int ICONST1 = 4;\n-    public static final int ICONST2 = 5;\n-    public static final int ICONST3 = 6;\n-    public static final int ICONST4 = 7;\n-    public static final int ICONST5 = 8;\n-    public static final int LCONST0 = 9;\n-    public static final int LCONST1 = 10;\n-    public static final int FCONST0 = 11;\n-    public static final int FCONST1 = 12;\n-    public static final int FCONST2 = 13;\n-    public static final int DCONST0 = 14;\n-    public static final int DCONST1 = 15;\n-    public static final int BIPUSH = 16;\n-    public static final int SIPUSH = 17;\n-    public static final int LDC = 18;\n-    public static final int LDCW = 19;\n-    public static final int LDC2W = 20;\n-    public static final int ILOAD = 21;\n-    public static final int LLOAD = 22;\n-    public static final int FLOAD = 23;\n-    public static final int DLOAD = 24;\n-    public static final int ALOAD = 25;\n-    public static final int ILOAD0 = 26;\n-    public static final int ILOAD1 = 27;\n-    public static final int ILOAD2 = 28;\n-    public static final int ILOAD3 = 29;\n-    public static final int LLOAD0 = 30;\n-    public static final int LLOAD1 = 31;\n-    public static final int LLOAD2 = 32;\n-    public static final int LLOAD3 = 33;\n-    public static final int FLOAD0 = 34;\n-    public static final int FLOAD1 = 35;\n-    public static final int FLOAD2 = 36;\n-    public static final int FLOAD3 = 37;\n-    public static final int DLOAD0 = 38;\n-    public static final int DLOAD1 = 39;\n-    public static final int DLOAD2 = 40;\n-    public static final int DLOAD3 = 41;\n-    public static final int ALOAD0 = 42;\n-    public static final int ALOAD1 = 43;\n-    public static final int ALOAD2 = 44;\n-    public static final int ALOAD3 = 45;\n-    public static final int IALOAD = 46;\n-    public static final int LALOAD = 47;\n-    public static final int FALOAD = 48;\n-    public static final int DALOAD = 49;\n-    public static final int AALOAD = 50;\n-    public static final int BALOAD = 51;\n-    public static final int CALOAD = 52;\n-    public static final int SALOAD = 53;\n-    public static final int ISTORE = 54;\n-    public static final int LSTORE = 55;\n-    public static final int FSTORE = 56;\n-    public static final int DSTORE = 57;\n-    public static final int ASTORE = 58;\n-    public static final int ISTORE0 = 59;\n-    public static final int ISTORE1 = 60;\n-    public static final int ISTORE2 = 61;\n-    public static final int ISTORE3 = 62;\n-    public static final int LSTORE0 = 63;\n-    public static final int LSTORE1 = 64;\n-    public static final int LSTORE2 = 65;\n-    public static final int LSTORE3 = 66;\n-    public static final int FSTORE0 = 67;\n-    public static final int FSTORE1 = 68;\n-    public static final int FSTORE2 = 69;\n-    public static final int FSTORE3 = 70;\n-    public static final int DSTORE0 = 71;\n-    public static final int DSTORE1 = 72;\n-    public static final int DSTORE2 = 73;\n-    public static final int DSTORE3 = 74;\n-    public static final int ASTORE0 = 75;\n-    public static final int ASTORE1 = 76;\n-    public static final int ASTORE2 = 77;\n-    public static final int ASTORE3 = 78;\n-    public static final int IASTORE = 79;\n-    public static final int LASTORE = 80;\n-    public static final int FASTORE = 81;\n-    public static final int DASTORE = 82;\n-    public static final int AASTORE = 83;\n-    public static final int BASTORE = 84;\n-    public static final int CASTORE = 85;\n-    public static final int SASTORE = 86;\n-    public static final int POP = 87;\n-    public static final int POP2 = 88;\n-    public static final int DUP = 89;\n-    public static final int DUPX1 = 90;\n-    public static final int DUPX2 = 91;\n-    public static final int DUP2 = 92;\n-    public static final int DUP2X1 = 93;\n-    public static final int DUP2X2 = 94;\n-    public static final int SWAP = 95;\n-    public static final int IADD = 96;\n-    public static final int LADD = 97;\n-    public static final int FADD = 98;\n-    public static final int DADD = 99;\n-    public static final int ISUB = 100;\n-    public static final int LSUB = 101;\n-    public static final int FSUB = 102;\n-    public static final int DSUB = 103;\n-    public static final int IMUL = 104;\n-    public static final int LMUL = 105;\n-    public static final int FMUL = 106;\n-    public static final int DMUL = 107;\n-    public static final int IDIV = 108;\n-    public static final int LDIV = 109;\n-    public static final int FDIV = 110;\n-    public static final int DDIV = 111;\n-    public static final int IREM = 112;\n-    public static final int LREM = 113;\n-    public static final int FREM = 114;\n-    public static final int DREM = 115;\n-    public static final int INEG = 116;\n-    public static final int LNEG = 117;\n-    public static final int FNEG = 118;\n-    public static final int DNEG = 119;\n-    public static final int ISHL = 120;\n-    public static final int LSHL = 121;\n-    public static final int ISHR = 122;\n-    public static final int LSHR = 123;\n-    public static final int IUSHR = 124;\n-    public static final int LUSHR = 125;\n-    public static final int IAND = 126;\n-    public static final int LAND = 127;\n-    public static final int IOR = 128;\n-    public static final int LOR = 129;\n-    public static final int IXOR = 130;\n-    public static final int LXOR = 131;\n-    public static final int IINC = 132;\n-    public static final int I2L = 133;\n-    public static final int I2F = 134;\n-    public static final int I2D = 135;\n-    public static final int L2I = 136;\n-    public static final int L2F = 137;\n-    public static final int L2D = 138;\n-    public static final int F2I = 139;\n-    public static final int F2L = 140;\n-    public static final int F2D = 141;\n-    public static final int D2I = 142;\n-    public static final int D2L = 143;\n-    public static final int D2F = 144;\n-    public static final int I2B = 145;\n-    public static final int I2C = 146;\n-    public static final int I2S = 147;\n-    public static final int LCMP = 148;\n-    public static final int FCMPL = 149;\n-    public static final int FCMPG = 150;\n-    public static final int DCMPL = 151;\n-    public static final int DCMPG = 152;\n-    public static final int IFEQ = 153;\n-    public static final int IFNE = 154;\n-    public static final int IFLT = 155;\n-    public static final int IFGE = 156;\n-    public static final int IFGT = 157;\n-    public static final int IFLE = 158;\n-    public static final int IFICMPEQ = 159;\n-    public static final int IFICMPNE = 160;\n-    public static final int IFICMPLT = 161;\n-    public static final int IFICMPGE = 162;\n-    public static final int IFICMPGT = 163;\n-    public static final int IFICMPLE = 164;\n-    public static final int IFACMPEQ = 165;\n-    public static final int IFACMPNE = 166;\n-    public static final int GOTO = 167;\n-    public static final int JSR = 168;\n-    public static final int RET = 169;\n-    public static final int TABLESWITCH = 170;\n-    public static final int LOOKUPSWITCH = 171;\n-    public static final int IRETURN = 172;\n-    public static final int LRETURN = 173;\n-    public static final int FRETURN = 174;\n-    public static final int DRETURN = 175;\n-    public static final int ARETURN = 176;\n-    public static final int RETURN = 177;\n-    public static final int GETSTATIC = 178;\n-    public static final int PUTSTATIC = 179;\n-    public static final int GETFIELD = 180;\n-    public static final int PUTFIELD = 181;\n-    public static final int INVOKEVIRTUAL = 182;\n-    public static final int INVOKESPECIAL = 183;\n-    public static final int INVOKESTATIC = 184;\n-    public static final int INVOKEINTERFACE = 185;\n-    public static final int NEW = 187;\n-    public static final int NEWARRAY = 188;\n-    public static final int ANEWARRAY = 189;\n-    public static final int ARRAYLENGTH = 190;\n-    public static final int ATHROW = 191;\n-    public static final int CHECKCAST = 192;\n-    public static final int INSTANCEOF = 193;\n-    public static final int MONITORENTER = 194;\n-    public static final int MONITOREXIT = 195;\n-    public static final int WIDE = 196;\n-    public static final int MULTIANEWARRAY = 197;\n-    public static final int IFNULL = 198;\n-    public static final int IFNONNULL = 199;\n-    public static final int GOTOW = 200;\n-    public static final int JSRW = 201;\n-\n-    // array types\n-    public static final int ARRAY_BOOLEAN = 4;\n-    public static final int ARRAY_CHAR = 5;\n-    public static final int ARRAY_FLOAT = 6;\n-    public static final int ARRAY_DOUBLE = 7;\n-    public static final int ARRAY_BYTE = 8;\n-    public static final int ARRAY_SHORT = 9;\n-    public static final int ARRAY_INT = 10;\n-    public static final int ARRAY_LONG = 11;\n-\n-    // math operations\n-    public static final int MATH_ADD = IADD;\n-    public static final int MATH_SUB = ISUB;\n-    public static final int MATH_MUL = IMUL;\n-    public static final int MATH_DIV = IDIV;\n-    public static final int MATH_REM = IREM;\n-    public static final int MATH_NEG = INEG;\n-    public static final int MATH_SHL = ISHL;\n-    public static final int MATH_SHR = ISHR;\n-    public static final int MATH_USHR = IUSHR;\n-    public static final int MATH_AND = IAND;\n-    public static final int MATH_OR = IOR;\n-    public static final int MATH_XOR = IXOR;\n-\n-    // human-readable opcode names\n-    public static final String[] OPCODE_NAMES = new String[]{\n-        \"nop\", \"aconstnull\", \"iconstm1\", \"iconst0\", \"iconst1\", \"iconst2\",\n-        \"iconst3\", \"iconst4\", \"iconst5\", \"lconst0\", \"lconst1\", \"fconst0\",\n-        \"fconst1\", \"fconst2\", \"dconst0\", \"dconst1\", \"bipush\", \"sipush\", \"ldc\",\n-        \"ldcw\", \"ldc2w\", \"iload\", \"lload\", \"fload\", \"dload\", \"aload\", \"iload0\",\n-        \"iload1\", \"iload2\", \"iload3\", \"lload0\", \"lload1\", \"lload2\", \"lload3\",\n-        \"fload0\", \"fload1\", \"fload2\", \"fload3\", \"dload0\", \"dload1\", \"dload2\",\n-        \"dload3\", \"aload0\", \"aload1\", \"aload2\", \"aload3\", \"iaload\", \"laload\",\n-        \"faload\", \"daload\", \"aaload\", \"baload\", \"caload\", \"saload\", \"istore\",\n-        \"lstore\", \"fstore\", \"dstore\", \"astore\", \"istore0\", \"istore1\", \"istore2\",\n-        \"istore3\", \"lstore0\", \"lstore1\", \"lstore2\", \"lstore3\", \"fstore0\",\n-        \"fstore1\", \"fstore2\", \"fstore3\", \"dstore0\", \"dstore1\", \"dstore2\",\n-        \"dstore3\", \"astore0\", \"astore1\", \"astore2\", \"astore3\", \"iastore\",\n-        \"lastore\", \"fastore\", \"dastore\", \"aastore\", \"bastore\", \"castore\",\n-        \"sastore\", \"pop\", \"pop2\", \"dup\", \"dupx1\", \"dupx2\", \"dup2\", \"dup2x1\",\n-        \"dup2x2\", \"swap\", \"iadd\", \"ladd\", \"fadd\", \"dadd\", \"isub\", \"lsub\",\n-        \"fsub\", \"dsub\", \"imul\", \"lmul\", \"fmul\", \"dmul\", \"idiv\", \"ldiv\", \"fdiv\",\n-        \"ddiv\", \"irem\", \"lrem\", \"frem\", \"drem\", \"ineg\", \"lneg\", \"fneg\", \"dneg\",\n-        \"ishl\", \"lshl\", \"ishr\", \"lshr\", \"iushr\", \"lushr\", \"iand\", \"land\", \"ior\",\n-        \"lor\", \"ixor\", \"lxor\", \"iinc\", \"i2l\", \"i2f\", \"i2d\", \"l2i\", \"l2f\", \"l2d\",\n-        \"f2i\", \"f2l\", \"f2d\", \"d2i\", \"d2l\", \"d2f\", \"i2b\", \"i2c\", \"i2s\", \"lcmp\",\n-        \"fcmpl\", \"fcmpg\", \"dcmpl\", \"dcmpg\", \"ifeq\", \"ifne\", \"iflt\", \"ifge\",\n-        \"ifgt\", \"ifle\", \"ificmpeq\", \"ificmpne\", \"ificmplt\", \"ificmpge\",\n-        \"ificmpgt\", \"ificmple\", \"ifacmpeq\", \"ifacmpne\", \"goto\", \"jsr\", \"ret\",\n-        \"tableswitch\", \"lookupswitch\", \"ireturn\", \"lreturn\", \"freturn\",\n-        \"dreturn\", \"areturn\", \"return\", \"getstatic\", \"putstatic\", \"getfield\",\n-        \"putfield\", \"invokevirtual\", \"invokespecial\", \"invokestatic\",\n-        \"invokeinterface\", \"??\", \"new\", \"newarray\", \"anewarray\", \"arraylength\",\n-        \"athrow\", \"checkcast\", \"instanceof\", \"monitorenter\", \"monitorexit\",\n-        \"wide\", \"multianewarray\", \"ifnull\", \"ifnonnull\", \"gotow\", \"jsrw\", };\n-}"},{"sha":"a4e241b77c894161a07d961c11f95e8bfd569e2c","filename":"serp/src/main/java/serp/bytecode/ConvertInstruction.java","status":"removed","additions":0,"deletions":352,"changes":352,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ConvertInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ConvertInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ConvertInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,352 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.util.Strings;\n-\n-/**\n- * A conversion opcode such as <code>i2l, f2i</code>, etc.\n- * Changing the types of the instruction will automatically\n- * update the underlying opcode. Converting from one type to the same\n- * type will result in a <code>nop</code>.\n- *\n- * @author Abe White\n- */\n-public class ConvertInstruction extends TypedInstruction {\n-\n-    private static final Class[][] _mappings = new Class[][]{\n-        { boolean.class, int.class }, { void.class, int.class },\n-        { Object.class, int.class }, };\n-    private static final Class[][] _fromMappings = new Class[][]{\n-        { boolean.class, int.class }, { void.class, int.class },\n-        { Object.class, int.class }, { byte.class, int.class },\n-        { char.class, int.class }, { short.class, int.class }, };\n-\n-    String _toType = null;\n-    String _fromType = null;\n-\n-    ConvertInstruction(Code owner) {\n-        super(owner);\n-    }\n-\n-    ConvertInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    public int getLogicalStackChange() {\n-        return 0;\n-    }\n-\n-    public int getStackChange() {\n-        switch (getOpcode()) {\n-            case Constants.I2L:\n-            case Constants.I2D:\n-            case Constants.F2L:\n-            case Constants.F2D:\n-                return 1;\n-            case Constants.L2I:\n-            case Constants.L2F:\n-            case Constants.D2I:\n-            case Constants.D2F:\n-                return -1;\n-            default:\n-                return 0;\n-        }\n-    }\n-\n-    public String getTypeName() {\n-        switch (getOpcode()) {\n-            case Constants.L2I:\n-            case Constants.F2I:\n-            case Constants.D2I:\n-                return int.class.getName();\n-            case Constants.I2L:\n-            case Constants.F2L:\n-            case Constants.D2L:\n-                return long.class.getName();\n-            case Constants.I2F:\n-            case Constants.L2F:\n-            case Constants.D2F:\n-                return float.class.getName();\n-            case Constants.I2D:\n-            case Constants.L2D:\n-            case Constants.F2D:\n-                return double.class.getName();\n-            case Constants.I2B:\n-                return byte.class.getName();\n-            case Constants.I2C:\n-                return char.class.getName();\n-            case Constants.I2S:\n-                return short.class.getName();\n-            default:\n-                return _toType;\n-        }\n-    }\n-\n-    public TypedInstruction setType(String type) {\n-        String toType = mapType(type, _mappings, true);\n-        String fromType = getFromTypeName();\n-\n-        // if no valid opcode, remember current types in case they reset one\n-        // to create a valid opcode\n-        if (toType == null || fromType == null || toType.equals(fromType)) {\n-            _toType = toType;\n-            _fromType = fromType;\n-            return (TypedInstruction) setOpcode(Constants.NOP);\n-        }\n-\n-        // ok, valid conversion possible, forget saved types\n-        _toType = null;\n-        _fromType = null;\n-\n-        char to = toType.charAt(0);\n-        char from = fromType.charAt(0);\n-\n-        switch (to) {\n-            case 'i':\n-                switch (from) {\n-                    case 'l':\n-                        return (TypedInstruction) setOpcode(Constants.L2I);\n-                    case 'f':\n-                        return (TypedInstruction) setOpcode(Constants.F2I);\n-                    case 'd':\n-                        return (TypedInstruction) setOpcode(Constants.D2I);\n-                }\n-            case 'l':\n-                switch (from) {\n-                    case 'i':\n-                        return (TypedInstruction) setOpcode(Constants.I2L);\n-                    case 'f':\n-                        return (TypedInstruction) setOpcode(Constants.F2L);\n-                    case 'd':\n-                        return (TypedInstruction) setOpcode(Constants.D2L);\n-                }\n-            case 'f':\n-                switch (from) {\n-                    case 'i':\n-                        return (TypedInstruction) setOpcode(Constants.I2F);\n-                    case 'l':\n-                        return (TypedInstruction) setOpcode(Constants.L2F);\n-                    case 'd':\n-                        return (TypedInstruction) setOpcode(Constants.D2F);\n-                }\n-            case 'd':\n-                switch (from) {\n-                    case 'i':\n-                        return (TypedInstruction) setOpcode(Constants.I2D);\n-                    case 'l':\n-                        return (TypedInstruction) setOpcode(Constants.L2D);\n-                    case 'f':\n-                        return (TypedInstruction) setOpcode(Constants.F2D);\n-                }\n-            case 'b':\n-                if (from == 'i')\n-                    return (TypedInstruction) setOpcode(Constants.I2B);\n-            case 'C':\n-                if (from == 'i')\n-                    return (TypedInstruction) setOpcode(Constants.I2C);\n-            case 'S':\n-                if (from == 'i')\n-                    return (TypedInstruction) setOpcode(Constants.I2S);\n-            default:\n-                throw new IllegalStateException();\n-        }\n-    }\n-\n-    /**\n-     * Return the name of the type being converted from.\n-     * If neither type has been set, this method will return null.\n-     */\n-    public String getFromTypeName() {\n-        switch (getOpcode()) {\n-            case Constants.I2L:\n-            case Constants.I2F:\n-            case Constants.I2D:\n-            case Constants.I2B:\n-            case Constants.I2S:\n-            case Constants.I2C:\n-                return int.class.getName();\n-            case Constants.L2I:\n-            case Constants.L2F:\n-            case Constants.L2D:\n-                return long.class.getName();\n-            case Constants.F2I:\n-            case Constants.F2L:\n-            case Constants.F2D:\n-                return float.class.getName();\n-            case Constants.D2I:\n-            case Constants.D2L:\n-            case Constants.D2F:\n-                return double.class.getName();\n-            default:\n-                return _fromType;\n-        }\n-    }\n-\n-    /**\n-     * Return the {@link Class} of the type being converted from.\n-     * If neither type has been set, this method will return null.\n-     */\n-    public Class getFromType() {\n-        String type = getFromTypeName();\n-        if (type == null)\n-            return null;\n-        return Strings.toClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Return the bytecode of the type being converted from.\n-     * If neither type has been set, this method will return null.\n-     */\n-    public BCClass getFromTypeBC() {\n-        String type = getFromTypeName();\n-        if (type == null)\n-            return null;\n-        return getProject().loadClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Set the type being converted from. Types that have no direct\n-     * support will be converted accordingly.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ConvertInstruction setFromType(String type) {\n-        String fromType = mapType(type, _fromMappings, true);\n-        String toType = getTypeName();\n-\n-        // if no valid opcode, remember current types in case they reset one\n-        // to create a valid opcode\n-        if (toType == null || fromType == null || toType.equals(fromType)) {\n-            _toType = toType;\n-            _fromType = fromType;\n-            return (ConvertInstruction) setOpcode(Constants.NOP);\n-        }\n-\n-        // ok, valid conversion possible, forget saved types\n-        _toType = null;\n-        _fromType = null;\n-\n-        char to = toType.charAt(0);\n-        char from = fromType.charAt(0);\n-\n-        switch (from) {\n-            case 'i':\n-                switch (to) {\n-                    case 'l':\n-                        return (ConvertInstruction) setOpcode(Constants.I2L);\n-                    case 'f':\n-                        return (ConvertInstruction) setOpcode(Constants.I2F);\n-                    case 'd':\n-                        return (ConvertInstruction) setOpcode(Constants.I2D);\n-                    case 'b':\n-                        return (ConvertInstruction) setOpcode(Constants.I2B);\n-                    case 'c':\n-                        return (ConvertInstruction) setOpcode(Constants.I2C);\n-                    case 's':\n-                        return (ConvertInstruction) setOpcode(Constants.I2S);\n-                }\n-            case 'l':\n-                switch (to) {\n-                    case 'i':\n-                        return (ConvertInstruction) setOpcode(Constants.L2I);\n-                    case 'f':\n-                        return (ConvertInstruction) setOpcode(Constants.L2F);\n-                    case 'd':\n-                        return (ConvertInstruction) setOpcode(Constants.L2D);\n-                }\n-            case 'f':\n-                switch (to) {\n-                    case 'i':\n-                        return (ConvertInstruction) setOpcode(Constants.F2I);\n-                    case 'l':\n-                        return (ConvertInstruction) setOpcode(Constants.F2L);\n-                    case 'd':\n-                        return (ConvertInstruction) setOpcode(Constants.F2D);\n-                }\n-            case 'd':\n-                switch (to) {\n-                    case 'i':\n-                        return (ConvertInstruction) setOpcode(Constants.D2I);\n-                    case 'l':\n-                        return (ConvertInstruction) setOpcode(Constants.D2L);\n-                    case 'f':\n-                        return (ConvertInstruction) setOpcode(Constants.D2F);\n-                }\n-            default:\n-                throw new IllegalStateException();\n-        }\n-    }\n-\n-    /**\n-     * Set the type being converted from. Types that have no direct\n-     * support will be converted accordingly.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ConvertInstruction setFromType(Class type) {\n-        if (type == null)\n-            return setFromType((String) null);\n-        return setFromType(type.getName());\n-    }\n-\n-    /**\n-     * Set the type being converted from. Types that have no direct\n-     * support will be converted accordingly.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public ConvertInstruction setFromType(BCClass type) {\n-        if (type == null)\n-            return setFromType((String) null);\n-        return setFromType(type.getName());\n-    }\n-\n-    /**\n-     * ConvertInstructions are equal if the types they convert between are\n-     * either equal or unset.\n-     */\n-    public boolean equalsInstruction(Instruction other) {\n-        if (other == this)\n-            return true;\n-        if (!(other instanceof ConvertInstruction))\n-            return false;\n-\n-        ConvertInstruction ins = (ConvertInstruction) other;\n-        if (getOpcode() != Constants.NOP && getOpcode() == ins.getOpcode())\n-            return true;\n-\n-        String type = getTypeName();\n-        String otherType = ins.getTypeName();\n-        if (!(type == null || otherType == null || type.equals(otherType)))\n-            return false;\n-\n-        type = getFromTypeName();\n-        otherType = ins.getFromTypeName();\n-        return type == null || otherType == null || type.equals(otherType);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterConvertInstruction(this);\n-        visit.exitConvertInstruction(this);\n-    }\n-\n-    void read(Instruction orig) {\n-        super.read(orig);\n-\n-        ConvertInstruction ins = (ConvertInstruction) orig;\n-        _toType = ins._toType;\n-        _fromType = ins._fromType;\n-    }\n-}"},{"sha":"22bff4c2e4d45de3f705cd2d4b2d8baf553ced18","filename":"serp/src/main/java/serp/bytecode/Deprecated.java","status":"removed","additions":0,"deletions":32,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Deprecated.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Deprecated.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Deprecated.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,32 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Attribute signifying that a method or class is deprecated.\n- *\n- * @author Abe White\n- */\n-public class Deprecated extends Attribute {\n-\n-    Deprecated(int nameIndex, Attributes owner) {\n-        super(nameIndex, owner);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterDeprecated(this);\n-        visit.exitDeprecated(this);\n-    }\n-}"},{"sha":"792aaa86ae7b43b688f62ed189e7bca0ca4d3b96","filename":"serp/src/main/java/serp/bytecode/ExceptionHandler.java","status":"removed","additions":0,"deletions":300,"changes":300,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ExceptionHandler.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ExceptionHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ExceptionHandler.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,300 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.lowlevel.ClassEntry;\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.bytecode.visitor.VisitAcceptor;\n-import serp.util.Strings;\n-\n-/**\n- * Represents a <code>try {} catch() {}</code> statement in bytecode.\n- *\n- * @author Abe White\n- */\n-public class ExceptionHandler\n-    implements InstructionPtr, BCEntity, VisitAcceptor {\n-\n-    private int _catchIndex = 0;\n-    private Code _owner = null;\n-\n-    private InstructionPtrStrategy _tryStart = new InstructionPtrStrategy(this);\n-    private InstructionPtrStrategy _tryEnd = new InstructionPtrStrategy(this);\n-    private InstructionPtrStrategy _tryHandler =\n-        new InstructionPtrStrategy(this);\n-\n-    ExceptionHandler(Code owner) {\n-        _owner = owner;\n-    }\n-\n-    /**\n-     * Return the owning code block.\n-     */\n-    public Code getCode() {\n-        return _owner;\n-    }\n-\n-    ///////////////////\n-    // Body operations\n-    ///////////////////\n-\n-    /**\n-     * Return the instruction marking the beginning of the try {} block.\n-     */\n-    public Instruction getTryStart() {\n-        return _tryStart.getTargetInstruction();\n-    }\n-\n-    /**\n-     * Set the {@link Instruction} marking the beginning of the try block.\n-     * The instruction must already be a part of the method.\n-     */\n-    public void setTryStart(Instruction instruction) {\n-        _tryStart.setTargetInstruction(instruction);\n-    }\n-\n-    /**\n-     * Return the instruction at the end of the try {} block.\n-     */\n-    public Instruction getTryEnd() {\n-        return _tryEnd.getTargetInstruction();\n-    }\n-\n-    /**\n-     * Set the Instruction at the end of the try block. The\n-     * Instruction must already be a part of the method.\n-     */\n-    public void setTryEnd(Instruction instruction) {\n-        _tryEnd.setTargetInstruction(instruction);\n-    }\n-\n-    //////////////////////\n-    // Handler operations\n-    //////////////////////\n-\n-    /**\n-     * Return the instruction marking the beginning of the catch {} block.\n-     */\n-    public Instruction getHandlerStart() {\n-        return _tryHandler.getTargetInstruction();\n-    }\n-\n-    /**\n-     * Set the {@link Instruction} marking the beginning of the catch block.\n-     * The instruction must already be a part of the method.\n-     * WARNING: if this instruction is deleted, the results are undefined.\n-     */\n-    public void setHandlerStart(Instruction instruction) {\n-        _tryHandler.setTargetInstruction(instruction);\n-    }\n-\n-    ////////////////////\n-    // Catch operations\n-    ////////////////////\n-\n-    /**\n-     * Return the index into the class {@link ConstantPool} of the\n-     * {@link ClassEntry} describing the exception type this handler catches.\n-     */\n-    public int getCatchIndex() {\n-        return _catchIndex;\n-    }\n-\n-    /**\n-     * Set the index into the class {@link ConstantPool} of the\n-     * {@link ClassEntry} describing the exception type this handler catches.\n-     */\n-    public void setCatchIndex(int catchTypeIndex) {\n-        _catchIndex = catchTypeIndex;\n-    }\n-\n-    /**\n-     * Return the name of the exception type; returns null for catch-all\n-     * clauses used to implement finally blocks. The name will be returned\n-     * in a forum suitable for a {@link Class#forName} call.\n-     */\n-    public String getCatchName() {\n-        if (_catchIndex == 0)\n-            return null;\n-\n-        ClassEntry entry = (ClassEntry) getPool().getEntry(_catchIndex);\n-        return getProject().getNameCache().getExternalForm\n-            (entry.getNameEntry().getValue(), false);\n-    }\n-\n-    /**\n-     * Return the {@link Class} of the exception type; returns null for\n-     * catch-all clauses used to implement finally blocks.\n-     */\n-    public Class getCatchType() {\n-        String name = getCatchName();\n-        if (name == null)\n-            return null;\n-        return Strings.toClass(name, getClassLoader());\n-    }\n-\n-    /**\n-     * Return the bytecode of the exception type; returns null for\n-     * catch-all clauses used to implement finally blocks.\n-     */\n-    public BCClass getCatchBC() {\n-        String name = getCatchName();\n-        if (name == null)\n-            return null;\n-        return getProject().loadClass(name, getClassLoader());\n-    }\n-\n-    /**\n-     * Set the class of the exception type, or null for catch-all clauses used\n-     * with finally blocks.\n-     */\n-    public void setCatch(String name) {\n-        if (name == null)\n-            _catchIndex = 0;\n-        else\n-            _catchIndex = getPool().findClassEntry(getProject().\n-                getNameCache().getInternalForm(name, false), true);\n-    }\n-\n-    /**\n-     * Set the class of the exception type, or null for catch-all clauses used\n-     * for finally blocks.\n-     */\n-    public void setCatch(Class type) {\n-        if (type == null)\n-            setCatch((String) null);\n-        else\n-            setCatch(type.getName());\n-    }\n-\n-    /**\n-     * Set the class of the exception type, or null for catch-all clauses used\n-     * for finally blocks.\n-     */\n-    public void setCatch(BCClass type) {\n-        if (type == null)\n-            setCatch((String) null);\n-        else\n-            setCatch(type.getName());\n-    }\n-\n-    /////////////////////////////////\n-    // InstructionPtr implementation\n-    /////////////////////////////////\n-\n-    public void updateTargets() {\n-        _tryStart.updateTargets();\n-        _tryEnd.updateTargets();\n-        _tryHandler.updateTargets();\n-    }\n-\n-    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n-        _tryStart.replaceTarget(oldTarget, newTarget);\n-        _tryEnd.replaceTarget(oldTarget, newTarget);\n-        _tryHandler.replaceTarget(oldTarget, newTarget);\n-    }\n-\n-    ///////////////////////////\n-    // BCEntity implementation\n-    ///////////////////////////\n-\n-    public Project getProject() {\n-        return _owner.getProject();\n-    }\n-\n-    public ConstantPool getPool() {\n-        return _owner.getPool();\n-    }\n-\n-    public ClassLoader getClassLoader() {\n-        return _owner.getClassLoader();\n-    }\n-\n-    public boolean isValid() {\n-        return _owner != null;\n-    }\n-\n-    ////////////////////////////////\n-    // VisitAcceptor implementation\n-    ////////////////////////////////\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterExceptionHandler(this);\n-        visit.exitExceptionHandler(this);\n-    }\n-\n-    //////////////////\n-    // I/O operations\n-    //////////////////\n-\n-    void read(ExceptionHandler orig) {\n-        _tryStart.setByteIndex(orig._tryStart.getByteIndex());\n-        _tryEnd.setByteIndex(orig._tryEnd.getByteIndex());\n-        _tryHandler.setByteIndex(orig._tryHandler.getByteIndex());\n-\n-        // done at a high level so that if the name isn't in our constant pool,\n-        // it will be added\n-        setCatch(orig.getCatchName());\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        setTryStart(in.readUnsignedShort());\n-        setTryEnd(in.readUnsignedShort());\n-        setHandlerStart(in.readUnsignedShort());\n-        setCatchIndex(in.readUnsignedShort());\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        out.writeShort(getTryStartPc());\n-        out.writeShort(getTryEndPc());\n-        out.writeShort(getHandlerStartPc());\n-        out.writeShort(getCatchIndex());\n-    }\n-\n-    public void setTryStart(int start) {\n-        _tryStart.setByteIndex(start);\n-    }\n-\n-    public int getTryStartPc() {\n-        return _tryStart.getByteIndex();\n-    }\n-\n-    public void setTryEnd(int end) {\n-        setTryEnd((Instruction) _owner.getInstruction(end).prev);\n-    }\n-\n-    /**\n-     * Return the program counter end position for this exception handler.\n-     * This represents an index into the code byte array.\n-     */\n-    public int getTryEndPc() {\n-        return _tryEnd.getByteIndex() + getTryEnd().getLength();\n-    }\n-\n-    public void setHandlerStart(int handler) {\n-        _tryHandler.setByteIndex(handler);\n-    }\n-\n-    public int getHandlerStartPc() {\n-        return _tryHandler.getByteIndex();\n-    }\n-\n-    void invalidate() {\n-        _owner = null;\n-    }\n-}"},{"sha":"b72cb7c386d429b77c3b33acf82830bd2b2d1db1","filename":"serp/src/main/java/serp/bytecode/Exceptions.java","status":"removed","additions":0,"deletions":291,"changes":291,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Exceptions.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Exceptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Exceptions.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,291 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import serp.bytecode.lowlevel.ClassEntry;\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.util.Numbers;\n-import serp.util.Strings;\n-\n-/**\n- * Attribute declaring the checked exceptions a method can throw.\n- *\n- * @author Abe White\n- */\n-public class Exceptions extends Attribute {\n-\n-    private List _indexes = new LinkedList();\n-\n-    Exceptions(int nameIndex, Attributes owner) {\n-        super(nameIndex, owner);\n-    }\n-\n-    int getLength() {\n-        return 2 + 2 * _indexes.size();\n-    }\n-\n-    /**\n-     * Return the owning method.\n-     */\n-    public BCMethod getMethod() {\n-        return (BCMethod) getOwner();\n-    }\n-\n-    /**\n-     * Return the indexes in the class {@link ConstantPool} of the\n-     * {@link ClassEntry}s for the exception types thrown by this method, or\n-     * an empty array if none.\n-     */\n-    public int[] getExceptionIndexes() {\n-        int[] indexes = new int[_indexes.size()];\n-        Iterator itr = _indexes.iterator();\n-        for (int i = 0; i < indexes.length; i++)\n-            indexes[i] = ((Integer) itr.next()).intValue();\n-        return indexes;\n-    }\n-\n-    /**\n-     * Set the indexes in the class {@link ConstantPool} of the\n-     * {@link ClassEntry}s for the exception types thrown by this method. Use\n-     * null or an empty array for none.\n-     */\n-    public void setExceptionIndexes(int[] exceptionIndexes) {\n-        _indexes.clear();\n-        if (exceptionIndexes != null)\n-            for (int i = 0; i < exceptionIndexes.length; i++)\n-                _indexes.add(Numbers.valueOf(exceptionIndexes[i]));\n-    }\n-\n-    /**\n-     * Return the names of the exception types for this method, or an empty\n-     * array if none. The names will be in a form suitable for a\n-     * {@link Class#forName} call.\n-     */\n-    public String[] getExceptionNames() {\n-        String[] names = new String[_indexes.size()];\n-        Iterator itr = _indexes.iterator();\n-        int index;\n-        ClassEntry entry;\n-        for (int i = 0; i < names.length; i++) {\n-            index = ((Number) itr.next()).intValue();\n-            entry = (ClassEntry) getPool().getEntry(index);\n-            names[i] = getProject().getNameCache().getExternalForm\n-                (entry.getNameEntry().getValue(), false);\n-        }\n-        return names;\n-    }\n-\n-    /**\n-     * Return the {@link Class} objects for the exception types for this\n-     * method, or an empty array if none.\n-     */\n-    public Class[] getExceptionTypes() {\n-        String[] names = getExceptionNames();\n-        Class[] types = new Class[names.length];\n-        for (int i = 0; i < names.length; i++)\n-            types[i] = Strings.toClass(names[i], getClassLoader());\n-        return types;\n-    }\n-\n-    /**\n-     * Return bytecode for the exception types of this\n-     * method, or an empty array if none.\n-     */\n-    public BCClass[] getExceptionBCs() {\n-        String[] names = getExceptionNames();\n-        BCClass[] types = new BCClass[names.length];\n-        for (int i = 0; i < names.length; i++)\n-            types[i] = getProject().loadClass(names[i], getClassLoader());\n-        return types;\n-    }\n-\n-    /**\n-     * Set the checked exceptions thrown by this method. Use null or an\n-     * empty array for none.\n-     */\n-    public void setExceptions(String[] exceptions) {\n-        if (exceptions != null)\n-            for (int i = 0; i < exceptions.length; i++)\n-                if (exceptions[i] == null)\n-                    throw new NullPointerException(\"exceptions[\" + i\n-                        + \"] = null\");\n-\n-        clear();\n-        if (exceptions != null)\n-            for (int i = 0; i < exceptions.length; i++)\n-                addException(exceptions[i]);\n-    }\n-\n-    /**\n-     * Set the checked exceptions thrown by this method. Use null or an\n-     * empty array for none.\n-     */\n-    public void setExceptions(Class[] exceptions) {\n-        String[] names = null;\n-        if (exceptions != null) {\n-            names = new String[exceptions.length];\n-            for (int i = 0; i < exceptions.length; i++)\n-                names[i] = exceptions[i].getName();\n-        }\n-        setExceptions(names);\n-    }\n-\n-    /**\n-     * Set the checked exceptions thrown by this method. Use null or an\n-     * empty array for none.\n-     */\n-    public void setExceptions(BCClass[] exceptions) {\n-        String[] names = null;\n-        if (exceptions != null) {\n-            names = new String[exceptions.length];\n-            for (int i = 0; i < exceptions.length; i++)\n-                names[i] = exceptions[i].getName();\n-        }\n-        setExceptions(names);\n-    }\n-\n-    /**\n-     * Clear this method of all exception declarations.\n-     */\n-    public void clear() {\n-        _indexes.clear();\n-    }\n-\n-    /**\n-     * Remove an exception type thrown by this method.\n-     *\n-     * @return true if the method had the exception type, false otherwise\n-     */\n-    public boolean removeException(String type) {\n-        String internalForm = getProject().getNameCache().\n-            getInternalForm(type, false);\n-        ClassEntry entry;\n-        for (Iterator itr = _indexes.iterator(); itr.hasNext();) {\n-            entry = (ClassEntry) getPool().getEntry\n-                (((Integer) itr.next()).intValue());\n-\n-            if (entry.getNameEntry().getValue().equals(internalForm)) {\n-                itr.remove();\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Remove an exception thrown by this method.\n-     *\n-     * @return true if the method had the exception type, false otherwise\n-     */\n-    public boolean removeException(Class type) {\n-        if (type == null)\n-            return false;\n-        return removeException(type.getName());\n-    }\n-\n-    /**\n-     * Remove an exception thrown by this method.\n-     *\n-     * @return true if the method had the exception type, false otherwise\n-     */\n-    public boolean removeException(BCClass type) {\n-        if (type == null)\n-            return false;\n-        return removeException(type.getName());\n-    }\n-\n-    /**\n-     * Add an exception type to those thrown by this method.\n-     */\n-    public void addException(String type) {\n-        int index = getPool().findClassEntry(getProject().getNameCache().\n-            getInternalForm(type, false), true);\n-        _indexes.add(Numbers.valueOf(index));\n-    }\n-\n-    /**\n-     * Add an exception to those thrown by this method.\n-     */\n-    public void addException(Class type) {\n-        addException(type.getName());\n-    }\n-\n-    /**\n-     * Add an exception to those thrown by this method.\n-     */\n-    public void addException(BCClass type) {\n-        addException(type.getName());\n-    }\n-\n-    /**\n-     * Return true if the method declares that it throws the given\n-     * exception type.\n-     */\n-    public boolean throwsException(String type) {\n-        String[] exceptions = getExceptionNames();\n-        for (int i = 0; i < exceptions.length; i++)\n-            if (exceptions[i].equals(type))\n-                return true;\n-        return false;\n-    }\n-\n-    /**\n-     * Return true if the method declares that it throws the given\n-     * exception type.\n-     */\n-    public boolean throwsException(Class type) {\n-        if (type == null)\n-            return false;\n-        return throwsException(type.getName());\n-    }\n-\n-    /**\n-     * Return true if the method declares that it throws the given\n-     * exception type.\n-     */\n-    public boolean throwsException(BCClass type) {\n-        if (type == null)\n-            return false;\n-        return throwsException(type.getName());\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterExceptions(this);\n-        visit.exitExceptions(this);\n-    }\n-\n-    void read(Attribute other) {\n-        setExceptions(((Exceptions) other).getExceptionNames());\n-    }\n-\n-    void read(DataInput in, int length) throws IOException {\n-        _indexes.clear();\n-        int exceptionCount = in.readUnsignedShort();\n-        for (int i = 0; i < exceptionCount; i++)\n-            _indexes.add(Numbers.valueOf((int) in.readUnsignedShort()));\n-    }\n-\n-    void write(DataOutput out, int length) throws IOException {\n-        out.writeShort(_indexes.size());\n-        for (Iterator itr = _indexes.iterator(); itr.hasNext();)\n-            out.writeShort(((Number) itr.next()).shortValue());\n-    }\n-}"},{"sha":"32c8d75b2160ab14ae395db7bf78458275c36a20","filename":"serp/src/main/java/serp/bytecode/FieldInstruction.java","status":"removed","additions":0,"deletions":420,"changes":420,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/FieldInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/FieldInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/FieldInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,420 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.lang.reflect.Field;\n-\n-import serp.bytecode.lowlevel.ComplexEntry;\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.util.Strings;\n-\n-/**\n- * Instruction that takes as an argument a field to operate\n- * on. Examples include <code>getfield, getstatic, setfield, setstatic</code>.\n- *\n- * @author Abe White\n- */\n-public abstract class FieldInstruction extends Instruction {\n-\n-    private int _index = 0;\n-\n-    FieldInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    int getLength() {\n-        return super.getLength() + 2;\n-    }\n-\n-    ////////////////////\n-    // Field operations\n-    ////////////////////\n-\n-    /**\n-     * Return the index in the class {@link ConstantPool} of the\n-     * {@link ComplexEntry} describing the field to operate on.\n-     */\n-    public int getFieldIndex() {\n-        return _index;\n-    }\n-\n-    /**\n-     * Set the index in the class {@link ConstantPool} of the\n-     * {@link ComplexEntry} describing the field to operate on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setFieldIndex(int index) {\n-        _index = index;\n-        return this;\n-    }\n-\n-    /**\n-     * Return the field this instruction operates on, or null if not set.\n-     */\n-    public BCField getField() {\n-        String dec = getFieldDeclarerName();\n-        if (dec == null)\n-            return null;\n-\n-        BCClass bc = getProject().loadClass(dec, getClassLoader());\n-        BCField[] fields = bc.getFields(getFieldName());\n-\n-        if (fields.length == 0)\n-            return null;\n-        return fields[0];\n-    }\n-\n-    /**\n-     * Set the field this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setField(BCField field) {\n-        if (field == null)\n-            return setFieldIndex(0);\n-        return setField(field.getDeclarer().getName(), field.getName(),\n-            field.getTypeName());\n-    }\n-\n-    /**\n-     * Set the field this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setField(Field field) {\n-        if (field == null)\n-            return setFieldIndex(0);\n-        return setField(field.getDeclaringClass(), field.getName(),\n-            field.getType());\n-    }\n-\n-    /**\n-     * Set the field this instruction operates on.\n-     *\n-     * @param dec the full class name of the field's declaring class\n-     * @param name the field name\n-     * @param type the full class name of the field type\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setField(String dec, String name, String type) {\n-        if (dec == null && name == null && type == null)\n-            return setFieldIndex(0);\n-\n-        if (dec == null)\n-            dec = \"\";\n-        if (name == null)\n-            name = \"\";\n-        if (type == null)\n-            type = \"\";\n-\n-        dec = getProject().getNameCache().getInternalForm(dec, false);\n-        type = getProject().getNameCache().getInternalForm(type, true);\n-\n-        return setFieldIndex(getPool().findFieldEntry(dec, name, type, true));\n-    }\n-\n-    /**\n-     * Set the field this instruction operates on, for fields that are\n-     * declared by the current class.\n-     *\n-     * @param name the field name\n-     * @param type the full class name of the field type\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setField(String name, String type) {\n-        BCClass owner = getCode().getMethod().getDeclarer();\n-        return setField(owner.getName(), name, type);\n-    }\n-\n-    /**\n-     * Set the field this instruction operates on.\n-     *\n-     * @param dec the field's declaring class\n-     * @param name the field name\n-     * @param type the class of the field type\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setField(Class dec, String name, Class type) {\n-        String decName = (dec == null) ? null : dec.getName();\n-        String typeName = (type == null) ? null : type.getName();\n-        return setField(decName, name, typeName);\n-    }\n-\n-    /**\n-     * Set the field this instruction operates on, for fields that are\n-     * declared by the current class.\n-     *\n-     * @param name the field name\n-     * @param type the class of the field type\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setField(String name, Class type) {\n-        BCClass owner = getCode().getMethod().getDeclarer();\n-        String typeName = (type == null) ? null : type.getName();\n-        return setField(owner.getName(), name, typeName);\n-    }\n-\n-    /**\n-     * Set the field this instruction operates on.\n-     *\n-     * @param dec the field's declaring class\n-     * @param name the field name\n-     * @param type the class of the field type\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setField(BCClass dec, String name, BCClass type) {\n-        String decName = (dec == null) ? null : dec.getName();\n-        String typeName = (type == null) ? null : type.getName();\n-        return setField(decName, name, typeName);\n-    }\n-\n-    /**\n-     * Set the field this instruction operates on, for fields that are\n-     * declared by the current class.\n-     *\n-     * @param name the field name\n-     * @param type the class of the field type\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setField(String name, BCClass type) {\n-        BCClass owner = getCode().getMethod().getDeclarer();\n-        String typeName = (type == null) ? null : type.getName();\n-        return setField(owner.getName(), name, typeName);\n-    }\n-\n-    ////////////////////////////////\n-    // Name, Type, Owner operations\n-    ////////////////////////////////\n-\n-    /**\n-     * Return the name of the field this instruction operates on, or null\n-     * if not set.\n-     */\n-    public String getFieldName() {\n-        int index = getFieldIndex();\n-        if (index == 0)\n-            return null;\n-\n-        ComplexEntry entry = (ComplexEntry) getPool().getEntry(index);\n-        String name = entry.getNameAndTypeEntry().getNameEntry().getValue();\n-        if (name.length() == 0)\n-            return null;\n-        return name;\n-    }\n-\n-    /**\n-     * Set the name of the field this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setFieldName(String name) {\n-        return setField(getFieldDeclarerName(), name, getFieldTypeName());\n-    }\n-\n-    /**\n-     * Return the type of the field this instruction operates on, or null\n-     * if not set.\n-     */\n-    public String getFieldTypeName() {\n-        int index = getFieldIndex();\n-        if (index == 0)\n-            return null;\n-\n-        ComplexEntry entry = (ComplexEntry) getPool().getEntry(index);\n-        String name = getProject().getNameCache().getExternalForm(entry.\n-            getNameAndTypeEntry().getDescriptorEntry().getValue(), false);\n-        if (name.length() == 0)\n-            return null;\n-        return name;\n-    }\n-\n-    /**\n-     * Return the type of the field this instruction operates on, or null\n-     * if not set.\n-     */\n-    public Class getFieldType() {\n-        String type = getFieldTypeName();\n-        if (type == null)\n-            return null;\n-        return Strings.toClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Return the type of the field this instruction operates on, or null\n-     * if not set.\n-     */\n-    public BCClass getFieldTypeBC() {\n-        String type = getFieldTypeName();\n-        if (type == null)\n-            return null;\n-        return getProject().loadClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Set the type of the field this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setFieldType(String type) {\n-        return setField(getFieldDeclarerName(), getFieldName(), type);\n-    }\n-\n-    /**\n-     * Set the type of the field this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setFieldType(Class type) {\n-        String name = null;\n-        if (type != null)\n-            name = type.getName();\n-        return setFieldType(name);\n-    }\n-\n-    /**\n-     * Set the type of the field this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setFieldType(BCClass type) {\n-        String name = null;\n-        if (type != null)\n-            name = type.getName();\n-        return setFieldType(name);\n-    }\n-\n-    /**\n-     * Return the declaring class of the field this instruction operates on,\n-     * or null if not set.\n-     */\n-    public String getFieldDeclarerName() {\n-        int index = getFieldIndex();\n-        if (index == 0)\n-            return null;\n-\n-        ComplexEntry entry = (ComplexEntry) getPool().getEntry(index);\n-        String name = getProject().getNameCache().getExternalForm(entry.\n-            getClassEntry().getNameEntry().getValue(), false);\n-        if (name.length() == 0)\n-            return null;\n-        return name;\n-    }\n-\n-    /**\n-     * Return the declaring class of the field this instruction operates on,\n-     * or null if not set.\n-     */\n-    public Class getFieldDeclarerType() {\n-        String type = getFieldDeclarerName();\n-        if (type == null)\n-            return null;\n-        return Strings.toClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Return the declaring class of the field this instruction operates on,\n-     * or null if not set.\n-     */\n-    public BCClass getFieldDeclarerBC() {\n-        String type = getFieldDeclarerName();\n-        if (type == null)\n-            return null;\n-        return getProject().loadClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Set the declaring class of the field this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setFieldDeclarer(String type) {\n-        return setField(type, getFieldName(), getFieldTypeName());\n-    }\n-\n-    /**\n-     * Set the declaring class of the field this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setFieldDeclarer(Class type) {\n-        String name = null;\n-        if (type != null)\n-            name = type.getName();\n-        return setFieldDeclarer(name);\n-    }\n-\n-    /**\n-     * Set the declaring class of the field this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public FieldInstruction setFieldDeclarer(BCClass type) {\n-        String name = null;\n-        if (type != null)\n-            name = type.getName();\n-        return setFieldDeclarer(name);\n-    }\n-\n-    /**\n-     * FieldInstructions are equal if the field they reference is the same,\n-     * or if the field of either is unset.\n-     */\n-    public boolean equalsInstruction(Instruction other) {\n-        if (other == this)\n-            return true;\n-        if (!(other instanceof FieldInstruction))\n-            return false;\n-        if (!super.equalsInstruction(other))\n-            return false;\n-\n-        FieldInstruction ins = (FieldInstruction) other;\n-\n-        String s1 = getFieldName();\n-        String s2 = ins.getFieldName();\n-        if (!(s1 == null || s2 == null || s1.equals(s2)))\n-            return false;\n-\n-        s1 = getFieldTypeName();\n-        s2 = ins.getFieldTypeName();\n-        if (!(s1 == null || s2 == null || s1.equals(s2)))\n-            return false;\n-\n-        s1 = getFieldDeclarerName();\n-        s2 = ins.getFieldDeclarerName();\n-        if (!(s1 == null || s2 == null || s1.equals(s2)))\n-            return false;\n-\n-        return true;\n-    }\n-\n-    void read(Instruction orig) {\n-        super.read(orig);\n-        FieldInstruction ins = (FieldInstruction) orig;\n-        setField(ins.getFieldDeclarerName(), ins.getFieldName(),\n-            ins.getFieldTypeName());\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        super.read(in);\n-        setFieldIndex(in.readUnsignedShort());\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        super.write(out);\n-        out.writeShort(getFieldIndex());\n-    }\n-}"},{"sha":"7b9133a54e61afcf3bf078f72c096b4ce52ff616","filename":"serp/src/main/java/serp/bytecode/GetFieldInstruction.java","status":"removed","additions":0,"deletions":52,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/GetFieldInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/GetFieldInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/GetFieldInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,52 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Loads a value from a field onto the stack.\n- *\n- * @author Abe White\n- */\n-public class GetFieldInstruction extends FieldInstruction {\n-\n-    GetFieldInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    public int getLogicalStackChange() {\n-        if (getOpcode() == Constants.GETSTATIC)\n-            return 1;\n-        return 0;\n-    }\n-\n-    public int getStackChange() {\n-        String type = getFieldTypeName();\n-        if (type == null)\n-            return 0;\n-\n-        int stack = 0;\n-        if (long.class.getName().equals(type)\n-            || double.class.getName().equals(type))\n-            stack++;\n-        if (getOpcode() == Constants.GETSTATIC)\n-            stack++;\n-        return stack;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterGetFieldInstruction(this);\n-        visit.exitGetFieldInstruction(this);\n-    }\n-}"},{"sha":"a36a0b26c7fd7f8f8dc286db787dc0a69c8972a8","filename":"serp/src/main/java/serp/bytecode/IIncInstruction.java","status":"removed","additions":0,"deletions":89,"changes":89,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/IIncInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/IIncInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/IIncInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,89 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * The <code>iinc</code> instruction.\n- *\n- * @author Abe White\n- */\n-public class IIncInstruction extends LocalVariableInstruction {\n-\n-    private int _inc = 0;\n-\n-    IIncInstruction(Code owner) {\n-        super(owner, Constants.IINC);\n-    }\n-\n-    int getLength() {\n-        return super.getLength() + 2;\n-    }\n-\n-    /**\n-     * Return the increment for this IINC instruction.\n-     */\n-    public int getIncrement() {\n-        return _inc;\n-    }\n-\n-    /**\n-     * Set the increment on this IINC instruction.\n-     *\n-     * @return this Instruction, for method chaining\n-     */\n-    public IIncInstruction setIncrement(int val) {\n-        _inc = val;\n-        return this;\n-    }\n-\n-    public boolean equalsInstruction(Instruction other) {\n-        if (this == other)\n-            return true;\n-        if (!(other instanceof IIncInstruction))\n-            return false;\n-        if (!super.equalsInstruction(other))\n-            return false;\n-\n-        IIncInstruction ins = (IIncInstruction) other;\n-        return (getIncrement() == 0 || ins.getIncrement() == 0\n-            || getIncrement() == ins.getIncrement());\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterIIncInstruction(this);\n-        visit.exitIIncInstruction(this);\n-    }\n-\n-    void read(Instruction other) {\n-        super.read(other);\n-        setIncrement(((IIncInstruction) other).getIncrement());\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        super.read(in);\n-        setLocal(in.readUnsignedByte());\n-        setIncrement(in.readByte());\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        super.write(out);\n-        out.writeByte(getLocal());\n-        out.writeByte(getIncrement());\n-    }\n-}"},{"sha":"3f98f7f62377f49b9a7aca344713186e782a38e4","filename":"serp/src/main/java/serp/bytecode/IfInstruction.java","status":"removed","additions":0,"deletions":73,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/IfInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/IfInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/IfInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,73 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * An if instruction such as <code>ifnull, ifeq</code>, etc.\n- *\n- * @author Abe White\n- */\n-public class IfInstruction extends JumpInstruction {\n-\n-    IfInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    public int getLogicalStackChange() {\n-        return getStackChange();\n-    }\n-\n-    public int getStackChange() {\n-        switch (getOpcode()) {\n-            case Constants.IFACMPEQ:\n-            case Constants.IFACMPNE:\n-            case Constants.IFICMPEQ:\n-            case Constants.IFICMPNE:\n-            case Constants.IFICMPLT:\n-            case Constants.IFICMPGT:\n-            case Constants.IFICMPLE:\n-            case Constants.IFICMPGE:\n-                return -2;\n-            case Constants.IFEQ:\n-            case Constants.IFNE:\n-            case Constants.IFLT:\n-            case Constants.IFGT:\n-            case Constants.IFLE:\n-            case Constants.IFGE:\n-            case Constants.IFNULL:\n-            case Constants.IFNONNULL:\n-                return -1;\n-            default:\n-                return super.getStackChange();\n-        }\n-    }\n-\n-    public String getTypeName() {\n-        switch (getOpcode()) {\n-            case Constants.IFACMPEQ:\n-            case Constants.IFACMPNE:\n-            case Constants.IFNULL:\n-            case Constants.IFNONNULL:\n-                return \"java.lang.Object\";\n-            default:\n-                return \"I\";\n-        }\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterIfInstruction(this);\n-        visit.exitIfInstruction(this);\n-    }\n-}"},{"sha":"1cd9bfaaf831aeade02ec87f0b81b165d67a2f6b","filename":"serp/src/main/java/serp/bytecode/InnerClass.java","status":"removed","additions":0,"deletions":441,"changes":441,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/InnerClass.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/InnerClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/InnerClass.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,441 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.lowlevel.ClassEntry;\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.bytecode.lowlevel.UTF8Entry;\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.bytecode.visitor.VisitAcceptor;\n-import serp.util.Strings;\n-\n-/**\n- * Any referenced class that is not a package member is represented by\n- * this structure. This includes member classes and interfaces.\n- *\n- * @author Abe White\n- */\n-public class InnerClass implements BCEntity, VisitAcceptor {\n-\n-    private int _index = 0;\n-    private int _nameIndex = 0;\n-    private int _ownerIndex = 0;\n-    private int _access = Constants.ACCESS_PRIVATE;\n-\n-    private InnerClasses _owner = null;\n-\n-    InnerClass(InnerClasses owner) {\n-        _owner = owner;\n-    }\n-\n-    /**\n-     * Inner classes are stored in an {@link InnerClasses} attribute.\n-     */\n-    public InnerClasses getOwner() {\n-        return _owner;\n-    }\n-\n-    void invalidate() {\n-        _owner = null;\n-    }\n-\n-    /////////////////////\n-    // Access operations\n-    /////////////////////\n-\n-    /**\n-     * Return the access flags of the inner class.\n-     */\n-    public int getAccessFlags() {\n-        return _access;\n-    }\n-\n-    /**\n-     * Set the access flags of the inner class.\n-     */\n-    public void setAccessFlags(int accessFlags) {\n-        _access = accessFlags;\n-    }\n-\n-    /**\n-     * Manipulate the inner class access flags.\n-     */\n-    public boolean isPublic() {\n-        return (getAccessFlags() & Constants.ACCESS_PUBLIC) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the inner class access flags.\n-     */\n-    public void makePublic() {\n-        setAccessFlags(getAccessFlags() | Constants.ACCESS_PUBLIC);\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PRIVATE);\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PROTECTED);\n-    }\n-\n-    /**\n-     * Manipulate the inner class access flags.\n-     */\n-    public boolean isProtected() {\n-        return (getAccessFlags() & Constants.ACCESS_PROTECTED) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the inner class access flags.\n-     */\n-    public void makeProtected() {\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PUBLIC);\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PRIVATE);\n-        setAccessFlags(getAccessFlags() | Constants.ACCESS_PROTECTED);\n-    }\n-\n-    /**\n-     * Manipulate the inner class access flags.\n-     */\n-    public boolean isPrivate() {\n-        return (getAccessFlags() & Constants.ACCESS_PRIVATE) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the inner class access flags.\n-     */\n-    public void makePrivate() {\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PUBLIC);\n-        setAccessFlags(getAccessFlags() | Constants.ACCESS_PRIVATE);\n-        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PROTECTED);\n-    }\n-\n-    /**\n-     * Manipulate the inner class access flags.\n-     */\n-    public boolean isFinal() {\n-        return (getAccessFlags() & Constants.ACCESS_FINAL) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the inner class access flags.\n-     */\n-    public void setFinal(boolean on) {\n-        if (on)\n-            setAccessFlags(getAccessFlags() | Constants.ACCESS_FINAL);\n-        else\n-            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_FINAL);\n-    }\n-\n-    /**\n-     * Manipulate the inner class access flags.\n-     */\n-    public boolean isStatic() {\n-        return (getAccessFlags() & Constants.ACCESS_STATIC) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the inner class access flags.\n-     */\n-    public void setStatic(boolean on) {\n-        if (on)\n-            setAccessFlags(getAccessFlags() | Constants.ACCESS_STATIC);\n-        else\n-            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_STATIC);\n-    }\n-\n-    /**\n-     * Manipulate the class access flags.\n-     */\n-    public boolean isInterface() {\n-        return (getAccessFlags() & Constants.ACCESS_INTERFACE) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the class access flags.\n-     */\n-    public void setInterface(boolean on) {\n-        if (on) {\n-            setAccessFlags(getAccessFlags() | Constants.ACCESS_INTERFACE);\n-            setAbstract(true);\n-        } else\n-            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_INTERFACE);\n-    }\n-\n-    /**\n-     * Manipulate the class access flags.\n-     */\n-    public boolean isAbstract() {\n-        return (getAccessFlags() & Constants.ACCESS_ABSTRACT) > 0;\n-    }\n-\n-    /**\n-     * Manipulate the class access flags.\n-     */\n-    public void setAbstract(boolean on) {\n-        if (on)\n-            setAccessFlags(getAccessFlags() | Constants.ACCESS_INTERFACE);\n-        else\n-            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_INTERFACE);\n-    }\n-\n-    ////////////////////////////////\n-    // Name, type, owner operations\n-    ////////////////////////////////\n-\n-    /**\n-     * Return the {@link ConstantPool} index of the {@link UTF8Entry} that\n-     * describes the simple name this class is referred to in source, or\n-     * 0 for anonymous classes.\n-     */\n-    public int getNameIndex() {\n-        return _nameIndex;\n-    }\n-\n-    /**\n-     * Set the {@link ConstantPool} index of the {@link UTF8Entry} that\n-     * describes the simple name this class is referred to in source, or\n-     * 0 for anonymous classes.\n-     */\n-    public void setNameIndex(int nameIndex) {\n-        _nameIndex = nameIndex;\n-    }\n-\n-    /**\n-     * Return the simple name of this inner class, or null if anonymous.\n-     */\n-    public String getName() {\n-        if (getNameIndex() == 0)\n-            return null;\n-        return ((UTF8Entry) getPool().getEntry(getNameIndex())).getValue();\n-    }\n-\n-    /**\n-     * Set the simple name of this inner class.\n-     */\n-    public void setName(String name) {\n-        if (name == null)\n-            setNameIndex(0);\n-        else\n-            setNameIndex(getPool().findUTF8Entry(name, true));\n-    }\n-\n-    /**\n-     * Return the {@link ConstantPool} index of the {@link ClassEntry} that\n-     * describes this class, or 0 if none.\n-     */\n-    public int getTypeIndex() {\n-        return _index;\n-    }\n-\n-    /**\n-     * Set the {@link ConstantPool} index of the {@link ClassEntry} that\n-     * describes this class.\n-     */\n-    public void setTypeIndex(int index) {\n-        _index = index;\n-    }\n-\n-    /**\n-     * Return the full name of the inner class, or null if unset.\n-     */\n-    public String getTypeName() {\n-        if (getTypeIndex() == 0)\n-            return null;\n-\n-        ClassEntry entry = (ClassEntry) getPool().getEntry(getTypeIndex());\n-        return getProject().getNameCache().getExternalForm\n-            (entry.getNameEntry().getValue(), false);\n-    }\n-\n-    /**\n-     * Return the type of the inner class.\n-     * If the type has not been set, this method will return null.\n-     */\n-    public Class getType() {\n-        String type = getTypeName();\n-        if (type == null)\n-            return null;\n-        return Strings.toClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Return the type for this instruction.\n-     * If the type has not been set, this method will return null.\n-     */\n-    public BCClass getTypeBC() {\n-        String type = getTypeName();\n-        if (type == null)\n-            return null;\n-        return getProject().loadClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Set the type of this inner class.\n-     */\n-    public void setType(String type) {\n-        if (type == null)\n-            setTypeIndex(0);\n-        else {\n-            type = getProject().getNameCache().getInternalForm(type, false);\n-            setTypeIndex(getPool().findClassEntry(type, true));\n-        }\n-    }\n-\n-    /**\n-     * Set the type of this inner class.\n-     */\n-    public void setType(Class type) {\n-        if (type == null)\n-            setType((String) null);\n-        else\n-            setType(type.getName());\n-    }\n-\n-    /**\n-     * Set the type of this inner class.\n-     */\n-    public void setType(BCClass type) {\n-        if (type == null)\n-            setType((String) null);\n-        else\n-            setType(type.getName());\n-    }\n-\n-    /**\n-     * Return the {@link ConstantPool} index of the {@link ClassEntry} that\n-     * describes the declaring class, or 0 if this class is not a member class.\n-     */\n-    public int getDeclarerIndex() {\n-        return _ownerIndex;\n-    }\n-\n-    /**\n-     * Set the {@link ConstantPool} index of the {@link ClassEntry} that\n-     * describes the declaring class, or 0 if this class is not a member class.\n-     */\n-    public void setDeclarerIndex(int ownerIndex) {\n-        _ownerIndex = ownerIndex;\n-    }\n-\n-    /**\n-     * Return the full name of the declaring class, or null if unset/not a\n-     * member.\n-     */\n-    public String getDeclarerName() {\n-        if (getDeclarerIndex() == 0)\n-            return null;\n-\n-        ClassEntry entry = (ClassEntry) getPool().getEntry(getDeclarerIndex());\n-        return getProject().getNameCache().getExternalForm\n-            (entry.getNameEntry().getValue(), false);\n-    }\n-\n-    /**\n-     * Return the type of the declaring class.\n-     * If the type has not been set or the class is not a member, this method\n-     * will return null.\n-     */\n-    public Class getDeclarerType() {\n-        String type = getDeclarerName();\n-        if (type == null)\n-            return null;\n-        return Strings.toClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Return the type for this instruction.\n-     * If the type has not been set or the class is not a member, this method\n-     * will return null.\n-     */\n-    public BCClass getDeclarerBC() {\n-        String type = getDeclarerName();\n-        if (type == null)\n-            return null;\n-        return getProject().loadClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Set the type of this declaring class.\n-     */\n-    public void setDeclarer(String type) {\n-        if (type == null)\n-            setDeclarerIndex(0);\n-        else {\n-            type = getProject().getNameCache().getInternalForm(type, false);\n-            setDeclarerIndex(getPool().findClassEntry(type, true));\n-        }\n-    }\n-\n-    /**\n-     * Set the type of this declaring class.\n-     */\n-    public void setDeclarer(Class type) {\n-        if (type == null)\n-            setDeclarer((String) null);\n-        else\n-            setDeclarer(type.getName());\n-    }\n-\n-    /**\n-     * Set the type of this declaring class.\n-     */\n-    public void setDeclarer(BCClass type) {\n-        if (type == null)\n-            setDeclarer((String) null);\n-        else\n-            setDeclarer(type.getName());\n-    }\n-\n-    ///////////////////////////\n-    // BCEntity implementation\n-    ///////////////////////////\n-\n-    public Project getProject() {\n-        return _owner.getProject();\n-    }\n-\n-    public ConstantPool getPool() {\n-        return _owner.getPool();\n-    }\n-\n-    public ClassLoader getClassLoader() {\n-        return _owner.getClassLoader();\n-    }\n-\n-    public boolean isValid() {\n-        return _owner != null;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterInnerClass(this);\n-        visit.exitInnerClass(this);\n-    }\n-\n-    //////////////////\n-    // I/O operations\n-    //////////////////\n-\n-    void read(DataInput in) throws IOException {\n-        setTypeIndex(in.readUnsignedShort());\n-        setDeclarerIndex(in.readUnsignedShort());\n-        setNameIndex(in.readUnsignedShort());\n-        setAccessFlags(in.readUnsignedShort());\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        out.writeShort(getTypeIndex());\n-        out.writeShort(getDeclarerIndex());\n-        out.writeShort(getNameIndex());\n-        out.writeShort(getAccessFlags());\n-    }\n-}"},{"sha":"e13992fcf9197188380d44770b68af237a46c25f","filename":"serp/src/main/java/serp/bytecode/InnerClasses.java","status":"removed","additions":0,"deletions":225,"changes":225,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/InnerClasses.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/InnerClasses.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/InnerClasses.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,225 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Attribute describing all referenced classes that are not package\n- * members. This includes all member interfaces and classes.\n- *\n- * @author Abe White\n- */\n-public class InnerClasses extends Attribute {\n-\n-    private List _innerClasses = new LinkedList();\n-\n-    InnerClasses(int nameIndex, Attributes owner) {\n-        super(nameIndex, owner);\n-    }\n-\n-    /**\n-     * Return all referenced inner classes, or empty array if none.\n-     */\n-    public InnerClass[] getInnerClasses() {\n-        return (InnerClass[]) _innerClasses.toArray\n-            (new InnerClass[_innerClasses.size()]);\n-    }\n-\n-    /**\n-     * Return the inner class with the given name. If multiple inner classes\n-     * share the name, which is returned is undefined. Use null to retrieve\n-     * anonymous classes.\n-     */\n-    public InnerClass getInnerClass(String name) {\n-        InnerClass[] inners = getInnerClasses();\n-        String inner;\n-        for (int i = 0; i < inners.length; i++) {\n-            inner = inners[i].getName();\n-            if ((inner == null && name == null)\n-                || (inner != null && inner.equals(name)))\n-                return inners[i];\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Return all inner classes with the given name, or empty array if none.\n-     * Use null to retrieve anonymous classes.\n-     */\n-    public InnerClass[] getInnerClasses(String name) {\n-        List matches = new LinkedList();\n-        InnerClass[] inners = getInnerClasses();\n-        String inner;\n-        for (int i = 0; i < inners.length; i++) {\n-            inner = inners[i].getName();\n-            if ((inner == null && name == null)\n-                || (inner != null && inner.equals(name)))\n-                matches.add(inners[i]);\n-        }\n-        return (InnerClass[]) matches.toArray(new InnerClass[matches.size()]);\n-    }\n-\n-    /**\n-     * Set the inner class references for this class. This method is\n-     * useful when importing inner class references from another class.\n-     */\n-    public void setInnerClasses(InnerClass[] inners) {\n-        clear();\n-        if (inners != null)\n-            for (int i = 0; i < inners.length; i++)\n-                addInnerClass(inners[i]);\n-    }\n-\n-    /**\n-     * Import an inner class from another entity, or make a copy of one\n-     * on this entity.\n-     *\n-     * @return the newly added inner class\n-     */\n-    public InnerClass addInnerClass(InnerClass inner) {\n-        InnerClass newInner = addInnerClass\n-            (inner.getName(), inner.getTypeName(), inner.getDeclarerName());\n-        newInner.setAccessFlags(inner.getAccessFlags());\n-        return newInner;\n-    }\n-\n-    /**\n-     * Add an inner class.\n-     */\n-    public InnerClass addInnerClass() {\n-        InnerClass inner = new InnerClass(this);\n-        _innerClasses.add(inner);\n-        return inner;\n-    }\n-\n-    /**\n-     * Add an inner class.\n-     *\n-     * @param name the simple name of the class, or null if anonymous\n-     * @param type the full class name of the inner class\n-     * @param owner the declaring class, or null if not a member class\n-     */\n-    public InnerClass addInnerClass(String name, String type, String owner) {\n-        InnerClass inner = addInnerClass();\n-        inner.setName(name);\n-        inner.setType(type);\n-        inner.setDeclarer(owner);\n-        return inner;\n-    }\n-\n-    /**\n-     * Add an inner class.\n-     *\n-     * @param name the simple name of the class, or null if anonymous\n-     * @param type the class of the inner class\n-     * @param owner the declaring class, or null if not a member class\n-     */\n-    public InnerClass addInnerClass(String name, Class type, Class owner) {\n-        String typeName = (type == null) ? null : type.getName();\n-        String ownerName = (owner == null) ? null : owner.getName();\n-        return addInnerClass(name, typeName, ownerName);\n-    }\n-\n-    /**\n-     * Add an inner class.\n-     *\n-     * @param name the simple name of the class, or null if anonymous\n-     * @param type the class of the inner class\n-     * @param owner the declaring class, or null if not a member class\n-     */\n-    public InnerClass addInnerClass(String name, BCClass type, BCClass owner) {\n-        String typeName = (type == null) ? null : type.getName();\n-        String ownerName = (owner == null) ? null : owner.getName();\n-        return addInnerClass(name, typeName, ownerName);\n-    }\n-\n-    /**\n-     * Clear all inner classes from this entity.\n-     */\n-    public void clear() {\n-        InnerClass inner;\n-        for (Iterator itr = _innerClasses.iterator(); itr.hasNext();) {\n-            inner = (InnerClass) itr.next();\n-            itr.remove();\n-            inner.invalidate();\n-        }\n-    }\n-\n-    /**\n-     * Remove the inner class with the given name. Use null for anonymous\n-     * classes.\n-     *\n-     * @return true if an inner class was removed, false otherwise\n-     */\n-    public boolean removeInnerClass(String name) {\n-        return removeInnerClass(getInnerClass(name));\n-    }\n-\n-    /**\n-     * Remove the given inner class. After being removed, the given inner\n-     * class is invalid, and the result of any operations on it are undefined.\n-     *\n-     * @return true if the inner class was removed, false otherwise\n-     */\n-    public boolean removeInnerClass(InnerClass innerClass) {\n-        if (innerClass == null || !_innerClasses.remove(innerClass))\n-            return false;\n-\n-        innerClass.invalidate();\n-        return true;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterInnerClasses(this);\n-\n-        InnerClass[] inners = getInnerClasses();\n-        for (int i = 0; i < inners.length; i++)\n-            inners[i].acceptVisit(visit);\n-\n-        visit.exitInnerClasses(this);\n-    }\n-\n-    int getLength() {\n-        return 2 + 8 * _innerClasses.size();\n-    }\n-\n-    void read(Attribute other) {\n-        setInnerClasses(((InnerClasses) other).getInnerClasses());\n-    }\n-\n-    void read(DataInput in, int length) throws IOException {\n-        clear();\n-        int numInnerClasses = in.readUnsignedShort();\n-\n-        InnerClass innerClass;\n-        for (int i = 0; i < numInnerClasses; i++) {\n-            innerClass = addInnerClass();\n-            innerClass.read(in);\n-        }\n-    }\n-\n-    void write(DataOutput out, int length) throws IOException {\n-        InnerClass[] inners = getInnerClasses();\n-        out.writeShort(inners.length);\n-        for (int i = 0; i < inners.length; i++)\n-            inners[i].write(out);\n-    }\n-}"},{"sha":"ae106c6b5463010de73c60d42af13680b1cf0900","filename":"serp/src/main/java/serp/bytecode/Instruction.java","status":"removed","additions":0,"deletions":180,"changes":180,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Instruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Instruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Instruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,180 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.bytecode.visitor.VisitAcceptor;\n-\n-/**\n- * An opcode in a method of a class.\n- *\n- * @author Abe White\n- */\n-public class Instruction extends CodeEntry implements BCEntity, VisitAcceptor {\n-\n-    private Code _owner = null;\n-    private int _opcode = Constants.NOP;\n-\n-    Instruction(Code owner) {\n-        _owner = owner;\n-    }\n-\n-    Instruction(Code owner, int opcode) {\n-        _owner = owner;\n-        _opcode = opcode;\n-    }\n-\n-    /**\n-     * Return the code block that owns this instruction.\n-     */\n-    public Code getCode() {\n-        return _owner;\n-    }\n-\n-    /**\n-     * Return the name of this instruction.\n-     */\n-    public String getName() {\n-        return Constants.OPCODE_NAMES[_opcode];\n-    }\n-\n-    /**\n-     * Return the opcode this instruction represents.\n-     */\n-    public int getOpcode() {\n-        return _opcode;\n-    }\n-\n-    /**\n-     * Set the opcode this instruction represents. For internal use only.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    Instruction setOpcode(int opcode) {\n-        _opcode = opcode;\n-        return this;\n-    }\n-\n-    /**\n-     * Return the index in the method code byte block at which this opcode\n-     * starts. Note that this information may be out of date if the code\n-     * block has been modified since last read/written.\n-     */\n-    public int getByteIndex() {\n-        if (_owner != null)\n-            return _owner.getByteIndex(this);\n-        return 0;\n-    }\n-\n-    /**\n-     * Return the line number of this instruction, or null if none. This\n-     * method is subject to the validity constraints of {@link #getByteIndex}.\n-     *\n-     * @see LineNumberTable#getLineNumber(Instruction)\n-     */\n-    public LineNumber getLineNumber() {\n-        LineNumberTable table = _owner.getLineNumberTable(false);\n-        if (table == null)\n-            return null;\n-        return table.getLineNumber(this);\n-    }\n-\n-    /**\n-     * Return the length in bytes of this opcode, including all arguments.\n-     * For many opcodes this method relies on an up-to-date byte index.\n-     */\n-    int getLength() {\n-        return 1;\n-    }\n-\n-    /**\n-     * Return the logical number of stack positions changed by this\n-     * instruction. In other words, ignore weirdness with longs and doubles\n-     * taking two stack positions.\n-     */\n-    public int getLogicalStackChange() {\n-        return getStackChange();\n-    }\n-\n-    /**\n-     * Return the number of stack positions this instruction pushes\n-     * or pops during its execution.\n-     *\n-     * @return 0 if the stack is not affected by this instruction, a\n-     *         positive number if it pushes onto the stack, and a negative\n-     *         number if it pops from the stack\n-     */\n-    public int getStackChange() {\n-        return 0;\n-    }\n-\n-    /**\n-     * Instructions are equal if their opcodes are the same. Subclasses\n-     * should override this method to perform a template comparison:\n-     * instructions should compare equal to other instructions of the same\n-     * type where the data is either the same or the data is unset.\n-     */\n-    public boolean equalsInstruction(Instruction other) {\n-        if (other == this)\n-            return true;\n-        return other.getOpcode() == getOpcode();\n-    }\n-\n-    public Project getProject() {\n-        return _owner.getProject();\n-    }\n-\n-    public ConstantPool getPool() {\n-        return _owner.getPool();\n-    }\n-\n-    public ClassLoader getClassLoader() {\n-        return _owner.getClassLoader();\n-    }\n-\n-    public boolean isValid() {\n-        return _owner != null;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-    }\n-\n-    void invalidate() {\n-        _owner = null;\n-    }\n-\n-    /**\n-     * Copy the given instruction data.\n-     */\n-    void read(Instruction orig) {\n-    }\n-\n-    /**\n-     * Read the arguments for this opcode from the given stream.\n-     * This method should be overridden by opcodes that take arguments.\n-     */\n-    void read(DataInput in) throws IOException {\n-    }\n-\n-    /**\n-     * Write the arguments for this opcode to the given stream.\n-     * This method should be overridden by opcodes that take arguments.\n-     */\n-    void write(DataOutput out) throws IOException {\n-    }\n-}"},{"sha":"8b094e3f70b42188170adea1db8f8514495c7a60","filename":"serp/src/main/java/serp/bytecode/InstructionPtr.java","status":"removed","additions":0,"deletions":43,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/InstructionPtr.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/InstructionPtr.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/InstructionPtr.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,43 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-/**\n- * An entity that maintains ptrs to instructions in a code block.\n- *\n- * @author Abe White\n- */\n-public interface InstructionPtr {\n-\n-    /**\n-     * Use the byte indexes read from the class file to calculate and\n-     * set references to the target instruction(s) for this ptr.\n-     * This method will be called after the byte code\n-     * has been read in for the first time and before it is written after\n-     * modification.\n-     */\n-    public void updateTargets();\n-\n-    /**\n-     * Replace the given old, likely invalid, target with a new target. The\n-     * new target Instruction is guaranteed to be in the same code\n-     * block as this InstructionPtr.\n-     */\n-    public void replaceTarget(Instruction oldTarget, Instruction newTarget);\n-\n-    /**\n-     * Returns the Code block that owns the Instruction(s) this\n-     * InstructionPtr points to.\n-     */\n-    public Code getCode();\n-}"},{"sha":"998f3ac3f9efb02b8e798be4437cd0c21604a22e","filename":"serp/src/main/java/serp/bytecode/InstructionPtrStrategy.java","status":"removed","additions":0,"deletions":109,"changes":109,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/InstructionPtrStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/InstructionPtrStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/InstructionPtrStrategy.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,109 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-/**\n- * InstructionPtrStrategy handles the different strategies for finding the\n- * Instructions that InstructionPtrs point to. These strategies include,\n- * from least desirable to most desirable, using byte indexes,\n- * and storing a reference to the target Instruction proper.\n- *\n- * @author Eric Lindauer\n- * @date 2002.7.26\n- */\n-class InstructionPtrStrategy implements InstructionPtr {\n-\n-    // the Instruction doing the targetting\n-    private InstructionPtr _pointer;\n-\n-    // two different ways to find the target from the pointer.\n-    // _target is used first, then _byteIndex\n-    private Instruction _target = null;\n-    private int _byteIndex = -1;\n-\n-    public InstructionPtrStrategy(InstructionPtr pointer) {\n-        _pointer = pointer;\n-    }\n-\n-    public InstructionPtrStrategy(InstructionPtr pointer, Instruction target) {\n-        this(pointer);\n-        setTargetInstruction(target);\n-    }\n-\n-    /**\n-     * Sets the byteIndex where the target Instruction can be found.\n-     * This target will now be using byte indices as its target finding\n-     * strategy, which is the least robust option. Changing the Code block\n-     * or importing it into another Method may result in an invalid target.\n-     */\n-    public void setByteIndex(int index) {\n-        if (index < 0 && index != -1)\n-            throw new IllegalArgumentException(String.valueOf(index));\n-\n-        _byteIndex = index;\n-        _target = null;\n-    }\n-\n-    /**\n-     * Changes the target Instruction. The target is in the best state\n-     * possible and should maintain this information even in the face\n-     * of Code imports and Code changes.\n-     */\n-    public void setTargetInstruction(Instruction ins) {\n-        if (ins.getCode() != getCode())\n-            throw new IllegalArgumentException(\"Instruction pointers and \"\n-                + \"targets must be part of the same code block.\");\n-\n-        _target = ins;\n-        _byteIndex = -1;\n-    }\n-\n-    /**\n-     * Returns the Instruction this Target is targetting. This request\n-     * does not change the targetting strategy for this Target.\n-     */\n-    public Instruction getTargetInstruction() {\n-        if (_target != null)\n-            return _target;\n-        return getCode().getInstruction(_byteIndex);\n-    }\n-\n-    /**\n-     * Returns the byteIndex at which the target instruction can be found.\n-     * This call does not change the Target strategy.\n-     */\n-    public int getByteIndex() {\n-        if (_target == null)\n-            return _byteIndex;\n-        return _target.getByteIndex();\n-    }\n-\n-    /**\n-     * Same as getInstruction, but this method alters the Target strategy\n-     * to use the returned Instruction. This method alters the Target\n-     * strategy(and Instruction) iff it was previously using byte indexes.\n-     */\n-    public void updateTargets() {\n-        if (_target == null)\n-            _target = getCode().getInstruction(_byteIndex);\n-    }\n-\n-    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n-        if (getTargetInstruction() == oldTarget)\n-            setTargetInstruction(newTarget);\n-    }\n-\n-    public Code getCode() {\n-        return _pointer.getCode();\n-    }\n-}"},{"sha":"8e993d714d9d9796cd9ee8aabe53324946ac4b8e","filename":"serp/src/main/java/serp/bytecode/JumpInstruction.java","status":"removed","additions":0,"deletions":162,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/JumpInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/JumpInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/JumpInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,162 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * An instruction that specifies a position in the code block to jump to.\n- * Examples include <code>go2, jsr</code>, etc.\n- *\n- * @author Abe White\n- */\n-public class JumpInstruction extends Instruction implements InstructionPtr {\n-\n-    private InstructionPtrStrategy _target = new InstructionPtrStrategy(this);\n-\n-    JumpInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    public int getLogicalStackChange() {\n-        return getStackChange();\n-    }\n-\n-    public int getStackChange() {\n-        if (getOpcode() == Constants.JSR)\n-            return 1;\n-        return 0;\n-    }\n-\n-    int getLength() {\n-        switch (getOpcode()) {\n-            case Constants.GOTOW:\n-            case Constants.JSRW:\n-                return super.getLength() + 4;\n-            default:\n-                return super.getLength() + 2;\n-        }\n-    }\n-\n-    /**\n-     * Get the current target instruction to jump to, if it has been set.\n-     */\n-    public Instruction getTarget() {\n-        return _target.getTargetInstruction();\n-    }\n-\n-    /**\n-     * Set the instruction to jump to; the instruction must already be\n-     * added to the code block.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public JumpInstruction setTarget(Instruction instruction) {\n-        _target.setTargetInstruction(instruction);\n-        return this;\n-    }\n-\n-    /**\n-     * JumpInstructions are equal if they represent the same operation and\n-     * the instruction they jump to is the\n-     * same, or if the jump Instruction of either is unset.\n-     */\n-    public boolean equalsInstruction(Instruction other) {\n-        if (this == other)\n-            return true;\n-        if (!super.equalsInstruction(other))\n-            return false;\n-\n-        Instruction target = ((JumpInstruction) other).getTarget();\n-        return (target == null || getTarget() == null || target == getTarget());\n-    }\n-\n-    public void updateTargets() {\n-        _target.updateTargets();\n-    }\n-\n-    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n-        _target.replaceTarget(oldTarget, newTarget);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterJumpInstruction(this);\n-        visit.exitJumpInstruction(this);\n-    }\n-\n-    void read(Instruction orig) {\n-        super.read(orig);\n-        _target.setByteIndex(((JumpInstruction) orig)._target.getByteIndex());\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        super.read(in);\n-\n-        switch (getOpcode()) {\n-            case Constants.GOTOW:\n-            case Constants.JSRW:\n-                setOffset(in.readInt());\n-                break;\n-            default:\n-                setOffset(in.readShort());\n-        }\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        super.write(out);\n-\n-        switch (getOpcode()) {\n-            case Constants.GOTOW:\n-            case Constants.JSRW:\n-                out.writeInt(getOffset());\n-                break;\n-            default:\n-                out.writeShort(getOffset());\n-        }\n-    }\n-\n-    void calculateOpcode() {\n-        int offset;\n-        switch (getOpcode()) {\n-            case Constants.GOTO:\n-            case Constants.GOTOW:\n-                offset = getOffset();\n-                if (offset < (2 << 16))\n-                    setOpcode(Constants.GOTO);\n-                else\n-                    setOpcode(Constants.GOTOW);\n-                break;\n-            case Constants.JSR:\n-            case Constants.JSRW:\n-                offset = getOffset();\n-                if (offset < (2 << 16))\n-                    setOpcode(Constants.JSR);\n-                else\n-                    setOpcode(Constants.JSRW);\n-                break;\n-        }\n-    }\n-\n-    public void setOffset(int offset) {\n-        _target.setByteIndex(getByteIndex() + offset);\n-        calculateOpcode();\n-    }\n-\n-    public int getOffset() {\n-        return _target.getByteIndex() - getByteIndex();\n-    }\n-}"},{"sha":"f84dee5e70b20890d50e0b91fe8c4fff552550ad","filename":"serp/src/main/java/serp/bytecode/LineNumber.java","status":"removed","additions":0,"deletions":154,"changes":154,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LineNumber.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LineNumber.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LineNumber.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,154 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.bytecode.visitor.VisitAcceptor;\n-\n-/**\n- * A line number corresponds to a sequence of opcodes that map logically\n- * to a line of source code.\n- *\n- * @author Abe White\n- */\n-public class LineNumber\n-    implements Comparable, InstructionPtr, BCEntity, VisitAcceptor {\n-\n-    private int _line = 0;\n-    private LineNumberTable _owner = null;\n-\n-    InstructionPtrStrategy _target = new InstructionPtrStrategy(this);\n-\n-    LineNumber(LineNumberTable owner) {\n-        _owner = owner;\n-    }\n-\n-    LineNumber(LineNumberTable owner, int startPc) {\n-        this(owner);\n-        setStartPc(startPc);\n-    }\n-\n-    /**\n-     * Line numbers are stored in a {@link LineNumberTable}.\n-     */\n-    public LineNumberTable getTable() {\n-        return _owner;\n-    }\n-\n-    void invalidate() {\n-        _owner = null;\n-    }\n-\n-    /**\n-     * Return source line number.\n-     */\n-    public int getLine() {\n-        return _line;\n-    }\n-\n-    /**\n-     * Set the source line number.\n-     */\n-    public void setLine(int lineNumber) {\n-        _line = lineNumber;\n-    }\n-\n-    /**\n-     * Return the instruction marking the beginning of this line.\n-     */\n-    public Instruction getStart() {\n-        return _target.getTargetInstruction();\n-    }\n-\n-    /**\n-     * Return the index into the code byte array at which this line starts.\n-     */\n-    public int getStartPc() {\n-        return _target.getByteIndex();\n-    }\n-\n-    /**\n-     * Set the index into the code byte array at which this line starts.\n-     */\n-    public void setStartPc(int startPc) {\n-        _target.setByteIndex(startPc);\n-    }\n-\n-    /**\n-     * Set the {@link Instruction} marking the beginning this line.\n-     * The instruction must already be a part of the method.\n-     */\n-    public void setStart(Instruction instruction) {\n-        _target.setTargetInstruction(instruction);\n-    }\n-\n-    public void updateTargets() {\n-        _target.updateTargets();\n-    }\n-\n-    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n-        _target.replaceTarget(oldTarget, newTarget);\n-    }\n-\n-    public Project getProject() {\n-        return _owner.getProject();\n-    }\n-\n-    public ConstantPool getPool() {\n-        return _owner.getPool();\n-    }\n-\n-    public ClassLoader getClassLoader() {\n-        return _owner.getClassLoader();\n-    }\n-\n-    public boolean isValid() {\n-        return _owner != null;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterLineNumber(this);\n-        visit.exitLineNumber(this);\n-    }\n-\n-    public int compareTo(Object other) {\n-        if (!(other instanceof LineNumber))\n-            return -1;\n-\n-        LineNumber ln = (LineNumber) other;\n-        if (getStartPc() == ln.getStartPc())\n-            return 0;\n-        if (getStartPc() < ln.getStartPc())\n-            return -1;\n-        return 1;\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        setStartPc(in.readUnsignedShort());\n-        setLine(in.readUnsignedShort());\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        out.writeShort(getStartPc());\n-        out.writeShort(getLine());\n-    }\n-\n-    public Code getCode() {\n-        return _owner.getCode();\n-    }\n-}"},{"sha":"1b776a483c2c2f2e39406834e1dfd710377f69ab","filename":"serp/src/main/java/serp/bytecode/LineNumberTable.java","status":"removed","additions":0,"deletions":211,"changes":211,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LineNumberTable.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LineNumberTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LineNumberTable.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,211 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Code blocks compiled from source have line number tables mapping\n- * opcodes to source lines. This table automatically maintains line\n- * numbers in ascending order by their start program counter position\n- * at all times.\n- *\n- * @author Abe White\n- */\n-public class LineNumberTable extends Attribute implements InstructionPtr {\n-\n-    private List _lineNumbers = new ArrayList();\n-\n-    LineNumberTable(int nameIndex, Attributes owner) {\n-        super(nameIndex, owner);\n-    }\n-\n-    /**\n-     * Return the line numbers held in this table.\n-     */\n-    public LineNumber[] getLineNumbers() {\n-        Collections.sort(_lineNumbers);\n-        return (LineNumber[]) _lineNumbers.toArray\n-            (new LineNumber[_lineNumbers.size()]);\n-    }\n-\n-    /**\n-     * Return the line number for the given program counter, or null if none.\n-     */\n-    public LineNumber getLineNumber(int pc) {\n-        for (int i = _lineNumbers.size() - 1; i >= 0; i--)\n-            if (((LineNumber) _lineNumbers.get(i)).\n-                _target.getByteIndex() <= pc)\n-                return (LineNumber) _lineNumbers.get(i);\n-        return null;\n-    }\n-\n-    /**\n-     * Return the line number for the given instruction, or null if none.\n-     */\n-    public LineNumber getLineNumber(Instruction ins) {\n-        if (ins == null)\n-            return null;\n-        return getLineNumber(ins.getByteIndex());\n-    }\n-\n-    /**\n-     * Set the line numbers for the table. This method is useful when\n-     * importing line numbers from another method.\n-     */\n-    public void setLineNumbers(LineNumber[] lines) {\n-        clear();\n-        if (lines != null)\n-            for (int i = 0; i < lines.length; i++)\n-                addLineNumber(lines[i]);\n-    }\n-\n-    /**\n-     * Import a line number from another method.\n-     *\n-     * @return the newly added line number\n-     */\n-    public LineNumber addLineNumber(LineNumber ln) {\n-        LineNumber line = addLineNumber();\n-        line.setStartPc(ln.getStartPc());\n-        line.setLine(ln.getLine());\n-        return line;\n-    }\n-\n-    /**\n-     * Add a new line number to this table.\n-     */\n-    public LineNumber addLineNumber() {\n-        LineNumber ln = new LineNumber(this);\n-        _lineNumbers.add(ln);\n-        return ln;\n-    }\n-\n-    /**\n-     * Add a new line number to this table.\n-     */\n-    public LineNumber addLineNumber(int startPc, int line) {\n-        LineNumber ln = addLineNumber();\n-        ln.setStartPc(startPc);\n-        ln.setLine(line);\n-        return ln;\n-    }\n-\n-    /**\n-     * Add a new line number to this table.\n-     */\n-    public LineNumber addLineNumber(Instruction start, int line) {\n-        LineNumber ln = addLineNumber();\n-        ln.setStart(start);\n-        ln.setLine(line);\n-        return ln;\n-    }\n-\n-    /**\n-     * Clear the line numbers.\n-     */\n-    public void clear() {\n-        for (int i = 0; i < _lineNumbers.size(); i++)\n-            ((LineNumber) _lineNumbers.get(i)).invalidate();\n-        _lineNumbers.clear();\n-    }\n-\n-    /**\n-     * Remove the given line.\n-     *\n-     * @return true if the line was removed, false otherwise\n-     */\n-    public boolean removeLineNumber(LineNumber ln) {\n-        if (ln == null || !_lineNumbers.remove(ln))\n-            return false;\n-\n-        ln.invalidate();\n-        return true;\n-    }\n-\n-    /**\n-     * Remove the line number for the given program counter.\n-     *\n-     * @return true if the line was removed, false otherwise\n-     */\n-    public boolean removeLineNumber(int pc) {\n-        return removeLineNumber(getLineNumber(pc));\n-    }\n-\n-    /**\n-     * Remove the line number for the given instruction.\n-     *\n-     * @return true if the line was removed, false otherwise\n-     */\n-    public boolean removeLineNumber(Instruction ins) {\n-        return removeLineNumber(getLineNumber(ins));\n-    }\n-\n-    public void updateTargets() {\n-        for (int i = 0; i < _lineNumbers.size(); i++)\n-            ((LineNumber) _lineNumbers.get(i)).updateTargets();\n-    }\n-\n-    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n-        for (int i = 0; i < _lineNumbers.size(); i++)\n-            ((LineNumber) _lineNumbers.get(i)).replaceTarget(oldTarget,\n-                newTarget);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterLineNumberTable(this);\n-\n-        LineNumber[] lines = getLineNumbers();\n-        for (int i = 0; i < lines.length; i++)\n-            lines[i].acceptVisit(visit);\n-\n-        visit.exitLineNumberTable(this);\n-    }\n-\n-    int getLength() {\n-        return 2 + 4 * _lineNumbers.size();\n-    }\n-\n-    void read(Attribute other) {\n-        setLineNumbers(((LineNumberTable) other).getLineNumbers());\n-    }\n-\n-    void read(DataInput in, int length) throws IOException {\n-        clear();\n-        int numLines = in.readUnsignedShort();\n-\n-        LineNumber lineNumber;\n-        for (int i = 0; i < numLines; i++) {\n-            lineNumber = addLineNumber();\n-            lineNumber.read(in);\n-        }\n-    }\n-\n-    void write(DataOutput out, int length) throws IOException {\n-        LineNumber[] lines = getLineNumbers();\n-        out.writeShort(lines.length);\n-        for (int i = 0; i < lines.length; i++)\n-            lines[i].write(out);\n-    }\n-\n-    public Code getCode() {\n-        return (Code) getOwner();\n-    }\n-}"},{"sha":"401017d84678bdea2255470130c67a526d2414ef","filename":"serp/src/main/java/serp/bytecode/LoadInstruction.java","status":"removed","additions":0,"deletions":270,"changes":270,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LoadInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LoadInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LoadInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,270 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Loads a value from the locals table to the stack.\n- *\n- * @author Abe White\n- */\n-public class LoadInstruction extends LocalVariableInstruction {\n-\n-    private static final Class[][] _mappings = new Class[][]{\n-        { byte.class, int.class }, { boolean.class, int.class },\n-        { char.class, int.class }, { short.class, int.class },\n-        { void.class, int.class }, };\n-\n-    String _type = null;\n-\n-    LoadInstruction(Code owner) {\n-        super(owner);\n-    }\n-\n-    LoadInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    int getLength() {\n-        switch (getOpcode()) {\n-            case Constants.ILOAD:\n-            case Constants.LLOAD:\n-            case Constants.FLOAD:\n-            case Constants.DLOAD:\n-            case Constants.ALOAD:\n-                return super.getLength() + 1;\n-            default:\n-                return super.getLength();\n-        }\n-    }\n-\n-    public int getStackChange() {\n-        switch (getOpcode()) {\n-            case Constants.LLOAD:\n-            case Constants.LLOAD0:\n-            case Constants.LLOAD1:\n-            case Constants.LLOAD2:\n-            case Constants.LLOAD3:\n-            case Constants.DLOAD:\n-            case Constants.DLOAD0:\n-            case Constants.DLOAD1:\n-            case Constants.DLOAD2:\n-            case Constants.DLOAD3:\n-                return 2;\n-            case Constants.NOP:\n-                return 0;\n-            default:\n-                return 1;\n-        }\n-    }\n-\n-    public int getLogicalStackChange() {\n-        switch (getOpcode()) {\n-            case Constants.NOP:\n-                return 0;\n-            default:\n-                return 1;\n-        }\n-    }\n-\n-    public String getTypeName() {\n-        switch (getOpcode()) {\n-            case Constants.ILOAD:\n-            case Constants.ILOAD0:\n-            case Constants.ILOAD1:\n-            case Constants.ILOAD2:\n-            case Constants.ILOAD3:\n-                return int.class.getName();\n-            case Constants.LLOAD:\n-            case Constants.LLOAD0:\n-            case Constants.LLOAD1:\n-            case Constants.LLOAD2:\n-            case Constants.LLOAD3:\n-                return long.class.getName();\n-            case Constants.FLOAD:\n-            case Constants.FLOAD0:\n-            case Constants.FLOAD1:\n-            case Constants.FLOAD2:\n-            case Constants.FLOAD3:\n-                return float.class.getName();\n-            case Constants.DLOAD:\n-            case Constants.DLOAD0:\n-            case Constants.DLOAD1:\n-            case Constants.DLOAD2:\n-            case Constants.DLOAD3:\n-                return double.class.getName();\n-            case Constants.ALOAD:\n-            case Constants.ALOAD0:\n-            case Constants.ALOAD1:\n-            case Constants.ALOAD2:\n-            case Constants.ALOAD3:\n-                return Object.class.getName();\n-            default:\n-                return _type;\n-        }\n-    }\n-\n-    public TypedInstruction setType(String type) {\n-        type = mapType(type, _mappings, true);\n-        int local = getLocal();\n-\n-        // if an invalid type or local, revert to nop\n-        if (type == null || local < 0) {\n-            _type = type;\n-            return (TypedInstruction) setOpcode(Constants.NOP);\n-        }\n-\n-        // valid opcode, unset saved type\n-        _type = null;\n-\n-        switch (type.charAt(0)) {\n-            case 'i':\n-                return (TypedInstruction) setOpcode(\n-                    (local > 3) ? Constants.ILOAD\n-                        : Constants.ILOAD0 + local);\n-            case 'l':\n-                return (TypedInstruction) setOpcode(\n-                    (local > 3) ? Constants.LLOAD\n-                        : Constants.LLOAD0 + local);\n-            case 'f':\n-                return (TypedInstruction) setOpcode(\n-                    (local > 3) ? Constants.FLOAD\n-                        : Constants.FLOAD0 + local);\n-            case 'd':\n-                return (TypedInstruction) setOpcode(\n-                    (local > 3) ? Constants.DLOAD\n-                        : Constants.DLOAD0 + local);\n-            default:\n-                return (TypedInstruction) setOpcode(\n-                    (local > 3) ? Constants.ALOAD\n-                        : Constants.ALOAD0 + local);\n-        }\n-    }\n-\n-    /**\n-     * Equivalent to <code>setLocal(0).setType(Object.class)</code>; the\n-     * <code>this</code> ptr is always passed in local variable 0.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public LoadInstruction setThis() {\n-        return (LoadInstruction) setLocal(0).setType(Object.class);\n-    }\n-\n-    /**\n-     * Equivalent to <code>getLocal() == 0 && getType() ==\n-     * Object.class</code>; the <code>this</code> ptr\n-     * is always passed in local variable 0.\n-     */\n-    public boolean isThis() {\n-        return getLocal() == 0 && getType() == Object.class;\n-    }\n-\n-    /**\n-     * LoadInstructions are equal if the type they reference the same\n-     * type and locals index or if either is unset.\n-     */\n-    public boolean equalsInstruction(Instruction other) {\n-        if (other == this)\n-            return true;\n-        if (!super.equalsInstruction(other))\n-            return false;\n-\n-        String type = getTypeName();\n-        String otherType = ((LoadInstruction) other).getTypeName();\n-\n-        return type == null || otherType == null || type.equals(otherType);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterLoadInstruction(this);\n-        visit.exitLoadInstruction(this);\n-    }\n-\n-    void read(Instruction orig) {\n-        super.read(orig);\n-\n-        LoadInstruction ins = (LoadInstruction) orig;\n-        _type = ins._type;\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        super.read(in);\n-\n-        switch (getOpcode()) {\n-            case Constants.ILOAD:\n-            case Constants.LLOAD:\n-            case Constants.FLOAD:\n-            case Constants.DLOAD:\n-            case Constants.ALOAD:\n-                setLocal(in.readUnsignedByte());\n-                break;\n-        }\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        super.write(out);\n-\n-        switch (getOpcode()) {\n-            case Constants.ILOAD:\n-            case Constants.LLOAD:\n-            case Constants.FLOAD:\n-            case Constants.DLOAD:\n-            case Constants.ALOAD:\n-                out.writeByte(getLocal());\n-        }\n-    }\n-\n-    void calculateOpcode() {\n-        // taken care of when setting type\n-        setType(getTypeName());\n-    }\n-\n-    void calculateLocal() {\n-        switch (getOpcode()) {\n-            case Constants.ILOAD0:\n-            case Constants.LLOAD0:\n-            case Constants.FLOAD0:\n-            case Constants.DLOAD0:\n-            case Constants.ALOAD0:\n-                setLocal(0);\n-                break;\n-            case Constants.ILOAD1:\n-            case Constants.LLOAD1:\n-            case Constants.FLOAD1:\n-            case Constants.DLOAD1:\n-            case Constants.ALOAD1:\n-                setLocal(1);\n-                break;\n-            case Constants.ILOAD2:\n-            case Constants.LLOAD2:\n-            case Constants.FLOAD2:\n-            case Constants.DLOAD2:\n-            case Constants.ALOAD2:\n-                setLocal(2);\n-                break;\n-            case Constants.ILOAD3:\n-            case Constants.LLOAD3:\n-            case Constants.FLOAD3:\n-            case Constants.DLOAD3:\n-            case Constants.ALOAD3:\n-                setLocal(3);\n-                break;\n-        }\n-    }\n-}"},{"sha":"9ccb70befca02e0760021cf8c7a984c40fd23871","filename":"serp/src/main/java/serp/bytecode/Local.java","status":"removed","additions":0,"deletions":264,"changes":264,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Local.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Local.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Local.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,264 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.bytecode.lowlevel.UTF8Entry;\n-\n-/**\n- * A local variable or local variable type.\n- *\n- * @author Abe White\n- */\n-public abstract class Local implements BCEntity, InstructionPtr {\n-\n-    private LocalTable _owner = null;\n-    private InstructionPtrStrategy _target = new InstructionPtrStrategy(this);\n-\n-    private int _length = 0;\n-    private int _nameIndex = 0;\n-    private int _descriptorIndex = 0;\n-    private int _index = 0;\n-\n-    Local(LocalTable owner) {\n-        _owner = owner;\n-    }\n-\n-    /**\n-     * The owning table.\n-     */\n-    public LocalTable getTable() {\n-        return _owner;\n-    }\n-\n-    void invalidate() {\n-        _owner = null;\n-    }\n-\n-    //////////////////////////\n-    // Local index operations\n-    //////////////////////////\n-\n-    /**\n-     * Get the local variable index of the current frame for this local.\n-     */\n-    public int getLocal() {\n-        return _index;\n-    }\n-\n-    /**\n-     * Set the local variable index of the current frame for this local.\n-     */\n-    public void setLocal(int index) {\n-        _index = index;\n-    }\n-\n-    /**\n-     * Return the parameter that this local corresponds to, or -1 if none.\n-     */\n-    public int getParam() {\n-        return getCode().getParamsIndex(getLocal());\n-    }\n-\n-    /**\n-     * Set the method parameter that this local corresponds to.\n-     */\n-    public void setParam(int param) {\n-        setLocal(_owner.getCode().getLocalsIndex(param));\n-    }\n-\n-    /**\n-     * Return the index into the code byte array at which this local starts.\n-     */\n-    public int getStartPc() {\n-        return _target.getByteIndex();\n-    }\n-\n-    ////////////////////////////\n-    // Start, Length operations\n-    ////////////////////////////\n-\n-    /**\n-     * Return the instruction marking the beginning of this local.\n-     */\n-    public Instruction getStart() {\n-        return _target.getTargetInstruction();\n-    }\n-\n-    /**\n-     * Set the index into the code byte array at which this local starts.\n-     */\n-    public void setStartPc(int startPc) {\n-        _target.setByteIndex(startPc);\n-    }\n-\n-    /**\n-     * Set the {@link Instruction} marking the beginning this local.\n-     * The instruction must already be a part of the method.\n-     * WARNING: if this instruction is deleted, the results are undefined.\n-     */\n-    public void setStart(Instruction instruction) {\n-        _target.setTargetInstruction(instruction);\n-    }\n-\n-    public void updateTargets() {\n-        _target.updateTargets();\n-    }\n-\n-    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n-        _target.replaceTarget(oldTarget, newTarget);\n-    }\n-\n-    /**\n-     * Get the number of bytes for which this local has a value in\n-     * the code byte array.\n-     */\n-    public int getLength() {\n-        return _length;\n-    }\n-\n-    /**\n-     * Set the number of bytes for which this local has a value in\n-     * the code byte array.\n-     */\n-    public void setLength(int length) {\n-        _length = length;\n-    }\n-\n-    /////////////////////////\n-    // Name, Type operations\n-    /////////////////////////\n-\n-    /**\n-     * Return the {@link ConstantPool} index of the {@link UTF8Entry} that\n-     * describes the name of this local. Defaults to 0.\n-     */\n-    public int getNameIndex() {\n-        return _nameIndex;\n-    }\n-\n-    /**\n-     * Set the {@link ConstantPool} index of the {@link UTF8Entry} that\n-     * describes the name of this local.\n-     */\n-    public void setNameIndex(int nameIndex) {\n-        _nameIndex = nameIndex;\n-    }\n-\n-    /**\n-     * Return the name of this local, or null if unset.\n-     */\n-    public String getName() {\n-        if (getNameIndex() == 0)\n-            return null;\n-        return ((UTF8Entry) getPool().getEntry(getNameIndex())).getValue();\n-    }\n-\n-    /**\n-     * Set the name of this inner local.\n-     */\n-    public void setName(String name) {\n-        if (name == null)\n-            setNameIndex(0);\n-        else\n-            setNameIndex(getPool().findUTF8Entry(name, true));\n-    }\n-\n-    /**\n-     * Return the {@link ConstantPool} index of the {@link UTF8Entry} that\n-     * describes this local. Defaults to 0.\n-     */\n-    public int getTypeIndex() {\n-        return _descriptorIndex;\n-    }\n-\n-    /**\n-     * Set the {@link ConstantPool} index of the {@link UTF8Entry} that\n-     * describes this local.\n-     */\n-    public void setTypeIndex(int index) {\n-        _descriptorIndex = index;\n-    }\n-\n-    /**\n-     * Return the full name of the local's type, or null if unset.\n-     */\n-    public String getTypeName() {\n-        if (getTypeIndex() == 0)\n-            return null;\n-\n-        UTF8Entry entry = (UTF8Entry) getPool().getEntry(getTypeIndex());\n-        return getProject().getNameCache().getExternalForm\n-            (entry.getValue(), false);\n-    }\n-\n-    /**\n-     * Set the type of this local.\n-     */\n-    public void setType(String type) {\n-        if (type == null)\n-            setTypeIndex(0);\n-        else {\n-            type = getProject().getNameCache().getInternalForm(type, true);\n-            setTypeIndex(getPool().findUTF8Entry(type, true));\n-        }\n-    }\n-\n-    ///////////////////////////\n-    // BCEntity implementation\n-    ///////////////////////////\n-\n-    public Project getProject() {\n-        return _owner.getProject();\n-    }\n-\n-    public ConstantPool getPool() {\n-        return _owner.getPool();\n-    }\n-\n-    public ClassLoader getClassLoader() {\n-        return _owner.getClassLoader();\n-    }\n-\n-    public boolean isValid() {\n-        return _owner != null;\n-    }\n-\n-    //////////////////\n-    // I/O operations\n-    //////////////////\n-\n-    void read(DataInput in) throws IOException {\n-        setStartPc(in.readUnsignedShort());\n-        setLength(in.readUnsignedShort());\n-        setNameIndex(in.readUnsignedShort());\n-        setTypeIndex(in.readUnsignedShort());\n-        setLocal(in.readUnsignedShort());\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        out.writeShort(getStartPc());\n-        out.writeShort(getLength());\n-        out.writeShort(getNameIndex());\n-        out.writeShort(getTypeIndex());\n-        out.writeShort(getLocal());\n-    }\n-\n-    public Code getCode() {\n-        return _owner.getCode();\n-    }\n-}"},{"sha":"728098695003224d767a8aabb56de7c49a46af30","filename":"serp/src/main/java/serp/bytecode/LocalTable.java","status":"removed","additions":0,"deletions":215,"changes":215,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LocalTable.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LocalTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalTable.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,215 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-/**\n- * Code blocks compiled from source have local tables mapping\n- * locals used in opcodes to their names and descriptions.\n- *\n- * @author Abe White\n- */\n-public abstract class LocalTable extends Attribute implements InstructionPtr {\n-\n-    private List _locals = new ArrayList();\n-\n-    LocalTable(int nameIndex, Attributes owner) {\n-        super(nameIndex, owner);\n-    }\n-\n-    /**\n-     * Return all the locals of this method.\n-     */\n-    public Local[] getLocals() {\n-        return (Local[]) _locals.toArray(newLocalArray(_locals.size()));\n-    }\n-\n-    /**\n-     * Return the local with the given locals index, or null if none.\n-     */\n-    public Local getLocal(int local) {\n-        for (int i = 0; i < _locals.size(); i++)\n-            if (((Local) _locals.get(i)).getLocal() == local)\n-                return (Local) _locals.get(i);\n-        return null;\n-    }\n-\n-    /**\n-     * Return the local with the given name, or null if none. If multiple\n-     * locals have the given name, which is returned is undefined.\n-     */\n-    public Local getLocal(String name) {\n-        String loc;\n-        for (int i = 0; i < _locals.size(); i++) {\n-            loc = ((Local) _locals.get(i)).getName();\n-            if ((loc == null && name == null)\n-                || (loc != null && loc.equals(name)))\n-                return (Local) _locals.get(i);\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Return all locals with the given name, or empty array if none.\n-     */\n-    public Local[] getLocals(String name) {\n-        List matches = new LinkedList();\n-        String loc;\n-        for (int i = 0; i < _locals.size(); i++) {\n-            loc = ((Local) _locals.get(i)).getName();\n-            if ((loc == null && name == null)\n-                || (loc != null && loc.equals(name)))\n-                matches.add(_locals.get(i));\n-        }\n-        return (Local[]) matches.toArray(newLocalArray(matches.size()));\n-    }\n-\n-    /**\n-     * Set the locals of this table. This method is useful when\n-     * importing locals from another method.\n-     */\n-    public void setLocals(Local[] locals) {\n-        clear();\n-        if (locals != null)\n-            for (int i = 0; i < locals.length; i++)\n-                addLocal(locals[i]);\n-    }\n-\n-    /**\n-     * Import a local from another method/class. Note that\n-     * the program counter and length from the given local is copied\n-     * directly, and thus will be incorrect unless this method is the same\n-     * as the one the local is copied from, or the pc and length are reset.\n-     */\n-    public Local addLocal(Local local) {\n-        Local newLocal = addLocal(local.getName(), local.getTypeName());\n-        newLocal.setStartPc(local.getStartPc());\n-        newLocal.setLength(local.getLength());\n-        return newLocal;\n-    }\n-\n-    /**\n-     * Add a local to this table.\n-     */\n-    public Local addLocal() {\n-        Local local = newLocal();\n-        _locals.add(local);\n-        return local;\n-    }\n-\n-    /**\n-     * Create a new element of this table.\n-     */\n-    protected abstract Local newLocal();\n-\n-    /**\n-     * Create a new array.\n-     */\n-    protected abstract Local[] newLocalArray(int size);\n-\n-    /**\n-     * Add a local to this table.\n-     */\n-    public Local addLocal(String name, String type) {\n-        Local local = addLocal();\n-        local.setName(name);\n-        local.setType(type);\n-        return local;\n-    }\n-\n-    /**\n-     * Clear all locals from this table.\n-     */\n-    public void clear() {\n-        for (int i = 0; i < _locals.size(); i++)\n-            ((Local) _locals.get(i)).invalidate();\n-        _locals.clear();\n-    }\n-\n-    /**\n-     * Removes the local with the given locals index from the table.\n-     *\n-     * @return true if a local was removed, false otherwise\n-     */\n-    public boolean removeLocal(int local) {\n-        return removeLocal(getLocal(local));\n-    }\n-\n-    /**\n-     * Removes the local with the given name from this method.\n-     *\n-     * @return true if a local was removed, false otherwise\n-     */\n-    public boolean removeLocal(String name) {\n-        return removeLocal(getLocal(name));\n-    }\n-\n-    /**\n-     * Removes a local from this method. After this method, the local\n-     * will be invalid, and the result of any operations on it is undefined.\n-     *\n-     * @return true if a local was removed, false otherwise\n-     */\n-    public boolean removeLocal(Local local) {\n-        if (local == null || !_locals.remove(local))\n-            return false;\n-\n-        local.invalidate();\n-        return true;\n-    }\n-\n-    public void updateTargets() {\n-        for (int i = 0; i < _locals.size(); i++)\n-            ((Local) _locals.get(i)).updateTargets();\n-    }\n-\n-    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n-        for (int i = 0; i < _locals.size(); i++)\n-            ((Local) _locals.get(i)).replaceTarget(oldTarget, newTarget);\n-    }\n-\n-    public Code getCode() {\n-        return (Code) getOwner();\n-    }\n-\n-    int getLength() {\n-        return 2 + 10 * _locals.size();\n-    }\n-\n-    void read(Attribute other) {\n-        setLocals(((LocalTable) other).getLocals());\n-    }\n-\n-    void read(DataInput in, int length) throws IOException {\n-        clear();\n-        int numLocals = in.readUnsignedShort();\n-\n-        Local Local;\n-        for (int i = 0; i < numLocals; i++) {\n-            Local = addLocal();\n-            Local.read(in);\n-        }\n-    }\n-\n-    void write(DataOutput out, int length) throws IOException {\n-        out.writeShort(_locals.size());\n-        for (int i = 0; i < _locals.size(); i++)\n-            ((Local) _locals.get(i)).write(out);\n-    }\n-}"},{"sha":"2a885fd02078c83f8fa5eb755b17816e0de87ff6","filename":"serp/src/main/java/serp/bytecode/LocalVariable.java","status":"removed","additions":0,"deletions":83,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LocalVariable.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LocalVariable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalVariable.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,83 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.util.Strings;\n-\n-/**\n- * A local variable contains the name, description, index and scope\n- * of a local used in opcodes.\n- *\n- * @author Abe White\n- */\n-public class LocalVariable extends Local {\n-\n-    LocalVariable(LocalVariableTable owner) {\n-        super(owner);\n-    }\n-\n-    /**\n-     * The owning table.\n-     */\n-    public LocalVariableTable getLocalVariableTable() {\n-        return (LocalVariableTable) getTable();\n-    }\n-\n-    /**\n-     * Return the type of this local.\n-     * If the type has not been set, this method will return null.\n-     */\n-    public Class getType() {\n-        String type = getTypeName();\n-        if (type == null)\n-            return null;\n-        return Strings.toClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Return the type of this local.\n-     * If the type has not been set, this method will return null.\n-     */\n-    public BCClass getTypeBC() {\n-        String type = getTypeName();\n-        if (type == null)\n-            return null;\n-        return getProject().loadClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Set the type of this local.\n-     */\n-    public void setType(Class type) {\n-        if (type == null)\n-            setType((String) null);\n-        else\n-            setType(type.getName());\n-    }\n-\n-    /**\n-     * Set the type of this local.\n-     */\n-    public void setType(BCClass type) {\n-        if (type == null)\n-            setType((String) null);\n-        else\n-            setType(type.getName());\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterLocalVariable(this);\n-        visit.exitLocalVariable(this);\n-    }\n-}"},{"sha":"47cff4f019ae93a91c11809de40cf4d35e0246da","filename":"serp/src/main/java/serp/bytecode/LocalVariableInstruction.java","status":"removed","additions":0,"deletions":154,"changes":154,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LocalVariableInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LocalVariableInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalVariableInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,154 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-/**\n- * An instruction that has an argument of an index into the\n- * local variable table of the current frame. This includes most of the\n- * <code>load</code> and <code>store</code> instructions.\n- * The local variable table size is fixed by the <code>maxLocals</code>\n- * property of the code block. Long and double types take up 2 local variable\n- * indexes.\n- * Parameter values to methods are loaded into the local variable table\n- * prior to the execution of the first instruction. The 0 index of the\n- * table is set to the instance of the class the method is being invoked on.\n- *\n- * @author Abe White\n- */\n-public abstract class LocalVariableInstruction extends TypedInstruction {\n-\n-    private int _index = -1;\n-\n-    LocalVariableInstruction(Code owner) {\n-        super(owner);\n-    }\n-\n-    LocalVariableInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-        calculateLocal();\n-    }\n-\n-    public String getTypeName() {\n-        return null;\n-    }\n-\n-    public TypedInstruction setType(String type) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return the index of the local variable that this instruction operates on.\n-     */\n-    public int getLocal() {\n-        return _index;\n-    }\n-\n-    /**\n-     * Set the index of the local variable that this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public LocalVariableInstruction setLocal(int index) {\n-        _index = index;\n-        calculateOpcode();\n-\n-        return this;\n-    }\n-\n-    /**\n-     * Return the parameter that this instruction operates on, or -1 if none.\n-     */\n-    public int getParam() {\n-        return getCode().getParamsIndex(getLocal());\n-    }\n-\n-    /**\n-     * Set the method parameter that this instruction operates on. This\n-     * will set both the local index and the type of the instruction based\n-     * on the current method parameters.\n-     */\n-    public LocalVariableInstruction setParam(int param) {\n-        int local = getCode().getLocalsIndex(param);\n-        if (local != -1) {\n-            BCMethod method = getCode().getMethod();\n-            setType(method.getParamNames()[param]);\n-        }\n-        return setLocal(local);\n-    }\n-\n-    /**\n-     * Return the local variable object this instruction\n-     * operates on, or null if none.\n-     *\n-     * @see LocalVariableTable#getLocalVariable(int)\n-     */\n-    public LocalVariable getLocalVariable() {\n-        LocalVariableTable table = getCode().getLocalVariableTable(false);\n-        if (table == null)\n-            return null;\n-        return table.getLocalVariable(getLocal());\n-    }\n-\n-    /**\n-     * Set the local variable object this instruction\n-     * operates on. This method will set both the type and local index\n-     * of this instruction from the given local variable.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public LocalVariableInstruction setLocalVariable(LocalVariable local) {\n-        if (local == null)\n-            return setLocal(-1);\n-        else {\n-            String type = local.getTypeName();\n-            if (type != null)\n-                setType(type);\n-            return setLocal(local.getLocal());\n-        }\n-    }\n-\n-    /**\n-     * Two local variable instructions are equal if the local index they\n-     * reference is equal or if either index is 0/unset.\n-     */\n-    public boolean equalsInstruction(Instruction other) {\n-        if (this == other)\n-            return true;\n-        if (!getClass().equals(other.getClass()))\n-            return false;\n-\n-        LocalVariableInstruction ins = (LocalVariableInstruction) other;\n-        int index = getLocal();\n-        int insIndex = ins.getLocal();\n-        return index == -1 || insIndex == -1 || index == insIndex;\n-    }\n-\n-    void read(Instruction orig) {\n-        super.read(orig);\n-        setLocal(((LocalVariableInstruction) orig).getLocal());\n-    }\n-\n-    /**\n-     * Subclasses with variable opcodes can use this method to be\n-     * notified that information possibly affecting the opcode has been changed.\n-     */\n-    void calculateOpcode() {\n-    }\n-\n-    /**\n-     * Subclasses can use this method to calculate\n-     * the locals index based on their opcode.\n-     */\n-    void calculateLocal() {\n-    }\n-}"},{"sha":"3b23db5ca279de892291c8e39916080b38b77dc5","filename":"serp/src/main/java/serp/bytecode/LocalVariableTable.java","status":"removed","additions":0,"deletions":115,"changes":115,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LocalVariableTable.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LocalVariableTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalVariableTable.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,115 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Code blocks compiled from source have local variable tables mapping\n- * locals used in opcodes to their names and descriptions.\n- *\n- * @author Abe White\n- */\n-public class LocalVariableTable extends LocalTable {\n-\n-    LocalVariableTable(int nameIndex, Attributes owner) {\n-        super(nameIndex, owner);\n-    }\n-\n-    /**\n-     * Return all the locals of this method.\n-     */\n-    public LocalVariable[] getLocalVariables() {\n-        return (LocalVariable[]) getLocals();\n-    }\n-\n-    /**\n-     * Return the local with the given locals index, or null if none.\n-     */\n-    public LocalVariable getLocalVariable(int local) {\n-        return (LocalVariable) getLocal(local);\n-    }\n-\n-    /**\n-     * Return the local with the given name, or null if none. If multiple\n-     * locals have the given name, which is returned is undefined.\n-     */\n-    public LocalVariable getLocalVariable(String name) {\n-        return (LocalVariable) getLocal(name);\n-    }\n-\n-    /**\n-     * Return all locals with the given name, or empty array if none.\n-     */\n-    public LocalVariable[] getLocalVariables(String name) {\n-        return (LocalVariable[]) getLocals(name);\n-    }\n-\n-    /**\n-     * Import a local from another method/class. Note that\n-     * the program counter and length from the given local is copied\n-     * directly, and thus will be incorrect unless this method is the same\n-     * as the one the local is copied from, or the pc and length are reset.\n-     */\n-    public LocalVariable addLocalVariable(LocalVariable local) {\n-        return (LocalVariable) addLocal(local);\n-    }\n-\n-    /**\n-     * Add a local to this table.\n-     */\n-    public LocalVariable addLocalVariable() {\n-        return (LocalVariable) addLocal();\n-    }\n-\n-    /**\n-     * Add a local to this table.\n-     */\n-    public LocalVariable addLocalVariable(String name, String type) {\n-        return (LocalVariable) addLocal(name, type);\n-    }\n-\n-    /**\n-     * Add a local to this table.\n-     */\n-    public LocalVariable addLocalVariable(String name, Class type) {\n-        String typeName = (type == null) ? null : type.getName();\n-        return addLocalVariable(name, typeName);\n-    }\n-\n-    /**\n-     * Add a local to this table.\n-     */\n-    public LocalVariable addLocalVariable(String name, BCClass type) {\n-        String typeName = (type == null) ? null : type.getName();\n-        return addLocalVariable(name, typeName);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterLocalVariableTable(this);\n-\n-        LocalVariable[] locals = (LocalVariable[]) getLocals();\n-        for (int i = 0; i < locals.length; i++)\n-            locals[i].acceptVisit(visit);\n-\n-        visit.exitLocalVariableTable(this);\n-    }\n-\n-    protected Local newLocal() {\n-        return new LocalVariable(this);\n-    }\n-\n-    protected Local[] newLocalArray(int size) {\n-        return new LocalVariable[size];\n-    }\n-}"},{"sha":"790e246d3effd3739a6107063ad62dc53f637102","filename":"serp/src/main/java/serp/bytecode/LocalVariableType.java","status":"removed","additions":0,"deletions":40,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LocalVariableType.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LocalVariableType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalVariableType.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,40 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * A local variable type contains the name, signature, index and scope\n- * of a generics-using local used in opcodes.\n- *\n- * @author Abe White\n- */\n-public class LocalVariableType extends Local {\n-\n-    LocalVariableType(LocalVariableTypeTable owner) {\n-        super(owner);\n-    }\n-\n-    /**\n-     * The owning table.\n-     */\n-    public LocalVariableTypeTable getLocalVariableTypeTable() {\n-        return (LocalVariableTypeTable) getTable();\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterLocalVariableType(this);\n-        visit.exitLocalVariableType(this);\n-    }\n-}"},{"sha":"a34e8dea8db37ac72f4777a356c961dd9cfd132d","filename":"serp/src/main/java/serp/bytecode/LocalVariableTypeTable.java","status":"removed","additions":0,"deletions":99,"changes":99,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LocalVariableTypeTable.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LocalVariableTypeTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalVariableTypeTable.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,99 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Code blocks compiled from source have local variable type tables mapping\n- * generics-using locals used in opcodes to their names and signatures.\n- *\n- * @author Abe White\n- */\n-public class LocalVariableTypeTable extends LocalTable {\n-\n-    LocalVariableTypeTable(int nameIndex, Attributes owner) {\n-        super(nameIndex, owner);\n-    }\n-\n-    /**\n-     * Return all the locals of this method.\n-     */\n-    public LocalVariableType[] getLocalVariableTypes() {\n-        return (LocalVariableType[]) getLocals();\n-    }\n-\n-    /**\n-     * Return the local with the given locals index, or null if none.\n-     */\n-    public LocalVariableType getLocalVariableType(int local) {\n-        return (LocalVariableType) getLocal(local);\n-    }\n-\n-    /**\n-     * Return the local with the given name, or null if none. If multiple\n-     * locals have the given name, which is returned is undefined.\n-     */\n-    public LocalVariableType getLocalVariableType(String name) {\n-        return (LocalVariableType) getLocal(name);\n-    }\n-\n-    /**\n-     * Return all locals with the given name, or empty array if none.\n-     */\n-    public LocalVariableType[] getLocalVariableTypes(String name) {\n-        return (LocalVariableType[]) getLocals(name);\n-    }\n-\n-    /**\n-     * Import a local from another method/class. Note that\n-     * the program counter and length from the given local is copied\n-     * directly, and thus will be incorrect unless this method is the same\n-     * as the one the local is copied from, or the pc and length are reset.\n-     */\n-    public LocalVariableType addLocalVariableType(LocalVariableType local) {\n-        return (LocalVariableType) addLocal(local);\n-    }\n-\n-    /**\n-     * Add a local to this table.\n-     */\n-    public LocalVariableType addLocalVariableType() {\n-        return (LocalVariableType) addLocal();\n-    }\n-\n-    /**\n-     * Add a local to this table.\n-     */\n-    public LocalVariableType addLocalVariableType(String name, String type) {\n-        return (LocalVariableType) addLocal(name, type);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterLocalVariableTypeTable(this);\n-\n-        LocalVariableType[] locals = (LocalVariableType[]) getLocals();\n-        for (int i = 0; i < locals.length; i++)\n-            locals[i].acceptVisit(visit);\n-\n-        visit.exitLocalVariableTypeTable(this);\n-    }\n-\n-    protected Local newLocal() {\n-        return new LocalVariableType(this);\n-    }\n-\n-    protected Local[] newLocalArray(int size) {\n-        return new LocalVariableType[size];\n-    }\n-}"},{"sha":"e917885bfb9dc7409df495747b3729cb58b50c84","filename":"serp/src/main/java/serp/bytecode/LookupSwitchInstruction.java","status":"removed","additions":0,"deletions":237,"changes":237,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LookupSwitchInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/LookupSwitchInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LookupSwitchInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.util.Numbers;\n-\n-/**\n- * The <code>lookupswitch</code> instruction.\n- *\n- * @author Abe White\n- */\n-public class LookupSwitchInstruction extends JumpInstruction {\n-\n-    // case info\n-    private List _matches = new LinkedList();\n-    private List _cases = new LinkedList();\n-\n-    LookupSwitchInstruction(Code owner) {\n-        super(owner, Constants.LOOKUPSWITCH);\n-    }\n-\n-    int getLength() {\n-        // don't call super.getLength(), cause JumpInstruction will return\n-        // value assuming this is an 'if' or 'goto' instruction\n-        int length = 1;\n-\n-        // make the first byte of the 'default' a multiple of 4 from the\n-        // start of the method\n-        int byteIndex = getByteIndex() + 1;\n-        for (; byteIndex % 4 != 0; byteIndex++, length++) ;\n-\n-        // default, npairs\n-        length += 8;\n-\n-        // pairs\n-        length += 8 * _matches.size();\n-\n-        return length;\n-    }\n-\n-    public int getLogicalStackChange() {\n-        return getStackChange();\n-    }\n-\n-    public int getStackChange() {\n-        return -1;\n-    }\n-\n-    /**\n-     * Synonymous with {@link #getTarget}.\n-     */\n-    public Instruction getDefaultTarget() {\n-        return getTarget();\n-    }\n-\n-    /**\n-     * Synonymous with {@link #setTarget}.\n-     */\n-    public LookupSwitchInstruction setDefaultTarget(Instruction ins) {\n-        return (LookupSwitchInstruction) setTarget(ins);\n-    }\n-\n-    /**\n-     * Synonymous with {@link #getOffset}.\n-     */\n-    public int getDefaultOffset() {\n-        return getOffset();\n-    }\n-\n-    /**\n-     * Synonymous with {@link #setOffset}.\n-     */\n-    public LookupSwitchInstruction setDefaultOffset(int offset) {\n-        setOffset(offset);\n-        return this;\n-    }\n-\n-    /**\n-     * Set the match-jumppt pairs for this switch.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public LookupSwitchInstruction setCases(int[] matches,\n-        Instruction[] targets) {\n-        _matches.clear();\n-        _cases.clear();\n-\n-        for (int i = 0; i < matches.length; i++)\n-            _matches.add(Numbers.valueOf(matches[i]));\n-\n-        for (int i = 0; i < targets.length; i++) {\n-            InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n-            next.setTargetInstruction(targets[i]);\n-            _cases.add(next);\n-        }\n-\n-        return this;\n-    }\n-\n-    public int[] getOffsets() {\n-        int bi = getByteIndex();\n-        int[] offsets = new int [_cases.size()];\n-        for (int i = 0; i < offsets.length; i++)\n-            offsets[i] = ((InstructionPtrStrategy) _cases.get(i)).\n-                getByteIndex() - bi;\n-        return offsets;\n-    }\n-\n-    /**\n-     * Return the values of the case statements for this switch.\n-     */\n-    public int[] getMatches() {\n-        int[] matches = new int[_matches.size()];\n-        Iterator itr = _matches.iterator();\n-        for (int i = 0; i < matches.length; i++)\n-            matches[i] = ((Integer) itr.next()).intValue();\n-        return matches;\n-    }\n-\n-    /**\n-     * Return the targets of the case statements for this switch.\n-     */\n-    public Instruction[] getTargets() {\n-        Instruction[] result = new Instruction[_cases.size()];\n-        for (int i = 0; i < result.length; i++)\n-            result[i] = ((InstructionPtrStrategy) _cases.get(i)).\n-                getTargetInstruction();\n-        return result;\n-    }\n-\n-    /**\n-     * Add a case to this switch.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public LookupSwitchInstruction addCase(int match, Instruction target) {\n-        _matches.add(Numbers.valueOf(match));\n-        _cases.add(new InstructionPtrStrategy(this, target));\n-        return this;\n-    }\n-\n-    private Instruction findJumpPoint(int jumpByteIndex, List inss) {\n-        Instruction ins;\n-        for (Iterator itr = inss.iterator(); itr.hasNext();) {\n-            ins = (Instruction) itr.next();\n-            if (ins.getByteIndex() == jumpByteIndex)\n-                return ins;\n-        }\n-        return null;\n-    }\n-\n-    public void updateTargets() {\n-        super.updateTargets();\n-        for (Iterator itr = _cases.iterator(); itr.hasNext();)\n-            ((InstructionPtrStrategy) itr.next()).updateTargets();\n-    }\n-\n-    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n-        super.replaceTarget(oldTarget, newTarget);\n-        for (Iterator itr = _cases.iterator(); itr.hasNext();)\n-            ((InstructionPtrStrategy) itr.next()).replaceTarget\n-                (oldTarget, newTarget);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterLookupSwitchInstruction(this);\n-        visit.exitLookupSwitchInstruction(this);\n-    }\n-\n-    void read(Instruction orig) {\n-        super.read(orig);\n-\n-        LookupSwitchInstruction ins = (LookupSwitchInstruction) orig;\n-        _matches = new LinkedList(ins._matches);\n-        _cases.clear();\n-        for (Iterator itr = ins._cases.iterator(); itr.hasNext();) {\n-            InstructionPtrStrategy origPtr = (InstructionPtrStrategy)\n-                itr.next();\n-            InstructionPtrStrategy newPtr = new InstructionPtrStrategy(this);\n-            newPtr.setByteIndex(origPtr.getByteIndex());\n-            _cases.add(newPtr);\n-        }\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        // don't call super\n-        int bi = getByteIndex();\n-        for (int byteIndex = bi + 1; byteIndex % 4 != 0; byteIndex++)\n-            in.readByte();\n-\n-        setOffset(in.readInt());\n-\n-        _matches.clear();\n-        _cases.clear();\n-        for (int i = 0, pairCount = in.readInt(); i < pairCount; i++) {\n-            _matches.add(Numbers.valueOf(in.readInt()));\n-            InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n-            next.setByteIndex(bi + in.readInt());\n-            _cases.add(next);\n-        }\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        // don't call super\n-\n-        int bi = getByteIndex();\n-        for (int byteIndex = bi + 1; byteIndex % 4 != 0; byteIndex++)\n-            out.writeByte(0);\n-\n-        out.writeInt(getOffset());\n-        out.writeInt(_matches.size());\n-\n-        for (int i = 0; i < _matches.size(); i++) {\n-            out.writeInt(((Integer) _matches.get(i)).intValue());\n-            out.writeInt(((InstructionPtrStrategy) _cases.get(i)).\n-                getByteIndex() - bi);\n-        }\n-    }\n-}"},{"sha":"67a79da22631b16de72e27213ad4ae307e75b817","filename":"serp/src/main/java/serp/bytecode/MathInstruction.java","status":"removed","additions":0,"deletions":251,"changes":251,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/MathInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/MathInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MathInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,251 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * One of the math operations defined in the {@link Constants} interface.\n- * Changing the type or operation of the instruction will automatically\n- * update the underlying opcode.\n- *\n- * @author Abe White\n- */\n-public class MathInstruction extends TypedInstruction {\n-\n-    private static final Class[][] _mappings = new Class[][]{\n-        { byte.class, int.class }, { boolean.class, int.class },\n-        { char.class, int.class }, { short.class, int.class },\n-        { void.class, int.class }, { Object.class, int.class }, };\n-\n-    private int _op = -1;\n-    private String _type = null;\n-\n-    MathInstruction(Code owner) {\n-        super(owner);\n-    }\n-\n-    MathInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-        _op = getOperation();\n-    }\n-\n-    public int getStackChange() {\n-        int op = getOperation();\n-        if (op == Constants.MATH_NEG || getOpcode() == Constants.NOP)\n-            return 0;\n-\n-        String type = getTypeName();\n-        if (long.class.getName().equals(type)\n-            || double.class.getName().equals(type)) {\n-            switch (getOpcode()) {\n-                case(Constants.LSHL):\n-                case(Constants.LSHR):\n-                case(Constants.LUSHR):\n-                    return -1;\n-                default:\n-                    return -2;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    public int getLogicalStackChange() {\n-        int op = getOperation();\n-        if (op == Constants.MATH_NEG || getOpcode() == Constants.NOP)\n-            return 0;\n-        return -1;\n-    }\n-\n-    public String getTypeName() {\n-        switch (getOpcode()) {\n-            case Constants.IADD:\n-            case Constants.ISUB:\n-            case Constants.IMUL:\n-            case Constants.IDIV:\n-            case Constants.IREM:\n-            case Constants.INEG:\n-            case Constants.ISHL:\n-            case Constants.ISHR:\n-            case Constants.IUSHR:\n-            case Constants.IAND:\n-            case Constants.IOR:\n-            case Constants.IXOR:\n-                return int.class.getName();\n-            case Constants.LADD:\n-            case Constants.LSUB:\n-            case Constants.LMUL:\n-            case Constants.LDIV:\n-            case Constants.LREM:\n-            case Constants.LNEG:\n-            case Constants.LSHL:\n-            case Constants.LSHR:\n-            case Constants.LUSHR:\n-            case Constants.LAND:\n-            case Constants.LOR:\n-            case Constants.LXOR:\n-                return long.class.getName();\n-            case Constants.FADD:\n-            case Constants.FSUB:\n-            case Constants.FMUL:\n-            case Constants.FDIV:\n-            case Constants.FREM:\n-            case Constants.FNEG:\n-                return float.class.getName();\n-            case Constants.DADD:\n-            case Constants.DSUB:\n-            case Constants.DMUL:\n-            case Constants.DDIV:\n-            case Constants.DREM:\n-            case Constants.DNEG:\n-                return double.class.getName();\n-            default:\n-                return _type;\n-        }\n-    }\n-\n-    public TypedInstruction setType(String type) {\n-        type = mapType(type, _mappings, true);\n-\n-        // if an invalid type or op, revert to nop\n-        if (type == null || _op < 0) {\n-            _type = type;\n-            return (TypedInstruction) setOpcode(Constants.NOP);\n-        }\n-\n-        // valid opcode, unset saved type\n-        _type = null;\n-\n-        switch (type.charAt(0)) {\n-            case 'i':\n-                return (TypedInstruction) setOpcode(_op);\n-            case 'l':\n-                return (TypedInstruction) setOpcode(_op + 1);\n-            case 'f':\n-                return (TypedInstruction) setOpcode(_op + 2);\n-            case 'd':\n-                return (TypedInstruction) setOpcode(_op + 3);\n-            default:\n-                throw new IllegalStateException();\n-        }\n-    }\n-\n-    /**\n-     * Set the math operation to be performed. This should be one of the\n-     * math constant defined in {@link Constants}.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public MathInstruction setOperation(int operation) {\n-        _op = operation;\n-\n-        // this calculates the opcode\n-        setType(getTypeName());\n-        return this;\n-    }\n-\n-    /**\n-     * Return the operation for this math instruction; will be one of the\n-     * math constant defined in {@link Constants}, or -1 if unset.\n-     */\n-    public int getOperation() {\n-        switch (getOpcode()) {\n-            case Constants.IADD:\n-            case Constants.LADD:\n-            case Constants.FADD:\n-            case Constants.DADD:\n-                return Constants.MATH_ADD;\n-            case Constants.ISUB:\n-            case Constants.LSUB:\n-            case Constants.FSUB:\n-            case Constants.DSUB:\n-                return Constants.MATH_SUB;\n-            case Constants.IMUL:\n-            case Constants.LMUL:\n-            case Constants.FMUL:\n-            case Constants.DMUL:\n-                return Constants.MATH_MUL;\n-            case Constants.IDIV:\n-            case Constants.LDIV:\n-            case Constants.FDIV:\n-            case Constants.DDIV:\n-                return Constants.MATH_DIV;\n-            case Constants.IREM:\n-            case Constants.LREM:\n-            case Constants.FREM:\n-            case Constants.DREM:\n-                return Constants.MATH_REM;\n-            case Constants.INEG:\n-            case Constants.LNEG:\n-            case Constants.FNEG:\n-            case Constants.DNEG:\n-                return Constants.MATH_NEG;\n-            case Constants.ISHL:\n-            case Constants.LSHL:\n-                return Constants.MATH_SHL;\n-            case Constants.ISHR:\n-            case Constants.LSHR:\n-                return Constants.MATH_SHR;\n-            case Constants.IUSHR:\n-            case Constants.LUSHR:\n-                return Constants.MATH_USHR;\n-            case Constants.IAND:\n-            case Constants.LAND:\n-                return Constants.MATH_AND;\n-            case Constants.IOR:\n-            case Constants.LOR:\n-                return Constants.MATH_OR;\n-            case Constants.IXOR:\n-            case Constants.LXOR:\n-                return Constants.MATH_XOR;\n-            default:\n-                return _op;\n-        }\n-    }\n-\n-    /**\n-     * MathInstructions are equal if they have the same operation and type,\n-     * or the operation and type of either is unset.\n-     */\n-    public boolean equalsInstruction(Instruction other) {\n-        if (this == other)\n-            return true;\n-        if (!(other instanceof MathInstruction))\n-            return false;\n-\n-        MathInstruction ins = (MathInstruction) other;\n-\n-        int op = getOperation();\n-        int otherOp = ins.getOperation();\n-        boolean opEq = op == -1 || otherOp == -1 || op == otherOp;\n-\n-        String type = getTypeName();\n-        String otherType = ins.getTypeName();\n-        boolean typeEq = type == null || otherType == null\n-            || type.equals(otherType);\n-\n-        return opEq && typeEq;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterMathInstruction(this);\n-        visit.exitMathInstruction(this);\n-    }\n-\n-    void read(Instruction orig) {\n-        super.read(orig);\n-        MathInstruction ins = (MathInstruction) orig;\n-        _type = ins._type;\n-        _op = ins._op;\n-    }\n-}"},{"sha":"5267604bc8560b320cdc805221d369a66b53bd13","filename":"serp/src/main/java/serp/bytecode/MethodInstruction.java","status":"removed","additions":0,"deletions":658,"changes":658,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/MethodInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/MethodInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MethodInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,658 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Method;\n-\n-import serp.bytecode.lowlevel.ComplexEntry;\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.util.Strings;\n-\n-/**\n- * An instruction that invokes a method.\n- *\n- * @author Abe White\n- */\n-public class MethodInstruction extends Instruction {\n-\n-    private int _index = 0;\n-\n-    MethodInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    int getLength() {\n-        if (getOpcode() == Constants.INVOKEINTERFACE)\n-            return super.getLength() + 4;\n-        return super.getLength() + 2;\n-    }\n-\n-    public int getLogicalStackChange() {\n-        String ret = getMethodReturnName();\n-        if (ret == null)\n-            return 0;\n-\n-        int stack = 0;\n-\n-        // subtract a stack pos for the this ptr\n-        if (getOpcode() != Constants.INVOKESTATIC)\n-            stack--;\n-\n-        // and for each arg\n-        String[] params = getMethodParamNames();\n-        for (int i = 0; i < params.length; i++)\n-            stack--;\n-\n-        // add for the return value, if any\n-        if (!void.class.getName().equals(ret))\n-            stack++;\n-\n-        return stack;\n-    }\n-\n-    public int getStackChange() {\n-        String ret = getMethodReturnName();\n-        if (ret == null)\n-            return 0;\n-\n-        int stack = 0;\n-\n-        // subtract a stack pos for the this ptr\n-        if (getOpcode() != Constants.INVOKESTATIC)\n-            stack--;\n-\n-        // and for each arg(2 for longs, doubles)\n-        String[] params = getMethodParamNames();\n-        for (int i = 0; i < params.length; i++, stack--)\n-            if (long.class.getName().equals(params[i])\n-                || double.class.getName().equals(params[i]))\n-                stack--;\n-\n-        // add for the return value, if any\n-        if (!void.class.getName().equals(ret))\n-            stack++;\n-        if (long.class.getName().equals(ret)\n-            || double.class.getName().equals(ret))\n-            stack++;\n-\n-        return stack;\n-    }\n-\n-    /////////////////////\n-    // Method operations\n-    /////////////////////\n-\n-    /**\n-     * Return the index in the class {@link ConstantPool} of the\n-     * {@link ComplexEntry} describing the method to operate on.\n-     */\n-    public int getMethodIndex() {\n-        return _index;\n-    }\n-\n-    /**\n-     * Set the index in the class {@link ConstantPool} of the\n-     * {@link ComplexEntry} describing the method to operate on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethodIndex(int index) {\n-        _index = index;\n-        return this;\n-    }\n-\n-    /**\n-     * Return the method this instruction operates on, or null if not set.\n-     */\n-    public BCMethod getMethod() {\n-        String dec = getMethodDeclarerName();\n-        if (dec == null)\n-            return null;\n-\n-        BCClass bc = getProject().loadClass(dec, getClassLoader());\n-        BCMethod[] meths = bc.getMethods(getMethodName(),\n-            getMethodParamNames());\n-\n-        if (meths.length == 0)\n-            return null;\n-        return meths[0];\n-    }\n-\n-    /**\n-     * Set the method this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethod(BCMethod method) {\n-        if (method == null)\n-            return setMethodIndex(0);\n-        return setMethod(method.getDeclarer().getName(), method.getName(),\n-            method.getReturnName(), method.getParamNames());\n-    }\n-\n-    /**\n-     * Set the method this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethod(Method method) {\n-        if (method == null)\n-            return setMethodIndex(0);\n-        return setMethod(method.getDeclaringClass(), method.getName(),\n-            method.getReturnType(), method.getParameterTypes());\n-    }\n-\n-    /**\n-     * Set the method this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethod(Constructor method) {\n-        if (method == null)\n-            return setMethodIndex(0);\n-\n-        setOpcode(Constants.INVOKESPECIAL);\n-        return setMethod(method.getDeclaringClass(), \"<init>\",\n-            void.class, method.getParameterTypes());\n-    }\n-\n-    /**\n-     * Set the method this instruction operates on.\n-     *\n-     * @param dec the full class name of the method's declaring class\n-     * @param name the method name\n-     * @param returnType the full class name of the method return type\n-     * @param param the full class names of the method param types\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethod(String dec, String name,\n-        String returnType, String[] params) {\n-        if (name == null && returnType == null && dec == null\n-            && (params == null || params.length == 0))\n-            return setMethodIndex(0);\n-\n-        if (dec == null)\n-            dec = \"\";\n-        if (name == null)\n-            name = \"\";\n-        if (returnType == null)\n-            returnType = \"\";\n-        if (params == null)\n-            params = new String[0];\n-\n-        NameCache cache = getProject().getNameCache();\n-        returnType = cache.getInternalForm(returnType, true);\n-        dec = cache.getInternalForm(dec, false);\n-        for (int i = 0; i < params.length; i++)\n-            params[i] = cache.getInternalForm(params[i], true);\n-\n-        String desc = cache.getDescriptor(returnType, params);\n-\n-        if (getOpcode() == Constants.INVOKEINTERFACE)\n-            return setMethodIndex(getPool().findInterfaceMethodEntry\n-                (dec, name, desc, true));\n-        return setMethodIndex(getPool().findMethodEntry\n-            (dec, name, desc, true));\n-    }\n-\n-    /**\n-     * Set the method this instruction operates on, for methods that are\n-     * declared by the current class.\n-     *\n-     * @param name the method name\n-     * @param returnType the full class name of the method return type\n-     * @param param the full class names of the method param types\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethod(String name, String returnType,\n-        String[] params) {\n-        BCClass owner = getCode().getMethod().getDeclarer();\n-        return setMethod(owner.getName(), name, returnType, params);\n-    }\n-\n-    /**\n-     * Set the method this instruction operates on.\n-     *\n-     * @param dec the method's declaring class\n-     * @param name the method name\n-     * @param returnType the class of the method return type\n-     * @param param the class of the method param types\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethod(Class dec, String name,\n-        Class returnType, Class[] params) {\n-        String decName = (dec == null) ? null : dec.getName();\n-        String returnName = (returnType == null) ? null : returnType.getName();\n-        String[] paramNames = null;\n-        if (params != null) {\n-            paramNames = new String[params.length];\n-            for (int i = 0; i < params.length; i++)\n-                paramNames[i] = params[i].getName();\n-        }\n-        return setMethod(decName, name, returnName, paramNames);\n-    }\n-\n-    /**\n-     * Set the method this instruction operates on, for methods that are\n-     * declared by the current class.\n-     *\n-     * @param name the method name\n-     * @param returnType the class of the method return type\n-     * @param param the class of the method param types\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethod(String name, Class returnType,\n-        Class[] params) {\n-        BCClass owner = getCode().getMethod().getDeclarer();\n-        String returnName = (returnType == null) ? null : returnType.getName();\n-        String[] paramNames = null;\n-        if (params != null) {\n-            paramNames = new String[params.length];\n-            for (int i = 0; i < params.length; i++)\n-                paramNames[i] = params[i].getName();\n-        }\n-        return setMethod(owner.getName(), name, returnName, paramNames);\n-    }\n-\n-    /**\n-     * Set the method this instruction operates on.\n-     *\n-     * @param dec the method's declaring class\n-     * @param name the method name\n-     * @param returnType the class of the method return type\n-     * @param param the class of the method param types\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethod(BCClass dec, String name,\n-        BCClass returnType, BCClass[] params) {\n-        String decName = (dec == null) ? null : dec.getName();\n-        String returnName = (returnType == null) ? null : returnType.getName();\n-        String[] paramNames = null;\n-        if (params != null) {\n-            paramNames = new String[params.length];\n-            for (int i = 0; i < params.length; i++)\n-                paramNames[i] = params[i].getName();\n-        }\n-        return setMethod(decName, name, returnName, paramNames);\n-    }\n-\n-    /**\n-     * Set the method this instruction operates on, for methods that are\n-     * declared by the current class.\n-     *\n-     * @param name the method name\n-     * @param returnType the class of the method return type\n-     * @param param the class of the method param types\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethod(String name, BCClass returnType,\n-        BCClass[] params) {\n-        BCClass owner = getCode().getMethod().getDeclarer();\n-        String returnName = (returnType == null) ? null : returnType.getName();\n-        String[] paramNames = null;\n-        if (params != null) {\n-            paramNames = new String[params.length];\n-            for (int i = 0; i < params.length; i++)\n-                paramNames[i] = params[i].getName();\n-        }\n-        return setMethod(owner.getName(), name, returnName, paramNames);\n-    }\n-\n-    /////////////////////////////////////////\n-    // Name, Return, Param, Owner operations\n-    /////////////////////////////////////////\n-\n-    /**\n-     * Return the name of the method this instruction operates on, or null\n-     * if not set.\n-     */\n-    public String getMethodName() {\n-        int index = getMethodIndex();\n-        if (index == 0)\n-            return null;\n-\n-        ComplexEntry entry = (ComplexEntry) getPool().getEntry(index);\n-        String name = entry.getNameAndTypeEntry().getNameEntry().getValue();\n-        if (name.length() == 0)\n-            return null;\n-\n-        return name;\n-    }\n-\n-    /**\n-     * Set the name of the method this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethodName(String name) {\n-        return setMethod(getMethodDeclarerName(), name,\n-            getMethodReturnName(), getMethodParamNames());\n-    }\n-\n-    /**\n-     * Return the return type of the method this instruction operates on,\n-     * or null if not set.\n-     */\n-    public String getMethodReturnName() {\n-        int index = getMethodIndex();\n-        if (index == 0)\n-            return null;\n-\n-        ComplexEntry entry = (ComplexEntry) getPool().getEntry(index);\n-        String desc = entry.getNameAndTypeEntry().getDescriptorEntry().\n-            getValue();\n-        NameCache cache = getProject().getNameCache();\n-        String name = cache.getExternalForm(cache.getDescriptorReturnName\n-            (desc), false);\n-        if (name.length() == 0)\n-            return null;\n-\n-        return name;\n-    }\n-\n-    /**\n-     * Return the return type of the method this instruction operates on,\n-     * or null if not set.\n-     */\n-    public Class getMethodReturnType() {\n-        String type = getMethodReturnName();\n-        if (type == null)\n-            return null;\n-        return Strings.toClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Return the return type of the method this instruction operates on,\n-     * or null if not set.\n-     */\n-    public BCClass getMethodReturnBC() {\n-        String type = getMethodReturnName();\n-        if (type == null)\n-            return null;\n-        return getProject().loadClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Set the return type of the method this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethodReturn(String type) {\n-        return setMethod(getMethodDeclarerName(), getMethodName(), type,\n-            getMethodParamNames());\n-    }\n-\n-    /**\n-     * Set the return type of the method this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethodReturn(Class type) {\n-        String name = null;\n-        if (type != null)\n-            name = type.getName();\n-        return setMethodReturn(name);\n-    }\n-\n-    /**\n-     * Set the return type of the method this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethodReturn(BCClass type) {\n-        String name = null;\n-        if (type != null)\n-            name = type.getName();\n-        return setMethodReturn(name);\n-    }\n-\n-    /**\n-     * Return the param types of the method this instruction operates on,\n-     * or empty array if none.\n-     */\n-    public String[] getMethodParamNames() {\n-        int index = getMethodIndex();\n-        if (index == 0)\n-            return null;\n-\n-        ComplexEntry entry = (ComplexEntry) getPool().getEntry(index);\n-        String desc = entry.getNameAndTypeEntry().getDescriptorEntry().\n-            getValue();\n-        NameCache cache = getProject().getNameCache();\n-        String[] names = cache.getDescriptorParamNames(desc);\n-        for (int i = 0; i < names.length; i++)\n-            names[i] = cache.getExternalForm(names[i], false);\n-        return names;\n-    }\n-\n-    /**\n-     * Return the param types of the method this instruction operates on,\n-     * or empty array if none.\n-     */\n-    public Class[] getMethodParamTypes() {\n-        String[] paramNames = getMethodParamNames();\n-        Class[] params = new Class[paramNames.length];\n-        for (int i = 0; i < paramNames.length; i++)\n-            params[i] = Strings.toClass(paramNames[i], getClassLoader());\n-        return params;\n-    }\n-\n-    /**\n-     * Return the param types of the method this instruction operates on,\n-     * or empty array if none.\n-     */\n-    public BCClass[] getMethodParamBCs() {\n-        String[] paramNames = getMethodParamNames();\n-        BCClass[] params = new BCClass[paramNames.length];\n-        for (int i = 0; i < paramNames.length; i++)\n-            params[i] = getProject().loadClass(paramNames[i], getClassLoader());\n-        return params;\n-    }\n-\n-    /**\n-     * Set the param types of the method this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethodParams(String[] types) {\n-        return setMethod(getMethodDeclarerName(), getMethodName(),\n-            getMethodReturnName(), types);\n-    }\n-\n-    /**\n-     * Set the param types of the method this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public void setMethodParams(Class[] types) {\n-        if (types == null)\n-            setMethodParams((String[]) null);\n-        else {\n-            String[] names = new String[types.length];\n-            for (int i = 0; i < types.length; i++)\n-                names[i] = types[i].getName();\n-            setMethodParams(names);\n-        }\n-    }\n-\n-    /**\n-     * Set the param types of the method this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public void setMethodParams(BCClass[] types) {\n-        if (types == null)\n-            setMethodParams((String[]) null);\n-        else {\n-            String[] names = new String[types.length];\n-            for (int i = 0; i < types.length; i++)\n-                names[i] = types[i].getName();\n-            setMethodParams(names);\n-        }\n-    }\n-\n-    /**\n-     * Return the declaring type of the method this instruction operates on,\n-     * or null if not set.\n-     */\n-    public String getMethodDeclarerName() {\n-        int index = getMethodIndex();\n-        if (index == 0)\n-            return null;\n-\n-        ComplexEntry entry = (ComplexEntry) getPool().getEntry(index);\n-        String name = getProject().getNameCache().getExternalForm\n-            (entry.getClassEntry().getNameEntry().getValue(), false);\n-        if (name.length() == 0)\n-            return null;\n-        return name;\n-    }\n-\n-    /**\n-     * Return the declaring type of the method this instruction operates on,\n-     * or null if not set.\n-     */\n-    public Class getMethodDeclarerType() {\n-        String type = getMethodDeclarerName();\n-        if (type == null)\n-            return null;\n-        return Strings.toClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Return the declaring type of the method this instruction operates on,\n-     * or null if not set.\n-     */\n-    public BCClass getMethodDeclarerBC() {\n-        String type = getMethodDeclarerName();\n-        if (type == null)\n-            return null;\n-        return getProject().loadClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Set the declaring type of the method this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethodDeclarer(String type) {\n-        return setMethod(type, getMethodName(), getMethodReturnName(),\n-            getMethodParamNames());\n-    }\n-\n-    /**\n-     * Set the declaring type of the method this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethodDeclarer(Class type) {\n-        String name = null;\n-        if (type != null)\n-            name = type.getName();\n-        return setMethodDeclarer(name);\n-    }\n-\n-    /**\n-     * Set the declaring type of the method this instruction operates on.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public MethodInstruction setMethodDeclarer(BCClass type) {\n-        String name = null;\n-        if (type != null)\n-            name = type.getName();\n-        return setMethodDeclarer(name);\n-    }\n-\n-    /**\n-     * MethodInstructions are equal if the method they reference is the same,\n-     * or if the method of either is unset.\n-     */\n-    public boolean equalsInstruction(Instruction other) {\n-        if (other == this)\n-            return true;\n-        if (!(other instanceof MethodInstruction))\n-            return false;\n-        if (!super.equalsInstruction(other))\n-            return false;\n-\n-        MethodInstruction ins = (MethodInstruction) other;\n-\n-        String s1 = getMethodName();\n-        String s2 = ins.getMethodName();\n-        if (!(s1 == null || s2 == null || s1.equals(s2)))\n-            return false;\n-\n-        s1 = getMethodReturnName();\n-        s2 = ins.getMethodReturnName();\n-        if (!(s1 == null || s2 == null || s1.equals(s2)))\n-            return false;\n-\n-        s1 = getMethodDeclarerName();\n-        s2 = ins.getMethodDeclarerName();\n-        if (!(s1 == null || s2 == null || s1.equals(s2)))\n-            return false;\n-\n-        String[] p1 = getMethodParamNames();\n-        String[] p2 = ins.getMethodParamNames();\n-        if (!(p1.length == 0 || p2.length == 0 || p1.length == p2.length))\n-            return false;\n-        for (int i = 0; i < p1.length; i++)\n-            if (!(p1[i] == null || p2[i] == null || p1[i].equals(p2[i])))\n-                return false;\n-\n-        return true;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterMethodInstruction(this);\n-        visit.exitMethodInstruction(this);\n-    }\n-\n-    void read(Instruction orig) {\n-        super.read(orig);\n-        MethodInstruction ins = (MethodInstruction) orig;\n-        setMethod(ins.getMethodDeclarerName(), ins.getMethodName(),\n-            ins.getMethodReturnName(), ins.getMethodParamNames());\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        super.read(in);\n-        setMethodIndex(in.readUnsignedShort());\n-        if (getOpcode() == Constants.INVOKEINTERFACE) {\n-            in.readByte();\n-            in.readByte();\n-        }\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        super.write(out);\n-        out.writeShort(getMethodIndex());\n-        if (getOpcode() == Constants.INVOKEINTERFACE) {\n-            String[] args = getMethodParamNames();\n-            int count = 1;\n-            for (int i = 0; i < args.length; i++, count++)\n-                if (long.class.getName().equals(args[i])\n-                    || double.class.getName().equals(args[i]))\n-                    count++;\n-\n-            out.writeByte(count);\n-            out.writeByte(0);\n-        }\n-    }\n-}"},{"sha":"f8687efb184351871b42b1d5b71464d66602e6af","filename":"serp/src/main/java/serp/bytecode/MonitorEnterInstruction.java","status":"removed","additions":0,"deletions":32,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/MonitorEnterInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/MonitorEnterInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MonitorEnterInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,32 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * The <code>monitorenter</code> instruction.\n- *\n- * @author Abe White\n- */\n-public class MonitorEnterInstruction extends MonitorInstruction {\n-\n-    MonitorEnterInstruction(Code owner) {\n-        super(owner, Constants.MONITORENTER);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterMonitorEnterInstruction(this);\n-        visit.exitMonitorEnterInstruction(this);\n-    }\n-}"},{"sha":"3010d39f3e60ebd7275f94643eca7f92e83dc8ed","filename":"serp/src/main/java/serp/bytecode/MonitorExitInstruction.java","status":"removed","additions":0,"deletions":32,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/MonitorExitInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/MonitorExitInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MonitorExitInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,32 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * The <code>monitorexit</code> instruction.\n- *\n- * @author Abe White\n- */\n-public class MonitorExitInstruction extends MonitorInstruction {\n-\n-    MonitorExitInstruction(Code owner) {\n-        super(owner, Constants.MONITOREXIT);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterMonitorExitInstruction(this);\n-        visit.exitMonitorExitInstruction(this);\n-    }\n-}"},{"sha":"448249cfebb31590b8ff7a747d0969a726bfe852","filename":"serp/src/main/java/serp/bytecode/MonitorInstruction.java","status":"removed","additions":0,"deletions":33,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/MonitorInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/MonitorInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MonitorInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,33 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-/**\n- * A synchronization instruction.\n- *\n- * @author Abe White\n- */\n-public abstract class MonitorInstruction extends Instruction {\n-\n-    MonitorInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    public int getLogicalStackChange() {\n-        return getStackChange();\n-    }\n-\n-    public int getStackChange() {\n-        return -1;\n-    }\n-}"},{"sha":"5a0475aa0904f98ec1cddcac326fbaf469928a34","filename":"serp/src/main/java/serp/bytecode/MultiANewArrayInstruction.java","status":"removed","additions":0,"deletions":101,"changes":101,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/MultiANewArrayInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/MultiANewArrayInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MultiANewArrayInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,101 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * The <code>multianewarray</code> instruction, which creates a new\n- * multi-dimensional array.\n- *\n- * @author Abe White\n- */\n-public class MultiANewArrayInstruction extends ClassInstruction {\n-\n-    private int _dims = -1;\n-\n-    MultiANewArrayInstruction(Code owner) {\n-        super(owner, Constants.MULTIANEWARRAY);\n-    }\n-\n-    int getLength() {\n-        return super.getLength() + 1;\n-    }\n-\n-    public int getLogicalStackChange() {\n-        return getStackChange();\n-    }\n-\n-    public int getStackChange() {\n-        return -(getDimensions()) + 1;\n-    }\n-\n-    /**\n-     * Return the dimensions of the array, or -1 if not set.\n-     */\n-    public int getDimensions() {\n-        return _dims;\n-    }\n-\n-    /**\n-     * Set the dimensions of the array.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public MultiANewArrayInstruction setDimensions(int dims) {\n-        _dims = dims;\n-        return this;\n-    }\n-\n-    /**\n-     * Two MultiANewArray instructions are equal if they have the same\n-     * type and dimensions, or if the type and dimensions of either is unset.\n-     */\n-    public boolean equalsInstruction(Instruction other) {\n-        if (other == this)\n-            return true;\n-        if (!(other instanceof MultiANewArrayInstruction))\n-            return false;\n-        if (!super.equalsInstruction(other))\n-            return false;\n-\n-        MultiANewArrayInstruction ins = (MultiANewArrayInstruction) other;\n-        int dims = getDimensions();\n-        int otherDims = ins.getDimensions();\n-        return dims == -1 || otherDims == -1 || dims == otherDims;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterMultiANewArrayInstruction(this);\n-        visit.exitMultiANewArrayInstruction(this);\n-    }\n-\n-    void read(Instruction orig) {\n-        super.read(orig);\n-        setDimensions(((MultiANewArrayInstruction) orig).getDimensions());\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        super.read(in);\n-        setDimensions(in.readUnsignedByte());\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        super.write(out);\n-        out.writeByte(getDimensions());\n-    }\n-}"},{"sha":"fd2c1316b20eb48839b7dc9b3615bd4f1beaf7fc","filename":"serp/src/main/java/serp/bytecode/NameCache.java","status":"removed","additions":0,"deletions":251,"changes":251,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/NameCache.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/NameCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/NameCache.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,251 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * Caching and conversion of names in both internal and external form.\n- *\n- * @author Abe White\n- */\n-public class NameCache {\n-\n-    static final Object[][] _codes = new Object[][]{\n-        { byte.class, \"B\" }, { char.class, \"C\" }, { double.class, \"D\" },\n-        { float.class, \"F\" }, { int.class, \"I\" }, { long.class, \"J\" },\n-        { short.class, \"S\" }, { boolean.class, \"Z\" }, { void.class, \"V\" }, };\n-\n-    // caches of internal and external forms of strings\n-    private final Map _internal = new HashMap();\n-    private final Map _internalDescriptor = new HashMap();\n-    private final Map _external = new HashMap();\n-    private final Map _externalHuman = new HashMap();\n-\n-    /**\n-     * Converts the given class name to its internal form.\n-     *\n-     * @param className the name to convert\n-     * @param descriptor true if the name is to be used for a descriptor\n-     * section -- the difference seems to be that for\n-     * descriptors, non-primitives are prefixed with 'L' and ended with ';'\n-     */\n-    public String getInternalForm(String className, boolean descriptor) {\n-        if (className == null || className.length() == 0)\n-            return className;\n-\n-        Map cache = (descriptor) ? _internalDescriptor : _internal;\n-        String cached = (String) cache.get(className);\n-        if (cached != null)\n-            return cached;\n-\n-        String ret = getInternalFormInternal(className, descriptor);\n-        cache.put(className, ret);\n-        return ret;\n-    }\n-\n-    /**\n-     * @see #getInternalForm\n-     */\n-    private String getInternalFormInternal(String cls, boolean descriptor) {\n-        // handle array types, whether already in internal form or not\n-        StringBuffer prefix = new StringBuffer();\n-        while (true) {\n-            if (cls.endsWith(\"[]\")) {\n-                prefix.append(\"[\");\n-                cls = cls.substring(0, cls.length() - 2);\n-            } else if (cls.startsWith(\"[\")) {\n-                prefix.append(\"[\");\n-                cls = cls.substring(1);\n-            } else\n-                break;\n-        }\n-\n-        // handle primitive array types\n-        for (int i = 0; i < _codes.length; i++)\n-            if (cls.equals(_codes[i][1].toString())\n-                || cls.equals(_codes[i][0].toString()))\n-                return prefix.append(_codes[i][1]).toString();\n-\n-        // if in descriptor form, strip leading 'L' and trailing ';'\n-        if (cls.startsWith(\"L\") && cls.endsWith(\";\"))\n-            cls = cls.substring(1, cls.length() - 1);\n-\n-        // non-primitive; make sure we don't prefix method descriptors with 'L'\n-        cls = cls.replace('.', '/');\n-        if ((descriptor || prefix.length() > 0) && cls.charAt(0) != '(')\n-            return prefix.append(\"L\").append(cls).append(\";\").toString();\n-        return prefix.append(cls).toString();\n-    }\n-\n-    /**\n-     * Given the internal name of the class, return the 'normal' java name.\n-     *\n-     * @param internalName the internal name being used\n-     * @param humanReadable if the returned name should be in human-readable\n-     * form, rather than a form suitable for a\n-     * {@link Class#forName} call -- the difference\n-     * lies in the handling of arrays\n-     */\n-    public String getExternalForm(String internalName, boolean humanReadable) {\n-        if (internalName == null || internalName.length() == 0)\n-            return internalName;\n-\n-        Map cache = (humanReadable) ? _externalHuman : _external;\n-        String cached = (String) cache.get(internalName);\n-        if (cached != null)\n-            return cached;\n-\n-        String ret = getExternalFormInternal(internalName, humanReadable);\n-        cache.put(internalName, ret);\n-        return ret;\n-    }\n-\n-    /**\n-     * @see #getExternalForm\n-     */\n-    private String getExternalFormInternal(String intern,\n-        boolean humanReadable) {\n-        if (!humanReadable) {\n-            // check against primitives\n-            for (int i = 0; i < _codes.length; i++) {\n-                if (intern.equals(_codes[i][1].toString()))\n-                    return _codes[i][0].toString();\n-                if (intern.equals(_codes[i][0].toString()))\n-                    return intern;\n-            }\n-\n-            intern = getInternalForm(intern, false);\n-            return intern.replace('/', '.');\n-        }\n-\n-        // handle arrays\n-        StringBuffer postfix = new StringBuffer(2);\n-        while (intern.startsWith(\"[\")) {\n-            intern = intern.substring(1);\n-            postfix.append(\"[]\");\n-        }\n-\n-        // strip off leading 'L' and trailing ';'\n-        if (intern.endsWith(\";\"))\n-            intern = intern.substring(1, intern.length() - 1);\n-\n-        // check primitives\n-        for (int i = 0; i < _codes.length; i++)\n-            if (intern.equals(_codes[i][1].toString()))\n-                return _codes[i][0].toString() + postfix;\n-\n-        return intern.replace('/', '.') + postfix;\n-    }\n-\n-    /**\n-     * Construct a method descriptor from the given return and parameter\n-     * types, which will be converted to internal form.\n-     */\n-    public String getDescriptor(String returnType, String[] paramTypes) {\n-        StringBuffer buf = new StringBuffer();\n-        buf.append(\"(\");\n-        if (paramTypes != null) {\n-            for (int i = 0; i < paramTypes.length; i++) {\n-                if (paramTypes[i] == null)\n-                    throw new NullPointerException(\"paramTypes[\" + i\n-                        + \"] = null\");\n-\n-                buf.append(getInternalForm(paramTypes[i], true));\n-            }\n-        }\n-        buf.append(\")\");\n-\n-        if (returnType == null)\n-            throw new NullPointerException(\"returnType = null\");\n-        buf.append(getInternalForm(returnType, true));\n-\n-        return buf.toString();\n-    }\n-\n-    /**\n-     * Return the return type, in internal form, for the given method\n-     * descriptor string.\n-     */\n-    public String getDescriptorReturnName(String descriptor) {\n-        int index = descriptor.indexOf(')');\n-        if (index == -1)\n-            return \"\";\n-        return descriptor.substring(descriptor.indexOf(')') + 1);\n-    }\n-\n-    /**\n-     * Return the parameter types, in internal form, for the given method\n-     * descriptor string.\n-     */\n-    public String[] getDescriptorParamNames(String descriptor) {\n-        if (descriptor == null || descriptor.length() == 0)\n-            return new String[0];\n-\n-        int index = descriptor.indexOf(')');\n-        if (index == -1)\n-            return new String[0];\n-\n-        // get rid of the parens and the return type\n-        descriptor = descriptor.substring(1, index);\n-\n-        // break the param string into individual params\n-        List tokens = new LinkedList();\n-        while (descriptor.length() > 0) {\n-            index = 0;\n-\n-            // skip the '[' up to the first letter code\n-            while (!Character.isLetter(descriptor.charAt(index)))\n-                index++;\n-\n-            // non-primitives always start with 'L' and end with ';'\n-            if (descriptor.charAt(index) == 'L')\n-                index = descriptor.indexOf(';');\n-\n-            tokens.add(descriptor.substring(0, index + 1));\n-            descriptor = descriptor.substring(index + 1);\n-        }\n-\n-        return (String[]) tokens.toArray(new String[tokens.size()]);\n-    }\n-\n-    /**\n-     * Return the component type name for the given array type, or null\n-     * if the given string does not represent an array type name. The name\n-     * given should be in proper {@link Class#forName} form.\n-     */\n-    public String getComponentName(String name) {\n-        if (name == null || !name.startsWith(\"[\"))\n-            return null;\n-\n-        name = name.substring(1);\n-        if (!name.startsWith(\"[\") && name.endsWith(\";\"))\n-            name = name.substring(1, name.length() - 1);\n-\n-        // will convert primitive type codes to names\n-        return getExternalForm(name, false);\n-    }\n-\n-    /**\n-     * Clear the cache.\n-     */\n-    public void clear() {\n-        _internal.clear();\n-        _internalDescriptor.clear();\n-        _external.clear();\n-        _externalHuman.clear();\n-    }\n-}"},{"sha":"f5374677289106fe998d8405351a518e68003e88","filename":"serp/src/main/java/serp/bytecode/NewArrayInstruction.java","status":"removed","additions":0,"deletions":144,"changes":144,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/NewArrayInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/NewArrayInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/NewArrayInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,144 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * The <code>newarray</code> instruction, which is used to create new\n- * arrays of primitive types.\n- *\n- * @author Abe White\n- */\n-public class NewArrayInstruction extends TypedInstruction {\n-\n-    private static final Class[][] _mappings = new Class[][]{\n-        { void.class, int.class }, { Object.class, int.class }, };\n-\n-    private int _code = -1;\n-\n-    NewArrayInstruction(Code owner) {\n-        super(owner, Constants.NEWARRAY);\n-    }\n-\n-    int getLength() {\n-        return super.getLength() + 1;\n-    }\n-\n-    public String getTypeName() {\n-        switch (getTypeCode()) {\n-            case Constants.ARRAY_BOOLEAN:\n-                return boolean.class.getName();\n-            case Constants.ARRAY_CHAR:\n-                return char.class.getName();\n-            case Constants.ARRAY_FLOAT:\n-                return float.class.getName();\n-            case Constants.ARRAY_DOUBLE:\n-                return double.class.getName();\n-            case Constants.ARRAY_BYTE:\n-                return byte.class.getName();\n-            case Constants.ARRAY_SHORT:\n-                return short.class.getName();\n-            case Constants.ARRAY_INT:\n-                return int.class.getName();\n-            case Constants.ARRAY_LONG:\n-                return long.class.getName();\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    public TypedInstruction setType(String type) {\n-        type = mapType(type, _mappings, true);\n-        if (type == null)\n-            return setTypeCode(-1);\n-\n-        switch (type.charAt(0)) {\n-            case 'b':\n-                if (boolean.class.getName().equals(type))\n-                    return setTypeCode(Constants.ARRAY_BOOLEAN);\n-                return setTypeCode(Constants.ARRAY_BYTE);\n-            case 'c':\n-                return setTypeCode(Constants.ARRAY_CHAR);\n-            case 'f':\n-                return setTypeCode(Constants.ARRAY_FLOAT);\n-            case 'd':\n-                return setTypeCode(Constants.ARRAY_DOUBLE);\n-            case 's':\n-                return setTypeCode(Constants.ARRAY_SHORT);\n-            case 'i':\n-                return setTypeCode(Constants.ARRAY_INT);\n-            case 'l':\n-                return setTypeCode(Constants.ARRAY_LONG);\n-            default:\n-                throw new IllegalStateException();\n-        }\n-    }\n-\n-    /**\n-     * Return the array code used in the lowlevel bytecode, or -1 if unset.\n-     */\n-    public int getTypeCode() {\n-        return _code;\n-    }\n-\n-    /**\n-     * Set the array code used in the lowlevel bytecode.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public NewArrayInstruction setTypeCode(int code) {\n-        _code = code;\n-        return this;\n-    }\n-\n-    /**\n-     * NewArray instructions are equal if the array type is the same,\n-     * of if the array type of either is unset.\n-     */\n-    public boolean equalsInstruction(Instruction other) {\n-        if (this == other)\n-            return true;\n-        if (!(other instanceof NewArrayInstruction))\n-            return false;\n-\n-        NewArrayInstruction ins = (NewArrayInstruction) other;\n-        int code = getTypeCode();\n-        int otherCode = ins.getTypeCode();\n-        return code == -1 || otherCode == -1 || code == otherCode;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterNewArrayInstruction(this);\n-        visit.exitNewArrayInstruction(this);\n-    }\n-\n-    void read(Instruction orig) {\n-        super.read(orig);\n-        setTypeCode(((NewArrayInstruction) orig).getTypeCode());\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        super.read(in);\n-        setTypeCode(in.readUnsignedByte());\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        super.write(out);\n-        out.writeByte(getTypeCode());\n-    }\n-}"},{"sha":"d0b83e81928b80265bdb6f07446e989b7b0594d9","filename":"serp/src/main/java/serp/bytecode/ObjectState.java","status":"removed","additions":0,"deletions":141,"changes":141,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ObjectState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ObjectState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ObjectState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,141 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-\n-import serp.bytecode.lowlevel.ClassEntry;\n-import serp.bytecode.lowlevel.ConstantPool;\n-\n-/**\n- * State implementing the behavior of an object type.\n- *\n- * @author Abe White\n- */\n-class ObjectState extends State {\n-\n-    private final ConstantPool _pool = new ConstantPool();\n-    private final NameCache _names;\n-\n-    private int _index = 0;\n-    private int _superclassIndex = 0;\n-    private int _magic = Constants.VALID_MAGIC;\n-    private int _major = Constants.MAJOR_VERSION;\n-    private int _minor = Constants.MINOR_VERSION;\n-    private int _access = Constants.ACCESS_PUBLIC | Constants.ACCESS_SUPER;\n-\n-    private final Collection _interfaces = new HashSet();\n-    private final Collection _fields = new LinkedList();\n-    private final Collection _methods = new LinkedList();\n-    private final Collection _attributes = new LinkedList();\n-\n-    public ObjectState(NameCache names) {\n-        _names = names;\n-    }\n-\n-    public int getMagic() {\n-        return _magic;\n-    }\n-\n-    public void setMagic(int magic) {\n-        _magic = magic;\n-    }\n-\n-    public int getMajorVersion() {\n-        return _major;\n-    }\n-\n-    public void setMajorVersion(int major) {\n-        _major = major;\n-    }\n-\n-    public int getMinorVersion() {\n-        return _minor;\n-    }\n-\n-    public void setMinorVersion(int minor) {\n-        _minor = minor;\n-    }\n-\n-    public int getAccessFlags() {\n-        return _access;\n-    }\n-\n-    public void setAccessFlags(int access) {\n-        _access = access;\n-    }\n-\n-    public int getIndex() {\n-        return _index;\n-    }\n-\n-    public void setIndex(int index) {\n-        _index = index;\n-    }\n-\n-    public int getSuperclassIndex() {\n-        return _superclassIndex;\n-    }\n-\n-    public void setSuperclassIndex(int index) {\n-        _superclassIndex = index;\n-    }\n-\n-    public Collection getInterfacesHolder() {\n-        return _interfaces;\n-    }\n-\n-    public Collection getFieldsHolder() {\n-        return _fields;\n-    }\n-\n-    public Collection getMethodsHolder() {\n-        return _methods;\n-    }\n-\n-    public Collection getAttributesHolder() {\n-        return _attributes;\n-    }\n-\n-    public ConstantPool getPool() {\n-        return _pool;\n-    }\n-\n-    public String getName() {\n-        if (_index == 0)\n-            return null;\n-        return _names.getExternalForm(((ClassEntry) _pool.getEntry(_index)).\n-            getNameEntry().getValue(), false);\n-    }\n-\n-    public String getSuperclassName() {\n-        if (_superclassIndex == 0)\n-            return null;\n-        return _names.getExternalForm(((ClassEntry) _pool.getEntry\n-            (_superclassIndex)).getNameEntry().getValue(), false);\n-    }\n-\n-    public String getComponentName() {\n-        return null;\n-    }\n-\n-    public boolean isPrimitive() {\n-        return false;\n-    }\n-\n-    public boolean isArray() {\n-        return false;\n-    }\n-}"},{"sha":"09031c9c0c36c381d6429ac3a400c1a469b16425","filename":"serp/src/main/java/serp/bytecode/PrimitiveState.java","status":"removed","additions":0,"deletions":92,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/PrimitiveState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/PrimitiveState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/PrimitiveState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,92 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.util.Collection;\n-import java.util.Collections;\n-\n-/**\n- * State implementing the behavior of a primitive class.\n- *\n- * @author Abe White\n- */\n-class PrimitiveState extends State {\n-\n-    private final Class _type;\n-    private final NameCache _names;\n-\n-    public PrimitiveState(Class type, NameCache names) {\n-        _type = type;\n-        _names = names;\n-    }\n-\n-    public int getMagic() {\n-        return Constants.VALID_MAGIC;\n-    }\n-\n-    public int getMajorVersion() {\n-        return Constants.MAJOR_VERSION;\n-    }\n-\n-    public int getMinorVersion() {\n-        return Constants.MINOR_VERSION;\n-    }\n-\n-    public int getAccessFlags() {\n-        return Constants.ACCESS_PUBLIC | Constants.ACCESS_FINAL;\n-    }\n-\n-    public int getIndex() {\n-        return 0;\n-    }\n-\n-    public int getSuperclassIndex() {\n-        return 0;\n-    }\n-\n-    public Collection getInterfacesHolder() {\n-        return Collections.EMPTY_LIST;\n-    }\n-\n-    public Collection getFieldsHolder() {\n-        return Collections.EMPTY_LIST;\n-    }\n-\n-    public Collection getMethodsHolder() {\n-        return Collections.EMPTY_LIST;\n-    }\n-\n-    public Collection getAttributesHolder() {\n-        return Collections.EMPTY_LIST;\n-    }\n-\n-    public String getName() {\n-        return _names.getExternalForm(_type.getName(), false);\n-    }\n-\n-    public String getSuperclassName() {\n-        return null;\n-    }\n-\n-    public String getComponentName() {\n-        return null;\n-    }\n-\n-    public boolean isPrimitive() {\n-        return true;\n-    }\n-\n-    public boolean isArray() {\n-        return false;\n-    }\n-}"},{"sha":"31059392abe992078e7dcc6ffd8f1e591179e30a","filename":"serp/src/main/java/serp/bytecode/Project.java","status":"removed","additions":0,"deletions":404,"changes":404,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Project.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Project.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Project.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,404 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.bytecode.visitor.VisitAcceptor;\n-import serp.util.Strings;\n-\n-/**\n- * The Project represents a working set of classes. It caches parsed\n- * bytecode and is responsible for bytecode class creation. Currently\n- * changes made in one class are <strong>not</strong> reflected in other\n- * classes, though this will be an option in the future.\n- * Bytecode that has been parsed is held in a cache so that retrieving\n- * a class with the same name multiple times always returns the same\n- * {@link BCClass} instance.\n- * A future goal is to eventually have facilities for traversing jars\n- * or directory structures to find classes that meet a given criteria(such\n- * as implementing a given interface, etc) and to perform operations on entire\n- * projects, similar to aspect-oriented programming.\n- *\n- * @author Abe White\n- */\n-public class Project implements VisitAcceptor {\n-\n-    private final String _name;\n-    private final HashMap _cache = new HashMap();\n-    private final NameCache _names = new NameCache();\n-\n-    /**\n-     * Default constructor.\n-     */\n-    public Project() {\n-        this(null);\n-    }\n-\n-    /**\n-     * Construct a named project.\n-     */\n-    public Project(String name) {\n-        _name = name;\n-    }\n-\n-    /**\n-     * Return the project name, or null if unset.\n-     */\n-    public String getName() {\n-        return _name;\n-    }\n-\n-    /**\n-     * Return the name cache, which includes utilities for converting names\n-     * from internal to external form and vice versa.\n-     */\n-    public NameCache getNameCache() {\n-        return _names;\n-    }\n-\n-    /**\n-     * Load a class with the given name.\n-     *\n-     * @see #loadClass(String,ClassLoader)\n-     */\n-    public BCClass loadClass(String name) {\n-        return loadClass(name, null);\n-    }\n-\n-    /**\n-     * Load the bytecode for the class with the given name.\n-     * If a {@link BCClass} with the given name already exists in this project,\n-     * it will be returned. Otherwise, a new {@link BCClass} will be created\n-     * with the given name and returned. If the name represents an existing\n-     * type, the returned instance will contain the parsed bytecode for\n-     * that type. If the name is of a primitive or array type, the returned\n-     * instance will act accordingly.\n-     *\n-     * @param name the name of the class, including package\n-     * @param loader the class loader to use to search for an existing\n-     * class with the given name; if null defaults to the\n-     * context loader of the current thread\n-     * @throws RuntimeException on parse error\n-     */\n-    public BCClass loadClass(String name, ClassLoader loader) {\n-        // convert to proper Class.forName() form\n-        name = _names.getExternalForm(name, false);\n-        BCClass cached = checkCache(name);\n-        if (cached != null)\n-            return cached;\n-\n-        // check for existing type\n-        if (loader == null)\n-            loader = Thread.currentThread().getContextClassLoader();\n-        try {\n-            return loadClass(Strings.toClass(name, loader));\n-        } catch (Exception e) {\n-        }\n-\n-        String componentName = _names.getComponentName(name);\n-        BCClass ret = new BCClass(this);\n-        if (componentName != null)\n-            ret.setState(new ArrayState(name, componentName));\n-        else {\n-            ret.setState(new ObjectState(_names));\n-            ret.setName(name);\n-            ret.setSuperclass(Object.class);\n-        }\n-\n-        cache(name, ret);\n-        return ret;\n-    }\n-\n-    /**\n-     * Load the bytecode for the given class.\n-     * If a {@link BCClass} with the name of the given class already exists in\n-     * this project, it will be returned. Otherwise, the bytecode of the given\n-     * class will be parsed and returned as a new {@link BCClass}. If the\n-     * given class is an array or primitive type, the returned instance will\n-     * act accordingly.\n-     *\n-     * @param type the class to parse\n-     * @throws RuntimeException on parse error\n-     */\n-    public BCClass loadClass(Class type) {\n-        BCClass cached = checkCache(type.getName());\n-        if (cached != null)\n-            return cached;\n-\n-        BCClass ret = new BCClass(this);\n-        if (type.isPrimitive())\n-            ret.setState(new PrimitiveState(type, _names));\n-        else if (type.isArray())\n-            ret.setState(new ArrayState(type.getName(), _names.\n-                getExternalForm(type.getComponentType().getName(), false)));\n-        else {\n-            ret.setState(new ObjectState(_names));\n-            try {\n-                ret.read(type);\n-            } catch (IOException ioe) {\n-                throw new RuntimeException(ioe.toString());\n-            }\n-        }\n-\n-        cache(type.getName(), ret);\n-        return ret;\n-    }\n-\n-    /**\n-     * Load the bytecode from the given class file.\n-     * If this project already contains the class in the given file, it will\n-     * be returned. Otherwise a new {@link BCClass} will be created from the\n-     * given bytecode.\n-     *\n-     * @throws RuntimeException on parse error\n-     */\n-    public BCClass loadClass(File classFile) {\n-        return loadClass(classFile, null);\n-    }\n-\n-    /**\n-     * Load the bytecode from the given class file.\n-     * If this project already contains the class in the given file, it will\n-     * be returned. Otherwise a new {@link BCClass} will be created from the\n-     * given bytecode.\n-     *\n-     * @throws RuntimeException on parse error\n-     */\n-    public BCClass loadClass(File classFile, ClassLoader loader) {\n-        // parse the bytecode from the file\n-        BCClass ret = new BCClass(this);\n-        ret.setState(new ObjectState(_names));\n-        try {\n-            ret.read(classFile, loader);\n-        } catch (IOException ioe) {\n-            throw new RuntimeException(ioe.toString());\n-        }\n-\n-        String name = ret.getName();\n-        BCClass cached = checkCache(name);\n-        if (cached != null)\n-            return cached;\n-\n-        cache(name, ret);\n-        return ret;\n-    }\n-\n-    /**\n-     * Load the bytecode from the given stream.\n-     * If this project already contains the class in the given stream,\n-     * it will be returned. Otherwise a new {@link BCClass} will be created\n-     * from the given bytecode.\n-     *\n-     * @throws RuntimeException on parse error\n-     */\n-    public BCClass loadClass(InputStream in) {\n-        return loadClass(in, null);\n-    }\n-\n-    /**\n-     * Load the bytecode from the given stream.\n-     * If this project already contains the class in the given stream,\n-     * it will be returned. Otherwise a new {@link BCClass} will be created\n-     * from the given bytecode.\n-     *\n-     * @throws RuntimeException on parse error\n-     */\n-    public BCClass loadClass(InputStream in, ClassLoader loader) {\n-        BCClass ret = new BCClass(this);\n-        ret.setState(new ObjectState(_names));\n-        try {\n-            ret.read(in, loader);\n-        } catch (IOException ioe) {\n-            throw new RuntimeException(ioe.toString());\n-        }\n-\n-        String name = ret.getName();\n-        BCClass cached = checkCache(name);\n-        if (cached != null)\n-            return cached;\n-\n-        cache(name, ret);\n-        return ret;\n-    }\n-\n-    /**\n-     * Import the given bytecode from another project. If a {@link BCClass}\n-     * with the same name already exists in this project, it will be returned.\n-     * Otherwise, a new {@link BCClass} will be created from the\n-     * information in the given class.\n-     */\n-    public BCClass loadClass(BCClass bc) {\n-        String name = bc.getName();\n-        BCClass cached = checkCache(name);\n-        if (cached != null)\n-            return cached;\n-\n-        BCClass ret = new BCClass(this);\n-        if (bc.isPrimitive())\n-            ret.setState(new PrimitiveState(bc.getType(), _names));\n-        else if (bc.isArray())\n-            ret.setState(new ArrayState(bc.getName(), bc.getComponentName()));\n-        else {\n-            ret.setState(new ObjectState(_names));\n-            ret.read(bc);\n-        }\n-\n-        cache(name, ret);\n-        return ret;\n-    }\n-\n-    /**\n-     * Clears all classes from this project.\n-     */\n-    public void clear() {\n-        Collection values = _cache.values();\n-        BCClass bc;\n-        for (Iterator itr = values.iterator(); itr.hasNext();) {\n-            bc = (BCClass) itr.next();\n-            itr.remove();\n-            bc.invalidate();\n-        }\n-\n-        _names.clear();\n-    }\n-\n-    /**\n-     * Remove a class from this project. After removal, the result of any\n-     * further operations on the class is undefined.\n-     *\n-     * @return true if the class belonged to this project, false otherwise\n-     */\n-    public boolean removeClass(String type) {\n-        return removeClass(checkCache(type));\n-    }\n-\n-    /**\n-     * Remove a class from this project. After removal, the result of any\n-     * further operations on the class is undefined.\n-     *\n-     * @return true if the class belonged to this project, false otherwise\n-     */\n-    public boolean removeClass(Class type) {\n-        if (type == null)\n-            return false;\n-        return removeClass(checkCache(type.getName()));\n-    }\n-\n-    /**\n-     * Remove a class from this project. After removal, the result of any\n-     * further operations on the class is undefined.\n-     *\n-     * @return true if the class belonged to this project, false otherwise\n-     */\n-    public boolean removeClass(BCClass type) {\n-        if (type == null)\n-            return false;\n-        if (!removeFromCache(type.getName(), type))\n-            return false;\n-\n-        type.invalidate();\n-        return true;\n-    }\n-\n-    /**\n-     * Return all loaded classes in the project.\n-     */\n-    public BCClass[] getClasses() {\n-        Collection values = _cache.values();\n-        return (BCClass[]) values.toArray(new BCClass[values.size()]);\n-    }\n-\n-    /**\n-     * Return true if the project already contains the given class.\n-     */\n-    public boolean containsClass(String type) {\n-        return _cache.containsKey(type);\n-    }\n-\n-    /**\n-     * Return true if the project already contains the given class.\n-     */\n-    public boolean containsClass(Class type) {\n-        return (type == null) ? false : containsClass(type.getName());\n-    }\n-\n-    /**\n-     * Return true if the project already contains the given class.\n-     */\n-    public boolean containsClass(BCClass type) {\n-        return (type == null) ? false : containsClass(type.getName());\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterProject(this);\n-\n-        BCClass[] classes = getClasses();\n-        for (int i = 0; i < classes.length; i++)\n-            classes[i].acceptVisit(visit);\n-\n-        visit.exitProject(this);\n-    }\n-\n-    /**\n-     * Renames the given class within this project. Used internally by\n-     * {@link BCClass} instances when their name is modified.\n-     *\n-     * @throws IllegalStateException if a class with the new name already exists\n-     */\n-    void renameClass(String oldName, String newName, BCClass bc) {\n-        if (oldName.equals(newName))\n-            return;\n-\n-        BCClass cached = (BCClass) checkCache(newName);\n-        if (cached != null)\n-            throw new IllegalStateException(\"A class with name \" + newName\n-                + \" already exists in this project\");\n-\n-        removeFromCache(oldName, bc);\n-        cache(newName, bc);\n-    }\n-\n-    /**\n-     * Check the cache for a loaded type.\n-     */\n-    private BCClass checkCache(String name) {\n-        return (BCClass) _cache.get(name);\n-    }\n-\n-    /**\n-     * Cache a class.\n-     */\n-    private void cache(String name, BCClass bc) {\n-        _cache.put(name, bc);\n-    }\n-\n-    /**\n-     * Remove a cached class.\n-     */\n-    private boolean removeFromCache(String name, BCClass bc) {\n-        BCClass rem = (BCClass) checkCache(name);\n-        if (rem != bc)\n-            return false;\n-\n-        _cache.remove(name);\n-        return true;\n-    }\n-}\n-"},{"sha":"d467e871dd97af1dc8445615cd6585785cedcbcf","filename":"serp/src/main/java/serp/bytecode/PutFieldInstruction.java","status":"removed","additions":0,"deletions":54,"changes":54,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/PutFieldInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/PutFieldInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/PutFieldInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,54 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Stores a value from the stack into a field.\n- *\n- * @author Abe White\n- */\n-public class PutFieldInstruction extends FieldInstruction {\n-\n-    PutFieldInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    public int getLogicalStackChange() {\n-        if (getFieldTypeName() == null)\n-            return 0;\n-        if (getOpcode() == Constants.PUTSTATIC)\n-            return -1;\n-        return -2;\n-    }\n-\n-    public int getStackChange() {\n-        String type = getFieldTypeName();\n-        if (type == null)\n-            return 0;\n-\n-        int stack = -2;\n-        if (long.class.getName().equals(type)\n-            || double.class.getName().equals(type))\n-            stack++;\n-        if (getOpcode() == Constants.PUTSTATIC)\n-            stack++;\n-        return stack;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterPutFieldInstruction(this);\n-        visit.exitPutFieldInstruction(this);\n-    }\n-}"},{"sha":"5421e1178f9d5024daa54928aa268a4a55c86dae","filename":"serp/src/main/java/serp/bytecode/RetInstruction.java","status":"removed","additions":0,"deletions":58,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/RetInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/RetInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/RetInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,58 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * The <code>ret</code> instruction is used in the implementation of finally.\n- *\n- * @author Abe White\n- */\n-public class RetInstruction extends LocalVariableInstruction {\n-\n-    RetInstruction(Code owner) {\n-        super(owner, Constants.RET);\n-    }\n-\n-    int getLength() {\n-        return super.getLength() + 1;\n-    }\n-\n-    public boolean equalsInstruction(Instruction other) {\n-        if (this == other)\n-            return true;\n-        if (!(other instanceof RetInstruction))\n-            return false;\n-        return super.equalsInstruction(other);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterRetInstruction(this);\n-        visit.exitRetInstruction(this);\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        super.read(in);\n-        setLocal(in.readUnsignedByte());\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        super.write(out);\n-        out.writeByte(getLocal());\n-    }\n-}"},{"sha":"2f0c740d0fd7f378465ec4f9b9fab2c520c2ac89","filename":"serp/src/main/java/serp/bytecode/ReturnInstruction.java","status":"removed","additions":0,"deletions":102,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ReturnInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/ReturnInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ReturnInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,102 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Returns a value(or void) from a method.\n- *\n- * @author Abe White\n- */\n-public class ReturnInstruction extends TypedInstruction {\n-\n-    private static final Class[][] _mappings = new Class[][]{\n-        { byte.class, int.class }, { char.class, int.class },\n-        { short.class, int.class }, { boolean.class, int.class }, };\n-\n-    ReturnInstruction(Code owner) {\n-        super(owner);\n-    }\n-\n-    ReturnInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    public String getTypeName() {\n-        switch (getOpcode()) {\n-            case Constants.IRETURN:\n-                return int.class.getName();\n-            case Constants.LRETURN:\n-                return long.class.getName();\n-            case Constants.FRETURN:\n-                return float.class.getName();\n-            case Constants.DRETURN:\n-                return double.class.getName();\n-            case Constants.ARETURN:\n-                return Object.class.getName();\n-            case Constants.RETURN:\n-                return void.class.getName();\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    public TypedInstruction setType(String type) {\n-        type = mapType(type, _mappings, true);\n-        if (type == null)\n-            return (TypedInstruction) setOpcode(Constants.NOP);\n-\n-        switch (type.charAt(0)) {\n-            case 'i':\n-                return (TypedInstruction) setOpcode(Constants.IRETURN);\n-            case 'l':\n-                return (TypedInstruction) setOpcode(Constants.LRETURN);\n-            case 'f':\n-                return (TypedInstruction) setOpcode(Constants.FRETURN);\n-            case 'd':\n-                return (TypedInstruction) setOpcode(Constants.DRETURN);\n-            case 'v':\n-                return (TypedInstruction) setOpcode(Constants.RETURN);\n-            default:\n-                return (TypedInstruction) setOpcode(Constants.ARETURN);\n-        }\n-    }\n-\n-    public int getLogicalStackChange() {\n-        switch (getOpcode()) {\n-            case Constants.NOP:\n-                return 0;\n-            default:\n-                return -1;\n-        }\n-    }\n-\n-    public int getStackChange() {\n-        switch (getOpcode()) {\n-            case Constants.RETURN:\n-            case Constants.NOP:\n-                return 0;\n-            case Constants.LRETURN:\n-            case Constants.DRETURN:\n-                return -2;\n-            default:\n-                return -1;\n-        }\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterReturnInstruction(this);\n-        visit.exitReturnInstruction(this);\n-    }\n-}"},{"sha":"973ffbd1536b1bc0e476c0cf62a6f0e55a617ac8","filename":"serp/src/main/java/serp/bytecode/SourceFile.java","status":"removed","additions":0,"deletions":125,"changes":125,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/SourceFile.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/SourceFile.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/SourceFile.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,125 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.File;\n-import java.io.IOException;\n-\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.bytecode.lowlevel.UTF8Entry;\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Attribute naming the source file for this class.\n- *\n- * @author Abe White\n- */\n-public class SourceFile extends Attribute {\n-\n-    int _sourceFileIndex = 0;\n-\n-    SourceFile(int nameIndex, Attributes owner) {\n-        super(nameIndex, owner);\n-    }\n-\n-    int getLength() {\n-        return 2;\n-    }\n-\n-    /**\n-     * Return the index into the class {@link ConstantPool} of the\n-     * {@link UTF8Entry} naming the source file for this class, or 0 if not set.\n-     */\n-    public int getFileIndex() {\n-        return _sourceFileIndex;\n-    }\n-\n-    /**\n-     * Set the index into the class {@link ConstantPool} of the\n-     * {@link UTF8Entry} naming the source file for this class.\n-     */\n-    public void setFileIndex(int sourceFileIndex) {\n-        if (sourceFileIndex < 0)\n-            sourceFileIndex = 0;\n-        _sourceFileIndex = sourceFileIndex;\n-    }\n-\n-    /**\n-     * Return the name of the source file, or null if not set.\n-     */\n-    public String getFileName() {\n-        if (_sourceFileIndex == 0)\n-            return null;\n-        return ((UTF8Entry) getPool().getEntry(_sourceFileIndex)).getValue();\n-    }\n-\n-    /**\n-     * Return the file object for the source file, or null if not set.\n-     *\n-     * @param dir the directory of the file, or null\n-     */\n-    public File getFile(File dir) {\n-        String name = getFileName();\n-        if (name == null)\n-            return null;\n-        return new File(dir, name);\n-    }\n-\n-    /**\n-     * Set the name of the source file. The name should be the file name\n-     * only; it should not include the path to the file.\n-     */\n-    public void setFile(String name) {\n-        if (name == null)\n-            setFileIndex(0);\n-        else\n-            setFileIndex(getPool().findUTF8Entry(name, true));\n-    }\n-\n-    /**\n-     * Set the source file. Note that only the file name is recorded;\n-     * the path to the file is discarded.\n-     */\n-    public void setFile(File file) {\n-        if (file == null)\n-            setFile((String) null);\n-        else\n-            setFile(file.getName());\n-    }\n-\n-    /**\n-     * Set the file name from the current class name plus the .java extension.\n-     */\n-    public void setFromClassName() {\n-        setFile(((BCClass) getOwner()).getClassName() + \".java\");\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterSourceFile(this);\n-        visit.exitSourceFile(this);\n-    }\n-\n-    void read(Attribute other) {\n-        setFile(((SourceFile) other).getFileName());\n-    }\n-\n-    void read(DataInput in, int length) throws IOException {\n-        setFileIndex(in.readUnsignedShort());\n-    }\n-\n-    void write(DataOutput out, int length) throws IOException {\n-        out.writeShort(getFileIndex());\n-    }\n-}"},{"sha":"737d91f64ccc8f4fe596e7627f0bbd673c6be0bf","filename":"serp/src/main/java/serp/bytecode/StackInstruction.java","status":"removed","additions":0,"deletions":126,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/StackInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/StackInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/StackInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,126 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Represents an instruction that manipulates the stack of the current\n- * frame. Using the {@link #setType} methods is a hint about the type being\n- * manipulated that might cause this instruction to use the wide version\n- * of the opcode it represents(if manipulating a long or double). This\n- * saves the developer from having to decide at compile time whether to\n- * use <code>pop</code> or <code>pop2</code>, etc.\n- *\n- * @author Abe White\n- */\n-public class StackInstruction extends TypedInstruction {\n-\n-    StackInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    public int getLogicalStackChange() {\n-        return getStackChange();\n-    }\n-\n-    public int getStackChange() {\n-        switch (getOpcode()) {\n-            case Constants.POP:\n-                return -1;\n-            case Constants.POP2:\n-                return -2;\n-            case Constants.DUP:\n-            case Constants.DUPX1:\n-            case Constants.DUPX2:\n-                return 1;\n-            case Constants.DUP2:\n-            case Constants.DUP2X1:\n-            case Constants.DUP2X2:\n-                return 2;\n-            default:\n-                return 0;\n-        }\n-    }\n-\n-    /**\n-     * This method will always return null; use {@link #isWide} to determine\n-     * if this is pop2, dup2, etc.\n-     */\n-    public String getTypeName() {\n-        return null;\n-    }\n-\n-    public TypedInstruction setType(String type) {\n-        type = getProject().getNameCache().getExternalForm(type, false);\n-        return setWide(long.class.getName().equals(type)\n-            || double.class.getName().equals(type));\n-    }\n-\n-    /**\n-     * Return whether to use the wide form of the current opcode for\n-     * operations on longs or doubles.\n-     */\n-    public boolean isWide() {\n-        switch (getOpcode()) {\n-            case Constants.POP2:\n-            case Constants.DUP2:\n-            case Constants.DUP2X1:\n-            case Constants.DUP2X2:\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    /**\n-     * Set whether to use the wide form of the current opcode for operations\n-     * on longs or doubles.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public StackInstruction setWide(boolean wide) {\n-        switch (getOpcode()) {\n-            case Constants.POP:\n-                if (wide) setOpcode(Constants.POP2);\n-                break;\n-            case Constants.POP2:\n-                if (!wide) setOpcode(Constants.POP);\n-                break;\n-            case Constants.DUP:\n-                if (wide) setOpcode(Constants.DUP2);\n-                break;\n-            case Constants.DUP2:\n-                if (!wide) setOpcode(Constants.DUP);\n-                break;\n-            case Constants.DUPX1:\n-                if (wide) setOpcode(Constants.DUP2X1);\n-                break;\n-            case Constants.DUP2X1:\n-                if (!wide) setOpcode(Constants.DUPX1);\n-                break;\n-            case Constants.DUPX2:\n-                if (wide) setOpcode(Constants.DUP2X2);\n-                break;\n-            case Constants.DUP2X2:\n-                if (!wide) setOpcode(Constants.DUPX2);\n-                break;\n-        }\n-        return this;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterStackInstruction(this);\n-        visit.exitStackInstruction(this);\n-    }\n-}"},{"sha":"a90f77a5747f48461dc98b38316a6d5c3c03ca9a","filename":"serp/src/main/java/serp/bytecode/State.java","status":"removed","additions":0,"deletions":206,"changes":206,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/State.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/State.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/State.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,206 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.util.Collection;\n-\n-import serp.bytecode.lowlevel.ClassEntry;\n-import serp.bytecode.lowlevel.ConstantPool;\n-\n-/**\n- * The State type is extended by various concrete types to change\n- * the behavior of a {@link BCClass}. All methods in this base\n- * implementation throw an {@link UnsupportedOperationException}\n- *\n- * @author Abe White\n- */\n-class State {\n-\n-    /**\n-     * A singleton instance of this type that can be used to make a\n-     * class invalid.\n-     */\n-    public static final State INVALID = new State();\n-\n-    /**\n-     * Return the magic number of the bytecode class.\n-     */\n-    public int getMagic() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Set the magic number of the bytecode class.\n-     */\n-    public void setMagic(int magic) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return the major number of the bytecode class.\n-     */\n-    public int getMajorVersion() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Set the major version of the bytecode class.\n-     */\n-    public void setMajorVersion(int major) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return the minor number of the bytecode class.\n-     */\n-    public int getMinorVersion() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Set the minor version of the bytecode class.\n-     */\n-    public void setMinorVersion(int minor) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return the access flags of the bytecode class.\n-     */\n-    public int getAccessFlags() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Set the access flags of the bytecode class.\n-     */\n-    public void setAccessFlags(int access) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return the {@link ConstantPool} index of the {@link ClassEntry}\n-     * for this class, or 0 if none.\n-     */\n-    public int getIndex() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Set the {@link ConstantPool} index of the {@link ClassEntry}\n-     * for this class.\n-     */\n-    public void setIndex(int index) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return the {@link ConstantPool} index of the {@link ClassEntry}\n-     * for the superclass of this class, or 0 if none.\n-     */\n-    public int getSuperclassIndex() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Set the {@link ConstantPool} index of the {@link ClassEntry}\n-     * for the superclass of this class. Throws\n-     * {@link UnsupportedOperationException} by default.\n-     */\n-    public void setSuperclassIndex(int index) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return the {@link ConstantPool} indexes of the {@link ClassEntry}s\n-     * for the indexes of this class, or empty collection if none. If the\n-     * state does not support changing the interfaces, the returned\n-     * collection should be immutable.\n-     */\n-    public Collection getInterfacesHolder() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return the {@link BCField}s of this class, or empty collection if none.\n-     * If the state does not support changing the fields, the returned\n-     * collection should be immutable.\n-     */\n-    public Collection getFieldsHolder() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return the {@link BCMethod}s of this class, or empty collection if none.\n-     * If the state does not support changing the methods, the returned\n-     * collection should be immutable.\n-     */\n-    public Collection getMethodsHolder() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return the {@link Attribute}s of this class, or empty collection if\n-     * none. If the state does not support changing the attributes, the\n-     * returned collection should be immutable.\n-     */\n-    public Collection getAttributesHolder() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return the constant pool of the class.\n-     */\n-    public ConstantPool getPool() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return the name of the class. The name should be in a form suitable\n-     * for a {@link Class#forName} call.\n-     */\n-    public String getName() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return the name of the superclass. The name should be in a form\n-     * suitable for a {@link Class#forName} call, or null if none.\n-     */\n-    public String getSuperclassName() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return the name of the component type of this array, or null if not\n-     * an array. The name should be in a form suitable for a\n-     * {@link Class#forName} call.\n-     */\n-    public String getComponentName() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return true if this class is a primitive.\n-     */\n-    public boolean isPrimitive() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Return true if this class is an array.\n-     */\n-    public boolean isArray() {\n-        throw new UnsupportedOperationException();\n-    }\n-}"},{"sha":"ab430b03db3d4981e62590a81af13d0ec467e19b","filename":"serp/src/main/java/serp/bytecode/StoreInstruction.java","status":"removed","additions":0,"deletions":250,"changes":250,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/StoreInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/StoreInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/StoreInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,250 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * An instruction to store a value from a local variable onto the stack.\n- *\n- * @author Abe White\n- */\n-public class StoreInstruction extends LocalVariableInstruction {\n-\n-    private static final Class[][] _mappings = new Class[][]{\n-        { byte.class, int.class }, { boolean.class, int.class },\n-        { char.class, int.class }, { short.class, int.class },\n-        { void.class, int.class }, };\n-\n-    String _type = null;\n-\n-    StoreInstruction(Code owner) {\n-        super(owner);\n-    }\n-\n-    StoreInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    int getLength() {\n-        switch (getOpcode()) {\n-            case Constants.ISTORE:\n-            case Constants.LSTORE:\n-            case Constants.FSTORE:\n-            case Constants.DSTORE:\n-            case Constants.ASTORE:\n-                return super.getLength() + 1;\n-            default:\n-                return super.getLength();\n-        }\n-    }\n-\n-    public int getLogicalStackChange() {\n-        switch (getOpcode()) {\n-            case Constants.NOP:\n-                return 0;\n-            default:\n-                return -1;\n-        }\n-    }\n-\n-    public int getStackChange() {\n-        switch (getOpcode()) {\n-            case Constants.LSTORE:\n-            case Constants.LSTORE0:\n-            case Constants.LSTORE1:\n-            case Constants.LSTORE2:\n-            case Constants.LSTORE3:\n-            case Constants.DSTORE:\n-            case Constants.DSTORE0:\n-            case Constants.DSTORE1:\n-            case Constants.DSTORE2:\n-            case Constants.DSTORE3:\n-                return -2;\n-            case Constants.NOP:\n-                return 0;\n-            default:\n-                return -1;\n-        }\n-    }\n-\n-    public String getTypeName() {\n-        switch (getOpcode()) {\n-            case Constants.ISTORE:\n-            case Constants.ISTORE0:\n-            case Constants.ISTORE1:\n-            case Constants.ISTORE2:\n-            case Constants.ISTORE3:\n-                return int.class.getName();\n-            case Constants.LSTORE:\n-            case Constants.LSTORE0:\n-            case Constants.LSTORE1:\n-            case Constants.LSTORE2:\n-            case Constants.LSTORE3:\n-                return long.class.getName();\n-            case Constants.FSTORE:\n-            case Constants.FSTORE0:\n-            case Constants.FSTORE1:\n-            case Constants.FSTORE2:\n-            case Constants.FSTORE3:\n-                return float.class.getName();\n-            case Constants.DSTORE:\n-            case Constants.DSTORE0:\n-            case Constants.DSTORE1:\n-            case Constants.DSTORE2:\n-            case Constants.DSTORE3:\n-                return double.class.getName();\n-            case Constants.ASTORE:\n-            case Constants.ASTORE0:\n-            case Constants.ASTORE1:\n-            case Constants.ASTORE2:\n-            case Constants.ASTORE3:\n-                return Object.class.getName();\n-            default:\n-                return _type;\n-        }\n-    }\n-\n-    public TypedInstruction setType(String type) {\n-        type = mapType(type, _mappings, true);\n-        int local = getLocal();\n-\n-        // if an invalid type or local, revert to nop\n-        if (type == null || local < 0) {\n-            _type = type;\n-            return (TypedInstruction) setOpcode(Constants.NOP);\n-        }\n-\n-        // valid opcode, unset saved type\n-        _type = null;\n-\n-        switch (type.charAt(0)) {\n-            case 'i':\n-                return (TypedInstruction) setOpcode(\n-                    (local > 3) ? Constants.ISTORE\n-                        : Constants.ISTORE0 + local);\n-            case 'l':\n-                return (TypedInstruction) setOpcode(\n-                    (local > 3) ? Constants.LSTORE\n-                        : Constants.LSTORE0 + local);\n-            case 'f':\n-                return (TypedInstruction) setOpcode(\n-                    (local > 3) ? Constants.FSTORE\n-                        : Constants.FSTORE0 + local);\n-            case 'd':\n-                return (TypedInstruction) setOpcode(\n-                    (local > 3) ? Constants.DSTORE\n-                        : Constants.DSTORE0 + local);\n-            default:\n-                return (TypedInstruction) setOpcode(\n-                    (local > 3) ? Constants.ASTORE\n-                        : Constants.ASTORE0 + local);\n-        }\n-    }\n-\n-    /**\n-     * StoreInstructions are equal if the type they reference the same\n-     * type and locals index or if either is unset.\n-     */\n-    public boolean equalsInstruction(Instruction other) {\n-        if (other == this)\n-            return true;\n-        if (!super.equalsInstruction(other))\n-            return false;\n-\n-        String type = getTypeName();\n-        String otherType = ((StoreInstruction) other).getTypeName();\n-        return type == null || otherType == null || type.equals(otherType);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterStoreInstruction(this);\n-        visit.exitStoreInstruction(this);\n-    }\n-\n-    void read(Instruction orig) {\n-        super.read(orig);\n-\n-        StoreInstruction ins = (StoreInstruction) orig;\n-        _type = ins._type;\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        super.read(in);\n-\n-        switch (getOpcode()) {\n-            case Constants.ISTORE:\n-            case Constants.LSTORE:\n-            case Constants.FSTORE:\n-            case Constants.DSTORE:\n-            case Constants.ASTORE:\n-                setLocal(in.readUnsignedByte());\n-                break;\n-        }\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        super.write(out);\n-\n-        switch (getOpcode()) {\n-            case Constants.ISTORE:\n-            case Constants.LSTORE:\n-            case Constants.FSTORE:\n-            case Constants.DSTORE:\n-            case Constants.ASTORE:\n-                out.writeByte(getLocal());\n-        }\n-    }\n-\n-    void calculateOpcode() {\n-        // taken care of when setting type\n-        setType(getTypeName());\n-    }\n-\n-    void calculateLocal() {\n-        switch (getOpcode()) {\n-            case Constants.ISTORE0:\n-            case Constants.LSTORE0:\n-            case Constants.FSTORE0:\n-            case Constants.DSTORE0:\n-            case Constants.ASTORE0:\n-                setLocal(0);\n-                break;\n-            case Constants.ISTORE1:\n-            case Constants.LSTORE1:\n-            case Constants.FSTORE1:\n-            case Constants.DSTORE1:\n-            case Constants.ASTORE1:\n-                setLocal(1);\n-                break;\n-            case Constants.ISTORE2:\n-            case Constants.LSTORE2:\n-            case Constants.FSTORE2:\n-            case Constants.DSTORE2:\n-            case Constants.ASTORE2:\n-                setLocal(2);\n-                break;\n-            case Constants.ISTORE3:\n-            case Constants.LSTORE3:\n-            case Constants.FSTORE3:\n-            case Constants.DSTORE3:\n-            case Constants.ASTORE3:\n-                setLocal(3);\n-                break;\n-        }\n-    }\n-}"},{"sha":"ad21c7b4b4de0cd2d656f4f8d83a8dcf65bfed8a","filename":"serp/src/main/java/serp/bytecode/SwitchInstruction.java","status":"removed","additions":0,"deletions":226,"changes":226,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/SwitchInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/SwitchInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/SwitchInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,226 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.IOException;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-/**\n- * Contains functionality common to the different switch types\n- * (TableSwitch and LookupSwitch).\n- *\n- * @author Eric Lindauer\n- */\n-public abstract class SwitchInstruction extends JumpInstruction {\n-\n-    private List _cases = new LinkedList();\n-\n-    public SwitchInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    /**\n-     * Returns the current byte offsets for the different\n-     * switch cases in this Instruction.\n-     */\n-    public int[] getOffsets() {\n-        int bi = getByteIndex();\n-        int[] offsets = new int [_cases.size()];\n-        for (int i = 0; i < offsets.length; i++)\n-            offsets[i] = ((InstructionPtrStrategy) _cases.get(i)).\n-                getByteIndex() - bi;\n-        return offsets;\n-    }\n-\n-    /**\n-     * Sets the offsets for the instructions representing the different\n-     * switch statement cases. WARNING: these offsets will not be changed\n-     * in the event that the code is modified following this call. It is\n-     * typically a good idea to follow this call with a call to updateTargets\n-     * as soon as the instructions at the given offsets are valid, at which\n-     * point the Instructions themselves will be used as the targets and the\n-     * offsets will be updated as expected.\n-     */\n-    public void setOffsets(int[] offsets) {\n-        int bi = getByteIndex();\n-        _cases.clear();\n-        for (int i = 0; i < offsets.length; i++) {\n-            InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n-            next.setByteIndex(offsets[i] + bi);\n-            _cases.add(next);\n-        }\n-    }\n-\n-    public int countTargets() {\n-        return _cases.size();\n-    }\n-\n-    int getLength() {\n-        // don't call super.getLength(), cause JumpInstruction will return\n-        // value assuming this is an 'if' or 'goto' instruction\n-        int length = 1;\n-\n-        // make the first byte of the 'default' a multiple of 4 from the\n-        // start of the method\n-        int byteIndex = getByteIndex() + 1;\n-        for (; byteIndex % 4 != 0; byteIndex++, length++) ;\n-\n-        return length;\n-    }\n-\n-    /**\n-     * Synonymous with {@link #getTarget}.\n-     */\n-    public Instruction getDefaultTarget() {\n-        return getTarget();\n-    }\n-\n-    /**\n-     * Synonymous with {@link #getOffset}.\n-     */\n-    public int getDefaultOffset() {\n-        return getOffset();\n-    }\n-\n-    /**\n-     * Synonymous with {@link #setOffset}.\n-     */\n-    public SwitchInstruction setDefaultOffset(int offset) {\n-        setOffset(offset);\n-        return this;\n-    }\n-\n-    /**\n-     * Synonymous with {@link #setTarget}.\n-     */\n-    public SwitchInstruction setDefaultTarget(Instruction ins) {\n-        return (SwitchInstruction) setTarget(ins);\n-    }\n-\n-    /**\n-     * Return the targets for this switch, or empty array if not set.\n-     */\n-    public Instruction[] getTargets() {\n-        Instruction[] result = new Instruction [_cases.size()];\n-        for (int i = 0; i < _cases.size(); i++)\n-            result[i] = ((InstructionPtrStrategy) _cases.get(i)).\n-                getTargetInstruction();\n-        return result;\n-    }\n-\n-    /**\n-     * Set the jump points for this switch.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public SwitchInstruction setTargets(Instruction[] targets) {\n-        _cases.clear();\n-        if (targets != null)\n-            for (int i = 0; i < targets.length; i++)\n-                addTarget(targets[i]);\n-        return this;\n-    }\n-\n-    /**\n-     * Add a target to this switch.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public SwitchInstruction addTarget(Instruction target) {\n-        _cases.add(new InstructionPtrStrategy(this, target));\n-        return this;\n-    }\n-\n-    public int getLogicalStackChange() {\n-        return getStackChange();\n-    }\n-\n-    public int getStackChange() {\n-        return -1;\n-    }\n-\n-    public void updateTargets() {\n-        super.updateTargets();\n-        for (Iterator itr = _cases.iterator(); itr.hasNext();)\n-            ((InstructionPtrStrategy) itr.next()).updateTargets();\n-    }\n-\n-    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n-        super.replaceTarget(oldTarget, newTarget);\n-        for (Iterator itr = _cases.iterator(); itr.hasNext();)\n-            ((InstructionPtrStrategy) itr.next()).replaceTarget\n-                (oldTarget, newTarget);\n-    }\n-\n-    void read(Instruction orig) {\n-        super.read(orig);\n-\n-        SwitchInstruction ins = (SwitchInstruction) orig;\n-        _cases.clear();\n-        for (Iterator itr = ins._cases.iterator(); itr.hasNext();) {\n-            InstructionPtrStrategy incoming = (InstructionPtrStrategy)\n-                itr.next();\n-            InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n-            next.setByteIndex(incoming.getByteIndex());\n-            _cases.add(next);\n-        }\n-    }\n-\n-    void clearTargets() {\n-        _cases.clear();\n-    }\n-\n-    void readTarget(DataInput in) throws IOException {\n-        InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n-        next.setByteIndex(getByteIndex() + in.readInt());\n-        _cases.add(next);\n-    }\n-\n-    /**\n-     * Set the match-jumppt pairs for this switch.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public SwitchInstruction setCases(int[] matches, Instruction[] targets) {\n-        setMatches(matches);\n-        setTargets(targets);\n-        return this;\n-    }\n-\n-    public SwitchInstruction setMatches(int[] matches) {\n-        clearMatches();\n-        for (int i = 0; i < matches.length; i++)\n-            addMatch(matches[i]);\n-        return this;\n-    }\n-\n-    /**\n-     * Add a case to this switch.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public SwitchInstruction addCase(int match, Instruction target) {\n-        addMatch(match);\n-        addTarget(target);\n-        return this;\n-    }\n-\n-    public abstract SwitchInstruction addMatch(int match);\n-\n-    public abstract int[] getMatches();\n-\n-    abstract void clearMatches();\n-}"},{"sha":"3baea0e19adc4aa9b2c767b9533a9fe941cb50ee","filename":"serp/src/main/java/serp/bytecode/Synthetic.java","status":"removed","additions":0,"deletions":33,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Synthetic.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Synthetic.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Synthetic.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,33 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Attribute marking a member as synthetic, or not present in the class\n- * source code.\n- *\n- * @author Abe White\n- */\n-public class Synthetic extends Attribute {\n-\n-    Synthetic(int nameIndex, Attributes owner) {\n-        super(nameIndex, owner);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterSynthetic(this);\n-        visit.exitSynthetic(this);\n-    }\n-}"},{"sha":"8f29d6dd7e2e88a2364930cc383336be692a73f0","filename":"serp/src/main/java/serp/bytecode/TableSwitchInstruction.java","status":"removed","additions":0,"deletions":252,"changes":252,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/TableSwitchInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/TableSwitchInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/TableSwitchInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,252 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * The <code>tableswitch</code> instruction.\n- *\n- * @author Abe White\n- */\n-public class TableSwitchInstruction extends JumpInstruction {\n-\n-    // case info\n-    private int _low = 0;\n-    private int _high = 0;\n-    private List _cases = new LinkedList();\n-\n-    TableSwitchInstruction(Code owner) {\n-        super(owner, Constants.TABLESWITCH);\n-    }\n-\n-    /**\n-     * Returns the current byte offsets for the different\n-     * switch cases in this Instruction.\n-     */\n-    public int[] getOffsets() {\n-        int bi = getByteIndex();\n-        int[] offsets = new int[_cases.size()];\n-        for (int i = 0; i < _cases.size(); i++)\n-            offsets[i] = ((InstructionPtrStrategy) _cases.get(i)).\n-                getByteIndex() - bi;\n-        return offsets;\n-    }\n-\n-    /**\n-     * Sets the offsets for the instructions representing the different\n-     * switch statement cases. WARNING: these offsets will not be changed\n-     * in the event that the code is modified following this call. It is\n-     * typically a good idea to follow this call with a call to updateTargets\n-     * as soon as the instructions at the given offsets are valid, at which\n-     * point the Instructions themselves will be used as the targets and the\n-     * offsets will be updated as expected.\n-     */\n-    public void setOffsets(int[] offsets) {\n-        int bi = getByteIndex();\n-        _cases.clear();\n-        for (int i = 0; i < offsets.length; i++) {\n-            InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n-            next.setByteIndex(offsets[i] + bi);\n-            _cases.add(next);\n-        }\n-    }\n-\n-    int getLength() {\n-        // don't call super\n-        int length = 1;\n-\n-        // make the first byte of the 'default' a multiple of 4 from the\n-        // start of the method\n-        int byteIndex = getByteIndex() + 1;\n-        for (; byteIndex % 4 != 0; byteIndex++, length++) ;\n-\n-        // default, low, high\n-        length += 12;\n-\n-        // offsets\n-        length += 4 * _cases.size();\n-\n-        return length;\n-    }\n-\n-    /**\n-     * Synonymous with {@link #getTarget}.\n-     */\n-    public Instruction getDefaultTarget() {\n-        return getTarget();\n-    }\n-\n-    /**\n-     * Synonymous with {@link #setTarget}.\n-     */\n-    public TableSwitchInstruction setDefaultTarget(Instruction ins) {\n-        return (TableSwitchInstruction) setTarget(ins);\n-    }\n-\n-    /**\n-     * Synonymous with {@link #getOffset}.\n-     */\n-    public int getDefaultOffset() {\n-        return getOffset();\n-    }\n-\n-    /**\n-     * Synonymous with {@link #setOffset}.\n-     */\n-    public TableSwitchInstruction setDefaultOffset(int offset) {\n-        setOffset(offset);\n-        return this;\n-    }\n-\n-    public int getLow() {\n-        return _low;\n-    }\n-\n-    public TableSwitchInstruction setLow(int low) {\n-        _low = low;\n-        return this;\n-    }\n-\n-    public int getHigh() {\n-        return _high;\n-    }\n-\n-    public TableSwitchInstruction setHigh(int high) {\n-        _high = high;\n-        return this;\n-    }\n-\n-    /**\n-     * Return the targets for this switch, or empty array if not set.\n-     */\n-    public Instruction[] getTargets() {\n-        Instruction[] result = new Instruction [_cases.size()];\n-        for (int i = 0; i < _cases.size(); i++)\n-            result[i] = ((InstructionPtrStrategy) _cases.get(i)).\n-                getTargetInstruction();\n-        return result;\n-    }\n-\n-    /**\n-     * Set the jump points for this switch.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public TableSwitchInstruction setTargets(Instruction[] targets) {\n-        _cases.clear();\n-        if (targets != null)\n-            for (int i = 0; i < targets.length; i++)\n-                addTarget(targets[i]);\n-        return this;\n-    }\n-\n-    /**\n-     * Add a target to this switch.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public TableSwitchInstruction addTarget(Instruction target) {\n-        _cases.add(new InstructionPtrStrategy(this, target));\n-        return this;\n-    }\n-\n-    public int getStackChange() {\n-        return -1;\n-    }\n-\n-    private Instruction findTarget(int jumpByteIndex, List inss) {\n-        Instruction ins;\n-        for (Iterator itr = inss.iterator(); itr.hasNext();) {\n-            ins = (Instruction) itr.next();\n-            if (ins.getByteIndex() == jumpByteIndex)\n-                return ins;\n-        }\n-        return null;\n-    }\n-\n-    public void updateTargets() {\n-        super.updateTargets();\n-        for (Iterator itr = _cases.iterator(); itr.hasNext();)\n-            ((InstructionPtrStrategy) itr.next()).updateTargets();\n-    }\n-\n-    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n-        super.replaceTarget(oldTarget, newTarget);\n-        for (Iterator itr = _cases.iterator(); itr.hasNext();)\n-            ((InstructionPtrStrategy) itr.next()).replaceTarget\n-                (oldTarget, newTarget);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterTableSwitchInstruction(this);\n-        visit.exitTableSwitchInstruction(this);\n-    }\n-\n-    void read(Instruction orig) {\n-        super.read(orig);\n-\n-        TableSwitchInstruction ins = (TableSwitchInstruction) orig;\n-        setLow(ins.getLow());\n-        setHigh(ins.getHigh());\n-        for (Iterator itr = ins._cases.iterator(); itr.hasNext();) {\n-            InstructionPtrStrategy incoming = (InstructionPtrStrategy)\n-                itr.next();\n-            InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n-            next.setByteIndex(incoming.getByteIndex());\n-            _cases.add(next);\n-        }\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        // don't call super\n-\n-        int bi = getByteIndex();\n-        for (int byteIndex = bi + 1; byteIndex % 4 != 0; byteIndex++)\n-            in.readByte();\n-\n-        setOffset(in.readInt());\n-        setLow(in.readInt());\n-        setHigh(in.readInt());\n-\n-        _cases.clear();\n-        for (int i = 0; i < (_high - _low + 1); i++) {\n-            InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n-            next.setByteIndex(bi + in.readInt());\n-            _cases.add(next);\n-        }\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        // don't call super\n-\n-        int bi = getByteIndex();\n-        for (int byteIndex = bi + 1; byteIndex % 4 != 0; byteIndex++)\n-            out.writeByte(0);\n-\n-        out.writeInt(getOffset());\n-        out.writeInt(getLow());\n-        out.writeInt(getHigh());\n-\n-        for (Iterator itr = _cases.iterator(); itr.hasNext();)\n-            out.writeInt(((InstructionPtrStrategy) itr.next()).\n-                getByteIndex() - bi);\n-    }\n-}"},{"sha":"b453b70ed6d35fc7e2f2ab548f98dab22b367631","filename":"serp/src/main/java/serp/bytecode/TypedInstruction.java","status":"removed","additions":0,"deletions":136,"changes":136,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/TypedInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/TypedInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/TypedInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,136 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-import serp.util.Strings;\n-\n-/**\n- * Any typed instruction.\n- *\n- * @author Abe White\n- */\n-public abstract class TypedInstruction extends Instruction {\n-\n-    private static final Set _opcodeTypes = new HashSet();\n-\n-    static {\n-        _opcodeTypes.add(int.class.getName());\n-        _opcodeTypes.add(long.class.getName());\n-        _opcodeTypes.add(float.class.getName());\n-        _opcodeTypes.add(double.class.getName());\n-        _opcodeTypes.add(Object.class.getName());\n-        _opcodeTypes.add(byte.class.getName());\n-        _opcodeTypes.add(char.class.getName());\n-        _opcodeTypes.add(short.class.getName());\n-        _opcodeTypes.add(boolean.class.getName());\n-        _opcodeTypes.add(void.class.getName());\n-    }\n-\n-    TypedInstruction(Code owner) {\n-        super(owner);\n-    }\n-\n-    TypedInstruction(Code owner, int opcode) {\n-        super(owner, opcode);\n-    }\n-\n-    /**\n-     * Return the type for the given name. Takes into account\n-     * the given mappings and the demote flag.\n-     *\n-     * @param mappings mappings of one type to another; for example,\n-     * array instruction treat booleans as ints, so\n-     * to reflect that there should be an index x of the\n-     * array such that mappings[x][0] = boolean.class and\n-     * mappings[x][1] = int.class; may be null if no special mappings are needed\n-     * @param demote if true, all object types will be demoted to Object.class\n-     */\n-    String mapType(String type, Class[][] mappings, boolean demote) {\n-        if (type == null)\n-            return null;\n-\n-        type = getProject().getNameCache().getExternalForm(type, false);\n-        if (!_opcodeTypes.contains(type) && demote)\n-            type = Object.class.getName();\n-\n-        if (mappings != null)\n-            for (int i = 0; i < mappings.length; i++)\n-                if (mappings[i][0].getName().equals(type))\n-                    type = mappings[i][1].getName();\n-\n-        return type;\n-    }\n-\n-    /**\n-     * Return the type name for this instruction.\n-     * If the type has not been set, this method will return null.\n-     */\n-    public abstract String getTypeName();\n-\n-    /**\n-     * Return the type for this instruction.\n-     * If the type has not been set, this method will return null.\n-     */\n-    public Class getType() {\n-        String type = getTypeName();\n-        if (type == null)\n-            return null;\n-        return Strings.toClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Return the type for this instruction.\n-     * If the type has not been set, this method will return null.\n-     */\n-    public BCClass getTypeBC() {\n-        String type = getTypeName();\n-        if (type == null)\n-            return null;\n-        return getProject().loadClass(type, getClassLoader());\n-    }\n-\n-    /**\n-     * Set the type of this instruction. Types that have no direct\n-     * support will be converted accordingly.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public abstract TypedInstruction setType(String type);\n-\n-    /**\n-     * Set the type of this instruction. Types that have no direct\n-     * support will be converted accordingly.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public TypedInstruction setType(Class type) {\n-        if (type == null)\n-            return setType((String) null);\n-        return setType(type.getName());\n-    }\n-\n-    /**\n-     * Set the type of this instruction. Types that have no direct\n-     * support will be converted accordingly.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public TypedInstruction setType(BCClass type) {\n-        if (type == null)\n-            return setType((String) null);\n-        return setType(type.getName());\n-    }\n-}"},{"sha":"8c69a8cba118b6e5e56f6801f9706c3879863c22","filename":"serp/src/main/java/serp/bytecode/UnknownAttribute.java","status":"removed","additions":0,"deletions":72,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/UnknownAttribute.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/UnknownAttribute.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/UnknownAttribute.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,72 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * An unrecognized attribute; class files are allowed to contain\n- * attributes that are not recognized, and the JVM must ignore them.\n- *\n- * @author Abe White\n- */\n-public class UnknownAttribute extends Attribute {\n-\n-    private byte[] _value = new byte[0];\n-\n-    UnknownAttribute(int nameIndex, Attributes owner) {\n-        super(nameIndex, owner);\n-    }\n-\n-    int getLength() {\n-        return _value.length;\n-    }\n-\n-    /**\n-     * The value is of unknown content, so it is stored as a byte array.\n-     */\n-    public byte[] getValue() {\n-        return _value;\n-    }\n-\n-    /**\n-     * The value is of unknown content, so it is stored as a byte array.\n-     */\n-    public void setValue(byte[] value) {\n-        if (value == null)\n-            value = new byte[0];\n-        _value = value;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterUnknownAttribute(this);\n-        visit.exitUnknownAttribute(this);\n-    }\n-\n-    void read(Attribute other) {\n-        setValue(((UnknownAttribute) other).getValue());\n-    }\n-\n-    void read(DataInput in, int length) throws IOException {\n-        _value = new byte[length];\n-        in.readFully(_value);\n-    }\n-\n-    void write(DataOutput out, int length) throws IOException {\n-        out.write(_value);\n-    }\n-}"},{"sha":"35676396b404543208ce3b42f0e34e525b60cbc7","filename":"serp/src/main/java/serp/bytecode/WideInstruction.java","status":"removed","additions":0,"deletions":385,"changes":385,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/WideInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/WideInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/WideInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,385 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * The <code>wide</code> instruction, which is used to allow other\n- * instructions to index values beyond what they can normally index baed\n- * on the length of their arguments.\n- *\n- * @author Abe White\n- */\n-public class WideInstruction extends LocalVariableInstruction {\n-\n-    private static final Class[][] _mappings = new Class[][]{\n-        { byte.class, int.class }, { boolean.class, int.class },\n-        { char.class, int.class }, { short.class, int.class },\n-        { void.class, int.class }, };\n-\n-    private int _ins = Constants.NOP;\n-    private int _inc = -1;\n-\n-    WideInstruction(Code owner) {\n-        super(owner, Constants.WIDE);\n-    }\n-\n-    int getLength() {\n-        // opcode, ins, index\n-        int length = super.getLength() + 1 + 2;\n-\n-        // increment\n-        if (getInstruction() == Constants.IINC)\n-            length += 2;\n-\n-        return length;\n-    }\n-\n-    public int getStackChange() {\n-        switch (getInstruction()) {\n-            case Constants.ILOAD:\n-            case Constants.FLOAD:\n-            case Constants.ALOAD:\n-                return 1;\n-            case Constants.LLOAD:\n-            case Constants.DLOAD:\n-                return 2;\n-            case Constants.ISTORE:\n-            case Constants.FSTORE:\n-            case Constants.ASTORE:\n-                return -1;\n-            case Constants.LSTORE:\n-            case Constants.DSTORE:\n-                return -2;\n-            default:\n-                return 0;\n-        }\n-    }\n-\n-    public int getLogicalStackChange() {\n-        switch (getInstruction()) {\n-            case Constants.ILOAD:\n-            case Constants.FLOAD:\n-            case Constants.ALOAD:\n-            case Constants.LLOAD:\n-            case Constants.DLOAD:\n-                return 1;\n-            case Constants.ISTORE:\n-            case Constants.FSTORE:\n-            case Constants.ASTORE:\n-            case Constants.LSTORE:\n-            case Constants.DSTORE:\n-                return -1;\n-            default:\n-                return 0;\n-        }\n-    }\n-\n-    public String getTypeName() {\n-        switch (getInstruction()) {\n-            case Constants.ILOAD:\n-            case Constants.ISTORE:\n-                return int.class.getName();\n-            case Constants.LLOAD:\n-            case Constants.LSTORE:\n-                return long.class.getName();\n-            case Constants.FLOAD:\n-            case Constants.FSTORE:\n-                return float.class.getName();\n-            case Constants.DLOAD:\n-            case Constants.DSTORE:\n-                return double.class.getName();\n-            case Constants.ALOAD:\n-            case Constants.ASTORE:\n-                return Object.class.getName();\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    public TypedInstruction setType(String type) {\n-        type = mapType(type, _mappings, true);\n-\n-        switch (getInstruction()) {\n-            case Constants.ILOAD:\n-            case Constants.LLOAD:\n-            case Constants.FLOAD:\n-            case Constants.DLOAD:\n-            case Constants.ALOAD:\n-                if (type == null)\n-                    throw new IllegalStateException();\n-                switch (type.charAt(0)) {\n-                    case 'i':\n-                        return (TypedInstruction) setInstruction(\n-                            Constants.ILOAD);\n-                    case 'l':\n-                        return (TypedInstruction) setInstruction(\n-                            Constants.LLOAD);\n-                    case 'f':\n-                        return (TypedInstruction) setInstruction(\n-                            Constants.FLOAD);\n-                    case 'd':\n-                        return (TypedInstruction) setInstruction(\n-                            Constants.DLOAD);\n-                    default:\n-                        return (TypedInstruction) setInstruction(\n-                            Constants.ALOAD);\n-                }\n-            case Constants.ISTORE:\n-            case Constants.LSTORE:\n-            case Constants.FSTORE:\n-            case Constants.DSTORE:\n-            case Constants.ASTORE:\n-                if (type == null)\n-                    throw new IllegalStateException();\n-                switch (type.charAt(0)) {\n-                    case 'i':\n-                        return (TypedInstruction) setInstruction(\n-                            Constants.ISTORE);\n-                    case 'l':\n-                        return (TypedInstruction) setInstruction(\n-                            Constants.LSTORE);\n-                    case 'f':\n-                        return (TypedInstruction) setInstruction(\n-                            Constants.FSTORE);\n-                    case 'd':\n-                        return (TypedInstruction) setInstruction(\n-                            Constants.DSTORE);\n-                    default:\n-                        return (TypedInstruction) setInstruction(\n-                            Constants.ASTORE);\n-                }\n-            default:\n-                if (type != null)\n-                    throw new IllegalStateException(\"Augmented instruction not \"\n-                        + \"typed\");\n-                return this;\n-        }\n-    }\n-\n-    /**\n-     * Return the opcode of the instruction to modify; this will return one\n-     * of the constants defined in {@link Constants}.\n-     */\n-    public int getInstruction() {\n-        return _ins;\n-    }\n-\n-    /**\n-     * Set the type of instruction this wide instruction modifies.\n-     */\n-    public WideInstruction setInstruction(Instruction ins) {\n-        if (ins == null)\n-            return setInstruction(Constants.NOP);\n-\n-        setInstruction(ins.getOpcode());\n-        if (ins instanceof IIncInstruction)\n-            setIncrement(((IIncInstruction) ins).getIncrement());\n-\n-        return this;\n-    }\n-\n-    /**\n-     * Set the type of instruction this wide instruction modifies.\n-     */\n-    public WideInstruction setInstruction(int opcode) {\n-        _ins = opcode;\n-        return this;\n-    }\n-\n-    /**\n-     * Set the type of instruction this wide instruction modifies.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public WideInstruction iinc() {\n-        return setInstruction(Constants.IINC);\n-    }\n-\n-    /**\n-     * Set the type of instruction this wide instruction modifies.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public WideInstruction ret() {\n-        return setInstruction(Constants.RET);\n-    }\n-\n-    /**\n-     * Set the type of instruction this wide instruction modifies.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public WideInstruction iload() {\n-        return setInstruction(Constants.ILOAD);\n-    }\n-\n-    /**\n-     * Set the type of instruction this wide instruction modifies.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public WideInstruction fload() {\n-        return setInstruction(Constants.FLOAD);\n-    }\n-\n-    /**\n-     * Set the type of instruction this wide instruction modifies.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public WideInstruction aload() {\n-        return setInstruction(Constants.ALOAD);\n-    }\n-\n-    /**\n-     * Set the type of instruction this wide instruction modifies.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public WideInstruction lload() {\n-        return setInstruction(Constants.LLOAD);\n-    }\n-\n-    /**\n-     * Set the type of instruction this wide instruction modifies.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public WideInstruction dload() {\n-        return setInstruction(Constants.DLOAD);\n-    }\n-\n-    /**\n-     * Set the type of instruction this wide instruction modifies.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public WideInstruction istore() {\n-        return setInstruction(Constants.ISTORE);\n-    }\n-\n-    /**\n-     * Set the type of instruction this wide instruction modifies.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public WideInstruction fstore() {\n-        return setInstruction(Constants.FSTORE);\n-    }\n-\n-    /**\n-     * Set the type of instruction this wide instruction modifies.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public WideInstruction astore() {\n-        return setInstruction(Constants.ASTORE);\n-    }\n-\n-    /**\n-     * Set the type of instruction this wide instruction modifies.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public WideInstruction lstore() {\n-        return setInstruction(Constants.LSTORE);\n-    }\n-\n-    /**\n-     * Set the type of instruction this wide instruction modifies.\n-     *\n-     * @return this instruction, for method chaining\n-     */\n-    public WideInstruction dstore() {\n-        return setInstruction(Constants.DSTORE);\n-    }\n-\n-    /**\n-     * Return the increment for this instruction if it augments IINC, or -1\n-     * if unset.\n-     */\n-    public int getIncrement() {\n-        return _inc;\n-    }\n-\n-    /**\n-     * Set the increment on this instruction if it augments IINC.\n-     *\n-     * @return this Instruction, for method chaining\n-     */\n-    public WideInstruction setIncrement(int val) {\n-        _inc = val;\n-        return this;\n-    }\n-\n-    /**\n-     * WideInstructions are equal if the instruction they augment is the same\n-     * or unset.\n-     */\n-    public boolean equalsInstruction(Instruction other) {\n-        if (other == this)\n-            return true;\n-        if (!super.equalsInstruction(other))\n-            return false;\n-        if (!(other instanceof WideInstruction))\n-            return false;\n-\n-        WideInstruction ins = (WideInstruction) other;\n-\n-        int code = getInstruction();\n-        int otherCode = ins.getInstruction();\n-        if (code != otherCode)\n-            return false;\n-\n-        if (code == Constants.IINC) {\n-            int inc = getIncrement();\n-            int otherInc = ins.getIncrement();\n-            return inc == -1 || otherInc == -1 || inc == otherInc;\n-        }\n-        return true;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterWideInstruction(this);\n-        visit.exitWideInstruction(this);\n-    }\n-\n-    void read(Instruction orig) {\n-        super.read(orig);\n-        setInstruction(((WideInstruction) orig).getInstruction());\n-    }\n-\n-    void read(DataInput in) throws IOException {\n-        super.read(in);\n-\n-        setInstruction(in.readUnsignedByte());\n-        setLocal(in.readUnsignedShort());\n-        if (getInstruction() == Constants.IINC)\n-            setIncrement(in.readUnsignedShort());\n-    }\n-\n-    void write(DataOutput out) throws IOException {\n-        super.write(out);\n-\n-        out.writeByte(getInstruction());\n-        out.writeShort(getLocal());\n-        if (getInstruction() == Constants.IINC)\n-            out.writeShort(getIncrement());\n-    }\n-}"},{"sha":"2fef199b2fc0847d63b5dd01d8836207110d0222","filename":"serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java","status":"removed","additions":0,"deletions":100,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,100 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * A constant pool entry describing a class.\n- * Class entries are used to refer to the current class, the superclass,\n- * implemented interfaces, etc. Each class entry contains the constant pool\n- * index of the {@link UTF8Entry} that stores the class name, which is\n- * represented in internal form.\n- *\n- * @author Abe White\n- */\n-public class ClassEntry extends Entry implements ConstantEntry {\n-\n-    private int _nameIndex = 0;\n-\n-    /**\n-     * Default constructor.\n-     */\n-    public ClassEntry() {\n-    }\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param nameIndex the constant pool index of the {@link UTF8Entry}\n-     * containing the class name\n-     */\n-    public ClassEntry(int nameIndex) {\n-        _nameIndex = nameIndex;\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link UTF8Entry}\n-     * containing the class name. Defaults to 0.\n-     */\n-    public int getNameIndex() {\n-        return _nameIndex;\n-    }\n-\n-    /**\n-     * Set the constant pool index of the {@link UTF8Entry}\n-     * containing the class name.\n-     */\n-    public void setNameIndex(int nameIndex) {\n-        Object key = beforeModify();\n-        _nameIndex = nameIndex;\n-        afterModify(key);\n-    }\n-\n-    /**\n-     * Return the referenced {@link UTF8Entry}. This method can only\n-     * be run for entries that have been added to a constant pool.\n-     */\n-    public UTF8Entry getNameEntry() {\n-        return (UTF8Entry) getPool().getEntry(_nameIndex);\n-    }\n-\n-    public int getType() {\n-        return Entry.CLASS;\n-    }\n-\n-    public Object getConstant() {\n-        return getNameEntry().getValue();\n-    }\n-\n-    public void setConstant(Object value) {\n-        getNameEntry().setConstant(value);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterClassEntry(this);\n-        visit.exitClassEntry(this);\n-    }\n-\n-    void readData(DataInput in) throws IOException {\n-        _nameIndex = in.readUnsignedShort();\n-    }\n-\n-    void writeData(DataOutput out) throws IOException {\n-        out.writeShort(_nameIndex);\n-    }\n-}"},{"sha":"083eb9638c1accd149ddc3b6f287e2963a3458fe","filename":"serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java","status":"removed","additions":0,"deletions":112,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,112 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-/**\n- * Base class for field, method, and interface method constant pool\n- * entries. All complex entries reference the {@link ClassEntry} of the\n- * class that owns the entity and a {@link NameAndTypeEntry} describing\n- * the entity.\n- *\n- * @author Abe White\n- */\n-public abstract class ComplexEntry extends Entry {\n-\n-    private int _classIndex = 0;\n-    private int _nameAndTypeIndex = 0;\n-\n-    /**\n-     * Default constructor.\n-     */\n-    public ComplexEntry() {\n-    }\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param classIndex the constant pool index of the\n-     * {@link ClassEntry} describing the owner of this entity\n-     * @param nameAndTypeIndex the constant pool index of the\n-     * {@link NameAndTypeEntry} describing this entity\n-     */\n-    public ComplexEntry(int classIndex, int nameAndTypeIndex) {\n-        _classIndex = classIndex;\n-        _nameAndTypeIndex = nameAndTypeIndex;\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link ClassEntry} describing\n-     * the owning class of this entity. Defaults to 0.\n-     */\n-    public int getClassIndex() {\n-        return _classIndex;\n-    }\n-\n-    /**\n-     * Set the constant pool index of the {@link ClassEntry} describing\n-     * the owning class of this entity.\n-     */\n-    public void setClassIndex(int classIndex) {\n-        Object key = beforeModify();\n-        _classIndex = classIndex;\n-        afterModify(key);\n-    }\n-\n-    /**\n-     * Return the referenced {@link ClassEntry}. This method can only\n-     * be run for entries that have been added to a constant pool.\n-     */\n-    public ClassEntry getClassEntry() {\n-        return (ClassEntry) getPool().getEntry(_classIndex);\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link NameAndTypeEntry}\n-     * describing this entity.\n-     */\n-    public int getNameAndTypeIndex() {\n-        return _nameAndTypeIndex;\n-    }\n-\n-    /**\n-     * Set the constant pool index of the {@link NameAndTypeEntry}\n-     * describing this entity.\n-     */\n-    public void setNameAndTypeIndex(int nameAndTypeIndex) {\n-        Object key = beforeModify();\n-        _nameAndTypeIndex = nameAndTypeIndex;\n-        afterModify(key);\n-    }\n-\n-    /**\n-     * Return the referenced {@link NameAndTypeEntry}. This method can only\n-     * be run for entries that have been added to a constant pool.\n-     */\n-    public NameAndTypeEntry getNameAndTypeEntry() {\n-        return (NameAndTypeEntry) getPool().getEntry(_nameAndTypeIndex);\n-    }\n-\n-    void readData(DataInput in) throws IOException {\n-        _classIndex = in.readUnsignedShort();\n-        _nameAndTypeIndex = in.readUnsignedShort();\n-    }\n-\n-    void writeData(DataOutput out) throws IOException {\n-        out.writeShort(_classIndex);\n-        out.writeShort(_nameAndTypeIndex);\n-    }\n-}"},{"sha":"95bc86861f4f1434976363797dbc8dcde9d1e269","filename":"serp/src/main/java/serp/bytecode/lowlevel/ConstantEntry.java","status":"removed","additions":0,"deletions":32,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ConstantEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ConstantEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ConstantEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,32 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-/**\n- * Interface implemented by entries representing constant values. Allows\n- * generic access the constant value regardless of type.\n- *\n- * @author Abe White\n- */\n-public interface ConstantEntry {\n-\n-    /**\n-     * Return the value of the constant held by this entry.\n-     */\n-    public Object getConstant();\n-\n-    /**\n-     * Set the value of the constant held by this entry.\n-     */\n-    public void setConstant(Object value);\n-}"},{"sha":"617196ab4f996e64e4cfb20f87a6810b12b2384d","filename":"serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java","status":"removed","additions":0,"deletions":625,"changes":625,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,625 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.bytecode.visitor.VisitAcceptor;\n-import serp.util.Numbers;\n-\n-/**\n- * A bytecode constant pool, containing entries for all strings,\n- * constants, classes, etc referenced in the class structure and method\n- * opcodes. In keeping with the low-level bytecode representation, all pool\n- * indexes are 1-based and {@link LongEntry}s and {@link DoubleEntry}s each\n- * occupy two indexes in the pool.\n- *\n- * @author Abe White\n- */\n-public class ConstantPool implements VisitAcceptor {\n-\n-    private List _entries = new ArrayList(50);\n-    private Map _lookup = new HashMap(50);\n-\n-    /**\n-     * Default constructor.\n-     */\n-    public ConstantPool() {\n-    }\n-\n-    /**\n-     * Return all the entries in the pool.\n-     */\n-    public Entry[] getEntries() {\n-        List entries = new ArrayList(_entries.size());\n-        Entry entry;\n-        for (Iterator itr = _entries.iterator(); itr.hasNext();) {\n-            entry = (Entry) itr.next();\n-            if (entry != null)\n-                entries.add(entry);\n-        }\n-        return (Entry[]) entries.toArray(new Entry[entries.size()]);\n-    }\n-\n-    /**\n-     * Retrieve the entry at the specified 1-based index.\n-     *\n-     * @throws IndexOutOfBoundsException if index is invalid,\n-     * including the case that it points to the second slot of a\n-     * long or double entry\n-     */\n-    public Entry getEntry(int index) {\n-        Entry entry = (Entry) _entries.get(index - 1);\n-        if (entry == null)\n-            throw new IndexOutOfBoundsException(\"index = \" + index);\n-        return entry;\n-    }\n-\n-    /**\n-     * Return the index of the given entry, or 0 if it is not in the pool.\n-     */\n-    public int indexOf(Entry entry) {\n-        if (entry == null || entry.getPool() != this)\n-            return 0;\n-        return entry.getIndex();\n-    }\n-\n-    /**\n-     * Add an entry to the pool.\n-     *\n-     * @return the index at which the entry was added\n-     */\n-    public int addEntry(Entry entry) {\n-        if (entry.getPool() != this)\n-            addEntry(getKey(entry), entry);\n-        return entry.getIndex();\n-    }\n-\n-    /**\n-     * Add an entry to the pool using the given key.\n-     */\n-    private int addEntry(Object key, Entry entry) {\n-        entry.setPool(this);\n-        _entries.add(entry);\n-        entry.setIndex(_entries.size());\n-\n-        _lookup.put(key, entry);\n-        if (entry.isWide())\n-            _entries.add(null);\n-        return entry.getIndex();\n-    }\n-\n-    /**\n-     * Remove the given entry from the pool.\n-     *\n-     * @return false if the entry is not in the pool, true otherwise\n-     */\n-    public boolean removeEntry(Entry entry) {\n-        if (entry == null || entry.getPool() != this)\n-            return false;\n-\n-        int index = entry.getIndex() - 1;\n-        entry.setPool(null);\n-        entry.setIndex(0);\n-\n-        _entries.remove(index);\n-        if (entry.isWide())\n-            _entries.remove(index);\n-        _lookup.remove(getKey(entry));\n-\n-        // rehash all the entries after the removed one with their new index\n-        Object key;\n-        for (int i = index; i < _entries.size(); i++) {\n-            entry = (Entry) _entries.get(i);\n-            if (entry != null) {\n-                key = getKey(entry);\n-                _lookup.remove(key);\n-                entry.setIndex(i + 1);\n-                _lookup.put(key, entry);\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Clear all entries from the pool.\n-     */\n-    public void clear() {\n-        Entry entry;\n-        for (Iterator itr = _entries.iterator(); itr.hasNext();) {\n-            entry = (Entry) itr.next();\n-            if (entry != null) {\n-                entry.setPool(null);\n-                entry.setIndex(0);\n-            }\n-        }\n-\n-        _entries.clear();\n-        _lookup.clear();\n-    }\n-\n-    /**\n-     * Return the number of places occupied in the pool, including the fact\n-     * that long and double entries occupy two places.\n-     */\n-    public int size() {\n-        return _entries.size();\n-    }\n-\n-    /**\n-     * Return the index of the {@link UTF8Entry} with the given value, or\n-     * 0 if it does not exist.\n-     *\n-     * @param add if true, the entry will be added if it does not\n-     * already exist, and the new entry's index returned\n-     */\n-    public int findUTF8Entry(String value, boolean add) {\n-        if (value == null) {\n-            if (add)\n-                throw new NullPointerException(\"value = null\");\n-            return 0;\n-        }\n-\n-        int index = find(value);\n-        if (!add || index > 0)\n-            return index;\n-        return addEntry(value, new UTF8Entry(value));\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link DoubleEntry} for the given\n-     * value, or 0 if it does not exist.\n-     *\n-     * @param value the value to find\n-     * @param add if true, the entry will be added if it does not\n-     * already exist, and the new entry's index returned\n-     */\n-    public int findDoubleEntry(double value, boolean add) {\n-        Double key = new Double(value);\n-        int index = find(key);\n-        if (!add || index > 0)\n-            return index;\n-        return addEntry(key, new DoubleEntry(value));\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link FloatEntry} for the given\n-     * value, or 0 if it does not exist.\n-     *\n-     * @param value the value to find\n-     * @param add if true, the entry will be added if it does not\n-     * already exist, and the new entry's index returned\n-     */\n-    public int findFloatEntry(float value, boolean add) {\n-        Float key = new Float(value);\n-        int index = find(key);\n-        if (!add || index > 0)\n-            return index;\n-        return addEntry(key, new FloatEntry(value));\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link IntEntry} for the given\n-     * value, or 0 if it does not exist.\n-     *\n-     * @param value the value to find\n-     * @param add if true, the entry will be added if it does not\n-     * already exist, and the new entry's index returned\n-     */\n-    public int findIntEntry(int value, boolean add) {\n-        Integer key = Numbers.valueOf(value);\n-        int index = find(key);\n-        if (!add || index > 0)\n-            return index;\n-        return addEntry(key, new IntEntry(value));\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link LongEntry} for the given\n-     * value, or 0 if it does not exist.\n-     *\n-     * @param value the value to find\n-     * @param add if true, the entry will be added if it does not\n-     * already exist, and the new entry's index returned\n-     */\n-    public int findLongEntry(long value, boolean add) {\n-        Long key = Numbers.valueOf(value);\n-        int index = find(key);\n-        if (!add || index > 0)\n-            return index;\n-        return addEntry(key, new LongEntry(value));\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link StringEntry} for the given\n-     * string value, or 0 if it does not exist.\n-     *\n-     * @param value the value to find\n-     * @param add if true, the entry will be added if it does not\n-     * already exist, and the new entry's index returned\n-     */\n-    public int findStringEntry(String value, boolean add) {\n-        int valueIndex = findUTF8Entry(value, add);\n-        if (valueIndex == 0)\n-            return 0;\n-\n-        StringKey key = new StringKey(valueIndex);\n-        int index = find(key);\n-        if (!add || index > 0)\n-            return index;\n-        return addEntry(key, new StringEntry(valueIndex));\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link ClassEntry} for the given\n-     * class name, or 0 if it does not exist.\n-     *\n-     * @param name the class name in internal form\n-     * @param add if true, the entry will be added if it does not\n-     * already exist, and the new entry's index returned\n-     */\n-    public int findClassEntry(String name, boolean add) {\n-        int nameIndex = findUTF8Entry(name, add);\n-        if (nameIndex == 0)\n-            return 0;\n-\n-        ClassKey key = new ClassKey(nameIndex);\n-        int index = find(key);\n-        if (!add || index > 0)\n-            return index;\n-        return addEntry(key, new ClassEntry(nameIndex));\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link NameAndTypeEntry} for the\n-     * given name and descriptor, or 0 if it does not exist.\n-     *\n-     * @param name the name of the entity\n-     * @param desc the descriptor of the entity in internal form\n-     * @param add if true, the entry will be added if it does not\n-     * already exist, and the new entry's index returned\n-     */\n-    public int findNameAndTypeEntry(String name, String desc, boolean add) {\n-        int nameIndex = findUTF8Entry(name, add);\n-        if (nameIndex == 0)\n-            return 0;\n-        int descIndex = findUTF8Entry(desc, add);\n-        if (descIndex == 0)\n-            return 0;\n-\n-        NameAndTypeKey key = new NameAndTypeKey(nameIndex, descIndex);\n-        int index = find(key);\n-        if (!add || index > 0)\n-            return index;\n-        return addEntry(key, new NameAndTypeEntry(nameIndex, descIndex));\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link FieldEntry} for the\n-     * given name, descriptor, and owner class name.\n-     *\n-     * @param owner the name of the field's owning class in internal form\n-     * @param name the name of the field\n-     * @param desc the descriptor of the field in internal form\n-     * @param add if true, the entry will be added if it does not\n-     * already exist, and the new entry's index returned\n-     */\n-    public int findFieldEntry(String owner, String name, String desc,\n-        boolean add) {\n-        return findComplexEntry(owner, name, desc, Entry.FIELD, add);\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link MethodEntry} for the\n-     * given name, descriptor, and owner class name.\n-     *\n-     * @param owner the name of the method's owning class in internal form\n-     * @param name the name of the method\n-     * @param desc the descriptor of the method in internal form\n-     * @param add if true, the entry will be added if it does not\n-     * already exist, and the new entry's index returned\n-     */\n-    public int findMethodEntry(String owner, String name, String desc,\n-        boolean add) {\n-        return findComplexEntry(owner, name, desc, Entry.METHOD, add);\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link InterfaceMethodEntry} for\n-     * the given name, descriptor, and owner class name.\n-     *\n-     * @param owner the name of the method's owning class in internal form\n-     * @param name the name of the method\n-     * @param desc the descriptor of the method in internal form\n-     * @param add if true, the entry will be added if it does not\n-     * already exist, and the new entry's index returned\n-     */\n-    public int findInterfaceMethodEntry(String owner, String name, String desc,\n-        boolean add) {\n-        return findComplexEntry(owner, name, desc, Entry.INTERFACEMETHOD, add);\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link ComplexEntry} for the\n-     * given name, descriptor, and owner class name.\n-     *\n-     * @param owner the name of the owning class in internal form\n-     * @param name the name of the entity\n-     * @param desc the descriptor of the entity in internal form\n-     * @param type the type of entry: field, method, interface method\n-     * @param add if true, the entry will be added if it does not\n-     * already exist, and the new entry's index returned\n-     */\n-    private int findComplexEntry(String owner, String name, String desc,\n-        int type, boolean add) {\n-        int classIndex = findClassEntry(owner, add);\n-        if (classIndex == 0)\n-            return 0;\n-        int descIndex = findNameAndTypeEntry(name, desc, add);\n-        if (descIndex == 0)\n-            return 0;\n-\n-        Object key = null;\n-        switch (type) {\n-            case Entry.FIELD:\n-                key = new FieldKey(classIndex, descIndex);\n-                break;\n-            case Entry.METHOD:\n-                key = new MethodKey(classIndex, descIndex);\n-                break;\n-            case Entry.INTERFACEMETHOD:\n-                key = new InterfaceMethodKey(classIndex, descIndex);\n-                break;\n-        }\n-        int index = find(key);\n-        if (!add || index > 0)\n-            return index;\n-\n-        Entry entry = null;\n-        switch (type) {\n-            case Entry.FIELD:\n-                entry = new FieldEntry(classIndex, descIndex);\n-                break;\n-            case Entry.METHOD:\n-                entry = new MethodEntry(classIndex, descIndex);\n-                break;\n-            case Entry.INTERFACEMETHOD:\n-                entry = new InterfaceMethodEntry(classIndex, descIndex);\n-                break;\n-        }\n-        return addEntry(key, entry);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterConstantPool(this);\n-\n-        Entry entry;\n-        for (Iterator itr = _entries.iterator(); itr.hasNext();) {\n-            entry = (Entry) itr.next();\n-            if (entry == null)\n-                continue;\n-\n-            visit.enterEntry(entry);\n-            entry.acceptVisit(visit);\n-            visit.exitEntry(entry);\n-        }\n-\n-        visit.exitConstantPool(this);\n-    }\n-\n-    /**\n-     * Fill the constant pool from the given bytecode stream.\n-     */\n-    public void read(DataInput in) throws IOException {\n-        clear();\n-\n-        int entryCount = in.readUnsignedShort();\n-        Entry entry;\n-        for (int i = 1; i < entryCount; i++) {\n-            entry = Entry.read(in);\n-            addEntry(entry);\n-\n-            if (entry.isWide())\n-                i++;\n-        }\n-    }\n-\n-    /**\n-     * Write the constant pool to the given bytecode stream.\n-     */\n-    public void write(DataOutput out) throws IOException {\n-        out.writeShort(_entries.size() + 1);\n-\n-        Entry entry;\n-        for (Iterator itr = _entries.iterator(); itr.hasNext();) {\n-            entry = (Entry) itr.next();\n-            if (entry != null)\n-                Entry.write(entry, out);\n-        }\n-    }\n-\n-    /**\n-     * Called by constant pool entries when they are mutated.\n-     */\n-    void modifyEntry(Object origKey, Entry entry) {\n-        _lookup.remove(origKey);\n-        _lookup.put(getKey(entry), entry);\n-    }\n-\n-    /**\n-     * Returns the constant pool index of the entry with the given key.\n-     */\n-    private int find(Object key) {\n-        Entry entry = (Entry) _lookup.get(key);\n-        if (entry == null)\n-            return 0;\n-        return entry.getIndex();\n-    }\n-\n-    /**\n-     * Return the hash key used for the specified entry.\n-     */\n-    static Object getKey(Entry entry) {\n-        switch (entry.getType()) {\n-            case Entry.CLASS:\n-                return new ClassKey(((ClassEntry) entry).getNameIndex());\n-            case Entry.FIELD:\n-                FieldEntry fe = (FieldEntry) entry;\n-                return new FieldKey(fe.getClassIndex(),\n-                    fe.getNameAndTypeIndex());\n-            case Entry.METHOD:\n-                MethodEntry me = (MethodEntry) entry;\n-                return new MethodKey(me.getClassIndex(),\n-                    me.getNameAndTypeIndex());\n-            case Entry.INTERFACEMETHOD:\n-                InterfaceMethodEntry ime = (InterfaceMethodEntry) entry;\n-                return new InterfaceMethodKey(ime.getClassIndex(),\n-                    ime.getNameAndTypeIndex());\n-            case Entry.STRING:\n-                return new StringKey(((StringEntry) entry).getStringIndex());\n-            case Entry.INT:\n-            case Entry.FLOAT:\n-            case Entry.LONG:\n-            case Entry.DOUBLE:\n-            case Entry.UTF8:\n-                return ((ConstantEntry) entry).getConstant();\n-            case Entry.NAMEANDTYPE:\n-                NameAndTypeEntry nte = (NameAndTypeEntry) entry;\n-                return new NameAndTypeKey(nte.getNameIndex(),\n-                    nte.getDescriptorIndex());\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    /**\n-     * Base class key for entries with one ptr to another entry.\n-     */\n-    private static abstract class PtrKey {\n-\n-        private final int _index;\n-\n-        public PtrKey(int index) {\n-            _index = index;\n-        }\n-\n-        public int hashCode() {\n-            return _index;\n-        }\n-\n-        public boolean equals(Object other) {\n-            if (other == this)\n-                return true;\n-            if (other.getClass() != getClass())\n-                return false;\n-            return ((PtrKey) other)._index == _index;\n-        }\n-    }\n-\n-    /**\n-     * Key for string entries.\n-     */\n-    private static class StringKey extends PtrKey {\n-\n-        public StringKey(int index) {\n-            super(index);\n-        }\n-    }\n-\n-    /**\n-     * Key for class entries.\n-     */\n-    private static class ClassKey extends PtrKey {\n-\n-        public ClassKey(int index) {\n-            super(index);\n-        }\n-    }\n-\n-    /**\n-     * Base class key for entries with two ptr to other entries.\n-     */\n-    private static abstract class DoublePtrKey {\n-\n-        private final int _index1;\n-        private final int _index2;\n-\n-        public DoublePtrKey(int index1, int index2) {\n-            _index1 = index1;\n-            _index2 = index2;\n-        }\n-\n-        public int hashCode() {\n-            return _index1 ^ _index2;\n-        }\n-\n-        public boolean equals(Object other) {\n-            if (other == this)\n-                return true;\n-            if (other.getClass() != getClass())\n-                return false;\n-\n-            DoublePtrKey key = (DoublePtrKey) other;\n-            return key._index1 == _index1 && key._index2 == _index2;\n-        }\n-    }\n-\n-    /**\n-     * Key for name and type entries.\n-     */\n-    private static class NameAndTypeKey extends DoublePtrKey {\n-\n-        public NameAndTypeKey(int index1, int index2) {\n-            super(index1, index2);\n-        }\n-    }\n-\n-    /**\n-     * Key for field entries.\n-     */\n-    private static class FieldKey extends DoublePtrKey {\n-\n-        public FieldKey(int index1, int index2) {\n-            super(index1, index2);\n-        }\n-    }\n-\n-    /**\n-     * Key for method entries.\n-     */\n-    private static class MethodKey extends DoublePtrKey {\n-\n-        public MethodKey(int index1, int index2) {\n-            super(index1, index2);\n-        }\n-    }\n-\n-    /**\n-     * Key for interface method entries.\n-     */\n-    private static class InterfaceMethodKey extends DoublePtrKey {\n-\n-        public InterfaceMethodKey(int index1, int index2) {\n-            super(index1, index2);\n-        }\n-    }\n-}\n-"},{"sha":"9f986646196be8fc8e9b91e93e7aee450a759df6","filename":"serp/src/main/java/serp/bytecode/lowlevel/ConstantPoolTable.java","status":"removed","additions":0,"deletions":191,"changes":191,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ConstantPoolTable.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ConstantPoolTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ConstantPoolTable.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,191 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.UnsupportedEncodingException;\n-\n-/**\n- * Efficient representation of the constant pool as a table. This class\n- * can be used to parse out bits of information from bytecode without\n- * instantiating a full {@link serp.bytecode.BCClass}.\n- *\n- * @author Abe White\n- */\n-public class ConstantPoolTable {\n-\n-    private byte[] _bytecode = null;\n-    private int[] _table = null;\n-    private int _idx = 0;\n-\n-    /**\n-     * Allows static computation of the byte index after the constant\n-     * pool without caching constant pool information.\n-     */\n-    public static int getEndIndex(byte[] b) {\n-        return parse(b, null);\n-    }\n-\n-    /**\n-     * Parse class bytecode, returning end index of pool.\n-     */\n-    private static int parse(byte[] b, int[] table) {\n-        // each entry is the index in the byte array of the data for a const\n-        // pool entry\n-        int entries = (table == null) ? readUnsignedShort(b, 8) : table.length;\n-        int idx = 10;\n-        for (int i = 1; i < entries; i++) {\n-            if (table != null)\n-                table[i] = idx + 1; // skip entry type\n-            switch (b[idx]) {\n-                case 1: // utf8\n-                    idx += 3 + readUnsignedShort(b, idx + 1);\n-                    break;\n-                case 3: // integer\n-                case 4: // float\n-                case 9: // field\n-                case 10: // method\n-                case 11: // interface method\n-                case 12: // name\n-                    idx += 5;\n-                    break;\n-                case 5: // long\n-                case 6: // double\n-                    idx += 9;\n-                    i++; // wide entry\n-                    break;\n-                default:\n-                    idx += 3;\n-            }\n-        }\n-        return idx;\n-    }\n-\n-    /**\n-     * Read a byte value at the given offset into the given bytecode.\n-     */\n-    public static int readByte(byte[] b, int idx) {\n-        return b[idx] & 0xFF;\n-    }\n-\n-    /**\n-     * Read an unsigned short value at the given offset into the given bytecode.\n-     */\n-    public static int readUnsignedShort(byte[] b, int idx) {\n-        return (readByte(b, idx) << 8) | readByte(b, idx + 1);\n-    }\n-\n-    /**\n-     * Read an int value at the given offset into the given bytecode.\n-     */\n-    public static int readInt(byte[] b, int idx) {\n-        return (readByte(b, idx) << 24) | (readByte(b, idx + 1) << 16)\n-            | (readByte(b, idx + 2) << 8) | readByte(b, idx + 3);\n-    }\n-\n-    /**\n-     * Read a long value at the given offset into the given bytecode.\n-     */\n-    public static long readLong(byte[] b, int idx) {\n-        return (readInt(b, idx) << 32) | readInt(b, idx + 4);\n-    }\n-\n-    /**\n-     * Read a UTF-8 string value at the given offset into the given bytecode.\n-     */\n-    public static String readString(byte[] b, int idx) {\n-        int len = readUnsignedShort(b, idx);\n-        try {\n-            return new String(b, idx + 2, len, \"UTF-8\");\n-        } catch (UnsupportedEncodingException uee) {\n-            throw new ClassFormatError(uee.toString());\n-        }\n-    }\n-\n-    /**\n-     * Constructor; supply class bytecode.\n-     */\n-    public ConstantPoolTable(byte[] b) {\n-        _bytecode = b;\n-        _table = new int[readUnsignedShort(b, 8)];\n-        _idx = parse(b, _table);\n-    }\n-\n-    /**\n-     * Constructor; supply input stream to bytecode.\n-     */\n-    public ConstantPoolTable(InputStream in) throws IOException {\n-        this(toByteArray(in));\n-    }\n-\n-    /**\n-     * Read the contents of the given stream.\n-     */\n-    private static byte[] toByteArray(InputStream in) throws IOException {\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        byte[] buf = new byte[1024];\n-        for (int r; (r = in.read(buf)) != -1; bout.write(buf, 0, r)) ;\n-        return bout.toByteArray();\n-    }\n-\n-    /**\n-     * Return the index into the bytecode of the end of the constant pool.\n-     */\n-    public int getEndIndex() {\n-        return _idx;\n-    }\n-\n-    /**\n-     * Return the given table entry.\n-     */\n-    public int get(int idx) {\n-        return _table[idx];\n-    }\n-\n-    /**\n-     * Read a byte value at the given offset.\n-     */\n-    public int readByte(int idx) {\n-        return readByte(_bytecode, idx);\n-    }\n-\n-    /**\n-     * Read an unsigned short value at the given offset.\n-     */\n-    public int readUnsignedShort(int idx) {\n-        return readUnsignedShort(_bytecode, idx);\n-    }\n-\n-    /**\n-     * Read an int value at the given offset.\n-     */\n-    public int readInt(int idx) {\n-        return readInt(_bytecode, idx);\n-    }\n-\n-    /**\n-     * Read a long value at the given offset.\n-     */\n-    public long readLong(int idx) {\n-        return readLong(_bytecode, idx);\n-    }\n-\n-    /**\n-     * Read a UTF-8 string value at the given offset.\n-     */\n-    public String readString(int idx) {\n-        return readString(_bytecode, idx);\n-    }\n-}"},{"sha":"8ce8119cdce008a2bed8d21665f9488e8eaf6d6c","filename":"serp/src/main/java/serp/bytecode/lowlevel/DoubleEntry.java","status":"removed","additions":0,"deletions":89,"changes":89,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/DoubleEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/DoubleEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/DoubleEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,89 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * A constant double value in the constant pool.\n- *\n- * @author Abe White\n- */\n-public class DoubleEntry extends Entry implements ConstantEntry {\n-\n-    private double _value = 0.0;\n-\n-    /**\n-     * Default constructor.\n-     */\n-    public DoubleEntry() {\n-    }\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param value the constant double value of this entry\n-     */\n-    public DoubleEntry(double value) {\n-        _value = value;\n-    }\n-\n-    public boolean isWide() {\n-        return true;\n-    }\n-\n-    public int getType() {\n-        return Entry.DOUBLE;\n-    }\n-\n-    /**\n-     * Return the value of the constant.\n-     */\n-    public double getValue() {\n-        return _value;\n-    }\n-\n-    /**\n-     * Set the value of the constant.\n-     */\n-    public void setValue(double value) {\n-        Object key = beforeModify();\n-        _value = value;\n-        afterModify(key);\n-    }\n-\n-    public Object getConstant() {\n-        return new Double(getValue());\n-    }\n-\n-    public void setConstant(Object value) {\n-        setValue(((Number) value).doubleValue());\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterDoubleEntry(this);\n-        visit.exitDoubleEntry(this);\n-    }\n-\n-    void readData(DataInput in) throws IOException {\n-        _value = in.readDouble();\n-    }\n-\n-    void writeData(DataOutput out) throws IOException {\n-        out.writeDouble(_value);\n-    }\n-}"},{"sha":"a1f97e4f6cd17b39009b557da4e0df4064fe5bdc","filename":"serp/src/main/java/serp/bytecode/lowlevel/Entry.java","status":"removed","additions":0,"deletions":168,"changes":168,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/Entry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/Entry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/Entry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,168 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.VisitAcceptor;\n-\n-/**\n- * Base type for all constant pool entries. Entries should generally be\n- * considered immutable; modifying an entry directly can have dire\n- * consequences, and often renders the resulting class file invalid.\n- * Entries cannot be shared among constant pools.\n- *\n- * @author Abe White\n- */\n-public abstract class Entry implements VisitAcceptor {\n-\n-    public static final int UTF8 = 1;\n-    public static final int INT = 3;\n-    public static final int FLOAT = 4;\n-    public static final int LONG = 5;\n-    public static final int DOUBLE = 6;\n-    public static final int CLASS = 7;\n-    public static final int STRING = 8;\n-    public static final int FIELD = 9;\n-    public static final int METHOD = 10;\n-    public static final int INTERFACEMETHOD = 11;\n-    public static final int NAMEANDTYPE = 12;\n-\n-    private ConstantPool _pool = null;\n-    private int _index = 0;\n-\n-    /**\n-     * Read a single entry from the given bytecode stream and returns it.\n-     */\n-    public static Entry read(DataInput in) throws IOException {\n-        Entry entry = create(in.readUnsignedByte());\n-        entry.readData(in);\n-        return entry;\n-    }\n-\n-    /**\n-     * Write the given entry to the given bytecode stream.\n-     */\n-    public static void write(Entry entry, DataOutput out) throws IOException {\n-        out.writeByte(entry.getType());\n-        entry.writeData(out);\n-    }\n-\n-    /**\n-     * Create an entry based on its type code.\n-     */\n-    public static Entry create(int type) {\n-        switch (type) {\n-            case CLASS:\n-                return new ClassEntry();\n-            case FIELD:\n-                return new FieldEntry();\n-            case METHOD:\n-                return new MethodEntry();\n-            case INTERFACEMETHOD:\n-                return new InterfaceMethodEntry();\n-            case STRING:\n-                return new StringEntry();\n-            case INT:\n-                return new IntEntry();\n-            case FLOAT:\n-                return new FloatEntry();\n-            case LONG:\n-                return new LongEntry();\n-            case DOUBLE:\n-                return new DoubleEntry();\n-            case NAMEANDTYPE:\n-                return new NameAndTypeEntry();\n-            case UTF8:\n-                return new UTF8Entry();\n-            default:\n-                throw new IllegalArgumentException(\"type = \" + type);\n-        }\n-    }\n-\n-    /**\n-     * Return the type code for this entry type.\n-     */\n-    public abstract int getType();\n-\n-    /**\n-     * Return true if this is a wide entry -- i.e. if it takes up two\n-     * places in the constant pool. Returns false by default.\n-     */\n-    public boolean isWide() {\n-        return false;\n-    }\n-\n-    /**\n-     * Returns the constant pool containing this entry, or null if none.\n-     */\n-    public ConstantPool getPool() {\n-        return _pool;\n-    }\n-\n-    /**\n-     * Returns the index of the entry in the owning constant pool, or 0.\n-     */\n-    public int getIndex() {\n-        return _index;\n-    }\n-\n-    /**\n-     * This method is called after reading the entry type from bytecode.\n-     * It should read all the data for this entry from the given stream.\n-     */\n-    abstract void readData(DataInput in) throws IOException;\n-\n-    /**\n-     * This method is called after writing the entry type to bytecode.\n-     * It should write all data for this entry to the given stream.\n-     */\n-    abstract void writeData(DataOutput out) throws IOException;\n-\n-    /**\n-     * Subclasses must call this method before their state is mutated.\n-     */\n-    Object beforeModify() {\n-        if (_pool == null)\n-            return null;\n-        return _pool.getKey(this);\n-    }\n-\n-    /**\n-     * Subclasses must call this method when their state is mutated.\n-     */\n-    void afterModify(Object key) {\n-        if (_pool != null)\n-            _pool.modifyEntry(key, this);\n-    }\n-\n-    /**\n-     * Sets the owning pool of the entry.\n-     */\n-    void setPool(ConstantPool pool) {\n-        // attempting to overwrite current pool?\n-        if (_pool != null && pool != null && _pool != pool)\n-            throw new IllegalStateException(\"Entry already belongs to a pool\");\n-\n-        _pool = pool;\n-    }\n-\n-    /**\n-     * Set the index of this entry within the pool.\n-     */\n-    void setIndex(int index) {\n-        _index = index;\n-    }\n-}"},{"sha":"5ae7a7e43af4b6c9090dde74a64750c6061a95fa","filename":"serp/src/main/java/serp/bytecode/lowlevel/FieldEntry.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/FieldEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/FieldEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/FieldEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,47 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * A reference to a class field.\n- *\n- * @author Abe White\n- */\n-public class FieldEntry extends ComplexEntry {\n-\n-    /**\n-     * Default constructor.\n-     */\n-    public FieldEntry() {\n-    }\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @see ComplexEntry#ComplexEntry(int,int)\n-     */\n-    public FieldEntry(int classIndex, int nameAndTypeIndex) {\n-        super(classIndex, nameAndTypeIndex);\n-    }\n-\n-    public int getType() {\n-        return Entry.FIELD;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterFieldEntry(this);\n-        visit.exitFieldEntry(this);\n-    }\n-}"},{"sha":"9a0698a4d33a2a2e9461341333762e123156868c","filename":"serp/src/main/java/serp/bytecode/lowlevel/FloatEntry.java","status":"removed","additions":0,"deletions":85,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/FloatEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/FloatEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/FloatEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,85 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * A constant float value in the constant pool.\n- *\n- * @author Abe White\n- */\n-public class FloatEntry extends Entry implements ConstantEntry {\n-\n-    private float _value = 0.0F;\n-\n-    /**\n-     * Default constructor.\n-     */\n-    public FloatEntry() {\n-    }\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param value the constant float value of this entry\n-     */\n-    public FloatEntry(float value) {\n-        _value = value;\n-    }\n-\n-    public int getType() {\n-        return Entry.FLOAT;\n-    }\n-\n-    /**\n-     * Return the value of this constant.\n-     */\n-    public float getValue() {\n-        return _value;\n-    }\n-\n-    /**\n-     * Set the value of this constant.\n-     */\n-    public void setValue(float value) {\n-        Object key = beforeModify();\n-        _value = value;\n-        afterModify(key);\n-    }\n-\n-    public Object getConstant() {\n-        return new Float(getValue());\n-    }\n-\n-    public void setConstant(Object value) {\n-        setValue(((Number) value).floatValue());\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterFloatEntry(this);\n-        visit.exitFloatEntry(this);\n-    }\n-\n-    void readData(DataInput in) throws IOException {\n-        _value = in.readFloat();\n-    }\n-\n-    void writeData(DataOutput out) throws IOException {\n-        out.writeFloat(_value);\n-    }\n-}"},{"sha":"6afa0011a025916a62daf44fe8fae881687c1f35","filename":"serp/src/main/java/serp/bytecode/lowlevel/IntEntry.java","status":"removed","additions":0,"deletions":86,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/IntEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/IntEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/IntEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,86 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.util.Numbers;\n-\n-/**\n- * A constant int value in the constant pool.\n- *\n- * @author Abe White\n- */\n-public class IntEntry extends Entry implements ConstantEntry {\n-\n-    private int _value = -1;\n-\n-    /**\n-     * Default constructor.\n-     */\n-    public IntEntry() {\n-    }\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param value the constant int value of this entry\n-     */\n-    public IntEntry(int value) {\n-        _value = value;\n-    }\n-\n-    public int getType() {\n-        return Entry.INT;\n-    }\n-\n-    /**\n-     * Return the value of this constant.\n-     */\n-    public int getValue() {\n-        return _value;\n-    }\n-\n-    /**\n-     * Set the value of this constant.\n-     */\n-    public void setValue(int value) {\n-        Object key = beforeModify();\n-        _value = value;\n-        afterModify(key);\n-    }\n-\n-    public Object getConstant() {\n-        return Numbers.valueOf(getValue());\n-    }\n-\n-    public void setConstant(Object value) {\n-        setValue(((Number) value).intValue());\n-    }\n-\n-    protected void readData(DataInput in) throws IOException {\n-        _value = in.readInt();\n-    }\n-\n-    protected void writeData(DataOutput out) throws IOException {\n-        out.writeInt(_value);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterIntEntry(this);\n-        visit.exitIntEntry(this);\n-    }\n-}"},{"sha":"7e28c7abb2f6ca4734436f6758f698d6644fdeed","filename":"serp/src/main/java/serp/bytecode/lowlevel/InterfaceMethodEntry.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/InterfaceMethodEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/InterfaceMethodEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/InterfaceMethodEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,47 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * A reference to an interface method.\n- *\n- * @author Abe White\n- */\n-public class InterfaceMethodEntry extends ComplexEntry {\n-\n-    /**\n-     * Default constructor.\n-     */\n-    public InterfaceMethodEntry() {\n-    }\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @see ComplexEntry#ComplexEntry(int,int)\n-     */\n-    public InterfaceMethodEntry(int classIndex, int nameAndTypeIndex) {\n-        super(classIndex, nameAndTypeIndex);\n-    }\n-\n-    public int getType() {\n-        return Entry.INTERFACEMETHOD;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterInterfaceMethodEntry(this);\n-        visit.exitInterfaceMethodEntry(this);\n-    }\n-}"},{"sha":"d823ffbf8fc6e0d3bb6f3fb2b030c60877b5eb74","filename":"serp/src/main/java/serp/bytecode/lowlevel/LongEntry.java","status":"removed","additions":0,"deletions":90,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/LongEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/LongEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/LongEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,90 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-import serp.util.Numbers;\n-\n-/**\n- * A long constant in the constant pool.\n- *\n- * @author Abe White\n- */\n-public class LongEntry extends Entry implements ConstantEntry {\n-\n-    private long _value = 0L;\n-\n-    /**\n-     * Default constructor.\n-     */\n-    public LongEntry() {\n-    }\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param value the constant long value of this entry\n-     */\n-    public LongEntry(long value) {\n-        _value = value;\n-    }\n-\n-    public boolean isWide() {\n-        return true;\n-    }\n-\n-    public int getType() {\n-        return Entry.LONG;\n-    }\n-\n-    /**\n-     * Return the value of the constant.\n-     */\n-    public long getValue() {\n-        return _value;\n-    }\n-\n-    /**\n-     * Set the value of the constant.\n-     */\n-    public void setValue(long value) {\n-        Object key = beforeModify();\n-        _value = value;\n-        afterModify(key);\n-    }\n-\n-    public Object getConstant() {\n-        return Numbers.valueOf(getValue());\n-    }\n-\n-    public void setConstant(Object value) {\n-        setValue(((Number) value).longValue());\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterLongEntry(this);\n-        visit.exitLongEntry(this);\n-    }\n-\n-    void readData(DataInput in) throws IOException {\n-        _value = in.readLong();\n-    }\n-\n-    void writeData(DataOutput out) throws IOException {\n-        out.writeLong(_value);\n-    }\n-}"},{"sha":"25a19a0fe35c505b4a054495243851e14e63470f","filename":"serp/src/main/java/serp/bytecode/lowlevel/MethodEntry.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/MethodEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/MethodEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/MethodEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,47 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * A reference to a class method.\n- *\n- * @author Abe White\n- */\n-public class MethodEntry extends ComplexEntry {\n-\n-    /**\n-     * Default constructor.\n-     */\n-    public MethodEntry() {\n-    }\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @see ComplexEntry#ComplexEntry(int,int)\n-     */\n-    public MethodEntry(int classIndex, int nameAndTypeIndex) {\n-        super(classIndex, nameAndTypeIndex);\n-    }\n-\n-    public int getType() {\n-        return Entry.METHOD;\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterMethodEntry(this);\n-        visit.exitMethodEntry(this);\n-    }\n-}"},{"sha":"6de2db13a6ea5c070a4b1a358939b612a0816738","filename":"serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java","status":"removed","additions":0,"deletions":121,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,121 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * Entry containing indexes referencing a name and a descriptor. Used\n- * to describe fields and methods of other classes referenced by opcodes.\n- *\n- * @author Abe White\n- */\n-public class NameAndTypeEntry extends Entry {\n-\n-    private int _nameIndex = 0;\n-    private int _descriptorIndex = 0;\n-\n-    /**\n-     * Default constructor.\n-     */\n-    public NameAndTypeEntry() {\n-    }\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param nameIndex the constant pool index of the\n-     * {@link UTF8Entry} containing the name of this entity\n-     * @param descriptorIndex the constant pool index of the\n-     * {@link UTF8Entry} containing the descriptor for this entity\n-     */\n-    public NameAndTypeEntry(int nameIndex, int descriptorIndex) {\n-        _nameIndex = nameIndex;\n-        _descriptorIndex = descriptorIndex;\n-    }\n-\n-    public int getType() {\n-        return Entry.NAMEANDTYPE;\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link UTF8Entry}\n-     * containing the name of this entity.\n-     */\n-    public int getNameIndex() {\n-        return _nameIndex;\n-    }\n-\n-    /**\n-     * Set the constant pool index of the {@link UTF8Entry}\n-     * containing the name of this entity.\n-     */\n-    public void setNameIndex(int nameIndex) {\n-        Object key = beforeModify();\n-        _nameIndex = nameIndex;\n-        afterModify(key);\n-    }\n-\n-    /**\n-     * Return the name's referenced {@link UTF8Entry}. This method can only\n-     * be run for entries that have been added to a constant pool.\n-     */\n-    public UTF8Entry getNameEntry() {\n-        return (UTF8Entry) getPool().getEntry(_nameIndex);\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link UTF8Entry}\n-     * containing the descriptor for this entity.\n-     */\n-    public int getDescriptorIndex() {\n-        return _descriptorIndex;\n-    }\n-\n-    /**\n-     * Set the constant pool index of a {@link UTF8Entry}\n-     * containing the descriptor for this entity.\n-     */\n-    public void setDescriptorIndex(int descriptorIndex) {\n-        Object key = beforeModify();\n-        _descriptorIndex = descriptorIndex;\n-        afterModify(key);\n-    }\n-\n-    /**\n-     * Return the descriptor's referenced {@link UTF8Entry}. This method\n-     * can only be run for entries that have been added to a constant pool.\n-     */\n-    public UTF8Entry getDescriptorEntry() {\n-        return (UTF8Entry) getPool().getEntry(_descriptorIndex);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterNameAndTypeEntry(this);\n-        visit.exitNameAndTypeEntry(this);\n-    }\n-\n-    void readData(DataInput in) throws IOException {\n-        _nameIndex = in.readUnsignedShort();\n-        _descriptorIndex = in.readUnsignedShort();\n-    }\n-\n-    void writeData(DataOutput out) throws IOException {\n-        out.writeShort(_nameIndex);\n-        out.writeShort(_descriptorIndex);\n-    }\n-}"},{"sha":"61ec943691e340e86ce522790f22001fd66aba00","filename":"serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java","status":"removed","additions":0,"deletions":97,"changes":97,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,97 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * A String constant in the constant pool. String constants\n- * hold a reference to a {@link UTF8Entry} that stores the actual value.\n- *\n- * @author Abe White\n- */\n-public class StringEntry extends Entry implements ConstantEntry {\n-\n-    private int _stringIndex = -1;\n-\n-    /**\n-     * Default constructor.\n-     */\n-    public StringEntry() {\n-    }\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param stringIndex the constant pool index of the {@link UTF8Entry}\n-     * containing the value of this string\n-     */\n-    public StringEntry(int stringIndex) {\n-        _stringIndex = stringIndex;\n-    }\n-\n-    public int getType() {\n-        return Entry.STRING;\n-    }\n-\n-    /**\n-     * Return the constant pool index of the {@link UTF8Entry}\n-     * storing the value of this string.\n-     */\n-    public int getStringIndex() {\n-        return _stringIndex;\n-    }\n-\n-    /**\n-     * Set the constant pool index of the {@link UTF8Entry}\n-     * storing the value of this string.\n-     */\n-    public void setStringIndex(int stringIndex) {\n-        Object key = beforeModify();\n-        _stringIndex = stringIndex;\n-        afterModify(key);\n-    }\n-\n-    /**\n-     * Return the referenced {@link UTF8Entry}. This method can only\n-     * be run for entries that have been added to a constant pool.\n-     */\n-    public UTF8Entry getStringEntry() {\n-        return (UTF8Entry) getPool().getEntry(_stringIndex);\n-    }\n-\n-    public Object getConstant() {\n-        return getStringEntry().getValue();\n-    }\n-\n-    public void setConstant(Object value) {\n-        getStringEntry().setConstant(value);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterStringEntry(this);\n-        visit.exitStringEntry(this);\n-    }\n-\n-    void readData(DataInput in) throws IOException {\n-        _stringIndex = in.readUnsignedShort();\n-    }\n-\n-    void writeData(DataOutput out) throws IOException {\n-        out.writeShort(_stringIndex);\n-    }\n-}"},{"sha":"ccd1d7d879eb8ed0ceea72530068df937da11912","filename":"serp/src/main/java/serp/bytecode/lowlevel/UTF8Entry.java","status":"removed","additions":0,"deletions":88,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/UTF8Entry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/UTF8Entry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/UTF8Entry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,88 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.lowlevel;\n-\n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n-\n-import serp.bytecode.visitor.BCVisitor;\n-\n-/**\n- * A unicode string value in the constant pool.\n- *\n- * @author Abe White\n- */\n-public class UTF8Entry extends Entry implements ConstantEntry {\n-\n-    private String _value = \"\";\n-\n-    /**\n-     * Default constructor.\n-     */\n-    public UTF8Entry() {\n-    }\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param value the constant string value of this entry\n-     */\n-    public UTF8Entry(String value) {\n-        _value = value;\n-    }\n-\n-    public int getType() {\n-        return Entry.UTF8;\n-    }\n-\n-    /**\n-     * Return the value of the entry.\n-     */\n-    public String getValue() {\n-        return _value;\n-    }\n-\n-    /**\n-     * Set the value of the entry.\n-     */\n-    public void setValue(String value) {\n-        if (value == null)\n-            throw new NullPointerException(\"value = null\");\n-\n-        Object key = beforeModify();\n-        _value = value;\n-        afterModify(key);\n-    }\n-\n-    public Object getConstant() {\n-        return getValue();\n-    }\n-\n-    public void setConstant(Object value) {\n-        setValue((String) value);\n-    }\n-\n-    public void acceptVisit(BCVisitor visit) {\n-        visit.enterUTF8Entry(this);\n-        visit.exitUTF8Entry(this);\n-    }\n-\n-    void readData(DataInput in) throws IOException {\n-        _value = in.readUTF();\n-    }\n-\n-    void writeData(DataOutput out) throws IOException {\n-        out.writeUTF(_value);\n-    }\n-}"},{"sha":"6047536ec192c1c177b12be283cb7923de458f23","filename":"serp/src/main/java/serp/bytecode/lowlevel/package.html","status":"removed","additions":0,"deletions":12,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/package.html","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/package.html?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,12 +0,0 @@\n-<html>\n-<body>\n-<p><strong>Lowlevel Bytecode Manipuation</strong></p>\n-\n-<p>\n-    This package contains facilities for lowlevel bytecode manipulation\n-    through the class constant pool. It is generally not necessary to use\n-    this package directly, as all necessary functionality is made available\n-    at a high level via the <code>serp.bytecode</code> package.\n-</p>\n-</body>\n-</html>"},{"sha":"9a4c00d451d7249a40d48a69551422452e591fea","filename":"serp/src/main/java/serp/bytecode/package.html","status":"removed","additions":0,"deletions":145,"changes":145,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/package.html","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/package.html?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,145 +0,0 @@\n-<html>\n-<body>\n-<p><strong>Bytecode Manipuation</strong></p>\n-\n-<p>\n-    This package contains a framework for Java bytecode manipulation.\n-</p>\n-\n-<p>\n-    Bytecode manipulation is a powerful tool in the arsenal of the Java\n-    developer. It can be used for tasks from compiling alternative\n-    programming languages to run in a JVM, to creating new classes on the\n-    fly at runtime, to instrumenting classes for performance analysis, to\n-    debugging, to altering or enhancing the capabilities of existing\n-    compiled classes. Traditionally, however, this power has come at a\n-    price: modifying bytecode has required an in-depth knowledge of the\n-    class file structure and has necessitated very low-level programming\n-    techniques. These costs have proven too much for most developers, and\n-    bytecode manipulation has been largely ignored by the mainstream.\n-</p>\n-\n-<p>\n-    The goal of the serp bytecode framework is to tap the full power of\n-    bytecode modification while lowering its associated costs.\n-    The framework provides a set of high-level APIs for manipulating all\n-    aspects of bytecode, from large-scale structures like class member\n-    fields to the individual instructions that comprise the code of\n-    methods. While in order to perform any advanced manipulation, some\n-    understanding of the\n-    <a href=\"http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html\">\n-        class file format</a> and especially of the\n-    <a href=\"http://java.sun.com/docs/books/vmspec/2nd-edition/html/Instructions.doc.html\">\n-        JVM instruction set</a> is necessary, the framework makes it as easy\n-    as possible to enter the world of bytecode development.\n-</p>\n-\n-<p>\n-    There are several other excellent bytecode frameworks available. Serp\n-    excels, however, in the following areas:\n-    <ul>\n-        <li>\n-            <em>Ease of use.</em> Serp provides very high-level APIs for\n-            all normal bytecode modification functionality. Additionally,\n-            the framework contains a large set of convenience methods to\n-            make code that uses it as clean as possible. From overloading\n-            its methods to prevent you from having to make type\n-            conversions, to making shortcuts for operations like adding\n-            default constructors, serp tries to take the pain out of\n-            bytecode development.\n-        </li>\n-        <li>\n-            <em>Power.</em> Serp does not hide any of the power of\n-            bytecode manipulation behind a limited set of high-level\n-            functions. In addition to its available high-level APIs, which\n-            themselves cover the functionality all but the most advanced\n-            users will ever need, serp gives you direct access to the\n-            low-level details of the class file and constant pool. You\n-            can even switch back and\n-            forth between low-level and high-level operations;\n-            serp maintains complete consistency of the class structure\n-            at all times. A change to a method descriptor in the constant\n-            pool, for example, will immediately change the return values\n-            of all the high-level APIs that describe that method.\n-        </li>\n-        <li>\n-            <em>Constant pool management.</em> In the class file format,\n-            all constant values are stored in a constant pool of shared\n-            entries to minimize the size of class structures. Serp gives\n-            you access to the constant pool directly, but most of you\n-            will never use it; serp's high-level APIs completely\n-            abstract management of the constant pool.\n-            Any time a new constant is needed, serp will automatically add\n-            it to the pool while ensuring that no duplicates ever exist.\n-            Serp also does its best to manipulate the pool so that the\n-            effects of changing a constant are as expected: i.e. changing\n-            one instruction to use the string \"bar\" instead of \"foo\"\n-            will not affect other instructions that use the string \"foo\",\n-            but changing the name of a class field will instantly change\n-            all instructions that reference that field to use the new name.\n-        </li>\n-        <li>\n-            <em>Instruction morphing.</em> Dealing with the individual\n-            instructions that make up method code is the most difficult\n-            part of bytecode manipulation. To facilitate this process,\n-            most serp instruction representations have the ability to\n-            change their underlying low-level opcodes on the fly as the\n-            you modify the parameters of the instruction. For\n-            example, accessing the constant integer value 0 requires the\n-            opcode <code>iconst0</code>, while accessing the string\n-            constant \"foo\" requires a different opcode, <code>ldc</code>,\n-            followed by the constant pool index of \"foo\". In serp, however,\n-            there is only one instruction, <code>constant</code>. This\n-            instruction has <code>setValue</code> methods which use the\n-            given value to automatically determine the correct opcodes and\n-            arguments -- <code>iconst0</code> for a value of 0 and\n-            <code>ldc</code> plus the proper constant pool index for the\n-            value of \"foo\".\n-        </li>\n-    </ul>\n-</p>\n-\n-<p>\n-    Serp is not ideally suited to all applications. Here are a few\n-    disadvantages of serp:\n-    <ul>\n-        <li>\n-            <em>Speed.</em> Serp is not built for speed. Though there\n-            are plans for performing incremental parsing, serp currently\n-            fully parses class files when a class is loaded, which is a\n-            slow process.\n-            Also, serp's insistence on full-time consistency between the\n-            low and high level class structures slows down both access and\n-            mutator methods. These factors are less of a concern, though,\n-            when creating new classes at runtime (rather than modifying\n-            existing code), or when using serp as part of the compilation\n-            process. Serp excels in both of these scenarios.\n-        </li>\n-        <li>\n-            <em>Memory.</em> Serp's high-level structures for representing\n-            class bytecode are very memory-hungry.\n-        </li>\n-        <li>\n-            <em>Multi-threaded modifications.</em> The serp toolkit is\n-            not threadsafe. Multiple threads cannot safely make\n-            modifications to the same classes the same time.\n-        </li>\n-        <li>\n-            <em>Project-level modifications.</em> Changes made in one\n-            class in a serp project are not yet automatically propogated\n-            to other classes. However, there are plans to implement this,\n-            as well as plans to allow operations to modify bytecode based\n-            on specified patterns, similar to aspect-oriented programming.\n-        </li>\n-    </ul>\n-</p>\n-\n-<p>\n-    The first class that you should study in this package is the\n-    {@link serp.bytecode.Project} type. From there, move onto the\n-    {@link serp.bytecode.BCClass}, and trace its APIs into\n-    {@link serp.bytecode.BCField}s, {@link serp.bytecode.BCMethod}s,\n-    and finally into actual {@link serp.bytecode.Code}.\n-</p>\n-</body>\n-</html>"},{"sha":"d7a1c40bcc1431e29168f3cdfe92ecf5d4a71924","filename":"serp/src/main/java/serp/bytecode/visitor/BCVisitor.java","status":"removed","additions":0,"deletions":468,"changes":468,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/visitor/BCVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/visitor/BCVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/visitor/BCVisitor.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,468 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.visitor;\n-\n-import serp.bytecode.ArrayLoadInstruction;\n-import serp.bytecode.ArrayStoreInstruction;\n-import serp.bytecode.Attribute;\n-import serp.bytecode.BCClass;\n-import serp.bytecode.BCField;\n-import serp.bytecode.BCMember;\n-import serp.bytecode.BCMethod;\n-import serp.bytecode.ClassInstruction;\n-import serp.bytecode.CmpInstruction;\n-import serp.bytecode.Code;\n-import serp.bytecode.ConstantInstruction;\n-import serp.bytecode.ConstantValue;\n-import serp.bytecode.ConvertInstruction;\n-import serp.bytecode.Deprecated;\n-import serp.bytecode.ExceptionHandler;\n-import serp.bytecode.Exceptions;\n-import serp.bytecode.GetFieldInstruction;\n-import serp.bytecode.IIncInstruction;\n-import serp.bytecode.IfInstruction;\n-import serp.bytecode.InnerClass;\n-import serp.bytecode.InnerClasses;\n-import serp.bytecode.Instruction;\n-import serp.bytecode.JumpInstruction;\n-import serp.bytecode.LineNumber;\n-import serp.bytecode.LineNumberTable;\n-import serp.bytecode.LoadInstruction;\n-import serp.bytecode.LocalVariable;\n-import serp.bytecode.LocalVariableTable;\n-import serp.bytecode.LocalVariableType;\n-import serp.bytecode.LocalVariableTypeTable;\n-import serp.bytecode.LookupSwitchInstruction;\n-import serp.bytecode.MathInstruction;\n-import serp.bytecode.MethodInstruction;\n-import serp.bytecode.MonitorEnterInstruction;\n-import serp.bytecode.MonitorExitInstruction;\n-import serp.bytecode.MultiANewArrayInstruction;\n-import serp.bytecode.NewArrayInstruction;\n-import serp.bytecode.Project;\n-import serp.bytecode.PutFieldInstruction;\n-import serp.bytecode.RetInstruction;\n-import serp.bytecode.ReturnInstruction;\n-import serp.bytecode.SourceFile;\n-import serp.bytecode.StackInstruction;\n-import serp.bytecode.StoreInstruction;\n-import serp.bytecode.Synthetic;\n-import serp.bytecode.TableSwitchInstruction;\n-import serp.bytecode.UnknownAttribute;\n-import serp.bytecode.WideInstruction;\n-import serp.bytecode.lowlevel.ClassEntry;\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.bytecode.lowlevel.DoubleEntry;\n-import serp.bytecode.lowlevel.Entry;\n-import serp.bytecode.lowlevel.FieldEntry;\n-import serp.bytecode.lowlevel.FloatEntry;\n-import serp.bytecode.lowlevel.IntEntry;\n-import serp.bytecode.lowlevel.InterfaceMethodEntry;\n-import serp.bytecode.lowlevel.LongEntry;\n-import serp.bytecode.lowlevel.MethodEntry;\n-import serp.bytecode.lowlevel.NameAndTypeEntry;\n-import serp.bytecode.lowlevel.StringEntry;\n-import serp.bytecode.lowlevel.UTF8Entry;\n-\n-/**\n- * Base class for visitors on a bytecode entity. The public {@link #visit}\n- * method will traverse the object graph of the given entity, calling the\n- * <code>enter*</code> and <code>exit*</code> methods as it visits each\n- * object. The traversal is done depth-first. Subclasses should override\n- * only the methods for visiting the entities they are interested in.\n- * Whenever there is a general method(i.e. <code>enter/exitEntry</code>) as\n- * well as a more specific one(i.e. <code>enter/exitStringEntry</code>), the\n- * more general method will be called first, followed by a call on the correct\n- * specific method. Most subclasses will override either the general or\n- * specific cases, but not both.\n- *\n- * @author Abe White\n- */\n-public class BCVisitor {\n-\n-    /**\n-     * Visit the given entity.\n-     */\n-    public void visit(VisitAcceptor obj) {\n-        if (obj == null)\n-            return;\n-\n-        obj.acceptVisit(this);\n-    }\n-\n-    public void enterProject(Project obj) {\n-    }\n-\n-    public void exitProject(Project obj) {\n-    }\n-\n-    public void enterBCClass(BCClass obj) {\n-    }\n-\n-    public void exitBCClass(BCClass obj) {\n-    }\n-\n-    public void enterBCMember(BCMember obj) {\n-    }\n-\n-    public void exitBCMember(BCMember obj) {\n-    }\n-\n-    public void enterBCField(BCField obj) {\n-    }\n-\n-    public void exitBCField(BCField obj) {\n-    }\n-\n-    public void enterBCMethod(BCMethod obj) {\n-    }\n-\n-    public void exitBCMethod(BCMethod obj) {\n-    }\n-\n-    public void enterAttribute(Attribute obj) {\n-    }\n-\n-    public void exitAttribute(Attribute obj) {\n-    }\n-\n-    public void enterConstantValue(ConstantValue obj) {\n-    }\n-\n-    public void exitConstantValue(ConstantValue obj) {\n-    }\n-\n-    public void enterDeprecated(Deprecated obj) {\n-    }\n-\n-    public void exitDeprecated(Deprecated obj) {\n-    }\n-\n-    public void enterExceptions(Exceptions obj) {\n-    }\n-\n-    public void exitExceptions(Exceptions obj) {\n-    }\n-\n-    public void enterInnerClasses(InnerClasses obj) {\n-    }\n-\n-    public void exitInnerClasses(InnerClasses obj) {\n-    }\n-\n-    public void enterLineNumberTable(LineNumberTable obj) {\n-    }\n-\n-    public void exitLineNumberTable(LineNumberTable obj) {\n-    }\n-\n-    public void enterLocalVariableTable(LocalVariableTable obj) {\n-    }\n-\n-    public void exitLocalVariableTable(LocalVariableTable obj) {\n-    }\n-\n-    public void enterLocalVariableTypeTable(LocalVariableTypeTable obj) {\n-    }\n-\n-    public void exitLocalVariableTypeTable(LocalVariableTypeTable obj) {\n-    }\n-\n-    public void enterSourceFile(SourceFile obj) {\n-    }\n-\n-    public void exitSourceFile(SourceFile obj) {\n-    }\n-\n-    public void enterSynthetic(Synthetic obj) {\n-    }\n-\n-    public void exitSynthetic(Synthetic obj) {\n-    }\n-\n-    public void enterUnknownAttribute(UnknownAttribute obj) {\n-    }\n-\n-    public void exitUnknownAttribute(UnknownAttribute obj) {\n-    }\n-\n-    public void enterCode(Code obj) {\n-    }\n-\n-    public void exitCode(Code obj) {\n-    }\n-\n-    public void enterExceptionHandler(ExceptionHandler obj) {\n-    }\n-\n-    public void exitExceptionHandler(ExceptionHandler obj) {\n-    }\n-\n-    public void enterInnerClass(InnerClass obj) {\n-    }\n-\n-    public void exitInnerClass(InnerClass obj) {\n-    }\n-\n-    public void enterLineNumber(LineNumber obj) {\n-    }\n-\n-    public void exitLineNumber(LineNumber obj) {\n-    }\n-\n-    public void enterLocalVariable(LocalVariable obj) {\n-    }\n-\n-    public void exitLocalVariable(LocalVariable obj) {\n-    }\n-\n-    public void enterLocalVariableType(LocalVariableType obj) {\n-    }\n-\n-    public void exitLocalVariableType(LocalVariableType obj) {\n-    }\n-\n-    public void enterInstruction(Instruction obj) {\n-    }\n-\n-    public void exitInstruction(Instruction obj) {\n-    }\n-\n-    public void enterArrayLoadInstruction(ArrayLoadInstruction obj) {\n-    }\n-\n-    public void exitArrayLoadInstruction(ArrayLoadInstruction obj) {\n-    }\n-\n-    public void enterArrayStoreInstruction(ArrayStoreInstruction obj) {\n-    }\n-\n-    public void exitArrayStoreInstruction(ArrayStoreInstruction obj) {\n-    }\n-\n-    public void enterClassInstruction(ClassInstruction obj) {\n-    }\n-\n-    public void exitClassInstruction(ClassInstruction obj) {\n-    }\n-\n-    public void enterConstantInstruction(ConstantInstruction obj) {\n-    }\n-\n-    public void exitConstantInstruction(ConstantInstruction obj) {\n-    }\n-\n-    public void enterConvertInstruction(ConvertInstruction obj) {\n-    }\n-\n-    public void exitConvertInstruction(ConvertInstruction obj) {\n-    }\n-\n-    public void enterGetFieldInstruction(GetFieldInstruction obj) {\n-    }\n-\n-    public void exitGetFieldInstruction(GetFieldInstruction obj) {\n-    }\n-\n-    public void enterIIncInstruction(IIncInstruction obj) {\n-    }\n-\n-    public void exitIIncInstruction(IIncInstruction obj) {\n-    }\n-\n-    public void enterJumpInstruction(JumpInstruction obj) {\n-    }\n-\n-    public void exitJumpInstruction(JumpInstruction obj) {\n-    }\n-\n-    public void enterIfInstruction(IfInstruction obj) {\n-    }\n-\n-    public void exitIfInstruction(IfInstruction obj) {\n-    }\n-\n-    public void enterLoadInstruction(LoadInstruction obj) {\n-    }\n-\n-    public void exitLoadInstruction(LoadInstruction obj) {\n-    }\n-\n-    public void enterLookupSwitchInstruction(LookupSwitchInstruction obj) {\n-    }\n-\n-    public void exitLookupSwitchInstruction(LookupSwitchInstruction obj) {\n-    }\n-\n-    public void enterMathInstruction(MathInstruction obj) {\n-    }\n-\n-    public void exitMathInstruction(MathInstruction obj) {\n-    }\n-\n-    public void enterMethodInstruction(MethodInstruction obj) {\n-    }\n-\n-    public void exitMethodInstruction(MethodInstruction obj) {\n-    }\n-\n-    public void enterMultiANewArrayInstruction(MultiANewArrayInstruction obj) {\n-    }\n-\n-    public void exitMultiANewArrayInstruction(MultiANewArrayInstruction obj) {\n-    }\n-\n-    public void enterNewArrayInstruction(NewArrayInstruction obj) {\n-    }\n-\n-    public void exitNewArrayInstruction(NewArrayInstruction obj) {\n-    }\n-\n-    public void enterPutFieldInstruction(PutFieldInstruction obj) {\n-    }\n-\n-    public void exitPutFieldInstruction(PutFieldInstruction obj) {\n-    }\n-\n-    public void enterRetInstruction(RetInstruction obj) {\n-    }\n-\n-    public void exitRetInstruction(RetInstruction obj) {\n-    }\n-\n-    public void enterReturnInstruction(ReturnInstruction obj) {\n-    }\n-\n-    public void exitReturnInstruction(ReturnInstruction obj) {\n-    }\n-\n-    public void enterStackInstruction(StackInstruction obj) {\n-    }\n-\n-    public void exitStackInstruction(StackInstruction obj) {\n-    }\n-\n-    public void enterStoreInstruction(StoreInstruction obj) {\n-    }\n-\n-    public void exitStoreInstruction(StoreInstruction obj) {\n-    }\n-\n-    public void enterTableSwitchInstruction(TableSwitchInstruction obj) {\n-    }\n-\n-    public void exitTableSwitchInstruction(TableSwitchInstruction obj) {\n-    }\n-\n-    public void enterWideInstruction(WideInstruction obj) {\n-    }\n-\n-    public void exitWideInstruction(WideInstruction obj) {\n-    }\n-\n-    public void enterMonitorEnterInstruction(MonitorEnterInstruction obj) {\n-    }\n-\n-    public void exitMonitorEnterInstruction(MonitorEnterInstruction obj) {\n-    }\n-\n-    public void enterMonitorExitInstruction(MonitorExitInstruction obj) {\n-    }\n-\n-    public void exitMonitorExitInstruction(MonitorExitInstruction obj) {\n-    }\n-\n-    public void enterCmpInstruction(CmpInstruction obj) {\n-    }\n-\n-    public void exitCmpInstruction(CmpInstruction obj) {\n-    }\n-\n-    public void enterConstantPool(ConstantPool obj) {\n-    }\n-\n-    public void exitConstantPool(ConstantPool obj) {\n-    }\n-\n-    public void enterEntry(Entry obj) {\n-    }\n-\n-    public void exitEntry(Entry obj) {\n-    }\n-\n-    public void enterClassEntry(ClassEntry obj) {\n-    }\n-\n-    public void exitClassEntry(ClassEntry obj) {\n-    }\n-\n-    public void enterDoubleEntry(DoubleEntry obj) {\n-    }\n-\n-    public void exitDoubleEntry(DoubleEntry obj) {\n-    }\n-\n-    public void enterFieldEntry(FieldEntry obj) {\n-    }\n-\n-    public void exitFieldEntry(FieldEntry obj) {\n-    }\n-\n-    public void enterFloatEntry(FloatEntry obj) {\n-    }\n-\n-    public void exitFloatEntry(FloatEntry obj) {\n-    }\n-\n-    public void enterIntEntry(IntEntry obj) {\n-    }\n-\n-    public void exitIntEntry(IntEntry obj) {\n-    }\n-\n-    public void enterInterfaceMethodEntry(InterfaceMethodEntry obj) {\n-    }\n-\n-    public void exitInterfaceMethodEntry(InterfaceMethodEntry obj) {\n-    }\n-\n-    public void enterLongEntry(LongEntry obj) {\n-    }\n-\n-    public void exitLongEntry(LongEntry obj) {\n-    }\n-\n-    public void enterMethodEntry(MethodEntry obj) {\n-    }\n-\n-    public void exitMethodEntry(MethodEntry obj) {\n-    }\n-\n-    public void enterNameAndTypeEntry(NameAndTypeEntry obj) {\n-    }\n-\n-    public void exitNameAndTypeEntry(NameAndTypeEntry obj) {\n-    }\n-\n-    public void enterStringEntry(StringEntry obj) {\n-    }\n-\n-    public void exitStringEntry(StringEntry obj) {\n-    }\n-\n-    public void enterUTF8Entry(UTF8Entry obj) {\n-    }\n-\n-    public void exitUTF8Entry(UTF8Entry obj) {\n-    }\n-}"},{"sha":"b436bf84c981a3816508545c111a708880e3f612","filename":"serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java","status":"removed","additions":0,"deletions":477,"changes":477,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,477 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.visitor;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-\n-import serp.bytecode.Attribute;\n-import serp.bytecode.BCClass;\n-import serp.bytecode.BCField;\n-import serp.bytecode.BCMethod;\n-import serp.bytecode.ClassInstruction;\n-import serp.bytecode.Code;\n-import serp.bytecode.ConstantInstruction;\n-import serp.bytecode.ConstantValue;\n-import serp.bytecode.Constants;\n-import serp.bytecode.ExceptionHandler;\n-import serp.bytecode.Exceptions;\n-import serp.bytecode.GetFieldInstruction;\n-import serp.bytecode.IIncInstruction;\n-import serp.bytecode.IfInstruction;\n-import serp.bytecode.InnerClass;\n-import serp.bytecode.Instruction;\n-import serp.bytecode.JumpInstruction;\n-import serp.bytecode.LineNumber;\n-import serp.bytecode.LoadInstruction;\n-import serp.bytecode.LocalVariable;\n-import serp.bytecode.LocalVariableType;\n-import serp.bytecode.LookupSwitchInstruction;\n-import serp.bytecode.MethodInstruction;\n-import serp.bytecode.MultiANewArrayInstruction;\n-import serp.bytecode.NewArrayInstruction;\n-import serp.bytecode.Project;\n-import serp.bytecode.PutFieldInstruction;\n-import serp.bytecode.RetInstruction;\n-import serp.bytecode.SourceFile;\n-import serp.bytecode.StoreInstruction;\n-import serp.bytecode.TableSwitchInstruction;\n-import serp.bytecode.WideInstruction;\n-import serp.bytecode.lowlevel.ClassEntry;\n-import serp.bytecode.lowlevel.ConstantPool;\n-import serp.bytecode.lowlevel.DoubleEntry;\n-import serp.bytecode.lowlevel.Entry;\n-import serp.bytecode.lowlevel.FieldEntry;\n-import serp.bytecode.lowlevel.FloatEntry;\n-import serp.bytecode.lowlevel.IntEntry;\n-import serp.bytecode.lowlevel.InterfaceMethodEntry;\n-import serp.bytecode.lowlevel.LongEntry;\n-import serp.bytecode.lowlevel.MethodEntry;\n-import serp.bytecode.lowlevel.NameAndTypeEntry;\n-import serp.bytecode.lowlevel.StringEntry;\n-import serp.bytecode.lowlevel.UTF8Entry;\n-\n-/**\n- * Visitor type that outputs a detailed, formatted document of the\n- * visited entity; similar to the <i>javap -c</i> command but more detailed.\n- *\n- * @author Abe White\n- */\n-public class PrettyPrintVisitor extends BCVisitor {\n-\n-    private PrintWriter _out = null;\n-    private String _prefix = \"\";\n-    private int _entryCount = 0;\n-\n-    /**\n-     * Invoke with the class or file names to pretty print; the\n-     * functionality is similar to the <i>javap -c</i> command, but more\n-     * detailed.\n-     */\n-    public static void main(String[] args)\n-        throws ClassNotFoundException, IOException {\n-        if (args.length == 0) {\n-            System.err.println(\"Usage: java \"\n-                + PrettyPrintVisitor.class.getName()\n-                + \" <class name | .class file>+\");\n-            System.exit(1);\n-        }\n-\n-        PrettyPrintVisitor ppv = new PrettyPrintVisitor();\n-        Project project = new Project();\n-        BCClass type;\n-        for (int i = 0; i < args.length; i++) {\n-            if (args[i].endsWith(\".class\"))\n-                type = project.loadClass(new File(args[i]));\n-            else\n-                type = project.loadClass(Class.forName(args[i], false,\n-                    PrettyPrintVisitor.class.getClassLoader()));\n-            ppv.visit(type);\n-        }\n-    }\n-\n-    /**\n-     * Constructor; all pritning will go to stdout.\n-     */\n-    public PrettyPrintVisitor() {\n-        _out = new PrintWriter(System.out);\n-    }\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param out the stream to print to\n-     */\n-    public PrettyPrintVisitor(PrintWriter out) {\n-        _out = out;\n-    }\n-\n-    public void visit(VisitAcceptor entity) {\n-        super.visit(entity);\n-        _out.flush();\n-    }\n-\n-    public void enterProject(Project obj) {\n-        openBlock(\"Project\");\n-\n-        println(\"name=\" + obj.getName());\n-    }\n-\n-    public void exitProject(Project obj) {\n-        closeBlock();\n-    }\n-\n-    public void enterBCClass(BCClass obj) {\n-        openBlock(\"Class\");\n-\n-        println(\"magic=\" + obj.getMagic());\n-        println(\"minor=\" + obj.getMinorVersion());\n-        println(\"major=\" + obj.getMajorVersion());\n-        println(\"access=\" + obj.getAccessFlags());\n-        println(\"name=\" + obj.getIndex() + \" <\" + obj.getName() + \">\");\n-        println(\"super=\" + obj.getSuperclassIndex()\n-            + \" <\" + obj.getSuperclassName() + \">\");\n-\n-        int[] indexes = obj.getDeclaredInterfaceIndexes();\n-        String[] names = obj.getDeclaredInterfaceNames();\n-        for (int i = 0; i < indexes.length; i++)\n-            println(\"interface=\" + indexes[i] + \" <\" + names[i] + \">\");\n-    }\n-\n-    public void exitBCClass(BCClass obj) {\n-        closeBlock();\n-    }\n-\n-    public void enterBCField(BCField obj) {\n-        openBlock(\"Field\");\n-        println(\"access=\" + obj.getAccessFlags());\n-        println(\"name=\" + obj.getNameIndex() + \" <\" + obj.getName() + \">\");\n-        println(\"type=\" + obj.getDescriptorIndex()\n-            + \" <\" + obj.getTypeName() + \">\");\n-    }\n-\n-    public void exitBCField(BCField obj) {\n-        closeBlock();\n-    }\n-\n-    public void enterBCMethod(BCMethod obj) {\n-        openBlock(\"Method\");\n-        println(\"access=\" + obj.getAccessFlags());\n-        println(\"name=\" + obj.getNameIndex() + \" <\" + obj.getName() + \">\");\n-        println(\"descriptor=\" + obj.getDescriptorIndex());\n-        println(\"return=\" + obj.getReturnName());\n-        String[] params = obj.getParamNames();\n-        for (int i = 0; i < params.length; i++)\n-            println(\"param=\" + params[i]);\n-    }\n-\n-    public void exitBCMethod(BCMethod obj) {\n-        closeBlock();\n-    }\n-\n-    public void enterAttribute(Attribute obj) {\n-        openBlock(obj.getName());\n-    }\n-\n-    public void exitAttribute(Attribute obj) {\n-        closeBlock();\n-    }\n-\n-    public void enterConstantValue(ConstantValue obj) {\n-        println(\"value=\" + obj.getValueIndex() + \" <\" + obj.getTypeName()\n-            + \"=\" + obj.getValue() + \">\");\n-    }\n-\n-    public void enterExceptions(Exceptions obj) {\n-        int[] indexes = obj.getExceptionIndexes();\n-        String[] names = obj.getExceptionNames();\n-        for (int i = 0; i < indexes.length; i++)\n-            println(\"exception=\" + indexes[i] + \" <\" + names[i] + \">\");\n-    }\n-\n-    public void enterSourceFile(SourceFile obj) {\n-        println(\"source=\" + obj.getFileIndex() + \" <\"\n-            + obj.getFileName() + \">\");\n-    }\n-\n-    public void enterCode(Code obj) {\n-        println(\"maxStack=\" + obj.getMaxStack());\n-        println(\"maxLocals=\" + obj.getMaxLocals());\n-        println(\"\");\n-    }\n-\n-    public void enterExceptionHandler(ExceptionHandler obj) {\n-        openBlock(\"ExceptionHandler\");\n-        println(\"startPc=\" + obj.getTryStartPc());\n-        println(\"endPc=\" + obj.getTryEndPc());\n-        println(\"handlerPc=\" + obj.getHandlerStartPc());\n-        println(\"catch=\" + obj.getCatchIndex() + \" <\"\n-            + obj.getCatchName() + \">\");\n-    }\n-\n-    public void exitExceptionHandler(ExceptionHandler obj) {\n-        closeBlock();\n-    }\n-\n-    public void enterInnerClass(InnerClass obj) {\n-        openBlock(\"InnerClass\");\n-        println(\"access=\" + obj.getAccessFlags());\n-        println(\"name=\" + obj.getNameIndex() + \" <\" + obj.getName() + \">\");\n-        println(\"type=\" + obj.getTypeIndex() + \"<\" + obj.getTypeName() + \">\");\n-        println(\"declarer=\" + obj.getDeclarerIndex() + \"<\"\n-            + obj.getDeclarerName() + \">\");\n-    }\n-\n-    public void exitInnerClass(InnerClass obj) {\n-        closeBlock();\n-    }\n-\n-    public void enterLineNumber(LineNumber obj) {\n-        openBlock(\"LineNumber\");\n-        println(\"startPc=\" + obj.getStartPc());\n-        println(\"line=\" + obj.getLine());\n-    }\n-\n-    public void exitLineNumber(LineNumber obj) {\n-        closeBlock();\n-    }\n-\n-    public void enterLocalVariable(LocalVariable obj) {\n-        openBlock(\"LocalVariable\");\n-        println(\"startPc=\" + obj.getStartPc());\n-        println(\"length=\" + obj.getLength());\n-        println(\"local=\" + obj.getLocal());\n-        println(\"name=\" + obj.getNameIndex() + \" <\" + obj.getName() + \">\");\n-        println(\"type=\" + obj.getTypeIndex() + \" <\" + obj.getTypeName() + \">\");\n-    }\n-\n-    public void exitLocalVariable(LocalVariable obj) {\n-        closeBlock();\n-    }\n-\n-    public void enterLocalVariableType(LocalVariableType obj) {\n-        openBlock(\"LocalVariableType\");\n-        println(\"startPc=\" + obj.getStartPc());\n-        println(\"length=\" + obj.getLength());\n-        println(\"local=\" + obj.getLocal());\n-        println(\"name=\" + obj.getNameIndex() + \" <\" + obj.getName() + \">\");\n-        println(\"signature=\" + obj.getTypeIndex() + \" <\"\n-            + obj.getTypeName() + \">\");\n-    }\n-\n-    public void exitLocalVariableType(LocalVariableType obj) {\n-        closeBlock();\n-    }\n-\n-    public void enterInstruction(Instruction obj) {\n-        _out.print(_prefix + obj.getByteIndex() + \" \" + obj.getName() + \" \");\n-    }\n-\n-    public void exitInstruction(Instruction obj) {\n-        _out.println();\n-    }\n-\n-    public void enterClassInstruction(ClassInstruction obj) {\n-        _out.print(obj.getTypeIndex() + \" <\" + obj.getTypeName() + \">\");\n-    }\n-\n-    public void enterConstantInstruction(ConstantInstruction obj) {\n-        _out.print(\"<\" + obj.getValue() + \">\");\n-    }\n-\n-    public void enterGetFieldInstruction(GetFieldInstruction obj) {\n-        _out.print(obj.getFieldIndex() + \" <\" + obj.getFieldTypeName()\n-            + \" \" + obj.getFieldDeclarerName()\n-            + \".\" + obj.getFieldName() + \">\");\n-    }\n-\n-    public void enterIIncInstruction(IIncInstruction obj) {\n-        _out.print(obj.getLocal() + \" \");\n-        if (obj.getIncrement() < 0)\n-            _out.print(\"-\");\n-        _out.print(obj.getIncrement());\n-    }\n-\n-    public void enterJumpInstruction(JumpInstruction obj) {\n-        _out.print(obj.getOffset());\n-    }\n-\n-    public void enterIfInstruction(IfInstruction obj) {\n-        _out.print(obj.getOffset());\n-    }\n-\n-    public void enterLoadInstruction(LoadInstruction obj) {\n-        _out.print(\"<\" + obj.getLocal() + \">\");\n-    }\n-\n-    public void enterLookupSwitchInstruction(LookupSwitchInstruction obj) {\n-        _out.println();\n-        _prefix += \"  \";\n-\n-        int[] offsets = obj.getOffsets();\n-        int[] matches = obj.getMatches();\n-        for (int i = 0; i < offsets.length; i++)\n-            println(\"case \" + matches[i] + \"=\" + offsets[i]);\n-        _out.print(_prefix + \"default=\" + obj.getDefaultOffset());\n-\n-        _prefix = _prefix.substring(2);\n-    }\n-\n-    public void enterMethodInstruction(MethodInstruction obj) {\n-        _out.print(obj.getMethodIndex() + \" <\" + obj.getMethodReturnName()\n-            + \" \" + obj.getMethodDeclarerName()\n-            + \".\" + obj.getMethodName() + \"(\");\n-        String[] params = obj.getMethodParamNames();\n-        int dotIndex;\n-        for (int i = 0; i < params.length; i++) {\n-            dotIndex = params[i].lastIndexOf('.');\n-            if (dotIndex != -1)\n-                params[i] = params[i].substring(dotIndex + 1);\n-\n-            _out.print(params[i]);\n-            if (i != params.length - 1)\n-                _out.print(\", \");\n-        }\n-\n-        _out.print(\")>\");\n-    }\n-\n-    public void enterMultiANewArrayInstruction(MultiANewArrayInstruction obj) {\n-        _out.print(obj.getTypeIndex() + \" \" + obj.getDimensions()\n-            + \" <\" + obj.getTypeName());\n-        String post = \"\";\n-        for (int i = 0; i < obj.getDimensions(); i++)\n-            post += \"[]\";\n-        _out.print(post + \">\");\n-    }\n-\n-    public void enterNewArrayInstruction(NewArrayInstruction obj) {\n-        _out.print(obj.getTypeCode() + \" <\" + obj.getTypeName() + \"[]>\");\n-    }\n-\n-    public void enterPutFieldInstruction(PutFieldInstruction obj) {\n-        _out.print(obj.getFieldIndex() + \" <\" + obj.getFieldTypeName()\n-            + \" \" + obj.getFieldDeclarerName()\n-            + \".\" + obj.getFieldName() + \">\");\n-    }\n-\n-    public void enterRetInstruction(RetInstruction obj) {\n-        _out.print(obj.getLocal());\n-    }\n-\n-    public void enterStoreInstruction(StoreInstruction obj) {\n-        _out.print(\"<\" + obj.getLocal() + \">\");\n-    }\n-\n-    public void enterTableSwitchInstruction(TableSwitchInstruction obj) {\n-        _out.println();\n-        _prefix += \"  \";\n-\n-        println(\"low=\" + obj.getLow());\n-        println(\"high=\" + obj.getHigh());\n-        int[] offsets = obj.getOffsets();\n-        for (int i = 0; i < offsets.length; i++)\n-            println(\"case=\" + offsets[i]);\n-        _out.print(_prefix + \"default=\" + obj.getDefaultOffset());\n-\n-        _prefix = _prefix.substring(2);\n-    }\n-\n-    public void enterWideInstruction(WideInstruction obj) {\n-        int ins = obj.getInstruction();\n-        _out.print(ins + \" <\" + Constants.OPCODE_NAMES[ins] + \">\");\n-    }\n-\n-    public void enterConstantPool(ConstantPool obj) {\n-        _entryCount = 0;\n-        openBlock(\"ConstantPool\");\n-    }\n-\n-    public void exitConstantPool(ConstantPool obj) {\n-        closeBlock();\n-    }\n-\n-    public void enterEntry(Entry obj) {\n-        String name = obj.getClass().getName();\n-        openBlock(++_entryCount + \": \"\n-            + name.substring(name.lastIndexOf('.') + 1));\n-    }\n-\n-    public void exitEntry(Entry obj) {\n-        closeBlock();\n-    }\n-\n-    public void enterClassEntry(ClassEntry obj) {\n-        println(\"name=\" + obj.getNameIndex());\n-    }\n-\n-    public void enterDoubleEntry(DoubleEntry obj) {\n-        println(\"value=\" + obj.getValue());\n-    }\n-\n-    public void enterFieldEntry(FieldEntry obj) {\n-        println(\"class=\" + obj.getClassIndex());\n-        println(\"nameAndType=\" + obj.getNameAndTypeIndex());\n-    }\n-\n-    public void enterFloatEntry(FloatEntry obj) {\n-        println(\"value=\" + obj.getValue());\n-    }\n-\n-    public void enterIntEntry(IntEntry obj) {\n-        println(\"value=\" + obj.getValue());\n-    }\n-\n-    public void enterInterfaceMethodEntry(InterfaceMethodEntry obj) {\n-        println(\"class=\" + obj.getClassIndex());\n-        println(\"nameAndType=\" + obj.getNameAndTypeIndex());\n-    }\n-\n-    public void enterLongEntry(LongEntry obj) {\n-        println(\"value=\" + obj.getValue());\n-    }\n-\n-    public void enterMethodEntry(MethodEntry obj) {\n-        println(\"class=\" + obj.getClassIndex());\n-        println(\"nameAndType=\" + obj.getNameAndTypeIndex());\n-    }\n-\n-    public void enterNameAndTypeEntry(NameAndTypeEntry obj) {\n-        println(\"name=\" + obj.getNameIndex());\n-        println(\"descriptor=\" + obj.getDescriptorIndex());\n-    }\n-\n-    public void enterStringEntry(StringEntry obj) {\n-        println(\"index=\" + obj.getStringIndex());\n-    }\n-\n-    public void enterUTF8Entry(UTF8Entry obj) {\n-        println(\"value=\" + obj.getValue());\n-    }\n-\n-    private void println(String ln) {\n-        _out.print(_prefix);\n-        _out.println(ln);\n-    }\n-\n-    private void openBlock(String name) {\n-        println(name + \" {\");\n-        _prefix += \"  \";\n-    }\n-\n-    private void closeBlock() {\n-        _prefix = _prefix.substring(2);\n-        println(\"}\");\n-    }\n-}"},{"sha":"5e3c408b59c6309c2dde47898d9b81853da419ed","filename":"serp/src/main/java/serp/bytecode/visitor/VisitAcceptor.java","status":"removed","additions":0,"deletions":32,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/visitor/VisitAcceptor.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/visitor/VisitAcceptor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/visitor/VisitAcceptor.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,32 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.bytecode.visitor;\n-\n-/**\n- * Interface denoting an entity that can accept a {@link BCVisitor} and\n- * provide its internal state to it. All entities in the bytecode framework\n- * implement this interface.\n- *\n- * @author Abe White\n- */\n-public interface VisitAcceptor {\n-\n-    /**\n-     * Accept a visit from a {@link BCVisitor}, calling the appropriate methods\n-     * to notify the visitor that it has entered this entity, and\n-     * to provide it with the proper callbacks for each sub-entity owned\n-     * by this one.\n-     */\n-    public void acceptVisit(BCVisitor visitor);\n-}\n-"},{"sha":"ea3ee7657e079cb30ed2e892fa608f4412fb9f91","filename":"serp/src/main/java/serp/bytecode/visitor/package.html","status":"removed","additions":0,"deletions":11,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/visitor/package.html","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/visitor/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/visitor/package.html?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,11 +0,0 @@\n-<html>\n-<body>\n-<p><strong>Bytecode Visitor</strong></p>\n-\n-<p>\n-    This package implements the visitor pattern on bytecode entities\n-    and provides a useful concrete visitor that pretty-prints a detailed\n-    document describing any bytecode entity.\n-</p>\n-</body>\n-</html>"},{"sha":"91bccc8cffc619e492911ef6d1751e07a59f4269","filename":"serp/src/main/java/serp/util/Numbers.java","status":"removed","additions":0,"deletions":57,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/util/Numbers.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/util/Numbers.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/util/Numbers.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,57 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package serp.util;\n-\n-/**\n- * Number utilities.\n- *\n- * @author Abe White\n- */\n-public class Numbers {\n-\n-    private static final Integer INT_NEGONE = new Integer(-1);\n-    private static final Long LONG_NEGONE = new Long(-1);\n-    private static final Integer[] INTEGERS = new Integer[50];\n-    private static final Long[] LONGS = new Long[50];\n-\n-    static {\n-        for (int i = 0; i < INTEGERS.length; i++)\n-            INTEGERS[i] = new Integer(i);\n-        for (int i = 0; i < LONGS.length; i++)\n-            LONGS[i] = new Long(i);\n-    }\n-\n-    /**\n-     * Return the wrapper for the given number, taking advantage of cached\n-     * common values.\n-     */\n-    public static Integer valueOf(int n) {\n-        if (n == -1)\n-            return INT_NEGONE;\n-        if (n >= 0 && n < INTEGERS.length)\n-            return INTEGERS[n];\n-        return new Integer(n);\n-    }\n-\n-    /**\n-     * Return the wrapper for the given number, taking advantage of cached\n-     * common values.\n-     */\n-    public static Long valueOf(long n) {\n-        if (n == -1)\n-            return LONG_NEGONE;\n-        if (n >= 0 && n < LONGS.length)\n-            return LONGS[(int) n];\n-        return new Long(n);\n-    }\n-}"},{"sha":"8c223bacf75ccc0ae74c8aeae031d55811c6d911","filename":"serp/src/main/java/serp/util/Strings.java","status":"removed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/util/Strings.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/util/Strings.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/util/Strings.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"94ac73a0d5dc5cbd055311597d94223d32b2360b","filename":"serp/src/main/java/serp/util/package.html","status":"removed","additions":0,"deletions":9,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/util/package.html","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/util/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/util/package.html?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"adfb3f17292a3dfb4a956c67ad2df43ae5d04f06","filename":"serp/src/test/java/serp/bytecode/AbstractStateTest.java","status":"removed","additions":0,"deletions":191,"changes":191,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/AbstractStateTest.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/AbstractStateTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/AbstractStateTest.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"34619ead5a4f89d964f5c923e02e45d34a4dc0c2","filename":"serp/src/test/java/serp/bytecode/TestArray.java","status":"removed","additions":0,"deletions":82,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestArray.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestArray.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestArray.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"f9c38f615af44ccb24f5e78d03d1408ecdf723b7","filename":"serp/src/test/java/serp/bytecode/TestArrayLoadInstruction.java","status":"removed","additions":0,"deletions":94,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestArrayLoadInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestArrayLoadInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestArrayLoadInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"74590a9fc40d90967d31fc856da8de4fbcfe0259","filename":"serp/src/test/java/serp/bytecode/TestArrayStoreInstruction.java","status":"removed","additions":0,"deletions":95,"changes":95,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestArrayStoreInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestArrayStoreInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestArrayStoreInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a275153a8b06aeab8cc3e985b01b3ec6655b9531","filename":"serp/src/test/java/serp/bytecode/TestAttributes.java","status":"removed","additions":0,"deletions":159,"changes":159,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestAttributes.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestAttributes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestAttributes.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"84a3d40e2a6d4d4b6586558e88f23b4d2a5bc42b","filename":"serp/src/test/java/serp/bytecode/TestBCClass.java","status":"removed","additions":0,"deletions":266,"changes":266,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestBCClass.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestBCClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestBCClass.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"70fc70d53b0a0ba67faae5f8d1b7f91b186ca839","filename":"serp/src/test/java/serp/bytecode/TestCode.java","status":"removed","additions":0,"deletions":137,"changes":137,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestCode.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestCode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestCode.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b7d073613efa6e21d41179263b1670694c940e4b","filename":"serp/src/test/java/serp/bytecode/TestConstantInstruction.java","status":"removed","additions":0,"deletions":125,"changes":125,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestConstantInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestConstantInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestConstantInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a4b025dfe54fc1a58e15f851864f56c0ce25ba82","filename":"serp/src/test/java/serp/bytecode/TestConvertInstruction.java","status":"removed","additions":0,"deletions":97,"changes":97,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestConvertInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestConvertInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestConvertInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"2f04c26d54269e5d7994619acb2e83e942cb1109","filename":"serp/src/test/java/serp/bytecode/TestLoadInstruction.java","status":"removed","additions":0,"deletions":177,"changes":177,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestLoadInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestLoadInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestLoadInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ef3a2a4b8ebe4b019f0d8affc378b2c6ceaa45ac","filename":"serp/src/test/java/serp/bytecode/TestMathInstruction.java","status":"removed","additions":0,"deletions":345,"changes":345,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestMathInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestMathInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestMathInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b201097b01bce30443414059fa043e354245b607","filename":"serp/src/test/java/serp/bytecode/TestNameCache.java","status":"removed","additions":0,"deletions":216,"changes":216,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestNameCache.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestNameCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestNameCache.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"71072ea94651878b6a02b15151dd4ea22358fd35","filename":"serp/src/test/java/serp/bytecode/TestPrimitive.java","status":"removed","additions":0,"deletions":69,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestPrimitive.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestPrimitive.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestPrimitive.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"621c163b018c31f50917239338969c2984d93f8b","filename":"serp/src/test/java/serp/bytecode/TestProject.java","status":"removed","additions":0,"deletions":318,"changes":318,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestProject.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestProject.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestProject.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"3e0529987069aa3ad45e2e0752b1eef762202ca0","filename":"serp/src/test/java/serp/bytecode/TestStoreInstruction.java","status":"removed","additions":0,"deletions":177,"changes":177,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestStoreInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/TestStoreInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestStoreInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"e68844dc1f838d05721e074e7f17ef1d81023e01","filename":"serp/src/test/java/serp/bytecode/lowlevel/TestConstantPool.java","status":"removed","additions":0,"deletions":356,"changes":356,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/lowlevel/TestConstantPool.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/bytecode/lowlevel/TestConstantPool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/lowlevel/TestConstantPool.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"6fd7102a305357ee708a7d58bd9b8af23684c5ba","filename":"serp/src/test/java/serp/util/TestStrings.java","status":"removed","additions":0,"deletions":127,"changes":127,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/util/TestStrings.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/test/java/serp/util/TestStrings.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/util/TestStrings.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"}]}

