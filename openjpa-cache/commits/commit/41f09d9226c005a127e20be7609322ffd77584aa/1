{"sha":"41f09d9226c005a127e20be7609322ffd77584aa","node_id":"MDY6Q29tbWl0MjA2MzY0OjQxZjA5ZDkyMjZjMDA1YTEyN2UyMGJlNzYwOTMyMmZmZDc3NTg0YWE=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2011-06-14T21:33:28Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2011-06-14T21:33:28Z"},"message":"OPENJPA-2008: Draft support for native SQL in Slice\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@1135806 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"be1e6c77bbac6162ac041060151fa0729853f936","url":"https://api.github.com/repos/apache/openjpa/git/trees/be1e6c77bbac6162ac041060151fa0729853f936"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/41f09d9226c005a127e20be7609322ffd77584aa","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/41f09d9226c005a127e20be7609322ffd77584aa","html_url":"https://github.com/apache/openjpa/commit/41f09d9226c005a127e20be7609322ffd77584aa","comments_url":"https://api.github.com/repos/apache/openjpa/commits/41f09d9226c005a127e20be7609322ffd77584aa/comments","author":null,"committer":null,"parents":[{"sha":"9be9d836c4ad883292a60c8b0df1366dae56b808","url":"https://api.github.com/repos/apache/openjpa/commits/9be9d836c4ad883292a60c8b0df1366dae56b808","html_url":"https://github.com/apache/openjpa/commit/9be9d836c4ad883292a60c8b0df1366dae56b808"}],"stats":{"total":307,"additions":306,"deletions":1},"files":[{"sha":"bdd17e99eabe7e13b2e39de1bf0bac5a2b0df03f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/41f09d9226c005a127e20be7609322ffd77584aa/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/41f09d9226c005a127e20be7609322ffd77584aa/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java?ref=41f09d9226c005a127e20be7609322ffd77584aa","patch":"@@ -98,7 +98,7 @@ public boolean requiresParameterDeclarations() {\n     /**\n      * Executes the filter as a SQL query.\n      */\n-    protected static class SQLExecutor\n+    public static class SQLExecutor\n         extends AbstractExecutor {\n \n         private final ClassMetaData _meta;"},{"sha":"8cfd194402172263d70a7d65540381459d8680e7","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCStoreManager.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/41f09d9226c005a127e20be7609322ffd77584aa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/41f09d9226c005a127e20be7609322ffd77584aa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCStoreManager.java?ref=41f09d9226c005a127e20be7609322ffd77584aa","patch":"@@ -41,6 +41,7 @@\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfigurationImpl;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.kernel.JDBCStoreManager;\n+import org.apache.openjpa.jdbc.kernel.SQLStoreQuery;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.ResultSetResult;\n import org.apache.openjpa.kernel.FetchConfiguration;\n@@ -437,7 +438,18 @@ public Object newDataStoreId(Object oidVal, ClassMetaData meta) {\n      * Construct a distributed query to be executed against all the slices.\n      */\n     public StoreQuery newQuery(String language) {\n+    \tif (QueryLanguages.LANG_SQL.equals(language)) {\n+    \t\tDistributedSQLStoreQuery ret = new DistributedSQLStoreQuery(this);\n+            for (SliceStoreManager slice : _slices) {\n+                ret.add(slice.newQuery(language));\n+            }\n+            return ret;\n+    \t}\n         ExpressionParser parser = QueryLanguages.parserForLanguage(language);\n+        if (parser == null) {\n+    \t\tthrow new UnsupportedOperationException(\"Language [\" + language + \"] not supported\");\n+        } \n+\n         DistributedStoreQuery ret = new DistributedStoreQuery(this, parser);\n         for (SliceStoreManager slice : _slices) {\n             ret.add(slice.newQuery(language));"},{"sha":"7b2a86b2465d1c2b8b87a7db3a96a6284a3fe840","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedSQLStoreQuery.java","status":"added","additions":293,"deletions":0,"changes":293,"blob_url":"https://github.com/apache/openjpa/blob/41f09d9226c005a127e20be7609322ffd77584aa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedSQLStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/41f09d9226c005a127e20be7609322ffd77584aa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedSQLStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedSQLStoreQuery.java?ref=41f09d9226c005a127e20be7609322ffd77584aa","patch":"@@ -0,0 +1,293 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.jdbc;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.concurrent.Callable;\r\n+import java.util.concurrent.ExecutionException;\r\n+import java.util.concurrent.ExecutorService;\r\n+import java.util.concurrent.Future;\r\n+import java.util.concurrent.SynchronousQueue;\r\n+import java.util.concurrent.ThreadFactory;\r\n+import java.util.concurrent.ThreadPoolExecutor;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\r\n+import org.apache.openjpa.jdbc.kernel.JDBCStoreQuery;\r\n+import org.apache.openjpa.jdbc.kernel.SQLStoreQuery;\r\n+import org.apache.openjpa.kernel.AbstractStoreQuery;\r\n+import org.apache.openjpa.kernel.BrokerImpl;\r\n+import org.apache.openjpa.kernel.ExpressionStoreQuery;\r\n+import org.apache.openjpa.kernel.FetchConfiguration;\r\n+import org.apache.openjpa.kernel.OrderingMergedResultObjectProvider;\r\n+import org.apache.openjpa.kernel.QueryContext;\r\n+import org.apache.openjpa.kernel.QueryImpl;\r\n+import org.apache.openjpa.kernel.StoreManager;\r\n+import org.apache.openjpa.kernel.StoreQuery;\r\n+import org.apache.openjpa.kernel.exps.ExpressionParser;\r\n+import org.apache.openjpa.lib.rop.MergedResultObjectProvider;\r\n+import org.apache.openjpa.lib.rop.RangeResultObjectProvider;\r\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.slice.DistributedConfiguration;\r\n+import org.apache.openjpa.slice.SliceThread;\r\n+import org.apache.openjpa.util.StoreException;\r\n+\r\n+/**\r\n+ * A query for distributed databases.\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ * \r\n+ */\r\n+@SuppressWarnings(\"serial\")\r\n+class DistributedSQLStoreQuery extends SQLStoreQuery {\r\n+\tprivate List<StoreQuery> _queries = new ArrayList<StoreQuery>();\r\n+\r\n+\tpublic DistributedSQLStoreQuery(JDBCStore store) {\r\n+\t\tsuper(store);\r\n+\t}\r\n+\r\n+\tvoid add(StoreQuery q) {\r\n+\t\t_queries.add(q);\r\n+\t}\r\n+\r\n+\tpublic DistributedJDBCStoreManager getDistributedStore() {\r\n+\t\treturn (DistributedJDBCStoreManager) getStore();\r\n+\t}\r\n+\r\n+\tpublic Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\r\n+\t\tboolean parallel = !getContext().getStoreContext().getBroker()\r\n+\t\t\t.getMultithreaded();\r\n+        ParallelExecutor ex = new ParallelExecutor(this, meta, parallel);\r\n+\t\tfor (StoreQuery q : _queries) {\r\n+\t\t\tex.addExecutor(q.newDataStoreExecutor(meta, subs));\r\n+\t\t}\r\n+\t\treturn ex;\r\n+\t}\r\n+\r\n+\tpublic void setContext(QueryContext ctx) {\r\n+\t\tsuper.setContext(ctx);\r\n+\t\tfor (StoreQuery q : _queries)\r\n+\t\t\tq.setContext(ctx);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Executes queries on multiple databases.\r\n+\t * \r\n+\t * @author Pinaki Poddar\r\n+\t * \r\n+\t */\r\n+\tpublic static class ParallelExecutor extends\r\n+\t\t\tSQLStoreQuery.SQLExecutor {\r\n+\t\tprivate List<Executor> executors = new ArrayList<Executor>();\r\n+\t\tprivate DistributedSQLStoreQuery owner = null;\r\n+\r\n+        public ParallelExecutor(DistributedSQLStoreQuery dsq, ClassMetaData meta, boolean p) {\r\n+\t\t\tsuper(dsq, meta);\r\n+\t\t\towner = dsq;\r\n+\t\t}\r\n+\r\n+\t\tpublic void addExecutor(Executor ex) {\r\n+\t\t\texecutors.add(ex);\r\n+\t\t}\r\n+\r\n+\t\t/**\r\n+         * Each child query must be executed with slice context and not the\r\n+\t\t * given query context.\r\n+\t\t */\r\n+\t\tpublic ResultObjectProvider executeQuery(StoreQuery q,\r\n+\t\t\t\tfinal Object[] params, final Range range) {\r\n+\t\t\tList<Future<ResultObjectProvider>> futures = \r\n+\t\t\t\tnew ArrayList<Future<ResultObjectProvider>>();\r\n+            final List<Executor> usedExecutors = new ArrayList<Executor>();\r\n+\t\t\tfinal List<ResultObjectProvider> rops = \r\n+\t\t\t\tnew ArrayList<ResultObjectProvider>();\r\n+\t\t\tList<SliceStoreManager> targets = findTargets();\r\n+\t\t\tQueryContext ctx = q.getContext();\r\n+\t\t\tboolean isReplicated = containsReplicated(ctx);\r\n+            ExecutorService threadPool = SliceThread.getPool();\r\n+\t\t\tfor (int i = 0; i < owner._queries.size(); i++) {\r\n+                // if replicated, then execute only on single slice\r\n+\t\t\t\tif (isReplicated && !usedExecutors.isEmpty()) {\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\t}\r\n+                StoreManager sm = owner.getDistributedStore().getSlice(i);\r\n+\t\t\t\tif (!targets.contains(sm))\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\tStoreQuery query = owner._queries.get(i);\r\n+\t\t\t\tExecutor executor = executors.get(i);\r\n+\t\t\t\tif (!targets.contains(sm))\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\tusedExecutors.add(executor);\r\n+                QueryExecutor call = new QueryExecutor();\r\n+                call.executor = executor;\r\n+                call.query = query;\r\n+                call.params = params;\r\n+                call.range = range;\r\n+                futures.add(threadPool.submit(call));\r\n+\t\t\t}\r\n+\t\t\tfor (Future<ResultObjectProvider> future : futures) {\r\n+\t\t\t\ttry {\r\n+\t\t\t\t\trops.add(future.get());\r\n+\t\t\t\t} catch (InterruptedException e) {\r\n+\t\t\t\t\tthrow new RuntimeException(e);\r\n+\t\t\t\t} catch (ExecutionException e) {\r\n+\t\t\t\t\tthrow new StoreException(e.getCause());\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tResultObjectProvider[] tmp = rops\r\n+                    .toArray(new ResultObjectProvider[rops.size()]);\r\n+\t\t\tResultObjectProvider result = null;\r\n+\t\t\tboolean[] ascending = getAscending(q);\r\n+\t\t\tboolean isAscending = ascending.length > 0;\r\n+\t\t\tboolean isAggregate = ctx.isAggregate();\r\n+\t\t\tboolean hasRange = ctx.getEndRange() != Long.MAX_VALUE;\r\n+\t\t\tif (isAggregate) {\r\n+\t\t\t\tresult = new UniqueResultObjectProvider(tmp, q,\r\n+\t\t\t\t\t\tgetQueryExpressions());\r\n+\t\t\t} else if (isAscending) {\r\n+                result = new OrderingMergedResultObjectProvider(tmp, ascending,\r\n+                    usedExecutors.toArray(new Executor[usedExecutors.size()]),\r\n+\t\t\t\t\tq, params);\r\n+\t\t\t} else {\r\n+\t\t\t\tresult = new MergedResultObjectProvider(tmp);\r\n+\t\t\t}\r\n+\t\t\tif (hasRange) {\r\n+                result = new RangeResultObjectProvider(result,\r\n+                        ctx.getStartRange(), ctx.getEndRange());\r\n+\t\t\t}\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t/**\r\n+         * Scans metadata to find out if a replicated class is the candidate.\r\n+\t\t */\r\n+\t\tboolean containsReplicated(QueryContext query) {\r\n+\t\t\tClass<?> candidate = query.getCandidateType();\r\n+\t\t\tDistributedConfiguration conf = (DistributedConfiguration)query.getStoreContext()\r\n+\t\t\t    .getConfiguration();\r\n+\t\t\tif (candidate != null) {\r\n+\t\t\t    return conf.isReplicated(candidate);\r\n+\t\t\t}\r\n+\t\t\tClassMetaData[] metas = query.getAccessPathMetaDatas();\r\n+\t\t\tif (metas == null || metas.length < 1)\r\n+\t\t\t\treturn false;\r\n+\t\t\tfor (ClassMetaData meta : metas)\r\n+\t\t\t\tif (conf.isReplicated(meta.getDescribedType()))\r\n+\t\t\t\t\treturn true;\r\n+\t\t\treturn false;\r\n+\t\t}\r\n+\r\n+\t\tpublic Number executeDelete(StoreQuery q, Object[] params) {\r\n+\t\t\tIterator<StoreQuery> qs = owner._queries.iterator();\r\n+\t\t\tList<Future<Number>> futures = null;\r\n+\t\t\tint result = 0;\r\n+            ExecutorService threadPool = SliceThread.getPool();\r\n+\t\t\tfor (Executor ex : executors) {\r\n+\t\t\t\tif (futures == null)\r\n+                    futures = new ArrayList<Future<Number>>();\r\n+\t\t\t\tDeleteExecutor call = new DeleteExecutor();\r\n+\t\t\t\tcall.executor = ex;\r\n+\t\t\t\tcall.query = qs.next();\r\n+\t\t\t\tcall.params = params;\r\n+\t\t\t\tfutures.add(threadPool.submit(call));\r\n+\t\t\t}\r\n+\t\t\tfor (Future<Number> future : futures) {\r\n+\t\t\t\ttry {\r\n+\t\t\t\t\tNumber n = future.get();\r\n+\t\t\t\t\tif (n != null)\r\n+\t\t\t\t\t\tresult += n.intValue();\r\n+\t\t\t\t} catch (InterruptedException e) {\r\n+\t\t\t\t\tthrow new RuntimeException(e);\r\n+\t\t\t\t} catch (ExecutionException e) {\r\n+\t\t\t\t\tthrow new StoreException(e.getCause());\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\tpublic Number executeUpdate(StoreQuery q, Object[] params) {\r\n+\t\t\tIterator<StoreQuery> qs = owner._queries.iterator();\r\n+\t\t\tList<Future<Number>> futures = null;\r\n+\t\t\tint result = 0;\r\n+            ExecutorService threadPool = SliceThread.getPool();\r\n+\t\t\tfor (Executor ex : executors) {\r\n+\t\t\t\tif (futures == null)\r\n+                    futures = new ArrayList<Future<Number>>();\r\n+\t\t\t\tUpdateExecutor call = new UpdateExecutor();\r\n+\t\t\t\tcall.executor = ex;\r\n+\t\t\t\tcall.query = qs.next();\r\n+\t\t\t\tcall.params = params;\r\n+\t\t\t\tfutures.add(threadPool.submit(call));\r\n+\t\t\t}\r\n+\t\t\tfor (Future<Number> future : futures) {\r\n+\t\t\t\ttry {\r\n+\t\t\t\t\tNumber n = future.get();\r\n+                    result += (n == null) ? 0 : n.intValue();\r\n+\t\t\t\t} catch (InterruptedException e) {\r\n+\t\t\t\t\tthrow new RuntimeException(e);\r\n+\t\t\t\t} catch (ExecutionException e) {\r\n+\t\t\t\t\tthrow new StoreException(e.getCause());\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\tList<SliceStoreManager> findTargets() {\r\n+\t\t\tFetchConfiguration fetch = owner.getContext()\r\n+\t\t\t\t\t.getFetchConfiguration();\r\n+\t\t\treturn owner.getDistributedStore().getTargets(fetch);\r\n+\t\t}\r\n+\t\t\r\n+\t}\r\n+\r\n+\tstatic class QueryExecutor implements Callable<ResultObjectProvider> {\r\n+\t\tStoreQuery query;\r\n+\t\tExecutor executor;\r\n+\t\tObject[] params;\r\n+\t\tRange range;\r\n+\r\n+\t\tpublic ResultObjectProvider call() throws Exception {\r\n+\t\t\treturn executor.executeQuery(query, params, range);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic class DeleteExecutor implements Callable<Number> {\r\n+\t\tStoreQuery query;\r\n+\t\tExecutor executor;\r\n+\t\tObject[] params;\r\n+\r\n+\t\tpublic Number call() throws Exception {\r\n+\t\t\treturn executor.executeDelete(query, params);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic class UpdateExecutor implements Callable<Number> {\r\n+\t\tStoreQuery query;\r\n+\t\tExecutor executor;\r\n+\t\tObject[] params;\r\n+\r\n+\t\tpublic Number call() throws Exception {\r\n+\t\t    return executor.executeUpdate(query, params);\r\n+\t\t}\r\n+\t}\r\n+}\r"}]}

