{"sha":"423b0a418af03102a95b1c7472665d5cd7c57b11","node_id":"MDY6Q29tbWl0MjA2MzY0OjQyM2IwYTQxOGFmMDMxMDJhOTViMWM3NDcyNjY1ZDVjZDdjNTdiMTE=","commit":{"author":{"name":"Stephen Kim","email":"skim@apache.org","date":"2006-09-01T17:16:50Z"},"committer":{"name":"Stephen Kim","email":"skim@apache.org","date":"2006-09-01T17:16:50Z"},"message":"Support for managed interfaces\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@439383 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1f65b12fee18bd14c682bcd24a6d197b62c168cb","url":"https://api.github.com/repos/apache/openjpa/git/trees/1f65b12fee18bd14c682bcd24a6d197b62c168cb"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/423b0a418af03102a95b1c7472665d5cd7c57b11","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/423b0a418af03102a95b1c7472665d5cd7c57b11","html_url":"https://github.com/apache/openjpa/commit/423b0a418af03102a95b1c7472665d5cd7c57b11","comments_url":"https://api.github.com/repos/apache/openjpa/commits/423b0a418af03102a95b1c7472665d5cd7c57b11/comments","author":null,"committer":null,"parents":[{"sha":"c39b7141ce03379cd66f7799a46cf3c019ba3fdc","url":"https://api.github.com/repos/apache/openjpa/commits/c39b7141ce03379cd66f7799a46cf3c019ba3fdc","html_url":"https://github.com/apache/openjpa/commit/c39b7141ce03379cd66f7799a46cf3c019ba3fdc"}],"stats":{"total":287,"additions":240,"deletions":47},"files":[{"sha":"5c2e2a3e4f6f04ba4e30d2354effc3b0306ab688","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","status":"modified","additions":70,"deletions":28,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","raw_url":"https://github.com/apache/openjpa/raw/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java?ref=423b0a418af03102a95b1c7472665d5cd7c57b11","patch":"@@ -90,8 +90,9 @@\n \n     public static final int ENHANCE_NONE = 0;\n     public static final int ENHANCE_AWARE = 2 << 0;\n-    public static final int ENHANCE_PC = 2 << 1;\n-    public static final int ENHANCE_OID = 2 << 2;\n+    public static final int ENHANCE_INTERFACE = 2 << 1;\n+    public static final int ENHANCE_PC = 2 << 2;\n+    public static final int ENHANCE_OID = 2 << 3;\n \n     private static final String PRE = \"pc\";\n     private static final Class PCTYPE = PersistenceCapable.class;\n@@ -127,7 +128,7 @@\n      * Constructor. Supply configuration and type to enhance.\n      */\n     public PCEnhancer(OpenJPAConfiguration conf, Class type) {\n-        this(conf, new Project().loadClass(type), null);\n+        this(conf, new Project().loadClass(type), (MetaDataRepository) null);\n     }\n \n     /**\n@@ -163,6 +164,17 @@ public PCEnhancer(OpenJPAConfiguration conf, BCClass type,\n         _meta = _repos.getMetaData(type.getType(), null, false);\n     }\n \n+    /**\n+     * Constructor. Supply configuration, type, and metadata.\n+     */\n+    public PCEnhancer(OpenJPAConfiguration conf, BCClass type,\n+        ClassMetaData meta) {\n+        _pc = type;\n+        _log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\n+        _repos = meta.getRepository();\n+        _meta = meta;\n+    }\n+\n     /**\n      * Return the bytecode representation of the class being manipulated.\n      */\n@@ -266,6 +278,10 @@ public int run() {\n             _log.trace(_loc.get(\"enhance-start\", _pc.getType()));\n \n         try {\n+            // if managed interface, skip\n+            if (_pc.isInterface())\n+                return ENHANCE_INTERFACE;\n+\n             // check if already enhanced\n             Class[] interfaces = _pc.getDeclaredInterfaceTypes();\n             for (int i = 0; i < interfaces.length; i++) {\n@@ -612,13 +628,13 @@ private void replaceAndValidateFieldAccess(Code code, Instruction ins,\n             String prefix = (get) ? PRE + \"Get\" : PRE + \"Set\";\n             methodName = prefix + name;\n             if (get) {\n-                mi.setMethod(owner.getDescribedType().getName(),\n+                mi.setMethod(getType(owner).getName(),\n                     methodName, typeName, new String[]\n-                    { owner.getDescribedType().getName() });\n+                    { getType(owner).getName() });\n             } else {\n-                mi.setMethod(owner.getDescribedType().getName(),\n+                mi.setMethod(getType(owner).getName(),\n                     methodName, \"void\", new String[]\n-                    { owner.getDescribedType().getName(), typeName });\n+                    { getType(owner).getName(), typeName });\n             }\n         }\n     }\n@@ -659,6 +675,10 @@ private ClassMetaData getPersistenceCapableOwner(String fieldName,\n         if (owner.getName().equals(Object.class.getName()))\n             return null;\n \n+        // managed interface\n+        if (_meta != null && _meta.getDescribedType().isInterface())\n+            return _meta;\n+\n         return _repos.getMetaData(owner, null, false);\n     }\n \n@@ -722,8 +742,9 @@ private void addClearFieldsMethod()\n         // super.pcClearFields ()\n         if (_meta.getPCSuperclass() != null) {\n             code.aload().setThis();\n-            code.invokespecial().setMethod(_meta.getPCSuperclass(),\n-                PRE + \"ClearFields\", void.class, null);\n+            code.invokespecial().setMethod(getType(_meta.\n+                getPCSuperclassMetaData()), PRE + \"ClearFields\", void.class, \n+                null);\n         }\n \n         FieldMetaData[] fmds = _meta.getDeclaredFields();\n@@ -849,7 +870,8 @@ private void addManagedFieldCountMethod() {\n         // return <fields> + <superclass>.pcGetManagedFieldCount ()\n         code.constant().setValue(_meta.getDeclaredFields().length);\n         if (_meta.getPCSuperclass() != null) {\n-            code.invokestatic().setMethod(_meta.getPCSuperclass().getName(),\n+            code.invokestatic().setMethod(getType(_meta.\n+                getPCSuperclassMetaData()).getName(),\n                 PRE + \"GetManagedFieldCount\", int.class.getName(), null);\n             code.iadd();\n         }\n@@ -1039,14 +1061,15 @@ private int beginSwitchMethod(String name, Code code) {\n             loadManagedInstance(code, false);\n             String[] args;\n             if (copy) {\n-                args = new String[]{ _meta.getPCSuperclass().getName(),\n-                    int.class.getName() };\n+                args = new String[]{ getType(_meta.getPCSuperclassMetaData()).\n+                    getName(), int.class.getName() };\n                 code.aload().setParam(0);\n             } else\n                 args = new String[]{ int.class.getName() };\n             code.iload().setParam(fieldNumber);\n-            code.invokespecial().setMethod(_meta.getPCSuperclass().\n-                getName(), name, void.class.getName(), args);\n+            code.invokespecial().setMethod(getType(_meta.\n+                getPCSuperclassMetaData()).getName(), name, \n+                void.class.getName(), args);\n             code.vreturn();\n         } else\n             throwException(code, IllegalArgumentException.class);\n@@ -1442,7 +1465,8 @@ private void addCopyKeyFieldsToObjectIdMethod(boolean fieldManager)\n             loadManagedInstance(code, false);\n             for (int i = 0; i < args.length; i++)\n                 code.aload().setParam(i);\n-            code.invokespecial().setMethod(_meta.getPCSuperclass().getName(),\n+            code.invokespecial().setMethod(getType(_meta.\n+                getPCSuperclassMetaData()).getName(),\n                 PRE + \"CopyKeyFieldsToObjectId\", void.class.getName(), args);\n         }\n \n@@ -1535,7 +1559,8 @@ private void addCopyKeyFieldsFromObjectIdMethod(boolean fieldManager)\n             loadManagedInstance(code, false);\n             for (int i = 0; i < args.length; i++)\n                 code.aload().setParam(i);\n-            code.invokespecial().setMethod(_meta.getPCSuperclass().getName(),\n+            code.invokespecial().setMethod(getType(_meta.\n+                getPCSuperclassMetaData()).getName(),\n                 PRE + \"CopyKeyFieldsFromObjectId\", void.class.getName(), args);\n         }\n \n@@ -1729,14 +1754,14 @@ private void addNewObjectIdInstanceMethod(boolean obj)\n             // new ObjectId (cls, oid)\n             code.anew().setType(ObjectId.class);\n             code.dup();\n-            code.classconstant().setClass(_meta.getDescribedType());\n+            code.classconstant().setClass(getType(_meta));\n         }\n \n         // new <oid class> ();\n         code.anew().setType(oidType);\n         code.dup();\n         if (_meta.isOpenJPAIdentity() || (obj && usesClsString == Boolean.TRUE))\n-            code.classconstant().setClass(_meta.getDescribedType());\n+            code.classconstant().setClass(getType(_meta));\n         if (obj) {\n             code.aload().setParam(0);\n             code.checkcast().setType(String.class);\n@@ -1926,12 +1951,14 @@ private void addStaticInitializer() {\n         Code code = getOrCreateClassInitCode(true);\n         if (_meta.getPCSuperclass() != null) {\n             // pcInheritedFieldCount = <superClass>.pcGetManagedFieldCount()\n-            code.invokestatic().setMethod(_meta.getPCSuperclass().getName(),\n+            code.invokestatic().setMethod(getType(_meta.\n+                getPCSuperclassMetaData()).getName(), \n                 PRE + \"GetManagedFieldCount\", int.class.getName(), null);\n             code.putstatic().setField(INHERIT, int.class);\n \n             // pcPCSuperclass = <superClass>;\n-            code.classconstant().setClass(_meta.getPCSuperclass());\n+            code.classconstant().setClass(getType(_meta.\n+                getPCSuperclassMetaData()));\n             code.putstatic().setField(SUPER, Class.class);\n         }\n \n@@ -2961,7 +2988,7 @@ private void addReadExternal(boolean parentDetachable,\n         // readUnmanaged (in);\n         loadManagedInstance(code, false);\n         code.aload().setParam(0);\n-        code.invokevirtual().setMethod(_meta.getDescribedType(),\n+        code.invokevirtual().setMethod(getType(_meta),\n             PRE + \"ReadUnmanaged\", void.class, inargs);\n \n         if (detachedState) {\n@@ -3013,8 +3040,9 @@ private void addReadUnmanaged(Collection unmgd, boolean parentDetachable)\n         if (parentDetachable) {\n             loadManagedInstance(code, false);\n             code.aload().setParam(0);\n-            code.invokespecial().setMethod(_meta.getPCSuperclass(),\n-                PRE + \"ReadUnmanaged\", void.class, inargs);\n+            code.invokespecial().setMethod(getType(_meta.\n+                getPCSuperclassMetaData()), PRE + \"ReadUnmanaged\", void.class, \n+                inargs);\n         }\n \n         // read declared unmanaged serializable fields\n@@ -3091,7 +3119,7 @@ private void addWriteExternal(boolean parentDetachable,\n         Code code = meth.getCode(true);\n \n         // super.writeExternal (out);\n-        Class sup = _meta.getDescribedType().getSuperclass();\n+        Class sup = getType(_meta).getSuperclass();\n         if (!parentDetachable && Externalizable.class.isAssignableFrom(sup)) {\n             loadManagedInstance(code, false);\n             code.aload().setParam(0);\n@@ -3102,7 +3130,7 @@ private void addWriteExternal(boolean parentDetachable,\n         // writeUnmanaged (out);\n         loadManagedInstance(code, false);\n         code.aload().setParam(0);\n-        code.invokevirtual().setMethod(_meta.getDescribedType(),\n+        code.invokevirtual().setMethod(getType(_meta),\n             PRE + \"WriteUnmanaged\", void.class, outargs);\n \n         JumpInstruction go2 = null;\n@@ -3169,8 +3197,9 @@ private void addWriteUnmanaged(Collection unmgd, boolean parentDetachable)\n         if (parentDetachable) {\n             loadManagedInstance(code, false);\n             code.aload().setParam(0);\n-            code.invokespecial().setMethod(_meta.getPCSuperclass(),\n-                PRE + \"WriteUnmanaged\", void.class, outargs);\n+            code.invokespecial().setMethod(getType(_meta.\n+                getPCSuperclassMetaData()), PRE + \"WriteUnmanaged\", void.class, \n+                outargs);\n         }\n \n         // write declared unmanaged serializable fields\n@@ -3316,7 +3345,7 @@ private BCMethod createSetMethod(FieldMetaData fmd) {\n             // static void pcSet<field> (XXX inst, <fieldtype> value)\n             BCField field = _pc.getDeclaredField(fmd.getName());\n             setter = _pc.declareMethod(PRE + \"Set\" + fmd.getName(), void.class,\n-                new Class[]{ _meta.getDescribedType(), fmd.getDeclaredType() });\n+                new Class[]{ getType(_meta), fmd.getDeclaredType() });\n             setter.setAccessFlags(field.getAccessFlags()\n                 & ~Constants.ACCESS_TRANSIENT & ~Constants.ACCESS_VOLATILE);\n             setter.setStatic(true);\n@@ -3337,6 +3366,17 @@ private BCMethod createSetMethod(FieldMetaData fmd) {\n         return setter;\n     }\n \n+    /**\n+     * Return the concrete type for the given class, i.e. impl for managed\n+     * interfaces\n+     */\n+    public Class getType(ClassMetaData meta) {\n+        if (meta.getInterfaceImpl() != null)\n+            return meta.getInterfaceImpl();\n+        return meta.getDescribedType();\n+    }\n+\n+\n     /**\n      * Move code-related attributes from one method to another.\n      */\n@@ -3479,6 +3519,8 @@ public static boolean run(OpenJPAConfiguration conf, String[] args,\n             status = enhancer.run();\n             if (status == ENHANCE_NONE)\n                 log.info(_loc.get(\"enhance-norun\"));\n+            else if (status == ENHANCE_INTERFACE)\n+                log.info(_loc.get(\"enhance-interface\"));\n             else if (status == ENHANCE_AWARE) {\n                 log.info(_loc.get(\"enhance-aware\"));\n                 enhancer.record();"},{"sha":"51ff98d9c8ede1f6f162e2e74bbc0746b3fe2f01","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":10,"deletions":6,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=423b0a418af03102a95b1c7472665d5cd7c57b11","patch":"@@ -2494,6 +2494,9 @@ public OpenJPAStateManager embed(Object obj, Object id,\n \n             PersistenceCapable copy;\n             PCState state;\n+            Class type = meta.getDescribedType();\n+            if (type.isInterface())\n+                type = meta.getInterfaceImpl();\n             if (obj != null) {\n                 // give copy and the original instance the same state manager\n                 // so that we can copy fields from one to the other\n@@ -2512,8 +2515,7 @@ public OpenJPAStateManager embed(Object obj, Object id,\n                     // copy the instance.  we do this even if it doesn't already\n                     // have a state manager in case it is later assigned to a\n                     // PC field; at that point it's too late to copy\n-                    copy = PCRegistry.newInstance(meta.getDescribedType(),\n-                        copySM, false);\n+                    copy = PCRegistry.newInstance(type, copySM, false);\n                     int[] fields = new int[meta.getFields().length];\n                     for (int i = 0; i < fields.length; i++)\n                         fields[i] = i;\n@@ -2527,8 +2529,7 @@ public OpenJPAStateManager embed(Object obj, Object id,\n                         pc.pcReplaceStateManager(null);\n                 }\n             } else {\n-                copy = PCRegistry.newInstance(meta.getDescribedType(), sm,\n-                    false);\n+                copy = PCRegistry.newInstance(type, sm, false);\n                 if ((_flags & FLAG_ACTIVE) != 0 && !_optimistic)\n                     state = PCState.ECLEAN;\n                 else\n@@ -3986,8 +3987,11 @@ public void unlock() {\n     public Object newInstance(Class cls) {\n         assertOpen();\n \n-        //### JDO2\n-        if (cls.isInterface() || Modifier.isAbstract(cls.getModifiers()))\n+        if (cls.isInterface()) {\n+            ClassMetaData meta = _conf.getMetaDataRepositoryInstance().\n+                getMetaData(cls, _loader, true);\n+            cls = meta.getInterfaceImpl();\n+        } else if (Modifier.isAbstract(cls.getModifiers()))\n             throw new UnsupportedOperationException(_loc.get\n                 (\"new-abstract\", cls).getMessage());\n "},{"sha":"db1cbf004a8f1d9ebe4481ee523d4559fb0f4380","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=423b0a418af03102a95b1c7472665d5cd7c57b11","patch":"@@ -241,6 +241,8 @@ else if (sub.getObjectIdType() != _meta.getObjectIdType()) {\n             }\n             _meta = sub;\n         }\n+        if (cls.isInterface())\n+            cls = _meta.getInterfaceImpl();\n \n         PersistenceCapable inst = PCRegistry.newInstance(cls, this, _oid, true);\n         if (inst == null) {"},{"sha":"4ab3b9c37360afcebf509748f0c081e9f06be67f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","status":"modified","additions":15,"deletions":1,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java?ref=423b0a418af03102a95b1c7472665d5cd7c57b11","patch":"@@ -41,6 +41,7 @@\n \n     private int _access = ClassMetaData.ACCESS_FIELD;\n     private boolean _ignore = true;\n+    private boolean _interface = true;\n     private boolean _pcRegistry = true;\n     private int _callback = CALLBACK_RETHROW;\n \n@@ -170,7 +171,8 @@ private boolean populateFromPCRegistry(ClassMetaData meta) {\n      */\n     private void populateFromReflection(ClassMetaData meta) {\n         Member[] members;\n-        if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD)\n+        boolean iface = meta.getDescribedType().isInterface();\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD && !iface)\n             members = meta.getDescribedType().getDeclaredFields();\n         else\n             members = meta.getDescribedType().getDeclaredMethods();\n@@ -263,6 +265,14 @@ protected boolean isReservedFieldName(String name) {\n     protected abstract boolean isDefaultPersistent(ClassMetaData meta,\n         Member member, String name);\n \n+    public void setDeclaredInterfacePersistent(boolean pers) {\n+        _interface = pers;\n+    }\n+\n+    public boolean isDeclaredInterfacePersistent() {\n+        return _interface;\n+    }\n+\n     public Member getBackingMember(FieldMetaData fmd) {\n         if (fmd == null)\n             return null;\n@@ -321,6 +331,10 @@ private Method getBackingMethod(Class cls, String name,\n             new String[]{ name, clsName, \"get\" + capName, \"is\" + capName }));\n     }\n \n+    public Class getUnimplementedExceptionType() {\n+        return UnsupportedOperationException.class;\n+    }\n+\n     /**\n      * Helper method; returns true if the given class appears to be\n      * user-defined."},{"sha":"8d271f09c4030bcc9b42569ba8f24bc2f930f65b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","status":"modified","additions":51,"deletions":4,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java?ref=423b0a418af03102a95b1c7472665d5cd7c57b11","patch":"@@ -140,6 +140,8 @@\n     private Boolean _openjpaId = null;\n     private Boolean _extent = null;\n     private Boolean _embedded = null;\n+    private Boolean _interface = null;\n+    private Class _impl = null;\n     private int _identity = -1;\n     private int _idStrategy = ValueStrategies.NONE;\n     private int _accessType = ACCESS_UNKNOWN;\n@@ -215,9 +217,8 @@ public Class getDescribedType() {\n      * an embedded value changes its declared type.\n      */\n     protected void setDescribedType(Class type) {\n-        if (type.isInterface())\n-            throw new MetaDataException(_loc.get(\"interface\", type));\n-        if (\"java.lang.Enum\".equals(type.getSuperclass().getName()))\n+        if (type.getSuperclass() != null && \"java.lang.Enum\".equals\n+            (type.getSuperclass().getName()))\n             throw new MetaDataException(_loc.get(\"enum\", type));\n         _type = type;\n     }\n@@ -669,6 +670,38 @@ public void setEmbeddedOnly(boolean embed) {\n         _embedded = (embed) ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n+    /**\n+     * Whether the type is a managed interface.\n+     */\n+    public boolean isManagedInterface() {\n+        if (!_type.isInterface())\n+            return false;\n+        return _interface == null ? false : _interface.booleanValue();\n+    }\n+\n+    /**\n+     * Whether the type is a managed interface\n+     */\n+    public void setManagedInterface(boolean managedInterface) {\n+        if (!_type.isInterface())\n+            throw new MetaDataException(_loc.get(\"not-interface\", _type));\n+        _interface = managedInterface ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Return the managed interface implementor if any.\n+     */\n+    public Class getInterfaceImpl() {\n+        return _impl;\n+    }\n+\n+    /**\n+     * Set the managed interface implementor class.\n+     */\n+    public void setInterfaceImpl(Class impl) {\n+        _impl = impl;\n+    }\n+    \n     /**\n      * Return the number of fields that use impl or intermediate data, in\n      * order to create a compacted array for storage of said data.\n@@ -1481,7 +1514,19 @@ protected void resolveMeta(boolean runtime) {\n             log.trace(_loc.get((embed) ? \"resolve-embed-meta\" : \"resolve-meta\",\n                 this + \"@\" + System.identityHashCode(this)));\n \n-        if (runtime && !PersistenceCapable.class.isAssignableFrom(_type))\n+        if (_type.isInterface()) {\n+            if (!embed && _interface != Boolean.TRUE)\n+                throw new MetaDataException(_loc.get(\"interface\", _type));\n+\n+            if (runtime) {\n+                _impl = _repos.getImplGenerator().createImpl(this);\n+                if (!embed)\n+                    _repos.setInterfaceImpl(this, _impl);\n+            }\n+        }\n+\n+        if (runtime && !_type.isInterface() && \n+            !PersistenceCapable.class.isAssignableFrom(_type))\n             throw new MetaDataException(_loc.get(\"not-enhanced\", _type));\n \n         // are we the target of an embedded value?\n@@ -2113,6 +2158,8 @@ public void copy(ClassMetaData meta) {\n         _objectId = meta.getObjectIdType();\n         _extent = (meta.getRequiresExtent()) ? Boolean.TRUE : Boolean.FALSE;\n         _embedded = (meta.isEmbeddedOnly()) ? Boolean.TRUE : Boolean.FALSE;\n+        _interface = (meta.isManagedInterface()) ? Boolean.TRUE : Boolean.FALSE;\n+        _impl = meta.getInterfaceImpl();\n         _identity = meta.getIdentityType();\n         _idStrategy = meta.getIdentityStrategy();\n         _seqName = meta.getIdentitySequenceName();"},{"sha":"0a89546940dbc911bdf740af63569af6aad836a6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java","raw_url":"https://github.com/apache/openjpa/raw/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java?ref=423b0a418af03102a95b1c7472665d5cd7c57b11","patch":"@@ -62,8 +62,14 @@ public int compare(Object o1, Object o2) {\n \n         int i1 = levels(c1);\n         int i2 = levels(c2);\n-        if (i1 == i2)\n+        if (i1 == i2) {\n+            // sort simple interfaces as well as simple order test will fail.\n+            if (c1.isAssignableFrom(o2.getClass()))\n+                return -1;\n+            if (c2.isAssignableFrom(o1.getClass()))\n+                return 1;\n             return c1.getName().compareTo(c2.getName());\n+        }\n         return i1 - i2;\n     }\n "},{"sha":"63564dac922595eb9104da9bb3bcbf738bb2728f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataDefaults.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataDefaults.java?ref=423b0a418af03102a95b1c7472665d5cd7c57b11","patch":"@@ -50,6 +50,12 @@\n      */\n     public void setIgnoreNonPersistent(boolean ignore);\n \n+    /**\n+     * Whether declared interfaces of a class are treated as persistent\n+     * types. Defaults to true.\n+     */\n+    public boolean isDeclaredInterfacePersistent();\n+\n     /**\n      * Populate the given metadata with default settings.\n      *\n@@ -61,4 +67,10 @@\n      * Return the backing member for the given field metadata.\n      */\n     public Member getBackingMember(FieldMetaData field);\n+\n+    /**\n+     * Return a runtime exception class to throw for un-implemented\n+     * managed interface methods.\n+     */\n+    public Class getUnimplementedExceptionType();\n }"},{"sha":"1c5e0c4d1ec0189b8f2473a2a91edfb7a28b4613","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataInheritanceComparator.java","status":"modified","additions":6,"deletions":2,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataInheritanceComparator.java","raw_url":"https://github.com/apache/openjpa/raw/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataInheritanceComparator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataInheritanceComparator.java?ref=423b0a418af03102a95b1c7472665d5cd7c57b11","patch":"@@ -25,7 +25,11 @@\n     extends InheritanceComparator {\n \n     protected Class toClass(Object elem) {\n-        return (elem == null) ? null\n-            : ((ClassMetaData) elem).getDescribedType();\n+        if (elem == null)\n+            return null;\n+        ClassMetaData meta = (ClassMetaData) elem;\n+        if (meta.getInterfaceImpl() != null)\n+            return meta.getInterfaceImpl();\n+        return meta.getDescribedType();\n     }\n }"},{"sha":"81bf0756bb3f47bec77f30236012e6159c053d48","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","status":"modified","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","raw_url":"https://github.com/apache/openjpa/raw/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java?ref=423b0a418af03102a95b1c7472665d5cd7c57b11","patch":"@@ -105,6 +105,7 @@\n     private final Map _metas = new HashMap();\n     private final Map _oids = Collections.synchronizedMap(new HashMap());\n     private final Map _impls = Collections.synchronizedMap(new HashMap());\n+    private final Map _ifaces = Collections.synchronizedMap(new HashMap());\n     private final Map _queries = new HashMap();\n     private final Map _seqs = new HashMap();\n     private final Map _aliases = Collections.synchronizedMap(new HashMap());\n@@ -116,6 +117,7 @@\n     private OpenJPAConfiguration _conf = null;\n     private Log _log = null;\n     private MetaDataFactory _factory = null;\n+    private InterfaceImplGenerator _implGen = null;\n     private int _resMode = MODE_META | MODE_MAPPING;\n     private int _sourceMode = MODE_META | MODE_MAPPING | MODE_QUERY;\n     private int _validate = VALIDATE_META | VALIDATE_UNENHANCED;\n@@ -541,6 +543,18 @@ private List resolveMeta(ClassMetaData meta) {\n                 } else\n                     sup = sup.getSuperclass();\n             }\n+            if (meta.getDescribedType().isInterface()) {\n+                Class[] sups = meta.getDescribedType().getInterfaces();\n+                for (int i = 0; i < sups.length; i++) {\n+                    supMeta = getMetaData(sups[i], meta.getEnvClassLoader(), \n+                        false);\n+                    if (supMeta != null) {\n+                        meta.setPCSuperclass(sup);\n+                        meta.setPCSuperclassMetaData(supMeta);\n+                        break;\n+                    }\n+                }\n+            }\n             if (_log.isTraceEnabled())\n                 _log.trace(_loc.get(\"assigned-sup\", meta,\n                     meta.getPCSuperclass()));\n@@ -845,12 +859,41 @@ public synchronized boolean removeMetaData(Class cls) {\n         if (cls == null)\n             return false;\n         if (_metas.remove(cls) != null) {\n+            Class impl = (Class) _ifaces.remove(cls);\n+            if (impl != null)\n+                _metas.remove(impl);\n             _count--;\n             return true;\n         }\n         return false;\n     }\n+\n+    /**\n+     * Add the given metadata as declared interface implementation.\n+     */\n+    public void addDeclaredInterfaceImpl(ClassMetaData meta, Class iface) {\n+        synchronized (_impls) {\n+            addToCollection(_impls, iface, meta.getDescribedType(), false);\n+        }\n+    }\n+\n+    /**\n+     * Set the implementation for the given managed interface.\n+     */\n+    synchronized void setInterfaceImpl(ClassMetaData meta, Class impl) {\n+        if (!meta.isManagedInterface())\n+            throw new MetaDataException(_loc.get(\"not-managed-interface\", \n+                meta, impl));\n+        _ifaces.put(meta.getDescribedType(), impl);\n+        _metas.put(impl, meta);\n+    }\n     \n+    synchronized InterfaceImplGenerator getImplGenerator() {\n+        if (_implGen == null)\n+            _implGen = new InterfaceImplGenerator(this);\n+        return _implGen;\n+    }\n+\n     /**\n      * Return the least-derived class metadata for the given application\n      * identity object.\n@@ -1274,6 +1317,8 @@ private void processRegisteredClass(Class cls) {\n      * Update the list of implementations of base classes and interfaces.\n      */\n     private void updateImpls(Class cls, Class leastDerived, Class check) {\n+        if (_factory.getDefaults().isDeclaredInterfacePersistent())\n+            return;\n         // allow users to query on common non-pc superclasses\n         Class sup = check.getSuperclass();\n         if (leastDerived == cls && sup != null && sup != Object.class) {"},{"sha":"0ec15ffd5e090b8a2e8152215750aadb0d812f92","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/NoneMetaDataFactory.java","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NoneMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NoneMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NoneMetaDataFactory.java?ref=423b0a418af03102a95b1c7472665d5cd7c57b11","patch":"@@ -104,10 +104,18 @@ public boolean getCallbacksBeforeListeners(int type) {\n     public void setIgnoreNonPersistent(boolean ignore) {\n     }\n \n+    public boolean isDeclaredInterfacePersistent() {\n+        return false;\n+    }\n+\n     public void populate(ClassMetaData meta, int access) {\n     }\n \n     public Member getBackingMember(FieldMetaData fmd) {\n         return null;\n     }\n+\n+    public Class getUnimplementedExceptionType() {\n+        return null;\n+    }\n }"},{"sha":"12a5eb93bd95345c0d69abfd778ed11be04461ce","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java","status":"modified","additions":5,"deletions":2,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java","raw_url":"https://github.com/apache/openjpa/raw/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java?ref=423b0a418af03102a95b1c7472665d5cd7c57b11","patch":"@@ -257,8 +257,11 @@ public static Object copy(Object oid, ClassMetaData meta) {\n         // to the original oid values, then copy its key fields to a new\n         // oid instance\n         if (!Modifier.isAbstract(meta.getDescribedType().getModifiers())) {\n-            PersistenceCapable pc = PCRegistry.newInstance\n-                (meta.getDescribedType(), null, oid, false);\n+            Class type = meta.getDescribedType();\n+            if (meta.getInterfaceImpl() != null)\n+                type = meta.getInterfaceImpl();\n+            PersistenceCapable pc = PCRegistry.newInstance(type, null, oid, \n+                 false);\n             Object copy = pc.pcNewObjectIdInstance();\n             pc.pcCopyKeyFieldsToObjectId(copy);\n             return copy;"},{"sha":"32552403d09c70255ae713044f9841f6d616c9ac","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties?ref=423b0a418af03102a95b1c7472665d5cd7c57b11","patch":"@@ -24,6 +24,7 @@ enhance-running-oids: Enhancer running on oid: {0}\n enhance-aware: The class does not have metadata - enhanced as persistence-aware.\n enhance-norun: The class is already persistence capable - no enhancement \\\n \tperformed.\n+enhance-interface: The class is a managed interface - no enhancement performed.\n enhance-usage: Usage: java org.apache.openjpa.enhance.PCEnhancer\\n\\\n \t\\t[-properties/-p <properties file or resource>]\\n\\\n \t\\t[-<property name> <property value>]*\\n\\"},{"sha":"e817c643e20ce740b9d6f61a965e47e377e694f3","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties?ref=423b0a418af03102a95b1c7472665d5cd7c57b11","patch":"@@ -4,8 +4,8 @@ unloaded-detached: Attempt to access an unloaded field of detached instance \\\n \t\"{0}\".\n meta-unknownid: Cannot manipulate identity of type \"{0}\": it''s identity type \\\n \tis unknown.\n-new-abstract: Cannot create an instance of \"{0}\": abstract classes and \\\n-\tinterfaces are not yet supported.\n+new-abstract: Cannot create an instance of \"{0}\": abstract classes are not \\\n+    yet supported.\n bad-new-query: Attempt to construct a query from an extent or class.  You must \\\n \tpass a (possibly null) query string or template to the query factory \\\n \tmethod when creating the query. "},{"sha":"41e7d3e81c623c5bd5145f28b2a9da1e0f377a62","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","status":"modified","additions":6,"deletions":1,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/423b0a418af03102a95b1c7472665d5cd7c57b11/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties?ref=423b0a418af03102a95b1c7472665d5cd7c57b11","patch":"@@ -18,6 +18,8 @@ clear-repos: Clearing metadata repository \"{0}\".\n process-registered: Processing registered persistence-capable class \"{0}\".\n assigned-sup: Set persistence-capable superclass of \"{0}\" to \"{1}\".\n found-pcs: Found {0} classes with metadata in {1} milliseconds.\n+not-managed-interface: Cannot set type \"{1}\" as interface \"{0}\" implementor. \\\n+    \"{0}\" is not a managed interface.\n unmanaged-sup-field: Superclass field \"{0}\" is mapped in the metadata for \\\n \tsubclass \"{1}\", but is not a persistent field.\n bad-discover-class: The class \"{0}\" listed in the openjpa.MetaDataFactory \\\n@@ -180,7 +182,10 @@ bad-update-strategy: \"{0}\" declares a read only value of \"{1}\". \\\n bad-update-strategy-hint: \"{0}\" declares a read only value of \\\n \t\"{1}\".  This is not a recognized strategy, though it closely resembles \\\n \tthe standard strategy \"{2}\".  Available strategies are: {3}\n-interface: Type \"{0}\" is an interface and therefore cannot be made persistent.\n+not-interface: Can't set type \"{0}\" to be a managed interface as it is not \\\n+    and interface.\n+interface: The type \"{0}\" is an unmanaged interface and therefore cannot be \\\n+    made persistent.\n enum: Type \"{0}\" is an enumeration and therefore cannot be made persistent.\n bad-drop: The metadata for some of the following classes may not have \\\n \tbeen dropped: {0}"}]}

