{"sha":"432499a3a69acdd985b321fd9ef3101430fa7b54","node_id":"MDY6Q29tbWl0MjA2MzY0OjQzMjQ5OWEzYTY5YWNkZDk4NWIzMjFmZDllZjMxMDE0MzBmYTdiNTQ=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2012-05-02T15:49:29Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2012-05-02T15:49:29Z"},"message":"OPENJPA-2161: Refactor revision 1306530 and make StateManagerImpl._meta protected.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@1333082 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4584948ca366165bb557cedd91667655adb4ccb9","url":"https://api.github.com/repos/apache/openjpa/git/trees/4584948ca366165bb557cedd91667655adb4ccb9"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/432499a3a69acdd985b321fd9ef3101430fa7b54","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/432499a3a69acdd985b321fd9ef3101430fa7b54","html_url":"https://github.com/apache/openjpa/commit/432499a3a69acdd985b321fd9ef3101430fa7b54","comments_url":"https://api.github.com/repos/apache/openjpa/commits/432499a3a69acdd985b321fd9ef3101430fa7b54/comments","author":null,"committer":null,"parents":[{"sha":"a0f7a2f50fcf156576333367613a50222cec7895","url":"https://api.github.com/repos/apache/openjpa/commits/a0f7a2f50fcf156576333367613a50222cec7895","html_url":"https://github.com/apache/openjpa/commit/a0f7a2f50fcf156576333367613a50222cec7895"}],"stats":{"total":22,"additions":9,"deletions":13},"files":[{"sha":"3f23ad9fdcacb2db581f157f1c7bbc68e0754555","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":9,"deletions":13,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/432499a3a69acdd985b321fd9ef3101430fa7b54/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/432499a3a69acdd985b321fd9ef3101430fa7b54/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=432499a3a69acdd985b321fd9ef3101430fa7b54","patch":"@@ -34,6 +34,7 @@\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Set;\n import java.util.TimeZone;\n import java.util.concurrent.locks.ReentrantLock;\n \n@@ -113,7 +114,7 @@\n \n     // information about the instance\n     private transient PersistenceCapable _pc = null;\n-    private transient ClassMetaData _meta = null;\n+    protected transient ClassMetaData _meta = null;\n     protected BitSet _loaded = null;\n     private BitSet _dirty = null;\n     private BitSet _flush = null;\n@@ -169,7 +170,7 @@\n      */\n     protected StateManagerImpl(Object id, ClassMetaData meta, BrokerImpl broker) {\n         _id = id;\n-        setMeta(meta);\n+        _meta = meta;\n         _broker = broker;\n         _single = new SingleFieldManager(this, broker);\n         if (broker.getMultithreaded())\n@@ -274,7 +275,6 @@ private void setPCState(PCState state) {\n             boolean wasDeleted = _state.isDeleted();\n             boolean wasDirty = _state.isDirty();\n             boolean wasPending = _state.isPendingTransactional();\n-\n             _state = state;\n \n             // enlist/delist from transaction\n@@ -323,7 +323,7 @@ else if (sub.getObjectIdType() != _meta.getObjectIdType()) {\n                     _oid = ApplicationIds.fromPKValues(pkFields, sub);\n                 }\n             }\n-            setMeta(sub);\n+            _meta = sub;\n         }\n \n         PersistenceCapable inst = PCRegistry.newInstance(cls, this, _oid, true);\n@@ -402,8 +402,9 @@ protected void initialize(PersistenceCapable pc, PCState state) {\n     public boolean isIntercepting() {\n         if (getMetaData().isIntercepting())\n             return true;\n-        // TODO:JRB Intercepting\n-        if (AccessCode.isProperty(getMetaData().getAccessType()) && _pc instanceof DynamicPersistenceCapable)\n+        // TODO:JRB Intercepting \n+        if (AccessCode.isProperty(getMetaData().getAccessType())\n+            && _pc instanceof DynamicPersistenceCapable)\n             return true;\n         return false;\n     }\n@@ -3427,8 +3428,8 @@ private void readObject(ObjectInputStream in)\n         // non-null when reconstituting ReflectingPC instances. Sadly, this\n         // penalizes the serialization footprint of non-ReflectingPC SMs also.\n         Class managedType = (Class) in.readObject();\n-        setMeta(_broker.getConfiguration().getMetaDataRepositoryInstance()\n-            .getMetaData(managedType, null, true));\n+        _meta = _broker.getConfiguration().getMetaDataRepositoryInstance()\n+            .getMetaData(managedType, null, true);\n \n         _pc = readPC(in);\n     }\n@@ -3467,13 +3468,8 @@ public boolean requiresFetch(FieldMetaData fmd) {\n     public void setPc(PersistenceCapable pc) {\n         _pc = pc;\n     }\n-    \n-    protected void setMeta(ClassMetaData cmd){\n-        _meta = cmd;\n-    }\n \n     public void setBroker(BrokerImpl ctx) {\n         _broker = ctx;\n     }\n-\n }"}]}

