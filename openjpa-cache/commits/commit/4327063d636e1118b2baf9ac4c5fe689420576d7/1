{"sha":"4327063d636e1118b2baf9ac4c5fe689420576d7","node_id":"MDY6Q29tbWl0MjA2MzY0OjQzMjcwNjNkNjM2ZTExMThiMmJhZjlhYzRjNWZlNjg5NDIwNTc2ZDc=","commit":{"author":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2009-10-02T00:36:33Z"},"committer":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2009-10-02T00:36:33Z"},"message":"OPENJPA-1327 Doc update for JPA2 JPQL Query\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@820853 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b4f6554e918434643664415f73292bc19e8e80c6","url":"https://api.github.com/repos/apache/openjpa/git/trees/b4f6554e918434643664415f73292bc19e8e80c6"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/4327063d636e1118b2baf9ac4c5fe689420576d7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/4327063d636e1118b2baf9ac4c5fe689420576d7","html_url":"https://github.com/apache/openjpa/commit/4327063d636e1118b2baf9ac4c5fe689420576d7","comments_url":"https://api.github.com/repos/apache/openjpa/commits/4327063d636e1118b2baf9ac4c5fe689420576d7/comments","author":null,"committer":null,"parents":[{"sha":"c14838950cd361f54f9ca913c396df570e368b1e","url":"https://api.github.com/repos/apache/openjpa/commits/c14838950cd361f54f9ca913c396df570e368b1e","html_url":"https://github.com/apache/openjpa/commit/c14838950cd361f54f9ca913c396df570e368b1e"}],"stats":{"total":1042,"additions":874,"deletions":168},"files":[{"sha":"11cce3e5b0e70aa3168007a9133c1f305ab6a472","filename":"openjpa-project/src/doc/manual/jpa_overview_query.xml","status":"modified","additions":874,"deletions":168,"changes":1042,"blob_url":"https://github.com/apache/openjpa/blob/4327063d636e1118b2baf9ac4c5fe689420576d7/openjpa-project/src/doc/manual/jpa_overview_query.xml","raw_url":"https://github.com/apache/openjpa/raw/4327063d636e1118b2baf9ac4c5fe689420576d7/openjpa-project/src/doc/manual/jpa_overview_query.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_query.xml?ref=4327063d636e1118b2baf9ac4c5fe689420576d7","patch":"@@ -2089,7 +2089,7 @@ FROM Employee e JOIN e.contactInfo.phones p\n WHERE e.contactInfo.address.zipcode = '95054'\n </programlisting>\n                 <para>\n-Path expression\n+Path expression \n navigability is composed using \"inner join\" semantics. That is, if the value of\n a non-terminal association-field in the path expression is null, the path is\n considered to have no value, and does not participate in the determination of\n@@ -2110,51 +2110,71 @@ path expressions is as follows:\n                 <itemizedlist>\n                     <listitem>\n                         <para>\n-single_valued_path_expression ::= state_field_path_expression | \n-single_valued_association_path_expression\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n-state_field_path_expression ::= {identification_variable |\n-single_valued_association_path_expression}.state_field\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n-single_valued_association_path_expression ::=\n-identification_variable.{single_valued_association_field.}*single_valued_association_field\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n+single_valued_path_expression ::= \n+qualified_identification_variable |\n+state_field_path_expression | \n+single_valued_object_path_expression\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+state_field_path_expression ::= \n+general_identification_variable.{single_valued_object_field.}*state_field\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+single_valued_object_path_expression ::=\n+general_identification_variable.{single_valued_object_field.}*single_valued_object_field\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n collection_valued_path_expression ::=\n-identification_variable.{single_valued_association_field.}*collection_valued_association_field\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n-state_field ::= {embedded_class_state_field.}*simple_state_field\n+general_identification_variable.{single_valued_object_field.}*collection_valued_field\n+                        </para>\n+                    </listitem>\n+                </itemizedlist>\n+                <para>\n+A <literal>single_valued_object_field</literal> is designated by the name of an\n+association-field in a one-to-one or many-to-one relationship \n+or a field of embeddable class type. The type of a\n+<literal>single_valued_object_field</literal> is the abstract schema type of the\n+related entity or embeddable class.\n+                </para>\n+                <para>\n+A <literal>state_field</literal> is designated by the name of an entity or \n+embeddable class state field that corresponds to\n+a basic type.                \n+                </para>\n+                <para>\n+A collection_valued_field is designated by the name\n+of an association-field in a one-to-many or a many-to-many relationship \n+or by the name of an element collection field. The\n+type of a <literal>collection_valued_field</literal> is \n+a collection of values of the\n+abstract schema type of the related entity \n+or element type. \n+                </para>\n+                <para>\n+An identification variable used in a \n+<literal>single_valued_object_path_expression</literal> or in a\n+<literal>collection_valued_path_expression</literal>  \n+may be an unqualified identification variable or an identification\n+variable to which the KEY or VALUE function has been applied.\n+                </para>\n+                <itemizedlist>\n+                    <listitem>\n+                        <para>\n+general_identification_variable ::=\n+identification_variable |\n+KEY(identification_variable) |\n+VALUE(identification_variable)\n                         </para>\n                     </listitem>\n                 </itemizedlist>\n                 <para>\n-A single_valued_association_field is designated by the name of an\n-association-field in a one-to-one or many-to-one relationship. The type of a\n-single_valued_association_field and thus a\n-single_valued_association_path_expression is the abstract schema type of the\n-related entity. A collection_valued_association_field is designated by the name\n-of an association-field in a one-to-many or a many-to-many relationship. The\n-type of a collection_valued_association_field is a collection of values of the\n-abstract schema type of the related entity. An embedded_class_state _field is\n-designated by the name of an entity state field that corresponds to an embedded\n-class. Navigation to a related entity results in a value of the related entity's\n-abstract schema type.\n-                </para>\n-                <para>\n-The evaluation of a path expression terminating in a state-field results in the\n-abstract schema type corresponding to the Java type designated by the\n-state-field. It is syntactically illegal to compose a path expression from a\n+It is syntactically illegal to compose a path expression from a\n path expression that evaluates to a collection. For example, if <literal>mag\n </literal> designates <literal>Magazine</literal>, the path expression <literal>\n mag.articles.author</literal> is illegal since navigation to authors results in\n@@ -2164,8 +2184,19 @@ declared in the <literal>FROM</literal> clause to range over the elements of the\n <literal>articles</literal> collection. Another path expression must be used to\n navigate over each such element in the <literal>WHERE</literal> clause of the\n query, as in the following query which returns all authors that have any\n-articles in any magazines: <programlisting>SELECT DISTINCT art.author FROM Magazine AS mag, IN(mag.articles) art\n+articles in any magazines: \n+               </para>\n+<programlisting>\n+SELECT DISTINCT art.author FROM Magazine AS mag, IN(mag.articles) art\n </programlisting>\n+                <para>\n+It is illegal to use a <literal>collection_valued_path_expression</literal> other than \n+in the <literal>FROM</literal> clause of a query\n+except in an <literal>empty_collection_comparison_expression</literal>, \n+in a <literal>collection_member_expression</literal>, or\n+as an argument to the <literal>SIZE</literal> operator. \n+See Sections <xref linkend=\"jpa_langref_empty_comp\"/>,  <xref linkend=\"jpa_langref_collection_member\"/>, \n+and <xref linkend=\"jpa_langref_arithmetic\"/>.       \n                 </para>\n             </section>\n             <section id=\"jpa_langref_Joins\">\n@@ -2175,7 +2206,16 @@ articles in any magazines: <programlisting>SELECT DISTINCT art.author FROM Magaz\n                 <para>\n An inner join may be implicitly specified by the use of a cartesian product in\n the <literal>FROM</literal> clause and a join condition in the <literal>WHERE\n-</literal> clause.\n+</literal> clause. In the absence of a join condition, this reduces to the cartesian product.\n+               </para>\n+               <para>\n+The main use case for this generalized style of join is when a join condition does not involve\n+a foreign key relationship that is mapped to an entity relationship. For Example,\n+                </para>\n+<example>SELECT c FROM Customer c, Employee e WHERE c.hatsize = e.shoesize</example>\n+                <para>\n+In general, use of this style of inner join (also referred to as theta-join) is less typical than explicitly\n+defined joins over relationships.\n                 </para>\n                 <para>\n The syntax for explicit join operations is as follows:\n@@ -2194,11 +2234,23 @@ fetch_join ::= join_spec FETCH join_association_path_expression\n                         <listitem>\n                             <para>\n join_association_path_expression ::= join_collection_valued_path_expression |\n-join_single_valued_association_path_expression\n+join_single_valued_path_expression\n                             </para>\n                         </listitem>\n                         <listitem>\n                             <para>\n+join_collection_valued_path_expression::=\n+identification_variable.{single_valued_embeddable_object_field.}*collection_valued_field  \n+                          </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+join_single_valued_path_expression::=\n+identification_variable.{single_valued_embeddable_object_field.}*single_valued_object_field  \n+                          </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n join_spec ::= [ LEFT [OUTER] | INNER ] JOIN\n                         </para>\n                     </listitem>\n@@ -2233,6 +2285,15 @@ over 1 million for which at least one magazine exists:\n                     </para>\n <programlisting>\n SELECT OBJECT(pub) FROM Publisher pub, IN(pub.magazines) mag WHERE pub.revenue &gt; 1000000\n+</programlisting>\n+                    <para>\n+The query below joins over Employee, ContactInfo and Phone. ContactInfo is an\n+embeddable class that consists of an address and set of phones. Phone is an entity.\n+                    </para>\n+<programlisting>\n+SELECT p.vendor\n+FROM Employee e JOIN e.contactInfo c JOIN c.phones p\n+WHERE c.address.zipcode = '95054'\n </programlisting>\n                 </section>\n                 <section id=\"jpa_langref_outer_joins\">\n@@ -2276,7 +2337,10 @@ The association referenced by the right side of the <literal>FETCH JOIN\n returned as a result of the query. It is not permitted to specify an\n identification variable for the entities referenced by the right side of the\n <literal>FETCH JOIN</literal> clause, and hence references to the implicitly\n-fetched entities cannot appear elsewhere in the query. The following query\n+fetched entities cannot appear elsewhere in the query. \n+                    </para>\n+                    <para>\n+The following query\n returns a set of magazines. As a side effect, the associated articles for those\n magazines are also retrieved, even though they are not part of the explicit\n query result. The persistent fields or properties of the articles that are\n@@ -2293,24 +2357,34 @@ join operation are not returned in the query result or otherwise referenced in\n the query. Hence, for example, if magazine id 1 has five articles, the above\n query returns five references to the magazine 1 entity.\n                     </para>\n+                    <para>\n+The <literal>FETCH JOIN</literal> construct must not be used in the FROM clause of a subquery.\n+                    </para>\n                 </section>\n             </section>\n             <section id=\"jpa_langref_collection_dec\">\n                 <title>\n                     JPQL Collection Member Declarations\n                 </title>\n                 <para>\n-An identification variable declared by a collection_member_declaration ranges\n+An identification variable declared by a <literal>collection_member_declaration</literal> ranges\n over values of a collection obtained by navigation using a path expression. Such\n a path expression represents a navigation involving the association-fields of an\n entity abstract schema type. Because a path expression can be based on another\n path expression, the navigation can use the association-fields of related\n-entities. An identification variable of a collection member declaration is\n+entities. \n+                </para>\n+                <para>\n+An identification variable of a collection member declaration is\n declared using a special operator, the reserved identifier <literal>IN</literal>\n . The argument to the <literal>IN</literal> operator is a collection-valued path\n expression. The path expression evaluates to a collection type specified as a\n-result of navigation to a collection-valued association-field of an entity\n-abstract schema type. The syntax for declaring a collection member\n+result of navigation to a collection-valued association-field of an entity \n+or embeddable class \n+abstract schema type. \n+                </para>\n+                <para>\n+The syntax for declaring a collection member\n identification variable is as follows:\n                 </para>\n                 <para>\n@@ -2324,7 +2398,7 @@ identification variable is as follows:\n For example, the query <programlisting>SELECT DISTINCT mag FROM Magazine mag\n     JOIN mag.articles art\n     JOIN art.author auth\n-    WHERE auth.lastName = 'Grisham'</programlisting> may equivalently be\n+    WHERE auth.lastName = 'Grisham'</programlisting> can equivalently be\n expressed as follows, using the <literal>IN</literal> operator: <programlisting>SELECT DISTINCT mag FROM Magazine mag,\n     IN(mag.articles) art\n     WHERE art.author.lastName = 'Grisham'</programlisting> In this example,\n@@ -2336,6 +2410,28 @@ In this example, <literal>mag</literal> is an identification variable of the\n abstract schema type <literal>Magazine</literal>.\n                 </para>\n             </section>\n+            <section id=\"jpa_langref_from_clause_and_sql\">\n+                <title>\n+                    JPQL FROM Clause and SQL\n+                </title>\n+                <para>\n+The Java Persistence query language treats the FROM clause similarly to SQL in that the declared identification\n+variables affect the results of the query even if they are not used in the WHERE clause. Application\n+developers should use caution in defining identification variables because the domain of the\n+query can depend on whether there are any values of the declared type.\n+                </para>\n+                <para>\n+For example, the <literal>FROM</literal> clause below defines a query over \n+all orders that have line items and existing\n+products. If there are no <litera.>Product</litera.> instances in the database, \n+the domain of the query is empty and no\n+order is selected.\n+                </para>\n+<programlisting>\n+SELECT o\n+FROM Order AS o JOIN o.lineItems l JOIN l.product p\n+</programlisting>\n+            </section>\n             <section id=\"jpa_langref_polymorph\">\n                 <title>\n                     JPQL Polymorphism\n@@ -2347,6 +2443,11 @@ entity classes to which explicitly refers but of subclasses as well. The\n instances returned by a query include instances of the subclasses that satisfy\n the query criteria.\n                 </para>\n+                <para>\n+Non-polymorphic queries or queries whose polymorphism is restricted can be specified using entity\n+type expressions in the WHERE clause to restrict the domain of the query.\n+See section <xref linked=\"jpa_langref_entity_type_expressions\"/>.\n+                </para>\n             </section>\n         </section>\n         <section id=\"jpa_langref_where\">\n@@ -2357,7 +2458,10 @@ the query criteria.\n The <literal>WHERE</literal> clause of a query consists of a conditional\n expression used to select objects or values that satisfy the expression. The\n <literal>WHERE</literal> clause restricts the result of a select statement or\n-the scope of an update or delete operation. A <literal>WHERE</literal> clause is\n+the scope of an update or delete operation. \n+            </para>\n+            <para>\n+A <literal>WHERE</literal> clause is\n defined as follows: <itemizedlist><listitem><para>where_clause ::= WHERE\n conditional_expression\n                         </para>\n@@ -2368,7 +2472,10 @@ conditional_expression\n The <literal>GROUP BY</literal> construct enables the aggregation of values\n according to the properties of an entity class. The <literal>HAVING</literal>\n construct enables conditions to be specified that further restrict the query\n-result as restrictions upon the groups. The syntax of the <literal>HAVING\n+result as restrictions upon the groups. \n+            </para>\n+            <para>\n+The syntax of the <literal>HAVING\n </literal> clause is as follows: <itemizedlist><listitem><para>having_clause\n ::= HAVING conditional_expression\n                         </para>\n@@ -2387,7 +2494,10 @@ further discussed in <xref linkend=\"jpa_langref_group\"/>.\n             <para>\n The following sections describe the language constructs that can be used in a\n conditional expression of the <literal>WHERE</literal> clause or <literal>\n-HAVING</literal> clause. State-fields that are mapped in serialized form or as\n+HAVING</literal> clause. \n+            </para>\n+            <para>\n+State-fields that are mapped in serialized form or as\n lobs may not be portably used in conditional expressions. <note><para> The\n implementation is not expected to perform such query operations involving such\n fields in memory rather than in the database.\n@@ -2403,16 +2513,48 @@ A string literal is enclosed in single quotes--for example: 'literal'. A string\n literal that includes a single quote is represented by two single quotes--for\n example: 'literal''s'. String literals in queries, like Java String literals,\n use unicode character encoding. The use of Java escape notation is not supported\n-in query string literals. Exact numeric literals support the use of Java integer\n-literal syntax as well as SQL exact numeric literal syntax. Approximate literals\n+in query string literals. \n+            </para>\n+            <para>\n+Exact numeric literals support the use of Java integer\n+literal syntax as well as SQL exact numeric literal syntax. \n+            </para>\n+            <para>\n+Approximate literals\n support the use of Java floating point literal syntax as well as SQL approximate\n-numeric literal syntax. Enum literals support the use of Java enum literal\n-syntax. The enum class name must be specified. Appropriate suffixes may be used\n+numeric literal syntax. \n+            </para>\n+            <para>\n+Enum literals support the use of Java enum literal\n+syntax. The enum class name must be specified. \n+            </para>\n+            <para>\n+Appropriate suffixes can be used\n to indicate the specific type of a numeric literal in accordance with the Java\n Language Specification. The boolean literals are <literal>TRUE</literal> and\n <literal>FALSE</literal>. Although predefined reserved literals appear in upper\n case, they are case insensitive.\n-                </para>\n+            </para>\n+            <para>\n+The JDBC escape syntax may be used for the specification of date, time, and timestamp literals. For\n+example:            \n+            </para>\n+            <programlisting>\n+SELECT o\n+FROM Customer c JOIN c.orders o\n+WHERE c.name = 'Smith'\n+AND o.submissionDate &lt; {d '2008-12-31'}\n+            </programlisting>\n+            <para>\n+Date, time, and timestamp literals are passed as it to the JDBC driver\n+in use.\n+            </para>\n+            <para>\n+Entity type literals are specified by entity names—for example: <literal>Customer</literal>.\n+            </para>\n+            <para>\n+Although reserved literals appear in upper case, they are case insensitive.            \n+            </para>\n             </section>\n             <section id=\"jpa_langref_idvar\">\n                 <title>\n@@ -2425,6 +2567,8 @@ HAVING</literal> clause of a <literal>SELECT</literal> or <literal>DELETE\n described in <xref linkend=\"jpa_langref_from_vars\"/>. The identification\n variables used in the <literal>WHERE</literal> clause of an <literal>UPDATE\n </literal> statement must be declared in the <literal>UPDATE</literal> clause.\n+                 </para>\n+                 <para>\n Identification variables are existentially quantified in the <literal>WHERE\n </literal> and <literal>HAVING</literal> clause. This means that an\n identification variable represents a member of a collection or an instance of an\n@@ -2437,10 +2581,10 @@ collection in its entirety.\n                     JPQL Path Expressions\n                 </title>\n                 <para>\n-It is illegal to use a collection_valued_path_expression within a <literal>\n+It is illegal to use a <literal>collection_valued_path_expression</literal> within a <literal>\n WHERE</literal> or <literal>HAVING</literal> clause as part of a conditional\n-expression except in an empty_collection_comparison_expression, in a\n-collection_member_expression, or as an argument to the <literal>SIZE</literal>\n+expression except in an <literal>empty_collection_comparison_expression</literal>, in a\n+<literal>collection_member_expression</literal>, or as an argument to the <literal>SIZE</literal>\n operator.\n                 </para>\n             </section>\n@@ -2450,14 +2594,22 @@ operator.\n                 </title>\n                 <para>\n Either positional or named parameters may be used. Positional and named\n-parameters may not be mixed in a single query. Input parameters can only be used\n+parameters may not be mixed in a single query. \n+                </para>\n+                <para>\n+Input parameters can only be used\n in the <literal>WHERE</literal> clause or <literal>HAVING</literal> clause of a\n query.\n                 </para>\n                 <para>\n Note that if an input parameter value is null, comparison operations or\n arithmetic operations involving the input parameter will return an unknown\n value. See <xref linkend=\"jpa_langref_null_values\"/>.\n+                </para>\n+                <para>\n+All input parameters must be single-valued, except in IN expressions (see section\n+<xref linkend=\"jpa_lagref_in_expression\"/>), which support the use of collection-valued\n+input parameters.\n                 </para>\n                 <section id=\"jpa_langref_pos_params\">\n                     <title>\n@@ -2471,8 +2623,18 @@ by an integer. For example: ?1.\n                             </listitem>\n                             <listitem>\n                                 <para>\n-Input parameters are numbered starting from 1. Note that the same parameter can\n-be used more than once in the query string and that the ordering of the use of\n+Input parameters are numbered starting from 1. \n+                                </para>\n+                            </listitem>\n+                            <listitem>\n+                                <para>\n+The same parameter can\n+be used more than once in the query string.\n+                                </para>\n+                            </listitem>\n+                            <listitem>\n+                                <para>\n+The ordering of the use of\n parameters within the query string need not conform to the order of the\n positional parameters.\n                                 </para>\n@@ -2494,6 +2656,9 @@ sensitive.\n Example: <programlisting>SELECT pub FROM Publisher pub WHERE pub.revenue &gt; :rev\n </programlisting>\n                     </para>\n+                    <para>\n+The same named parameter can be used more than once in the query string.\n+                    </para>\n                 </section>\n             </section>\n             <section id=\"jpa_langref_cond_comp\">\n@@ -2503,12 +2668,22 @@ Example: <programlisting>SELECT pub FROM Publisher pub WHERE pub.revenue &gt; :r\n                 <para>\n Conditional expressions are composed of other conditional expressions,\n comparison operations, logical operations, path expressions that evaluate to\n-boolean values, boolean literals, and boolean input parameters. Arithmetic\n-expressions can be used in comparison expressions. Arithmetic expressions are\n-composed of other arithmetic expressions, arithmetic operations, path\n-expressions that evaluate to numeric values, numeric literals, and numeric input\n-parameters. Arithmetic operations use numeric promotion. Standard bracketing ()\n-for ordering expression evaluation is supported. Conditional expressions are\n+boolean values, boolean literals, and boolean input parameters. \n+                </para>\n+                <para>\n+The scalar expressions described in section <xref linkend=\"jpa_langref_scalar_expressions\"/> \n+ can be used in conditional expressions. \n+                </para>\n+                <para>\n+Standard bracketing ()\n+for ordering expression evaluation is supported.\n+                </para>\n+                <para>\n+Aggregate functions can only be used in conditional expressions in a <literal>\n+HAVING</literal> clause. See <xref linkend=\"jpa_langref_group\"/>.\n+                </para>\n+                <para> \n+Conditional expressions are\n defined as follows:\n                 </para>\n                 <para>\n@@ -2542,10 +2717,6 @@ exists_expression\n                         </listitem>\n                     </itemizedlist>\n                 </para>\n-                <para>\n-Aggregate functions can only be used in conditional expressions in a <literal>\n-HAVING</literal> clause. See <xref linkend=\"jpa_langref_group\"/>.\n-                </para>\n             </section>\n             <section id=\"jpa_langref_operators\">\n                 <title>\n@@ -2585,6 +2756,50 @@ Logical operators: <literal>NOT</literal>, <literal>AND</literal>,\n       \n                 </para>\n             </section>\n+            <section id=\"jpa_langref_comparison_expressions\">\n+                <title>\n+                    JPQL Comparison Expressions\n+                </title>\n+                <para>\n+The syntax for the use of comparison expressions in a conditional expression is as follows:\n+                </para>\n+                <itemizedlist>\n+                <listitem>\n+                  <para> \n+comparison_expression ::=\n+string_expression comparison_operator {string_expression | all_or_any_expression} |\n+boolean_expression { =|&lt;&gt; } {boolean_expression | all_or_any_expression} |\n+enum_expression { =|&lt;&gt; } {enum_expression | all_or_any_expression} |\n+datetime_expression comparison_operator\n+{datetime_expression | all_or_any_expression} |\n+entity_expression { = | &lt;&gt; } {entity_expression | all_or_any_expression} |\n+arithmetic_expression comparison_operator\n+{arithmetic_expression | all_or_any_expression} |\n+entity_type_expression { = | &lt;&gt; } entity_type_expression}\n+                  </para>\n+                </listitem>\n+                <listitem>\n+                  <para>\n+comparison_operator ::= = | &gt; | &gt;= | &lt; | &lt;= | &lt;&gt;\n+                  </para>\n+                </listitem>\n+                </itemizedlist>\n+                <para>\n+Examples:\n+                </para>\n+<programlisting>\n+item.cost * 1.08 &lt;= 100.00\n+</programlisting>\n+<programlisting>\n+CONCAT(person.lastName, ‘, ’, person.firstName)) = ‘Jones, Sam’\n+</programlisting>\n+<programlisting>\n+TYPE(e) = ExemptEmployee\n+</programlisting>\n+<note>\n+Comparisons over instances of embeddable class types are not supported.\n+</note>\n+                </section>\n             <section id=\"jpa_langref_between\">\n                 <title>\n                     JPQL Between Expressions\n@@ -2604,14 +2819,26 @@ The BETWEEN expression <programlisting>x BETWEEN y AND z</programlisting> is\n semantically equivalent to: <programlisting>y &lt;= x AND x &lt;= z\n </programlisting> The rules for unknown and <literal>NULL</literal> values in\n comparison operations apply. See <xref linkend=\"jpa_langref_null_values\"/>\n-. Examples are: <programlisting>p.age BETWEEN 15 and 19</programlisting> is\n+. \n+                 </para>\n+                 <para>\n+Examples are: <programlisting>p.age BETWEEN 15 and 19</programlisting> is\n equivalent to: <programlisting>p.age &gt;= 15 AND p.age &lt;= 19</programlisting>\n                 </para>\n                 <para>\n The following expression:\n <programlisting>p.age NOT BETWEEN 15 and 19</programlisting> excludes the range, and is equivalent to:\n <programlisting>p.age &lt; 15 OR p.age &gt; 19</programlisting>\n                 </para>\n+                <para>\n+In the following example, <literal>transactionHistory</literal> is a list of credit card \n+transactions defined using an order column.\n+                </para>\n+<programlisting>\n+SELECT t\n+FROM CreditCard c JOIN c.transactionHistory t\n+WHERE c.holder.name = ‘John Doe’ AND INDEX(t) BETWEEN 0 AND 9\n+</programlisting>\n             </section>\n             <section id=\"jpa_langref_in\">\n                 <title>\n@@ -2634,23 +2861,37 @@ in_item ::= literal | single_valued_input_parameter\n                     </itemizedlist>\n                 </para>\n                 <para>\n-The state_field_path_expression must have a string, numeric, or enum value. The\n-literal and/or input_parameter values must be like the same abstract schema type\n-of the state_field_path_expression in type. (See\n+The <literal>state_field_path_expression</literal> must have a string, numeric, or enum value.\n+                </para>\n+                <para>\n+ The literal and/or input_parameter values must be <literal>like</literal> \n+ the same abstract schema type\n+of the <literal>state_field_path_expression</literal> in type. (See\n <xref linkend=\"jpa_langref_equality\"/> ).\n                 </para>\n                 <para>\n-The results of the subquery must be like the same abstract schema type of the\n-state_field_path_expression in type. Subqueries are discussed in\n-<xref linkend=\"jpa_langref_subqueries\"/>. Examples are: <programlisting>o.country IN ('UK', 'US', 'France')\n+The results of the subquery must be <literal>like</literal> the same abstract schema type of the\n+<literal>state_field_path_expression</literal> in type. Subqueries are discussed in\n+<xref linkend=\"jpa_langref_subqueries\"/>.\n+                </para>\n+                <para> \n+Examples: \n+                </para>\n+<programlisting>o.country IN ('UK', 'US', 'France')\n </programlisting> is true for UK and false for Peru, and is equivalent to the\n expression: <programlisting>(o.country = 'UK') OR (o.country = 'US') OR (o.country = ' France')\n </programlisting> In the following expression: <programlisting>o.country NOT IN ('UK', 'US', 'France')\n </programlisting> is false for UK and true for Peru, and is equivalent to the\n expression: <programlisting>NOT ((o.country = 'UK') OR (o.country = 'US') OR (o.country = 'France'))\n-</programlisting> There must be at least one element in the comma separated list\n-that defines the set of values for the <literal>IN</literal> expression. If the\n-value of a state_field_path_expression in an <literal>IN</literal> or <literal>\n+</programlisting> \n+                <para>\n+There must be at least one element in the comma separated list\n+that defines the set of values for the <literal>IN</literal> expression. \n+                </para>\n+                <para>\n+If the \n+value of a <literal>state_field_path_expression</literal> or <literal>in_item</literal> \n+ in an <literal>IN</literal> or <literal>\n NOT IN</literal> expression is <literal>NULL</literal> or unknown, the value of\n the expression is unknown.\n                 </para>\n@@ -2668,17 +2909,21 @@ The syntax for the use of the comparison operator [ <literal>NOT</literal> ]\n <literal>LIKE</literal> in a conditional expression is as follows:\n                 </para>\n                 <para>\n-string_expression [NOT] LIKE pattern_value [ESCAPE escape_character]\n+like_expression ::=\n+string_expression [NOT] LIKE <literal>pattern_value</literal> [ESCAPE <literal>escape_character</literal>]\n                 </para>\n                 <para>\n-The string_expression must have a string value. The pattern_value is a string\n+The <literal>string_expression</literal> must have a string value. \n+The <literal>pattern_value</literal> is a string\n literal or a string-valued input parameter in which an underscore (_) stands for\n any single character, a percent (%) character stands for any sequence of\n characters (including the empty sequence), and all other characters stand for\n themselves. The optional escape_character is a single-character string literal\n or a character-valued input parameter (i.e., char or Character) and is used to\n escape the special meaning of the underscore and percent characters in\n-pattern_value. Examples are:\n+pattern_value. </para>\n+               <para>\n+Examples:\n                 </para>\n                 <para>\n <itemizedlist><listitem><para><programlisting>address.phone LIKE '12%3'\n@@ -2700,15 +2945,18 @@ for '_foo' and false for 'bar'\n                         <listitem>\n                             <para>\n <programlisting>address.phone NOT LIKE '12%3'</programlisting> is false for\n-'123' and '12993' and true for '1234'. If the value of the string_expression or\n-pattern_value is <literal>NULL</literal> or unknown, the value of the <literal>\n-LIKE</literal> expression is unknown. If the escape_character is specified and\n-is <literal>NULL</literal>, the value of the <literal>LIKE</literal> expression\n-is unknown.\n+'123' and '12993' and true for '1234'. \n                             </para>\n                         </listitem>\n                     </itemizedlist>\n                 </para>\n+                <para>\n+If the value of the <literal>string_expression</literal> or\n+<literal>pattern_value</literal> is <literal>NULL</literal> or unknown, the value of the <literal>\n+LIKE</literal> expression is unknown. If the <literal>escape_character</literal> is specified and\n+is <literal>NULL</literal>, the value of the <literal>LIKE</literal> expression\n+is unknown.\n+                </para>\n             </section>\n             <section id=\"jpa_langref_null\">\n                 <title>\n@@ -2719,23 +2967,27 @@ The syntax for the use of the comparison operator <literal>IS NULL</literal> in\n a conditional expression is as follows:\n                 </para>\n                 <para>\n-{single_valued_path_expression | input_parameter } IS [NOT] NULL\n+null_comparison_expression ::= {single_valued_path_expression | input_parameter } IS [NOT] NULL\n                 </para>\n                 <para>\n A null comparison expression tests whether or not the single-valued path\n expression or input parameter is a <literal>NULL</literal> value.\n                 </para>\n+                <para>\n+Null comparisons over instances of embeddable class types are not supported.\n+                </para>\n             </section>\n             <section id=\"jpa_langref_empty_comp\">\n                 <title>\n                     JPQL Empty Collection Comparison Expressions\n                 </title>\n                 <para>\n The syntax for the use of the comparison operator <literal>IS EMPTY</literal> in\n-an empty_collection_comparison_expression is as follows:\n+an <literal>empty_collection_comparison_expression</literal> is as follows:\n                 </para>\n                 <para>\n-collection_valued_path_expression IS [NOT] EMPTY\n+empty_collection_comparison_expression ::=\n+    collection_valued_path_expression IS [NOT] EMPTY\n                 </para>\n                 <para>\n This expression tests whether or not the collection designated by the\n@@ -2744,7 +2996,10 @@ collection-valued path expression is empty (i.e. has no elements).\n                 <para>\n For example, the following query will return all magazines that don't have any\n articles at all: <programlisting>SELECT mag FROM Magazine mag WHERE mag.articles IS EMPTY\n-</programlisting> If the value of the collection-valued path expression in an\n+</programlisting> \n+                 </para>\n+                 <para>\n+If the value of the collection-valued path expression in an\n empty collection comparison expression is unknown, the value of the empty\n comparison expression is unknown.\n                 </para>\n@@ -2754,41 +3009,60 @@ comparison expression is unknown.\n                     JPQL Collection Member Expressions\n                 </title>\n                 <para>\n-The use of the comparison collection_member_expression is as follows:\n+The syntax for the use of the comparison operator <literal>MEMBER OF</literal> \n+in an <literal>collection_member_expression</literal> is as follows:\n                     <itemizedlist>\n                         <listitem>\n                             <para>\n-collection_member_expression ::= entity_expression [NOT] MEMBER [OF]\n+collection_member_expression ::= entity_or_value_expression [NOT] MEMBER [OF]\n collection_valued_path_expression\n                             </para>\n                         </listitem>\n                         <listitem>\n                             <para>\n-entity_expression ::= single_valued_association_path_expression |\n-simple_entity_expression\n+entity_or_value_expression ::= single_valued_object_path_expression |\n+state_field_path_expression |\n+simple_entity_or_value_expression\n                             </para>\n                         </listitem>\n                         <listitem>\n                             <para>\n-simple_entity_expression ::= identification_variable | input_parameter\n+simple_entity_or_value_expression ::= \n+    identification_variable | \n+    input_parameter | \n+    literal\n                             </para>\n                         </listitem>\n                     </itemizedlist>\n                 </para>\n                 <para>\n This expression tests whether the designated value is a member of the collection\n-specified by the collection-valued path expression. If the collection valued\n+specified by the collection-valued path expression. \n+                </para>\n+                <para>\n+                </para>\n+Expressions that evaluate to embeddable types are not supported in collection member expressions.\n+                <para>\n+If the collection valued\n path expression designates an empty collection, the value of the <literal>\n MEMBER OF</literal> expression is <literal>FALSE</literal> and the value of the\n <literal>NOT MEMBER OF</literal> expression is <literal>TRUE</literal>.\n-Otherwise, if the value of the collection-valued path expression or\n-single-valued association-field path expression in the collection member\n+Otherwise, if the value of the <literal>collection_valued_path_expression</literal> or\n+<literal>entity_or_value_expression</literal> in the collection member\n expression is <literal>NULL</literal> or unknown, the value of the collection\n member expression is unknown.\n                 </para>\n                 <para>\n The use of the reserved word OF is optional in this expression.\n                 </para>\n+                <para>\n+Example:\n+                </para>\n+                <programlisting>\n+SELECT p\n+FROM Person p\n+WHERE 'Joe' MEMBER OF p.nicknames\n+                </programlisting>\n             </section>\n             <section id=\"jpa_langref_exists\">\n                 <title>\n@@ -2816,17 +3090,25 @@ is also an author.\n                     JPQL All or Any Expressions\n                 </title>\n                 <para>\n-An <literal>ALL</literal> conditional expression is a predicate that is true if\n-the comparison operation is true for all values in the result of the subquery or\n-the result of the subquery is empty. An <literal>ALL</literal> conditional\n+An <literal>ALL</literal> conditional expression is a predicate \n+over a subquery that is true if the comparison operation is\n+true for all values in the result of the subquery or the result of the subquery is empty. \n+An <literal>ALL</literal> conditional\n expression is false if the result of the comparison is false for at least one\n-row, and is unknown if neither true nor false. An <literal>ANY</literal>\n-conditional expression is a predicate that is true if the comparison operation\n+value of the result of the subquery, \n+and is unknown if neither true nor false. \n+                 </para>\n+                 <para>\n+An <literal>ANY</literal> \n+conditional expression is a predicate over a subquery that is true if the comparison operation\n is true for some value in the result of the subquery. An <literal>ANY</literal>\n conditional expression is false if the result of the subquery is empty or if the\n comparison operation is false for every value in the result of the subquery, and\n is unknown if neither true nor false. The keyword <literal>SOME</literal> is\n-synonymous with <literal>ANY</literal>. The comparison operators used with\n+synonymous with <literal>ANY</literal>. \n+                  </para>\n+                  <para>\n+The comparison operators used with\n <literal>ALL</literal> or <literal>ANY</literal> conditional expressions are =,\n &lt;, &lt;=, &gt;, &gt;=, &lt;&gt;. The result of the subquery must be like that\n of the other argument to the comparison operator in type. See\n@@ -2869,22 +3151,37 @@ simple_select_expression\n                         <listitem>\n                             <para>\n subquery_from_clause ::= FROM subselect_identification_variable_declaration {,\n-subselect_identification_variable_declaration}*\n+subselect_identification_variable_declaration |\n+collection_member_declaration }*\n                             </para>\n                         </listitem>\n                         <listitem>\n                             <para>\n subselect_identification_variable_declaration ::=\n-identification_variable_declaration | association_path_expression [AS]\n-identification_variable | collection_member_declaration\n+identification_variable_declaration | derived_path_expression [AS]\n+identification_variable {join}* | derived_collection_member_declaration\n                             </para>\n                         </listitem>\n                         <listitem>\n                             <para>\n simple_select_expression ::= single_valued_path_expression |\n+scalar_expression |\n aggregate_expression | identification_variable\n                             </para>\n                         </listitem>\n+                        <listitem>\n+                            <para>\n+derived_path_expression ::=\n+superquery_identification_variable.{single_valued_object_field.}*collection_valued_field |\n+superquery_identification_variable.{single_valued_object_field.}*single_valued_object_field\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+derived_collection_member_declaration ::=\n+IN superquery_identification_variable.{single_valued_object_field.}*collection_valued_field \n+                            </para>\n+                        </listitem>\n                     </itemizedlist>\n                 </para>\n                 <para>\n@@ -2897,6 +3194,12 @@ subquery be a scalar subquery (i.e., produce a single result). This is\n illustrated in the following example involving a numeric comparison operation.\n <programlisting>SELECT goodPublisher FROM Publisher goodPublisher\n     WHERE goodPublisher.revenue &lt; (SELECT AVG(p.revenue) FROM Publisher p)\n+</programlisting>\n+<programlisting>\n+SELECT goodCustomer\n+FROM Customer goodCustomer\n+WHERE goodCustomer.balanceOwed &lt; (\n+SELECT AVG(c.balanceOwed)/2.0 FROM Customer c)\n </programlisting>\n                 </para>\n             </section>\n@@ -2922,7 +3225,7 @@ boolean_primary |\n case_expression |\n entity_type_expression                \n                 </para>\n-            <section id=\"jpa_langref_arithmetic_expressions\">\n+            <section id=\"jpa_langref_math_expressions\">\n                 <title>\n                     Arithmetic Expressions\n                 </title>\n@@ -2937,7 +3240,7 @@ The arithmetic operators are:\n Arithmetic operations use numeric promotion.\n                 </para>\n                 <para>\n-Arithmetic functions are described in section <xref link=\"jpa_langref_arithmetic\"/>.\n+Arithmetic functions are described in section <xref linkend=\"jpa_langref_arithmetic\"/>.\n                 </para>\n                 </para>\n             </section>\n@@ -2948,15 +3251,15 @@ Arithmetic functions are described in section <xref link=\"jpa_langref_arithmetic\n                 <para> \n JPQL includes the built-in functions described in subsections \n <xref linkend=\"jpa_langref_string_fun\"/>, \n-<xref linkend=\"jpa_langref_arithmetic\"/>,\n-<xref linkend=\"jpa_langref_datetime\"/>,\n-which may be used in the <literal>SELECT</literal>,\n-<literal>WHERE</literal>\n+<xref linkend=\"jpa_langref_arithmetic\"/>, \n+<xref linkend=\"jpa_langref_datetime\"/>, \n+which may be used in the <literal>SELECT</literal>, \n+<literal>WHERE</literal> \n or <literal>HAVING</literal> clause of a query.\n                  <para>\n                  </para>               \n If the\n-value of any argument to a functional expression is null or unknown, the value\n+value of any argument to a functional expression is null or unknown, the value \n of the functional expression is unknown.\n                 </para>\n                 <section id=\"jpa_langref_string_fun\">\n@@ -3033,7 +3336,8 @@ integer.\n                     </title>\n                     <para>\n <itemizedlist><listitem><para>functions_returning_numerics ::=\n-ABS(simple_arithmetic_expression) | SQRT(simple_arithmetic_expression) |\n+ABS(simple_arithmetic_expression) | \n+SQRT(simple_arithmetic_expression) |\n MOD(simple_arithmetic_expression, simple_arithmetic_expression) |\n SIZE(collection_valued_path_expression) |\n INDEX(identification_variable)\n@@ -3087,6 +3391,142 @@ the database server.\n                     </para>\n                 </section>\n             </section>\n+            <section id=\"jpa_langref_case_expressions\">\n+                <title>\n+                    Case Expressions\n+                </title>\n+                <para>\n+The following forms of case expressions are supported: general case expressions, simple case expressions,\n+coalesce expressions, and nullif expressions.[\n+<itemizedlist>\n+<listitem>\n+case_expression::=\n+general_case_expression |\n+simple_case_expression |\n+coalesce_expression |\n+nullif_expression\n+</listitem>\n+<listitem>\n+general_case_expression::=\n+<literal>CASE</literal> when_clause {when_clause}* <literal>ELSE</literal> scalar_expression <literal>END</literal>\n+</listitem>\n+<listitem>\n+when_clause::= <literal>WHEN</literal> conditional_expression <literal>THEN</literal> scalar_expression\n+</listitem>\n+simple_case_expression::=\n+<literal>CASE</literal> case_operand simple_when_clause {simple_when_clause}*\n+<literal>ELSE</literal> scalar_expression\n+<literal>END</literal>\n+<listitem>\n+case_operand::= state_field_path_expression | type_discriminator\n+</listitem>\n+<listitem>\n+simple_when_clause::= <literal>WHEN</literal> scalar_expression <literal>THEN</literal> scalar_expression\n+</listitem>\n+<listitem>\n+coalesce_expression::= <literal>COALESCE</literal>(scalar_expression {, scalar_expression}+)\n+</listitem>\n+<listitem>\n+nullif_expression::= <literal>NULLIF</literal>(scalar_expression, scalar_expression)\n+</listitem>\n+                </itemizedlist>\n+                </para>\n+                <para>\n+Examples:\n+                </para>\n+<programlisting>\n+UPDATE Employee e\n+SET e.salary =\n+    CASE WHEN e.rating = 1 THEN e.salary * 1.1\n+         WHEN e.rating = 2 THEN e.salary * 1.05\n+         ELSE e.salary * 1.01\n+    END\n+</programlisting>\n+<programlisting>\n+UPDATE Employee e\n+SET e.salary =\n+    CASE e.rating WHEN 1 THEN e.salary * 1.1\n+                  WHEN 2 THEN e.salary * 1.05\n+                  ELSE e.salary * 1.01\n+    END\n+</programlisting>\n+<programlisting>\n+SELECT e.name,\n+    CASE TYPE(e) WHEN Exempt THEN 'Exempt'\n+                 WHEN Contractor THEN 'Contractor'\n+                 WHEN Intern THEN 'Intern'\n+                 ELSE 'NonExempt'\n+    END\n+FROM Employee e\n+WHERE e.dept.name = 'Engineering'\n+</programlisting>\n+<programlisting>\n+SELECT e.name,\n+       f.name,\n+       CONCAT(CASE WHEN f.annualMiles &gt; 50000 THEN 'Platinum '\n+                   WHEN f.annualMiles &gt; 25000 THEN 'Gold '\n+                   ELSE ''\n+                   END,\n+              'Frequent Flyer')\n+FROM Employee e JOIN e.frequentFlierPlan f  \n+</programlisting>\n+            </section>\n+            <section id=\"jpa_langref_entity_type_expressions\">\n+                <title>\n+                    Entity Type Expressions\n+                </title>\n+                <para>\n+An entity type expression can be used to restrict query polymorphism. \n+The <literal>TYPE</literal> operator returns the\n+exact type of the argument.\n+                </para>\n+                <para>\n+The syntax of an entity type expression is as follows:\n+                </para>\n+                <itemizedlist>\n+<listitem>\n+entity_type_expression ::=\n+type_discriminator |\n+entity_type_literal |\n+input_parameter\n+</listitem>\n+<listitem>\n+type_discriminator ::=\n+TYPE(identification_variable |\n+single_valued_object_path_expression |\n+input_parameter )\n+</listitem>\n+                </itemizedlist>\n+                <para>\n+An <literal>entity_type_literal</literal> is designated by the entity name.\n+                </para>\n+                <para>\n+The Java class of the entity is used as an input parameter to specify the entity type.\n+                </para>\n+                <para>\n+Examples:\n+                </para>\n+<programlisting>\n+SELECT e\n+FROM Employee e\n+WHERE TYPE(e) IN (Exempt, Contractor)\n+</programlisting>\n+<programlisting>\n+SELECT e\n+FROM Employee e\n+WHERE TYPE(e) IN (:empType1, :empType2)\n+</programlisting>\n+<programlisting>\n+SELECT e\n+FROM Employee e\n+WHERE TYPE(e) IN :empTypes\n+</programlisting>\n+<programlisting>\n+SELECT TYPE(e)\n+FROM Employee e\n+WHERE TYPE(e) &lt;&gt; Exempt\n+</programlisting>\n+            </section>\n             </section>\n         <section id=\"jpa_langref_group\">\n             <title>\n@@ -3096,7 +3536,10 @@ the database server.\n The <literal>GROUP BY</literal> construct enables the aggregation of values\n according to a set of properties. The <literal>HAVING</literal> construct\n enables conditions to be specified that further restrict the query result. Such\n-conditions are restrictions upon the groups. The syntax of the <literal>GROUP\n+conditions are restrictions upon the groups.\n+            </para>\n+            <para> \n+The syntax of the <literal>GROUP\n BY</literal> and <literal>HAVING</literal> clauses is as follows:\n             </para>\n             <para>\n@@ -3122,13 +3565,24 @@ BY</literal> clause, the effect is that of first applying the where clause, and\n then forming the groups and filtering them according to the <literal>HAVING\n </literal> clause. The <literal>HAVING</literal> clause causes those groups to\n be retained that satisfy the condition of the <literal>HAVING</literal> clause.\n+             </para>\n+             <para>\n The requirements for the <literal>SELECT</literal> clause when <literal>GROUP\n BY</literal> is used follow those of SQL: namely, any item that appears in the\n <literal>SELECT</literal> clause (other than as an argument to an aggregate\n function) must also appear in the <literal>GROUP BY</literal> clause. In forming\n-the groups, null values are treated as the same for grouping purposes. Grouping\n+the groups, null values are treated as the same for grouping purposes. \n+             </para>\n+             <para>\n+Grouping\n by an entity is permitted. In this case, the entity must contain no serialized\n-state fields or lob-valued state fields. The <literal>HAVING</literal> clause\n+state fields or lob-valued state fields that are eagerly fetched.\n+             </para>\n+             <para>\n+Grouping by embeddables is not supported.\n+             </para>\n+             <para>\n+The <literal>HAVING</literal> clause\n must specify search conditions over the grouping items or aggregate functions\n that apply to grouping items.\n             </para>\n@@ -3139,28 +3593,56 @@ select list can only consist of aggregate functions. When a query declares a\n <literal>HAVING</literal> clause, it must always also declare a <literal>GROUP\n BY</literal> clause.\n             </para>\n+            <para>\n+Examples:\n+            </para>\n+            <programlisting>\n+SELECT c.status, AVG(c.filledOrderCount), COUNT(c)\n+FROM Customer c\n+GROUP BY c.status\n+HAVING c.status IN (1, 2)\n+</programlisting>\n+<programlisting>\n+SELECT c.country, COUNT(c)\n+FROM Customer c\n+GROUP BY c.country\n+HAVING COUNT(c) &gt; 30\n+</programlisting>\n         </section>\n         <section id=\"jpa_langref_select_clause\">\n             <title>\n                 JPQL SELECT Clause\n             </title>\n             <para>\n The <literal>SELECT</literal> clause denotes the query result. More than one\n-value may be returned from the <literal>SELECT</literal> clause of a query. The\n-<literal>SELECT</literal> clause may contain one or more of the following\n+value may be returned from the <literal>SELECT</literal> clause of a query.\n+            </para>\n+            <para> \n+The <literal>SELECT</literal> clause can contain one or more of the following\n elements: a single range variable or identification variable that ranges over an\n-entity abstract schema type, a single-valued path expression, an aggregate\n-select expression, a constructor expression. The <literal>SELECT</literal>\n+entity abstract schema type, a single-valued path expression, \n+a scalar expression, \n+an aggregate expression, a constructor expression. \n+             </para>\n+             <para>\n+The <literal>SELECT</literal>\n clause has the following syntax:\n             </para>\n             <para>\n <itemizedlist><listitem><para>select_clause ::= SELECT [DISTINCT]\n-select_expression {, select_expression}*\n+select_item {, select_item}*\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-select_expression ::= single_valued_path_expression | aggregate_expression |\n+select_item ::= select_expression [ [AS] result_variable]\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+select_expression ::= single_valued_path_expression | \n+scalar_expression | \n+aggregate_expression |\n identification_variable | OBJECT(identification_variable) |\n constructor_expression\n                         </para>\n@@ -3173,14 +3655,17 @@ constructor_item}*)\n                     </listitem>\n                     <listitem>\n                         <para>\n-constructor_item ::= single_valued_path_expression | aggregate_expression\n+constructor_item ::= single_valued_path_expression | \n+scalar_expression | \n+aggregate_expression |\n+identification_variable\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n aggregate_expression ::= { AVG | MAX | MIN | SUM } ([DISTINCT]\n state_field_path_expression) | COUNT ([DISTINCT] identification_variable |\n-state_field_path_expression | single_valued_association_path_expression)\n+state_field_path_expression | single_valued_object_path_expression)\n                         </para>\n                     </listitem>\n                 </itemizedlist>\n@@ -3191,50 +3676,135 @@ For example: <programlisting>SELECT pub.id, pub.revenue\n </programlisting>\n             </para>\n             <para>\n+In the following example, videoInventory is a Map from the entity Movie to the number of copies\n+in stock:\n+            </para>\n+<programlisting>\n+SELECT v.location.street, KEY(i).title, VALUE(i)\n+FROM VideoStore v JOIN v.videoInventory i\n+WHERE v.location.zipcode = '94301' AND VALUE(i) &gt; 0\n+</programlisting>\n+            <para>\n Note that the <literal>SELECT</literal> clause must be specified to return only\n single-valued expressions. The query below is therefore not valid:\n-<programlisting>SELECT mag.authors FROM Magazine AS mag</programlisting> The\n-<literal>DISTINCT</literal> keyword is used to specify that duplicate values\n-must be eliminated from the query result. If <literal>DISTINCT</literal> is not\n-specified, duplicate values are not eliminated. Standalone identification\n+<programlisting>SELECT mag.authors FROM Magazine AS mag</programlisting>\n+            </para>\n+            <para>\n+The <literal>DISTINCT</literal> keyword is used to specify that duplicate values\n+must be eliminated from the query result.\n+            </para>\n+            <para> \n+If <literal>DISTINCT</literal> is not\n+specified, duplicate values are not eliminated. \n+            </para>\n+            <para>\n+The result of DISTINCT over embeddable objects or map entry results is undefined.\n+            </para>\n+            <para>\n+Standalone identification\n variables in the <literal>SELECT</literal> clause may optionally be qualified by\n the <literal>OBJECT</literal> operator. The <literal>SELECT</literal> clause\n must not use the OBJECT operator to qualify path expressions.\n+            </para>\n+            <para>\n+A result_variable may be used to name a select_item in the query result. \n+ For example,\n+<programlisting>\n+SELECT c, COUNT(l) AS itemCount\n+FROM Customer c JOIN c.Orders o JOIN o.lineItems l\n+WHERE c.address.state = ‘CA’\n+ORDER BY itemCount\n+ </programlisting>          \n             </para>\n             <section id=\"jpa_langref_resulttype\">\n                 <title>\n                     JPQL Result Type of the SELECT Clause\n                 </title>\n                 <para>\n The type of the query result specified by the <literal>SELECT</literal> clause\n-of a query is an entity abstract schema type, a state-field type, the result of\n+of a query is an entity abstract schema type, a state-field type, \n+the result of of a scalar expression, the result of \n an aggregate function, the result of a construction operation, or some sequence\n-of these. The result type of the <literal>SELECT</literal> clause is defined by\n+of these. \n+                </para>\n+                <para>\n+The result type of the <literal>SELECT</literal> clause is defined by\n the result types of the select_expressions contained in it. When multiple\n-select_expressions are used in the <literal>SELECT</literal> clause, the result\n+select expressions are used in the <literal>SELECT</literal> clause, the result\n of the query is of type Object[], and the elements in this result correspond in\n order to the order of their specification in the <literal>SELECT</literal>\n-clause and in type to the result types of each of the select_expressions. The\n-type of the result of a select_expression is as follows: <itemizedlist>\n-<listitem><para> A single_valued_path_expression that is a\n-state_field_path_expression results in an object of the same type as the\n-corresponding state field of the entity. If the state field of the entity is a\n-primitive type, the corresponding object type is returned.\n+clause and in type to the result types of each of the select expressions. \n+                </para>\n+                <para>\n+The type of the result of a <literal>select_expression</literal> is as follows:\n+<itemizedlist>\n+                        <listitem>\n+                            <para>\n+The result type of an <literal>identification_variable</literal>  \n+is the type of the entity object or embeddable\n+object to which the identification variable corresponds. The type of an \n+<literal>identification_variable</literal>\n+that refers to an entity abstract schema type is the type of the entity to which that identification\n+variable corresponds or a subtype as determined by the object/relational mapping.\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para> \n+The result type of a <literal>single_valued_path_expression</literal> that is a\n+<literal>state_field_path_expression</literal> \n+results in an object of the same type as the\n+corresponding state field of the entity or embeddable class. \n+If the state field of the entity is a\n+primitive type, the result type is the corresponding object type.\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+The result type of a <literal>single_valued_path_expression</literal> that is a\n+<literal>single_valued_object_path_expression</literal> \n+is the type of the entity object or embeddable\n+object to which the path expression corresponds.\n+A <literal>single_valued_object_path_expression</literal> \n+that results in an entity object will result in an entity of the type of \n+the relationship field or the\n+subtype of the relationship field of the entity object as determined by \n+the object/relational mapping.\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+The result type of a \n+<literal>single_valued_path_expression</literal> \n+that is an identification_variable to\n+which the <literal>KEY</literal> or <literal>VALUE</literal> function \n+has been applied is determined by the type of the map key\n+or value respectively, as defined by the above rules\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+The result type of a \n+<literal>single_valued_path_expression</literal> that is an \n+<literal>identification_variable</literal> to\n+which the <literal>ENTRY</literal> function has been applied is \n+<literal>java.util.Map.Entry</literal>, where the key\n+and value types of the map entry are determined by the above rules as applied to the map key\n+and map value respectively.\n                             </para>\n                         </listitem>\n                         <listitem>\n                             <para>\n-single_valued_path_expression that is a\n-single_valued_association_path_expression results in an entity object of the\n-type of the relationship field or the subtype of the relationship field of the\n-entity object as determined by the object/relational mapping.\n+The result type of a \n+<literal>scalar_expression</literal> is the type of the scalar value to which the expression\n+evaluates. The result type of a numeric <literal>scalar_expression</literal> is defined in section\n+<xref linkend=\"jpa_langref_scalar_expressions\"/>\n                             </para>\n                         </listitem>\n                         <listitem>\n                             <para>\n-The result type of an identification_variable is the type of the entity to which\n-that identification variable corresponds or a subtype as determined by the\n-object/relational mapping.\n+The result type of an \n+<literal>entity_type_expression</literal> scalar expression is the Java class to which the\n+resulting abstract schema type corresponds.\n                             </para>\n                         </listitem>\n                         <listitem>\n@@ -3245,7 +3815,8 @@ The result type of aggregate_expression is defined in section\n                         </listitem>\n                         <listitem>\n                             <para>\n-The result type of a constructor_expression is the type of the class for which\n+The result type of a \n+<literal>constructor_expression</literal> is the type of the class for which\n the constructor is defined. The types of the arguments to the constructor are\n defined by the above rules.\n                             </para>\n@@ -3265,10 +3836,18 @@ The constructor name must be fully qualified.\n                 </para>\n                 <para>\n If an entity class name is specified in the <literal>SELECT NEW</literal>\n-clause, the resulting entity instances are in the new state. <programlisting>SELECT NEW com.company.PublisherInfo(pub.id, pub.revenue, mag.price)\n+clause, the resulting entity instances are in the new state.\n+                </para>\n+                <para>\n+If a single_valued_path_expression or identification_variable that is an argument to the constructor\n+references an entity, the resulting entity instance will be in the managed state.\n+                </para>\n+                <para>\n+Example:\n+                </para> \n+<programlisting>SELECT NEW com.company.PublisherInfo(pub.id, pub.revenue, mag.price)\n     FROM Publisher pub JOIN pub.magazines mag WHERE mag.price &gt; 5.00\n </programlisting>\n-                </para>\n             </section>\n             <section id=\"jpa_langref_null_select\">\n                 <title>\n@@ -3278,31 +3857,87 @@ clause, the resulting entity instances are in the new state. <programlisting>SEL\n If the result of a query corresponds to a association-field or state-field whose\n value is null, that null value is returned in the result of the query method.\n The <literal>IS NOT NULL</literal> construct can be used to eliminate such null\n-values from the result set of the query. Note, however, that state-field types\n+values from the result set of the query.\n+                </para>\n+                <para> \n+Note, however, that state-field types\n defined in terms of Java numeric primitive types cannot produce <literal>NULL\n </literal> values in the query result. A query that returns such a state-field\n type as a result type must not return a null value.\n                 </para>\n             </section>\n+            <section id=\"jpa_langref_embeddables\">\n+                <title>\n+                    JPQL Embeddables in the Query Result\n+                </title>\n+                <para> \n+If the result of a query corresponds to an identification variable or state field whose value is an\n+embeddable, the embeddable instance returned by the query will not be in the managed state (i.e., it will\n+not be part of the state of any managed entity). \n+                </para>          \n+                <para> \n+In the following example, the <literal>Address</literal> instances returned by the query will reference Phone\n+instances. While the <literal>Phone</literal> instances will be managed, \n+the <literal>Address</literal>> instances referenced by the\n+<literal>addr</literal> result variable will not be. \n+Modifications to these embeddable instances are not allowed.\n+                </para>  \n+<programlisting>\n+@Entity\n+public class Employee {\n+  @Id int id;\n+  Address address;\n+  ...\n+}\n+\n+@Embeddable\n+public class Address { \n+  String street;\n+  ...\n+  @OneToOne Phone phone; // fetch=EAGER\n+}\n+\n+@Entity\n+public class Phone {\n+  @Id int id;\n+  ...\n+  @OneToOne(mappedBy=\"address.phone\") Employee emp; // fetch=EAGER\n+}\n+\n+SELECT e.address AS addr\n+FROM Employee e\n+</programlisting>        \n+            </section>\n             <section id=\"jpa_langref_aggregates\">\n                 <title>\n                     JPQL Aggregate Functions\n                 </title>\n                 <para>\n The result of a query may be the result\n-of an aggregate function applied to a path expression. The following aggregate\n+of an aggregate function applied to a path expression.\n+                </para>\n+                <para> \n+The following aggregate\n functions can be used in the <literal>SELECT</literal> clause of a query:\n <literal>AVG</literal>, <literal>COUNT</literal>, <literal>MAX</literal>,\n-<literal>MIN</literal>, <literal>SUM</literal>. For all aggregate functions\n+<literal>MIN</literal>, <literal>SUM</literal>. \n+                </para>\n+                <para>\n+For all aggregate functions\n except <literal>COUNT</literal>, the path expression that is the argument to\n the aggregate function must terminate in a state-field. The path expression\n argument to <literal>COUNT</literal> may terminate in either a state-field or a\n association-field, or the argument to <literal>COUNT</literal> may be an\n-identification variable. Arguments to the functions <literal>SUM</literal> and\n+identification variable. \n+                </para>\n+                <para>\n+Arguments to the functions <literal>SUM</literal> and\n <literal>AVG</literal> must be numeric. Arguments to the functions <literal>MAX\n </literal> and <literal>MIN</literal> must correspond to orderable state-field\n-types (i.e., numeric types, string types, character types, or date types). The\n-Java type that is contained in the result of a query using an aggregate function\n+types (i.e., numeric types, string types, character types, or date types).\n+                </para>\n+                <para>\n+The Java type that is contained in the result of a query using an aggregate function\n is as follows: <itemizedlist><listitem><para><literal>COUNT</literal> returns\n Long.\n                             </para>\n@@ -3323,25 +3958,36 @@ state-field to which they are applied.\n <literal>SUM</literal> returns Long when applied to state-fields of integral\n types (other than BigInteger); Double when applied to state-fields of floating\n point types; BigInteger when applied to state-fields of type BigInteger; and\n-BigDecimal when applied to state-fields of type BigDecimal. If <literal>SUM\n+BigDecimal when applied to state-fields of type BigDecimal. \n+                </para>\n+                        </listitem>\n+                    </itemizedlist>\n+                </para>\n+                <para>\n+If <literal>SUM\n </literal>, <literal>AVG</literal>, <literal>MAX</literal>, or <literal>MIN\n </literal> is used, and there are no values to which the aggregate function can\n-be applied, the result of the aggregate function is <literal>NULL</literal>. If\n-<literal>COUNT</literal> is used, and there are no values to which <literal>\n+be applied, the result of the aggregate function is <literal>NULL</literal>.\n+                </para>\n+                <para>\n+If <literal>COUNT</literal> is used, and there are no values to which <literal>\n COUNT</literal> can be applied, the result of the aggregate function is 0.\n                             </para>\n-                        </listitem>\n-                    </itemizedlist>\n-                </para>\n                 <para>\n The argument to an aggregate function may be preceded by the keyword <literal>\n DISTINCT</literal> to specify that duplicate values are to be eliminated before\n the aggregate function is applied.\n It is legal to specify <literal>DISTINCT</literal> with <literal>MAX</literal>\n or <literal>MIN</literal>, but it does not affect the result.\n+                </para>\n+                <para>\n Null values are eliminated before the\n aggregate function is applied, regardless of whether the keyword <literal>\n DISTINCT</literal> is specified.\n+                </para>\n+                <para>\n+The use of <literal>DISTINCT</literal> with <literal>COUNT</literal> is not supported for arguments of \n+embeddable types or map entry types.\n                 </para>\n                 <section id=\"jpa_langref_agg_examples\">\n                     <title>\n@@ -3356,6 +4002,66 @@ magazines published by 'Larry': <programlisting>SELECT SUM(mag.price) FROM Publi\n <programlisting>SELECT COUNT(mag) FROM Magazine mag</programlisting>\n                     </para>\n                 </section>\n+                <section id =\"jpa_langref_numeric_expressions_in_select\">\n+                    <title>\n+                        JPQL Numeric Expressions in the SELECT Clause\n+                    </title>\n+                    <para>\n+The type of a numeric expression in the query result is determined as follows:\n+                    </para>\n+                    <para>\n+An operand that corresponds to a persistent state-field is of the same type as that persistent state-field.\n+                    </para>\n+                    <para>\n+An operand that corresponds to one of arithmetic functions described in section \n+<xref linkend=\"jpa_langref_arithmetic\"/> is of the type defined by section \n+<xref linkend=\"jpa_langref_arithmetic\"/>.\n+                    </para>\n+                    <para>\n+An operand that corresponds to one of an aggregate functions described in section \n+<xref linkend=\"jpa_langref_aggregates\"/> is of the type defined by section \n+<xref linkend=\"jpa_langref_aggregates\"/>.\n+                    </para>\n+                    <para>\n+The result of a case expression, coalesce expression, nullif expression, or arithmetic expression (+, -, *,\n+/) is determined by applying the following rule to its operands.\n+                    </para>\n+                    <itemizedlist>\n+                    <listitem>\n+                        <para>\n+If there is an operand of type Double or double, the result of the operation is of type Double;\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+otherwise, if there is an operand of type Float or float, the result of the operation is of type\n+Float;\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+otherwise, if there is an operand of type BigDecimal, the result of the operation is of type Big-\n+Decimal;\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+otherwise, if there is an operand of type BigInteger, the result of the operation is of type BigInteger;\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+otherwise, if there is an operand of type Long or long, the result of the operation is of type\n+Long;\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+otherwise, if there is an operand of integral type, the result of the operation is of type Integer.\n+                        </para>\n+                    </listitem>\n+                    </itemizedlist>\n+                </section>\n             </section>\n         </section>\n         <section id=\"jpa_langref_orderby\">\n@@ -3374,7 +4080,7 @@ orderby_item}*\n                     </listitem>\n                     <listitem>\n                         <para>\n-orderby_item ::= state_field_path_expression [ASC | DESC]\n+orderby_item ::= { state_field_path_expression | result_variable } [ASC | DESC]\n                         </para>\n                     </listitem>\n                 </itemizedlist>"}]}

