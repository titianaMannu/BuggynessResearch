{"sha":"433475f6ad37062a00916c6a79f7ac08f35bdc4e","node_id":"MDY6Q29tbWl0MjA2MzY0OjQzMzQ3NWY2YWQzNzA2MmEwMDkxNmM2YTc5ZjdhYzA4ZjM1YmRjNGU=","commit":{"author":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-10-06T22:31:28Z"},"committer":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-10-06T22:31:28Z"},"message":"Merge fixes from Kodo 4.0 line.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@453796 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"57179feb474fc5225cb03397c31959a874b67a95","url":"https://api.github.com/repos/apache/openjpa/git/trees/57179feb474fc5225cb03397c31959a874b67a95"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/433475f6ad37062a00916c6a79f7ac08f35bdc4e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/433475f6ad37062a00916c6a79f7ac08f35bdc4e","html_url":"https://github.com/apache/openjpa/commit/433475f6ad37062a00916c6a79f7ac08f35bdc4e","comments_url":"https://api.github.com/repos/apache/openjpa/commits/433475f6ad37062a00916c6a79f7ac08f35bdc4e/comments","author":null,"committer":null,"parents":[{"sha":"ac1679d41cc43174affec904f1265abe3492cfb5","url":"https://api.github.com/repos/apache/openjpa/commits/ac1679d41cc43174affec904f1265abe3492cfb5","html_url":"https://github.com/apache/openjpa/commit/ac1679d41cc43174affec904f1265abe3492cfb5"}],"stats":{"total":162,"additions":109,"deletions":53},"files":[{"sha":"7879833ae969a3b1a310064e3bd8471f9b09f44d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java","status":"modified","additions":16,"deletions":1,"changes":17,"blob_url":"https://github.com/apache/openjpa/blob/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java?ref=433475f6ad37062a00916c6a79f7ac08f35bdc4e","patch":"@@ -1634,7 +1634,7 @@ else if (!defaultTarget(col, tcol, num))\n         if (col.getDefaultString() != null)\n             copy.setDefaultString(col.getDefaultString());\n         if (col.isNotNull() && !col.isPrimaryKey()\n-            && !isPrimitive(col.getJavaType()))\n+            && (!isPrimitive(col.getJavaType()) || isForeignKey(col)))\n             copy.setNotNull(true);\n \n         // set type name if not default\n@@ -1674,6 +1674,21 @@ else if (!defaultTarget(col, tcol, num))\n         return copy;\n     }\n \n+    /** \n+     * Return whether the given column belongs to a foreign key.\n+     */ \n+    private static boolean isForeignKey(Column col) \n+    {       \n+        if (col.getTable() == null)\n+            return false;\n+        ForeignKey[] fks = col.getTable().getForeignKeys();\n+        for (int i = 0; i < fks.length; i++) \n+            if (fks[i].containsColumn(col) \n+                || fks[i].containsConstantColumn(col))\n+                return true;\n+        return false;\n+    }\n+\n     /**\n      * Return true if the given type code represents a primitive.\n      */"},{"sha":"98c74e33289efba6e53215694b5f01af5c5e7cad","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","status":"modified","additions":17,"deletions":10,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java?ref=433475f6ad37062a00916c6a79f7ac08f35bdc4e","patch":"@@ -180,7 +180,7 @@ public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n         OpenJPAStateManager rel = RelationStrategies.getStateManager\n             (sm.fetchObjectField(field.getIndex()), store.getContext());\n         if (field.getJoinDirection() == field.JOIN_INVERSE)\n-            updateInverse(sm, rel, store, rm, sm);\n+            updateInverse(sm, rel, store, rm);\n         else {\n             Row row = field.getRow(sm, store, rm, Row.ACTION_INSERT);\n             if (row != null)\n@@ -198,7 +198,7 @@ public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n \n         if (field.getJoinDirection() == field.JOIN_INVERSE) {\n             nullInverse(sm, rm);\n-            updateInverse(sm, rel, store, rm, sm);\n+            updateInverse(sm, rel, store, rm);\n         } else {\n             Row row = field.getRow(sm, store, rm, Row.ACTION_UPDATE);\n             if (row != null)\n@@ -215,7 +215,7 @@ public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n             if (sm.getLoaded().get(field.getIndex())) {\n                 OpenJPAStateManager rel = RelationStrategies.getStateManager(sm.\n                     fetchObjectField(field.getIndex()), store.getContext());\n-                updateInverse(sm, rel, store, rm, null);\n+                updateInverse(sm, rel, store, rm);\n             } else\n                 nullInverse(sm, rm);\n         } else {\n@@ -241,6 +241,9 @@ public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n      */\n     private void nullInverse(OpenJPAStateManager sm, RowManager rm)\n         throws SQLException {\n+        if (field.getUseClassCriteria())\n+            return;\n+\n         ForeignKey fk = field.getForeignKey();\n         ColumnIO io = field.getColumnIO();\n         if (!io.isAnyUpdatable(fk, true))\n@@ -260,23 +263,27 @@ private void nullInverse(OpenJPAStateManager sm, RowManager rm)\n      * with the given object.\n      */\n     private void updateInverse(OpenJPAStateManager sm, OpenJPAStateManager rel,\n-        JDBCStore store, RowManager rm, OpenJPAStateManager sm2)\n+        JDBCStore store, RowManager rm)\n         throws SQLException {\n-        // nothing to do if inverse is null or about to be deleted\n-        //### should we throw an exception if the inverse is null?\n-        if (rel == null || rel.isDeleted())\n+        if (rel == null)\n             return;\n \n         ForeignKey fk = field.getForeignKey();\n         ColumnIO io = field.getColumnIO();\n \n         int action;\n         if (rel.isNew() && !rel.isFlushed()) {\n-            if (sm2 == null || !io.isAnyInsertable(fk, false))\n+            if (sm.isDeleted() || !io.isAnyInsertable(fk, false))\n                 return;\n             action = Row.ACTION_INSERT;\n+        } else if (rel.isDeleted()) {\n+            if (rel.isFlushed() || !sm.isDeleted())\n+                return;\n+            action = Row.ACTION_DELETE;\n         } else {\n-            if (!io.isAnyUpdatable(fk, sm2 == null))\n+            if (sm.isDeleted())\n+                sm = null;\n+            if (!io.isAnyUpdatable(fk, sm == null))\n                 return;\n             action = Row.ACTION_UPDATE;\n         }\n@@ -306,7 +313,7 @@ private void updateInverse(OpenJPAStateManager sm, OpenJPAStateManager rel,\n             row.wherePrimaryKey(rel);\n \n         // update the inverse pointer with our oid value\n-        row.setForeignKey(fk, io, sm2);\n+        row.setForeignKey(fk, io, sm);\n     }\n \n     public int supportsSelect(Select sel, int type, OpenJPAStateManager sm,"},{"sha":"f76f1f7290692c1f66ff85c2c30dbbaf96299c28","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java","status":"modified","additions":30,"deletions":12,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java?ref=433475f6ad37062a00916c6a79f7ac08f35bdc4e","patch":"@@ -216,23 +216,32 @@ public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n \n     public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n         throws SQLException {\n-        if (field.getMappedBy() != null\n-            || field.getElementMapping().getUseClassCriteria())\n+        if (field.getMappedBy() != null)\n             return;\n \n+        // if nullable, null any existing inverse columns that refer to this obj\n         ValueMapping elem = field.getElementMapping();\n         ColumnIO io = elem.getColumnIO();\n         ForeignKey fk = elem.getForeignKey();\n-        if (!io.isAnyUpdatable(fk, true)) \n+        if (!elem.getUseClassCriteria() && io.isAnyUpdatable(fk, true)) { \n+            assertInversable();\n+            Row row = rm.getAllRows(fk.getTable(), Row.ACTION_UPDATE);\n+            row.setForeignKey(fk, io, null);\n+            row.whereForeignKey(fk, sm);\n+            rm.flushAllRows(row);\n             return;\n+        }\n \n-        // if the fk doesn't enforce it, null any existing inverse columns \n-        // that refer to this obj\n-        assertInversable();\n-        Row row = rm.getAllRows(fk.getTable(), Row.ACTION_UPDATE);\n-        row.setForeignKey(fk, io, null);\n-        row.whereForeignKey(fk, sm);\n-        rm.flushAllRows(row);\n+        if (!sm.getLoaded().get(field.getIndex()))\n+            return;\n+\n+        // update fk on each field value row\n+        ClassMapping rel = field.getElementMapping().getTypeMapping();\n+        StoreContext ctx = store.getContext();\n+        Collection objs = toCollection(sm.fetchObject(field.getIndex()));\n+        if (objs != null && !objs.isEmpty())\n+            for (Iterator itr = objs.iterator(); itr.hasNext();)\n+                updateInverse (ctx, itr.next(), rel, rm, sm, 0);\n     }\n \n     /**\n@@ -244,7 +253,7 @@ private void updateInverse(StoreContext ctx, Object inverse,\n         throws SQLException {\n         OpenJPAStateManager invsm = RelationStrategies.getStateManager(inverse,\n             ctx);\n-        if (invsm == null || invsm.isDeleted())\n+        if (invsm == null)\n             return;\n \n         ValueMapping elem = field.getElementMapping();\n@@ -257,12 +266,21 @@ private void updateInverse(StoreContext ctx, Object inverse,\n         boolean orderWriteable;\n         if (invsm.isNew() && !invsm.isFlushed()) {\n             // no need to null inverse columns of new instance\n-            if (sm == null)\n+            if (sm == null || sm.isDeleted())\n                 return;\n             writeable = io.isAnyInsertable(fk, false);\n             orderWriteable = _orderInsert;\n             action = Row.ACTION_INSERT;\n+        } else if (invsm.isDeleted()) {\n+            // no need to null inverse columns of deleted instance\n+            if (invsm.isFlushed() || sm == null || !sm.isDeleted())\n+                return;\n+            writeable = true;\n+            orderWriteable = false;\n+            action = Row.ACTION_DELETE;\n         } else {\n+            if (sm != null && sm.isDeleted())\n+                sm = null;\n             writeable = io.isAnyUpdatable(fk, sm == null);\n             orderWriteable = field.getOrderColumnIO().isUpdatable\n                 (order, sm == null);"},{"sha":"fb209e49d4d99ee38e965aeea5a13dd3ca7b250a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java","status":"modified","additions":19,"deletions":4,"changes":23,"blob_url":"https://github.com/apache/openjpa/blob/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java","raw_url":"https://github.com/apache/openjpa/raw/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java?ref=433475f6ad37062a00916c6a79f7ac08f35bdc4e","patch":"@@ -80,7 +80,8 @@ public boolean isAnyInsertable(Column[] cols, boolean nullValue) {\n      * Return true if any columns for the given key are insertable.\n      */\n     public boolean isAnyInsertable(ForeignKey fk, boolean nullValue) {\n-        return isAny(fk, _unInsertable, _unNullInsertable, nullValue);\n+        return isAny(fk, _unInsertable, _unNullInsertable, nullValue)\n+            && (!nullValue || fk.isLogical() || isNullable(fk));\n     }\n \n     /**\n@@ -101,7 +102,8 @@ public boolean isAllInsertable(Column[] cols, boolean nullValue) {\n      * Return true if all columns for the given key are insertable.\n      */\n     public boolean isAllInsertable(ForeignKey fk, boolean nullValue) {\n-        return isAll(fk, _unInsertable, _unNullInsertable, nullValue);\n+        return isAll(fk, _unInsertable, _unNullInsertable, nullValue)\n+            && (!nullValue || fk.isLogical() || isNullable(fk));\n     }\n \n     /**\n@@ -152,7 +154,8 @@ public boolean isAnyUpdatable(Column[] cols, boolean nullValue) {\n      * Return true if any columns for the given key are updatable.\n      */\n     public boolean isAnyUpdatable(ForeignKey fk, boolean nullValue) {\n-        return isAny(fk, _unUpdatable, _unNullUpdatable, nullValue);\n+        return isAny(fk, _unUpdatable, _unNullUpdatable, nullValue)\n+            && (!nullValue || fk.isLogical() || isNullable(fk));\n     }\n \n     /**\n@@ -173,7 +176,8 @@ public boolean isAllUpdatable(Column[] cols, boolean nullValue) {\n      * Return true if all columns for the given key are updatable.\n      */\n     public boolean isAllUpdatable(ForeignKey fk, boolean nullValue) {\n-        return isAll(fk, _unUpdatable, _unNullUpdatable, nullValue);\n+        return isAll(fk, _unUpdatable, _unNullUpdatable, nullValue)\n+            && (!nullValue || fk.isLogical() || isNullable(fk));\n     }\n \n     /**\n@@ -284,4 +288,15 @@ private int set(int col, boolean is, int property) {\n             return property & ~(2 << col);\n         return property | (2 << col);\n     }\n+\n+    /**\n+     * Whether the given foreign key is nullable.\n+     */\n+    private boolean isNullable(ForeignKey fk) {\n+        Column[] cols = fk.getColumns();\n+        for (int i = 0; i < cols.length; i++)\n+            if (cols[i].isNotNull() || cols[i].isPrimaryKey())\n+                return false;\n+        return true;\n+    }\n }"},{"sha":"02787f22e2709fcc80d3939874c78491c4fa5127","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","raw_url":"https://github.com/apache/openjpa/raw/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java?ref=433475f6ad37062a00916c6a79f7ac08f35bdc4e","patch":"@@ -203,7 +203,7 @@ private boolean isPrimaryKeyAutoAssigned(List seen) {\n         seen.add(this);\n         for (int i = 0; i < cols.length; i++) {\n             for (int j = 0; j < fks.length; j++) {\n-                if (fks[j].getPrimaryKeyColumn(cols[i]) == null)\n+                if (!fks[j].containsColumn(cols[i]))\n                     continue;\n                 if (!seen.contains(fks[j])\n                     && fks[j].isPrimaryKeyAutoAssigned(seen)) {"},{"sha":"c42ff82a524960f30729033dcd53b65049077d8b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","raw_url":"https://github.com/apache/openjpa/raw/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java?ref=433475f6ad37062a00916c6a79f7ac08f35bdc4e","patch":"@@ -390,10 +390,11 @@ private void validateProperties() {\n             setter = _pc.getDeclaredMethod(getSetterName(fmds[i]),\n                 new Class[]{ fmds[i].getDeclaredType() });\n             if (setter == null) {\n-                if (returned == null)\n+                if (returned == null) {\n                     addViolation(\"property-no-setter\",\n                         new Object[]{ fmds[i] }, true);\n-                else {\n+                    continue;\n+                } else {\n                     // create synthetic setter\n                     setter = _pc.declareMethod(getSetterName(fmds[i]),\n                         void.class, new Class[]{ fmds[i].getDeclaredType() });\n@@ -419,10 +420,9 @@ private void validateProperties() {\n                     _backingFields.put(setter.getName(), assigned.getName());\n \n                 if (assigned != returned)\n-                    addViolation(\"property-setter-getter-mismatch\",\n-                        new Object[]{ fmds[i], assigned.getName(),\n-                            (returned == null) ? null : returned.getName() },\n-                        false);\n+                    addViolation(\"property-setter-getter-mismatch\", new Object[]\n+                        { fmds[i], assigned.getName(), (returned == null) \n+                        ? null : returned.getName() }, false);\n             }\n         }\n     }"},{"sha":"4c2f45fa8f7122f3f2d6ad8f1ab57aa8e053d1f7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":19,"deletions":17,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=433475f6ad37062a00916c6a79f7ac08f35bdc4e","patch":"@@ -1928,8 +1928,7 @@ protected void flush(int reason) {\n                 exceps = add(exceps,\n                     newFlushException(_store.flush(transactional)));\n             }\n-        }\n-        finally {\n+        } finally {\n             _flags &= ~FLAG_STORE_FLUSHING;\n \n             if (reason == FLUSH_ROLLBACK)\n@@ -1942,21 +1941,24 @@ else if (reason != FLUSH_LOGICAL)\n                 StateManagerImpl sm;\n                 for (Iterator itr = transactional.iterator(); itr.hasNext();) {\n                     sm = (StateManagerImpl) itr.next();\n-\n-                    // the state may have become transient, such as if\n-                    // it is embedded and the owner has been deleted during\n-                    // this flush process; bug #1100\n-                    if (sm.getPCState() == PCState.TRANSIENT)\n-                        continue;\n-\n-                    sm.afterFlush(reason);\n-                    if (reason == FLUSH_INC) {\n-                        // if not about to clear trans cache for commit anyway,\n-                        // re-cache dirty objects with default soft refs; we\n-                        // don't need hard refs now that the changes have been\n-                        // flushed\n-                        sm.proxyFields(true, false);\n-                        _transCache.flushed(sm);\n+                    try {\n+                        // the state may have become transient, such as if\n+                        // it is embedded and the owner has been deleted during\n+                        // this flush process; bug #1100\n+                        if (sm.getPCState() == PCState.TRANSIENT)\n+                            continue;\n+\n+                        sm.afterFlush(reason);\n+                        if (reason == FLUSH_INC) {\n+                            // if not about to clear trans cache for commit \n+                            // anyway, re-cache dirty objects with default soft\n+                            // refs; we don't need hard refs now that the \n+                            // changes have been flushed\n+                            sm.proxyFields(true, false);\n+                            _transCache.flushed(sm);\n+                        }\n+                    } catch (Exception e) {\n+                        exceps = add(exceps, e);\n                     }\n                 }\n             }"},{"sha":"66a67680dae99e6c88d946e9e6772605a3926682","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","raw_url":"https://github.com/apache/openjpa/raw/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java?ref=433475f6ad37062a00916c6a79f7ac08f35bdc4e","patch":"@@ -194,7 +194,7 @@ private static Object getDetachedState(StateManagerImpl sm, BitSet fields) {\n      * needed. Return true if flushed/stored, false otherwise.\n      */\n     private static boolean flushDirty(StateManagerImpl sm) {\n-        if (!sm.isDirty())\n+        if (!sm.isDirty() || !sm.getBroker().isActive())\n             return false;\n \n         // only flush if there are actually any dirty non-flushed fields"},{"sha":"9c3a38feeece442aa6af65ce8dfeb50c99bbb234","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/433475f6ad37062a00916c6a79f7ac08f35bdc4e/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java?ref=433475f6ad37062a00916c6a79f7ac08f35bdc4e","patch":"@@ -332,7 +332,6 @@ protected void parseNewResource(Reader xml, String sourceName)\n         // even if we want to validate, specify that it won't happen\n         // if we have neither a DocType not a Schema\n         Object schemaSource = getSchemaSource();\n-\n         if (schemaSource != null && _schemaBug) {\n             if (_log != null && _log.isInfoEnabled())\n                 _log.info(_loc.get(\"parser-schema-bug\"));"}]}

