{"sha":"437897789151a863d3db32d8c4692100bcb12a60","node_id":"MDY6Q29tbWl0MjA2MzY0OjQzNzg5Nzc4OTE1MWE4NjNkM2RiMzJkOGM0NjkyMTAwYmNiMTJhNjA=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-09-21T21:59:21Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-09-21T21:59:21Z"},"message":"OPENJPA-250: Committing to trunk. Submitted by Patrick Linskey, Simon Droscher, and Rick Curtis.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@817429 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"726565c9385906684aa4d15721b5536982780671","url":"https://api.github.com/repos/apache/openjpa/git/trees/726565c9385906684aa4d15721b5536982780671"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/437897789151a863d3db32d8c4692100bcb12a60","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/437897789151a863d3db32d8c4692100bcb12a60","html_url":"https://github.com/apache/openjpa/commit/437897789151a863d3db32d8c4692100bcb12a60","comments_url":"https://api.github.com/repos/apache/openjpa/commits/437897789151a863d3db32d8c4692100bcb12a60/comments","author":null,"committer":null,"parents":[{"sha":"19da9769b0b11017a169f84125813ecae51a3458","url":"https://api.github.com/repos/apache/openjpa/commits/19da9769b0b11017a169f84125813ecae51a3458","html_url":"https://github.com/apache/openjpa/commit/19da9769b0b11017a169f84125813ecae51a3458"}],"stats":{"total":1484,"additions":853,"deletions":631},"files":[{"sha":"7a6808ca0e526b7f39ba6c71e2e6b5a0f5bf41aa","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","status":"modified","additions":62,"deletions":29,"changes":91,"blob_url":"https://github.com/apache/openjpa/blob/437897789151a863d3db32d8c4692100bcb12a60/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","raw_url":"https://github.com/apache/openjpa/raw/437897789151a863d3db32d8c4692100bcb12a60/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java?ref=437897789151a863d3db32d8c4692100bcb12a60","patch":"@@ -149,7 +149,7 @@ public void setMappingDefaults(MappingDefaults defaults) {\n     /**\n      * Representation of the database schema.\n      */\n-    public synchronized SchemaGroup getSchemaGroup() {\n+    public SchemaGroup getSchemaGroup() {\n         if (_schema == null)\n             _schema = ((JDBCConfiguration) getConfiguration()).\n                 getSchemaFactoryInstance().readSchema();\n@@ -159,14 +159,14 @@ public synchronized SchemaGroup getSchemaGroup() {\n     /**\n      * Representation of the database schema.\n      */\n-    public synchronized void setSchemaGroup(SchemaGroup schema) {\n+    public void setSchemaGroup(SchemaGroup schema) {\n         _schema = schema;\n     }\n \n     /**\n      * Installs mapping strategies on components.\n      */\n-    public synchronized StrategyInstaller getStrategyInstaller() {\n+    public StrategyInstaller getStrategyInstaller() {\n         if (_installer == null)\n             _installer = new RuntimeStrategyInstaller(this);\n         return _installer;\n@@ -175,20 +175,24 @@ public synchronized StrategyInstaller getStrategyInstaller() {\n     /**\n      * Installs mapping strategies on components.\n      */\n-    public synchronized void setStrategyInstaller(StrategyInstaller installer) {\n+    public void setStrategyInstaller(StrategyInstaller installer) {\n         _installer = installer;\n     }\n \n     /**\n      * Return the query result mapping for the given name.\n      */\n-    public synchronized QueryResultMapping getQueryResultMapping(Class cls,\n+    public QueryResultMapping getQueryResultMapping(Class cls,\n         String name, ClassLoader envLoader, boolean mustExist) {\n-        QueryResultMapping res = getQueryResultMappingInternal(cls, name,\n-            envLoader);\n-        if (res == null && mustExist)\n-            throw new MetaDataException(_loc.get(\"no-query-res\", cls, name));\n-        return res;\n+        lock();\n+        try {\n+            QueryResultMapping res = getQueryResultMappingInternal(cls, name, envLoader);\n+            if (res == null && mustExist)\n+                throw new MetaDataException(_loc.get(\"no-query-res\", cls, name));\n+            return res;\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n@@ -226,47 +230,71 @@ private QueryResultMapping getQueryResultMappingInternal(Class cls,\n      * Return all cached query result mappings.\n      */\n     public synchronized QueryResultMapping[] getQueryResultMappings() {\n-        Collection values = _results.values();\n-        return (QueryResultMapping[]) values.toArray\n-            (new QueryResultMapping[values.size()]);\n+        lock();\n+        try {\n+            Collection values = _results.values();\n+            return (QueryResultMapping[]) values.toArray(new QueryResultMapping[values.size()]);\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n      * Return the cached query result mapping with the given name, or null if\n      * none.\n      */\n-    public synchronized QueryResultMapping getCachedQueryResultMapping\n+    public QueryResultMapping getCachedQueryResultMapping\n         (Class cls, String name) {\n-        return (QueryResultMapping) _results.get(getQueryResultKey(cls, name));\n+        lock();\n+        try {\n+            return (QueryResultMapping) _results.get(getQueryResultKey(cls, name));\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n      * Add a query result mapping.\n      */\n-    public synchronized QueryResultMapping addQueryResultMapping(Class cls,\n+    public QueryResultMapping addQueryResultMapping(Class cls,\n         String name) {\n-        QueryResultMapping res = new QueryResultMapping(name, this);\n-        res.setDefiningType(cls);\n-        _results.put(getQueryResultKey(res), res);\n-        return res;\n+        lock();\n+        try {\n+            QueryResultMapping res = new QueryResultMapping(name, this);\n+            res.setDefiningType(cls);\n+            _results.put(getQueryResultKey(res), res);\n+            return res;\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n      * Remove a query result mapping.\n      */\n-    public synchronized boolean removeQueryResultMapping\n+    public boolean removeQueryResultMapping\n         (QueryResultMapping res) {\n-        return _results.remove(getQueryResultKey(res)) != null;\n+        lock();\n+        try {\n+            return _results.remove(getQueryResultKey(res)) != null;\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n      * Remove a query result mapping.\n      */\n-    public synchronized boolean removeQueryResultMapping(Class cls,\n+    public boolean removeQueryResultMapping(Class cls,\n         String name) {\n-        if (name == null)\n-            return false;\n-        return _results.remove(getQueryResultKey(cls, name)) != null;\n+        lock();\n+        try {\n+            if (name == null)\n+                return false;\n+            return _results.remove(getQueryResultKey(cls, name)) != null;\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n@@ -307,9 +335,14 @@ public ClassMapping getMapping(Object oid, ClassLoader envLoader,\n     }\n \n     public synchronized void clear() {\n-        super.clear();\n-        _schema = null;\n-        _results.clear();\n+        lock();\n+        try {\n+            super.clear();\n+            _schema = null;\n+            _results.clear();\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     protected void prepareMapping(ClassMetaData meta) {"},{"sha":"a5fee9f194031a3b6bccaba57edc13b5fb3a4519","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","status":"modified","additions":22,"deletions":1,"changes":23,"blob_url":"https://github.com/apache/openjpa/blob/437897789151a863d3db32d8c4692100bcb12a60/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","raw_url":"https://github.com/apache/openjpa/raw/437897789151a863d3db32d8c4692100bcb12a60/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java?ref=437897789151a863d3db32d8c4692100bcb12a60","patch":"@@ -35,7 +35,9 @@\n     extends PluginValue {\n \n     private static final String KEY = \"MetaDataRepository\";\n-\n+    private static final String PRELOAD_STR = \"Preload=true\";\n+    private static final String NOLOCK_STR = \"NoLock=true\";\n+      \n     public MetaDataRepositoryValue() {\n         super(KEY, false);\n         String[] aliases = new String[] {\n@@ -47,6 +49,25 @@ public MetaDataRepositoryValue() {\n         setString(aliases[0]);\n     }\n \n+    public boolean getPreload() {\n+        String p = getProperties();\n+        if (p != null && p.indexOf(PRELOAD_STR) >= 0) {\n+            return true;\n+        } else if (getNoLock() == true) {\n+            // No locking implies that we need to also preload.\n+            // Return true regardless of the value of the\n+            // preload flag.\n+            return true;\n+        }\n+        return false;\n+    }\n+    public boolean getNoLock(){\n+        String p = getProperties();\n+        if (p != null && p.indexOf(NOLOCK_STR) >= 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n     public Object instantiate(Class type, Configuration c, boolean fatal) {\n         MetaDataRepository repos = null;\n         OpenJPAConfiguration conf = (OpenJPAConfiguration) c;"},{"sha":"9afa79aa02a81d4f1c24ca18653ae844f8e1abe9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/437897789151a863d3db32d8c4692100bcb12a60/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/437897789151a863d3db32d8c4692100bcb12a60/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java?ref=437897789151a863d3db32d8c4692100bcb12a60","patch":"@@ -42,7 +42,6 @@\n import org.apache.openjpa.kernel.InverseManager;\n import org.apache.openjpa.kernel.LockLevels;\n import org.apache.openjpa.kernel.LockManager;\n-import org.apache.openjpa.kernel.MixedLockLevels;\n import org.apache.openjpa.kernel.PreparedQueryCache;\n import org.apache.openjpa.kernel.QueryFlushModes;\n import org.apache.openjpa.kernel.RestoreState;\n@@ -149,7 +148,7 @@\n     public BooleanValue multithreaded;\n     public StringValue mapping;\n     public PluginValue metaFactoryPlugin;\n-    public ObjectValue metaRepositoryPlugin;\n+    public MetaDataRepositoryValue metaRepositoryPlugin;\n     public ObjectValue lockManagerPlugin;\n     public ObjectValue inverseManagerPlugin;\n     public ObjectValue savepointManagerPlugin;\n@@ -335,8 +334,7 @@ public OpenJPAConfigurationImpl(boolean derivations, boolean loadGlobals) {\n         mapping = addString(\"Mapping\");\n         metaFactoryPlugin = addPlugin(\"MetaDataFactory\", false);\n \n-        metaRepositoryPlugin = (ObjectValue)\n-            addValue(new MetaDataRepositoryValue());\n+        metaRepositoryPlugin = (MetaDataRepositoryValue)addValue(new MetaDataRepositoryValue());\n \n         connectionFactory = addObject(\"ConnectionFactory\");\n         connectionFactory.setInstantiatingGetter(\"getConnectionFactory\");"},{"sha":"e4a381a913ef9a2a74e1404554d2a8dadaa68337","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"modified","additions":15,"deletions":0,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/437897789151a863d3db32d8c4692100bcb12a60/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/437897789151a863d3db32d8c4692100bcb12a60/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=437897789151a863d3db32d8c4692100bcb12a60","patch":"@@ -40,6 +40,7 @@\n import org.apache.commons.collections.set.MapBackedSet;\n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.conf.BrokerValue;\n+import org.apache.openjpa.conf.MetaDataRepositoryValue;\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\n import org.apache.openjpa.conf.OpenJPAVersion;\n@@ -163,6 +164,20 @@ protected AbstractBrokerFactory(OpenJPAConfiguration config) {\n                 _conf.getConnectionRetainModeConstant(), false).close(); \n         }\n \n+        // This logic needs to happen here for a reason! The preloading of the MDR\n+        // can not happen during the configuration of the MDR because when running\n+        // in a container environment we need to be able to get an uninitialized\n+        // MDR to pass to the PCClassFileTransformer. If we preload before registering\n+        // the class transformer, we miss the class being defined by the JVM and in turn\n+        // we fail to enhance our entities.\n+        OpenJPAConfigurationImpl impl = (OpenJPAConfigurationImpl) config;\n+        MetaDataRepositoryValue m = impl.metaRepositoryPlugin;\n+        if (m.getPreload() == true) {\n+            // Obtain a reference to the MetaDataRepository and trigger the preload\n+            MetaDataRepository mdr = config.getMetaDataRepositoryInstance();\n+            mdr.preload();\n+        }\n+        \n         initWriteBehindCallback();\n     }\n "},{"sha":"575ffd45afe0acb8f88909488c052d44a890d76e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","status":"modified","additions":752,"deletions":597,"changes":1349,"blob_url":"https://github.com/apache/openjpa/blob/437897789151a863d3db32d8c4692100bcb12a60/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","raw_url":"https://github.com/apache/openjpa/raw/437897789151a863d3db32d8c4692100bcb12a60/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java?ref=437897789151a863d3db32d8c4692100bcb12a60","patch":"@@ -20,6 +20,7 @@\n \n import java.io.Serializable;\n import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -32,38 +33,40 @@\n import java.util.Map;\n import java.util.Set;\n import java.util.TreeSet;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.enhance.DynamicPersistenceCapable;\n import org.apache.openjpa.enhance.PCRegistry;\n-import org.apache.openjpa.enhance.PCRegistry.RegisterClassListener;\n import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.enhance.PCRegistry.RegisterClassListener;\n import org.apache.openjpa.event.LifecycleEventManager;\n import org.apache.openjpa.lib.conf.Configurable;\n import org.apache.openjpa.lib.conf.Configuration;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.Closeable;\n import org.apache.openjpa.lib.util.J2DoPrivHelper;\n import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.MultiClassLoader;\n import org.apache.openjpa.lib.util.StringDistance;\n import org.apache.openjpa.util.ImplHelper;\n import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.MetaDataException;\n import org.apache.openjpa.util.OpenJPAId;\n+\n import serp.util.Strings;\n \n /**\n  * Repository of and factory for persistent metadata.\n- *\n+ * \n  * @since 0.3.0\n  * @author Abe White\n  * @author Steve Kim (query metadata)\n  */\n @SuppressWarnings(\"serial\")\n-public class MetaDataRepository\n-    implements PCRegistry.RegisterClassListener, Configurable, Closeable, \n-    MetaDataModes, Serializable {\n+public class MetaDataRepository implements PCRegistry.RegisterClassListener, Configurable, Closeable, MetaDataModes,\n+    Serializable {\n \n     /**\n      * Constant to not validate any metadata.\n@@ -86,55 +89,43 @@\n     public static final int VALIDATE_UNENHANCED = 4;\n \n     /**\n-     * Bit flag for runtime validation. Requires that all classes are\n-     * enhanced, and performs extra field resolution steps.\n+     * Bit flag for runtime validation. Requires that all classes are enhanced, and performs extra\n+     * field resolution steps.\n      */\n     public static final int VALIDATE_RUNTIME = 8;\n \n     protected static final Class<?>[] EMPTY_CLASSES = new Class[0];\n-    protected static final NonPersistentMetaData[] EMPTY_NON_PERSISTENT = \n-    \tnew NonPersistentMetaData[0];\n+    protected static final NonPersistentMetaData[] EMPTY_NON_PERSISTENT = new NonPersistentMetaData[0];\n     protected final ClassMetaData[] EMPTY_METAS;\n     protected final FieldMetaData[] EMPTY_FIELDS;\n     protected final Order[] EMPTY_ORDERS;\n \n-    private static final Localizer _loc = Localizer.forPackage\n-        (MetaDataRepository.class);\n+    private static final Localizer _loc = Localizer.forPackage(MetaDataRepository.class);\n \n     // system sequence\n     private SequenceMetaData _sysSeq = null;\n-\n     // cache of parsed metadata, oid class to class, and interface class\n     // to metadatas\n-    private final Map<Class<?>,ClassMetaData> _metas = \n-       new HashMap<Class<?>,ClassMetaData>();\n-    private final Map<Class<?>,Class<?>> _oids = \n-       Collections.synchronizedMap(new HashMap<Class<?>,Class<?>>());\n-    private final Map<Class<?>,Collection<Class<?>>> _impls = Collections\n-        .synchronizedMap(new HashMap<Class<?>,Collection<Class<?>>>());\n-    private final Map<Class<?>,Class<?>> _ifaces = \n-        Collections.synchronizedMap(new HashMap<Class<?>,Class<?>>());\n-    private final Map<Object,QueryMetaData> _queries = \n-        new HashMap<Object,QueryMetaData>();\n-    private final Map<String,SequenceMetaData> _seqs = \n-        new HashMap<String,SequenceMetaData>();\n-    private final Map<String,List<Class<?>>> _aliases = \n-        Collections.synchronizedMap(new HashMap<String,List<Class<?>>>());\n-    private final Map<Class<?>,NonPersistentMetaData> _pawares = Collections\n-        .synchronizedMap(new HashMap<Class<?>,NonPersistentMetaData>());\n-    private final Map<Class<?>,NonPersistentMetaData> _nonMapped = Collections\n-        .synchronizedMap(new HashMap<Class<?>,NonPersistentMetaData>());\n-    private final Map<Class<?>, Class<?>> _metamodel = Collections\n-        .synchronizedMap(new HashMap<Class<?>, Class<?>>());\n-    \n+    private Map<Class<?>, ClassMetaData> _metas = new HashMap<Class<?>, ClassMetaData>();\n+    private Map<Class<?>, Class<?>> _oids = Collections.synchronizedMap(new HashMap<Class<?>, Class<?>>());\n+    private Map<Class<?>, Collection<Class<?>>> _impls =\n+        Collections.synchronizedMap(new HashMap<Class<?>, Collection<Class<?>>>());\n+    private Map<Class<?>, Class<?>> _ifaces = Collections.synchronizedMap(new HashMap<Class<?>, Class<?>>());\n+    private Map<Object, QueryMetaData> _queries = new HashMap<Object, QueryMetaData>();\n+    private Map<String, SequenceMetaData> _seqs = new HashMap<String, SequenceMetaData>();\n+    private Map<String, List<Class<?>>> _aliases = Collections.synchronizedMap(new HashMap<String, List<Class<?>>>());\n+    private Map<Class<?>, NonPersistentMetaData> _pawares =\n+        Collections.synchronizedMap(new HashMap<Class<?>, NonPersistentMetaData>());\n+    private Map<Class<?>, NonPersistentMetaData> _nonMapped =\n+        Collections.synchronizedMap(new HashMap<Class<?>, NonPersistentMetaData>());\n+    private Map<Class<?>, Class<?>> _metamodel = Collections.synchronizedMap(new HashMap<Class<?>, Class<?>>());\n+\n     // map of classes to lists of their subclasses\n-    private final Map<Class<?>,List<Class<?>>> _subs = \n-        Collections.synchronizedMap(new HashMap<Class<?>,List<Class<?>>>());\n+    private Map<Class<?>, List<Class<?>>> _subs = Collections.synchronizedMap(new HashMap<Class<?>, List<Class<?>>>());\n \n     // xml mapping\n     protected final XMLMetaData[] EMPTY_XMLMETAS;\n-    private final Map<Class<?>,XMLMetaData> _xmlmetas = \n-        new HashMap<Class<?>,XMLMetaData>();\n+    private final Map<Class<?>, XMLMetaData> _xmlmetas = new HashMap<Class<?>, XMLMetaData>();\n \n     private transient OpenJPAConfiguration _conf = null;\n     private transient Log _log = null;\n@@ -150,25 +141,26 @@\n     private final Collection<Class<?>> _registered = new HashSet<Class<?>>();\n \n     // set of metadatas we're in the process of resolving\n-    private final InheritanceOrderedMetaDataList _resolving =\n-        new InheritanceOrderedMetaDataList();\n-    private final InheritanceOrderedMetaDataList _mapping =\n-        new InheritanceOrderedMetaDataList();\n-    private final List<RuntimeException> _errs = \n-    \tnew LinkedList<RuntimeException>();\n+    private final InheritanceOrderedMetaDataList _resolving = new InheritanceOrderedMetaDataList();\n+    private final InheritanceOrderedMetaDataList _mapping = new InheritanceOrderedMetaDataList();\n+    private final List<RuntimeException> _errs = new LinkedList<RuntimeException>();\n \n     // system listeners\n-    private LifecycleEventManager.ListenerList _listeners =\n-        new LifecycleEventManager.ListenerList(3);\n+    private LifecycleEventManager.ListenerList _listeners = new LifecycleEventManager.ListenerList(3);\n+\n+    private ReentrantLock _lock = null;\n+    protected boolean _preload = false;\n+    protected boolean _noLock = false;\n \n     /**\n-     * Default constructor.  Configure via {@link Configurable}.\n+     * Default constructor. Configure via {@link Configurable}.\n      */\n     public MetaDataRepository() {\n         EMPTY_METAS = newClassMetaDataArray(0);\n         EMPTY_FIELDS = newFieldMetaDataArray(0);\n         EMPTY_ORDERS = newOrderArray(0);\n         EMPTY_XMLMETAS = newXMLClassMetaDataArray(0);\n+        \n     }\n \n     /**\n@@ -201,16 +193,14 @@ public void setMetaDataFactory(MetaDataFactory factory) {\n     }\n \n     /**\n-     * The metadata validation level. Defaults to\n-     * <code>VALIDATE_META | VALIDATE_UNENHANCED</code>.\n+     * The metadata validation level. Defaults to <code>VALIDATE_META | VALIDATE_UNENHANCED</code>.\n      */\n     public int getValidate() {\n         return _validate;\n     }\n \n     /**\n-     * The metadata validation level. Defaults to\n-     * <code>VALIDATE_META | VALIDATE_UNENHANCED</code>.\n+     * The metadata validation level. Defaults to <code>VALIDATE_META | VALIDATE_UNENHANCED</code>.\n      */\n     public void setValidate(int validate) {\n         _validate = validate;\n@@ -230,24 +220,21 @@ else if (on)\n     }\n \n     /**\n-     * The metadata resolution mode. Defaults to\n-     * <code>MODE_META | MODE_MAPPING</code>.\n+     * The metadata resolution mode. Defaults to <code>MODE_META | MODE_MAPPING</code>.\n      */\n     public int getResolve() {\n         return _resMode;\n     }\n \n     /**\n-     * The metadata resolution mode. Defaults to\n-     * <code>MODE_META | MODE_MAPPING</code>.\n+     * The metadata resolution mode. Defaults to <code>MODE_META | MODE_MAPPING</code>.\n      */\n     public void setResolve(int mode) {\n         _resMode = mode;\n     }\n \n     /**\n-     * The metadata resolution mode. Defaults to\n-     * <code>MODE_META | MODE_MAPPING</code>.\n+     * The metadata resolution mode. Defaults to <code>MODE_META | MODE_MAPPING</code>.\n      */\n     public void setResolve(int mode, boolean on) {\n         if (mode == MODE_NONE)\n@@ -287,57 +274,140 @@ else if (on)\n             _sourceMode &= ~mode;\n     }\n \n+    public void setPreload(boolean l) {\n+        _preload = l;\n+    }\n+\n+    public void setNoLock(boolean l) {\n+        _noLock = l;\n+    }\n+\n+    /**\n+     * If the openjpa.MetaDataRepository plugin value preload=false is set, this method will noop.\n+     * If preload=true this method gets the list of persistent classes and calls to the\n+     * MetaDataFactory to load ALL metadata.\n+     * <p>\n+     * \n+     * If noLock=true, calling this method will also remove ALL locking from this class.\n+     * <p>\n+     * \n+     * NOTE : This method is not thread safe and should ONLY be called by the AbstractBrokerFactory\n+     * constructor.\n+     */\n+    public void preload() {\n+        if (_preload == false) {\n+            return;\n+        }\n+        if (_log.isTraceEnabled()) {\n+            _log.trace(\"MetaDataRepository preload=\" + _preload + \",noLock=\" + _noLock);\n+        }\n+\n+        // Remove locking and use unsynchronized maps.\n+        if (_noLock == true) {\n+            _oids = new HashMap<Class<?>, Class<?>>();\n+            _impls = new HashMap<Class<?>, Collection<Class<?>>>();\n+            _ifaces = new HashMap<Class<?>, Class<?>>();\n+            _aliases = new HashMap<String, List<Class<?>>>();\n+            _pawares = new HashMap<Class<?>, NonPersistentMetaData>();\n+            _nonMapped = new HashMap<Class<?>, NonPersistentMetaData>();\n+            _subs = new HashMap<Class<?>, List<Class<?>>>();\n+            _metamodel = new HashMap<Class<?>, Class<?>>();\n+\n+            _lock = null;\n+        }\n+\n+        MultiClassLoader multi = AccessController.doPrivileged(J2DoPrivHelper.newMultiClassLoaderAction());\n+        multi.addClassLoader(AccessController.doPrivileged(J2DoPrivHelper.getContextClassLoaderAction()));\n+        multi.addClassLoader(AccessController.doPrivileged(J2DoPrivHelper\n+            .getClassLoaderAction(MetaDataRepository.class)));\n+\n+        Set<String> classes = getPersistentTypeNames(false, multi);\n+        if (classes == null || classes.size() == 0) {\n+            throw new RuntimeException(\"No persistent classes listed when trying to preload the MetaDataRepository\");\n+        }\n+        if (_log.isTraceEnabled() == true) {\n+            _log.trace(MetaDataRepository.class.getName() \n+                + \" preloading the following classes : \" + classes.toString());\n+        }\n+\n+        for (String c : classes) {\n+            try {\n+                Class<?> cls = AccessController.doPrivileged((J2DoPrivHelper.getForNameAction(c, true, multi)));\n+                _factory.load(cls, MODE_ALL, multi);\n+            } catch (PrivilegedActionException pae) {\n+                // Unexpected!\n+                if (_log.isTraceEnabled() == true) {\n+                    _log.trace(MetaDataRepository.class.getName() + \" encountered an unexpected exception \", pae);\n+                }\n+            }\n+        }// end for\n+    }\n+\n+    protected void lock() {\n+        if (_lock != null) {\n+            _lock.lock();\n+        }\n+    }\n+\n+    protected void unlock() {\n+        if (_lock != null) {\n+            _lock.unlock();\n+        }\n+    }\n+\n     /**\n      * Return the metadata for the given class.\n-     *\n-     * @param cls the class to retrieve metadata for\n-     * @param envLoader the environmental class loader, if any\n-     * @param mustExist if true, throws a {@link MetaDataException}\n-     * if no metadata is found\n-     */\n-    public synchronized ClassMetaData getMetaData(Class<?> cls,\n-        ClassLoader envLoader, boolean mustExist) {\n-        if (cls != null &&\n-            DynamicPersistenceCapable.class.isAssignableFrom(cls))\n-            cls = cls.getSuperclass();\n-\n-        // if cls is a generated interface, use the user interface\n-        // to locate metadata\n-        if (cls != null && _implGen.isImplType(cls))\n-            cls = _implGen.toManagedInterface(cls);\n-\n-        ClassMetaData meta = getMetaDataInternal(cls, envLoader);\n-        if (meta == null && mustExist) {\n-            if (cls != null &&\n-                !ImplHelper.isManagedType(_conf, cls))\n-                throw new MetaDataException(_loc.get(\"no-meta-notpc\", cls)).\n-                    setFatal(false);\n+     * \n+     * @param cls\n+     *            the class to retrieve metadata for\n+     * @param envLoader\n+     *            the environmental class loader, if any\n+     * @param mustExist\n+     *            if true, throws a {@link MetaDataException} if no metadata is found\n+     */\n+    public ClassMetaData getMetaData(Class cls, ClassLoader envLoader, boolean mustExist) {\n+        lock();\n+        try {\n+            if (cls != null && DynamicPersistenceCapable.class.isAssignableFrom(cls))\n+                cls = cls.getSuperclass();\n \n-            Set<String> pcNames = getPersistentTypeNames(false, envLoader);\n-            if (pcNames != null && pcNames.size() > 0)\n-                throw new MetaDataException(_loc.get(\"no-meta-types\",\n-                    cls, pcNames));\n+            // if cls is a generated interface, use the user interface\n+            // to locate metadata\n+            if (cls != null && _implGen.isImplType(cls))\n+                cls = _implGen.toManagedInterface(cls);\n \n-            throw new MetaDataException(_loc.get(\"no-meta\", cls));\n+            ClassMetaData meta = getMetaDataInternal(cls, envLoader);\n+            if (meta == null && mustExist) {\n+                if (cls != null && !ImplHelper.isManagedType(_conf, cls))\n+                    throw new MetaDataException(_loc.get(\"no-meta-notpc\", cls)).setFatal(false);\n+\n+                Set<String> pcNames = getPersistentTypeNames(false, envLoader);\n+                if (pcNames != null && pcNames.size() > 0)\n+                    throw new MetaDataException(_loc.get(\"no-meta-types\", cls, pcNames));\n+\n+                throw new MetaDataException(_loc.get(\"no-meta\", cls));\n+            }\n+            resolve(meta);\n+            return meta;\n+        } finally {\n+            unlock();\n         }\n-        resolve(meta);\n-        return meta;\n     }\n \n     /**\n      * Return the metadata for the given alias name.\n-     *\n-     * @param alias the alias to class to retrieve metadata for\n-     * @param envLoader the environmental class loader, if any\n-     * @param mustExist if true, throws a {@link MetaDataException}\n-     * if no metadata is found\n+     * \n+     * @param alias\n+     *            the alias to class to retrieve metadata for\n+     * @param envLoader\n+     *            the environmental class loader, if any\n+     * @param mustExist\n+     *            if true, throws a {@link MetaDataException} if no metadata is found\n      * @see ClassMetaData#getTypeAlias\n      */\n-    public ClassMetaData getMetaData(String alias, ClassLoader envLoader,\n-        boolean mustExist) {\n+    public ClassMetaData getMetaData(String alias, ClassLoader envLoader, boolean mustExist) {\n         if (alias == null && mustExist)\n-            throw new MetaDataException(_loc.get(\"no-alias-meta\", alias,\n-                _aliases));\n+            throw new MetaDataException(_loc.get(\"no-alias-meta\", alias, _aliases));\n         if (alias == null)\n             return null;\n \n@@ -360,8 +430,7 @@ public ClassMetaData getMetaData(String alias, ClassLoader envLoader,\n \n                 // if we have specified a list of persistent clases,\n                 // also check to ensure that the class is in that list\n-                if (pcNames == null || pcNames.size() == 0 \n-                    || pcNames.contains(nc.getName())) {\n+                if (pcNames == null || pcNames.size() == 0 || pcNames.contains(nc.getName())) {\n                     cls = nc;\n                     if (!classList.contains(cls))\n                         classList.add(cls);\n@@ -384,8 +453,12 @@ public ClassMetaData getMetaData(String alias, ClassLoader envLoader,\n             return null;\n         }\n \n-        // record that this is an invalid type\n-        _aliases.put(alias, null);\n+        // We need to synchronize on _aliases because a ConcurrentModificationException can if there\n+        // is a thread in getAliasNames() AND this class isn't using any locking.\n+        synchronized (_aliases) {\n+            // record that this is an invalid type\n+            _aliases.put(alias, null);\n+        }\n \n         if (!mustExist)\n             return null;\n@@ -395,11 +468,9 @@ public ClassMetaData getMetaData(String alias, ClassLoader envLoader,\n     private ClassMetaData throwNoRegisteredAlias(String alias) {\n         String close = getClosestAliasName(alias);\n         if (close != null)\n-            throw new MetaDataException(\n-                _loc.get(\"no-alias-meta-hint\", alias, _aliases, close));\n+            throw new MetaDataException(_loc.get(\"no-alias-meta-hint\", alias, _aliases, close));\n         else\n-            throw new MetaDataException(\n-                _loc.get(\"no-alias-meta\", alias, _aliases));\n+            throw new MetaDataException(_loc.get(\"no-alias-meta\", alias, _aliases));\n     }\n \n     /**\n@@ -418,8 +489,7 @@ public String getClosestAliasName(String alias) {\n     public Collection<String> getAliasNames() {\n         Collection<String> aliases = new HashSet<String>();\n         synchronized (_aliases) {\n-            for (Iterator<Map.Entry<String, List<Class<?>>>> iter = \n-            \t_aliases.entrySet().iterator(); iter.hasNext(); ) {\n+            for (Iterator<Map.Entry<String, List<Class<?>>>> iter = _aliases.entrySet().iterator(); iter.hasNext();) {\n                 Map.Entry<String, List<Class<?>>> e = iter.next();\n                 if (e.getValue() != null)\n                     aliases.add(e.getKey());\n@@ -429,22 +499,19 @@ public String getClosestAliasName(String alias) {\n     }\n \n     /**\n-     * Internal method to get the metadata for the given class, without\n-     * resolving it.\n+     * Internal method to get the metadata for the given class, without resolving it.\n      */\n-    private ClassMetaData getMetaDataInternal(Class<?> cls,\n-        ClassLoader envLoader) {\n+    private ClassMetaData getMetaDataInternal(Class<?> cls, ClassLoader envLoader) {\n         if (cls == null)\n             return null;\n \n         // check cache for existing metadata, or give up if no metadata and\n         // our list of configured persistent types doesn't include the class\n         ClassMetaData meta = (ClassMetaData) _metas.get(cls);\n-        if (meta != null && ((meta.getSourceMode() & MODE_META) != 0\n-            || (_sourceMode & MODE_META) == 0))\n+        if (meta != null && ((meta.getSourceMode() & MODE_META) != 0 || (_sourceMode & MODE_META) == 0))\n             return meta;\n \n-        // if runtime, cut off search if not in pc list.  we don't do this at\n+        // if runtime, cut off search if not in pc list. we don't do this at\n         // dev time so that user can manipulate persistent classes he's writing\n         // before adding them to the list\n         if ((_validate & VALIDATE_RUNTIME) != 0) {\n@@ -459,18 +526,16 @@ private ClassMetaData getMetaDataInternal(Class<?> cls,\n                 return null;\n \n             // make sure this isn't an obviously bad class\n-            if (cls.isPrimitive() || cls.getName().startsWith(\"java.\")\n-                || cls == PersistenceCapable.class)\n+            if (cls.isPrimitive() || cls.getName().startsWith(\"java.\") || cls == PersistenceCapable.class)\n                 return null;\n \n             // designed to get around jikes 1.17 / JDK1.5 issue where static\n             // initializers are not invoked when a class is referenced, so the\n             // class never registers itself with the system\n             if ((_validate & VALIDATE_RUNTIME) != 0) {\n                 try {\n-                    Class.forName(cls.getName(), true,\n-                        AccessController.doPrivileged(\n-                            J2DoPrivHelper.getClassLoaderAction(cls)));\n+                    Class.forName(cls.getName(), true, AccessController.doPrivileged(J2DoPrivHelper\n+                        .getClassLoaderAction(cls)));\n                 } catch (Throwable t) {\n                 }\n             }\n@@ -492,8 +557,7 @@ else if ((_sourceMode & MODE_MAPPING) == 0)\n         // check cache again\n         if (meta == null)\n             meta = (ClassMetaData) _metas.get(cls);\n-        if (meta != null && ((meta.getSourceMode() & MODE_META) != 0\n-            || (_sourceMode & MODE_META) == 0))\n+        if (meta != null && ((meta.getSourceMode() & MODE_META) != 0 || (_sourceMode & MODE_META) == 0))\n             return meta;\n \n         // record that this class has no metadata; checking for this later\n@@ -522,10 +586,9 @@ private static String toModeString(int mode) {\n     }\n \n     /**\n-     * Prepare metadata for mapping resolution. This method might map parts\n-     * of the metadata that don't rely on other classes being mapped, but that\n-     * other classes might rely on during their own mapping (for example,\n-     * primary key fields). By default, this method only calls\n+     * Prepare metadata for mapping resolution. This method might map parts of the metadata that\n+     * don't rely on other classes being mapped, but that other classes might rely on during their\n+     * own mapping (for example, primary key fields). By default, this method only calls\n      * {@link ClassMetaData#defineSuperclassFields}.\n      */\n     protected void prepareMapping(ClassMetaData meta) {\n@@ -536,20 +599,18 @@ protected void prepareMapping(ClassMetaData meta) {\n      * Resolve the given metadata if needed. There are three goals:\n      * <ol>\n      * <li>Make sure no unresolved metadata gets back to the client.</li>\n-     * <li>Avoid infinite reentrant calls for mutually-dependent metadatas by\n-     * allowing unresolved metadata to be returned to other metadatas.</li>\n-     * <li>Always make sure the superclass metadata is resolved before the\n-     * subclass metadata so that the subclass can access the super's list\n-     * of fields.</li>\n-     * </ol> Note that the code calling this method is synchronized, so this\n-     * method doesn't have to be.\n+     * <li>Avoid infinite reentrant calls for mutually-dependent metadatas by allowing unresolved\n+     * metadata to be returned to other metadatas.</li>\n+     * <li>Always make sure the superclass metadata is resolved before the subclass metadata so that\n+     * the subclass can access the super's list of fields.</li>\n+     * </ol>\n+     * Note that the code calling this method is synchronized, so this method doesn't have to be.\n      */\n     private void resolve(ClassMetaData meta) {\n         // return anything that has its metadata resolved, because that means\n         // it is either fully resolved or must at least be in the process of\n         // resolving mapping, etc since we do that right after meta resolve\n-        if (meta == null || _resMode == MODE_NONE\n-            || (meta.getResolve() & MODE_META) != 0)\n+        if (meta == null || _resMode == MODE_NONE || (meta.getResolve() & MODE_META) != 0)\n             return;\n \n         // resolve metadata\n@@ -575,17 +636,17 @@ private void resolve(ClassMetaData meta) {\n             if (_errs.size() == 1)\n                 re = _errs.get(0);\n             else\n-                re = new MetaDataException(_loc.get(\"resolve-errs\")).\n-                    setNestedThrowables((Throwable[]) _errs.toArray\n-                        (new Exception[_errs.size()]));\n+                re =\n+                    new MetaDataException(_loc.get(\"resolve-errs\")).setNestedThrowables((Throwable[]) _errs\n+                        .toArray(new Exception[_errs.size()]));\n             _errs.clear();\n             throw re;\n         }\n     }\n \n     /**\n-     * Resolve metadata mode, returning list of processed metadadatas, or null\n-     * if we're still in the process of resolving other metadatas.\n+     * Resolve metadata mode, returning list of processed metadadatas, or null if we're still in the\n+     * process of resolving other metadatas.\n      */\n     private List<ClassMetaData> resolveMeta(ClassMetaData meta) {\n         if (meta.getPCSuperclass() == null) {\n@@ -604,8 +665,7 @@ private void resolve(ClassMetaData meta) {\n             if (meta.getDescribedType().isInterface()) {\n                 Class<?>[] sups = meta.getDescribedType().getInterfaces();\n                 for (int i = 0; i < sups.length; i++) {\n-                    supMeta = getMetaData(sups[i], meta.getEnvClassLoader(), \n-                        false);\n+                    supMeta = getMetaData(sups[i], meta.getEnvClassLoader(), false);\n                     if (supMeta != null) {\n                         meta.setPCSuperclass(sup);\n                         meta.setPCSuperclassMetaData(supMeta);\n@@ -614,23 +674,21 @@ private void resolve(ClassMetaData meta) {\n                 }\n             }\n             if (_log.isTraceEnabled())\n-                _log.trace(_loc.get(\"assigned-sup\", meta,\n-                    meta.getPCSuperclass()));\n+                _log.trace(_loc.get(\"assigned-sup\", meta, meta.getPCSuperclass()));\n         }\n \n         // resolve relation primary key fields for mapping dependencies\n         FieldMetaData[] fmds = meta.getDeclaredFields();\n         for (int i = 0; i < fmds.length; i++)\n             if (fmds[i].isPrimaryKey())\n-                getMetaData(fmds[i].getDeclaredType(), \n-                    meta.getEnvClassLoader(), false);\n+                getMetaData(fmds[i].getDeclaredType(), meta.getEnvClassLoader(), false);\n \n         // resolve metadata; if we're not in the process of resolving\n         // others, this will return the set of interrelated metas that\n         // resolved\n         return processBuffer(meta, _resolving, MODE_META);\n     }\n-    \n+\n     /**\n      * Load mapping information for the given metadata.\n      */\n@@ -639,20 +697,17 @@ private void loadMapping(ClassMetaData meta) {\n             return;\n \n         // load mapping information\n-        if ((meta.getSourceMode() & MODE_MAPPING) == 0\n-            && (_sourceMode & MODE_MAPPING) != 0) {\n+        if ((meta.getSourceMode() & MODE_MAPPING) == 0 && (_sourceMode & MODE_MAPPING) != 0) {\n             // embedded-only metadata doesn't have mapping, so always loaded\n             if (meta.isEmbeddedOnly())\n                 meta.setSourceMode(MODE_MAPPING, true);\n             else {\n                 // load mapping data\n                 int mode = _sourceMode & ~MODE_META;\n                 if (_log.isTraceEnabled())\n-                    _log.trace(_loc.get(\"load-mapping\", meta,\n-                        toModeString(mode)));\n+                    _log.trace(_loc.get(\"load-mapping\", meta, toModeString(mode)));\n                 try {\n-                    _factory.load(meta.getDescribedType(), mode,\n-                        meta.getEnvClassLoader());\n+                    _factory.load(meta.getDescribedType(), mode, meta.getEnvClassLoader());\n                 } catch (RuntimeException re) {\n                     removeMetaData(meta);\n                     _errs.add(re);\n@@ -685,12 +740,11 @@ private void preMapping(ClassMetaData meta) {\n \n     /**\n      * Resolve and initialize mapping.\n-     *\n+     * \n      * @return false if we're still in the process of resolving mappings\n      */\n     private boolean resolveMapping(ClassMetaData meta) {\n-        List<ClassMetaData> mapped = processBuffer(meta, _mapping, \n-        \tMODE_MAPPING);\n+        List<ClassMetaData> mapped = processBuffer(meta, _mapping, MODE_MAPPING);\n         if (mapped == null)\n             return false;\n \n@@ -712,8 +766,7 @@ private boolean resolveMapping(ClassMetaData meta) {\n     /**\n      * Process the given metadata and the associated buffer.\n      */\n-    private List<ClassMetaData> processBuffer(ClassMetaData meta,\n-        InheritanceOrderedMetaDataList buffer, int mode) {\n+    private List<ClassMetaData> processBuffer(ClassMetaData meta, InheritanceOrderedMetaDataList buffer, int mode) {\n         // if we're already processing a metadata, just buffer this one; when\n         // the initial metadata finishes processing, we traverse the buffer\n         // and process all the others that were introduced during reentrant\n@@ -737,16 +790,14 @@ private boolean resolveMapping(ClassMetaData meta) {\n                 _errs.add(re);\n \n                 // any exception during resolution of one type means we can't\n-                // resolve any of the related types, so clear buffer.  this also\n+                // resolve any of the related types, so clear buffer. this also\n                 // ensures that if two types relate to each other and one\n                 // dies, we don't get into infinite cycles\n-                for (Iterator<ClassMetaData> itr = buffer.iterator(); \n-                   itr.hasNext();) {\n+                for (Iterator<ClassMetaData> itr = buffer.iterator(); itr.hasNext();) {\n                     meta = itr.next();\n                     removeMetaData(meta);\n                     if (meta != buffered) {\n-                        _errs.add(new MetaDataException(_loc.get\n-                            (\"prev-errs\", meta, buffered)));\n+                        _errs.add(new MetaDataException(_loc.get(\"prev-errs\", meta, buffered)));\n                     }\n                 }\n                 buffer.clear();\n@@ -758,48 +809,50 @@ private boolean resolveMapping(ClassMetaData meta) {\n     /**\n      * Return all the metadata instances currently in the repository.\n      */\n-    public synchronized ClassMetaData[] getMetaDatas() {\n-        // prevent concurrent mod errors when resolving one metadata\n-        // introduces others\n-        ClassMetaData[] metas = (ClassMetaData[]) _metas.values().\n-            toArray(new ClassMetaData[_metas.size()]);\n-        for (int i = 0; i < metas.length; i++)\n-            if (metas[i] != null)\n-                getMetaData(metas[i].getDescribedType(),\n-                    metas[i].getEnvClassLoader(), true);\n-\n-        List<ClassMetaData> resolved = new ArrayList<ClassMetaData>\n-            (_metas.size());\n-        for (ClassMetaData meta : _metas.values()) {\n-            if (meta != null)\n-                resolved.add(meta);\n+    public ClassMetaData[] getMetaDatas() {\n+        lock();\n+        try {\n+            // prevent concurrent mod errors when resolving one metadata\n+            // introduces others\n+            ClassMetaData[] metas = (ClassMetaData[]) _metas.values().toArray(new ClassMetaData[_metas.size()]);\n+            for (int i = 0; i < metas.length; i++)\n+                if (metas[i] != null)\n+                    getMetaData(metas[i].getDescribedType(), metas[i].getEnvClassLoader(), true);\n+\n+            List<ClassMetaData> resolved = new ArrayList<ClassMetaData>(_metas.size());\n+            for (ClassMetaData meta : _metas.values()) {\n+                if (meta != null)\n+                    resolved.add(meta);\n+            }\n+            metas = resolved.toArray(newClassMetaDataArray(resolved.size()));\n+            Arrays.sort(metas);\n+            return metas;\n+        } finally {\n+            unlock();\n         }\n-        metas = resolved.toArray(newClassMetaDataArray(resolved.size()));\n-        Arrays.sort(metas);\n-        return metas;\n     }\n \n     /**\n-     * Return the cached metadata for the given class, without any resolution.\n-     * Return null if none.\n+     * Return the cached metadata for the given class, without any resolution. Return null if none.\n      */\n     public ClassMetaData getCachedMetaData(Class<?> cls) {\n         return (ClassMetaData) _metas.get(cls);\n     }\n-    \n+\n     /**\n-     * Create a new metadata, populate it with default information, add it to\n-     * the repository, and return it. Use the default access type.\n+     * Create a new metadata, populate it with default information, add it to the repository, and\n+     * return it. Use the default access type.\n      */\n     public ClassMetaData addMetaData(Class<?> cls) {\n         return addMetaData(cls, AccessCode.UNKNOWN);\n     }\n \n     /**\n-     * Create a new metadata, populate it with default information, add it to\n-     * the repository, and return it.\n-     *\n-     * @param access the access type to use in populating metadata\n+     * Create a new metadata, populate it with default information, add it to the repository, and\n+     * return it.\n+     * \n+     * @param access\n+     *            the access type to use in populating metadata\n      */\n     public ClassMetaData addMetaData(Class<?> cls, int access) {\n         if (cls == null || cls.isPrimitive())\n@@ -810,14 +863,17 @@ public ClassMetaData addMetaData(Class<?> cls, int access) {\n \n         // synchronize on this rather than the map, because all other methods\n         // that access _metas are synchronized on this\n-        synchronized (this) {\n+        lock();\n+        try {\n             if (_pawares.containsKey(cls))\n                 throw new MetaDataException(_loc.get(\"pc-and-aware\", cls));\n             _metas.put(cls, meta);\n+        } finally {\n+            unlock();\n         }\n         return meta;\n     }\n-    \n+\n     /**\n      * Create a new class metadata instance.\n      */\n@@ -835,8 +891,7 @@ protected ClassMetaData newClassMetaData(Class<?> type) {\n     /**\n      * Create a new field metadata instance.\n      */\n-    protected FieldMetaData newFieldMetaData(String name, Class<?> type,\n-        ClassMetaData owner) {\n+    protected FieldMetaData newFieldMetaData(String name, Class<?> type, ClassMetaData owner) {\n         return new FieldMetaData(name, type, owner);\n     }\n \n@@ -869,9 +924,8 @@ protected ValueMetaData newValueMetaData(FieldMetaData owner) {\n     }\n \n     /**\n-     * Create an {@link Order} for the given field and declaration. This\n-     * method delegates to {@link #newRelatedFieldOrder} and\n-     * {@link #newValueFieldOrder} by default.\n+     * Create an {@link Order} for the given field and declaration. This method delegates to\n+     * {@link #newRelatedFieldOrder} and {@link #newValueFieldOrder} by default.\n      */\n     protected Order newOrder(FieldMetaData owner, String name, boolean asc) {\n         // paths can start with (or equal) '#element'\n@@ -887,22 +941,19 @@ protected Order newOrder(FieldMetaData owner, String name, boolean asc) {\n         // related field\n         ClassMetaData meta = owner.getElement().getTypeMetaData();\n         if (meta == null)\n-            throw new MetaDataException(_loc.get(\"nonpc-field-orderable\",\n-                owner, name));\n+            throw new MetaDataException(_loc.get(\"nonpc-field-orderable\", owner, name));\n         FieldMetaData rel = getOrderByField(meta, name);\n         if (rel == null)\n-            throw new MetaDataException(_loc.get(\"bad-field-orderable\",\n-                owner, name));\n+            throw new MetaDataException(_loc.get(\"bad-field-orderable\", owner, name));\n         return newRelatedFieldOrder(owner, rel, asc);\n     }\n \n-    \n     public FieldMetaData getOrderByField(ClassMetaData meta, String orderBy) {\n         FieldMetaData field = meta.getField(orderBy);\n         if (field != null)\n             return field;\n-        int dotIdx = orderBy.indexOf(\".\"); \n-        if ( dotIdx == -1)\n+        int dotIdx = orderBy.indexOf(\".\");\n+        if (dotIdx == -1)\n             return null;\n         String fieldName = orderBy.substring(0, dotIdx);\n         FieldMetaData field1 = meta.getField(fieldName);\n@@ -913,8 +964,8 @@ public FieldMetaData getOrderByField(ClassMetaData meta, String orderBy) {\n             return null;\n         String mappedBy1 = orderBy.substring(dotIdx + 1);\n         return getOrderByField(meta1, mappedBy1);\n-    }  \n-    \n+    }\n+\n     /**\n      * Order by the field value.\n      */\n@@ -925,8 +976,7 @@ protected Order newValueOrder(FieldMetaData owner, boolean asc) {\n     /**\n      * Order by a field of the related type.\n      */\n-    protected Order newRelatedFieldOrder(FieldMetaData owner,\n-        FieldMetaData rel, boolean asc) {\n+    protected Order newRelatedFieldOrder(FieldMetaData owner, FieldMetaData rel, boolean asc) {\n         return new InMemoryRelatedFieldOrder(rel, asc, getConfiguration());\n     }\n \n@@ -939,7 +989,7 @@ protected Order newRelatedFieldOrder(FieldMetaData owner,\n \n     /**\n      * Remove a metadata instance from the repository.\n-     *\n+     * \n      * @return true if removed, false if not in this repository\n      */\n     public boolean removeMetaData(ClassMetaData meta) {\n@@ -950,19 +1000,24 @@ public boolean removeMetaData(ClassMetaData meta) {\n \n     /**\n      * Remove a metadata instance from the repository.\n-     *\n+     * \n      * @return true if removed, false if not in this repository\n      */\n-    public synchronized boolean removeMetaData(Class<?> cls) {\n-        if (cls == null)\n+    public boolean removeMetaData(Class cls) {\n+        lock();\n+        try {\n+            if (cls == null)\n+                return false;\n+            if (_metas.remove(cls) != null) {\n+                Class<?> impl = _ifaces.remove(cls);\n+                if (impl != null)\n+                    _metas.remove(impl);\n+                return true;\n+            }\n             return false;\n-        if (_metas.remove(cls) != null) {\n-            Class<?> impl = _ifaces.remove(cls);\n-            if (impl != null)\n-                _metas.remove(impl);\n-            return true;\n+        } finally {\n+            unlock();\n         }\n-        return false;\n     }\n \n     /**\n@@ -971,7 +1026,7 @@ public synchronized boolean removeMetaData(Class<?> cls) {\n     void addDeclaredInterfaceImpl(ClassMetaData meta, Class<?> iface) {\n         synchronized (_impls) {\n             Collection<Class<?>> vals = _impls.get(iface);\n-            \n+\n             // check to see if the superclass already declares to avoid dups\n             if (vals != null) {\n                 ClassMetaData sup = meta.getPCSuperclassMetaData();\n@@ -986,40 +1041,43 @@ void addDeclaredInterfaceImpl(ClassMetaData meta, Class<?> iface) {\n     /**\n      * Set the implementation for the given managed interface.\n      */\n-    synchronized void setInterfaceImpl(ClassMetaData meta, Class<?> impl) {\n-        if (!meta.isManagedInterface())\n-            throw new MetaDataException(_loc.get(\"not-managed-interface\", \n-                meta, impl));\n-        _ifaces.put(meta.getDescribedType(), impl);\n-        addDeclaredInterfaceImpl(meta, meta.getDescribedType());\n-        ClassMetaData sup = meta.getPCSuperclassMetaData();\n-        while (sup != null) {\n-            // record superclass interface info while we can as well as we\n-            // will only register concrete superclass in PCRegistry\n-            sup.clearSubclassCache();\n-            addToCollection(_subs, sup.getDescribedType(), impl, true);\n-            sup = (ClassMetaData) sup.getPCSuperclassMetaData();\n-        }\n-    }\n-    \n+    void setInterfaceImpl(ClassMetaData meta, Class<?> impl) {\n+        lock();\n+        try {\n+            if (!meta.isManagedInterface())\n+                throw new MetaDataException(_loc.get(\"not-managed-interface\", meta, impl));\n+            _ifaces.put(meta.getDescribedType(), impl);\n+            addDeclaredInterfaceImpl(meta, meta.getDescribedType());\n+            ClassMetaData sup = meta.getPCSuperclassMetaData();\n+            while (sup != null) {\n+                // record superclass interface info while we can as well as we\n+                // will only register concrete superclass in PCRegistry\n+                sup.clearSubclassCache();\n+                addToCollection(_subs, sup.getDescribedType(), impl, true);\n+                sup = (ClassMetaData) sup.getPCSuperclassMetaData();\n+            }\n+        } finally {\n+            unlock();\n+        }\n+    }\n+\n     InterfaceImplGenerator getImplGenerator() {\n         return _implGen;\n     }\n \n     /**\n-     * Return the least-derived class metadata for the given application\n-     * identity object.\n-     *\n-     * @param oid the oid to get the metadata for\n-     * @param envLoader the environmental class loader, if any\n-     * @param mustExist if true, throws a {@link MetaDataException}\n-     * if no metadata is found\n-     */\n-    public ClassMetaData getMetaData(Object oid, ClassLoader envLoader,\n-        boolean mustExist) {\n+     * Return the least-derived class metadata for the given application identity object.\n+     * \n+     * @param oid\n+     *            the oid to get the metadata for\n+     * @param envLoader\n+     *            the environmental class loader, if any\n+     * @param mustExist\n+     *            if true, throws a {@link MetaDataException} if no metadata is found\n+     */\n+    public ClassMetaData getMetaData(Object oid, ClassLoader envLoader, boolean mustExist) {\n         if (oid == null && mustExist)\n-            throw new MetaDataException(_loc.get(\"no-oid-meta\", oid, \"?\",\n-                _oids.toString()));\n+            throw new MetaDataException(_loc.get(\"no-oid-meta\", oid, \"?\", _oids.toString()));\n         if (oid == null)\n             return null;\n \n@@ -1037,8 +1095,7 @@ public ClassMetaData getMetaData(Object oid, ClassLoader envLoader,\n         // maybe this is some type we've seen but just isn't valid\n         if (_oids.containsKey(oid.getClass())) {\n             if (mustExist)\n-                throw new MetaDataException(_loc.get(\"no-oid-meta\", oid,\n-                    oid.getClass(), _oids));\n+                throw new MetaDataException(_loc.get(\"no-oid-meta\", oid, oid.getClass(), _oids));\n             return null;\n         }\n \n@@ -1056,13 +1113,11 @@ public ClassMetaData getMetaData(Object oid, ClassLoader envLoader,\n \n         if (!mustExist)\n             return null;\n-        throw new MetaDataException(_loc.get(\"no-oid-meta\", oid,\n-            oid.getClass(), _oids)).setFailedObject(oid);\n+        throw new MetaDataException(_loc.get(\"no-oid-meta\", oid, oid.getClass(), _oids)).setFailedObject(oid);\n     }\n \n     /**\n-     * Make some guesses about the name of a target class for an\n-     * unknown application identity class.\n+     * Make some guesses about the name of a target class for an unknown application identity class.\n      */\n     private void resolveIdentityClass(Object oid) {\n         if (oid == null)\n@@ -1072,19 +1127,18 @@ private void resolveIdentityClass(Object oid) {\n         if (_log.isTraceEnabled())\n             _log.trace(_loc.get(\"resolve-identity\", oidClass));\n \n-        ClassLoader cl = AccessController.doPrivileged(\n-            J2DoPrivHelper.getClassLoaderAction(oidClass)); \n+        ClassLoader cl = AccessController.doPrivileged(J2DoPrivHelper.getClassLoaderAction(oidClass));\n         String className;\n         while (oidClass != null && oidClass != Object.class) {\n             className = oidClass.getName();\n \n             // we take a brute-force approach: try to load all the class'\n             // substrings. this will handle the following common naming cases:\n             //\n-            //   com.company.MyClass$ID\t-> com.company.MyClass\n-            //   com.company.MyClassId\t-> com.company.MyClass\n-            //   com.company.MyClassOid\t-> com.company.MyClass\n-            //   com.company.MyClassPK\t-> com.company.MyClass\n+            // com.company.MyClass$ID -> com.company.MyClass\n+            // com.company.MyClassId -> com.company.MyClass\n+            // com.company.MyClassOid -> com.company.MyClass\n+            // com.company.MyClassPK -> com.company.MyClass\n             //\n             // this isn't the fastest thing possible, but this method will\n             // only be called once per JVM per unknown app id class\n@@ -1104,16 +1158,17 @@ private void resolveIdentityClass(Object oid) {\n     }\n \n     /**\n-     * Return all least-derived metadatas with some mapped assignable type that\n-     * implement the given class.\n-     *\n-     * @param cls the class or interface to retrieve implementors for\n-     * @param envLoader the environmental class loader, if any\n-     * @param mustExist if true, throws a {@link MetaDataException}\n-     * if no metadata is found\n-     */\n-    public ClassMetaData[] getImplementorMetaDatas(Class<?> cls,\n-        ClassLoader envLoader, boolean mustExist) {\n+     * Return all least-derived metadatas with some mapped assignable type that implement the given\n+     * class.\n+     * \n+     * @param cls\n+     *            the class or interface to retrieve implementors for\n+     * @param envLoader\n+     *            the environmental class loader, if any\n+     * @param mustExist\n+     *            if true, throws a {@link MetaDataException} if no metadata is found\n+     */\n+    public ClassMetaData[] getImplementorMetaDatas(Class<?> cls, ClassLoader envLoader, boolean mustExist) {\n         if (cls == null && mustExist)\n             throw new MetaDataException(_loc.get(\"no-meta\", cls));\n         if (cls == null)\n@@ -1125,68 +1180,74 @@ private void resolveIdentityClass(Object oid) {\n         ClassMetaData meta;\n         Collection<ClassMetaData> mapped = null;\n         if (vals != null) {\n-            synchronized (vals) {\n+            lock();\n+            try {\n                 for (Iterator<Class<?>> itr = vals.iterator(); itr.hasNext();) {\n                     meta = getMetaData(itr.next(), envLoader, true);\n-                    if (meta.isMapped()\n-                        || meta.getMappedPCSubclassMetaDatas().length > 0) {\n+                    if (meta.isMapped() || meta.getMappedPCSubclassMetaDatas().length > 0) {\n                         if (mapped == null)\n                             mapped = new ArrayList<ClassMetaData>(vals.size());\n                         mapped.add(meta);\n                     }\n                 }\n+            } finally {\n+                unlock();\n             }\n         }\n \n         if (mapped == null && mustExist)\n             throw new MetaDataException(_loc.get(\"no-meta\", cls));\n         if (mapped == null)\n             return EMPTY_METAS;\n-        return mapped.toArray(newClassMetaDataArray\n-            (mapped.size()));\n+        return mapped.toArray(newClassMetaDataArray(mapped.size()));\n     }\n-     \n+\n     /**\n-     * Gets the metadata corresponding to the given persistence-aware class. \n-     * Returns null, if the given class is not registered as \n-     * persistence-aware.\n+     * Gets the metadata corresponding to the given persistence-aware class. Returns null, if the\n+     * given class is not registered as persistence-aware.\n      */\n     public NonPersistentMetaData getPersistenceAware(Class<?> cls) {\n-    \treturn (NonPersistentMetaData)_pawares.get(cls);\n+        return (NonPersistentMetaData) _pawares.get(cls);\n     }\n-    \n+\n     /**\n      * Gets all the metadatas for persistence-aware classes\n      * \n      * @return empty array if no class has been registered as pers-aware\n      */\n     public NonPersistentMetaData[] getPersistenceAwares() {\n-        synchronized (_pawares) {\n+        lock();\n+        try {\n             if (_pawares.isEmpty())\n                 return EMPTY_NON_PERSISTENT;\n-            return (NonPersistentMetaData[])_pawares.values().toArray\n-                (new NonPersistentMetaData[_pawares.size()]);\n+            return (NonPersistentMetaData[]) _pawares.values().toArray(new NonPersistentMetaData[_pawares.size()]);\n+        } finally {\n+            unlock();\n         }\n     }\n \n     /**\n      * Add the given class as persistence-aware.\n      * \n-     * @param cls non-null and must not alreaddy be added as persitence-capable\n+     * @param cls\n+     *            non-null and must not alreaddy be added as persitence-capable\n      */\n     public NonPersistentMetaData addPersistenceAware(Class<?> cls) {\n-    \tif (cls == null)\n-    \t\treturn null;\n-        synchronized(this) {\n+        if (cls == null)\n+            return null;\n+        lock();\n+        try {\n             if (_pawares.containsKey(cls))\n-                return (NonPersistentMetaData)_pawares.get(cls);\n+                return (NonPersistentMetaData) _pawares.get(cls);\n             if (getCachedMetaData(cls) != null)\n                 throw new MetaDataException(_loc.get(\"pc-and-aware\", cls));\n-            NonPersistentMetaData meta = new NonPersistentMetaData(cls, this,\n-                NonPersistentMetaData.TYPE_PERSISTENCE_AWARE);\n+            NonPersistentMetaData meta =\n+                new NonPersistentMetaData(cls, this, NonPersistentMetaData.TYPE_PERSISTENCE_AWARE);\n             _pawares.put(cls, meta);\n             return meta;\n-    \t}\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n@@ -1195,53 +1256,57 @@ public NonPersistentMetaData addPersistenceAware(Class<?> cls) {\n      * @return true if removed\n      */\n     public boolean removePersistenceAware(Class<?> cls) {\n-    \treturn _pawares.remove(cls) != null;\n+        return _pawares.remove(cls) != null;\n     }\n \n     /**\n-     * Gets the metadata corresponding to the given non-mapped interface.\n-     * Returns null, if the given interface is not registered as \n-     * persistence-aware.\n+     * Gets the metadata corresponding to the given non-mapped interface. Returns null, if the given\n+     * interface is not registered as persistence-aware.\n      */\n     public NonPersistentMetaData getNonMappedInterface(Class<?> iface) {\n-    \treturn (NonPersistentMetaData)_nonMapped.get(iface);\n+        return (NonPersistentMetaData) _nonMapped.get(iface);\n     }\n-    \n+\n     /**\n-     * Gets the corresponding metadatas for all registered, non-mapped\n-     * interfaces\n+     * Gets the corresponding metadatas for all registered, non-mapped interfaces\n      * \n      * @return empty array if no non-mapped interface has been registered.\n      */\n     public NonPersistentMetaData[] getNonMappedInterfaces() {\n-        synchronized (_nonMapped) {\n+        lock();\n+        try {\n             if (_nonMapped.isEmpty())\n                 return EMPTY_NON_PERSISTENT;\n-            return (NonPersistentMetaData[])_nonMapped.values().toArray\n-                (new NonPersistentMetaData[_nonMapped.size()]);\n+            return (NonPersistentMetaData[]) _nonMapped.values().toArray(new NonPersistentMetaData[_nonMapped.size()]);\n+        } finally {\n+            unlock();\n         }\n     }\n \n     /**\n      * Add the given non-mapped interface to the repository.\n      * \n-     * @param iface the non-mapped interface\n+     * @param iface\n+     *            the non-mapped interface\n      */\n     public NonPersistentMetaData addNonMappedInterface(Class<?> iface) {\n-    \tif (iface == null)\n-    \t\treturn null;\n+        if (iface == null)\n+            return null;\n         if (!iface.isInterface())\n             throw new MetaDataException(_loc.get(\"not-non-mapped\", iface));\n-        synchronized(this) {\n+        lock();\n+        try {\n             if (_nonMapped.containsKey(iface))\n-                return (NonPersistentMetaData)_nonMapped.get(iface);\n+                return (NonPersistentMetaData) _nonMapped.get(iface);\n             if (getCachedMetaData(iface) != null)\n                 throw new MetaDataException(_loc.get(\"non-mapped-pc\", iface));\n-            NonPersistentMetaData meta = new NonPersistentMetaData(iface, this,\n-                NonPersistentMetaData.TYPE_NON_MAPPED_INTERFACE);\n+            NonPersistentMetaData meta =\n+                new NonPersistentMetaData(iface, this, NonPersistentMetaData.TYPE_NON_MAPPED_INTERFACE);\n             _nonMapped.put(iface, meta);\n             return meta;\n-    \t}\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n@@ -1250,96 +1315,108 @@ public NonPersistentMetaData addNonMappedInterface(Class<?> iface) {\n      * @return true if removed\n      */\n     public boolean removeNonMappedInterface(Class<?> iface) {\n-    \treturn _nonMapped.remove(iface) != null;\n+        return _nonMapped.remove(iface) != null;\n     }\n \n     /**\n-     * Clear the cache of parsed metadata. This method also clears the\n-     * internal {@link MetaDataFactory MetaDataFactory}'s cache.\n+     * Clear the cache of parsed metadata. This method also clears the internal\n+     * {@link MetaDataFactory MetaDataFactory}'s cache.\n      */\n-    public synchronized void clear() {\n-        if (_log.isTraceEnabled())\n-            _log.trace(_loc.get(\"clear-repos\", this));\n-\n-        _metas.clear();\n-        _oids.clear();\n-        _subs.clear();\n-        _impls.clear();\n-        _queries.clear();\n-        _seqs.clear();\n-        _registered.clear();\n-        _factory.clear();\n-        _aliases.clear();\n-        _pawares.clear();\n-        _nonMapped.clear();\n-    }\n-\n-    /**\n-     * Return the set of configured persistent classes, or null if the user\n-     * did not configure any.\n-     *\n-     * @param devpath if true, search for metadata files in directories\n-     * in the classpath if no classes are configured explicitly\n-     * @param envLoader the class loader to use, or null for default\n-     */\n-    public synchronized Set<String> getPersistentTypeNames(boolean devpath,\n-        ClassLoader envLoader) {\n-        return _factory.getPersistentTypeNames(devpath, envLoader);\n-    }\n-    \n-    public synchronized Collection<Class<?>> loadPersistentTypes(\n-    \t\tboolean devpath, ClassLoader envLoader) {\n-    \treturn loadPersistentTypes(devpath, envLoader, false);\n-    }\n-\n-    /**\n-     * Load the persistent classes named in configuration.\n-     * This ensures that all subclasses and application identity classes of\n-     * each type are known in advance, without having to rely on the\n-     * application loading the classes before performing operations that\n-     * might involve them.\n-     *\n-     * @param devpath if true, search for metadata files in directories\n-     * in the classpath if the no classes are configured explicitly\n-     * @param envLoader the class loader to use, or null for default\n-     * @param mustExist if true then empty list of classes or any unloadable\n-     * but specified class will raise an exception. \n+    public void clear() {\n+        lock();\n+        try {\n+            if (_log.isTraceEnabled())\n+                _log.trace(_loc.get(\"clear-repos\", this));\n+\n+            _metas.clear();\n+            _oids.clear();\n+            _subs.clear();\n+            _impls.clear();\n+            _queries.clear();\n+            _seqs.clear();\n+            _registered.clear();\n+            _factory.clear();\n+            _aliases.clear();\n+            _pawares.clear();\n+            _nonMapped.clear();\n+        } finally {\n+            unlock();\n+        }\n+    }\n+\n+    /**\n+     * Return the set of configured persistent classes, or null if the user did not configure any.\n+     * \n+     * @param devpath\n+     *            if true, search for metadata files in directories in the classpath if no classes\n+     *            are configured explicitly\n+     * @param envLoader\n+     *            the class loader to use, or null for default\n+     */\n+    public Set<String> getPersistentTypeNames(boolean devpath, ClassLoader envLoader) {\n+        lock();\n+        try {\n+            return _factory.getPersistentTypeNames(devpath, envLoader);\n+        } finally {\n+            unlock();\n+        }\n+    }\n+\n+    public synchronized Collection<Class<?>> loadPersistentTypes(boolean devpath, ClassLoader envLoader) {\n+        return loadPersistentTypes(devpath, envLoader, false);\n+    }\n+\n+    /**\n+     * Load the persistent classes named in configuration. This ensures that all subclasses and\n+     * application identity classes of each type are known in advance, without having to rely on the\n+     * application loading the classes before performing operations that might involve them.\n+     * \n+     * @param devpath\n+     *            if true, search for metadata files in directories in the classpath if the no\n+     *            classes are configured explicitly\n+     * @param envLoader\n+     *            the class loader to use, or null for default\n+     * @param mustExist\n+     *            if true then empty list of classes or any unloadable but specified class will\n+     *            raise an exception.\n      * @return the loaded classes, or empty collection if none\n      */\n-    public synchronized Collection<Class<?>> loadPersistentTypes(\n-    \tboolean devpath, ClassLoader envLoader, boolean mustExist) {\n-        Set<String> names = getPersistentTypeNames(devpath, envLoader);\n-        if (names == null || names.isEmpty()) {\n-        \tif (!mustExist)\n-        \t\treturn Collections.EMPTY_LIST;\n-        \telse\n-                throw new MetaDataException(_loc.get(\"eager-no-class-found\"));\n-        }\n-\n-        // attempt to load classes so that they get processed\n-        ClassLoader clsLoader = _conf.getClassResolverInstance().\n-            getClassLoader(getClass(), envLoader);\n-        List<Class<?>> classes = new ArrayList<Class<?>> (names.size());\n-        Class<?> cls;\n-        for (String  className : names) {\n-            cls = classForName(className, clsLoader);\n-            if (_factory.isMetaClass(cls)) {\n-                setMetaModel(cls);\n-                continue;\n+    public Collection<Class<?>> loadPersistentTypes(boolean devpath, ClassLoader envLoader, boolean mustExist) {\n+        lock();\n+        try {\n+            Set<String> names = getPersistentTypeNames(devpath, envLoader);\n+            if (names == null || names.isEmpty()) {\n+                if (!mustExist)\n+                    return Collections.EMPTY_LIST;\n+                else\n+                    throw new MetaDataException(_loc.get(\"eager-no-class-found\"));\n             }\n-            if (cls != null) {\n-                classes.add(cls);\n-\n-                // if the class is an interface, load its metadata to kick\n-                // off the impl generator\n-                if (cls.isInterface())\n-                    getMetaData(cls, clsLoader, false);\n-            } else if (cls == null && mustExist) {\n-                throw new MetaDataException(_loc.get(\"eager-class-not-found\", \n-        \t\t\t\tclassName));\n+\n+            // attempt to load classes so that they get processed\n+            ClassLoader clsLoader = _conf.getClassResolverInstance().getClassLoader(getClass(), envLoader);\n+            List<Class<?>> classes = new ArrayList<Class<?>>(names.size());\n+            Class<?> cls;\n+            for (String className : names) {\n+                cls = classForName(className, clsLoader);\n+                if (_factory.isMetaClass(cls)) {\n+                    setMetaModel(cls);\n+                    continue;\n+                }\n+                if (cls != null) {\n+                    classes.add(cls);\n+\n+                    // if the class is an interface, load its metadata to kick\n+                    // off the impl generator\n+                    if (cls.isInterface())\n+                        getMetaData(cls, clsLoader, false);\n+                } else if (cls == null && mustExist) {\n+                    throw new MetaDataException(_loc.get(\"eager-class-not-found\", className));\n+                }\n             }\n+            return classes;\n+        } finally {\n+            unlock();\n         }\n-        return classes;\n     }\n \n     /**\n@@ -1375,9 +1452,8 @@ public synchronized void clear() {\n     }\n \n     /**\n-     * Return all known subclasses for the given class mapping. Note\n-     * that this method only works during runtime when the repository is\n-     * registered as a {@link RegisterClassListener}.\n+     * Return all known subclasses for the given class mapping. Note that this method only works\n+     * during runtime when the repository is registered as a {@link RegisterClassListener}.\n      */\n     Collection<Class<?>> getPCSubclasses(Class<?> cls) {\n         Collection<Class<?>> subs = _subs.get(cls);\n@@ -1386,15 +1462,18 @@ public synchronized void clear() {\n         return subs;\n     }\n \n-    ////////////////////////////////////////\n+    // //////////////////////////////////////\n     // RegisterClassListener implementation\n-    ////////////////////////////////////////\n+    // //////////////////////////////////////\n \n     public void register(Class cls) {\n         // buffer registered classes until an oid metadata request is made,\n         // at which point we'll parse everything in the buffer\n-        synchronized (_registered) {\n+        lock();\n+        try {\n             _registered.add(cls);\n+        } finally {\n+            unlock();\n         }\n     }\n \n@@ -1423,26 +1502,27 @@ private void loadRegisteredClassMetaData(ClassLoader envLoader) {\n         // copy into new collection to avoid concurrent mod errors on reentrant\n         // registrations\n         Class<?>[] reg;\n-        synchronized (_registered) {\n+        lock();\n+        try {\n             reg = _registered.toArray(new Class[_registered.size()]);\n             _registered.clear();\n+        } finally {\n+            unlock();\n         }\n \n         Collection<String> pcNames = getPersistentTypeNames(false, envLoader);\n         Collection<Class<?>> failed = null;\n         for (int i = 0; i < reg.length; i++) {\n             // don't process types that aren't listed by the user; may belong\n             // to a different persistence unit\n-            if (pcNames != null && !pcNames.isEmpty()\n-                && !pcNames.contains(reg[i].getName()))\n+            if (pcNames != null && !pcNames.isEmpty() && !pcNames.contains(reg[i].getName()))\n                 continue;\n \n             try {\n                 processRegisteredClass(reg[i]);\n             } catch (Throwable t) {\n                 if (!_conf.getRetryClassRegistration())\n-                    throw new MetaDataException(_loc.get(\"error-registered\",\n-                        reg[i]), t);\n+                    throw new MetaDataException(_loc.get(\"error-registered\", reg[i]), t);\n \n                 if (_log.isWarnEnabled())\n                     _log.warn(_loc.get(\"failed-registered\", reg[i]), t);\n@@ -1452,18 +1532,20 @@ private void loadRegisteredClassMetaData(ClassLoader envLoader) {\n             }\n         }\n         if (failed != null) {\n-            synchronized (_registered) {\n+            lock();\n+            try {\n                 _registered.addAll(failed);\n+            } finally {\n+                unlock();\n             }\n         }\n         return reg;\n     }\n \n     /**\n-     * Updates our datastructures with the given registered class.\n-     * Relies on the fact that a child class cannot register itself without\n-     * also registering its parent class by specifying its persistence\n-     * capable superclass in the registration event.\n+     * Updates our datastructures with the given registered class. Relies on the fact that a child\n+     * class cannot register itself without also registering its parent class by specifying its\n+     * persistence capable superclass in the registration event.\n      */\n     private void processRegisteredClass(Class<?> cls) {\n         if (_log.isTraceEnabled())\n@@ -1472,16 +1554,18 @@ private void processRegisteredClass(Class<?> cls) {\n         // update subclass lists; synchronize on this because accessing _metas\n         // requires it\n         Class<?> leastDerived = cls;\n-        synchronized (this) {\n+        lock();\n+        try {\n             ClassMetaData meta;\n-            for (Class<?> anc = cls;\n-                (anc = PCRegistry.getPersistentSuperclass(anc)) != null;) {\n+            for (Class<?> anc = cls; (anc = PCRegistry.getPersistentSuperclass(anc)) != null;) {\n                 addToCollection(_subs, anc, cls, true);\n                 meta = (ClassMetaData) _metas.get(anc);\n                 if (meta != null)\n                     meta.clearSubclassCache();\n                 leastDerived = anc;\n             }\n+        } finally {\n+            unlock();\n         }\n \n         // update oid mappings if this is a base concrete class\n@@ -1518,31 +1602,33 @@ private void processRegisteredClass(Class<?> cls) {\n         // set alias for class\n         String alias = PCRegistry.getTypeAlias(cls);\n         if (alias != null) {\n-            synchronized (_aliases) {\n+            lock();\n+            try {\n                 List<Class<?>> classList = _aliases.get(alias);\n                 if (classList == null) {\n                     classList = new ArrayList<Class<?>>(3);\n                     _aliases.put(alias, classList);\n                 }\n                 if (!classList.contains(cls))\n                     classList.add(cls);\n+            } finally {\n+                unlock();\n             }\n         }\n     }\n \n     /**\n      * Update the list of implementations of base classes and interfaces.\n      */\n-    private void updateImpls(Class<?> cls, Class<?> leastDerived, \n-    \tClass<?> check) {\n+    private void updateImpls(Class<?> cls, Class<?> leastDerived, Class<?> check) {\n         // allow users to query on common non-pc superclasses\n         Class<?> sup = check.getSuperclass();\n         if (leastDerived == cls && sup != null && sup != Object.class) {\n             addToCollection(_impls, sup, cls, false);\n             updateImpls(cls, leastDerived, sup);\n         }\n \n-        // allow users to query on any implemented interfaces unless defaults \n+        // allow users to query on any implemented interfaces unless defaults\n         // say the user must implement persistent interfaces explicitly in meta\n         if (!_factory.getDefaults().isDeclaredInterfacePersistent())\n             return;\n@@ -1561,8 +1647,8 @@ private void updateImpls(Class<?> cls, Class<?> leastDerived,\n     }\n \n     /**\n-     * Return true if the given class is the least-derived persistent\n-     * implementor of the given interface, false otherwise.\n+     * Return true if the given class is the least-derived persistent implementor of the given\n+     * interface, false otherwise.\n      */\n     private boolean isLeastDerivedImpl(Class<?> inter, Class<?> cls) {\n         Class<?> parent = PCRegistry.getPersistentSuperclass(cls);\n@@ -1575,12 +1661,11 @@ private boolean isLeastDerivedImpl(Class<?> inter, Class<?> cls) {\n     }\n \n     /**\n-     * Add the given value to the collection cached in the given map under\n-     * the given key.\n+     * Add the given value to the collection cached in the given map under the given key.\n      */\n-    private void addToCollection(Map map, \n-    \tClass<?> key, Class<?> value, boolean inheritance) {\n-        synchronized (map) {\n+    private void addToCollection(Map map, Class<?> key, Class<?> value, boolean inheritance) {\n+        lock();\n+        try {\n             Collection coll = (Collection) map.get(key);\n             if (coll == null) {\n                 if (inheritance) {\n@@ -1592,9 +1677,11 @@ private void addToCollection(Map map,\n                 map.put(key, coll);\n             }\n             coll.add(value);\n+        } finally {\n+            unlock();\n         }\n     }\n-    \n+\n     /**\n      * Puts the meta class corresponding to the given entity class.\n      */\n@@ -1603,36 +1690,33 @@ public void setMetaModel(Class<?> m2) {\n         if (cls != null)\n             _metamodel.put(cls, m2);\n     }\n-    \n+\n     /**\n      * Puts the meta class corresponding to the given persistent class.\n      */\n     public void setMetaModel(ClassMetaData meta, Class<?> m2) {\n         _metamodel.put(meta.getDescribedType(), m2);\n     }\n-    \n+\n     /**\n      * Gets the meta class corresponding to the given persistent class.\n      */\n     public Class<?> getMetaModel(ClassMetaData meta, boolean load) {\n         return getMetaModel(meta.getDescribedType(), load);\n     }\n-    \n+\n     /**\n-     * Gets the meta class corresponding to the given class.\n-     * If load is false, returns the meta class if has been set for the given \n-     * persistent class earlier. \n-     * If the load is true then also attempts to apply the current\n-     * naming policy to derive meta class name and attempts to load the meta\n-     * class.  \n+     * Gets the meta class corresponding to the given class. If load is false, returns the meta\n+     * class if has been set for the given persistent class earlier. If the load is true then also\n+     * attempts to apply the current naming policy to derive meta class name and attempts to load\n+     * the meta class.\n      */\n     public Class<?> getMetaModel(Class<?> entity, boolean load) {\n         if (_metamodel.containsKey(entity))\n             return _metamodel.get(entity);\n         String m2 = _factory.getMetaModelClassName(entity.getName());\n         try {\n-            Class<?> m2cls = J2DoPrivHelper.getForNameAction(m2, true, \n-                entity.getClassLoader()).run();\n+            Class<?> m2cls = J2DoPrivHelper.getForNameAction(m2, true, entity.getClassLoader()).run();\n             _metamodel.put(entity, m2cls);\n             return m2cls;\n         } catch (Throwable t) {\n@@ -1642,9 +1726,9 @@ public void setMetaModel(ClassMetaData meta, Class<?> m2) {\n         return null;\n     }\n \n-    ///////////////////////////////\n+    // /////////////////////////////\n     // Configurable implementation\n-    ///////////////////////////////\n+    // /////////////////////////////\n \n     public void setConfiguration(Configuration conf) {\n         _conf = (OpenJPAConfiguration) conf;\n@@ -1655,6 +1739,8 @@ public void startConfiguration() {\n     }\n \n     public void endConfiguration() {\n+        _lock = new ReentrantLock();\n+        \n         initializeMetaDataFactory();\n         if (_implGen == null)\n             _implGen = new InterfaceImplGenerator(this);\n@@ -1669,39 +1755,41 @@ private void initializeMetaDataFactory() {\n         }\n     }\n \n-    //////////////////\n+    // ////////////////\n     // Query metadata\n-    //////////////////\n+    // ////////////////\n \n     /**\n      * Return query metadata for the given class, name, and classloader.\n      */\n-    public synchronized QueryMetaData getQueryMetaData(Class<?> cls, \n-    \tString name, ClassLoader envLoader, boolean mustExist) {\n-        QueryMetaData meta = getQueryMetaDataInternal(cls, name, envLoader);\n-        if (meta == null) {\n-            // load all the metadatas for all the known classes so that\n-            // query names are seen and registered\n-            resolveAll(envLoader);\n-            meta = getQueryMetaDataInternal(cls, name, envLoader);\n-        }\n-\n-        if (meta == null && mustExist) {\n-            if (cls == null) {\n-                throw new MetaDataException(_loc.get\n-                    (\"no-named-query-null-class\", \n-                        getPersistentTypeNames(false, envLoader), name));\n-            } else {\n-                throw new MetaDataException(_loc.get(\"no-named-query\",\n-                    cls, name));\n+    public QueryMetaData getQueryMetaData(Class<?> cls, String name, ClassLoader envLoader, boolean mustExist) {\n+        lock();\n+        try {\n+            QueryMetaData meta = getQueryMetaDataInternal(cls, name, envLoader);\n+            if (meta == null) {\n+                // load all the metadatas for all the known classes so that\n+                // query names are seen and registered\n+                resolveAll(envLoader);\n+                meta = getQueryMetaDataInternal(cls, name, envLoader);\n             }\n-        }\n \n-        return meta;\n+            if (meta == null && mustExist) {\n+                if (cls == null) {\n+                    throw new MetaDataException(_loc.get(\"no-named-query-null-class\", getPersistentTypeNames(false,\n+                        envLoader), name));\n+                } else {\n+                    throw new MetaDataException(_loc.get(\"no-named-query\", cls, name));\n+                }\n+            }\n+\n+            return meta;\n+        } finally {\n+            unlock();\n+        }\n     }\n \n-    /** \n-     * Resolve all known metadata classes. \n+    /**\n+     * Resolve all known metadata classes.\n      */\n     private void resolveAll(ClassLoader envLoader) {\n         Collection<Class<?>> types = loadPersistentTypes(false, envLoader);\n@@ -1713,15 +1801,14 @@ private void resolveAll(ClassLoader envLoader) {\n     /**\n      * Return query metadata for the given class, name, and classloader.\n      */\n-    private QueryMetaData getQueryMetaDataInternal(Class<?> cls, String name,\n-        ClassLoader envLoader) {\n+    private QueryMetaData getQueryMetaDataInternal(Class<?> cls, String name, ClassLoader envLoader) {\n         if (name == null)\n             return null;\n         QueryMetaData qm = null;\n         if (cls == null) {\n-        \tqm = searchQueryMetaDataByName(name);\n-        \tif (qm != null)\n-        \t\treturn qm;\n+            qm = searchQueryMetaDataByName(name);\n+            if (qm != null)\n+                return qm;\n         }\n         // check cache\n         Object key = getQueryKey(cls, name);\n@@ -1750,65 +1837,95 @@ private QueryMetaData getQueryMetaDataInternal(Class<?> cls, String name,\n     /**\n      * Return the cached query metadata.\n      */\n-    public synchronized QueryMetaData[] getQueryMetaDatas() {\n-        return _queries.values().toArray(new QueryMetaData[_queries.size()]);\n+    public QueryMetaData[] getQueryMetaDatas() {\n+        lock();\n+        try {\n+            return _queries.values().toArray(new QueryMetaData[_queries.size()]);\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n      * Return the cached query metadata for the given name.\n      */\n-    public synchronized QueryMetaData getCachedQueryMetaData(Class<?> cls,\n-        String name) {\n-        return _queries.get(getQueryKey(cls, name));\n+    public QueryMetaData getCachedQueryMetaData(Class<?> cls, String name) {\n+        lock();\n+        try {\n+            return _queries.get(getQueryKey(cls, name));\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n      * Add a new query metadata to the repository and return it.\n      */\n-    public synchronized QueryMetaData addQueryMetaData(Class<?> cls, \n-    \tString name) {\n-        QueryMetaData meta = newQueryMetaData(cls, name);\n-        _queries.put(getQueryKey(meta), meta);\n-        return meta;\n+    public QueryMetaData addQueryMetaData(Class<?> cls, String name) {\n+        lock();\n+        try{\n+            QueryMetaData meta = newQueryMetaData(cls, name);\n+            _queries.put(getQueryKey(meta), meta);\n+            return meta;\n+        }finally{\n+            unlock();\n+        }\n     }\n \n     /**\n      * Create a new query metadata instance.\n      */\n     protected QueryMetaData newQueryMetaData(Class<?> cls, String name) {\n-        QueryMetaData meta = new QueryMetaData(name);\n-        meta.setDefiningType(cls);\n-        return meta;\n+        lock();\n+        try {\n+            QueryMetaData meta = new QueryMetaData(name);\n+            meta.setDefiningType(cls);\n+            return meta;\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n      * Remove the given query metadata from the repository.\n      */\n-    public synchronized boolean removeQueryMetaData(QueryMetaData meta) {\n-        if (meta == null)\n-            return false;\n-        return _queries.remove(getQueryKey(meta)) != null;\n+    public boolean removeQueryMetaData(QueryMetaData meta) {\n+        lock();\n+        try {\n+            if (meta == null) {\n+                return false;\n+            }\n+\n+            return _queries.remove(getQueryKey(meta)) != null;\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n      * Remove query metadata for the given class name if in the repository.\n      */\n-    public synchronized boolean removeQueryMetaData(Class<?> cls, String name) {\n-        if (name == null)\n-            return false;\n-        return _queries.remove(getQueryKey(cls, name)) != null;\n+    public boolean removeQueryMetaData(Class<?> cls, String name) {\n+        lock();\n+        try {\n+            if (name == null)\n+                return false;\n+            return _queries.remove(getQueryKey(cls, name)) != null;\n+        } finally {\n+            unlock();\n+        }\n     }\n-    \n+\n     /**\n-     * Searches all cached query metadata by name. \n+     * Searches all cached query metadata by name.\n      */\n     public QueryMetaData searchQueryMetaDataByName(String name) {\n-    \tfor (Object key : _queries.keySet()) {\n-    \t\tif (key instanceof QueryKey)\n-    \t\t\tif (StringUtils.equals(((QueryKey)key).name, name))\n-    \t\t\t\treturn (QueryMetaData)_queries.get(key);\n-    \t}\n-    \treturn null;\n+        for (Object key : _queries.keySet()) {\n+            if (key instanceof QueryKey)\n+                if (StringUtils.equals(((QueryKey) key).name, name))\n+                    return (QueryMetaData) _queries.get(key);\n+        }\n+        return null;\n     }\n \n     /**\n@@ -1821,8 +1938,7 @@ private static Object getQueryKey(QueryMetaData meta) {\n     }\n \n     /**\n-     * Return a unique key for a given class / name. The class\n-     * argument can be null.\n+     * Return a unique key for a given class / name. The class argument can be null.\n      */\n     protected static Object getQueryKey(Class<?> cls, String name) {\n         if (cls == null)\n@@ -1833,37 +1949,39 @@ protected static Object getQueryKey(Class<?> cls, String name) {\n         return key;\n     }\n \n-    /////////////////////\n+    // ///////////////////\n     // Sequence metadata\n-    /////////////////////\n+    // ///////////////////\n \n     /**\n      * Return sequence metadata for the given name and classloader.\n      */\n-    public synchronized SequenceMetaData getSequenceMetaData(String name,\n-        ClassLoader envLoader, boolean mustExist) {\n-        SequenceMetaData meta = getSequenceMetaDataInternal(name, envLoader);\n-        if (meta == null && SequenceMetaData.NAME_SYSTEM.equals(name)) {\n-            if (_sysSeq == null)\n-                _sysSeq = newSequenceMetaData(name);\n-            return _sysSeq;\n+    public SequenceMetaData getSequenceMetaData(String name, ClassLoader envLoader, boolean mustExist) {\n+        lock();\n+        try {\n+            SequenceMetaData meta = getSequenceMetaDataInternal(name, envLoader);\n+            if (meta == null && SequenceMetaData.NAME_SYSTEM.equals(name)) {\n+                if (_sysSeq == null)\n+                    _sysSeq = newSequenceMetaData(name);\n+                return _sysSeq;\n+            }\n+            if (meta == null && mustExist)\n+                throw new MetaDataException(_loc.get(\"no-named-sequence\", name));\n+            return meta;\n+        } finally {\n+            unlock();\n         }\n-        if (meta == null && mustExist)\n-            throw new MetaDataException(_loc.get(\"no-named-sequence\", name));\n-        return meta;\n     }\n \n     /**\n-     * Used internally by metadata to retrieve sequence metadatas based on\n-     * possibly-unqualified sequence name.\n+     * Used internally by metadata to retrieve sequence metadatas based on possibly-unqualified\n+     * sequence name.\n      */\n-    SequenceMetaData getSequenceMetaData(ClassMetaData context, String name,\n-        boolean mustExist) {\n+    SequenceMetaData getSequenceMetaData(ClassMetaData context, String name, boolean mustExist) {\n         // try with given name\n         MetaDataException e = null;\n         try {\n-            SequenceMetaData seq = getSequenceMetaData(name,\n-                context.getEnvClassLoader(), mustExist);\n+            SequenceMetaData seq = getSequenceMetaData(name, context.getEnvClassLoader(), mustExist);\n             if (seq != null)\n                 return seq;\n         } catch (MetaDataException mde) {\n@@ -1878,11 +1996,9 @@ SequenceMetaData getSequenceMetaData(ClassMetaData context, String name,\n         }\n \n         // try with qualified name\n-        name = Strings.getPackageName(context.getDescribedType())\n-            + \".\" + name;\n+        name = Strings.getPackageName(context.getDescribedType()) + \".\" + name;\n         try {\n-            return getSequenceMetaData(name, context.getEnvClassLoader(),\n-                mustExist);\n+            return getSequenceMetaData(name, context.getEnvClassLoader(), mustExist);\n         } catch (MetaDataException mde) {\n             // throw original exception\n             if (e != null)\n@@ -1894,8 +2010,7 @@ SequenceMetaData getSequenceMetaData(ClassMetaData context, String name,\n     /**\n      * Return sequence metadata for the given name and classloader.\n      */\n-    private SequenceMetaData getSequenceMetaDataInternal(String name,\n-        ClassLoader envLoader) {\n+    private SequenceMetaData getSequenceMetaDataInternal(String name, ClassLoader envLoader) {\n         if (name == null)\n             return null;\n \n@@ -1913,26 +2028,39 @@ private SequenceMetaData getSequenceMetaDataInternal(String name,\n     /**\n      * Return the cached sequence metadata.\n      */\n-    public synchronized SequenceMetaData[] getSequenceMetaDatas() {\n-        return _seqs.values().toArray\n-            (new SequenceMetaData[_seqs.size()]);\n+    public SequenceMetaData[] getSequenceMetaDatas() {\n+        lock();\n+        try {\n+            return _seqs.values().toArray(new SequenceMetaData[_seqs.size()]);\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n      * Return the cached a sequence metadata for the given name.\n      */\n-    public synchronized SequenceMetaData getCachedSequenceMetaData(\n-        String name) {\n-        return _seqs.get(name);\n+    public SequenceMetaData getCachedSequenceMetaData(String name) {\n+        lock();\n+        try {\n+            return _seqs.get(name);\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n      * Add a new sequence metadata to the repository and return it.\n      */\n-    public synchronized SequenceMetaData addSequenceMetaData(String name) {\n-        SequenceMetaData meta = newSequenceMetaData(name);\n-        _seqs.put(name, meta);\n-        return meta;\n+    public SequenceMetaData addSequenceMetaData(String name) {\n+        lock();\n+        try {\n+            SequenceMetaData meta = newSequenceMetaData(name);\n+            _seqs.put(name, meta);\n+            return meta;\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n@@ -1945,47 +2073,65 @@ protected SequenceMetaData newSequenceMetaData(String name) {\n     /**\n      * Remove the given sequence metadata from the repository.\n      */\n-    public synchronized boolean removeSequenceMetaData(SequenceMetaData meta) {\n-        if (meta == null)\n-            return false;\n-        return _seqs.remove(meta.getName()) != null;\n+    public boolean removeSequenceMetaData(SequenceMetaData meta) {\n+        lock();\n+        try {\n+            if (meta == null)\n+                return false;\n+            return _seqs.remove(meta.getName()) != null;\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n      * Remove sequence metadata for the name if in the repository.\n      */\n-    public synchronized boolean removeSequenceMetaData(String name) {\n-        if (name == null)\n-            return false;\n-        return _seqs.remove(name) != null;\n+    public boolean removeSequenceMetaData(String name) {\n+        lock();\n+        try {\n+            if (name == null)\n+                return false;\n+            return _seqs.remove(name) != null;\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n      * Add the given system lifecycle listener.\n      */\n-    public synchronized void addSystemListener(Object listener) {\n-        // copy to avoid issues with ListenerList and avoid unncessary\n-        // locking on the list during runtime\n-        LifecycleEventManager.ListenerList listeners = new\n-            LifecycleEventManager.ListenerList(_listeners);\n-        listeners.add(listener);\n-        _listeners = listeners;\n+    public void addSystemListener(Object listener) {\n+        lock();\n+        try {\n+            // copy to avoid issues with ListenerList and avoid unncessary\n+            // locking on the list during runtime\n+            LifecycleEventManager.ListenerList listeners = new LifecycleEventManager.ListenerList(_listeners);\n+            listeners.add(listener);\n+            _listeners = listeners;\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n      * Remove the given system lifecycle listener.\n      */\n-    public synchronized boolean removeSystemListener(Object listener) {\n-        if (!_listeners.contains(listener))\n-            return false;\n+    public boolean removeSystemListener(Object listener) {\n+        lock();\n+        try {\n+            if (!_listeners.contains(listener))\n+                return false;\n \n-        // copy to avoid issues with ListenerList and avoid unncessary\n-        // locking on the list during runtime\n-        LifecycleEventManager.ListenerList listeners = new\n-            LifecycleEventManager.ListenerList(_listeners);\n-        listeners.remove(listener);\n-        _listeners = listeners;\n-        return true;\n+            // copy to avoid issues with ListenerList and avoid unncessary\n+            // locking on the list during runtime\n+            LifecycleEventManager.ListenerList listeners = new LifecycleEventManager.ListenerList(_listeners);\n+            listeners.remove(listener);\n+            _listeners = listeners;\n+            return true;\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n@@ -1998,18 +2144,22 @@ public synchronized boolean removeSystemListener(Object listener) {\n     /**\n      * Free the resources used by this repository. Closes all user sequences.\n      */\n-    public synchronized void close() {\n-        SequenceMetaData[] smds = getSequenceMetaDatas();\n-        for (int i = 0; i < smds.length; i++)\n-            smds[i].close();\n-        clear();\n+    public void close() {\n+        lock();\n+        try {\n+            SequenceMetaData[] smds = getSequenceMetaDatas();\n+            for (int i = 0; i < smds.length; i++)\n+                smds[i].close();\n+            clear();\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n      * Query key struct.\n      */\n-    private static class QueryKey\n-        implements Serializable {\n+    private static class QueryKey implements Serializable {\n \n         public String clsName;\n         public String name;\n@@ -2020,77 +2170,82 @@ public int hashCode() {\n             return clsHash + nameHash;\n         }\n \n-        public boolean equals(Object obj)\n-\t\t{\n-\t\t\tif (obj == this)\n-\t\t\t\treturn true;\n-\t\t\tif (!(obj instanceof QueryKey))\n-\t\t\t\treturn false;\n-\t\t\n-\t\t\tQueryKey qk = (QueryKey) obj;\n-\t\t\treturn StringUtils.equals (clsName, qk.clsName)\n-\t\t\t\t&& StringUtils.equals (name, qk.name);\t\n-\t\t}\n-\t}\n-    \n+        public boolean equals(Object obj) {\n+            if (obj == this)\n+                return true;\n+            if (!(obj instanceof QueryKey))\n+                return false;\n+\n+            QueryKey qk = (QueryKey) obj;\n+            return StringUtils.equals(clsName, qk.clsName) && StringUtils.equals(name, qk.name);\n+        }\n+    }\n+\n     /**\n      * Return XML metadata for a given field metadata\n+     * \n      * @param fmd\n      * @return XML metadata\n      */\n-    public synchronized XMLMetaData getXMLMetaData(FieldMetaData fmd) {\n-        Class<?> cls = fmd.getDeclaredType();\n-        // check if cached before\n-        XMLMetaData xmlmeta = _xmlmetas.get(cls);\n-        if (xmlmeta != null)\n-            return xmlmeta;\n-        \n-        // load JAXB XML metadata\n-        _factory.loadXMLMetaData(fmd);\n-        \n-        xmlmeta = (XMLClassMetaData) _xmlmetas.get(cls);\n+    public XMLMetaData getXMLMetaData(FieldMetaData fmd) {\n+        lock();\n+        try {\n+            Class<?> cls = fmd.getDeclaredType();\n+            // check if cached before\n+            XMLMetaData xmlmeta = _xmlmetas.get(cls);\n+            if (xmlmeta != null)\n+                return xmlmeta;\n+\n+            // load JAXB XML metadata\n+            _factory.loadXMLMetaData(fmd);\n \n-        return xmlmeta;\n+            xmlmeta = (XMLClassMetaData) _xmlmetas.get(cls);\n+\n+            return xmlmeta;\n+        } finally {\n+            unlock();\n+        }\n     }\n \n     /**\n-     * Create a new metadata, populate it with default information, add it to\n-     * the repository, and return it.\n-     *\n-     * @param access the access type to use in populating metadata\n+     * Create a new metadata, populate it with default information, add it to the repository, and\n+     * return it.\n+     * \n+     * @param access\n+     *            the access type to use in populating metadata\n      */\n     public XMLClassMetaData addXMLMetaData(Class<?> type, String name) {\n         XMLClassMetaData meta = newXMLClassMetaData(type, name);\n-        \n-        // synchronize on this rather than the map, because all other methods\n-        // that access _xmlmetas are synchronized on this\n-        synchronized (this) {\n+        lock();\n+        try {\n             _xmlmetas.put(type, meta);\n+        } finally {\n+            unlock();\n         }\n         return meta;\n     }\n \n     /**\n-     * Return the cached XMLClassMetaData for the given class\n-     * Return null if none.\n+     * Return the cached XMLClassMetaData for the given class Return null if none.\n      */\n     public XMLMetaData getCachedXMLMetaData(Class<?> cls) {\n         return _xmlmetas.get(cls);\n     }\n-    \n+\n     /**\n      * Create a new xml class metadata\n+     * \n      * @param type\n      * @param name\n      * @return a XMLClassMetaData\n      */\n     protected XMLClassMetaData newXMLClassMetaData(Class<?> type, String name) {\n         return new XMLClassMetaData(type, name);\n     }\n-    \n+\n     /**\n-     * Create a new xml field meta, add it to the fieldMap in the given \n-     *     xml class metadata\n+     * Create a new xml field meta, add it to the fieldMap in the given xml class metadata\n+     * \n      * @param type\n      * @param name\n      * @param meta"}]}

