{"sha":"45651cee86e2b0fd09d9ba131c25b5f668c0412d","node_id":"MDY6Q29tbWl0MjA2MzY0OjQ1NjUxY2VlODZlMmIwZmQwOWQ5YmExMzFjMjViNWY2NjhjMDQxMmQ=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-08-02T13:58:56Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-08-02T13:58:56Z"},"message":"OPENJPA-497: TemporalType conversion at facade level Query.\nAlso includes extensive changes in parameter validation logic and data structure.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@681977 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5cf0c5cf0f06c9b4894cfaee3f0224e6046858f0","url":"https://api.github.com/repos/apache/openjpa/git/trees/5cf0c5cf0f06c9b4894cfaee3f0224e6046858f0"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/45651cee86e2b0fd09d9ba131c25b5f668c0412d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/45651cee86e2b0fd09d9ba131c25b5f668c0412d","html_url":"https://github.com/apache/openjpa/commit/45651cee86e2b0fd09d9ba131c25b5f668c0412d","comments_url":"https://api.github.com/repos/apache/openjpa/commits/45651cee86e2b0fd09d9ba131c25b5f668c0412d/comments","author":null,"committer":null,"parents":[{"sha":"043b0596b888f03b8ac25cdd694a05026b870dc8","url":"https://api.github.com/repos/apache/openjpa/commits/043b0596b888f03b8ac25cdd694a05026b870dc8","html_url":"https://github.com/apache/openjpa/commit/043b0596b888f03b8ac25cdd694a05026b870dc8"}],"stats":{"total":1789,"additions":1252,"deletions":537},"files":[{"sha":"97441334bc1d387555e51c4c96ad7dd41e616c57","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestQueryParameterBinding.java","status":"added","additions":247,"deletions":0,"changes":247,"blob_url":"https://github.com/apache/openjpa/blob/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestQueryParameterBinding.java","raw_url":"https://github.com/apache/openjpa/raw/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestQueryParameterBinding.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestQueryParameterBinding.java?ref=45651cee86e2b0fd09d9ba131c25b5f668c0412d","patch":"@@ -0,0 +1,247 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence.jdbc.query;\r\n+\r\n+import javax.persistence.EntityManager;\r\n+import javax.persistence.Query;\r\n+\r\n+import org.apache.openjpa.persistence.ArgumentException;\r\n+import org.apache.openjpa.persistence.jdbc.query.domain.Binder;\r\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n+\r\n+/**\r\n+ * Tests validation of positional and named parameter binding for JPQL queries.\r\n+ *  \r\n+ *  \r\n+ * @author Pinaki Poddar\r\n+ *\r\n+ */\r\n+public class TestQueryParameterBinding extends SingleEMFTestCase {\r\n+\tprivate static String JPQL = \"SELECT p FROM Binder p \";\r\n+\t\r\n+\tprivate static int INT_VALUE    = 1;\r\n+\tprivate static String STR_VALUE = \"2\";\r\n+\tprivate static double DBL_VALUE = 3.0;\r\n+\t\r\n+\tprivate EntityManager em;\r\n+\t@Override\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tsuper.setUp(CLEAR_TABLES, Binder.class);\r\n+\t\t\r\n+\t\tem = emf.createEntityManager();\r\n+\t\tem.getTransaction().begin();\r\n+\t\tem.persist(new Binder(INT_VALUE, STR_VALUE, DBL_VALUE));\r\n+\t\tem.getTransaction().commit();\r\n+\t}\r\n+\t\r\n+\tpublic void testPositionalParameterWithPositionalBindingSucceeds() {\r\n+\t\tString JPQL_POSITIONAL  = JPQL + \"WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\";\r\n+\t\tQuery q = em.createQuery(JPQL_POSITIONAL);\r\n+\t\tq.setParameter(1, INT_VALUE);\r\n+\t\tq.setParameter(2, STR_VALUE);\r\n+\t\tq.setParameter(3, DBL_VALUE);\r\n+\t\t\r\n+\t\tassertEquals(1, q.getResultList().size());\r\n+\t}\r\n+\t\r\n+\tpublic void testPositionalParameterWithNamedBindingFails() {\r\n+\t\tString JPQL_POSITIONAL  = JPQL + \"WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\";\r\n+\t\tQuery q = em.createQuery(JPQL_POSITIONAL);\r\n+\t\tq.setParameter(\"p1\", INT_VALUE);\r\n+\t\tq.setParameter(\"p2\", STR_VALUE);\r\n+\t\tq.setParameter(\"p3\", DBL_VALUE);\r\n+\t\t\r\n+\t\tfail(q);\r\n+\t}\r\n+\t\r\n+\tpublic void testPositionalParameterWithInsufficientValuesFails() {\r\n+\t\tString JPQL_POSITIONAL  = JPQL + \"WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\";\r\n+\t\tQuery q = em.createQuery(JPQL_POSITIONAL);\r\n+\t\tq.setParameter(1, INT_VALUE);\r\n+\t\tq.setParameter(2, STR_VALUE);\r\n+\t\t\r\n+\t\tfail(q);\r\n+\t}\r\n+\t\r\n+\tpublic void testPositionalParameterWithExtraValuesFails() {\r\n+\t\tString JPQL_POSITIONAL  = JPQL + \"WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\";\r\n+\t\tQuery q = em.createQuery(JPQL_POSITIONAL);\r\n+\t\tq.setParameter(1, INT_VALUE);\r\n+\t\tq.setParameter(2, STR_VALUE);\r\n+\t\tq.setParameter(3, DBL_VALUE);\r\n+\t\tq.setParameter(4, 4);\r\n+\t\t\r\n+\t\tfail(q);\r\n+\t}\r\n+\r\n+\tpublic void testPositionalParameterWithRepeatedValuesSucceeds() {\r\n+\t\tString jPQL_POSITIONAL_REPEATED_PARAM  = \r\n+\t\t\tJPQL + \"WHERE p.p1=?1 OR p.p1=?1 AND p.p3=?2\";\r\n+\t\tQuery q = em.createQuery(jPQL_POSITIONAL_REPEATED_PARAM);\r\n+\t\tq.setParameter(1,  INT_VALUE);\r\n+\t\tq.setParameter(2,  DBL_VALUE);\r\n+\t\t\r\n+\t\tassertEquals(1,q.getResultList().size());\r\n+\t}\r\n+\t\r\n+\tpublic void testPositionalParameterWithGapSucceeds() {\r\n+\t\tString JPQL_POSITIONAL_GAP_IN_PARAM  = \r\n+\t\t\tJPQL + \"WHERE p.p1=?1 AND p.p2=?3\";\r\n+\t\tQuery q = em.createQuery(JPQL_POSITIONAL_GAP_IN_PARAM);\r\n+\t\tq.setParameter(1,  INT_VALUE);\r\n+\t\tq.setParameter(3,  STR_VALUE);\r\n+\t\t\r\n+\t\tassertEquals(1,q.getResultList().size());\r\n+\t}\r\n+\t\r\n+\tpublic void testPositionalParameterWithGapFails() {\r\n+\t\tString JPQL_POSITIONAL_GAP_IN_PARAM  = \r\n+\t\t\tJPQL + \"WHERE p.p1=?1 AND p.p3=?3\";\r\n+\t\tQuery q = em.createQuery(JPQL_POSITIONAL_GAP_IN_PARAM);\r\n+\t\tq.setParameter(1,  INT_VALUE);\r\n+\t\tq.setParameter(2,  STR_VALUE);\r\n+\t\tq.setParameter(3,  DBL_VALUE);\r\n+\t\t\r\n+\t\tfail(q);\r\n+\t}\r\n+\t\r\n+\tpublic void testNamedParameterWithNamedBindingSucceeds() {\r\n+\t\tString JPQL_NAMED  = JPQL + \"WHERE p.p1=:p1 AND p.p2=:p2 AND p.p3=:p3\";\r\n+\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n+\t\tq.setParameter(\"p1\", INT_VALUE);\r\n+\t\tq.setParameter(\"p2\", STR_VALUE);\r\n+\t\tq.setParameter(\"p3\", DBL_VALUE);\r\n+\t\t\r\n+\t\tassertEquals(1, q.getResultList().size());\r\n+\t}\r\n+\t\r\n+\tpublic void testNamedParameterWithPositionalBindingFails() {\r\n+\t\tString JPQL_NAMED  = JPQL + \"WHERE p.p1=:p1 AND p.p2=:p2 AND p.p3=:p3\";\r\n+\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n+\t\tq.setParameter(1, INT_VALUE);\r\n+\t\tq.setParameter(2, STR_VALUE);\r\n+\t\tq.setParameter(3, DBL_VALUE);\r\n+\t\t\r\n+\t\tfail(q);\r\n+\t}\r\n+\t\r\n+\tpublic void testNamedParameterWithInsufficientValuesFails() {\r\n+\t\tString JPQL_NAMED  = JPQL + \"WHERE p.p1=:p1 AND p.p2=:p2 AND p.p3=:p3\";\r\n+\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n+\t\tq.setParameter(\"p1\", INT_VALUE);\r\n+\t\tq.setParameter(\"p2\", STR_VALUE);\r\n+\t\t\r\n+\t\tfail(q);\r\n+\t}\r\n+\t\r\n+\tpublic void testNamedParameterWithExtraValuesFails() {\r\n+\t\tString JPQL_NAMED  = JPQL + \"WHERE p.p1=:p1 AND p.p2=:p2 AND p.p3=:p3\";\r\n+\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n+\t\tq.setParameter(\"p1\", INT_VALUE);\r\n+\t\tq.setParameter(\"p2\", STR_VALUE);\r\n+\t\tq.setParameter(\"p3\", DBL_VALUE);\r\n+\t\tq.setParameter(\"p4\", 4);\r\n+\t\t\r\n+\t\tfail(q);\r\n+\t}\r\n+\r\n+\tpublic void testNamedParameterWithRepeatedValuesSucceeds() {\r\n+\t\tString jPQL_NAMED_REPEATED_PARAM  = \r\n+\t\t\tJPQL + \"WHERE p.p1=:p1 OR p.p1=:p1 AND p.p3=:p2\";\r\n+\t\tQuery q = em.createQuery(jPQL_NAMED_REPEATED_PARAM);\r\n+\t\tq.setParameter(\"p1\",  INT_VALUE);\r\n+\t\tq.setParameter(\"p2\",  DBL_VALUE);\r\n+\t\t\r\n+\t\tassertEquals(1,q.getResultList().size());\r\n+\t}\r\n+\t\r\n+\tpublic void testNamedParameterWithGapSucceeds() {\r\n+\t\tString JPQL_NAMED_GAP_IN_PARAM  = \r\n+\t\t\tJPQL + \"WHERE p.p1=:p1 AND p.p2=:p3\";\r\n+\t\tQuery q = em.createQuery(JPQL_NAMED_GAP_IN_PARAM);\r\n+\t\tq.setParameter(\"p1\",  INT_VALUE);\r\n+\t\tq.setParameter(\"p3\",  STR_VALUE);\r\n+\t\t\r\n+\t\tassertEquals(1,q.getResultList().size());\r\n+\t}\r\n+\t\r\n+\tpublic void testNamedParameterWithGapFails() {\r\n+\t\tString JPQL_NAMED_GAP_IN_PARAM  = \r\n+\t\t\tJPQL + \"WHERE p.p1=:p1 AND p.p3=:p3\";\r\n+\t\tQuery q = em.createQuery(JPQL_NAMED_GAP_IN_PARAM);\r\n+\t\tq.setParameter(\"p1\",  INT_VALUE);\r\n+\t\tq.setParameter(\"p2\",  STR_VALUE);\r\n+\t\tq.setParameter(\"p3\",  DBL_VALUE);\r\n+\t\t\r\n+\t\tfail(q);\r\n+\t}\r\n+\t\r\n+\tpublic void testNamedParameterWithWrongType() {\r\n+\t\tString JPQL_NAMED  = JPQL + \"WHERE p.p1=:p1 AND p.p2=:p2 AND p.p3=:p3\";\r\n+\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n+\t\tq.setParameter(\"p1\",  INT_VALUE);\r\n+\t\tq.setParameter(\"p2\",  DBL_VALUE);\r\n+\t\tq.setParameter(\"p3\",  STR_VALUE);\r\n+\t\t\r\n+\t\tfail(q);\r\n+\t}\r\n+\t\r\n+\tpublic void testPositionalParameterWithWrongType() {\r\n+\t\tString JPQL_NAMED  = JPQL + \"WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\";\r\n+\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n+\t\tq.setParameter(1,  INT_VALUE);\r\n+\t\tq.setParameter(2,  DBL_VALUE);\r\n+\t\tq.setParameter(3,  STR_VALUE);\r\n+\t\t\r\n+\t\tfail(q);\r\n+\t}\r\n+\t\r\n+\tpublic void testNamedParameterWithNullValue() {\r\n+\t\tString JPQL_NAMED  = JPQL + \"WHERE p.p1=:p1 AND p.p2=:p2 AND p.p3=:p3\";\r\n+\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n+\t\tq.setParameter(\"p1\",  INT_VALUE);\r\n+\t\tq.setParameter(\"p2\",  null);\r\n+\t\tq.setParameter(\"p3\",  null);\r\n+\t\t\r\n+\t\tfail(q);\r\n+\t}\r\n+\t\r\n+\tpublic void testPositionalParameterWithNullValue() {\r\n+\t\tString JPQL_NAMED  = JPQL + \"WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\";\r\n+\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n+\t\tq.setParameter(1,  INT_VALUE);\r\n+\t\tq.setParameter(2,  null);\r\n+\t\tq.setParameter(3,  null);\r\n+\t\t\r\n+\t\tfail(q);\r\n+\t}\r\n+\t\r\n+\t\r\n+\tvoid fail(Query q) {\r\n+\t\ttry {\r\n+\t\t\tq.getResultList();\r\n+\t\t\tfail(\"Expeceted \" + ArgumentException.class.getName());\r\n+\t\t} catch (IllegalArgumentException ex) {\r\n+\t\t// good\r\n+\t\t\tSystem.err.println(\"*** ERROR \" + getName());\r\n+\t\t\tSystem.err.println(\"*** ERROR \" + ex.getMessage());\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+}\r"},{"sha":"603d4132439918d851e4651a3ac504d0504b6e24","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestTemporalTypeQueryParameterBinding.java","status":"added","additions":198,"deletions":0,"changes":198,"blob_url":"https://github.com/apache/openjpa/blob/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestTemporalTypeQueryParameterBinding.java","raw_url":"https://github.com/apache/openjpa/raw/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestTemporalTypeQueryParameterBinding.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestTemporalTypeQueryParameterBinding.java?ref=45651cee86e2b0fd09d9ba131c25b5f668c0412d","patch":"@@ -0,0 +1,198 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence.jdbc.query;\r\n+\r\n+import java.sql.Time;\r\n+import java.sql.Timestamp;\r\n+import java.util.Calendar;\r\n+import java.util.Date;\r\n+\r\n+import javax.persistence.EntityManager;\r\n+import javax.persistence.Query;\r\n+import javax.persistence.TemporalType;\r\n+\r\n+import org.apache.openjpa.persistence.ArgumentException;\r\n+import org.apache.openjpa.persistence.jdbc.query.domain.TimeKeeper;\r\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n+\r\n+/**\r\n+ * Tests that queries can convert to temporal types.\r\n+ * Also tests that parameter validation for mismatch between named parameter\r\n+ * and positional binding or vice versa.\r\n+ *  \r\n+ * Originally reported in \r\n+ * <A HRE=\"http://issues.apache.org/jira/browse/OPENJPA-112>OPENJPA-497</A>\r\n+ *  \r\n+ * @author Pinaki Poddar\r\n+ *\r\n+ */\r\n+public class TestTemporalTypeQueryParameterBinding extends SingleEMFTestCase {\r\n+\tprivate static Calendar PARAM_CALENDAR = Calendar.getInstance();\r\n+\tprivate  static long T1 = PARAM_CALENDAR.getTimeInMillis();\r\n+\tprivate  static long T2 = T1 + 2000; \r\n+\tprivate  static long T3 = T1 + 3000;\r\n+\t\r\n+\tprivate static Date     VALUE_DATE     = new Date(T1);\r\n+\tprivate static Time     VALUE_TIME     = new Time(T2);\r\n+\tprivate static Timestamp VALUE_TSTAMP   = new Timestamp(T3);\r\n+\t\r\n+\t\r\n+\tprivate static String JPQL_NAMED  = \r\n+\t\t\"SELECT p FROM TimeKeeper p WHERE p.date=:d AND p.time=:t AND p.tstamp=:ts\";\r\n+\tprivate static String JPQL_POSITIONAL  = \r\n+\t\t\"SELECT p FROM TimeKeeper p WHERE p.date=?1 AND p.time=?2 AND p.tstamp=?3\";\r\n+\t\r\n+\tprivate EntityManager em;\r\n+\t@Override\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tsuper.setUp(CLEAR_TABLES, TimeKeeper.class);\r\n+\t\tem = emf.createEntityManager();\r\n+\t\t\r\n+\t\tTimeKeeper pc = new TimeKeeper();\r\n+\t\tpc.setDate(VALUE_DATE);\r\n+\t\tpc.setTime(VALUE_TIME);\r\n+\t\tpc.setTstamp(VALUE_TSTAMP);\r\n+\t\t\r\n+\t\tem.getTransaction().begin();\r\n+\t\tem.persist(pc);\r\n+\t\tem.getTransaction().commit();\r\n+\t}\r\n+\t\r\n+\tpublic void testNamedParameterConvertedFromCalendarValue() {\r\n+\t\tCalendar c1 = Calendar.getInstance();\r\n+\t\tCalendar c2 = Calendar.getInstance();\r\n+\t\tCalendar c3 = Calendar.getInstance();\r\n+\t\tc1.setTimeInMillis(T1);\r\n+\t\tc2.setTimeInMillis(T2);\r\n+\t\tc3.setTimeInMillis(T3);\r\n+\t\t\r\n+\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n+\t\tq.setParameter(\"d\",  c1, TemporalType.DATE);\r\n+\t\tq.setParameter(\"t\",  c2, TemporalType.TIME);\r\n+\t\tq.setParameter(\"ts\", c3, TemporalType.TIMESTAMP);\r\n+\t\t\r\n+\t\tassertEquals(1, q.getResultList().size());\r\n+\t}\r\n+\t\r\n+\tpublic void testPositionalParameterConvertedFromCalendarValue() {\r\n+\t\tCalendar c1 = Calendar.getInstance();\r\n+\t\tCalendar c2 = Calendar.getInstance();\r\n+\t\tCalendar c3 = Calendar.getInstance();\r\n+\t\tc1.setTimeInMillis(T1);\r\n+\t\tc2.setTimeInMillis(T2);\r\n+\t\tc3.setTimeInMillis(T3);\r\n+\t\t\r\n+\t\tQuery q = em.createQuery(JPQL_POSITIONAL);\r\n+\t\tq.setParameter(1,  c1, TemporalType.DATE);\r\n+\t\tq.setParameter(2,  c2, TemporalType.TIME);\r\n+\t\tq.setParameter(3,  c3, TemporalType.TIMESTAMP);\r\n+\t\t\r\n+\t\tassertEquals(1, q.getResultList().size());\r\n+\t}\r\n+\tpublic void testNamedParameterConvertedFromDateValue() {\r\n+\t\tDate d1 = new Date(T1);\r\n+\t\tDate d2 = new Date(T2);\r\n+\t\tDate d3 = new Date(T3);\r\n+\t\t\r\n+\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n+\t\tq.setParameter(\"d\",  d1, TemporalType.DATE);\r\n+\t\tq.setParameter(\"t\",  d2, TemporalType.TIME);\r\n+\t\tq.setParameter(\"ts\", d3, TemporalType.TIMESTAMP);\r\n+\t\t\r\n+\t\tassertEquals(1, q.getResultList().size());\r\n+\t}\r\n+\t\r\n+\tpublic void testPositionalParameterConvertedFromDateValue() {\r\n+\t\tDate d1 = new Date(T1);\r\n+\t\tDate d2 = new Date(T2);\r\n+\t\tDate d3 = new Date(T3);\r\n+\t\t\r\n+\t\tQuery q = em.createQuery(JPQL_POSITIONAL);\r\n+\t\tq.setParameter(1,  d1, TemporalType.DATE);\r\n+\t\tq.setParameter(2,  d2, TemporalType.TIME);\r\n+\t\tq.setParameter(3,  d3, TemporalType.TIMESTAMP);\r\n+\t\t\r\n+\t\tassertEquals(1, q.getResultList().size());\r\n+\t}\r\n+\t\r\n+\t\r\n+\tpublic void testNamedParameterWithMismatchedValue() {\r\n+\t\tDate d1 = new Date(T1);\r\n+\t\tDate d2 = new Date(T2);\r\n+\t\tDate d3 = new Date(T3);\r\n+\t\t\r\n+\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n+\t\tq.setParameter(\"d\",  d1, TemporalType.TIME);\r\n+\t\tq.setParameter(\"ts\",  d2, TemporalType.TIMESTAMP);\r\n+\t\tq.setParameter(\"t\",  d3, TemporalType.DATE);\r\n+\t\t\r\n+\t\ttry {\r\n+\t\t\tq.getResultList();\r\n+\t\t\tfail(\"Expeceted \" + ArgumentException.class.getName());\r\n+\t\t} catch (ArgumentException ex) {\r\n+\t\t\t// good\r\n+\t\t\tSystem.err.println(ex.getMessage());\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\tpublic void testPositionalParameterWithMismatchedValue() {\r\n+\t\tDate d1 = new Date(T1);\r\n+\t\tDate d2 = new Date(T2);\r\n+\t\tDate d3 = new Date(T3);\r\n+\t\t\r\n+\t\tQuery q = em.createQuery(JPQL_POSITIONAL);\r\n+\t\tq.setParameter(1,  d1, TemporalType.TIME);\r\n+\t\tq.setParameter(2,  d2, TemporalType.TIMESTAMP);\r\n+\t\tq.setParameter(3,  d3, TemporalType.DATE);\r\n+\t\t\r\n+\t\ttry {\r\n+\t\t\tq.getResultList();\r\n+\t\t\tfail(\"Expeceted \" + ArgumentException.class.getName());\r\n+\t\t} catch (ArgumentException ex) {\r\n+\t\t\t// good\r\n+\t\t\tSystem.err.println(ex.getMessage());\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\tvoid verifyParams(String jpql, Class error, Object...params) {\r\n+\t\tEntityManager em = emf.createEntityManager();\r\n+\t\tem.getTransaction().begin();\r\n+\t\tQuery query = em.createNativeQuery(jpql);\r\n+\t\tfor (int i=0; params != null && i<params.length; i=+2) {\r\n+\t\t\ttry {\r\n+\t\t\t\tif (params[i] instanceof Number) {\r\n+\t\t\t\t\tquery.setParameter(((Number)params[i]).intValue(), params[i+1]);\r\n+\t\t\t\t} else { \r\n+\t\t\t\t\tquery.setParameter(params[i].toString(), params[i+1]);\r\n+\t\t\t\t}\r\n+\t\t\t\tif (error != null)\r\n+\t\t\t\t\tfail(\"Expected \" + error.getName());\r\n+\t\t\t} catch (Exception e) {\r\n+\t\t\t\tif (error.isAssignableFrom(e.getClass())) {\r\n+\t\t\t\t\tSystem.err.println(e.getMessage());\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\te.printStackTrace();\r\n+\t\t\t\t\tfail();\r\n+\t\t\t\t}\r\n+\t\t\t} \r\n+\t\t\t\t\r\n+\t\t}\r\n+\t\tem.getTransaction().commit();\r\n+\t}\r\n+}\r"},{"sha":"a8408f4047d863266bb3b48e05fcf25795e4e9e3","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestNonPrimaryKeyQueryParameters.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestNonPrimaryKeyQueryParameters.java","raw_url":"https://github.com/apache/openjpa/raw/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestNonPrimaryKeyQueryParameters.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestNonPrimaryKeyQueryParameters.java?ref=45651cee86e2b0fd09d9ba131c25b5f668c0412d","patch":"@@ -80,7 +80,6 @@ public void testSelectQueryWithNoParameter() {\n \t\tEntityManager em = emf.createEntityManager();\r\n \r\n \t\tQuery query = em.createQuery(\"SELECT d from Department d\");\r\n-\t\tquery.setParameter(1, DEPT_NAME);\r\n \t\tDepartment dept = (Department) query.getSingleResult();\r\n \r\n \t\tassertEquals(FULLTIME_EMPLOYEE_COUNT, dept.getFullTimeEmployees()\r"},{"sha":"52b275aed12ce5e0fa7fdb88b105a89d15dd8f92","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Binder.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Binder.java","raw_url":"https://github.com/apache/openjpa/raw/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Binder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Binder.java?ref=45651cee86e2b0fd09d9ba131c25b5f668c0412d","patch":"@@ -0,0 +1,50 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.persistence.jdbc.query.domain;\r\n+\r\n+import java.sql.Time;\r\n+import java.sql.Timestamp;\r\n+import java.util.Date;\r\n+\r\n+import javax.persistence.Column;\r\n+import javax.persistence.Entity;\r\n+import javax.persistence.GeneratedValue;\r\n+import javax.persistence.Id;\r\n+\r\n+@Entity\r\n+public class Binder {\r\n+\t@Id\r\n+\t@GeneratedValue\r\n+\tprivate long id;\r\n+\t\r\n+\tprivate int p1;\r\n+\tprivate String p2;\r\n+\tprivate double p3;\r\n+\t\r\n+\tprotected Binder() {\r\n+\t\tthis(-1, \"-1\" , -1.0);\r\n+\t}\r\n+\t\r\n+\tpublic Binder(int i1, String i2, double i3) {\r\n+\t\tp1 = i1;\r\n+\t\tp2 = i2;\r\n+\t\tp3 = i3;\r\n+\t}\r\n+\t\r\n+}\r"},{"sha":"529210784e3a6ced693c265f1a637bf98c61f74a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/TimeKeeper.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/TimeKeeper.java","raw_url":"https://github.com/apache/openjpa/raw/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/TimeKeeper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/TimeKeeper.java?ref=45651cee86e2b0fd09d9ba131c25b5f668c0412d","patch":"@@ -0,0 +1,65 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.persistence.jdbc.query.domain;\r\n+\r\n+import java.sql.Time;\r\n+import java.sql.Timestamp;\r\n+import java.util.Date;\r\n+\r\n+import javax.persistence.Column;\r\n+import javax.persistence.Entity;\r\n+import javax.persistence.GeneratedValue;\r\n+import javax.persistence.Id;\r\n+\r\n+@Entity\r\n+public class TimeKeeper {\r\n+\t@Id\r\n+\t@GeneratedValue\r\n+\tprivate long id;\r\n+\t\r\n+\t@Column(name=\"D\")\r\n+\tprivate Date date;\r\n+\t@Column(name=\"T\")\r\n+\tprivate Time time;\r\n+\t@Column(name=\"TS\")\r\n+\tprivate Timestamp tstamp;\r\n+\t\r\n+\tpublic Date getDate() {\r\n+\t\treturn date;\r\n+\t}\r\n+\tpublic void setDate(Date date) {\r\n+\t\tthis.date = date;\r\n+\t}\r\n+\tpublic Time getTime() {\r\n+\t\treturn time;\r\n+\t}\r\n+\tpublic void setTime(Time time) {\r\n+\t\tthis.time = time;\r\n+\t}\r\n+\tpublic Timestamp getTstamp() {\r\n+\t\treturn tstamp;\r\n+\t}\r\n+\tpublic void setTstamp(Timestamp tstamp) {\r\n+\t\tthis.tstamp = tstamp;\r\n+\t}\r\n+\tpublic long getId() {\r\n+\t\treturn id;\r\n+\t}\r\n+\r\n+}\r"},{"sha":"cd1d7b37f390ff196755b0a9a751e3a9c1d0775f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDupNamedQuery.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDupNamedQuery.java","raw_url":"https://github.com/apache/openjpa/raw/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDupNamedQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDupNamedQuery.java?ref=45651cee86e2b0fd09d9ba131c25b5f668c0412d","patch":"@@ -55,7 +55,7 @@ private void simpleQuery(boolean simple2, String findOneQName,\n         String ValueTwo) {\n         EntityManager em = emf.createEntityManager();\n \n-        List list = em.createNamedQuery(findOneQName).setParameter(1, nameOne)\n+        List list = em.createNamedQuery(findOneQName).setParameter(\"fname\", nameOne)\n             .getResultList();\n         assertNotNull(list);\n         assertEquals(list.size(), 1);"},{"sha":"9dc86f38fdbf917c0c0ca52ebe6750df121d6a05","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","status":"modified","additions":676,"deletions":532,"changes":1208,"blob_url":"https://github.com/apache/openjpa/blob/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java?ref=45651cee86e2b0fd09d9ba131c25b5f668c0412d","patch":"@@ -20,7 +20,10 @@\n \n import java.io.Serializable;\n import java.lang.reflect.Method;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Calendar;\n import java.util.Collection;\n import java.util.Collections;\n@@ -30,9 +33,12 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.TreeMap;\n+\n import javax.persistence.FlushModeType;\n import javax.persistence.Query;\n import javax.persistence.TemporalType;\n+import javax.swing.text.Position;\n \n import org.apache.commons.collections.map.LinkedMap;\n import org.apache.openjpa.enhance.Reflection;\n@@ -50,543 +56,681 @@\n \n /**\n  * Implementation of {@link Query} interface.\n- *\n+ * \n  * @author Marc Prud'hommeaux\n  * @author Abe White\n  * @nojavadoc\n  */\n-public class QueryImpl\n-    implements OpenJPAQuerySPI, Serializable {\n-\n-    private static final Object[] EMPTY_ARRAY = new Object[0];\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (QueryImpl.class);\n-\n-    private final DelegatingQuery _query;\n-    private transient EntityManagerImpl _em;\n-    private transient FetchPlan _fetch;\n-\n-    private Map _named;\n-    private List _positional;\n-\n-    /**\n-     * Constructor; supply factory exception translator and delegate.\n-     * \n-     * @param em\n-     *            The EntityManager which created this query\n-     * @param ret\n-     *            Exception translater for this query\n-     * @param query\n-     *            The underlying \"kernel\" query.\n-     */\n-    public QueryImpl(EntityManagerImpl em, RuntimeExceptionTranslator ret,\n-        org.apache.openjpa.kernel.Query query) {\n-        _em = em;\n-        _query = new DelegatingQuery(query, ret);\n-    }\n-    \n-    /**\n-     * Constructor; supply factory and delegate.\n-     * @deprecated\n-     */\n-    public QueryImpl(EntityManagerImpl em, org.apache.openjpa.kernel.Query query) {\n-        this(em, null, query);\n-    }\n-\n-    /**\n+public class QueryImpl implements OpenJPAQuerySPI, Serializable {\n+\n+\tprivate static final Object[] EMPTY_ARRAY = new Object[0];\n+\n+\tprivate static final Localizer _loc = Localizer.forPackage(QueryImpl.class);\n+\n+\tprivate final DelegatingQuery _query;\n+\tprivate transient EntityManagerImpl _em;\n+\tprivate transient FetchPlan _fetch;\n+\n+\tprivate Map<String, Object> _named;\n+\tprivate Map<Integer, Object> _positional;\n+\n+\tprivate static Object GAP_FILLER = new Object();\n+\n+\t/**\n+\t * Constructor; supply factory exception translator and delegate.\n+\t * \n+\t * @param em\n+\t *            The EntityManager which created this query\n+\t * @param ret\n+\t *            Exception translater for this query\n+\t * @param query\n+\t *            The underlying \"kernel\" query.\n+\t */\n+\tpublic QueryImpl(EntityManagerImpl em, RuntimeExceptionTranslator ret,\n+\t\t\torg.apache.openjpa.kernel.Query query) {\n+\t\t_em = em;\n+\t\t_query = new DelegatingQuery(query, ret);\n+\t}\n+\n+\t/**\n+\t * Constructor; supply factory and delegate.\n+\t * \n+\t * @deprecated\n+\t */\n+\tpublic QueryImpl(EntityManagerImpl em, org.apache.openjpa.kernel.Query query) {\n+\t\tthis(em, null, query);\n+\t}\n+\n+\t/**\n \t * Delegate.\n \t */\n-    public org.apache.openjpa.kernel.Query getDelegate() {\n-        return _query.getDelegate();\n-    }\n-\n-    public OpenJPAEntityManager getEntityManager() {\n-        return _em;\n-    }\n-\n-    public String getLanguage() {\n-        return _query.getLanguage();\n-    }\n-\n-    public QueryOperationType getOperation() {\n-        return QueryOperationType.fromKernelConstant(_query.getOperation());\n-    }\n-\n-    public FetchPlan getFetchPlan() {\n-        _em.assertNotCloseInvoked();\n-        _query.assertNotSerialized();\n-        _query.lock();\n-        try {\n-            if (_fetch == null)\n-                _fetch = ((EntityManagerFactoryImpl) _em.\n-                    getEntityManagerFactory()).toFetchPlan(_query.getBroker(),\n-                    _query.getFetchConfiguration());\n-            return _fetch;\n-        } finally {\n-            _query.unlock();\n-        }\n-    }\n-\n-    public String getQueryString() {\n-        return _query.getQueryString();\n-    }\n-\n-    public boolean getIgnoreChanges() {\n-        return _query.getIgnoreChanges();\n-    }\n-\n-    public OpenJPAQuery setIgnoreChanges(boolean ignore) {\n-        _em.assertNotCloseInvoked();\n-        _query.setIgnoreChanges(ignore);\n-        return this;\n-    }\n-\n-    public OpenJPAQuery addFilterListener(FilterListener listener) {\n-        _em.assertNotCloseInvoked();\n-        _query.addFilterListener(listener);\n-        return this;\n-    }\n-\n-    public OpenJPAQuery removeFilterListener(FilterListener listener) {\n-        _em.assertNotCloseInvoked();\n-        _query.removeFilterListener(listener);\n-        return this;\n-    }\n-\n-    public OpenJPAQuery addAggregateListener(AggregateListener listener) {\n-        _em.assertNotCloseInvoked();\n-        _query.addAggregateListener(listener);\n-        return this;\n-    }\n-\n-    public OpenJPAQuery removeAggregateListener(AggregateListener listener) {\n-        _em.assertNotCloseInvoked();\n-        _query.removeAggregateListener(listener);\n-        return this;\n-    }\n-\n-    public Collection getCandidateCollection() {\n-        return _query.getCandidateCollection();\n-    }\n-\n-    public OpenJPAQuery setCandidateCollection(Collection coll) {\n-        _em.assertNotCloseInvoked();\n-        _query.setCandidateCollection(coll);\n-        return this;\n-    }\n-\n-    public Class getResultClass() {\n-        Class res = _query.getResultType();\n-        if (res != null)\n-            return res;\n-        return _query.getCandidateType();\n-    }\n-\n-    public OpenJPAQuery setResultClass(Class cls) {\n-        _em.assertNotCloseInvoked();\n-        if (ImplHelper.isManagedType(_em.getConfiguration(), cls))\n-            _query.setCandidateType(cls, true);\n-        else\n-            _query.setResultType(cls);\n-        return this;\n-    }\n-\n-    public boolean hasSubclasses() {\n-        return _query.hasSubclasses();\n-    }\n-\n-    public OpenJPAQuery setSubclasses(boolean subs) {\n-        _em.assertNotCloseInvoked();\n-        Class cls = _query.getCandidateType();\n-        _query.setCandidateExtent(_query.getBroker().newExtent(cls, subs));\n-        return this;\n-    }\n-\n-    public int getFirstResult() {\n-        return asInt(_query.getStartRange());\n-    }\n-\n-    public OpenJPAQuery setFirstResult(int startPosition) {\n-        _em.assertNotCloseInvoked();\n-        long end;\n-        if (_query.getEndRange() == Long.MAX_VALUE)\n-            end = Long.MAX_VALUE;\n-        else\n-            end = startPosition +\n-                (_query.getEndRange() - _query.getStartRange());\n-        _query.setRange(startPosition, end);\n-        return this;\n-    }\n-\n-    public int getMaxResults() {\n-        return asInt(_query.getEndRange() - _query.getStartRange());\n-    }\n-\n-    public OpenJPAQuery setMaxResults(int max) {\n-        _em.assertNotCloseInvoked();\n-        long start = _query.getStartRange();\n-        if (max == Integer.MAX_VALUE)\n-            _query.setRange(start, Long.MAX_VALUE);\n-        else\n-            _query.setRange(start, start + max);\n-        return this;\n-    }\n-\n-    public OpenJPAQuery compile() {\n-        _em.assertNotCloseInvoked();\n-        _query.compile();\n-        return this;\n-    }\n-\n-    private Object execute() {\n-        if (_query.getOperation() != QueryOperations.OP_SELECT)\n-            throw new InvalidStateException(_loc.get(\"not-select-query\",\n-                _query.getQueryString()), null, null, false);\n-\n-        validateParameters();\n-\n-        // handle which types of parameters we are using, if any\n-        if (_positional != null)\n-            return _query.execute(_positional.toArray());\n-        if (_named != null)\n-            return _query.execute(_named);\n-        return _query.execute();\n-    }\n-\n-    /**\n-     * Validate that the types of the parameters are correct.\n-     */\n-    private void validateParameters() {\n-        if (_positional != null) {\n-            LinkedMap types = _query.getParameterTypes();\n-            for (int i = 0,\n-                size = Math.min(_positional.size(), types.size());\n-                i < size; i++)\n-                validateParameter(String.valueOf(i),\n-                    (Class) types.getValue(i), _positional.get(i));\n-        } else if (_named != null) {\n-            Map types = _query.getParameterTypes();\n-            for (Iterator i = _named.entrySet().iterator(); i.hasNext();) {\n-                Map.Entry entry = (Map.Entry) i.next();\n-                String name = (String) entry.getKey();\n-                validateParameter(name, (Class) types.get(name),\n-                    entry.getValue());\n-            }\n-        }\n-    }\n-\n-    private void validateParameter(String paramDesc, Class type, Object param) {\n-        // null parameters are allowed, so are not validated\n-        if (param == null || type == null)\n-            return;\n-\n-        // check the parameter against the wrapped type\n-        if (!Filters.wrap(type).isInstance(param))\n-            throw new ArgumentException(_loc.get(\"bad-param-type\",\n-                paramDesc, param.getClass().getName(), type.getName()),\n-                null, null, false);\n-    }\n-\n-    public List getResultList() {\n-        _em.assertNotCloseInvoked();\n-        Object ob = execute();\n-        if (ob instanceof List) {\n-            List ret = (List) ob;\n-            if (ret instanceof ResultList)\n-                return new DelegatingResultList((ResultList) ret,\n-                    PersistenceExceptions.getRollbackTranslator(_em));\n-            else\n-                return ret;\n-        }\n-\n-        return Collections.singletonList(ob);\n-    }\n-\n-    /**\n-     * Execute a query that returns a single result.\n-     */\n-    public Object getSingleResult() {\n-        _em.assertNotCloseInvoked();\n-        // temporarily set query to unique so that a single result is validated\n-        // and returned; unset again in case the user executes query again\n-        // via getResultList\n-        _query.setUnique(true);\n-        try {\n-            return execute();\n-        } finally {\n-            _query.setUnique(false);\n-        }\n-    }\n-\n-    public int executeUpdate() {\n-        _em.assertNotCloseInvoked();\n-        if (_query.getOperation() == QueryOperations.OP_DELETE) {\n-            // handle which types of parameters we are using, if any\n-            if (_positional != null)\n-                return asInt(_query.deleteAll(_positional.toArray()));\n-            if (_named != null)\n-                return asInt(_query.deleteAll(_named));\n-            return asInt(_query.deleteAll());\n-        }\n-        if (_query.getOperation() == QueryOperations.OP_UPDATE) {\n-            // handle which types of parameters we are using, if any\n-            if (_positional != null)\n-                return asInt(_query.updateAll(_positional.toArray()));\n-            if (_named != null)\n-                return asInt(_query.updateAll(_named));\n-            return asInt(_query.updateAll());\n-        }\n-        throw new InvalidStateException(_loc.get(\"not-update-delete-query\",\n-            _query.getQueryString()), null, null, false);\n-    }\n-\n-    /**\n-     * Cast the specified long down to an int, first checking for overflow.\n-     */\n-    private static int asInt(long l) {\n-        if (l > Integer.MAX_VALUE)\n-            return Integer.MAX_VALUE;\n-        if (l < Integer.MIN_VALUE) // unlikely, but we might as well check\n-            return Integer.MIN_VALUE;\n-        return (int) l;\n-    }\n-\n-    public FlushModeType getFlushMode() {\n-        return EntityManagerImpl.fromFlushBeforeQueries(_query.\n-            getFetchConfiguration().getFlushBeforeQueries());\n-    }\n-\n-    public OpenJPAQuery setFlushMode(FlushModeType flushMode) {\n-        _em.assertNotCloseInvoked();\n-        _query.getFetchConfiguration().setFlushBeforeQueries\n-            (EntityManagerImpl.toFlushBeforeQueries(flushMode));\n-        return this;\n-    }\n-\n-    public OpenJPAQuery setHint(String key, Object value) {\n-        _em.assertNotCloseInvoked();\n-        if (key == null || !key.startsWith(\"openjpa.\"))\n-            return this;\n-        String k = key.substring(\"openjpa.\".length());\n-\n-        try {\n-            if (\"Subclasses\".equals(k)) {\n-                if (value instanceof String)\n-                    value = Boolean.valueOf((String) value);\n-                setSubclasses(((Boolean) value).booleanValue());\n-            } else if (\"FilterListener\".equals(k))\n-                addFilterListener(Filters.hintToFilterListener(value,\n-                    _query.getBroker().getClassLoader()));\n-            else if (\"FilterListeners\".equals(k)) {\n-                FilterListener[] arr = Filters.hintToFilterListeners(value,\n-                    _query.getBroker().getClassLoader());\n-                for (int i = 0; i < arr.length; i++)\n-                    addFilterListener(arr[i]);\n-            } else if (\"AggregateListener\".equals(k))\n-                addAggregateListener(Filters.hintToAggregateListener(value,\n-                    _query.getBroker().getClassLoader()));\n-            else if (\"FilterListeners\".equals(k)) {\n-                AggregateListener[] arr = Filters.hintToAggregateListeners\n-                    (value, _query.getBroker().getClassLoader());\n-                for (int i = 0; i < arr.length; i++)\n-                    addAggregateListener(arr[i]);\n-            } else if (k.startsWith(\"FetchPlan.\")) {\n-                k = k.substring(\"FetchPlan.\".length());\n-                hintToSetter(getFetchPlan(), k, value);\n-            } else if (k.startsWith(\"hint.\")) {\n-                if (\"hint.OptimizeResultCount\".equals(k)) {\n-                    if (value instanceof String) {\n-                        try {\n-                            value = new Integer((String) value);\n-                        } catch (NumberFormatException nfe) {\n-                        }\n-                    }\n-                    if (!(value instanceof Number) \n-                        || ((Number) value).intValue() < 0)\n-                        throw new ArgumentException(_loc.get\n-                            (\"bad-query-hint-value\", key, value), null, null, \n-                            false);\n-                }\n-                _query.getFetchConfiguration().setHint(key, value);\n-            }\n-            else\n-                throw new ArgumentException(_loc.get(\"bad-query-hint\", key),\n-                    null, null, false);\n-            return this;\n-        } catch (Exception e) {\n-            throw PersistenceExceptions.toPersistenceException(e);\n-        }\n-    }\n-\n-    private void hintToSetter(FetchPlan fetchPlan, String k, Object value) {\n-        if (fetchPlan == null || k == null)\n-            return;\n-\n-        Method setter = Reflection.findSetter(fetchPlan.getClass(), k, true);\n-        Class paramType = setter.getParameterTypes()[0];\n-        if (Enum.class.isAssignableFrom(paramType) && value instanceof String)\n-            value = Enum.valueOf(paramType, (String) value);\n-        \n-        Filters.hintToSetter(fetchPlan, k, value);\n-    }\n-\n-    public OpenJPAQuery setParameter(int position, Calendar value,\n-        TemporalType t) {\n-        return setParameter(position, value);\n-    }\n-\n-    public OpenJPAQuery setParameter(int position, Date value,\n-        TemporalType type) {\n-        return setParameter(position, value);\n-    }\n-\n-    public OpenJPAQuery setParameter(int position, Object value) {\n-        _query.assertOpen();\n-        _em.assertNotCloseInvoked();\n-        _query.lock();\n-        try {\n-        \tif (isNative() && position < 1) {\n-        \t\tthrow new IllegalArgumentException(_loc.get(\"bad-pos-params\", \n-        \t\t      position, _query.getQueryString()).toString());\n-        \t}\n-            // not allowed to mix positional and named parameters (EDR2 3.6.4)\n-            if (_named != null)\n-                throw new InvalidStateException(_loc.get\n-                    (\"no-pos-named-params-mix\", _query.getQueryString()),\n-                    null, null, false);\n-\n-            if (position < 1)\n-                throw new InvalidStateException(_loc.get\n-                    (\"illegal-index\", position), null, null, false);\n-\n-            if (_positional == null)\n-                _positional = new ArrayList();\n-\n-            // make sure it is at least the requested size\n-            while (_positional.size() < position)\n-                _positional.add(null);\n-\n-            // note that we add it to position - 1, since setPosition\n-            // starts at 1, while List starts at 0\n-            _positional.set(position - 1, value);\n-            return this;\n-        } finally {\n-            _query.unlock();\n-        }\n-    }\n-\n-    public OpenJPAQuery setParameter(String name, Calendar value,\n-        TemporalType t) {\n-        return setParameter(name, value);\n-    }\n-\n-    public OpenJPAQuery setParameter(String name, Date value,\n-        TemporalType type) {\n-        return setParameter(name, value);\n-    }\n-\n-    public OpenJPAQuery setParameter(String name, Object value) {\n-        _query.assertOpen();\n-        _em.assertNotCloseInvoked();\n-        _query.lock();\n-        try {\n-        \tif (isNative()) {\n-        \t\tthrow new IllegalArgumentException(_loc.get(\"no-named-params\", \n-        \t\t    name, _query.getQueryString()).toString());\n-        \t}\n-            // not allowed to mix positional and named parameters (EDR2 3.6.4)\n-            if (_positional != null)\n-                throw new InvalidStateException(_loc.get\n-                    (\"no-pos-named-params-mix\", _query.getQueryString()),\n-                    null, null, false);\n-\n-            if (_named == null)\n-                _named = new HashMap();\n-            _named.put(name, value);\n-            return this;\n-        } finally {\n-            _query.unlock();\n-        }\n-    }\n-    \n-    public boolean isNative() {\n-    \treturn QueryLanguages.LANG_SQL.equals(getLanguage());\n-    }\n-\n-    public boolean hasPositionalParameters() {\n-        return _positional != null;\n-    }\n-\n-    public Object[] getPositionalParameters() {\n-        _query.lock();\n-        try {\n-            return (_positional == null) ? EMPTY_ARRAY : _positional.toArray();\n-        } finally {\n-            _query.unlock();\n-        }\n-    }\n-\n-    public OpenJPAQuery setParameters(Object... params) {\n-        _query.assertOpen();\n-        _em.assertNotCloseInvoked();\n-        _query.lock();\n-        try {\n-            _positional = null;\n-            _named = null;\n-            if (params != null)\n-                for (int i = 0; i < params.length; i++)\n-                    setParameter(i + 1, params[i]);\n-            return this;\n-        } finally {\n-            _query.unlock();\n-        }\n-    }\n-\n-    public Map getNamedParameters() {\n-        _query.lock();\n-        try {\n-            return (_named == null) ? Collections.EMPTY_MAP\n-                : Collections.unmodifiableMap(_named);\n-        } finally {\n-            _query.unlock();\n-        }\n-    }\n-\n-    public OpenJPAQuery setParameters(Map params) {\n-        _query.assertOpen();\n-        _em.assertNotCloseInvoked();\n-        _query.lock();\n-        try {\n-            _positional = null;\n-            _named = null;\n-            if (params != null)\n-                for (Map.Entry e : (Set<Map.Entry>) params.entrySet())\n-                    setParameter((String) e.getKey(), e.getValue());\n-            return this;\n-        } finally {\n-            _query.unlock();\n-        }\n-    }\n-\n-    public OpenJPAQuery closeAll() {\n-        _query.closeAll();\n-        return this;\n-    }\n-\n-    public String[] getDataStoreActions(Map params) {\n-        return _query.getDataStoreActions(params);\n-    }\n-\n-    public int hashCode() {\n-        return _query.hashCode();\n-    }\n-\n-    public boolean equals(Object other) {\n-        if (other == this)\n-            return true;\n-        if (!(other instanceof QueryImpl))\n-            return false;\n-        return _query.equals(((QueryImpl) other)._query);\n+\tpublic org.apache.openjpa.kernel.Query getDelegate() {\n+\t\treturn _query.getDelegate();\n+\t}\n+\n+\tpublic OpenJPAEntityManager getEntityManager() {\n+\t\treturn _em;\n+\t}\n+\n+\tpublic String getLanguage() {\n+\t\treturn _query.getLanguage();\n+\t}\n+\n+\tpublic QueryOperationType getOperation() {\n+\t\treturn QueryOperationType.fromKernelConstant(_query.getOperation());\n+\t}\n+\n+\tpublic FetchPlan getFetchPlan() {\n+\t\t_em.assertNotCloseInvoked();\n+\t\t_query.assertNotSerialized();\n+\t\t_query.lock();\n+\t\ttry {\n+\t\t\tif (_fetch == null)\n+\t\t\t\t_fetch = ((EntityManagerFactoryImpl) _em\n+\t\t\t\t\t\t.getEntityManagerFactory()).toFetchPlan(_query\n+\t\t\t\t\t\t.getBroker(), _query.getFetchConfiguration());\n+\t\t\treturn _fetch;\n+\t\t} finally {\n+\t\t\t_query.unlock();\n+\t\t}\n+\t}\n+\n+\tpublic String getQueryString() {\n+\t\treturn _query.getQueryString();\n+\t}\n+\n+\tpublic boolean getIgnoreChanges() {\n+\t\treturn _query.getIgnoreChanges();\n+\t}\n+\n+\tpublic OpenJPAQuery setIgnoreChanges(boolean ignore) {\n+\t\t_em.assertNotCloseInvoked();\n+\t\t_query.setIgnoreChanges(ignore);\n+\t\treturn this;\n+\t}\n+\n+\tpublic OpenJPAQuery addFilterListener(FilterListener listener) {\n+\t\t_em.assertNotCloseInvoked();\n+\t\t_query.addFilterListener(listener);\n+\t\treturn this;\n+\t}\n+\n+\tpublic OpenJPAQuery removeFilterListener(FilterListener listener) {\n+\t\t_em.assertNotCloseInvoked();\n+\t\t_query.removeFilterListener(listener);\n+\t\treturn this;\n+\t}\n+\n+\tpublic OpenJPAQuery addAggregateListener(AggregateListener listener) {\n+\t\t_em.assertNotCloseInvoked();\n+\t\t_query.addAggregateListener(listener);\n+\t\treturn this;\n+\t}\n+\n+\tpublic OpenJPAQuery removeAggregateListener(AggregateListener listener) {\n+\t\t_em.assertNotCloseInvoked();\n+\t\t_query.removeAggregateListener(listener);\n+\t\treturn this;\n+\t}\n+\n+\tpublic Collection getCandidateCollection() {\n+\t\treturn _query.getCandidateCollection();\n+\t}\n+\n+\tpublic OpenJPAQuery setCandidateCollection(Collection coll) {\n+\t\t_em.assertNotCloseInvoked();\n+\t\t_query.setCandidateCollection(coll);\n+\t\treturn this;\n+\t}\n+\n+\tpublic Class getResultClass() {\n+\t\tClass res = _query.getResultType();\n+\t\tif (res != null)\n+\t\t\treturn res;\n+\t\treturn _query.getCandidateType();\n+\t}\n+\n+\tpublic OpenJPAQuery setResultClass(Class cls) {\n+\t\t_em.assertNotCloseInvoked();\n+\t\tif (ImplHelper.isManagedType(_em.getConfiguration(), cls))\n+\t\t\t_query.setCandidateType(cls, true);\n+\t\telse\n+\t\t\t_query.setResultType(cls);\n+\t\treturn this;\n+\t}\n+\n+\tpublic boolean hasSubclasses() {\n+\t\treturn _query.hasSubclasses();\n+\t}\n+\n+\tpublic OpenJPAQuery setSubclasses(boolean subs) {\n+\t\t_em.assertNotCloseInvoked();\n+\t\tClass cls = _query.getCandidateType();\n+\t\t_query.setCandidateExtent(_query.getBroker().newExtent(cls, subs));\n+\t\treturn this;\n+\t}\n+\n+\tpublic int getFirstResult() {\n+\t\treturn asInt(_query.getStartRange());\n+\t}\n+\n+\tpublic OpenJPAQuery setFirstResult(int startPosition) {\n+\t\t_em.assertNotCloseInvoked();\n+\t\tlong end;\n+\t\tif (_query.getEndRange() == Long.MAX_VALUE)\n+\t\t\tend = Long.MAX_VALUE;\n+\t\telse\n+\t\t\tend = startPosition\n+\t\t\t\t\t+ (_query.getEndRange() - _query.getStartRange());\n+\t\t_query.setRange(startPosition, end);\n+\t\treturn this;\n+\t}\n+\n+\tpublic int getMaxResults() {\n+\t\treturn asInt(_query.getEndRange() - _query.getStartRange());\n+\t}\n+\n+\tpublic OpenJPAQuery setMaxResults(int max) {\n+\t\t_em.assertNotCloseInvoked();\n+\t\tlong start = _query.getStartRange();\n+\t\tif (max == Integer.MAX_VALUE)\n+\t\t\t_query.setRange(start, Long.MAX_VALUE);\n+\t\telse\n+\t\t\t_query.setRange(start, start + max);\n+\t\treturn this;\n+\t}\n+\n+\tpublic OpenJPAQuery compile() {\n+\t\t_em.assertNotCloseInvoked();\n+\t\t_query.compile();\n+\t\treturn this;\n+\t}\n+\n+\tprivate Object execute() {\n+\t\tif (_query.getOperation() != QueryOperations.OP_SELECT)\n+\t\t\tthrow new InvalidStateException(_loc.get(\"not-select-query\", _query\n+\t\t\t\t\t.getQueryString()), null, null, false);\n+\n+\t\tvalidateParameters();\n+\n+\t\t// handle which types of parameters we are using, if any\n+\t\tif (_positional != null)\n+\t\t\treturn _query.execute(_positional);\n+\t\tif (_named != null)\n+\t\t\treturn _query.execute(_named);\n+\t\treturn _query.execute();\n+\t}\n+\t\n+\t/**\n+\t * Validate that the types of the parameters are correct.\n+\t * The idea is to catch as many validation error as possible at the facade\n+\t * layer itself.\n+\t * \n+\t * The expected parameters are parsed from the query and in a LinkedMap \n+\t *\tkey   : name of the parameter as declared in query\n+\t *  value : expected Class of allowed value\n+\t *  \n+\t * The bound parameters depends on positional or named parameter style\n+\t * \n+\t * TreeMap<Integer, Object> for positional parameters:\n+\t *   key   : 1-based Integer index\n+\t *   value : bound value. GAP_FILLER if the position is not set. This\n+\t *   simplifies validation at the kernel layer\n+\t *   \n+\t * Map<String, Object> for named parameters:\n+\t *   key   : parameter name\n+\t *   value : the bound value\n+\t *   \n+\t *  Validation accounts for \n+\t *    a) gaps in positional parameters\n+\t *       SELECT p FROM PObject p WHERE p.a1=?1 AND p.a3=?3\n+\t *    \n+\t *    b) repeated parameters\n+\t *       SELECT p FROM PObject p WHERE p.a1=?1 AND p.a2=?1 AND p.a3=?2\n+\t *       \n+\t *    c) parameter is bound but not declared\n+\t *    \n+\t *    d) parameter is declared but not bound\n+\t *    \n+\t *    e) parameter does not match the value type\n+\t *    \n+\t *    f) parameter is primitive type but bound to null value\n+\t */\n+\tprivate void validateParameters() {\n+\t\tString query = getQueryString();\n+\t\tif (_positional != null) {\n+\t\t\tLinkedMap expected = _query.getParameterTypes();\n+\t\t\tMap<Integer, Object> actual = _positional;\n+\t\t\tfor (Object o : expected.keySet()) {\n+\t\t\t\tString position = (String) o;\n+\t\t\t\tClass expectedParamType = (Class) expected.get(position);\n+\t\t\t\ttry {\n+\t\t\t\t\tInteger.parseInt(position);\n+\t\t\t\t} catch (NumberFormatException ex) {\n+\t\t\t\t\tnewValidationException(\"param-style-mismatch\", query,\n+\t\t\t\t\t\t\texpected.asList(),\n+\t\t\t\t\t\t\tArrays.toString(actual.keySet().toArray()));\n+\t\t\t\t}\n+\t\t\t\tObject actualValue = actual.get(Integer.parseInt(position));\n+\t\t\t\tboolean valueUnspecified = (actualValue == GAP_FILLER)\n+\t\t\t\t\t\t|| (actualValue == null && (actual.size() < expected\n+\t\t\t\t\t\t\t\t.size()));\n+\t\t\t\tif (valueUnspecified) \n+\t\t\t\t\tnewValidationException(\"param-missing\", position, query,\n+\t\t\t\t\t\t\tArrays.toString(actual.keySet().toArray()));\n+\t\t\t\t\n+\t\t\t\tif (expectedParamType.isPrimitive() && actualValue == null)\n+\t\t\t\t\tnewValidationException(\"param-type-null\", \n+\t\t\t\t\t\t\tposition, query, expectedParamType.getName());\n+\t\t\t\tif (actualValue == null)\n+\t\t\t\t\tcontinue;\n+\t\t\t\tif (!Filters.wrap(expectedParamType).isInstance(actualValue)) \n+\t\t\t\t\tnewValidationException(\"param-type-mismatch\",\n+\t\t\t\t\t\t\tposition, query, actualValue,\n+\t\t\t\t\t\t\tactualValue.getClass().getName(),\n+\t\t\t\t\t\t\texpectedParamType.getName());\n+\t\t\t\t\n+\t\t\t}\n+\t\t\tfor (Integer position : actual.keySet()) {\n+\t\t\t\tObject actualValue = actual.get(position);\n+\t\t\t\tClass expectedParamType = (Class) expected.get(\"\" + position);\n+\t\t\t\tboolean paramExpected = expected.containsKey(\"\" + position);\n+\t\t\t\tif (actualValue == GAP_FILLER) {\n+\t\t\t\t\tif (paramExpected) {\n+\t\t\t\t\t\tnewValidationException(\"param-missing\", position, query,\n+\t\t\t\t\t\t\t\tArrays.toString(actual.keySet().toArray()));\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tif (!paramExpected)\n+\t\t\t\t\t\tnewValidationException(\"param-extra\", position, query,\n+\t\t\t\t\t\t\t\texpected.asList());\n+\t\t\t\t\tif (expectedParamType.isPrimitive() && actualValue == null)\n+\t\t\t\t\t\tnewValidationException(\"param-type-null\", \n+\t\t\t\t\t\t\t\tposition, query, expectedParamType.getName());\n+\t\t\t\t\tif (!Filters.wrap(expectedParamType)\n+\t\t\t\t\t\t\t.isInstance(actualValue)) \n+\t\t\t\t\t\tnewValidationException(\"param-type-mismatch\",\n+\t\t\t\t\t\t\t\tposition, query, actualValue,\n+\t\t\t\t\t\t\t\tactualValue.getClass().getName(),\n+\t\t\t\t\t\t\t\texpectedParamType.getName());\n+\t\t\t\t\t\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t} else if (_named != null) {\n+\t\t\tLinkedMap expected = _query.getParameterTypes();\n+\t\t\t// key : name of the parameter used while binding\n+\t\t\t// value : user supplied parameter value. null may mean either\n+\t\t\t// user has supplied a value or not specified at all\n+\t\t\tMap<String, Object> actual = _named;\n+\t\t\tfor (Object o : expected.keySet()) {\n+\t\t\t\tString expectedName = (String) o;\n+\t\t\t\tClass expectedParamType = (Class) expected.get(expectedName);\n+\t\t\t\tObject actualValue = actual.get(expectedName);\n+\t\t\t\tboolean valueUnspecified = !actual.containsKey(expectedName);\n+\t\t\t\tif (valueUnspecified) {\n+\t\t\t\t\tnewValidationException(\"param-missing\", expectedName, query,\n+\t\t\t\t\t\t\tArrays.toString(actual.keySet().toArray()));\n+\t\t\t\t}\n+\t\t\t\tif (expectedParamType.isPrimitive() && actualValue == null)\n+\t\t\t\t\tnewValidationException(\"param-type-null\", \n+\t\t\t\t\t\t\texpectedName, query, expectedParamType.getName());\n+\t\t\t\tif (actualValue == null)\n+\t\t\t\t\tcontinue;\n+\t\t\t\tif (!Filters.wrap(expectedParamType).isInstance(actualValue)) {\n+\t\t\t\t\tnewValidationException(\"param-type-mismatch\",\n+\t\t\t\t\t\t\texpectedName, query, actualValue,\n+\t\t\t\t\t\t\tactualValue.getClass().getName(),\n+\t\t\t\t\t\t\texpectedParamType.getName());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfor (String actualName : actual.keySet()) {\n+\t\t\t\tObject actualValue = actual.get(actualName);\n+\t\t\t\tClass expectedParamType = (Class) expected.get(actualName);\n+\t\t\t\tboolean paramExpected = expected.containsKey(actualName);\n+\t\t\t\tif (!paramExpected) {\n+\t\t\t\t\tnewValidationException(\"param-extra\", actualName, query,\n+\t\t\t\t\t\t\texpected.asList());\n+\t\t\t\t}\n+\t\t\t\tif (expectedParamType.isPrimitive() && actualValue == null)\n+\t\t\t\t\tnewValidationException(\"param-type-null\", \n+\t\t\t\t\t\t\tactualName, query, expectedParamType.getName());\n+\t\t\t\tif (!Filters.wrap(expectedParamType).isInstance(actualValue)) {\n+\t\t\t\t\tnewValidationException(\"param-type-mismatch\",\n+\t\t\t\t\t\t\tactualName, query, actualValue,\n+\t\t\t\t\t\t\tactualValue.getClass().getName(),\n+\t\t\t\t\t\t\texpectedParamType.getName());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tvoid newValidationException(String msgKey, Object...args) {\n+\t\tthrow new ArgumentException(_loc.get(msgKey, args), null, null, false);\n+\t}\n+\n+\tpublic List getResultList() {\n+\t\t_em.assertNotCloseInvoked();\n+\t\tObject ob = execute();\n+\t\tif (ob instanceof List) {\n+\t\t\tList ret = (List) ob;\n+\t\t\tif (ret instanceof ResultList)\n+\t\t\t\treturn new DelegatingResultList((ResultList) ret,\n+\t\t\t\t\t\tPersistenceExceptions.getRollbackTranslator(_em));\n+\t\t\telse\n+\t\t\t\treturn ret;\n+\t\t}\n+\n+\t\treturn Collections.singletonList(ob);\n+\t}\n+\n+\t/**\n+\t * Execute a query that returns a single result.\n+\t */\n+\tpublic Object getSingleResult() {\n+\t\t_em.assertNotCloseInvoked();\n+\t\t// temporarily set query to unique so that a single result is validated\n+\t\t// and returned; unset again in case the user executes query again\n+\t\t// via getResultList\n+\t\t_query.setUnique(true);\n+\t\ttry {\n+\t\t\treturn execute();\n+\t\t} finally {\n+\t\t\t_query.setUnique(false);\n+\t\t}\n+\t}\n+\n+\tpublic int executeUpdate() {\n+\t\t_em.assertNotCloseInvoked();\n+\t\tif (_query.getOperation() == QueryOperations.OP_DELETE) {\n+\t\t\t// handle which types of parameters we are using, if any\n+\t\t\tif (_positional != null)\n+\t\t\t\treturn asInt(_query.deleteAll(_positional));\n+\t\t\tif (_named != null)\n+\t\t\t\treturn asInt(_query.deleteAll(_named));\n+\t\t\treturn asInt(_query.deleteAll());\n+\t\t}\n+\t\tif (_query.getOperation() == QueryOperations.OP_UPDATE) {\n+\t\t\t// handle which types of parameters we are using, if any\n+\t\t\tif (_positional != null)\n+\t\t\t\treturn asInt(_query.updateAll(_positional));\n+\t\t\tif (_named != null)\n+\t\t\t\treturn asInt(_query.updateAll(_named));\n+\t\t\treturn asInt(_query.updateAll());\n+\t\t}\n+\t\tthrow new InvalidStateException(_loc.get(\"not-update-delete-query\",\n+\t\t\t\t_query.getQueryString()), null, null, false);\n+\t}\n+\n+\t/**\n+\t * Cast the specified long down to an int, first checking for overflow.\n+\t */\n+\tprivate static int asInt(long l) {\n+\t\tif (l > Integer.MAX_VALUE)\n+\t\t\treturn Integer.MAX_VALUE;\n+\t\tif (l < Integer.MIN_VALUE) // unlikely, but we might as well check\n+\t\t\treturn Integer.MIN_VALUE;\n+\t\treturn (int) l;\n+\t}\n+\n+\tpublic FlushModeType getFlushMode() {\n+\t\treturn EntityManagerImpl.fromFlushBeforeQueries(_query\n+\t\t\t\t.getFetchConfiguration().getFlushBeforeQueries());\n+\t}\n+\n+\tpublic OpenJPAQuery setFlushMode(FlushModeType flushMode) {\n+\t\t_em.assertNotCloseInvoked();\n+\t\t_query.getFetchConfiguration().setFlushBeforeQueries(\n+\t\t\t\tEntityManagerImpl.toFlushBeforeQueries(flushMode));\n+\t\treturn this;\n+\t}\n+\n+\tpublic OpenJPAQuery setHint(String key, Object value) {\n+\t\t_em.assertNotCloseInvoked();\n+\t\tif (key == null || !key.startsWith(\"openjpa.\"))\n+\t\t\treturn this;\n+\t\tString k = key.substring(\"openjpa.\".length());\n+\n+\t\ttry {\n+\t\t\tif (\"Subclasses\".equals(k)) {\n+\t\t\t\tif (value instanceof String)\n+\t\t\t\t\tvalue = Boolean.valueOf((String) value);\n+\t\t\t\tsetSubclasses(((Boolean) value).booleanValue());\n+\t\t\t} else if (\"FilterListener\".equals(k))\n+\t\t\t\taddFilterListener(Filters.hintToFilterListener(value, _query\n+\t\t\t\t\t\t.getBroker().getClassLoader()));\n+\t\t\telse if (\"FilterListeners\".equals(k)) {\n+\t\t\t\tFilterListener[] arr = Filters.hintToFilterListeners(value,\n+\t\t\t\t\t\t_query.getBroker().getClassLoader());\n+\t\t\t\tfor (int i = 0; i < arr.length; i++)\n+\t\t\t\t\taddFilterListener(arr[i]);\n+\t\t\t} else if (\"AggregateListener\".equals(k))\n+\t\t\t\taddAggregateListener(Filters.hintToAggregateListener(value,\n+\t\t\t\t\t\t_query.getBroker().getClassLoader()));\n+\t\t\telse if (\"FilterListeners\".equals(k)) {\n+\t\t\t\tAggregateListener[] arr = Filters.hintToAggregateListeners(\n+\t\t\t\t\t\tvalue, _query.getBroker().getClassLoader());\n+\t\t\t\tfor (int i = 0; i < arr.length; i++)\n+\t\t\t\t\taddAggregateListener(arr[i]);\n+\t\t\t} else if (k.startsWith(\"FetchPlan.\")) {\n+\t\t\t\tk = k.substring(\"FetchPlan.\".length());\n+\t\t\t\thintToSetter(getFetchPlan(), k, value);\n+\t\t\t} else if (k.startsWith(\"hint.\")) {\n+\t\t\t\tif (\"hint.OptimizeResultCount\".equals(k)) {\n+\t\t\t\t\tif (value instanceof String) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tvalue = new Integer((String) value);\n+\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (!(value instanceof Number)\n+\t\t\t\t\t\t\t|| ((Number) value).intValue() < 0)\n+\t\t\t\t\t\tthrow new ArgumentException(_loc.get(\n+\t\t\t\t\t\t\t\t\"bad-query-hint-value\", key, value), null,\n+\t\t\t\t\t\t\t\tnull, false);\n+\t\t\t\t}\n+\t\t\t\t_query.getFetchConfiguration().setHint(key, value);\n+\t\t\t} else\n+\t\t\t\tthrow new ArgumentException(_loc.get(\"bad-query-hint\", key),\n+\t\t\t\t\t\tnull, null, false);\n+\t\t\treturn this;\n+\t\t} catch (Exception e) {\n+\t\t\tthrow PersistenceExceptions.toPersistenceException(e);\n+\t\t}\n+\t}\n+\n+\tprivate void hintToSetter(FetchPlan fetchPlan, String k, Object value) {\n+\t\tif (fetchPlan == null || k == null)\n+\t\t\treturn;\n+\n+\t\tMethod setter = Reflection.findSetter(fetchPlan.getClass(), k, true);\n+\t\tClass paramType = setter.getParameterTypes()[0];\n+\t\tif (Enum.class.isAssignableFrom(paramType) && value instanceof String)\n+\t\t\tvalue = Enum.valueOf(paramType, (String) value);\n+\n+\t\tFilters.hintToSetter(fetchPlan, k, value);\n+\t}\n+\n+\tpublic OpenJPAQuery setParameter(int position, Calendar value,\n+\t\t\tTemporalType t) {\n+\t\treturn setParameter(position, convertTemporalType(value, t));\n+\t}\n+\n+\tpublic OpenJPAQuery setParameter(int position, Date value, TemporalType type) {\n+\t\treturn setParameter(position, convertTemporalType(value, type));\n+\t}\n+\n+\t/**\n+\t * Converts the given Date to a value corresponding to given temporal type.\n+\t */\n+\n+\tObject convertTemporalType(Date value, TemporalType type) {\n+\t\tswitch (type) {\n+\t\tcase DATE:\n+\t\t\treturn value;\n+\t\tcase TIME:\n+\t\t\treturn new Time(value.getTime());\n+\t\tcase TIMESTAMP:\n+\t\t\treturn new Timestamp(value.getTime());\n+\t\tdefault:\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tObject convertTemporalType(Calendar value, TemporalType type) {\n+\t\treturn convertTemporalType(value.getTime(), type);\n+\t}\n+\n+\tpublic OpenJPAQuery setParameter(int position, Object value) {\n+\t\t_query.assertOpen();\n+\t\t_em.assertNotCloseInvoked();\n+\t\t_query.lock();\n+\t\ttry {\n+\t\t\tif (isNative() && position < 1) {\n+\t\t\t\tthrow new IllegalArgumentException(_loc.get(\"bad-pos-params\",\n+\t\t\t\t\t\tposition, _query.getQueryString()).toString());\n+\t\t\t}\n+\t\t\t// not allowed to mix positional and named parameters (EDR2 3.6.4)\n+\t\t\tif (_named != null)\n+\t\t\t\tthrow new InvalidStateException(_loc.get(\n+\t\t\t\t\t\t\"no-pos-named-params-mix\", _query.getQueryString()),\n+\t\t\t\t\t\tnull, null, false);\n+\n+\t\t\tif (position < 1)\n+\t\t\t\tthrow new InvalidStateException(_loc.get(\"illegal-index\",\n+\t\t\t\t\t\tposition), null, null, false);\n+\n+\t\t\tif (_positional == null)\n+\t\t\t\t_positional = new TreeMap<Integer, Object>();\n+\n+\t\t\t_positional.put(position, value);\n+\t\t\tfor (int i = 1; i < position; i++)\n+\t\t\t\tif (!_positional.containsKey(i))\n+\t\t\t\t\t_positional.put(i, GAP_FILLER);\n+\n+\t\t\treturn this;\n+\t\t} finally {\n+\t\t\t_query.unlock();\n+\t\t}\n+\t}\n+\n+\tpublic OpenJPAQuery setParameter(String name, Calendar value,\n+\t\t\tTemporalType type) {\n+\t\treturn setParameter(name, convertTemporalType(value, type));\n+\t}\n+\n+\tpublic OpenJPAQuery setParameter(String name, Date value, TemporalType type) {\n+\t\treturn setParameter(name, convertTemporalType(value, type));\n+\t}\n+\n+\tpublic OpenJPAQuery setParameter(String name, Object value) {\n+\t\t_query.assertOpen();\n+\t\t_em.assertNotCloseInvoked();\n+\t\t_query.lock();\n+\t\ttry {\n+\t\t\tif (isNative()) {\n+\t\t\t\tthrow new IllegalArgumentException(_loc.get(\"no-named-params\",\n+\t\t\t\t\t\tname, _query.getQueryString()).toString());\n+\t\t\t}\n+\t\t\t// not allowed to mix positional and named parameters (EDR2 3.6.4)\n+\t\t\tif (_positional != null)\n+\t\t\t\tthrow new InvalidStateException(_loc.get(\n+\t\t\t\t\t\t\"no-pos-named-params-mix\", _query.getQueryString()),\n+\t\t\t\t\t\tnull, null, false);\n+\n+\t\t\tif (_named == null)\n+\t\t\t\t_named = new HashMap();\n+\t\t\t_named.put(name, value);\n+\t\t\treturn this;\n+\t\t} finally {\n+\t\t\t_query.unlock();\n+\t\t}\n+\t}\n+\n+\tpublic boolean isNative() {\n+\t\treturn QueryLanguages.LANG_SQL.equals(getLanguage());\n+\t}\n+\n+\tpublic boolean hasPositionalParameters() {\n+\t\treturn _positional != null;\n+\t}\n+\n+\t/**\n+\t * Gets the array of positional parameter values. A value of\n+\t * <code>GAP_FILLER</code> indicates that user has not set the\n+\t * corresponding positional parameter. A value of null implies that user has\n+\t * set the value as null.\n+\t */\n+\tpublic Object[] getPositionalParameters() {\n+\t\t_query.lock();\n+\t\ttry {\n+\t\t\treturn (_positional == null) ? EMPTY_ARRAY : _positional.values()\n+\t\t\t\t\t.toArray();\n+\t\t} finally {\n+\t\t\t_query.unlock();\n+\t\t}\n+\t}\n+\n+\tpublic OpenJPAQuery setParameters(Object... params) {\n+\t\t_query.assertOpen();\n+\t\t_em.assertNotCloseInvoked();\n+\t\t_query.lock();\n+\t\ttry {\n+\t\t\t_positional = null;\n+\t\t\t_named = null;\n+\t\t\tif (params != null)\n+\t\t\t\tfor (int i = 0; i < params.length; i++)\n+\t\t\t\t\tsetParameter(i + 1, params[i]);\n+\t\t\treturn this;\n+\t\t} finally {\n+\t\t\t_query.unlock();\n+\t\t}\n+\t}\n+\n+\tpublic Map getNamedParameters() {\n+\t\t_query.lock();\n+\t\ttry {\n+\t\t\treturn (_named == null) ? Collections.EMPTY_MAP : Collections\n+\t\t\t\t\t.unmodifiableMap(_named);\n+\t\t} finally {\n+\t\t\t_query.unlock();\n+\t\t}\n+\t}\n+\n+\tpublic OpenJPAQuery setParameters(Map params) {\n+\t\t_query.assertOpen();\n+\t\t_em.assertNotCloseInvoked();\n+\t\t_query.lock();\n+\t\ttry {\n+\t\t\t_positional = null;\n+\t\t\t_named = null;\n+\t\t\tif (params != null)\n+\t\t\t\tfor (Map.Entry e : (Set<Map.Entry>) params.entrySet())\n+\t\t\t\t\tsetParameter((String) e.getKey(), e.getValue());\n+\t\t\treturn this;\n+\t\t} finally {\n+\t\t\t_query.unlock();\n+\t\t}\n+\t}\n+\n+\tpublic OpenJPAQuery closeAll() {\n+\t\t_query.closeAll();\n+\t\treturn this;\n+\t}\n+\n+\tpublic String[] getDataStoreActions(Map params) {\n+\t\treturn _query.getDataStoreActions(params);\n+\t}\n+\n+\tpublic int hashCode() {\n+\t\treturn _query.hashCode();\n+\t}\n+\n+\tpublic boolean equals(Object other) {\n+\t\tif (other == this)\n+\t\t\treturn true;\n+\t\tif (!(other instanceof QueryImpl))\n+\t\t\treturn false;\n+\t\treturn _query.equals(((QueryImpl) other)._query);\n \t}\n }"},{"sha":"9ab0ffb5e2094095d190b849bdcd538fe152f401","filename":"openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties","status":"modified","additions":15,"deletions":3,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/45651cee86e2b0fd09d9ba131c25b5f668c0412d/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties?ref=45651cee86e2b0fd09d9ba131c25b5f668c0412d","patch":"@@ -102,8 +102,10 @@ no-named-params: Named parameter \"{0}\" is invalid for native query \"{1}\". \\\n \tUse only 1-based positional parameter in native queries.\n bad-pos-params: Positional parameter \"{0}\"  is invalid for native query \"{1}\". \\\n \tUse only 1-based positional parameter in native queries.\n-bad-param-type: The parameter \"{0}\" is of type \"{1}\", but the \\\n-\tdeclaration in the query is for type \"{2}\". \n+bad-param-type: The parameter \"{1}\" in query \"{0}\" is set to a value of type \\\n+\t\"{2}\", but the parameter binds to a field of type \"{3}\". \n+missing-param-name: The parameter \"{1}\" in query \"{0}\" is not found in the \\\n+\tavailable list of parameters \"{2}\".\n bad-em-prop: Invalid EntityManager property passed to createEntityManager. \\\n \tKey: \"{0}\", Value: \"{1}\".\n bad-em-props: Invalid EntityManager properties passed to createEntityManager. \\\n@@ -148,4 +150,14 @@ EntityManagerFactory-cat: Persistence.Advanced\n EntityManagerFactory-displayorder: 50\n EntityManagerFactory-expert: true\n EntityManagerFactory-interface: org.apache.openjpa.persistence.EntityManagerFactoryImpl\n-\n+param-style-mismatch: Query \"{0}\" is declared with named parameters \"{1}\" but \\\n+\tactual parameters \"{2}\" are bound by position.\n+param-missing: Parameter \"{0}\" declared in \"{1}\" but is missing from the bound \\\n+\tparameters \"{2}\".\n+param-extra: Parameter \"{0}\" is bound to \"{1}\" but is missing from the \\\n+\tdeclared parameters \"{2}\".\n+param-type-mismatch: Parameter \"{0}\" declared in \"{1}\" is set to value of \\\n+\t\"{2}\" of type \"{3}\", but this parameter is bound to a field of type \"{4}\".\n+param-type-mismatch: Parameter \"{0}\" declared in \"{1}\" is set to null, \\\n+\tbut this parameter is bound to a field of primitive type \"{2}\".\n+\t\n\\ No newline at end of file"}]}

