{"sha":"45693d4e7ac426b9ea68565e7a04413a2c6d551d","node_id":"MDY6Q29tbWl0MjA2MzY0OjQ1NjkzZDRlN2FjNDI2YjllYTY4NTY1ZTdhMDQ0MTNhMmM2ZDU1MWQ=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-05-27T22:45:01Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-05-27T22:45:01Z"},"message":"OPENJPA-610: refresh() hits database irrespective of clean/dirty state or current lock mode or active/inactive DataCache\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@660753 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"82870b335692efaea8045826a4b69460a394b561","url":"https://api.github.com/repos/apache/openjpa/git/trees/82870b335692efaea8045826a4b69460a394b561"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/45693d4e7ac426b9ea68565e7a04413a2c6d551d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/45693d4e7ac426b9ea68565e7a04413a2c6d551d","html_url":"https://github.com/apache/openjpa/commit/45693d4e7ac426b9ea68565e7a04413a2c6d551d","comments_url":"https://api.github.com/repos/apache/openjpa/commits/45693d4e7ac426b9ea68565e7a04413a2c6d551d/comments","author":null,"committer":null,"parents":[{"sha":"8f97a2aea35130f6eea10fc12d210e5c6985a7e2","url":"https://api.github.com/repos/apache/openjpa/commits/8f97a2aea35130f6eea10fc12d210e5c6985a7e2","html_url":"https://github.com/apache/openjpa/commit/8f97a2aea35130f6eea10fc12d210e5c6985a7e2"}],"stats":{"total":134,"additions":59,"deletions":75},"files":[{"sha":"f71add0652247ff48af92083426b0de0fbf0fe4f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/45693d4e7ac426b9ea68565e7a04413a2c6d551d/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/45693d4e7ac426b9ea68565e7a04413a2c6d551d/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java?ref=45693d4e7ac426b9ea68565e7a04413a2c6d551d","patch":"@@ -423,7 +423,7 @@ public boolean load(OpenJPAStateManager sm, BitSet fields,\n \n     public Collection loadAll(Collection sms, PCState state, int load,\n     \t\tFetchConfiguration fetch, Object edata) {\n-        if (isLocking(fetch))\n+        if (load == StoreManager.FORCE_LOAD_REFRESH || isLocking(fetch))\n             return super.loadAll(sms, state, load, fetch, edata);\n \n         Map unloaded = null;"},{"sha":"f99ab242349a5194b216eb5be7c567fdaab6b387","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":12,"deletions":50,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/45693d4e7ac426b9ea68565e7a04413a2c6d551d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/45693d4e7ac426b9ea68565e7a04413a2c6d551d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=45693d4e7ac426b9ea68565e7a04413a2c6d551d","patch":"@@ -2720,21 +2720,17 @@ OpenJPAStateManager copy(OpenJPAStateManager copy, PCState state) {\n     }\r\n \r\n     public void refreshAll(Collection objs, OpCallbacks call) {\r\n-        if (objs.isEmpty())\r\n+        if (objs == null || objs.isEmpty())\r\n             return;\r\n \r\n         beginOperation(true);\r\n         try {\r\n             assertNontransactionalRead();\r\n \r\n-            for (Iterator itr = objs.iterator(); itr.hasNext();)\r\n+            for (Iterator itr = objs.iterator(); itr.hasNext();) {\r\n                 gatherCascadeRefresh(itr.next(), call);\r\n-            if (_operating.isEmpty())\r\n-                return;\r\n-            if (_operating.size() == 1)\r\n-                refreshInternal(_operating.iterator().next(), call);\r\n-            else\r\n-                refreshInternal(_operating, call);\r\n+            }\r\n+            refreshInternal(_operating, call);\r\n         } finally {\r\n             endOperation();\r\n         }\r\n@@ -2749,12 +2745,7 @@ public void refresh(Object obj, OpCallbacks call) {\n             assertNontransactionalRead();\r\n \r\n             gatherCascadeRefresh(obj, call);\r\n-            if (_operating.isEmpty())\r\n-                return;\r\n-            if (_operating.size() == 1)\r\n-                refreshInternal(_operating.iterator().next(), call);\r\n-            else\r\n-                refreshInternal(_operating, call);\r\n+            refreshInternal(_operating, call);\r\n         } finally {\r\n             endOperation();\r\n         }\r\n@@ -2786,10 +2777,12 @@ void gatherCascadeRefresh(Object obj, OpCallbacks call) {\n      * cascade-refresh relations from the user-given instances.\r\n      */\r\n     protected void refreshInternal(Collection objs, OpCallbacks call) {\r\n+    \tif (objs == null || objs.isEmpty())\r\n+    \t\treturn;\r\n         List exceps = null;\r\n         try {\r\n             // collect instances that need a refresh\r\n-            Collection load = null;\r\n+            Collection load = new ArrayList(objs.size());\r\n             StateManagerImpl sm;\r\n             Object obj;\r\n             for (Iterator itr = objs.iterator(); itr.hasNext();) {\r\n@@ -2804,11 +2797,9 @@ protected void refreshInternal(Collection objs, OpCallbacks call) {\n                         continue;\r\n \r\n                     if (sm != null) {\r\n-                        if (sm.isDetached())\r\n+                        if (sm.isDetached()) {\r\n                             throw newDetachedException(obj, \"refresh\");\r\n-                        else if (sm.beforeRefresh(true)) {\r\n-                            if (load == null)\r\n-                                load = new ArrayList(objs.size());\r\n+                        } else if (sm.beforeRefresh(true)) {\r\n                             load.add(sm);\r\n                         }\r\n                     } else if (assertPersistenceCapable(obj).pcIsDetached()\r\n@@ -2820,7 +2811,7 @@ else if (sm.beforeRefresh(true)) {\n             }\r\n \r\n             // refresh all\r\n-            if (load != null) {\r\n+            if (!load.isEmpty()) {\r\n                 Collection failed = _store.loadAll(load, null,\r\n                     StoreManager.FORCE_LOAD_REFRESH, _fc, null);\r\n                 if (failed != null && !failed.isEmpty())\r\n@@ -2862,38 +2853,9 @@ else if (sm.beforeRefresh(true)) {\n         throwNestedExceptions(exceps, false);\r\n     }\r\n \r\n-    /**\r\n-     * Optimization for single-object refresh.\r\n-     */\r\n-    protected void refreshInternal(Object obj, OpCallbacks call) {\r\n-        try {\r\n-            StateManagerImpl sm = getStateManagerImpl(obj, true);\r\n-            if ((processArgument(OpCallbacks.OP_REFRESH, obj, sm, call)\r\n-                & OpCallbacks.ACT_RUN) == 0)\r\n-                return;\r\n-\r\n-            if (sm != null) {\r\n-                if (sm.isDetached())\r\n-                    throw newDetachedException(obj, \"refresh\");\r\n-                else if (sm.beforeRefresh(false)) {\r\n-                    sm.load(_fc, StateManagerImpl.LOAD_FGS, null, null, false);\r\n-                    sm.afterRefresh();\r\n-                }\r\n-                fireLifecycleEvent(sm.getManagedInstance(), null,\r\n-                    sm.getMetaData(), LifecycleEvent.AFTER_REFRESH);\r\n-            } else if (assertPersistenceCapable(obj).pcIsDetached()\r\n-                == Boolean.TRUE)\r\n-                throw newDetachedException(obj, \"refresh\");\r\n-        } catch (OpenJPAException ke) {\r\n-            throw ke;\r\n-        } catch (RuntimeException re) {\r\n-            throw new GeneralException(re);\r\n-        }\r\n-    }\r\n-\r\n     public void retrieveAll(Collection objs, boolean dfgOnly,\r\n         OpCallbacks call) {\r\n-        if (objs.isEmpty())\r\n+        if (objs == null || objs.isEmpty())\r\n             return;\r\n         if (objs.size() == 1) {\r\n             retrieve(objs.iterator().next(), dfgOnly, call);\r"},{"sha":"ac530366d27f5e0c4578711fe5a25822e544248b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheBehavesIdentical.java","status":"modified","additions":46,"deletions":24,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/45693d4e7ac426b9ea68565e7a04413a2c6d551d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheBehavesIdentical.java","raw_url":"https://github.com/apache/openjpa/raw/45693d4e7ac426b9ea68565e7a04413a2c6d551d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheBehavesIdentical.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheBehavesIdentical.java?ref=45693d4e7ac426b9ea68565e7a04413a2c6d551d","patch":"@@ -265,9 +265,28 @@ public void testInconsitentBidirectionalRelationIsNotPreservedWithoutDataCache()\n \t * @param lock lock to be used\r\n \t * @param makeDirtyBeforeRefresh flags if the instance be dirtied before\r\n \t * refresh()\r\n+\t * @param expected The expected marker i.e. where the state is refreshed \r\n+\t * from. This should be always <code>MARKER_DATABASE</code>.\r\n+\t * a) whether DataCache is active\r\n+\t * b) whether current Lock is stronger than NOLOCK\r\n+\t * c) whether the object to be refreshed is dirty\r\n+\t * \r\n+\t * The following truth table enumerates the possibilities\r\n+\t * \r\n+\t * Use Cache?   Lock?   Dirty?     Target\r\n+\t *    Y          Y       Y         Database\r\n+\t *    Y          N       Y         Data Cache\r\n+\t *    Y          Y       N         Data Cache\r\n+\t *    Y          N       N         Data Cache\r\n+\t *    \r\n+\t *    N          Y       Y         Database\r\n+\t *    N          N       Y         Database\r\n+\t *    N          Y       N         Object Cache\r\n+\t *    N          N       N         Object Cache\r\n+\r\n \t */\r\n \tpublic void verifyRefresh(boolean useDataCache, LockModeType lock, \r\n-\t\t\tboolean makeDirtyBeforeRefresh) {\r\n+\t\t\tboolean makeDirtyBeforeRefresh, String expected) {\r\n \t\tOpenJPAEntityManagerFactorySPI emf = (useDataCache)\r\n \t\t\t? emfWithDataCache : emfWithoutDataCache;\r\n \t\t\t\r\n@@ -303,7 +322,6 @@ public void verifyRefresh(boolean useDataCache, LockModeType lock,\n \t\t}\r\n \t\tem.refresh(pc);\r\n \t\t\r\n-\t\tString expected = getExpectedMarker(useDataCache, lock, makeDirtyBeforeRefresh);\r\n \t\tassertEquals(expected, pc.getName());\r\n \t\tem.getTransaction().commit();\r\n \t}\r\n@@ -337,47 +355,48 @@ public void verifyRefresh(boolean useDataCache, LockModeType lock,\n \tString getExpectedMarker(boolean useDataCache, LockModeType lock, \r\n \t\t\tboolean makeDirtyBeforeRefresh) {\r\n \t\tif (useDataCache) {\r\n-\t\t\treturn (lock != null && makeDirtyBeforeRefresh)\r\n-\t\t\t\t? MARKER_DATABASE : MARKER_DATACACHE; \r\n+//\t\t\treturn (lock != null && makeDirtyBeforeRefresh)\r\n+\t\t\treturn (lock != null) ? MARKER_DATABASE : MARKER_DATACACHE; \r\n \t\t} else {\r\n-\t\t\treturn (makeDirtyBeforeRefresh) ? MARKER_DATABASE : MARKER_CACHE;\r\n+//\t\t\treturn (makeDirtyBeforeRefresh) ? MARKER_DATABASE : MARKER_CACHE;\r\n+\t\t\treturn MARKER_DATABASE;\r\n \t\t}\r\n \t}\r\n \t\r\n-\tpublic void testDirtyRefreshWithNoLockHitsDataCache() {\r\n-\t\tverifyRefresh(WITH_DATACACHE, NOLOCK, DIRTY);\r\n+\tpublic void testDirtyRefreshWithNoLockHitsDatabase() {\r\n+\t\tverifyRefresh(WITH_DATACACHE, NOLOCK, DIRTY, MARKER_DATABASE);\r\n \t}\r\n \t\r\n-\tpublic void testCleanRefreshWithNoLockHitsDataCache() {\r\n-\t\tverifyRefresh(WITH_DATACACHE, NOLOCK, !DIRTY);\r\n+\tpublic void testCleanRefreshWithNoLockHitsDatabase() {\r\n+\t\tverifyRefresh(WITH_DATACACHE, NOLOCK, !DIRTY, MARKER_DATABASE);\r\n \t}\r\n \t\r\n \tpublic void testDirtyRefreshWithReadLockHitsDatabase() {\r\n-\t\tverifyRefresh(WITH_DATACACHE, LockModeType.READ, DIRTY);\r\n+\t\tverifyRefresh(WITH_DATACACHE, LockModeType.READ, DIRTY, MARKER_DATABASE);\r\n \t}\r\n \t\r\n-\tpublic void testCleanRefreshWithReadLockHitsDataCache() {\r\n-\t\tverifyRefresh(WITH_DATACACHE, LockModeType.READ, !DIRTY);\r\n+\tpublic void testCleanRefreshWithReadLockHitsDatabase() {\r\n+\t\tverifyRefresh(WITH_DATACACHE, LockModeType.READ, !DIRTY, MARKER_DATABASE);\r\n \t}\r\n \t\r\n \tpublic void testDirtyRefreshWithWriteLockHitsDatabase() {\r\n-\t\tverifyRefresh(WITH_DATACACHE, LockModeType.WRITE, DIRTY);\r\n+\t\tverifyRefresh(WITH_DATACACHE, LockModeType.WRITE, DIRTY, MARKER_DATABASE);\r\n \t}\r\n \t\r\n \tpublic void testCleanRefreshWithWriteLockHitsDatabase() {\r\n-\t\tverifyRefresh(WITH_DATACACHE, LockModeType.WRITE, !DIRTY);\r\n+\t\tverifyRefresh(WITH_DATACACHE, LockModeType.WRITE, !DIRTY, MARKER_DATABASE);\r\n \t}\r\n \t\r\n \tpublic void testDirtyRefreshWithoutDataCacheAlwaysHitsDatabase() {\r\n-\t\tverifyRefresh(!WITH_DATACACHE, NOLOCK, DIRTY);\r\n-\t\tverifyRefresh(!WITH_DATACACHE, LockModeType.READ, DIRTY);\r\n-\t\tverifyRefresh(!WITH_DATACACHE, LockModeType.WRITE, DIRTY);\r\n+\t\tverifyRefresh(!WITH_DATACACHE, NOLOCK, DIRTY, MARKER_DATABASE);\r\n+\t\tverifyRefresh(!WITH_DATACACHE, LockModeType.READ, DIRTY, MARKER_DATABASE);\r\n+\t\tverifyRefresh(!WITH_DATACACHE, LockModeType.WRITE, DIRTY, MARKER_DATABASE);\r\n \t}\r\n \t\r\n-\tpublic void testCleanRefreshWithoutDataCacheNeverHitsDatabase() {\r\n-\t\tverifyRefresh(!WITH_DATACACHE, NOLOCK, !DIRTY);\r\n-\t\tverifyRefresh(!WITH_DATACACHE, LockModeType.READ, !DIRTY);\r\n-\t\tverifyRefresh(!WITH_DATACACHE, LockModeType.WRITE, !DIRTY);\r\n+\tpublic void testCleanRefreshWithoutDataCacheAlwaysHitsDatabase() {\r\n+\t\tverifyRefresh(!WITH_DATACACHE, NOLOCK, !DIRTY, MARKER_DATABASE);\r\n+\t\tverifyRefresh(!WITH_DATACACHE, LockModeType.READ, !DIRTY, MARKER_DATABASE);\r\n+\t\tverifyRefresh(!WITH_DATACACHE, LockModeType.WRITE, !DIRTY, MARKER_DATABASE);\r\n \t}\r\n \t\r\n \t/**\r\n@@ -434,9 +453,12 @@ public void verifyDeleteDetectionOnRefresh(boolean useDataCache,\n \t\t\t} else {\r\n \t\t\t\tfail(\"expected EntityNotFoundException for PObject:\" + oid);\r\n \t\t\t}\r\n-\t\t} catch (EntityNotFoundException ex) {\r\n-\t\t\tif (lock != null) {\r\n-\t\t\t\t// we are good\r\n+\t\t} catch (Exception ex) {\r\n+\t\t\tif (ex instanceof EntityNotFoundException || \r\n+\t\t\t\tex instanceof org.apache.openjpa.persistence.EntityNotFoundException) {\r\n+\t\t\t\tif (lock != null) {\r\n+\t\t\t\t\t// we are good\r\n+\t\t\t\t}\r\n \t\t\t}\r\n \t\t} finally {\r\n \t\t\tem.getTransaction().rollback();\r"}]}

