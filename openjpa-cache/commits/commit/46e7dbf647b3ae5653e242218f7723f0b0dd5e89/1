{"sha":"46e7dbf647b3ae5653e242218f7723f0b0dd5e89","node_id":"MDY6Q29tbWl0MjA2MzY0OjQ2ZTdkYmY2NDdiM2FlNTY1M2UyNDIyMThmNzcyM2YwYjBkZDVlODk=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-06-28T19:46:13Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-06-28T19:46:13Z"},"message":"added some openjpa-lib test, pom files, and serp fork. We may move the changes in serp back into the serp source tree and add a maven layout to serp, but for now, let's just get things rolling here.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@417860 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"14bc407ab7146e852f9c6b12f12020bb69aac643","url":"https://api.github.com/repos/apache/openjpa/git/trees/14bc407ab7146e852f9c6b12f12020bb69aac643"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/46e7dbf647b3ae5653e242218f7723f0b0dd5e89","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/46e7dbf647b3ae5653e242218f7723f0b0dd5e89","html_url":"https://github.com/apache/openjpa/commit/46e7dbf647b3ae5653e242218f7723f0b0dd5e89","comments_url":"https://api.github.com/repos/apache/openjpa/commits/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/comments","author":null,"committer":null,"parents":[{"sha":"b9183699ba5e4eb2335772077f2b0d8918767fb8","url":"https://api.github.com/repos/apache/openjpa/commits/b9183699ba5e4eb2335772077f2b0d8918767fb8","html_url":"https://github.com/apache/openjpa/commit/b9183699ba5e4eb2335772077f2b0d8918767fb8"}],"stats":{"total":27294,"additions":27213,"deletions":81},"files":[{"sha":"57b10968d40dde76373d8873e2b92bf459fbd26d","filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/NoneConfigurationProvider.java","status":"removed","additions":0,"deletions":81,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/b9183699ba5e4eb2335772077f2b0d8918767fb8/openjpa-lib/main/java/org/apache/openjpa/lib/conf/NoneConfigurationProvider.java","raw_url":"https://github.com/apache/openjpa/raw/b9183699ba5e4eb2335772077f2b0d8918767fb8/openjpa-lib/main/java/org/apache/openjpa/lib/conf/NoneConfigurationProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/main/java/org/apache/openjpa/lib/conf/NoneConfigurationProvider.java?ref=b9183699ba5e4eb2335772077f2b0d8918767fb8","patch":"@@ -1,81 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.openjpa.lib.conf;\n-\n-\n-import java.io.*;\n-import java.util.*;\n-\n-import org.apache.commons.collections.*;\n-\n-\n-/**\n- *\t<p>No-op configuration provider.</p>\n- *\n- *\t@author\t\tAbe White \n- *\t@nojavadoc\n- */\n-public class NoneConfigurationProvider\n-\timplements ConfigurationProvider\n-{\n-\tprivate static final NoneConfigurationProvider _instance = \n-\t\tnew NoneConfigurationProvider ();\n-\n-\n-\t/**\n-\t *\tSingleton.\n-\t */\n-\tpublic static NoneConfigurationProvider getInstance ()\n-\t{\n-\t\treturn _instance;\n-\t}\n-\n-\n-\tpublic boolean loadDefaults (ClassLoader loader)\n-\t{\n-\t\treturn false;\n-\t}\n-\n-\n-\tpublic boolean load (String resource, ClassLoader loader)\n-\t{\n-\t\treturn false;\n-\t}\n-\n-\n-\tpublic boolean load (File file)\n-\t{\n-\t\treturn false;\n-\t}\n-\n-\n-\tpublic Map getProperties ()\n-\t{\n-\t\treturn MapUtils.EMPTY_MAP;\n-\t}\n-\n-\n-\tpublic void addProperties (Map props)\n-\t{\n-\t\tif (props != null && !props.isEmpty ())\n-\t\t\tthrow new UnsupportedOperationException ();\n-\t}\n-\n-\n-\tpublic void setInto (Configuration conf)\n-\t{\n-\t}\n-}"},{"sha":"13bbe1e43c94f4236234f59236a8ce55332272bc","filename":"openjpa-lib/pom.xml","status":"added","additions":113,"deletions":0,"changes":113,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/pom.xml?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,113 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\t\t<modelVersion>4.0.0</modelVersion>\n+\t<groupId>org.apache.openjpa</groupId>\n+\t<artifactId>openjpa-lib</artifactId>\n+\t<packaging>jar</packaging>\n+\n+\t<name>Utilities</name>\n+\t<description>Utilities</description>\n+\t<url>http://incubator.apache.org/projects/openjpa</url>\n+<parent>\n+\t\n+\t\t<groupId>org.apache.openjpa</groupId>\n+\t\t<artifactId>openjpa</artifactId>\n+\t\t<version>0.0.1</version>\n+\t\t\n+\t</parent>\n+\t<dependencies>\n+\t\n+\t\t<dependency>\n+\t\t\n+\t\t\t<groupId>org.apache.openjpa</groupId>\n+\t\t\t<artifactId>serp</artifactId>\n+\t\t\t<version>0.0.1</version>\n+\t\t\t<scope>compile</scope>\n+\t\t\t\n+\t\t</dependency>\n+\t\t<dependency>\n+\t\t\n+\t\t\t<groupId>commons-logging</groupId>\n+\t\t\t<artifactId>commons-logging</artifactId>\n+\t\t\t<version>1.0.4</version>\n+\t\t\t<scope>compile</scope>\n+\t\t\t\n+\t\t</dependency>\n+\t\t<dependency>\n+\t\t\n+\t\t\t<groupId>log4j</groupId>\n+\t\t\t<artifactId>log4j</artifactId>\n+\t\t\t<version>1.2.13</version>\n+\t\t\t<scope>compile</scope>\n+\t\t\t\n+\t\t</dependency>\n+\t\t<dependency>\n+\t\t\n+\t\t\t<groupId>javax.servlet</groupId>\n+\t\t\t<artifactId>servlet-api</artifactId>\n+\t\t\t<version>2.5</version>\n+\t\t\t<scope>compile</scope>\n+\t\t\t\n+\t\t</dependency>\n+\t\t<dependency>\n+\t\t\n+\t\t\t<groupId>commons-lang</groupId>\n+\t\t\t<artifactId>commons-lang</artifactId>\n+\t\t\t<version>2.1</version>\n+\t\t\t<scope>compile</scope>\n+\t\t\t\n+\t\t</dependency>\n+\t\t<dependency>\n+\t\t\n+\t\t\t<groupId>ant</groupId>\n+\t\t\t<artifactId>ant</artifactId>\n+\t\t\t<version>1.6.5</version>\n+\t\t\t<scope>compile</scope>\n+\t\t\t\n+\t\t</dependency>\n+\t\t<dependency>\n+\t\t\n+\t\t\t<groupId>commons-collections</groupId>\n+\t\t\t<artifactId>commons-collections</artifactId>\n+\t\t\t<version>3.1</version>\n+\t\t\t<scope>compile</scope>\n+\t\t\t\n+\t\t</dependency>\n+\t\t<dependency>\n+\t\t\n+\t\t\t<groupId>commons-pool</groupId>\n+\t\t\t<artifactId>commons-pool</artifactId>\n+\t\t\t<version>1.2</version>\n+\t\t\t<scope>compile</scope>\n+\t\t\t\n+\t\t</dependency>\n+\t\t<dependency>\n+\t\t\n+\t\t\t<groupId>backport-util-concurrent</groupId>\n+\t\t\t<artifactId>backport-util-concurrent</artifactId>\n+\t\t\t<version>2.1</version>\n+\t\t\t<scope>compile</scope>\n+\t\t\t\n+\t\t</dependency>\n+\t\t\n+\t</dependencies>\n+\t<build>\n+\t\n+\t\t<plugins>\n+\t\t\n+\t\t\t<plugin>\n+\t\t\t\n+\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n+\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n+\t\t\t\t<configuration>\n+\t\t\t\t<source>1.3</source>\n+\t\t\t\t<target>1.3</target>\n+\t\t\t\t</configuration>\n+\t\t\t\t\n+\t\t\t</plugin>\n+\t\t\t\n+\t\t</plugins>\n+\t\t\n+\t</build>\n+\t\n+\n+</project>"},{"sha":"1d94191a4452a8c77ccb023aec35147d6c9e712e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/AbstractTask.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/AbstractTask.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/AbstractTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/AbstractTask.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/ant/AbstractTask.java"},{"sha":"20ad92b70d2019485db5bdb4711ab89261027cee","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/package.html","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/package.html","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/package.html?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/ant/package.html"},{"sha":"7d8cb54f0e5a41e109fcd50e6e61a8510c08bbd0","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BooleanValue.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BooleanValue.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BooleanValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BooleanValue.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/BooleanValue.java"},{"sha":"63ba1065c81a7eca3351c639531b63123edb0774","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurable.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurable.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurable.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/Configurable.java"},{"sha":"18747f06072221cceac1cba70ac9a02fed3826d2","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/Configuration.java"},{"sha":"531f5076bc32992883e4d3f0dfb8407e1c61f762","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java"},{"sha":"8c6d627ad86ccbf49be77f96cb1b93fbe603990b","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java"},{"sha":"953bd7710ba7e875458d1a8d46100319db5c0ce5","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/Configurations.java"},{"sha":"0d096cbb57094292ead93820f34cd00bb4563804","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/DoubleValue.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/DoubleValue.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/DoubleValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/DoubleValue.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/DoubleValue.java"},{"sha":"975dce4d152b3b60d136502093c623df57486d11","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/FileValue.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/FileValue.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/FileValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/FileValue.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/FileValue.java"},{"sha":"a246f34cd993e7068c89617487aba536567b0111","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/GenericConfigurable.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/GenericConfigurable.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/GenericConfigurable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/GenericConfigurable.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/GenericConfigurable.java"},{"sha":"75c845ea83c66fecf654942a0c8bee060bb6679e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/IntValue.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/IntValue.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/IntValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/IntValue.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/IntValue.java"},{"sha":"17fdc2ebd6f787c1f69ffb5b71e566102be88365","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/MapConfigurationProvider.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/MapConfigurationProvider.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/MapConfigurationProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/MapConfigurationProvider.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/MapConfigurationProvider.java"},{"sha":"3d09cc753bf89a3bca79e76cdeb2f58e4d5ab6e7","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/ObjectValue.java"},{"sha":"0bb76657a86742a59a4bd491e27a78df596970d1","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginListValue.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginListValue.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginListValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginListValue.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/PluginListValue.java"},{"sha":"612fdbe0557e9d922b26b4fec3e8f34ec2f2f12a","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginValue.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginValue.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginValue.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/PluginValue.java"},{"sha":"886dd787f7b626f60f738a7b9db2a9574eb24d9e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringListValue.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringListValue.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringListValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringListValue.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/StringListValue.java"},{"sha":"9c9a21c5730afa57bd75d81b419ec322dc62a9d8","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringValue.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringValue.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringValue.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/StringValue.java"},{"sha":"290ae8ae9d7513afa4f96d785b3c04c50c03b2ef","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Value.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Value.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Value.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Value.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/Value.java"},{"sha":"a9c068b9efd3137d488abf192996adc6d061fbc4","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ValueListener.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ValueListener.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ValueListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ValueListener.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/ValueListener.java"},{"sha":"e3ff8caf15e4a51231fda16c2a20479e7d174cb5","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/package.html","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/package.html","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/package.html?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/conf/package.html"},{"sha":"b955cda61ee0815560491eff49ea8ad1669627d6","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/AbstractJDBCListener.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/AbstractJDBCListener.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/AbstractJDBCListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/AbstractJDBCListener.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/AbstractJDBCListener.java"},{"sha":"afc19d3cb44c714f863c67b7fd845d42bab4e831","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConfiguringConnectionDecorator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConfiguringConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConfiguringConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConfiguringConnectionDecorator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/ConfiguringConnectionDecorator.java"},{"sha":"cefb3d12e0494126858a5161e5cc4df07ae4a147","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConnectionDecorator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConnectionDecorator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/ConnectionDecorator.java"},{"sha":"2ac32a2d58c217476ddb53ae72f31f4482e0476e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DataSourceLogs.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DataSourceLogs.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DataSourceLogs.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DataSourceLogs.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/DataSourceLogs.java"},{"sha":"b67d692ada0adfd00a3d8e8ce7585ba212a04a23","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java"},{"sha":"7ffe8d54138deec99ceed9a17a2f3b9f6b82461c","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java"},{"sha":"167d42b746e7dde799771b1184319a8d0a914646","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java"},{"sha":"23243cf2f4f065c3d1f818e2e1f61fd696d748f2","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java"},{"sha":"d0a5f6a3e9de5e872cd5bfc07f47a87371d35489","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java"},{"sha":"45c531c127462e97cdb9c490ecceb743fd62e39e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java"},{"sha":"3b56a1a9fa442ccc4c57b7bf0e0f5f1b9dfdd130","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingResultSet.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingResultSet.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingResultSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingResultSet.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/DelegatingResultSet.java"},{"sha":"c3265c05c737234425c372369f3386fa051acca5","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingStatement.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingStatement.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingStatement.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/DelegatingStatement.java"},{"sha":"3fc7f8c9f1692219b0c2024e85145afc89d778d9","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEvent.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEvent.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEvent.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/JDBCEvent.java"},{"sha":"c9bd3a41e7b65455795c1cb43a19783d5d829163","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java"},{"sha":"58b2428ad9fa590072bf5e229f1691e86bb6be5a","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCListener.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCListener.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCListener.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/JDBCListener.java"},{"sha":"4d086a785cbbd15886e6d42dd41a3448e6f99fb4","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java"},{"sha":"9846421d7432f33da2d44e263eca1433cf2192d5","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java"},{"sha":"df43a625d5e2925d3d9f90ae0deee63dd84ae1fb","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/SQLFormatter.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/SQLFormatter.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/SQLFormatter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/SQLFormatter.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/SQLFormatter.java"},{"sha":"314161e362ed832157d8f50c7945bb8a46a442b2","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/package.html","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/package.html","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/package.html?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/jdbc/package.html"},{"sha":"6c15cadda2389a3ba5c6a4f653b2d1ce89f07082","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/AbstractLog.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/AbstractLog.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/AbstractLog.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/AbstractLog.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/log/AbstractLog.java"},{"sha":"667ef6949812482b7a80d073cf0e245e9f700be8","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/CommonsLogFactory.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/CommonsLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/CommonsLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/CommonsLogFactory.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/log/CommonsLogFactory.java"},{"sha":"9a2cc4eea5bd19f347eecf38f512d79af2d2488e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/log/Log.java"},{"sha":"2d57a046bff9abdb08b5d0e1fd17b783e1848679","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log4JLogFactory.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log4JLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log4JLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log4JLogFactory.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/log/Log4JLogFactory.java"},{"sha":"107d38823216bfd2b9eaa6708ec6b0b6803ebd3b","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactory.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactory.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/log/LogFactory.java"},{"sha":"00c67961215d3b8240251b33389ddffa654529f7","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java"},{"sha":"b1336a3f34d141efb5df3b2ee20dc4af67a0ad8a","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java"},{"sha":"c0419fbf150965278db3e505fe410d2a39234f77","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogOutputStream.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogOutputStream.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogOutputStream.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogOutputStream.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/log/LogOutputStream.java"},{"sha":"8936d23cc1b44e0fe5c1da4daa1dbf244e0fccbf","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java"},{"sha":"461b034de6d92462db840d25519f7e6fd319c0d0","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/NoneLogFactory.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/NoneLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/NoneLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/NoneLogFactory.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/log/NoneLogFactory.java"},{"sha":"8fa6f062e725023caaf8048dbc7f062923e8ed2f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/package.html","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/package.html","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/package.html?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/log/package.html"},{"sha":"a2a5880cbdd9d19423b5d81621acba632ef57a2d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataParser.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataParser.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/CFMetaDataParser.java"},{"sha":"0b6beb9ea69ee3935bb5e7278ae847b8922932cc","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataSerializer.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataSerializer.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/CFMetaDataSerializer.java"},{"sha":"bfad9966cae902ea94885bd0c5abbba9d6b64ed0","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassAnnotationMetaDataFilter.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassAnnotationMetaDataFilter.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassAnnotationMetaDataFilter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassAnnotationMetaDataFilter.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/ClassAnnotationMetaDataFilter.java"},{"sha":"acb31a234a1de196986df8f85c30f70531e5969b","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java"},{"sha":"c040d4d92291fc44d6fc75c6aacdd1e23721c43a","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassMetaDataIterator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassMetaDataIterator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/ClassMetaDataIterator.java"},{"sha":"8f36c728deee0aa6afa0f925b76ff02e2f5e77ce","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClasspathMetaDataIterator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClasspathMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClasspathMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClasspathMetaDataIterator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/ClasspathMetaDataIterator.java"},{"sha":"b124a5808dfe951139218c0d9d3ac41ac246e9dc","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/FileMetaDataIterator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/FileMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/FileMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/FileMetaDataIterator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/FileMetaDataIterator.java"},{"sha":"06af1018f8edde1c722e5cc74b73519fc77eadd6","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataFilter.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataFilter.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataFilter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataFilter.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/MetaDataFilter.java"},{"sha":"9cd4c41663fa42881a53378d727da2703991f529","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataIterator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataIterator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/MetaDataIterator.java"},{"sha":"4cb6fe05d465c2345cf51ca50d3c3da5c256f0d3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataIteratorChain.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataIteratorChain.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataIteratorChain.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataIteratorChain.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/MetaDataIteratorChain.java"},{"sha":"d4914c15ffc1d5fb7f8e40b72aeacf5af244866d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataParser.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataParser.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/MetaDataParser.java"},{"sha":"068d8ac950c6b7276b913af130f994e91ceba277","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataSerializer.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataSerializer.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/MetaDataSerializer.java"},{"sha":"75e67dfe6f02e01388e35c97d27073096b9dd70b","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ResourceMetaDataIterator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ResourceMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ResourceMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ResourceMetaDataIterator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/ResourceMetaDataIterator.java"},{"sha":"f56ba2c93303340556fb39dc53d460f9cbdf9395","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SourceTracker.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SourceTracker.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SourceTracker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SourceTracker.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/SourceTracker.java"},{"sha":"d4b069cd98b9c7bd0c23c05d49010258f34f4c03","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SourceTrackers.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SourceTrackers.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SourceTrackers.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SourceTrackers.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/SourceTrackers.java"},{"sha":"e777d0b82264f4a1b1a295d6380689b4d3bdcc91","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SuffixMetaDataFilter.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SuffixMetaDataFilter.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SuffixMetaDataFilter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SuffixMetaDataFilter.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/SuffixMetaDataFilter.java"},{"sha":"1de1481e24d46e16ad57c2490406b7ab22ed0798","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/URLMetaDataIterator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/URLMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/URLMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/URLMetaDataIterator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/URLMetaDataIterator.java"},{"sha":"15dc8cdd2cae5c6badaae727544fc5b7ba5aceb4","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java"},{"sha":"18fc49aa2cbf0dddc35ed5617c2c0eca8f9509db","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataSerializer.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataSerializer.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/XMLMetaDataSerializer.java"},{"sha":"9af7926f9ed261ef049c618b09cada3864d00b0b","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ZipFileMetaDataIterator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ZipFileMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ZipFileMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ZipFileMetaDataIterator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/ZipFileMetaDataIterator.java"},{"sha":"4caef04bcedb8037a9b1948934dc9d6792c997c3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ZipStreamMetaDataIterator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ZipStreamMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ZipStreamMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ZipStreamMetaDataIterator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/ZipStreamMetaDataIterator.java"},{"sha":"c134cc6a6efc75f88138cf98e9d77a48c24323f2","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/package.html","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/package.html","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/package.html?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/meta/package.html"},{"sha":"20738b272935e524ff6573bcb5bcd63a2a7bffb5","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractListIterator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractListIterator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractListIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractListIterator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/AbstractListIterator.java"},{"sha":"1833fb1d907ff565e475b03c784b7e7d3effb64e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java"},{"sha":"31bd8ad4f53964f0b2fb26d6d717677bda2fab39","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractResultList.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractResultList.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractResultList.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/AbstractResultList.java"},{"sha":"f904eeed30c50dba01fb0a2f25e1b5a85d4d8d07","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractSequentialResultList.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractSequentialResultList.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractSequentialResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractSequentialResultList.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/AbstractSequentialResultList.java"},{"sha":"503825c48380ac2ed1faebae9221c809502041c6","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/EagerResultList.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/EagerResultList.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/EagerResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/EagerResultList.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/EagerResultList.java"},{"sha":"63f240bc49aa0d2699cd1d2f2e9ae8326c70408f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java"},{"sha":"0b162756367cb841dc255507ebe290dd3fd158ae","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultList.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultList.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultList.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/ListResultList.java"},{"sha":"4eecdbcc54859c053843dbf51b8ce95c97c6ef7d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultObjectProvider.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultObjectProvider.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/ListResultObjectProvider.java"},{"sha":"3428a97f517a25ff94dc7813936345284f1d9332","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/MergedResultObjectProvider.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/MergedResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/MergedResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/MergedResultObjectProvider.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/MergedResultObjectProvider.java"},{"sha":"ce53761e18ad8a2e1eed686df4c6bb5f2e0889f1","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/RandomAccessResultList.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/RandomAccessResultList.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/RandomAccessResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/RandomAccessResultList.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/RandomAccessResultList.java"},{"sha":"d136b12429430f61bd30061bf59df73ac0958e43","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/RangeResultObjectProvider.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/RangeResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/RangeResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/RangeResultObjectProvider.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/RangeResultObjectProvider.java"},{"sha":"c8c935242a7e5bbbc5d42b0e58f87503347313e7","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultList.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultList.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultList.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/ResultList.java"},{"sha":"04d8b3a6eec4395ef9330b460edd5d9ada91e175","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultListIterator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultListIterator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultListIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultListIterator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/ResultListIterator.java"},{"sha":"814afc1317bb5a20e2de908c7a2e5e520fa76f38","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultObjectProvider.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultObjectProvider.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/ResultObjectProvider.java"},{"sha":"423856f7c0ab176caf89ab22062b54c7932ba3a3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultObjectProviderIterator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultObjectProviderIterator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultObjectProviderIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ResultObjectProviderIterator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/ResultObjectProviderIterator.java"},{"sha":"95c6b2b7b29fda80a55bc8c2dd07b5de1d5a310c","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/SimpleResultList.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/SimpleResultList.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/SimpleResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/SimpleResultList.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/SimpleResultList.java"},{"sha":"faef7d3926d8f66380f63cb779be9cb508e3e868","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/SoftRandomAccessResultList.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/SoftRandomAccessResultList.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/SoftRandomAccessResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/SoftRandomAccessResultList.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/SoftRandomAccessResultList.java"},{"sha":"f514af037fb7108ffa5f1a05e70c84089eafdd49","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/WindowResultList.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/WindowResultList.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/WindowResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/WindowResultList.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/WindowResultList.java"},{"sha":"0d4b1307e0dd6fd7f629ba5354ad961c8c791a56","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/package.html","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/package.html","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/package.html?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/rop/package.html"},{"sha":"a402b6bdef650e593eb8c453aa71e3e74bd015f4","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/AbstractEventManager.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/AbstractEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/AbstractEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/AbstractEventManager.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/AbstractEventManager.java"},{"sha":"6beef6822de3659db192d56fce57aa8d15f23a9c","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Base16Encoder.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Base16Encoder.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Base16Encoder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Base16Encoder.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/Base16Encoder.java"},{"sha":"5ff5417231391e6ab4aea64a427ec9942f2f2856","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/BytecodeWriter.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/BytecodeWriter.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/BytecodeWriter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/BytecodeWriter.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/BytecodeWriter.java"},{"sha":"d494eb36789b5e8a9adabdd9d7ef1fd88b52daa8","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Closeable.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Closeable.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Closeable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Closeable.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/Closeable.java"},{"sha":"d386e811d2551723d5701d462065068087ec9920","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/CodeFormat.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/CodeFormat.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/CodeFormat.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/CodeFormat.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/CodeFormat.java"},{"sha":"bf596b1a02540ec71d7b832bccb6621959893906","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/EventManager.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/EventManager.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/EventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/EventManager.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/EventManager.java"},{"sha":"d37659d0c189d75406c28cee83a5ca0ca7a04ee4","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Files.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Files.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Files.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Files.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/Files.java"},{"sha":"58e53a3d16b56a9472696bee62075002eae87e58","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java"},{"sha":"1f1626bf6cbfe973c2a36a5f07742e7323c01056","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/JavaVersions.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/JavaVersions.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/JavaVersions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/JavaVersions.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/JavaVersions.java"},{"sha":"cf024777bbd3e5da8af3e97864e5c410e684c76d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/LRUMap.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/LRUMap.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/LRUMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/LRUMap.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/LRUMap.java"},{"sha":"21a2d6b821a18428ab03d41f0d30f45933e34831","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/Localizer.java"},{"sha":"99a3bd0e8fd537126e3aaf52297fa74885418245","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/MultiClassLoader.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/MultiClassLoader.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/MultiClassLoader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/MultiClassLoader.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/MultiClassLoader.java"},{"sha":"bea8c2c44446230d8602e666635a9871695f7c05","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Options.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Options.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Options.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Options.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/Options.java"},{"sha":"30b1b6adb0fd843ef69c34be692ead9b50881744","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ParameterTemplate.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ParameterTemplate.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ParameterTemplate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ParameterTemplate.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/ParameterTemplate.java"},{"sha":"fa4c77bec56dbb2a0c982cd802e3a03dcaa6cefb","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ParseException.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ParseException.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ParseException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ParseException.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/ParseException.java"},{"sha":"5c6f9a49cd8614f97ac281af6e330dbe8c2908a3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceHashMap.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceHashMap.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/ReferenceHashMap.java"},{"sha":"c7e37fe852a7e1a475bbd2bc005dedaaaa6dd2a6","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceHashSet.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceHashSet.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceHashSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceHashSet.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/ReferenceHashSet.java"},{"sha":"2fdda17768987b93f89ebc3617f8931dba667786","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceMap.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceMap.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceMap.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/ReferenceMap.java"},{"sha":"525f70f9eba149ea140de947becb1997958b9772","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ResourceBundleProvider.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ResourceBundleProvider.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ResourceBundleProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ResourceBundleProvider.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/ResourceBundleProvider.java"},{"sha":"079f37107c95448250595376d9885bb09d4dcc43","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Services.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Services.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Services.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Services.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/Services.java"},{"sha":"304c27b8275ba46662c4d8a8eb207a5269144056","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SimpleRegex.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SimpleRegex.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SimpleRegex.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SimpleRegex.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/SimpleRegex.java"},{"sha":"d0d2f137368909616c075243993a16ed2b27560e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SimpleResourceBundleProvider.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SimpleResourceBundleProvider.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SimpleResourceBundleProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SimpleResourceBundleProvider.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/SimpleResourceBundleProvider.java"},{"sha":"a23ba84147e37e27b33e6f0c37c7cb731c3f1d77","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SizedMap.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SizedMap.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SizedMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SizedMap.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/SizedMap.java"},{"sha":"e27bf8fb2d7f4751d616f9f729936d988dc5c199","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StreamResourceBundleProvider.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StreamResourceBundleProvider.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StreamResourceBundleProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StreamResourceBundleProvider.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/StreamResourceBundleProvider.java"},{"sha":"acf77f91ff1aa6d80f26279efbf72e83584a9f4a","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StringDistance.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StringDistance.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StringDistance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StringDistance.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/StringDistance.java"},{"sha":"3f34070ffbd77988cef8b08c81c79a282e876d24","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TemporaryClassLoader.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TemporaryClassLoader.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TemporaryClassLoader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TemporaryClassLoader.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/TemporaryClassLoader.java"},{"sha":"5e036664169790950af96e42d4501d9841ab39bf","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TypedProperties.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TypedProperties.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TypedProperties.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TypedProperties.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/TypedProperties.java"},{"sha":"7db3ef5e35c5abf3c169800ab7bad984db343f45","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/UUIDGenerator.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/UUIDGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/UUIDGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/UUIDGenerator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/UUIDGenerator.java"},{"sha":"2d77f343b45c4a6959feaf2547af71de84b138f3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ZipResourceBundleProvider.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ZipResourceBundleProvider.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ZipResourceBundleProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ZipResourceBundleProvider.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/ZipResourceBundleProvider.java"},{"sha":"3956332d0dd25419907951f8caa7682c0b2608a0","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractCollection.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractCollection.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractCollection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractCollection.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/AbstractCollection.java"},{"sha":"0744cbdc8da17092563d42d38230c07a289dc4f4","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractConcurrentEventManager.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractConcurrentEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractConcurrentEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractConcurrentEventManager.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/AbstractConcurrentEventManager.java"},{"sha":"9a8acdd8b7e3406a1a55c34e1eb4ccc171bc2201","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractQueue.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractQueue.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractQueue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractQueue.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/AbstractQueue.java"},{"sha":"2582864c8463321a8fc379d2d5b20abebe5df999","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractSet.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractSet.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractSet.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/AbstractSet.java"},{"sha":"beab660d16fc68e15b73930e265a09236e444c1c","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Arrays.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Arrays.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Arrays.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Arrays.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/Arrays.java"},{"sha":"479151b32a264d7dfe4a35a7094db90f810731b1","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java"},{"sha":"3f37e37e94e9c397c3cdd4d420b1b463905f826f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashSet.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashSet.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashSet.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashSet.java"},{"sha":"cf7f0044f6e84a5d97efff588f762caa4c4d984d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentLinkedQueue.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentLinkedQueue.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentLinkedQueue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentLinkedQueue.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentLinkedQueue.java"},{"sha":"32d7d6a86c50fce2d8c4e7004b94a91bef92461e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentMap.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentMap.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentMap.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentMap.java"},{"sha":"6ba7aaf4ee600c9811b4fb68640f23d779f7701c","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap.java"},{"sha":"cc68e07cf3672652dd9fd7f79d040eb82f25f9b8","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashSet.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashSet.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashSet.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashSet.java"},{"sha":"3d2bee724d9cf5a7ff87a903c8a1312f82b74ca8","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java"},{"sha":"63267b29c09352bc8bda7799809b1c51d5f67c4f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Condition.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Condition.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Condition.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Condition.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/Condition.java"},{"sha":"1cfcbedb741a026940694da7bd64848a704e4b2d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArrayList.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArrayList.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArrayList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArrayList.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArrayList.java"},{"sha":"fea2dadd7d24e4ebee588c2138776d60eb6b5b0e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArraySet.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArraySet.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArraySet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArraySet.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArraySet.java"},{"sha":"d973dba8073d10aeb5679d1841916b1981ef0237","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOCondVar.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOCondVar.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOCondVar.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOCondVar.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/FIFOCondVar.java"},{"sha":"d0b5cb061920ee366656f3a9f09129dd1a20e105","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOWaitQueue.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOWaitQueue.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOWaitQueue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOWaitQueue.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/FIFOWaitQueue.java"},{"sha":"372b3e9c0172fed0f3d39cfbe317208d00f582eb","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Lock.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Lock.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Lock.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Lock.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/Lock.java"},{"sha":"351380d751dbad9fba41d8eb2a96d2e156757eef","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NanoTimer.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NanoTimer.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NanoTimer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NanoTimer.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/NanoTimer.java"},{"sha":"578b0a53b83183a28f573d05d4d8f7f88587cc9f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Queue.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Queue.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Queue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Queue.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/Queue.java"},{"sha":"48fd4d3d09f79543316cd70aac34359eee721083","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java"},{"sha":"f25c8d7b1d69326a5a36f6d5ac1c1040a12bf5bd","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/TimeUnit.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/TimeUnit.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/TimeUnit.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/TimeUnit.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/TimeUnit.java"},{"sha":"9938b3a39eb1231e6ed9f3157072a00ecb1574cd","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Utils.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Utils.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Utils.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Utils.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/Utils.java"},{"sha":"2e52787a317c349f94260d12c0c8e28fe8c8146b","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/WaitQueue.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/WaitQueue.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/WaitQueue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/WaitQueue.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/WaitQueue.java"},{"sha":"1bce3dcb801da09d585cd43701bd12bbd02da7d7","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/package.html","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/package.html","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/package.html?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/concurrent/package.html"},{"sha":"4b4b1ba6111e0af9558558d0a3931ffef0bc9f17","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/package.html","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/package.html","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/package.html?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/util/package.html"},{"sha":"ce1fd2477e974b13775fbecd15c3525aac20094b","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/Commentable.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/Commentable.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/Commentable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/Commentable.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/xml/Commentable.java"},{"sha":"ea81798453d32254124d074f643604544b80b83f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/DocTypeReader.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/DocTypeReader.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/DocTypeReader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/DocTypeReader.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/xml/DocTypeReader.java"},{"sha":"3e060e3b3799ca928a561726a84a099a26786078","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/Location.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/Location.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/Location.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/Location.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/xml/Location.java"},{"sha":"a0a8a2e1a74dc62c179260d032d8310948a289fb","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/ValidatingErrorHandler.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/ValidatingErrorHandler.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/ValidatingErrorHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/ValidatingErrorHandler.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/xml/ValidatingErrorHandler.java"},{"sha":"b9de2bf999719d3f2957ec17efecaeae4f4090d4","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/XMLFactory.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/XMLFactory.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/XMLFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/XMLFactory.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/xml/XMLFactory.java"},{"sha":"3e26cf32a10c3bc69a4e776c25dae6d0a603f1f2","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/XMLWriter.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/XMLWriter.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/XMLWriter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/XMLWriter.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/xml/XMLWriter.java"},{"sha":"8dc7df50e371fe5041d5b16d1c2015f00fa3db4e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/package.html","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/package.html","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/xml/package.html?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/java/org/apache/openjpa/lib/xml/package.html"},{"sha":"4ae56a1e211bf972b7a036c97b7756e4eeaf4a6e","filename":"openjpa-lib/src/main/resources/org/apache/openjpa/lib/ant/localizer.properties","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/ant/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/ant/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/resources/org/apache/openjpa/lib/ant/localizer.properties?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/resources/org/apache/openjpa/lib/ant/localizer.properties"},{"sha":"6c07afed7618d9a5b2a88185e213c3931273a0e7","filename":"openjpa-lib/src/main/resources/org/apache/openjpa/lib/conf/localizer.properties","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/conf/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/conf/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/resources/org/apache/openjpa/lib/conf/localizer.properties?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/resources/org/apache/openjpa/lib/conf/localizer.properties"},{"sha":"94f3a2af1e69e60f2b0c029052e5ac7555bb5cd5","filename":"openjpa-lib/src/main/resources/org/apache/openjpa/lib/jdbc/localizer.properties","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/jdbc/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/jdbc/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/resources/org/apache/openjpa/lib/jdbc/localizer.properties?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/resources/org/apache/openjpa/lib/jdbc/localizer.properties"},{"sha":"332351997e3f28000adcd7d2173c7c1a2968af6e","filename":"openjpa-lib/src/main/resources/org/apache/openjpa/lib/log/localizer.properties","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/log/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/log/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/resources/org/apache/openjpa/lib/log/localizer.properties?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/resources/org/apache/openjpa/lib/log/localizer.properties"},{"sha":"f37569532ed1c610d05df9732255f35edaebf832","filename":"openjpa-lib/src/main/resources/org/apache/openjpa/lib/meta/localizer.properties","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/meta/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/meta/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/resources/org/apache/openjpa/lib/meta/localizer.properties?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/resources/org/apache/openjpa/lib/meta/localizer.properties"},{"sha":"4c385b1c61577f0bfbf77418319c2c6ed695ff89","filename":"openjpa-lib/src/main/resources/org/apache/openjpa/lib/rop/localizer.properties","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/rop/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/rop/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/resources/org/apache/openjpa/lib/rop/localizer.properties?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/resources/org/apache/openjpa/lib/rop/localizer.properties"},{"sha":"44954e8b447fc3185ff6a92e253af4835a679ef5","filename":"openjpa-lib/src/main/resources/org/apache/openjpa/lib/util/localizer.properties","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/util/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/util/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/resources/org/apache/openjpa/lib/util/localizer.properties?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/resources/org/apache/openjpa/lib/util/localizer.properties"},{"sha":"4423dd7a47cd396d759a2c32af6884c7181613f7","filename":"openjpa-lib/src/main/resources/org/apache/openjpa/lib/xml/localizer.properties","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/xml/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/main/resources/org/apache/openjpa/lib/xml/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/resources/org/apache/openjpa/lib/xml/localizer.properties?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","previous_filename":"openjpa-lib/main/resources/org/apache/openjpa/lib/xml/localizer.properties"},{"sha":"4691af30756b85f776a53bba5c759237099767d0","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/Duration.java","status":"added","additions":162,"deletions":0,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/Duration.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/Duration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/Duration.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import java.lang.Exception;\n+import java.lang.System;\n+\n+\n+/*\n+        Millisecond (only) accuracy timer.\n+        Java 1.4 supposedly has sun.misc.Perf.\n+        Java 1.5 has System.nanoTime (JSR 166)\n+*/\n+public class Duration implements Cloneable {\n+    private String _name;\n+    private boolean _started;\n+    private boolean _running;\n+    private long _startTime; // millis\n+    private long _stopTime; // millis\n+\n+    // NYI clock time of day at start\n+    public Duration(String name) {\n+        _name = name;\n+        _started = false;\n+        _running = false;\n+    }\n+\n+    public String getName() {\n+        return _name;\n+    }\n+\n+    public synchronized void start() {\n+        if (_started) {\n+            throw new RuntimeException(\"Duration was already started.\");\n+        }\n+\n+        _startTime = System.currentTimeMillis();\n+        _started = true;\n+        _running = true;\n+    }\n+\n+    public synchronized void stop() {\n+        if (!_started) {\n+            throw new RuntimeException(\"Duration was never started.\");\n+        }\n+\n+        if (!_running) {\n+            throw new RuntimeException(\"Duration was already stopped.\");\n+        }\n+\n+        _stopTime = System.currentTimeMillis();\n+        _running = false;\n+    }\n+\n+    protected Object clone() throws CloneNotSupportedException {\n+        return super.clone();\n+    }\n+\n+    /*\n+            Returns a new Duration object from a currently running timer\n+            as a snapshot of this object.\n+            The returned timer is stopped, while this object continue on.\n+    */\n+    public synchronized Duration getCurrentDuration() {\n+        if (!_started) {\n+            throw new RuntimeException(\"Duration was never started.\");\n+        }\n+\n+        if (!_running) {\n+            throw new RuntimeException(\"Duration is not running.\");\n+        }\n+\n+        long now = System.currentTimeMillis();\n+        Duration currentDuration;\n+\n+        try {\n+            currentDuration = (Duration) this.clone();\n+        } catch (Exception e) {\n+            currentDuration = new Duration(\"\");\n+        }\n+\n+        currentDuration._stopTime = now;\n+        currentDuration._running = false;\n+\n+        return currentDuration;\n+    }\n+\n+    /* Obtain the duration that this timer has run (in seconds)        */\n+    public synchronized double getDurationAsSeconds() {\n+        if (!_started) {\n+            throw new RuntimeException(\"Duration was never started.\");\n+        }\n+\n+        if (_running) {\n+            // snapshot\n+            Duration snapshot = getCurrentDuration();\n+\n+            return (1000.0 * (snapshot._stopTime - snapshot._startTime));\n+        }\n+\n+        // Return a double value. Someday this class may make use of\n+        // higher precision timing services (e.g. java 1.5)\n+        return ((_stopTime - _startTime) / (double) 1000.0);\n+    }\n+\n+    public synchronized boolean isRunning() {\n+        return _running;\n+    }\n+\n+    public synchronized boolean wasStarted() {\n+        return _started;\n+    }\n+\n+    public String toString() {\n+        double time = 0.0;\n+        StringBuffer buf = new StringBuffer(256);\n+\n+        if (wasStarted()) {\n+            if (isRunning()) {\n+                Duration snapshot = getCurrentDuration();\n+                time = snapshot.getDurationAsSeconds();\n+            } else {\n+                time = getDurationAsSeconds();\n+            }\n+\n+            buf.append(\"Duration for '\" + _name + \"' is \" + time + \" (s).\");\n+        } else {\n+            buf.append(\"Duration for '\" + _name +\n+                \"' has not yet been started.\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    /* Example usage:\n+               public static void main (String[] args)\n+                    throws Exception\n+            {\n+                    Duration test = new Duration (\"hello, count to 1 million\");\n+                    System.out.println (test);\n+                    test.start ();\n+                    for (int i = 0; i < 1000000000; i++)\n+                            {\n+                            }\n+                    test.stop ();\n+                    System.out.println (test);\n+            }\n+            */\n+}"},{"sha":"b9e921f103ed04daf773a4823dc34336a8f3ba44","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import junit.framework.*;\n+\n+import junit.textui.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Tests the {@link AbstractEventManager}.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class TestAbstractEventManager extends TestCase {\n+    private EventManager _em = new EventManager();\n+\n+    public TestAbstractEventManager(String test) {\n+        super(test);\n+    }\n+\n+    public void testReentrantAdd() {\n+        Listener l1 = new Listener(Listener.ADD);\n+        Listener l2 = new Listener(Listener.NONE);\n+        _em.addListener(l1);\n+        _em.addListener(l2);\n+        _em.fireEvent(new Object());\n+        assertTrue(l1.fired);\n+        assertTrue(l2.fired);\n+        assertEquals(3, _em.getListeners().size());\n+    }\n+\n+    public void testReentrantRemove() {\n+        Listener l1 = new Listener(Listener.REMOVE);\n+        Listener l2 = new Listener(Listener.NONE);\n+        _em.addListener(l1);\n+        _em.addListener(l2);\n+        _em.fireEvent(new Object());\n+        assertTrue(l1.fired);\n+        assertTrue(l2.fired);\n+        assertEquals(1, _em.getListeners().size());\n+        assertFalse(_em.getListeners().contains(l1));\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestAbstractEventManager.class);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    private static class EventManager extends AbstractEventManager {\n+        protected void fireEvent(Object event, Object listener) {\n+            ((Listener) listener).fire();\n+        }\n+    }\n+\n+    private class Listener {\n+        public static final int NONE = 0;\n+        public static final int ADD = 1;\n+        public static final int REMOVE = 2;\n+        public boolean fired;\n+        private final int _action;\n+\n+        public Listener(int action) {\n+            _action = action;\n+        }\n+\n+        public void fire() {\n+            fired = true;\n+\n+            if (_action == ADD) {\n+                _em.addListener(new Listener(NONE));\n+            } else if (_action == REMOVE) {\n+                assertTrue(_em.removeListener(this));\n+            }\n+        }\n+    }\n+}"},{"sha":"bdcf227e3eb2d53e7e56c83facc93f3c38e3adc1","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestLocalizer.java","status":"added","additions":125,"deletions":0,"changes":125,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestLocalizer.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestLocalizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestLocalizer.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import junit.framework.*;\n+\n+import junit.textui.*;\n+\n+import org.apache.openjpa.lib.util.testlocalizer.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Tests the Localizer.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class TestLocalizer extends TestCase {\n+    private Localizer _locals = null;\n+\n+    public TestLocalizer(String test) {\n+        super(test);\n+    }\n+\n+    public void setUp() {\n+        _locals = Localizer.forPackage(LocalizerTestHelper.class);\n+    }\n+\n+    /**\n+     *  Test getting a string for a class.\n+     */\n+    public void testForClass() {\n+        assertEquals(\"value1\", _locals.get(\"test.local1\"));\n+    }\n+\n+    /**\n+     *  Test getting a string for a non-default locale.\n+     */\n+    public void testForLocale() {\n+        Localizer locl = Localizer.forPackage(LocalizerTestHelper.class,\n+                Locale.GERMANY);\n+        assertEquals(\"value1_de\", locl.get(\"test.local1\"));\n+    }\n+\n+    /**\n+     *  Tests that if a locale is missing the system falls back to\n+     *  the default.\n+     */\n+    public void testFallbackLocale() {\n+        Localizer locl = Localizer.forPackage(LocalizerTestHelper.class,\n+                Locale.FRANCE);\n+        assertEquals(\"value1\", locl.get(\"test.local1\"));\n+    }\n+\n+    /**\n+     *  Tests that a null class accesses the localizer.properties file\n+     *  for the top-level (no package).\n+     */\n+    public void testTopLevel() {\n+        Localizer system = Localizer.forPackage(null);\n+        assertEquals(\"systemvalue1\", system.get(\"test.systemlocal\"));\n+    }\n+\n+    /**\n+     *  Test that the message formatting works correctly.\n+     */\n+    public void testMessageFormat() {\n+        assertEquals(\"value2 x sep y\",\n+            _locals.get(\"test.local2\", new String[] { \"x\", \"y\" }));\n+\n+        // test that it treates single objects as single-element arrays\n+        assertEquals(\"value2 x sep {1}\", _locals.get(\"test.local2\", \"x\"));\n+    }\n+\n+    /**\n+     *  Test that a {@link MissingResourceException} is thrown for missing\n+     *  resource bundles.\n+     */\n+    public void testMissingBundle() {\n+        Localizer missing = Localizer.forPackage(String.class);\n+        assertEquals(\"foo.bar\", missing.get(\"foo.bar\"));\n+\n+        try {\n+            missing.getFatal(\"foo.bar\");\n+            fail(\"No exception for fatal get on missing bundle.\");\n+        } catch (MissingResourceException mre) {\n+        }\n+    }\n+\n+    /**\n+     *  Test that a {@link MissingResourceException} is thrown for missing\n+     *  keys.\n+     */\n+    public void testMissingKey() {\n+        assertEquals(\"foo.bar\", _locals.get(\"foo.bar\"));\n+\n+        try {\n+            _locals.getFatal(\"foo.bar\");\n+            fail(\"No exception for fatal get on missing key.\");\n+        } catch (MissingResourceException mre) {\n+        }\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestLocalizer.class);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+}"},{"sha":"b378b95f796289093ecba2c0da5cbde01a99e870","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestMultiClassLoader.java","status":"added","additions":163,"deletions":0,"changes":163,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestMultiClassLoader.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestMultiClassLoader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestMultiClassLoader.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import junit.framework.*;\n+\n+import junit.textui.*;\n+\n+import java.net.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Tests the {@link MultiClassLoader}.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class TestMultiClassLoader extends TestCase {\n+    private ClassLoader SYSTEM_LOADER = MultiClassLoader.class.getClassLoader();\n+    private MultiClassLoader _loader = new MultiClassLoader();\n+\n+    public TestMultiClassLoader(String test) {\n+        super(test);\n+    }\n+\n+    public void setUp() {\n+        _loader.addClassLoader(MultiClassLoader.THREAD_LOADER);\n+        _loader.addClassLoader(SYSTEM_LOADER);\n+    }\n+\n+    /**\n+     *  Tests basic add/remove functionality.\n+     */\n+    public void testBasic() {\n+        assertEquals(2, _loader.size());\n+        assertTrue(!_loader.isEmpty());\n+        assertTrue(_loader.getClassLoaders()[0] == SYSTEM_LOADER);\n+        assertEquals(Thread.currentThread().getContextClassLoader(),\n+            _loader.getClassLoaders()[1]);\n+        assertTrue(_loader.getClassLoader(0) == SYSTEM_LOADER);\n+        assertTrue(!_loader.addClassLoader(_loader.THREAD_LOADER));\n+\n+        FooLoader foo = new FooLoader();\n+        assertTrue(_loader.addClassLoader(foo));\n+        assertTrue(!_loader.addClassLoader(foo));\n+        assertEquals(3, _loader.size());\n+        assertEquals(foo, _loader.getClassLoaders()[2]);\n+\n+        assertTrue(_loader.removeClassLoader(_loader.THREAD_LOADER));\n+        assertTrue(!_loader.removeClassLoader(_loader.THREAD_LOADER));\n+        assertEquals(2, _loader.size());\n+        assertTrue(_loader.getClassLoaders()[0] == SYSTEM_LOADER);\n+        assertEquals(foo, _loader.getClassLoaders()[1]);\n+\n+        assertTrue(_loader.removeClassLoader(foo));\n+        assertTrue(_loader.removeClassLoader(SYSTEM_LOADER));\n+        assertTrue(_loader.isEmpty());\n+\n+        MultiClassLoader loader2 = new MultiClassLoader();\n+        loader2.addClassLoader(MultiClassLoader.THREAD_LOADER);\n+        loader2.addClassLoader(SYSTEM_LOADER);\n+        assertTrue(_loader.addClassLoaders(loader2));\n+        assertTrue(!_loader.addClassLoaders(loader2));\n+\n+        FooLoader foo2 = new FooLoader();\n+        loader2.addClassLoader(foo);\n+        loader2.addClassLoader(foo2);\n+        assertTrue(_loader.addClassLoaders(1, loader2));\n+\n+        ClassLoader[] loaders = _loader.getClassLoaders();\n+        assertTrue(loaders[0] == SYSTEM_LOADER);\n+        assertEquals(Thread.currentThread().getContextClassLoader(), loaders[3]);\n+        assertEquals(foo, loaders[1]);\n+        assertEquals(foo2, loaders[2]);\n+    }\n+\n+    /**\n+      *  Test finding classes.\n+     */\n+\n+    /*\n+            public void testClassForName ()\n+                    throws Exception\n+            {\n+                    assertEquals (MultiClassLoader.class,\n+                            Class.forName (MultiClassLoader.class.getName (), true, _loader));\n+                    assertTrue (_loader.removeClassLoader (SYSTEM_LOADER));\n+                    assertTrue (_loader.removeClassLoader (MultiClassLoader.THREAD_LOADER));\n+                    try\n+                    {\n+                            // have to switch classes here b/c other is now cached\n+                            assertEquals (TestMultiClassLoader.class, Class.forName\n+                                    (TestMultiClassLoader.class.getName (), true, _loader));\n+                            fail (\"System class laoder still working.\");\n+                    }\n+                    catch (ClassNotFoundException cnfe)\n+                    {\n+                    }\n+                    try\n+                    {\n+                            Class.forName (\"foo\", true, _loader);\n+                            fail (\"Somehow found 'foo'???\");\n+                    }\n+                    catch (ClassNotFoundException cnfe)\n+                    {\n+                    }\n+                    _loader.addClassLoader (new FooLoader ());\n+                    assertEquals (Integer.class, Class.forName (\"foo\", true, _loader));\n+            }\n+    */\n+\n+    /**\n+     *  Test finding resources.\n+     */\n+    public void testGetResource() {\n+        assertNull(_loader.getResource(\"foo\"));\n+        _loader.addClassLoader(new FooLoader());\n+        assertNotNull(_loader.getResource(\"foo\"));\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestMultiClassLoader.class);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    private static final class FooLoader extends ClassLoader {\n+        protected Class findClass(String name) throws ClassNotFoundException {\n+            if (\"foo\".equals(name)) {\n+                return Integer.class;\n+            }\n+\n+            throw new ClassNotFoundException(name);\n+        }\n+\n+        protected URL findResource(String name) {\n+            try {\n+                if (\"foo\".equals(name)) {\n+                    return new URL(\"file:///dev/null\");\n+                }\n+            } catch (Exception e) {\n+            }\n+\n+            return null;\n+        }\n+    }\n+}"},{"sha":"d436dcfe53a30e76ac609379b28330c0d19f6606","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestOptions.java","status":"added","additions":218,"deletions":0,"changes":218,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestOptions.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestOptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestOptions.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import junit.framework.*;\n+\n+import junit.textui.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Tests the {@link Options} type.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class TestOptions extends TestCase {\n+    private Options _opts = null;\n+    private String[] _args = new String[] {\n+            \"-int\", \"10\", \"-boolean\", \"-string\", \"STR,STR2\", \"-range1\", \"10,100\",\n+            \"-range2\", \"10\", \"-fieldVal\", \"20\", \"-FieldVal2\", \"30\",\n+            \"-inner.nullInner.range1\", \"10,100\", \"arg1\", \"arg2\", \"arg3\"\n+        };\n+\n+    public TestOptions(String test) {\n+        super(test);\n+    }\n+\n+    public void setUp() {\n+        Properties defs = new Properties();\n+        defs.setProperty(\"default\", \"value\");\n+        _opts = new Options(defs);\n+        _args = _opts.setFromCmdLine(_args);\n+    }\n+\n+    /**\n+     *  Test command-line parsing.\n+     */\n+    public void testCmdLineParsing() {\n+        assertEquals(3, _args.length);\n+        assertEquals(\"arg1\", _args[0]);\n+        assertEquals(\"arg2\", _args[1]);\n+        assertEquals(\"arg3\", _args[2]);\n+\n+        assertEquals(\"10\", _opts.getProperty(\"int\"));\n+        assertEquals(\"true\", _opts.getProperty(\"boolean\"));\n+        assertEquals(\"STR,STR2\", _opts.getProperty(\"string\"));\n+        assertEquals(\"20\", _opts.getProperty(\"fieldVal\"));\n+        assertEquals(\"30\", _opts.getProperty(\"FieldVal2\"));\n+        assertEquals(\"10,100\", _opts.getProperty(\"range1\"));\n+        assertEquals(\"10\", _opts.getProperty(\"range2\"));\n+        assertEquals(\"10,100\", _opts.getProperty(\"inner.nullInner.range1\"));\n+        assertEquals(\"value\", _opts.getProperty(\"default\"));\n+\n+        _args = _opts.setFromCmdLine(new String[] { \"-default\", \"newValue\" });\n+        assertEquals(0, _args.length);\n+        assertEquals(\"newValue\", _opts.getProperty(\"default\"));\n+    }\n+\n+    /**\n+     *  Tests the setting of option values into bean objects.\n+     */\n+    public void testSetObject() {\n+        Inner inner = new Inner();\n+        _opts.setInto(inner);\n+\n+        assertEquals(10, inner.getInt());\n+        assertTrue(inner.getBoolean());\n+        assertEquals(\"STR,STR2\", inner.getString());\n+        assertEquals(20, inner.fieldVal);\n+        assertEquals(30, inner.fieldVal2);\n+        assertEquals(10, inner.getRange1()[0]);\n+        assertEquals(100, inner.getRange1()[1]);\n+        assertEquals(10, inner.getRange2()[0]);\n+        assertEquals(0, inner.getRange2()[1]);\n+        assertEquals(\"value\", inner.getDefault());\n+\n+        assertEquals(10, inner.getInner().getNullInner().getRange1()[0]);\n+        assertEquals(100, inner.getInner().getNullInner().getRange1()[1]);\n+\n+        inner = new Inner();\n+\n+        Options opts = new Options();\n+        opts.setProperty(\"inner\", Inner2.class.getName());\n+        opts.setInto(inner);\n+        assertEquals(Inner2.class, inner.getInner().getClass());\n+\n+        inner = new Inner();\n+        opts = new Options();\n+        opts.setProperty(\"mixed\", \"STR,1\");\n+        opts.setInto(inner);\n+        assertEquals(1, inner.getInt());\n+        assertEquals(\"STR\", inner.getString());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestOptions.class);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     *  Used internally for testing; must be public so Options can\n+     *  construct it.\n+     */\n+    public static class Inner {\n+        public int fieldVal = 0;\n+        public int fieldVal2 = 0;\n+        private int _int = 0;\n+        private boolean _boolean = false;\n+        private String _string = null;\n+        private String _default = null;\n+        private Inner _inner = null;\n+        private Inner _nullInner = null;\n+        private int[] _range1 = new int[2];\n+        private int[] _range2 = new int[2];\n+\n+        public Inner() {\n+        }\n+\n+        public int getInt() {\n+            return _int;\n+        }\n+\n+        public void setInt(int i) {\n+            _int = i;\n+        }\n+\n+        public boolean getBoolean() {\n+            return _boolean;\n+        }\n+\n+        public void setBoolean(boolean b) {\n+            _boolean = b;\n+        }\n+\n+        public String getString() {\n+            return _string;\n+        }\n+\n+        public void setString(String s) {\n+            _string = s;\n+        }\n+\n+        public String getDefault() {\n+            return _default;\n+        }\n+\n+        public void setDefault(String s) {\n+            _default = s;\n+        }\n+\n+        public int[] getRange1() {\n+            return _range1;\n+        }\n+\n+        public void setRange1(int min, int max) {\n+            _range1[0] = min;\n+            _range1[1] = max;\n+        }\n+\n+        public int[] getRange2() {\n+            return _range2;\n+        }\n+\n+        public void setRange2(int min, int max) {\n+            _range2[0] = min;\n+            _range2[1] = max;\n+        }\n+\n+        public void setMixed(String s, int i) {\n+            _int = i;\n+            _string = s;\n+        }\n+\n+        public Inner getInner() {\n+            if (_inner == null) {\n+                _inner = new Inner();\n+            }\n+\n+            return _inner;\n+        }\n+\n+        public void setInner(Inner in) {\n+            _inner = in;\n+        }\n+\n+        public Inner getNullInner() {\n+            return _nullInner;\n+        }\n+\n+        public void setNullInner(Inner in) {\n+            _nullInner = in;\n+        }\n+    }\n+\n+    /**\n+     *  Used internally for testing; must be public so Options can\n+     *  construct it.\n+     */\n+    public static class Inner2 extends Inner {\n+    }\n+}"},{"sha":"e432bebe1a5497c172ca582c6304468a6b9b4eaa","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestParameterTemplate.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestParameterTemplate.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestParameterTemplate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestParameterTemplate.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import junit.framework.*;\n+\n+import junit.textui.*;\n+\n+\n+/**\n+ *  <p>Tests the {@link ParameterTemplate} utility class.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class TestParameterTemplate extends TestCase {\n+    private ParameterTemplate templ = new ParameterTemplate();\n+\n+    public TestParameterTemplate(String test) {\n+        super(test);\n+    }\n+\n+    public void testParameters() {\n+        templ.append(\"{foo$${foo}bar{${bar}}biz baz$\");\n+        templ.append(\"{booz}booz${java.io.tmpdir}{ack}\");\n+\n+        templ.setParameter(\"foo\", \"X\");\n+        templ.setParameter(\"bar\", \"Y\");\n+        templ.setParameter(\"booz\", \"Z\");\n+\n+        String tmpdir = System.getProperty(\"java.io.tmpdir\");\n+        assertEquals(\"{foo$Xbar{Y}biz bazZbooz\" + tmpdir + \"{ack}\",\n+            templ.toString());\n+\n+        templ.clearParameters();\n+        templ.setParameter(\"foo\", \"AA\");\n+        templ.setParameter(\"bar\", \"BB\");\n+        templ.setParameter(\"booz\", \"CC\");\n+        assertEquals(\"{foo$AAbar{BB}biz bazCCbooz\" + tmpdir + \"{ack}\",\n+            templ.toString());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestParameterTemplate.class);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+}"},{"sha":"3d293f1f145b196b506c3399533da757050b7b3f","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","status":"added","additions":406,"deletions":0,"changes":406,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,406 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import junit.framework.*;\n+\n+import org.apache.openjpa.lib.util.FormatPreservingProperties.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+// things to test:\n+// - delimiters in keys\n+// - escape chars, including \\:, \\= in files (as generated by Properties)\n+// - unicode\n+// - non-String keys / vals\n+// - list() method behavior\n+public class TestPropertiesParser extends TestCase {\n+    public void testSimpleProperties() throws IOException {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"key: value\\n\");\n+        buf.append(\"key2: value2\"); // no EOL -- this is intentional\n+\n+        Properties p = toProperties(buf.toString());\n+        assertProperties(new String[][] {\n+                { \"key\", \"value\" },\n+                { \"key2\", \"value2\" }\n+            }, p);\n+    }\n+\n+    public void testComments() throws IOException {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"# this is a comment\\n\");\n+        buf.append(\" # another one, with leading whitespace\t\\n\");\n+        buf.append(\" \t# \tand more with interesting whitespace\t\\n\");\n+        buf.append(\"! and with a ! delimiter\\n\");\n+        buf.append(\"! and with escape \\t chars\\n\");\n+        buf.append(\"#and a comment with no whitespace\\n\");\n+\n+        Properties p = toProperties(buf.toString());\n+        assertEquals(0, p.size());\n+    }\n+\n+    public void testMixedContent() throws IOException {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"# this is a comment\\n\");\n+        buf.append(\" # another one, with leading whitespace\t\\n\");\n+        buf.append(\"foo: bar#baz\\n\");\n+        buf.append(\"! and with a ! delimiter\\n\");\n+        buf.append(\"! and with escape \\t chars\\n\");\n+\n+        Properties p = toProperties(buf.toString());\n+        assertProperties(new String[][] {\n+                { \"foo\", \"bar#baz\" }\n+            }, p);\n+    }\n+\n+    public void testMultiLineInput() throws IOException {\n+        String s = \"foo: bar\\\\\\n\" + \"more line goes here\";\n+        Properties p = toProperties(s);\n+        assertProperties(new String[][] {\n+                { \"foo\", \"barmore line goes here\" }\n+            }, p);\n+    }\n+\n+    public void testEmptyLines() throws IOException {\n+        Properties p = toProperties(\"\\nfoo: bar\\n\\nbaz: val\");\n+        assertProperties(new String[][] {\n+                { \"foo\", \"bar\" },\n+                { \"baz\", \"val\" }\n+            }, p);\n+    }\n+\n+    public void testAddProperties() throws IOException {\n+        // intentionally left out the trailing end line\n+        String s = \"foo: bar\\nbaz: val\";\n+        Properties p = toProperties(s);\n+        assertProperties(new String[][] {\n+                { \"foo\", \"bar\" },\n+                { \"baz\", \"val\" }\n+            }, p);\n+\n+        p.put(\"new-key\", \"val1\");\n+        p.put(\"new-key-2\", \"val2\");\n+        p.put(\"another-new-key\", \"val3\");\n+        assertRoundTrip(s + \"\\nnew-key: val1\\nnew-key-2: val2\\n\" +\n+            \"another-new-key: val3\\n\", p);\n+    }\n+\n+    public void testAddAndMutateProperties() throws IOException {\n+        // intentionally left out the trailing end line\n+        Properties p = toProperties(\"foo: bar\\nbaz: val\");\n+        assertProperties(new String[][] {\n+                { \"foo\", \"bar\" },\n+                { \"baz\", \"val\" }\n+            }, p);\n+\n+        p.put(\"new-key\", \"new value\");\n+        p.put(\"foo\", \"barbar\");\n+        assertRoundTrip(\"foo: barbar\\nbaz: val\\nnew-key: new value\\n\", p);\n+    }\n+\n+    public void testEscapedEquals() throws IOException {\n+        Properties p = toProperties(\"foo=bar\\\\=WARN,baz\\\\=TRACE\");\n+        assertProperties(new String[][] {\n+                { \"foo\", \"bar=WARN,baz=TRACE\" }\n+            }, p);\n+    }\n+\n+    public void testLineTypes() throws IOException {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"   !comment\\n \\t  \\nname = no\\n    \" +\n+            \"#morec\\tomm\\\\\\nents\\n\\n  dog=no\\\\cat   \\nburps    \" +\n+            \":\\ntest=\\ndate today\\n\\n\\nlong\\\\\\n   value=tryin \\\\\\n \" +\n+            \"gto\\n4:vier\\nvier     :4\");\n+\n+        Properties p = toProperties(buf.toString());\n+        assertProperties(new String[][] {\n+                { \"name\", \"no\" },\n+                { \"ents\", \"\" },\n+                { \"dog\", \"nocat   \" },\n+                { \"burps\", \"\" },\n+                { \"test\", \"\" },\n+                { \"date\", \"today\" },\n+                { \"longvalue\", \"tryin gto\" },\n+                { \"4\", \"vier\" },\n+                { \"vier\", \"4\" },\n+            }, p);\n+    }\n+\n+    public void testSpecialChars() throws Throwable {\n+        testSpecialChars(false, true);\n+        testSpecialChars(true, true);\n+        testSpecialChars(false, false);\n+        testSpecialChars(true, false);\n+    }\n+\n+    /**\n+     *  Test that special characters work.\n+     *\n+     *  @param formattingProps  if true, test against the\n+     *                           FormatPreservingProperties, otherwise test\n+     *                           against a normal Properties instance (for\n+     *                           validation of the test case).\n+     *  @param value            whether to test the key or the value\n+     */\n+    public void testSpecialChars(boolean formattingProps, boolean value)\n+        throws Throwable {\n+        List valueList = new ArrayList(Arrays.asList(\n+                    new String[] {\n+                        \"xxyy\", \"xx\\\\yy\", \"xx\\nyy\", \"xx\\\\nyy\", \"xx\\tyy\",\n+                        \"xx\\\\tyy\", \"xx\\ryy\", \"xx\\\\ryy\", \"xx\\fyy\", \"xx\\\\fyy\",\n+                        \"xx\\r\\n\\\\\\t\\r\\t\\nyy\", \"xx\\\\r\\n\\\\\\t\\\\r\\t\\\\nyy\",\n+                        \"xx\\r\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\t\\r\\t\\nyy\",\n+                        \"C:\\\\Program Files\\\\Some Application\\\\OpenJPA\\\\My File.dat\",\n+                    }));\n+\n+        // also store every individual character\n+        for (char c = 'a'; c < 'Z'; c++) {\n+            valueList.add(new String(new char[] { c }));\n+            valueList.add(new String(new char[] { c, '\\\\', c }));\n+            valueList.add(new String(new char[] { '\\\\', c }));\n+        }\n+\n+        String[] values = (String[]) valueList.toArray(new String[0]);\n+\n+        final String dummy = \"XXX\";\n+\n+        for (int i = 0; i < values.length; i++) {\n+            // test special characters in either keys or values\n+            String val = value ? values[i] : dummy;\n+            String key = value ? dummy : values[i];\n+\n+            Properties p = formattingProps ? new FormatPreservingProperties()\n+                                           : new Properties();\n+\n+            if (p instanceof FormatPreservingProperties) {\n+                // set these properties so we behave the same way as\n+                // java.util.Properties\n+                ((FormatPreservingProperties) p).setDefaultEntryDelimiter('=');\n+                ((FormatPreservingProperties) p).setAddWhitespaceAfterDelimiter(false);\n+            }\n+\n+            p.setProperty(key, val);\n+\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            p.store(out, null);\n+\n+            Properties copy = new Properties();\n+            copy.setProperty(key, val);\n+\n+            ByteArrayOutputStream copyOut = new ByteArrayOutputStream();\n+            copy.store(copyOut, null);\n+\n+            p = formattingProps ? new FormatPreservingProperties()\n+                                : new Properties();\n+\n+            InputStream in = new BufferedInputStream(new ByteArrayInputStream(\n+                        out.toByteArray()));\n+\n+            try {\n+                // make sure that the 2 properties serialized are the same\n+                String copyOutString = stripComments(copyOut.toByteArray());\n+                String outString = stripComments(out.toByteArray());\n+                assertEquals(copyOutString, outString);\n+\n+                p.load(in);\n+\n+                assertNotNull(\"Property \\\"\" + key + \"\\\" was null\",\n+                    p.getProperty(key));\n+                assertEquals(val.trim(), p.getProperty(key).trim());\n+            } catch (Throwable ioe) {\n+                if (!formattingProps) {\n+                    throw ioe;\n+                }\n+\n+                // bug (1211, ioe,\n+                // \t\"Cannot store backslash in FormatPreservingProperties\");\n+                throw ioe;\n+            }\n+        }\n+    }\n+\n+    static Character randomChar() {\n+        char[] TEST_CHAR_ARRAY = new char[] {\n+                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+                'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+                '1', '2', '3', '4', '5', '6', '7', '8', '9'\n+            };\n+\n+        return new Character(TEST_CHAR_ARRAY[(int) (Math.random() * TEST_CHAR_ARRAY.length)]);\n+    }\n+\n+    static String randomString(int len) {\n+        StringBuffer buf = new StringBuffer();\n+\n+        for (int i = 0; i < ((int) (Math.random() * len) + 1); i++)\n+            buf.append(randomChar());\n+\n+        return buf.toString();\n+    }\n+\n+    public void testEquivalentStore() throws IOException {\n+        Properties p1 = new Properties();\n+        FormatPreservingProperties p2 = new FormatPreservingProperties();\n+\n+        ((FormatPreservingProperties) p2).setDefaultEntryDelimiter('=');\n+        ((FormatPreservingProperties) p2).setAddWhitespaceAfterDelimiter(false);\n+\n+        String[] values = new String[] {\n+                \"x\", \"x\\ny\", \"x\\\\ny\", \"x\\ty\", \"x\\\\ty\", \"x\\fy\", \"x\\\\fy\", \"x\\ry\",\n+                \"x\\\\ry\", \"C:\\\\Foo Bar\\\\Baz\", randomString(5).replace('a', '\\\\'),\n+                randomString(500).replace('a', '\\\\'),\n+                randomString(5000).replace('a', '\\\\'),\n+            };\n+\n+        for (int i = 0; i < values.length; i++) {\n+            p1.clear();\n+            p2.clear();\n+\n+            p1.setProperty(\"xxx\", values[i]);\n+            p2.setProperty(\"xxx\", values[i]);\n+\n+            ByteArrayOutputStream out1 = new ByteArrayOutputStream();\n+            ByteArrayOutputStream out2 = new ByteArrayOutputStream();\n+\n+            p1.store(out1, null);\n+            p2.store(out2, null);\n+\n+            String s1 = new String(out1.toByteArray());\n+            String s2 = new String(out2.toByteArray());\n+\n+            assertTrue(\"Expected <\" + s1 + \"> but was <\" + s2 + \">\",\n+                s1.indexOf(s2) != -1);\n+        }\n+    }\n+\n+    static String stripComments(byte[] bytes) throws IOException {\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(\n+                    new ByteArrayInputStream(bytes)));\n+        StringBuffer sbuf = new StringBuffer();\n+        String line;\n+\n+        while ((line = reader.readLine()) != null) {\n+            // skip comments\n+            if (line.trim().startsWith(\"#\")) {\n+                continue;\n+            }\n+\n+            sbuf.append(line);\n+            sbuf.append('\\n');\n+        }\n+\n+        return sbuf.toString();\n+    }\n+\n+    public void testDuplicateProperties() throws IOException {\n+        FormatPreservingProperties p = new FormatPreservingProperties();\n+\n+        try {\n+            toProperties(\"foo=bar\\nfoo=baz\", p);\n+            fail(\"expected duplicate keys to cause exception\");\n+        } catch (DuplicateKeyException e) {\n+            // expected\n+        }\n+\n+        // now test the expected behavior when duplicates are allowed.\n+        p = new FormatPreservingProperties();\n+        p.setAllowDuplicates(true);\n+        toProperties(\"foo=bar\\nfoo=baz\", p);\n+        assertProperties(new String[][] {\n+                { \"foo\", \"baz\" }\n+            }, p);\n+    }\n+\n+    public void testMultipleLoads() throws IOException {\n+        String props = \"foo=bar\\nbaz=quux\";\n+        String props2 = \"a=b\\nc=d\";\n+        Properties vanilla = new Properties();\n+        vanilla.load(new BufferedInputStream(new StringBufferInputStream(props)));\n+        vanilla.load(new BufferedInputStream(\n+                new StringBufferInputStream(props2)));\n+\n+        Properties p = new FormatPreservingProperties();\n+        p.load(new BufferedInputStream(new StringBufferInputStream(props)));\n+        p.load(new BufferedInputStream(new StringBufferInputStream(props2)));\n+        assertPropertiesSame(vanilla, p);\n+    }\n+\n+    protected FormatPreservingProperties toProperties(String s)\n+        throws IOException {\n+        return toProperties(s, new FormatPreservingProperties());\n+    }\n+\n+    protected FormatPreservingProperties toProperties(String s,\n+        FormatPreservingProperties p) throws IOException {\n+        Properties vanilla = new Properties();\n+        vanilla.load(new StringBufferInputStream(s));\n+\n+        p.load(new StringBufferInputStream(s));\n+        assertRoundTrip(s, p);\n+\n+        assertPropertiesSame(vanilla, p);\n+\n+        return p;\n+    }\n+\n+    private void assertRoundTrip(String s, Properties p)\n+        throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        p.store(out, null);\n+        assertEquals(s, out.toString());\n+\n+        // also check serializable\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        new ObjectOutputStream(bout).writeObject(p);\n+\n+        try {\n+            FormatPreservingProperties deserialized = (FormatPreservingProperties) new ObjectInputStream(new ByteArrayInputStream(\n+                        bout.toByteArray())).readObject();\n+            assertEquals(p, deserialized);\n+\n+            out = new ByteArrayOutputStream();\n+            deserialized.store(out, null);\n+            assertEquals(s, out.toString());\n+        } catch (ClassNotFoundException cnfe) {\n+            fail(cnfe + \"\");\n+        }\n+    }\n+\n+    public static void assertEquals(String expected, String actual) {\n+        if (expected == actual) {\n+            return;\n+        }\n+\n+        if ((expected == null) || !expected.equals(actual)) {\n+            fail(\"Expected <\" + expected + \"> but was <\" + actual + \">\");\n+        }\n+    }\n+\n+    private void assertPropertiesSame(Properties vanilla, Properties p) {\n+        assertEquals(vanilla, p);\n+    }\n+\n+    protected void assertProperties(String[][] strings, Properties p) {\n+        for (int i = 0; i < strings.length; i++)\n+            assertEquals(strings[i][1], p.get(strings[i][0]));\n+\n+        assertEquals(strings.length, p.size());\n+    }\n+}"},{"sha":"1094668eb22ac7454ce5973ad16b5b8cec5607ec","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestReferenceSet.java","status":"added","additions":135,"deletions":0,"changes":135,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestReferenceSet.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestReferenceSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestReferenceSet.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import junit.framework.*;\n+\n+import junit.textui.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Tests the {@link ReferenceHashSet}.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class TestReferenceSet extends TestCase {\n+    private ReferenceHashSet _coll = new ReferenceHashSet(ReferenceHashSet.WEAK);\n+    private Object _heldValue = new Integer(2);\n+\n+    public TestReferenceSet(String test) {\n+        super(test);\n+    }\n+\n+    public void setUp() {\n+        _coll.add(_heldValue);\n+        _coll.add(new Integer(1));\n+    }\n+\n+    /**\n+     *  Tests basic add/contains/remove functionality.\n+     */\n+    public void testBasics() {\n+        Collection coll = new ReferenceHashSet(ReferenceHashSet.WEAK);\n+        assertEquals(0, coll.size());\n+        assertTrue(!coll.contains(\"foo\"));\n+\n+        assertTrue(coll.add(\"foo\"));\n+        assertEquals(1, coll.size());\n+        assertTrue(coll.contains(\"foo\"));\n+        assertEquals(\"foo\", coll.iterator().next());\n+\n+        assertTrue(!coll.remove(\"bar\"));\n+        assertEquals(1, coll.size());\n+        assertTrue(coll.remove(\"foo\"));\n+        assertEquals(0, coll.size());\n+        assertTrue(coll.isEmpty());\n+    }\n+\n+    /**\n+     *  Test that values with strong references are not gc'd.\n+     */\n+    public void testHeldReference() {\n+        if (JavaVersions.VERSION >= 5) {\n+            return;\n+        }\n+\n+        System.gc();\n+        System.gc();\n+        assertTrue(_coll.contains(_heldValue));\n+    }\n+\n+    /**\n+     *  Test that weak references are gc'd.\n+      */\n+    public void testWeakReference() {\n+        if (JavaVersions.VERSION >= 5) {\n+            return;\n+        }\n+\n+        System.gc();\n+        System.gc();\n+        assertTrue(!_coll.contains(new Integer(1)));\n+        assertEquals(1, _coll.size());\n+\n+        int size = 0;\n+\n+        for (Iterator itr = _coll.iterator(); itr.hasNext(); size++)\n+            assertEquals(_heldValue, itr.next());\n+\n+        assertEquals(1, size);\n+\n+        // run a mutator method to ensure expired elements are removed\n+        _coll.add(\"foo\");\n+        assertEquals(2, _coll.size());\n+        assertTrue(_coll.contains(\"foo\"));\n+        assertTrue(_coll.contains(_heldValue));\n+        assertTrue(!_coll.contains(new Integer(1)));\n+    }\n+\n+    /**\n+     *  Test that values that have been replaced aren't expired.\n+     */\n+    public void testChangeValue() {\n+        if (JavaVersions.VERSION >= 5) {\n+            return;\n+        }\n+\n+        Object held = new Integer(1);\n+        assertTrue(_coll.remove(held));\n+        assertTrue(_coll.add(held));\n+        System.gc();\n+        System.gc();\n+\n+        // run a mutator to clear expired references\n+        _coll.add(\"foo\");\n+        assertTrue(_coll.contains(held));\n+    }\n+\n+    /**\n+     *  Used to test inherited functionality.\n+     */\n+    private static final class Node {\n+        public int hashCode() {\n+            return 1;\n+        }\n+\n+        public boolean equals(Object other) {\n+            return true;\n+        }\n+    }\n+}"},{"sha":"91be3eac0af0cdaa1e2d8fda5548fa95d841965a","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestSimpleRegex.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestSimpleRegex.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestSimpleRegex.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestSimpleRegex.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import junit.framework.*;\n+\n+import junit.textui.*;\n+\n+\n+/**\n+ *  <p>Tests simple regex for use in in-memory query execution.</p>\n+ *\n+ *  @author Greg Campbell\n+ */\n+public class TestSimpleRegex extends TestCase {\n+    private boolean matchExpr(String target, String expr, boolean caseInsens) {\n+        SimpleRegex re = new SimpleRegex(expr, caseInsens);\n+\n+        return re.matches(target);\n+    }\n+\n+    public void testWildcards() {\n+        assertTrue(matchExpr(\"Hello\", \"Hello\", false));\n+        assertFalse(matchExpr(\"Hello\", \"Bye\", false));\n+        assertFalse(matchExpr(\"Hello\", \"ByeBye\", false));\n+        assertFalse(matchExpr(\"Hello\", \"Hellooo\", false));\n+        assertFalse(matchExpr(\"Hello\", \"HHello\", false));\n+        assertTrue(matchExpr(\"Hello\", \"H.llo\", false));\n+        assertTrue(matchExpr(\"Hello\", \"Hell.*\", false));\n+        assertTrue(matchExpr(\"Yo Hello\", \".*ello\", false));\n+        assertTrue(matchExpr(\"Hello\", \".*ello\", false));\n+        assertTrue(matchExpr(\"Hello\", \".*ell.*\", false));\n+        assertTrue(matchExpr(\"Hellow\", \".*ell.*\", false));\n+        assertTrue(matchExpr(\"Hello\", \"Hel.*lo\", false));\n+        assertTrue(matchExpr(\"HelYolo\", \"Hel.*lo\", false));\n+        assertTrue(matchExpr(\"Hello\", \"H.*lo\", false));\n+        assertFalse(matchExpr(\"Hellowe\", \"H.*lo\", false));\n+        assertTrue(matchExpr(\"Hello\", \"h.*lo\", true));\n+        assertFalse(matchExpr(\"Hello\", \"h.*lo\", false));\n+        assertTrue(matchExpr(\"The quick brown fox jumped over the lazy dog\",\n+                \"The .*brown.*dog\", false));\n+        assertTrue(matchExpr(\"The quick brown fox jumped over the lazy dog\",\n+                \"The .*br.wn.*d.g\", false));\n+        assertTrue(matchExpr(\"the quick BRown fox jumped over the lazy dog\",\n+                \"The .*br.wn.*d.g\", true));\n+        assertFalse(matchExpr(\"The quick brown fox jumped over the lazy dog\",\n+                \"The .*brown.*dogg\", false));\n+        assertFalse(matchExpr(\"The quick brown fox jumped over the lazy dog\",\n+                \"TThe .*brown.*dogg\", false));\n+\n+        assertFalse(matchExpr(\"Yo Hellow\", \".*ello\", false));\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(TestSimpleRegex.class);\n+    }\n+}"},{"sha":"6c5762bd5b67e17031052c91fc8ed9e820870081","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestTemporaryClassLoader.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestTemporaryClassLoader.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestTemporaryClassLoader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestTemporaryClassLoader.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import junit.framework.*;\n+\n+import java.util.*;\n+\n+\n+public class TestTemporaryClassLoader extends TestCase {\n+    public void testTemporaryClassLoader() throws Exception {\n+        Set s = new HashSet();\n+\n+        for (int i = 0; i < 2; i++) {\n+            ClassLoader loader = new TemporaryClassLoader(getClass()\n+                                                              .getClassLoader());\n+            Class cls = Class.forName(\"org.apache.openjpa.lib.util.TempClass\",\n+                    true, loader);\n+            s.add(cls);\n+            assertEquals(loader, cls.getClassLoader());\n+            assertEquals(i + 1, s.size());\n+        }\n+    }\n+}\n+\n+\n+class TempClass {\n+}"},{"sha":"7cc87988b7e825306ae42033b733561dba8ed308","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestTypedProperties.java","status":"added","additions":110,"deletions":0,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestTypedProperties.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestTypedProperties.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestTypedProperties.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import junit.framework.*;\n+\n+import junit.textui.*;\n+\n+\n+/**\n+ *  <p>Tests the {@link TypedProperties} type.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class TestTypedProperties extends TestCase {\n+    private TypedProperties _props = null;\n+    private TypedProperties _defs = null;\n+\n+    public TestTypedProperties(String test) {\n+        super(test);\n+    }\n+\n+    public void setUp() {\n+        _props = new TypedProperties();\n+        _props.setProperty(\"bool\", \"true\");\n+        _props.setProperty(\"int\", \"1\");\n+        _props.setProperty(\"long\", \"2\");\n+        _props.setProperty(\"float\", \"1.1\");\n+        _props.setProperty(\"double\", \"2.2\");\n+\n+        _defs = new TypedProperties(_props);\n+    }\n+\n+    /**\n+     *  Tests basic typed gets.\n+     */\n+    public void testTypes() {\n+        assertTrue(_props.getBooleanProperty(\"bool\"));\n+        assertEquals(1, _props.getIntProperty(\"int\"));\n+        assertEquals(2L, _props.getLongProperty(\"long\"));\n+        assertEquals(1.1F, _props.getFloatProperty(\"float\"), 0.01F);\n+        assertEquals(2.2D, _props.getDoubleProperty(\"double\"), 0.01D);\n+        assertEquals(\"2.2\", _props.getProperty(\"double\"));\n+    }\n+\n+    /**\n+     *  Tests the defaults returned for missing keys.\n+     */\n+    public void testNoDefaults() {\n+        assertTrue(!_props.getBooleanProperty(\"bool2\"));\n+        assertEquals(0, _props.getIntProperty(\"int2\"));\n+        assertEquals(0L, _props.getLongProperty(\"long2\"));\n+        assertEquals(0F, _props.getFloatProperty(\"float2\"), 0F);\n+        assertEquals(0D, _props.getDoubleProperty(\"double2\"), 0D);\n+        assertEquals(null, _props.getProperty(\"double2\"));\n+    }\n+\n+    /**\n+     *  Tests the defaults returned by keys found in the default\n+     *  backing properties instance.\n+     */\n+    public void testDefaults() {\n+        assertTrue(_defs.getBooleanProperty(\"bool\"));\n+        assertEquals(1, _defs.getIntProperty(\"int\"));\n+        assertEquals(2L, _defs.getLongProperty(\"long\"));\n+        assertEquals(1.1F, _defs.getFloatProperty(\"float\"), 0.01F);\n+        assertEquals(2.2D, _defs.getDoubleProperty(\"double\"), 0.01D);\n+        assertEquals(\"2.2\", _defs.getProperty(\"double\"));\n+    }\n+\n+    /**\n+     *  Tests that given defaults works.\n+     */\n+    public void testGivenDefaults() {\n+        assertTrue(_props.getBooleanProperty(\"bool2\", true));\n+        assertEquals(1, _props.getIntProperty(\"int2\", 1));\n+        assertEquals(2L, _props.getLongProperty(\"long2\", 2L));\n+        assertEquals(1.1F, _props.getFloatProperty(\"float2\", 1.1F), 0.01F);\n+        assertEquals(2.2D, _props.getDoubleProperty(\"double2\", 2.2D), 0.01D);\n+        assertEquals(\"2.2\", _props.getProperty(\"double2\", \"2.2\"));\n+\n+        assertTrue(_defs.getBooleanProperty(\"bool\", false));\n+        assertEquals(1, _defs.getIntProperty(\"int\", 2));\n+        assertEquals(2L, _defs.getLongProperty(\"long\", 3L));\n+        assertEquals(1.1F, _defs.getFloatProperty(\"float\", 2.2F), 0.01F);\n+        assertEquals(2.2D, _defs.getDoubleProperty(\"double\", 3.3D), 0.01D);\n+        assertEquals(\"2.2\", _defs.getProperty(\"double\", \"3.3\"));\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestTypedProperties.class);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+}"},{"sha":"86250eecd6135a1d99706b91d0079324bd9783a8","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestUUIDGenerator.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestUUIDGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestUUIDGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestUUIDGenerator.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import junit.framework.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Test UUID generation.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class TestUUIDGenerator extends TestCase {\n+    public void testUniqueString() {\n+        Set seen = new HashSet();\n+\n+        for (int i = 0; i < 1000; i++)\n+            assertTrue(seen.add(UUIDGenerator.nextString()));\n+    }\n+\n+    public void testUniqueHex() {\n+        Set seen = new HashSet();\n+\n+        for (int i = 0; i < 1000; i++)\n+            assertTrue(seen.add(UUIDGenerator.nextHex()));\n+    }\n+}"},{"sha":"a4cd1a1b6721df419f19438984a56ad9c0df292b","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestConcurrentMap.java","status":"added","additions":155,"deletions":0,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestConcurrentMap.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestConcurrentMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestConcurrentMap.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.util.concurrent;\n+\n+import junit.framework.*;\n+\n+import junit.textui.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Tests the methods of {@link ConcurrentMap}.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class TestConcurrentMap extends TestCase {\n+    private static final int ENTRIES = 333;\n+    private static final int SLEEP = 3;\n+    private ConcurrentMap[] _maps = new ConcurrentMap[] {\n+            new ConcurrentHashMap(),\n+            new ConcurrentReferenceHashMap(ReferenceMap.HARD, ReferenceMap.HARD),\n+        };\n+\n+    public void setUp() {\n+        for (int i = 0; i < ENTRIES; i++) {\n+            for (int j = 0; j < _maps.length; j++) {\n+                int key = (j * ENTRIES) + i;\n+                _maps[j].put(new Integer(key), \"v\" + key);\n+            }\n+        }\n+    }\n+\n+    public void testRemoveRandom() {\n+        Set keys = new TreeSet();\n+\n+        for (int i = 0; i < ENTRIES; i++)\n+            for (int j = 0; j < _maps.length; j++)\n+                assertTrue(removeRandom(_maps[j], keys));\n+\n+        postRemoveTest(keys);\n+    }\n+\n+    private static boolean removeRandom(ConcurrentMap map, Set keys) {\n+        Map.Entry rem = map.removeRandom();\n+\n+        return (rem != null) && rem.getValue().equals(\"v\" + rem.getKey()) &&\n+        keys.add(rem.getKey());\n+    }\n+\n+    private void postRemoveTest(Set keys) {\n+        for (int i = 0; i < _maps.length; i++) {\n+            assertTrue(_maps[i].isEmpty());\n+            assertTrue(!_maps[i].containsKey(new Integer((ENTRIES * i) + i)));\n+        }\n+\n+        assertEquals(keys.toString(), ENTRIES * _maps.length, keys.size());\n+    }\n+\n+    public synchronized void testRemoveRandomThreaded()\n+        throws InterruptedException {\n+        Set keys = Collections.synchronizedSet(new TreeSet());\n+        RemoveRandomRunnable[] runs = new RemoveRandomRunnable[ENTRIES * _maps.length];\n+\n+        for (int i = 0; i < ENTRIES; i++)\n+            for (int j = 0; j < _maps.length; j++)\n+                runs[(j * ENTRIES) + i] = new RemoveRandomRunnable(_maps[j],\n+                        keys);\n+\n+        for (int i = 0; i < runs.length; i++)\n+            new Thread(runs[i]).start();\n+\n+        Thread.currentThread().sleep(SLEEP * ENTRIES * _maps.length);\n+\n+        for (int i = 0; i < runs.length; i++) {\n+            assertTrue(String.valueOf(i), !runs[i].error);\n+\n+            if (runs[i].interrupted) {\n+                throw new InterruptedException(String.valueOf(i));\n+            }\n+        }\n+\n+        postRemoveTest(keys);\n+    }\n+\n+    public void testIterate() {\n+        iterationTest(false);\n+    }\n+\n+    private List iterationTest(boolean random) {\n+        Set keys = new TreeSet();\n+        List ordered = new ArrayList(200);\n+\n+        for (int i = 0; i < _maps.length; i++) {\n+            Iterator itr = (random) ? _maps[i].randomEntryIterator()\n+                                    : _maps[i].entrySet().iterator();\n+\n+            while (itr.hasNext()) {\n+                Map.Entry entry = (Map.Entry) itr.next();\n+                assertEquals(\"v\" + entry.getKey(), entry.getValue());\n+                assertTrue(keys + \":: \" + _maps[i].getClass() + \"::\" +\n+                    entry.getKey() + \"::\" + entry.getValue(),\n+                    keys.add(entry.getKey()));\n+                ordered.add(entry.getKey());\n+            }\n+        }\n+\n+        assertEquals(keys.toString(), ENTRIES * _maps.length, keys.size());\n+\n+        return ordered;\n+    }\n+\n+    public void testRandomIterate() {\n+        List l1 = iterationTest(true);\n+        List l2 = iterationTest(true);\n+        assertTrue(!l1.equals(l2));\n+    }\n+\n+    private static class RemoveRandomRunnable implements Runnable {\n+        public boolean error = false;\n+        public boolean interrupted = false;\n+        private final ConcurrentMap _map;\n+        private final Set _keys;\n+\n+        public RemoveRandomRunnable(ConcurrentMap map, Set keys) {\n+            _map = map;\n+            _keys = keys;\n+        }\n+\n+        public synchronized void run() {\n+            try {\n+                Thread.currentThread().sleep((long) (Math.random() * SLEEP));\n+            } catch (InterruptedException ie) {\n+                interrupted = true;\n+            }\n+\n+            error = !removeRandom(_map, _keys);\n+        }\n+    }\n+}"},{"sha":"7033caaf83cd2e8c14719695eb730e0dafe8bf6d","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/testlocalizer/LocalizerTestHelper.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/testlocalizer/LocalizerTestHelper.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/testlocalizer/LocalizerTestHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/testlocalizer/LocalizerTestHelper.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.util.testlocalizer;\n+\n+\n+/**\n+ *  <p>Helper class used so that the localizer.properties file in this package\n+ *  can be accessed.  The properties cannot be in the same package (serp.util)\n+ *  as the main tester class because other utilities in the source line might\n+ *  eventually want to use a localizer.properties file for that package.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class LocalizerTestHelper {\n+}"},{"sha":"6788632037547de42f5d13e0a9c6e87f2481ab82","filename":"openjpa-lib/src/test/resources/localizer.properties","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/resources/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/resources/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/resources/localizer.properties?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1 @@\n+test.systemlocal\t\tsystemvalue1"},{"sha":"25dea07de493c37ae792fba1a9a7f7b752676393","filename":"openjpa-lib/src/test/resources/org/apache/openjpa/lib/conf/test/localizer.properties","status":"added","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/resources/org/apache/openjpa/lib/conf/test/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/resources/org/apache/openjpa/lib/conf/test/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/resources/org/apache/openjpa/lib/conf/test/localizer.properties?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,12 @@\n+testKey-name: name\n+testKey-desc: desc\n+testKey-type: General\n+sysKey-name: name\n+sysKey-desc: desc\n+sysKey-type: General\n+pluginKey-name: name\n+pluginKey-desc: desc\n+pluginKey-type: General\n+objectKey-name: name\n+objectKey-desc: desc\n+objectKey-type: General"},{"sha":"930196f0f8950bb0c3c25196da6bf2616c7bc9eb","filename":"openjpa-lib/src/test/resources/org/apache/openjpa/lib/util/testlocalizer/localizer.properties","status":"added","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/resources/org/apache/openjpa/lib/util/testlocalizer/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/resources/org/apache/openjpa/lib/util/testlocalizer/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/resources/org/apache/openjpa/lib/util/testlocalizer/localizer.properties?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,2 @@\n+test.local1\t\tvalue1\n+test.local2\t\tvalue2 {0} sep {1}"},{"sha":"93b786788cf557db2fd402d5d816249371601c9b","filename":"openjpa-lib/src/test/resources/org/apache/openjpa/lib/util/testlocalizer/localizer_de_DE.properties","status":"added","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/resources/org/apache/openjpa/lib/util/testlocalizer/localizer_de_DE.properties","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/openjpa-lib/src/test/resources/org/apache/openjpa/lib/util/testlocalizer/localizer_de_DE.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/resources/org/apache/openjpa/lib/util/testlocalizer/localizer_de_DE.properties?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,2 @@\n+test.local1\t\tvalue1_de\n+test.local2\t\tvalue2_de {0} sep {1}"},{"sha":"12069c696b8caf6ee3aa7568385b78adbba176f9","filename":"pom.xml","status":"added","additions":179,"deletions":0,"changes":179,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/pom.xml?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,179 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\t\t<modelVersion>4.0.0</modelVersion>\n+\t<groupId>org.apache.openjpa</groupId>\n+\t<artifactId>openjpa</artifactId>\n+\t<packaging>pom</packaging>\n+\n+\t<name>OpenJPA</name>\n+\t<description>OpenJPA</description>\n+\t<version>0.0.1</version>\n+\t<url>http://incubator.apache.org/projects/openjpa</url>\n+\t<issueManagement>\n+\t\t<system>jira</system>\n+\t\t<url>http://issues.apache.org/jira/browse/OPENJPA</url>\n+\t</issueManagement>\n+\t<inceptionYear>2006</inceptionYear>\n+\t<mailingLists>\n+\t\t<mailingList>\n+\t\t\t<name>OpenJPA Developer List</name>\n+\t\t\t<subscribe>open-jpa-dev-subscribe@incubator.apache.org</subscribe>\n+\t\t\t<unsubscribe>open-jpa-dev-unsubscribe@incubator.apache.org</unsubscribe>\n+\t\t\t<post>open-jpa-dev@incubator.apache.org</post>\n+\t\t\t<archive>http://mail-archives.apache.org/mod_mbox/incubator-open-jpa-dev/</archive>\n+\t\t</mailingList>\n+\t\t<mailingList>\n+\t\t\t<name>OpenJPA Commits List</name>\n+\t\t\t<subscribe>open-jpa-commits-subscribe@incubator.apache.org</subscribe>\n+\t\t\t<unsubscribe>open-jpa-commits-unsubscribe@incubator.apache.org</unsubscribe>\n+\t\t\t<post>open-jpa-commits@incubator.apache.org</post>\n+\t\t\t<archive>http://mail-archives.apache.org/mod_mbox/incubator-open-jpa-commits/</archive>\n+\t\t</mailingList>\n+\t</mailingLists>\n+\t<developers>\n+\t\t<developer>\n+\t\t\t<name>Patrick Linskey</name>\n+\t\t\t<id>plinskey</id>\n+\t\t\t<organization>BEA Systems, Inc.</organization>\n+\t\t\t<email>plinskey@bea.com</email>\n+\t\t</developer>\n+\t\t<developer>\n+\t\t\t<name>Abe White</name>\n+\t\t\t<id>awhite</id>\n+\t\t\t<organization>BEA Systems, Inc.</organization>\n+\t\t\t<email>awhite@bea.com</email>\n+\t\t</developer>\n+\t\t<developer>\n+\t\t\t<name>Steve Kim</name>\n+\t\t\t<id>stkim</id>\n+\t\t\t<organization>BEA Systems, Inc.</organization>\n+\t\t\t<email>stkim@bea.com</email>\n+\t\t</developer>\n+\t\t<developer>\n+\t\t\t<name>Marc Prud'hommeaux</name>\n+\t\t\t<id>mprudhom</id>\n+\t\t\t<organization>BEA Systems, Inc.</organization>\n+\t\t\t<email>mprudhom@bea.com</email>\n+\t\t</developer>\n+\t</developers>\n+\t<licenses>\n+\t\t<license>\n+\t\t\t<name>Apache Software License 2.0</name>\n+\t\t\t<url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>\n+\t\t\t<distribution>repo</distribution>\n+\t\t</license>\n+\t</licenses>\n+\t<organization>\n+\t\t<name>Apache Software Foundation</name>\n+\t\t<url>http://www.apache.org</url>\n+\t</organization>\n+\t<scm>\n+\t\t<connection>scm:svn:http://svn.apache.org/repos/asf/incubator/openjpa/${pom.artifactId}</connection>\n+\t\t<developerConnection>scm:svn:https://svn.apache.org/repos/asf/incubator/openjpa/${pom.artifactId}</developerConnection>\n+\t\t<url>https://svn.apache.org/repos/asf/incubator/openjpa/${pom.artifactId}</url>\n+\t</scm>\n+<modules>\n+\t\n+\t\t<module>openjpa-lib</module>\n+\t\t<module>serp</module>\n+\t\t\n+\t</modules>\n+\t<repositories>\n+\t\n+\t\t<repository>\n+\t\t<id>central</id>\n+\t\t<name>Maven Repository Switchboard</name>\n+\t\t<url>http://www.ibiblio.org/maven2</url>\n+\t\t</repository>\n+\t\t\n+\t\n+\t\t<repository>\n+\t\t<id>swami</id>\n+\t\t<name>Swami repository</name>\n+\t\t<url>http://m2.ngbw.org</url>\n+\t\t</repository>\n+\t\t\n+\t\n+\t\t<repository>\n+\t\t<id>java-net</id>\n+\t\t<name>dev.java.net repository</name>\n+\t\t<url>https://maven-repository.dev.java.net/nonav/repository</url>\n+\t\t<layout>legacy</layout>\n+\t\t</repository>\n+\t\t\n+\t</repositories>\n+\t<dependencies>\n+\t\n+\t\t<dependency>\n+\t\t\n+\t\t\t<groupId>junit</groupId>\n+\t\t\t<artifactId>junit</artifactId>\n+\t\t\t<version>3.8.1</version>\n+\t\t\t<scope>compile</scope>\n+\t\t\t\n+\t\t</dependency>\n+\t\t\n+\t</dependencies>\n+\t<build>\n+\t\n+\t\t<plugins>\n+\t\t\n+\t\t\t<plugin>\n+\t\t\t\n+\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n+\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n+\t\t\t\t<configuration>\n+\t\t\t\t<source>1.5</source>\n+\t\t\t\t<target>1.5</target>\n+\t\t\t\t</configuration>\n+\t\t\t\t\n+\t\t\t</plugin>\n+\t\t\t\n+\t\t</plugins>\n+\t\t\n+\t</build>\n+\t\n+\t<reporting>\n+\t\t<plugins>\n+\t\t\t<plugin>\n+\t\t\t\t<artifactId>maven-surefire-plugin</artifactId>\n+\t\t\t</plugin>\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>org.codehaus.mojo</groupId>\n+\t\t\t\t<artifactId>taglist-maven-plugin</artifactId>\n+\t\t\t</plugin>\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>org.codehaus.mojo</groupId>\n+\t\t\t\t<artifactId>jxr-maven-plugin</artifactId>\n+\t\t\t\t<configuration>\n+\t\t\t\t\t<aggregate>true</aggregate>\n+\t\t\t\t</configuration>\n+\t\t\t</plugin>\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n+\t\t\t\t<artifactId>maven-javadoc-plugin</artifactId>\n+\t\t\t\t<configuration>\n+\t\t\t\t\t<aggregate>true</aggregate>\n+\t\t\t\t\t<linksource>true</linksource>\n+\t\t\t\t\t<links>\n+\t\t\t\t\t\t<link>http://java.sun.com/j2se/1.5.0/docs/api</link>\n+\t\t\t\t\t\t<link>http://java.sun.com/javaee/5/docs/api</link>\n+\t\t\t\t\t\t<link>http://jakarta.apache.org/commons/collections/api-release</link>\n+\t\t\t\t\t</links>\n+\t\t\t\t</configuration>\n+\t\t\t</plugin>\n+\t\t</plugins>\n+\t</reporting>\n+\t<distributionManagement>\n+\t\t<repository>\n+\t\t\t<id>bea-internal</id>\n+\t\t\t<name>Internal BEA OpenJPA test site</name>\n+\t\t\t<url>file:///${user.home}/web/devel/openjpa/dist</url>\n+\t\t</repository>\n+\t\t<site>\n+\t\t\t<id>bea-internal</id>\n+\t\t\t<name>Internal BEA OpenJPA test sit</name>\n+\t\t\t<url>file:///${user.home}/web/devel/openjpa/site</url>\n+\t\t</site>\n+\t</distributionManagement>\n+\n+</project>"},{"sha":"5bb7163194bd54871757c9b33d1616d46742a4fe","filename":"serp/pom.xml","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/pom.xml?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,41 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\t\t<modelVersion>4.0.0</modelVersion>\n+\t<groupId>org.apache.openjpa</groupId>\n+\t<artifactId>serp</artifactId>\n+\t<packaging>jar</packaging>\n+\n+\t<name>Serp</name>\n+\t<description>Serp</description>\n+\t<url>http://incubator.apache.org/projects/openjpa</url>\n+<parent>\n+\t\n+\t\t<groupId>org.apache.openjpa</groupId>\n+\t\t<artifactId>openjpa</artifactId>\n+\t\t<version>0.0.1</version>\n+\t\t\n+\t</parent>\n+\t<dependencies>\n+\t\n+\t\t\n+\t</dependencies>\n+\t<build>\n+\t\n+\t\t<plugins>\n+\t\t\n+\t\t\t<plugin>\n+\t\t\t\n+\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n+\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n+\t\t\t\t<configuration>\n+\t\t\t\t<source>1.3</source>\n+\t\t\t\t<target>1.3</target>\n+\t\t\t\t</configuration>\n+\t\t\t\t\n+\t\t\t</plugin>\n+\t\t\t\n+\t\t</plugins>\n+\t\t\n+\t</build>\n+\t\n+\n+</project>"},{"sha":"613678710c25fb71402ea27b1260fc2f1944534f","filename":"serp/src/main/java/serp/bytecode/ArrayInstruction.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ArrayInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ArrayInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ArrayInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Any array load or store instruction.  This class has\n+ *  no functionality beyond the {@link TypedInstruction} but is provided\n+ *  so that users can easily identify array instructions in code if\n+ *  need be.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public abstract class ArrayInstruction extends TypedInstruction {\n+    ArrayInstruction(Code owner) {\n+        super(owner);\n+    }\n+\n+    ArrayInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+}"},{"sha":"ab83f7b96a2e68463069f6cc6ddfcb8c9c84ecb0","filename":"serp/src/main/java/serp/bytecode/ArrayLoadInstruction.java","status":"added","additions":131,"deletions":0,"changes":131,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ArrayLoadInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ArrayLoadInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ArrayLoadInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+\n+/**\n+ *  <p>Loads a value from an array onto the stack.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class ArrayLoadInstruction extends ArrayInstruction {\n+    private static final Class[][] _mappings = new Class[][] {\n+            { boolean.class, int.class },\n+            { void.class, int.class },\n+        };\n+\n+    ArrayLoadInstruction(Code owner) {\n+        super(owner);\n+    }\n+\n+    ArrayLoadInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    public int getLogicalStackChange() {\n+        switch (getOpcode()) {\n+        case Constants.NOP:\n+            return 0;\n+\n+        default:\n+            return -1;\n+        }\n+    }\n+\n+    public int getStackChange() {\n+        switch (getOpcode()) {\n+        case Constants.DALOAD:\n+        case Constants.LALOAD:\n+        case Constants.NOP:\n+            return 0;\n+\n+        default:\n+            return -1;\n+        }\n+    }\n+\n+    public String getTypeName() {\n+        switch (getOpcode()) {\n+        case Constants.IALOAD:\n+            return int.class.getName();\n+\n+        case Constants.LALOAD:\n+            return long.class.getName();\n+\n+        case Constants.FALOAD:\n+            return float.class.getName();\n+\n+        case Constants.DALOAD:\n+            return double.class.getName();\n+\n+        case Constants.AALOAD:\n+            return Object.class.getName();\n+\n+        case Constants.BALOAD:\n+            return byte.class.getName();\n+\n+        case Constants.CALOAD:\n+            return char.class.getName();\n+\n+        case Constants.SALOAD:\n+            return short.class.getName();\n+\n+        default:\n+            return null;\n+        }\n+    }\n+\n+    public TypedInstruction setType(String type) {\n+        type = mapType(type, _mappings, true);\n+\n+        if (type == null) {\n+            return (TypedInstruction) setOpcode(Constants.NOP);\n+        }\n+\n+        switch (type.charAt(0)) {\n+        case 'i':\n+            return (TypedInstruction) setOpcode(Constants.IALOAD);\n+\n+        case 'l':\n+            return (TypedInstruction) setOpcode(Constants.LALOAD);\n+\n+        case 'f':\n+            return (TypedInstruction) setOpcode(Constants.FALOAD);\n+\n+        case 'd':\n+            return (TypedInstruction) setOpcode(Constants.DALOAD);\n+\n+        case 'b':\n+            return (TypedInstruction) setOpcode(Constants.BALOAD);\n+\n+        case 'c':\n+            return (TypedInstruction) setOpcode(Constants.CALOAD);\n+\n+        case 's':\n+            return (TypedInstruction) setOpcode(Constants.SALOAD);\n+\n+        default:\n+            return (TypedInstruction) setOpcode(Constants.AALOAD);\n+        }\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterArrayLoadInstruction(this);\n+        visit.exitArrayLoadInstruction(this);\n+    }\n+}"},{"sha":"135224d39b2bfa774d6bd9911be1f3f0d22acd6a","filename":"serp/src/main/java/serp/bytecode/ArrayState.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ArrayState.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ArrayState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ArrayState.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>State implementing the behavior of an array class.</p>\n+ *\n+ *  @author Abe White\n+ */\n+class ArrayState extends State {\n+    private String _name = null;\n+    private String _componentName = null;\n+\n+    public ArrayState(String name, String componentName) {\n+        _name = name;\n+        _componentName = componentName;\n+    }\n+\n+    public int getMagic() {\n+        return Constants.VALID_MAGIC;\n+    }\n+\n+    public int getMajorVersion() {\n+        return Constants.MAJOR_VERSION;\n+    }\n+\n+    public int getMinorVersion() {\n+        return Constants.MINOR_VERSION;\n+    }\n+\n+    public int getAccessFlags() {\n+        return Constants.ACCESS_PUBLIC | Constants.ACCESS_FINAL;\n+    }\n+\n+    public int getIndex() {\n+        return 0;\n+    }\n+\n+    public int getSuperclassIndex() {\n+        return 0;\n+    }\n+\n+    public Collection getInterfacesHolder() {\n+        return Collections.EMPTY_LIST;\n+    }\n+\n+    public Collection getFieldsHolder() {\n+        return Collections.EMPTY_LIST;\n+    }\n+\n+    public Collection getMethodsHolder() {\n+        return Collections.EMPTY_LIST;\n+    }\n+\n+    public Collection getAttributesHolder() {\n+        return Collections.EMPTY_LIST;\n+    }\n+\n+    public String getName() {\n+        return _name;\n+    }\n+\n+    public String getSuperclassName() {\n+        return Object.class.getName();\n+    }\n+\n+    public String getComponentName() {\n+        return _componentName;\n+    }\n+\n+    public boolean isPrimitive() {\n+        return false;\n+    }\n+\n+    public boolean isArray() {\n+        return true;\n+    }\n+}"},{"sha":"79eea5bd1e67f3b880bb57406362125a4bb36c40","filename":"serp/src/main/java/serp/bytecode/ArrayStoreInstruction.java","status":"added","additions":133,"deletions":0,"changes":133,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ArrayStoreInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ArrayStoreInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ArrayStoreInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,133 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+\n+/**\n+ *  <p>Store a value from the stack into an array.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class ArrayStoreInstruction extends ArrayInstruction {\n+    private static final Class[][] _mappings = new Class[][] {\n+            { boolean.class, int.class },\n+            { void.class, int.class },\n+        };\n+\n+    ArrayStoreInstruction(Code owner) {\n+        super(owner);\n+    }\n+\n+    ArrayStoreInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    public int getLogicalStackChange() {\n+        switch (getOpcode()) {\n+        case Constants.NOP:\n+            return 0;\n+\n+        default:\n+            return -3;\n+        }\n+    }\n+\n+    public int getStackChange() {\n+        switch (getOpcode()) {\n+        case Constants.DASTORE:\n+        case Constants.LASTORE:\n+            return -4;\n+\n+        case Constants.NOP:\n+            return 0;\n+\n+        default:\n+            return -3;\n+        }\n+    }\n+\n+    public String getTypeName() {\n+        switch (getOpcode()) {\n+        case Constants.IASTORE:\n+            return int.class.getName();\n+\n+        case Constants.LASTORE:\n+            return long.class.getName();\n+\n+        case Constants.FASTORE:\n+            return float.class.getName();\n+\n+        case Constants.DASTORE:\n+            return double.class.getName();\n+\n+        case Constants.AASTORE:\n+            return Object.class.getName();\n+\n+        case Constants.BASTORE:\n+            return byte.class.getName();\n+\n+        case Constants.CASTORE:\n+            return char.class.getName();\n+\n+        case Constants.SASTORE:\n+            return short.class.getName();\n+\n+        default:\n+            return null;\n+        }\n+    }\n+\n+    public TypedInstruction setType(String type) {\n+        type = mapType(type, _mappings, true);\n+\n+        if (type == null) {\n+            return (TypedInstruction) setOpcode(Constants.NOP);\n+        }\n+\n+        switch (type.charAt(0)) {\n+        case 'i':\n+            return (TypedInstruction) setOpcode(Constants.IASTORE);\n+\n+        case 'l':\n+            return (TypedInstruction) setOpcode(Constants.LASTORE);\n+\n+        case 'f':\n+            return (TypedInstruction) setOpcode(Constants.FASTORE);\n+\n+        case 'd':\n+            return (TypedInstruction) setOpcode(Constants.DASTORE);\n+\n+        case 'b':\n+            return (TypedInstruction) setOpcode(Constants.BASTORE);\n+\n+        case 'c':\n+            return (TypedInstruction) setOpcode(Constants.CASTORE);\n+\n+        case 's':\n+            return (TypedInstruction) setOpcode(Constants.SASTORE);\n+\n+        default:\n+            return (TypedInstruction) setOpcode(Constants.AASTORE);\n+        }\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterArrayStoreInstruction(this);\n+        visit.exitArrayStoreInstruction(this);\n+    }\n+}"},{"sha":"1b03800f2300a4b3305937b580eff97ca1b52179","filename":"serp/src/main/java/serp/bytecode/Attribute.java","status":"added","additions":148,"deletions":0,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Attribute.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Attribute.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Attribute.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import serp.util.*;\n+\n+import java.io.*;\n+\n+import java.lang.reflect.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>In bytecode attributes are used to represent anything that is not\n+ *  part of the class structure.  This includes the source file name, code of\n+ *  methods, the line number table, etc.  All attributes contain at a minimum\n+ *  an immutable name that also determines the attribute's type.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public abstract class Attribute extends Attributes implements VisitAcceptor {\n+    private int _nameIndex = 0;\n+    private Attributes _owner = null;\n+\n+    Attribute(int nameIndex, Attributes owner) {\n+        _owner = owner;\n+        _nameIndex = nameIndex;\n+    }\n+\n+    /**\n+     *  Create an attribute of the appropriate type based on the\n+     *  the attribute name.\n+     */\n+    static Attribute create(String name, Attributes owner) {\n+        int nameIndex = owner.getPool().findUTF8Entry(name, true);\n+\n+        try {\n+            Class type = Class.forName(\"serp.bytecode.\" + name);\n+            Constructor cons = type.getDeclaredConstructor(new Class[] {\n+                        int.class, Attributes.class\n+                    });\n+\n+            return (Attribute) cons.newInstance(new Object[] {\n+                    Numbers.valueOf(nameIndex), owner\n+                });\n+        } catch (Throwable t) {\n+            return new UnknownAttribute(nameIndex, owner);\n+        }\n+    }\n+\n+    /**\n+     *  Return the {@link Attributes} that owns this attribute.  The entity\n+     *  might be a {@link BCClass}, {@link BCField}, {@link BCMethod}, or other\n+     *  attribute.\n+     */\n+    public Attributes getOwner() {\n+        return _owner;\n+    }\n+\n+    /**\n+     *  Return the index in the {@link ConstantPool} of the {@link UTF8Entry}\n+     *  holding the name of this attribute.\n+     */\n+    public int getNameIndex() {\n+        return _nameIndex;\n+    }\n+\n+    /**\n+      *  Return the name of this attribute.\n+     */\n+    public String getName() {\n+        return ((UTF8Entry) getPool().getEntry(_nameIndex)).getValue();\n+    }\n+\n+    public Project getProject() {\n+        return _owner.getProject();\n+    }\n+\n+    public ConstantPool getPool() {\n+        return _owner.getPool();\n+    }\n+\n+    public ClassLoader getClassLoader() {\n+        return _owner.getClassLoader();\n+    }\n+\n+    public boolean isValid() {\n+        return _owner != null;\n+    }\n+\n+    Collection getAttributesHolder() {\n+        return Collections.EMPTY_LIST;\n+    }\n+\n+    /**\n+     *  Invalidate this attribute.\n+     */\n+    void invalidate() {\n+        _owner = null;\n+    }\n+\n+    /**\n+     *  Return the length of the bytecode representation of this attribute\n+     *  in bytes, excluding the name index.\n+     */\n+    int getLength() {\n+        return 0;\n+    }\n+\n+    /**\n+     *  Copy the information from the given attribute to this one.  Does\n+     *  nothing by default.\n+     */\n+    void read(Attribute other) {\n+    }\n+\n+    /**\n+     *  Read the attribute bytecode from the given stream, up to length\n+     *  bytes, excluding the name index.  Does nothing by default.\n+     */\n+    void read(DataInput in, int length) throws IOException {\n+    }\n+\n+    /**\n+     *  Write the attribute bytecode to the given stream, up to length bytes,\n+     *  excluding the name index.  Does nothing by default.\n+     */\n+    void write(DataOutput out, int length) throws IOException {\n+    }\n+}"},{"sha":"2bff18f43848ae163fad37b730aadccb43712301","filename":"serp/src/main/java/serp/bytecode/Attributes.java","status":"added","additions":217,"deletions":0,"changes":217,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Attributes.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Attributes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Attributes.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Abstract superclass for all bytecode entities that hold attributes.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public abstract class Attributes implements BCEntity {\n+    /**\n+     *  Return all the attributes owned by this entity.\n+     *\n+     *  @return all owned attributes, or empty array if none\n+     */\n+    public Attribute[] getAttributes() {\n+        Collection attrs = getAttributesHolder();\n+\n+        return (Attribute[]) attrs.toArray(new Attribute[attrs.size()]);\n+    }\n+\n+    /**\n+     *  Return the attribute with the given name.  If multiple attributes\n+     *  share the name, which is returned is undefined.\n+     */\n+    public Attribute getAttribute(String name) {\n+        Collection attrs = getAttributesHolder();\n+        Attribute attr;\n+\n+        for (Iterator itr = attrs.iterator(); itr.hasNext();) {\n+            attr = (Attribute) itr.next();\n+\n+            if (attr.getName().equals(name)) {\n+                return attr;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     *  Return all attributes with the given name.\n+      *\n+     *  @return the matching attributes, or empty array if none\n+     */\n+    public Attribute[] getAttributes(String name) {\n+        List matches = new LinkedList();\n+\n+        Collection attrs = getAttributesHolder();\n+        Attribute attr;\n+\n+        for (Iterator itr = attrs.iterator(); itr.hasNext();) {\n+            attr = (Attribute) itr.next();\n+\n+            if (attr.getName().equals(name)) {\n+                matches.add(attr);\n+            }\n+        }\n+\n+        return (Attribute[]) matches.toArray(new Attribute[matches.size()]);\n+    }\n+\n+    /**\n+     *  Set the attributes for this entity; this method is useful for importing\n+     *  all attributes from another entity.  Set to null or empty array if none.\n+     */\n+    public void setAttributes(Attribute[] attrs) {\n+        clearAttributes();\n+\n+        if (attrs != null) {\n+            for (int i = 0; i < attrs.length; i++)\n+                addAttribute(attrs[i]);\n+        }\n+    }\n+\n+    /**\n+     *  Import an attribute from another entity, or make a copy of one\n+     *  on this entity.\n+     */\n+    public Attribute addAttribute(Attribute attr) {\n+        Attribute newAttr = addAttribute(attr.getName());\n+        newAttr.read(attr);\n+\n+        return newAttr;\n+    }\n+\n+    /**\n+      *  Add an attribute of the given type.\n+     */\n+    public Attribute addAttribute(String name) {\n+        Attribute attr = Attribute.create(name, this);\n+        getAttributesHolder().add(attr);\n+\n+        return attr;\n+    }\n+\n+    /**\n+     *  Clear all attributes from this entity.\n+     */\n+    public void clearAttributes() {\n+        Collection attrs = getAttributesHolder();\n+        Attribute attr;\n+\n+        for (Iterator itr = attrs.iterator(); itr.hasNext();) {\n+            attr = (Attribute) itr.next();\n+            itr.remove();\n+            attr.invalidate();\n+        }\n+    }\n+\n+    /**\n+     *  Remove all attributes with the given name from this entity.\n+     *\n+     *  @return true if an attribute was removed, false otherwise\n+     */\n+    public boolean removeAttribute(String name) {\n+        return removeAttribute(getAttribute(name));\n+    }\n+\n+    /**\n+     *  Remove the given attribute.  After being removed, the attribute\n+     *  is invalid, and the result of any operations on it are undefined.\n+     *\n+     *  @return true if the attribute was removed, false otherwise\n+     */\n+    public boolean removeAttribute(Attribute attribute) {\n+        if ((attribute == null) || !getAttributesHolder().remove(attribute)) {\n+            return false;\n+        }\n+\n+        attribute.invalidate();\n+\n+        return true;\n+    }\n+\n+    /**\n+     *  Convenience method to be called by BCEntities when being visited\n+     *  by a {@link BCVisitor}; this method will allow the visitor to visit all\n+     *  attributes of this entity.\n+     */\n+    void visitAttributes(BCVisitor visit) {\n+        Attribute attr;\n+\n+        for (Iterator itr = getAttributesHolder().iterator(); itr.hasNext();) {\n+            attr = (Attribute) itr.next();\n+            visit.enterAttribute(attr);\n+            attr.acceptVisit(visit);\n+            visit.exitAttribute(attr);\n+        }\n+    }\n+\n+    /**\n+     *  Build the attribute list from the given stream.\n+     *  Relies on the ability of attributes to read themselves, and\n+     *  requires access to the constant pool, which must already by read.\n+     */\n+    void readAttributes(DataInput in) throws IOException {\n+        Collection attrs = getAttributesHolder();\n+        attrs.clear();\n+\n+        Attribute attribute;\n+        String name;\n+\n+        for (int i = in.readUnsignedShort(); i > 0; i--) {\n+            name = ((UTF8Entry) getPool().getEntry(in.readUnsignedShort())).getValue();\n+            attribute = addAttribute(name);\n+            attribute.read(in, in.readInt());\n+        }\n+    }\n+\n+    /**\n+     *  Writes all the owned attributes to the given stream.\n+     *  Relies on the ability of attributes to write themselves.\n+     */\n+    void writeAttributes(DataOutput out) throws IOException {\n+        Collection attrs = getAttributesHolder();\n+        out.writeShort(attrs.size());\n+\n+        Attribute attribute;\n+        int length;\n+\n+        for (Iterator itr = attrs.iterator(); itr.hasNext();) {\n+            attribute = (Attribute) itr.next();\n+            out.writeShort(attribute.getNameIndex());\n+            length = attribute.getLength();\n+            out.writeInt(length);\n+            attribute.write(out, length);\n+        }\n+    }\n+\n+    /**\n+     *  Return the collection used to hold the attributes of this entity.\n+     */\n+    abstract Collection getAttributesHolder();\n+}"},{"sha":"d9e5e6caf0a6b16c81de22fb2ad1e47387d1f535","filename":"serp/src/main/java/serp/bytecode/BCClass.java","status":"added","additions":1878,"deletions":0,"changes":1878,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/BCClass.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/BCClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCClass.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,1878 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import serp.util.*;\n+\n+import java.io.*;\n+\n+import java.net.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>The BCClass represents a class object in the bytecode framework, in many\n+ *  ways mirroring the {@link Class} class of Java reflection.  The represented\n+ *  class might be a primitive, array, existing object type, or some new user-\n+ *  defined type.  As with most entities in the        bytecode framework, the BCClass\n+ *  contains methods to manipulate the low-level state of the class (constant\n+ *  pool indexes, etc), but these can and should be ignored in\n+ *  favor of the available high-level methods.</p>\n+ *\n+ *  <p>A BCClass instance is loaded from a {@link Project} and remains\n+ *  attached to that project for its lifetime.  If a BCClass is removed from\n+ *  its project, the result of any further operations on the class are\n+ *  undefined.</p>\n+ *\n+ *  <p>Note that if a BCClass represents a primitive or array type, all of the\n+ *  available mutator methods and any methods that access the constant pool\n+ *  will throw {@link UnsupportedOperationException}s.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class BCClass extends Attributes implements VisitAcceptor {\n+    private Project _project = null;\n+    private State _state = null;\n+    private ClassLoader _loader = null;\n+\n+    /**\n+     *  Hide constructor.  For use by the owning project only.\n+     */\n+    BCClass(Project project) {\n+        _project = project;\n+    }\n+\n+    /**\n+     *  Set the class state.  For use by the owning project only.\n+     */\n+    void setState(State state) {\n+        _state = state;\n+    }\n+\n+    /**\n+     *  Invalidate this class.\n+     */\n+    void invalidate() {\n+        _project = null;\n+        _state = State.INVALID;\n+    }\n+\n+    //////////////////\n+    // I/O operations\n+    //////////////////\n+\n+    /**\n+     *  Initialize from the class definition in the given file.  For use by\n+         *  the owning project only.\n+     */\n+    void read(File classFile, ClassLoader loader) throws IOException {\n+        InputStream in = new FileInputStream(classFile);\n+\n+        try {\n+            read(in, loader);\n+        } finally {\n+            in.close();\n+        }\n+    }\n+\n+    /**\n+     *  Initialize from the class definition in the given stream.  For use by\n+     *  the owning project only.\n+     */\n+    void read(InputStream instream, ClassLoader loader)\n+        throws IOException {\n+        DataInput in = new DataInputStream(instream);\n+\n+        // header information\n+        _state.setMagic(in.readInt());\n+        _state.setMinorVersion(in.readUnsignedShort());\n+        _state.setMajorVersion(in.readUnsignedShort());\n+\n+        // constant pool\n+        _state.getPool().read(in);\n+\n+        // access flags\n+        _state.setAccessFlags(in.readUnsignedShort());\n+\n+        // class, super class, interfaces\n+        _state.setIndex(in.readUnsignedShort());\n+        _state.setSuperclassIndex(in.readUnsignedShort());\n+\n+        Collection interfaces = _state.getInterfacesHolder();\n+        interfaces.clear();\n+\n+        int interfaceCount = in.readUnsignedShort();\n+\n+        for (int i = 0; i < interfaceCount; i++)\n+            interfaces.add(Numbers.valueOf(in.readUnsignedShort()));\n+\n+        // fields\n+        Collection fields = _state.getFieldsHolder();\n+        fields.clear();\n+\n+        int fieldCount = in.readUnsignedShort();\n+        BCField field;\n+\n+        for (int i = 0; i < fieldCount; i++) {\n+            field = new BCField(this);\n+            fields.add(field);\n+            field.read(in);\n+        }\n+\n+        // methods\n+        Collection methods = _state.getMethodsHolder();\n+        methods.clear();\n+\n+        int methodCount = in.readUnsignedShort();\n+        BCMethod method;\n+\n+        for (int i = 0; i < methodCount; i++) {\n+            method = new BCMethod(this);\n+            methods.add(method);\n+            method.read(in);\n+        }\n+\n+        readAttributes(in);\n+        _loader = loader;\n+    }\n+\n+    /**\n+     *  Initialize from the bytecode of the definition of the given class.\n+     *  For use by the owning project only.\n+     */\n+    void read(Class type) throws IOException {\n+        // find out the length of the package name\n+        int dotIndex = type.getName().lastIndexOf('.') + 1;\n+\n+        // strip the package off of the class name\n+        String className = type.getName().substring(dotIndex);\n+\n+        // attempt to get the class file for the class as a stream\n+        InputStream in = type.getResourceAsStream(className + \".class\");\n+\n+        try {\n+            read(in, type.getClassLoader());\n+        } finally {\n+            in.close();\n+        }\n+    }\n+\n+    /**\n+     *  Initialize from the given parsed bytecode.\n+     *  For use by the owning project only.\n+     */\n+    void read(BCClass orig) {\n+        try {\n+            ByteArrayInputStream in = new ByteArrayInputStream(orig.toByteArray());\n+            read(in, orig.getClassLoader());\n+            in.close();\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe.toString());\n+        }\n+    }\n+\n+    /**\n+      *  Write the class bytecode to the .class file in the proper directory of\n+     *  the        CLASSPATH.  The file must exist already, so this method only works\n+     *  on existing classes.\n+     */\n+    public void write() throws IOException {\n+        String name = getName();\n+        int dotIndex = name.lastIndexOf('.') + 1;\n+        name = name.substring(dotIndex);\n+\n+        Class type = getType();\n+\n+        // attempt to get the class file for the class as a stream;\n+        // we need to use the url decoder in case the target directory\n+        // has spaces in it\n+        OutputStream out = new FileOutputStream(URLDecoder.decode(\n+                    type.getResource(name + \".class\").getFile()));\n+\n+        try {\n+            write(out);\n+        } finally {\n+            out.close();\n+        }\n+    }\n+\n+    /**\n+     *  Write the class bytecode to the specified file.\n+     */\n+    public void write(File classFile) throws IOException {\n+        OutputStream out = new FileOutputStream(classFile);\n+\n+        try {\n+            write(out);\n+        } finally {\n+            out.close();\n+        }\n+    }\n+\n+    /**\n+     *  Write the class bytecode to the specified stream.\n+     */\n+    public void write(OutputStream outstream) throws IOException {\n+        DataOutput out = new DataOutputStream(outstream);\n+\n+        // header information\n+        out.writeInt(_state.getMagic());\n+        out.writeShort(_state.getMinorVersion());\n+        out.writeShort(_state.getMajorVersion());\n+\n+        // constant pool\n+        _state.getPool().write(out);\n+\n+        // access flags\n+        out.writeShort(_state.getAccessFlags());\n+\n+        // class, super class\n+        out.writeShort(_state.getIndex());\n+        out.writeShort(_state.getSuperclassIndex());\n+\n+        // interfaces\n+        Collection interfaces = _state.getInterfacesHolder();\n+        out.writeShort(interfaces.size());\n+\n+        for (Iterator itr = interfaces.iterator(); itr.hasNext();)\n+            out.writeShort(((Number) itr.next()).intValue());\n+\n+        // fields\n+        Collection fields = _state.getFieldsHolder();\n+        out.writeShort(fields.size());\n+\n+        for (Iterator itr = fields.iterator(); itr.hasNext();)\n+            ((BCField) itr.next()).write(out);\n+\n+        // methods\n+        Collection methods = _state.getMethodsHolder();\n+        out.writeShort(methods.size());\n+\n+        for (Iterator itr = methods.iterator(); itr.hasNext();)\n+            ((BCMethod) itr.next()).write(out);\n+\n+        // attributes\n+        writeAttributes(out);\n+    }\n+\n+    /**\n+     *  Return the bytecode of this class as a byte array, possibly for use\n+     *  in a custom {@link ClassLoader}.\n+     */\n+    public byte[] toByteArray() {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+\n+        try {\n+            write(out);\n+            out.flush();\n+\n+            return out.toByteArray();\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe.toString());\n+        } finally {\n+            try {\n+                out.close();\n+            } catch (IOException ioe) {\n+            }\n+        }\n+    }\n+\n+    /////////////////////\n+    // Access operations\n+    /////////////////////\n+\n+    /**\n+     *  Return the magic number for this class; if this is a valid type, this\n+     *  should be equal to {@link Constants#VALID_MAGIC} (the default value).\n+     */\n+    public int getMagic() {\n+        return _state.getMagic();\n+    }\n+\n+    /**\n+     *  Set the magic number for this class; if this is a valid type, this\n+     *  should be equal to {@link Constants#VALID_MAGIC} (the default value).\n+     */\n+    public void setMagic(int magic) {\n+        _state.setMagic(magic);\n+    }\n+\n+    /**\n+     *  Return the major version of the bytecode spec used for this class.\n+     *  JVMs are only required to operate with versions that they understand;\n+     *  leaving the default value of {@link Constants#MAJOR_VERSION} is safe.\n+     */\n+    public int getMajorVersion() {\n+        return _state.getMajorVersion();\n+    }\n+\n+    /**\n+     *  Set the major version of the bytecode spec used for this class.\n+     *  JVMs are only required to operate with versions that they understand;\n+     *  leaving the default value of {@link Constants#MAJOR_VERSION} is safe.\n+     */\n+    public void setMajorVersion(int majorVersion) {\n+        _state.setMajorVersion(majorVersion);\n+    }\n+\n+    /**\n+     *  Get the minor version of the bytecode spec used for this class.\n+     *  JVMs are only required to operate with versions that they understand;\n+     *  leaving the default value of {@link Constants#MINOR_VERSION} is safe.\n+     */\n+    public int getMinorVersion() {\n+        return _state.getMinorVersion();\n+    }\n+\n+    /**\n+     *  Set the minor version of the bytecode spec used for this class.\n+     *  JVMs are only required to operate with versions that they understand;\n+     *  leaving the default value of {@link Constants#MINOR_VERSION} is safe.\n+     */\n+    public void setMinorVersion(int minorVersion) {\n+        _state.setMinorVersion(minorVersion);\n+    }\n+\n+    /**\n+     *  Return the access flags for this class as a bit array of\n+      *  ACCESS_XXX constants from {@link Constants}.  This can be used to\n+     *  transfer access flags between classes without getting/setting each\n+     *  possible flag.\n+     */\n+    public int getAccessFlags() {\n+        return _state.getAccessFlags();\n+    }\n+\n+    /**\n+     *  Set the access flags for this class as a bit array of\n+      *  ACCESS_XXX constants from {@link Constants}.  This can be used to\n+     *  transfer access flags between classes without getting/setting each\n+     *  possible flag.\n+     */\n+    public void setAccessFlags(int access) {\n+        _state.setAccessFlags(access);\n+    }\n+\n+    /**\n+     *  Manipulate the class access flags.\n+     */\n+    public boolean isPublic() {\n+        return (getAccessFlags() & Constants.ACCESS_PUBLIC) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the class access flags.\n+     */\n+    public void makePublic() {\n+        setAccessFlags(getAccessFlags() | Constants.ACCESS_PUBLIC);\n+    }\n+\n+    /**\n+     *  Manipulate the class access flags.\n+     */\n+    public boolean isPackage() {\n+        return !isPublic();\n+    }\n+\n+    /**\n+     *  Manipulate the class access flags.\n+     */\n+    public void makePackage() {\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PUBLIC);\n+    }\n+\n+    /**\n+     *  Manipulate the class access flags.\n+     */\n+    public boolean isFinal() {\n+        return (getAccessFlags() & Constants.ACCESS_FINAL) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the class access flags.\n+     */\n+    public void setFinal(boolean on) {\n+        if (on) {\n+            setAccessFlags(getAccessFlags() | Constants.ACCESS_FINAL);\n+        } else {\n+            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_FINAL);\n+        }\n+    }\n+\n+    /**\n+     *  Manipulate the class access flags.\n+     */\n+    public boolean isInterface() {\n+        return (getAccessFlags() & Constants.ACCESS_INTERFACE) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the class access flags.\n+     */\n+    public void setInterface(boolean on) {\n+        if (on) {\n+            setAccessFlags(getAccessFlags() | Constants.ACCESS_INTERFACE);\n+            setAbstract(true);\n+        } else {\n+            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_INTERFACE);\n+        }\n+    }\n+\n+    /**\n+     *  Manipulate the class access flags.\n+     */\n+    public boolean isAbstract() {\n+        return (getAccessFlags() & Constants.ACCESS_ABSTRACT) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the class access flags.\n+     */\n+    public void setAbstract(boolean on) {\n+        if (on) {\n+            setAccessFlags(getAccessFlags() | Constants.ACCESS_ABSTRACT);\n+        } else {\n+            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_ABSTRACT);\n+        }\n+    }\n+\n+    /**\n+     *  Return true if this class is a primitive type.\n+     */\n+    public boolean isPrimitive() {\n+        return _state.isPrimitive();\n+    }\n+\n+    /**\n+     *  Return true if this class is an array type.\n+     */\n+    public boolean isArray() {\n+        return _state.isArray();\n+    }\n+\n+    /////////////////////////\n+    // Class name operations\n+    /////////////////////////\n+\n+    /**\n+     *  Return the {@link ConstantPool} index of the\n+     *  {@link ClassEntry} for this class.  Returns 0 if the class does not\n+     *  have a constant pool (such as a primitive or array).\n+     */\n+    public int getIndex() {\n+        return _state.getIndex();\n+    }\n+\n+    /**\n+     *  Set the {@link ConstantPool} index of the {@link ClassEntry} for this\n+     *  class.  Unlike most other low-level methods, the index\n+      *  will be checked against the pool immediately;\n+     *  classes must have a valid name at all times.\n+     */\n+    public void setIndex(int index) {\n+        String oldName = getName();\n+        String newName = ((ClassEntry) getPool().getEntry(index)).getNameEntry()\n+                          .getValue();\n+\n+        beforeRename(oldName, newName);\n+        _state.setIndex(index);\n+    }\n+\n+    /**\n+     *  Return the name of this class, including package name.  The name will\n+     *  be in a form suitable for a {@link Class#forName} call.\n+     */\n+    public String getName() {\n+        return _state.getName();\n+    }\n+\n+    /**\n+     *  Return the name of the class only, without package.\n+     */\n+    public String getClassName() {\n+        String name = _project.getNameCache().getExternalForm(getName(), true);\n+\n+        return name.substring(name.lastIndexOf('.') + 1);\n+    }\n+\n+    /**\n+     *  Return the package name only, without class, or null if none.\n+     */\n+    public String getPackageName() {\n+        String name = _project.getNameCache().getExternalForm(getName(), true);\n+        int index = name.lastIndexOf('.');\n+\n+        if (index == -1) {\n+            return null;\n+        }\n+\n+        return name.substring(0, index);\n+    }\n+\n+    /**\n+     *  Set the name of this class, including package name.\n+     */\n+    public void setName(String name) {\n+        name = _project.getNameCache().getExternalForm(name, false);\n+\n+        String oldName = getName();\n+\n+        // get a reference to the class entry for this class\n+        int index = getIndex();\n+\n+        if (index == 0) {\n+            index = getPool().findClassEntry(name, true);\n+        }\n+\n+        ClassEntry entry = (ClassEntry) getPool().getEntry(index);\n+\n+        // make sure the rename is ok with the project\n+        beforeRename(oldName, name);\n+\n+        // reset the name index of the class entry to the new name\n+        int nameIndex = getPool()\n+                            .findUTF8Entry(_project.getNameCache()\n+                                                   .getInternalForm(name, false),\n+                true);\n+        entry.setNameIndex(nameIndex);\n+\n+        // we might have just added a new entry; set the index\n+        _state.setIndex(index);\n+    }\n+\n+    /**\n+     *  Return the {@link Class} object for this class, if it is loadable.\n+     */\n+    public Class getType() {\n+        return Strings.toClass(getName(), getClassLoader());\n+    }\n+\n+    /**\n+     *  Return the component type name of this class, or null if not an array.\n+     *  The name will be in a form suitable for a {@link Class#forName} call.\n+     */\n+    public String getComponentName() {\n+        return _state.getComponentName();\n+    }\n+\n+    /**\n+     *  Return the component type of this class, or null if not an array.\n+     */\n+    public Class getComponentType() {\n+        String componentName = getComponentName();\n+\n+        if (componentName == null) {\n+            return null;\n+        }\n+\n+        return Strings.toClass(componentName, getClassLoader());\n+    }\n+\n+    /**\n+     *  Return the component type of this class, or null if not an array.\n+     */\n+    public BCClass getComponentBC() {\n+        String componentName = getComponentName();\n+\n+        if (componentName == null) {\n+            return null;\n+        }\n+\n+        return getProject().loadClass(componentName, getClassLoader());\n+    }\n+\n+    /////////////////////////\n+    // Superclass operations\n+    /////////////////////////\n+\n+    /**\n+     *  Return the {@link ConstantPool} index of the\n+     *  {@link ClassEntry} for the superclass of this class.  Returns -1 if\n+     *  the class does not have a constant pool (such as a primitive or array).\n+     */\n+    public int getSuperclassIndex() {\n+        return _state.getSuperclassIndex();\n+    }\n+\n+    /**\n+     *  Set the {@link ConstantPool} index of the\n+     *  {@link ClassEntry} for the superclass of this class.\n+     */\n+    public void setSuperclassIndex(int index) {\n+        _state.setSuperclassIndex(index);\n+    }\n+\n+    /**\n+     *  Return the name of the superclass for this class, including package\n+     *  name.  The name will  be in a form suitable for a\n+     *  {@link Class#forName} call, or null for types without superclasses.\n+     */\n+    public String getSuperclassName() {\n+        return _state.getSuperclassName();\n+    }\n+\n+    /**\n+     *  Return the {@link Class} object for the superclass of this class, if it\n+     *  is loadable.  Returns null for types without superclasses.\n+     */\n+    public Class getSuperclassType() {\n+        String name = getSuperclassName();\n+\n+        if (name == null) {\n+            return null;\n+        }\n+\n+        return Strings.toClass(name, getClassLoader());\n+    }\n+\n+    /**\n+     *  Return the bytecode of the superclass of this class, or\n+     *  null for types without superclasses.\n+     */\n+    public BCClass getSuperclassBC() {\n+        String name = getSuperclassName();\n+\n+        if (name == null) {\n+            return null;\n+        }\n+\n+        return getProject().loadClass(name, getClassLoader());\n+    }\n+\n+    /**\n+     *  Set the superclass of this class.\n+     */\n+    public void setSuperclass(String name) {\n+        if (name == null) {\n+            setSuperclassIndex(0);\n+        } else {\n+            setSuperclassIndex(getPool()\n+                                   .findClassEntry(_project.getNameCache()\n+                                                           .getInternalForm(name,\n+                        false), true));\n+        }\n+    }\n+\n+    /**\n+     *  Set the superclass of this class.\n+     */\n+    public void setSuperclass(Class type) {\n+        if (type == null) {\n+            setSuperclass((String) null);\n+        } else {\n+            setSuperclass(type.getName());\n+        }\n+    }\n+\n+    /**\n+     *  Set the superclass of this class.\n+     */\n+    public void setSuperclass(BCClass type) {\n+        if (type == null) {\n+            setSuperclass((String) null);\n+        } else {\n+            setSuperclass(type.getName());\n+        }\n+    }\n+\n+    ////////////////////////\n+    // Interface operations\n+    ////////////////////////\n+\n+    /**\n+     *  Return the list of {@link ConstantPool} indexes of the\n+     *  {@link ClassEntry}s describing all the interfaces this class declares\n+     *  that it        implements/extends.\n+     *\n+     *  @return the implmented interfaces, or an empty array if none\n+     */\n+    public int[] getDeclaredInterfaceIndexes() {\n+        Collection interfaces = _state.getInterfacesHolder();\n+        int[] indexes = new int[interfaces.size()];\n+\n+        Iterator itr = interfaces.iterator();\n+\n+        for (int i = 0, max = interfaces.size(); i < max; i++)\n+            indexes[i] = ((Number) itr.next()).intValue();\n+\n+        return indexes;\n+    }\n+\n+    /**\n+     *  Set the list of {@link ConstantPool} indexes of the\n+     *  {@link ClassEntry}s        describing all the interfaces this class declares\n+     *  it implements/extends; set to null or an empty array if none.\n+     */\n+    public void setDeclaredInterfaceIndexes(int[] interfaceIndexes) {\n+        Collection stateIndexes = _state.getInterfacesHolder();\n+        stateIndexes.clear();\n+\n+        for (int i = 0; i < interfaceIndexes.length; i++)\n+            stateIndexes.add(Numbers.valueOf(interfaceIndexes[i]));\n+    }\n+\n+    /**\n+     *  Return the names of the interfaces declared for this class, including\n+     *  package names, or an empty array if none.  The names will  be in a form\n+     *  suitable for a {@link Class#forName} call.\n+     */\n+    public String[] getDeclaredInterfaceNames() {\n+        int[] indexes = getDeclaredInterfaceIndexes();\n+        String[] names = new String[indexes.length];\n+\n+        ClassEntry entry;\n+\n+        for (int i = 0; i < indexes.length; i++) {\n+            entry = (ClassEntry) getPool().getEntry(indexes[i]);\n+            names[i] = _project.getNameCache()\n+                               .getExternalForm(entry.getNameEntry().getValue(),\n+                    false);\n+        }\n+\n+        return names;\n+    }\n+\n+    /**\n+     *  Return the {@link Class} objects for the declared interfaces of this\n+     *  class, or an empty array if none.\n+     */\n+    public Class[] getDeclaredInterfaceTypes() {\n+        String[] names = getDeclaredInterfaceNames();\n+        Class[] types = new Class[names.length];\n+\n+        for (int i = 0; i < names.length; i++)\n+            types[i] = Strings.toClass(names[i], getClassLoader());\n+\n+        return types;\n+    }\n+\n+    /**\n+     *  Return the bytecode for the declared interfaces of this class, or an\n+     *  empty array if none.\n+     */\n+    public BCClass[] getDeclaredInterfaceBCs() {\n+        String[] names = getDeclaredInterfaceNames();\n+        BCClass[] types = new BCClass[names.length];\n+\n+        for (int i = 0; i < names.length; i++)\n+            types[i] = getProject().loadClass(names[i], getClassLoader());\n+\n+        return types;\n+    }\n+\n+    /**\n+     *  Set the interfaces declared implemented/extended by this class; set to\n+     *  null or an empty array if none.\n+     */\n+    public void setDeclaredInterfaces(String[] interfaces) {\n+        clearDeclaredInterfaces();\n+\n+        if (interfaces != null) {\n+            for (int i = 0; i < interfaces.length; i++)\n+                declareInterface(interfaces[i]);\n+        }\n+    }\n+\n+    /**\n+     *  Set the interfaces declared implemented/extended by this class; set to\n+     *  null or an empty array if none.\n+     */\n+    public void setDeclaredInterfaces(Class[] interfaces) {\n+        String[] names = null;\n+\n+        if (interfaces != null) {\n+            names = new String[interfaces.length];\n+\n+            for (int i = 0; i < interfaces.length; i++)\n+                names[i] = interfaces[i].getName();\n+        }\n+\n+        setDeclaredInterfaces(names);\n+    }\n+\n+    /**\n+     *  Set the interfaces declared implemented/extended by this class; set to\n+     *  null or an empty array if none.\n+     */\n+    public void setDeclaredInterfaces(BCClass[] interfaces) {\n+        String[] names = null;\n+\n+        if (interfaces != null) {\n+            names = new String[interfaces.length];\n+\n+            for (int i = 0; i < interfaces.length; i++)\n+                names[i] = interfaces[i].getName();\n+        }\n+\n+        setDeclaredInterfaces(names);\n+    }\n+\n+    /**\n+     *  Return the names of all unique interfaces implemented by this class,\n+     *  including those of all superclasses.  The names will be returned in a\n+     *  form suitable for a {@link Class#forName} call.\n+     *  This method does not recurse into interfaces-of-interfaces.\n+     */\n+    public String[] getInterfaceNames() {\n+        Collection allNames = new LinkedList();\n+        String[] names;\n+\n+        for (BCClass type = this; type != null;\n+                type = type.getSuperclassBC()) {\n+            names = type.getDeclaredInterfaceNames();\n+\n+            for (int i = 0; i < names.length; i++)\n+                allNames.add(names[i]);\n+        }\n+\n+        return (String[]) allNames.toArray(new String[allNames.size()]);\n+    }\n+\n+    /**\n+     *  Return the {@link Class} objects of all unique interfaces implemented\n+     *  by this class, including those of all superclasses.\n+     *  This method does not recurse into interfaces-of-interfaces.\n+     */\n+    public Class[] getInterfaceTypes() {\n+        Collection allTypes = new LinkedList();\n+        Class[] types;\n+\n+        for (BCClass type = this; type != null;\n+                type = type.getSuperclassBC()) {\n+            types = type.getDeclaredInterfaceTypes();\n+\n+            for (int i = 0; i < types.length; i++)\n+                allTypes.add(types[i]);\n+        }\n+\n+        return (Class[]) allTypes.toArray(new Class[allTypes.size()]);\n+    }\n+\n+    /**\n+     *  Return the bytecode of all unique interfaces implemented by this class,\n+     *  including those of all superclasses.\n+     *  This method does not recurse into interfaces-of-interfaces.\n+     */\n+    public BCClass[] getInterfaceBCs() {\n+        Collection allTypes = new LinkedList();\n+        BCClass[] types;\n+\n+        for (BCClass type = this; type != null;\n+                type = type.getSuperclassBC()) {\n+            types = type.getDeclaredInterfaceBCs();\n+\n+            for (int i = 0; i < types.length; i++)\n+                allTypes.add(types[i]);\n+        }\n+\n+        return (BCClass[]) allTypes.toArray(new BCClass[allTypes.size()]);\n+    }\n+\n+    /**\n+     *  Clear this class of all interface declarations.\n+     */\n+    public void clearDeclaredInterfaces() {\n+        _state.getInterfacesHolder().clear();\n+    }\n+\n+    /**\n+     *  Remove an interface declared by this class.\n+     *\n+      *  @return true if the class had the interface, false otherwise\n+     */\n+    public boolean removeDeclaredInterface(String name) {\n+        String[] names = getDeclaredInterfaceNames();\n+        Iterator itr = _state.getInterfacesHolder().iterator();\n+\n+        for (int i = 0; i < names.length; i++) {\n+            itr.next();\n+\n+            if (names[i].equals(name)) {\n+                itr.remove();\n+\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     *  Remove an interface declared by this class.\n+     *\n+      *  @return true if the class had the interface, false otherwise\n+     */\n+    public boolean removeDeclaredInterface(Class type) {\n+        if (type == null) {\n+            return false;\n+        }\n+\n+        return removeDeclaredInterface(type.getName());\n+    }\n+\n+    /**\n+     *  Remove an interface declared by this class.\n+     *\n+      *  @return true if the class had the interface, false otherwise\n+     */\n+    public boolean removeDeclaredInterface(BCClass type) {\n+        if (type == null) {\n+            return false;\n+        }\n+\n+        return removeDeclaredInterface(type.getName());\n+    }\n+\n+    /**\n+      *  Add an interface to those declared by this class.\n+     */\n+    public void declareInterface(String name) {\n+        int index = getPool()\n+                        .findClassEntry(_project.getNameCache()\n+                                                .getInternalForm(name, false),\n+                true);\n+        _state.getInterfacesHolder().add(Numbers.valueOf(index));\n+    }\n+\n+    /**\n+      *  Add an interface to those declared by this class.\n+     */\n+    public void declareInterface(Class type) {\n+        declareInterface(type.getName());\n+    }\n+\n+    /**\n+     *  Add an interface to those declared by this class.\n+     */\n+    public void declareInterface(BCClass type) {\n+        declareInterface(type.getName());\n+    }\n+\n+    /**\n+     *  Return true if this class or any of its superclasses implement/extend\n+     *  the given interface/class.\n+     *  This method does not recurse into interfaces-of-interfaces.\n+     */\n+    public boolean isInstanceOf(String name) {\n+        name = _project.getNameCache().getExternalForm(name, false);\n+\n+        String[] interfaces = getInterfaceNames();\n+\n+        for (int i = 0; i < interfaces.length; i++)\n+            if (interfaces[i].equals(name)) {\n+                return true;\n+            }\n+\n+        for (BCClass type = this; type != null;\n+                type = type.getSuperclassBC())\n+            if (type.getName().equals(name)) {\n+                return true;\n+            }\n+\n+        return false;\n+    }\n+\n+    /**\n+     *  Return true if this class or any of its superclasses implement/extend\n+     *  the given interface/class.\n+     *  This method does not recurse into interfaces-of-interfaces.\n+     */\n+    public boolean isInstanceOf(Class type) {\n+        if (type == null) {\n+            return false;\n+        }\n+\n+        return isInstanceOf(type.getName());\n+    }\n+\n+    /**\n+     *  Return true if this class or any of its superclasses implement/extend\n+     *  the given interface/class.\n+     *  This method does not recurse into interfaces-of-interfaces.\n+     */\n+    public boolean isInstanceOf(BCClass type) {\n+        if (type == null) {\n+            return false;\n+        }\n+\n+        return isInstanceOf(type.getName());\n+    }\n+\n+    //////////////////////\n+    // Field operations\n+    //////////////////////\n+\n+    /**\n+     *  Return all the declared fields of this class, or an empty array if none.\n+     */\n+    public BCField[] getDeclaredFields() {\n+        Collection fields = _state.getFieldsHolder();\n+\n+        return (BCField[]) fields.toArray(new BCField[fields.size()]);\n+    }\n+\n+    /**\n+     *  Return the declared field with the given name, or null if none.\n+     */\n+    public BCField getDeclaredField(String name) {\n+        BCField[] fields = getDeclaredFields();\n+\n+        for (int i = 0; i < fields.length; i++)\n+            if (fields[i].getName().equals(name)) {\n+                return fields[i];\n+            }\n+\n+        return null;\n+    }\n+\n+    /**\n+     *  Return all the fields of this class, including those of all\n+     *  superclasses, or an empty array if none.\n+     */\n+    public BCField[] getFields() {\n+        Collection allFields = new LinkedList();\n+        BCField[] fields;\n+\n+        for (BCClass type = this; type != null;\n+                type = type.getSuperclassBC()) {\n+            fields = type.getDeclaredFields();\n+\n+            for (int i = 0; i < fields.length; i++)\n+                allFields.add(fields[i]);\n+        }\n+\n+        return (BCField[]) allFields.toArray(new BCField[allFields.size()]);\n+    }\n+\n+    /**\n+     *  Return all fields with the given name, including those of all\n+     *  superclasses, or an empty array if none.\n+     */\n+    public BCField[] getFields(String name) {\n+        List matches = new LinkedList();\n+        BCField[] fields = getFields();\n+\n+        for (int i = 0; i < fields.length; i++)\n+            if (fields[i].getName().equals(name)) {\n+                matches.add(fields[i]);\n+            }\n+\n+        return (BCField[]) matches.toArray(new BCField[matches.size()]);\n+    }\n+\n+    /**\n+     *  Set the fields for this class; this method is useful for importing all\n+     *  fields from another class.  Set to null or empty array if none.\n+     */\n+    public void setDeclaredFields(BCField[] fields) {\n+        clearDeclaredFields();\n+\n+        if (fields != null) {\n+            for (int i = 0; i < fields.length; i++)\n+                declareField(fields[i]);\n+        }\n+    }\n+\n+    /**\n+     *  Import the information from given field as a new field in this class.\n+     *\n+     *  @return the added field\n+     */\n+    public BCField declareField(BCField field) {\n+        BCField newField = declareField(field.getName(), field.getTypeName());\n+        newField.setAccessFlags(field.getAccessFlags());\n+        newField.setAttributes(field.getAttributes());\n+\n+        return newField;\n+    }\n+\n+    /**\n+     *  Add a field to this class.\n+     *\n+     *  @return the added field\n+     */\n+    public BCField declareField(String name, String type) {\n+        BCField field = new BCField(this);\n+        _state.getFieldsHolder().add(field);\n+        field.initialize(name,\n+            _project.getNameCache().getInternalForm(type, true));\n+\n+        return field;\n+    }\n+\n+    /**\n+     *  Add a field to this class.\n+     *\n+     *  @return the added field\n+     */\n+    public BCField declareField(String name, Class type) {\n+        String typeName = (type == null) ? null : type.getName();\n+\n+        return declareField(name, typeName);\n+    }\n+\n+    /**\n+     *  Add a field to this class.\n+     *\n+     *  @return the added field\n+     */\n+    public BCField declareField(String name, BCClass type) {\n+        String typeName = (type == null) ? null : type.getName();\n+\n+        return declareField(name, typeName);\n+    }\n+\n+    /**\n+     *  Clear all fields from this class.\n+     */\n+    public void clearDeclaredFields() {\n+        Collection fields = _state.getFieldsHolder();\n+        BCField field;\n+\n+        for (Iterator itr = fields.iterator(); itr.hasNext();) {\n+            field = (BCField) itr.next();\n+            itr.remove();\n+            field.invalidate();\n+        }\n+    }\n+\n+    /**\n+      *  Remove a field from this class.  After this method, the removed field\n+     *  will be invalid, and the result of any operations on it is undefined.\n+     *\n+     *  @return true if this class contained the field, false otherwise\n+     */\n+    public boolean removeDeclaredField(String name) {\n+        Collection fields = _state.getFieldsHolder();\n+        BCField field;\n+\n+        for (Iterator itr = fields.iterator(); itr.hasNext();) {\n+            field = (BCField) itr.next();\n+\n+            if (field.getName().equals(name)) {\n+                itr.remove();\n+                field.invalidate();\n+\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+      *  Remove a field from this class.  After this method, the removed field\n+     *  will be invalid, and the result of any operations on it is undefined.\n+     *\n+     *  @return true if this class contained the field, false otherwise\n+     */\n+    public boolean removeDeclaredField(BCField field) {\n+        if (field == null) {\n+            return false;\n+        }\n+\n+        return removeDeclaredField(field.getName());\n+    }\n+\n+    //////////////////////\n+    // Method operations\n+    //////////////////////\n+\n+    /**\n+     *  Return all methods declared by this class.  Constructors and static\n+     *  initializers are included.\n+     */\n+    public BCMethod[] getDeclaredMethods() {\n+        Collection methods = _state.getMethodsHolder();\n+\n+        return (BCMethod[]) methods.toArray(new BCMethod[methods.size()]);\n+    }\n+\n+    /**\n+     *  Return the declared method with the given name, or null if none.\n+     *  If multiple methods are declared with the given name, which is returned\n+     *  is undefined.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     */\n+    public BCMethod getDeclaredMethod(String name) {\n+        BCMethod[] methods = getDeclaredMethods();\n+\n+        for (int i = 0; i < methods.length; i++)\n+            if (methods[i].getName().equals(name)) {\n+                return methods[i];\n+            }\n+\n+        return null;\n+    }\n+\n+    /**\n+     *  Return all the declared methods with the given name, or an empty array\n+     *  if none.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     */\n+    public BCMethod[] getDeclaredMethods(String name) {\n+        Collection matches = new LinkedList();\n+        BCMethod[] methods = getDeclaredMethods();\n+\n+        for (int i = 0; i < methods.length; i++)\n+            if (methods[i].getName().equals(name)) {\n+                matches.add(methods[i]);\n+            }\n+\n+        return (BCMethod[]) matches.toArray(new BCMethod[matches.size()]);\n+    }\n+\n+    /**\n+     *  Return the declared method with the given name and parameter types,\n+     *  or null if none.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     */\n+    public BCMethod getDeclaredMethod(String name, String[] paramTypes) {\n+        if (paramTypes == null) {\n+            paramTypes = new String[0];\n+        }\n+\n+        String[] curParams;\n+        boolean match;\n+        BCMethod[] methods = getDeclaredMethods();\n+\n+        for (int i = 0; i < methods.length; i++) {\n+            if (methods[i].getName().equals(name)) {\n+                curParams = methods[i].getParamNames();\n+\n+                if (curParams.length != paramTypes.length) {\n+                    continue;\n+                }\n+\n+                match = true;\n+\n+                for (int j = 0; j < paramTypes.length; j++) {\n+                    if (!curParams[j].equals(_project.getNameCache()\n+                                                         .getExternalForm(paramTypes[j],\n+                                    false))) {\n+                        match = false;\n+\n+                        break;\n+                    }\n+                }\n+\n+                if (match) {\n+                    return methods[i];\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     *  Return the declared method with the given name and parameter types,\n+     *  or null if none.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     */\n+    public BCMethod getDeclaredMethod(String name, Class[] paramTypes) {\n+        if (paramTypes == null) {\n+            return getDeclaredMethod(name, (String[]) null);\n+        }\n+\n+        String[] paramNames = new String[paramTypes.length];\n+\n+        for (int i = 0; i < paramTypes.length; i++)\n+            paramNames[i] = paramTypes[i].getName();\n+\n+        return getDeclaredMethod(name, paramNames);\n+    }\n+\n+    /**\n+     *  Return the declared method with the given name and parameter types,\n+     *  or null if none.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     */\n+    public BCMethod getDeclaredMethod(String name, BCClass[] paramTypes) {\n+        if (paramTypes == null) {\n+            return getDeclaredMethod(name, (String[]) null);\n+        }\n+\n+        String[] paramNames = new String[paramTypes.length];\n+\n+        for (int i = 0; i < paramTypes.length; i++)\n+            paramNames[i] = paramTypes[i].getName();\n+\n+        return getDeclaredMethod(name, paramNames);\n+    }\n+\n+    /**\n+     *  Return the methods of this class, including those of all superclasses,\n+     *  or an empty array if none.\n+     *  The base version of methods that are overridden will be included, as\n+     *  will all constructors and static initializers.\n+     *  The methods will be ordered from those in the most-specific type up to\n+     *  those in {@link Object}.\n+     */\n+    public BCMethod[] getMethods() {\n+        Collection allMethods = new LinkedList();\n+        BCMethod[] methods;\n+\n+        for (BCClass type = this; type != null;\n+                type = type.getSuperclassBC()) {\n+            methods = type.getDeclaredMethods();\n+\n+            for (int i = 0; i < methods.length; i++)\n+                allMethods.add(methods[i]);\n+        }\n+\n+        return (BCMethod[]) allMethods.toArray(new BCMethod[allMethods.size()]);\n+    }\n+\n+    /**\n+     *  Return the methods with the given name, including those of all\n+     *  superclasses, or an empty array if none.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     */\n+    public BCMethod[] getMethods(String name) {\n+        Collection matches = new LinkedList();\n+        BCMethod[] methods = getMethods();\n+\n+        for (int i = 0; i < methods.length; i++)\n+            if (methods[i].getName().equals(name)) {\n+                matches.add(methods[i]);\n+            }\n+\n+        return (BCMethod[]) matches.toArray(new BCMethod[matches.size()]);\n+    }\n+\n+    /**\n+     *  Return the methods with the given name and parameter types, including\n+     *  those of all superclasses, or an empty array if none.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     */\n+    public BCMethod[] getMethods(String name, String[] paramTypes) {\n+        if (paramTypes == null) {\n+            paramTypes = new String[0];\n+        }\n+\n+        String[] curParams;\n+        boolean match;\n+        BCMethod[] methods = getMethods();\n+        Collection matches = new LinkedList();\n+\n+        for (int i = 0; i < methods.length; i++) {\n+            if (methods[i].getName().equals(name)) {\n+                curParams = methods[i].getParamNames();\n+\n+                if (curParams.length != paramTypes.length) {\n+                    continue;\n+                }\n+\n+                match = true;\n+\n+                for (int j = 0; j < paramTypes.length; j++) {\n+                    if (!curParams[j].equals(_project.getNameCache()\n+                                                         .getExternalForm(paramTypes[j],\n+                                    false))) {\n+                        match = false;\n+\n+                        break;\n+                    }\n+                }\n+\n+                if (match) {\n+                    matches.add(methods[i]);\n+                }\n+            }\n+        }\n+\n+        return (BCMethod[]) matches.toArray(new BCMethod[matches.size()]);\n+    }\n+\n+    /**\n+     *  Return the methods with the given name and parameter types, including\n+     *  those of all superclasses, or an empty array if none.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     */\n+    public BCMethod[] getMethods(String name, Class[] paramTypes) {\n+        if (paramTypes == null) {\n+            return getMethods(name, (String[]) null);\n+        }\n+\n+        String[] paramNames = new String[paramTypes.length];\n+\n+        for (int i = 0; i < paramTypes.length; i++)\n+            paramNames[i] = paramTypes[i].getName();\n+\n+        return getMethods(name, paramNames);\n+    }\n+\n+    /**\n+     *  Return the methods with the given name and parameter types, including\n+     *  those of all superclasses, or an empty array if none.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     */\n+    public BCMethod[] getMethods(String name, BCClass[] paramTypes) {\n+        if (paramTypes == null) {\n+            return getMethods(name, (String[]) null);\n+        }\n+\n+        String[] paramNames = new String[paramTypes.length];\n+\n+        for (int i = 0; i < paramTypes.length; i++)\n+            paramNames[i] = paramTypes[i].getName();\n+\n+        return getMethods(name, paramNames);\n+    }\n+\n+    /**\n+     *  Set the methods for this class; this method is useful for importing all\n+     *  methods from another class.  Set to null or empty array if none.\n+     */\n+    public void setDeclaredMethods(BCMethod[] methods) {\n+        clearDeclaredMethods();\n+\n+        if (methods != null) {\n+            for (int i = 0; i < methods.length; i++)\n+                declareMethod(methods[i]);\n+        }\n+    }\n+\n+    /**\n+     *  Import the information in the given method as a new method of this\n+     *  class.\n+     *\n+     *  @return the added method\n+     */\n+    public BCMethod declareMethod(BCMethod method) {\n+        BCMethod newMethod = declareMethod(method.getName(),\n+                method.getReturnName(), method.getParamNames());\n+        newMethod.setAccessFlags(method.getAccessFlags());\n+        newMethod.setAttributes(method.getAttributes());\n+\n+        return newMethod;\n+    }\n+\n+    /**\n+     *  Add a method to this class.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     *\n+     *  @return the added method\n+     */\n+    public BCMethod declareMethod(String name, String returnType,\n+        String[] paramTypes) {\n+        BCMethod method = new BCMethod(this);\n+        _state.getMethodsHolder().add(method);\n+        method.initialize(name,\n+            _project.getNameCache().getDescriptor(returnType, paramTypes));\n+\n+        return method;\n+    }\n+\n+    /**\n+     *  Add a method to this class.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     *\n+     *  @return the added method\n+     */\n+    public BCMethod declareMethod(String name, Class returnType,\n+        Class[] paramTypes) {\n+        String[] paramNames = null;\n+\n+        if (paramTypes != null) {\n+            paramNames = new String[paramTypes.length];\n+\n+            for (int i = 0; i < paramTypes.length; i++)\n+                paramNames[i] = paramTypes[i].getName();\n+        }\n+\n+        String returnName = (returnType == null) ? null : returnType.getName();\n+\n+        return declareMethod(name, returnName, paramNames);\n+    }\n+\n+    /**\n+     *  Add a method to this class.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     *\n+     *  @return the added method\n+     */\n+    public BCMethod declareMethod(String name, BCClass returnType,\n+        BCClass[] paramTypes) {\n+        String[] paramNames = null;\n+\n+        if (paramTypes != null) {\n+            paramNames = new String[paramTypes.length];\n+\n+            for (int i = 0; i < paramTypes.length; i++)\n+                paramNames[i] = paramTypes[i].getName();\n+        }\n+\n+        String returnName = (returnType == null) ? null : returnType.getName();\n+\n+        return declareMethod(name, returnName, paramNames);\n+    }\n+\n+    /**\n+     *  Clear all declared methods from this class.\n+     */\n+    public void clearDeclaredMethods() {\n+        Collection methods = _state.getMethodsHolder();\n+        BCMethod method;\n+\n+        for (Iterator itr = methods.iterator(); itr.hasNext();) {\n+            method = (BCMethod) itr.next();\n+            itr.remove();\n+            method.invalidate();\n+        }\n+    }\n+\n+    /**\n+      *  Remove a method from this class.  After this method, the removed method\n+     *  will be invalid, and the result of any operations on it is undefined.\n+     *  If multiple methods match the given name, which is removed is undefined.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     *\n+     *  @return true if this class contained the method, false otherwise\n+     */\n+    public boolean removeDeclaredMethod(String name) {\n+        Collection methods = _state.getMethodsHolder();\n+        BCMethod method;\n+\n+        for (Iterator itr = methods.iterator(); itr.hasNext();) {\n+            method = (BCMethod) itr.next();\n+\n+            if (method.getName().equals(name)) {\n+                itr.remove();\n+                method.invalidate();\n+\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+      *  Removes a method from this class.  After this method, the removed method\n+     *  will be invalid, and the result of any operations on it is undefined.\n+     *\n+     *  @return true if this class contained the method, false otherwise\n+     */\n+    public boolean removeDeclaredMethod(BCMethod method) {\n+        if (method == null) {\n+            return false;\n+        }\n+\n+        return removeDeclaredMethod(method.getName(), method.getParamNames());\n+    }\n+\n+    /**\n+      *  Removes a method from this class.  After this method, the removed method\n+     *  will be invalid, and the result of any operations on it is undefined.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     *\n+     *  @return true if this class contained the method, false otherwise\n+     */\n+    public boolean removeDeclaredMethod(String name, String[] paramTypes) {\n+        if (paramTypes == null) {\n+            paramTypes = new String[0];\n+        }\n+\n+        String[] curParams;\n+        boolean match;\n+        Collection methods = _state.getMethodsHolder();\n+        BCMethod method;\n+\n+        for (Iterator itr = methods.iterator(); itr.hasNext();) {\n+            method = (BCMethod) itr.next();\n+\n+            if (method.getName().equals(name)) {\n+                curParams = method.getParamNames();\n+\n+                if (curParams.length != paramTypes.length) {\n+                    continue;\n+                }\n+\n+                match = true;\n+\n+                for (int j = 0; j < paramTypes.length; j++) {\n+                    if (!curParams[j].equals(_project.getNameCache()\n+                                                         .getExternalForm(paramTypes[j],\n+                                    false))) {\n+                        match = false;\n+\n+                        break;\n+                    }\n+                }\n+\n+                if (match) {\n+                    itr.remove();\n+                    method.invalidate();\n+\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+      *  Removes a method from this class.  After this method, the removed method\n+     *  will be invalid, and the result of any operations on it is undefined.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     *\n+     *  @return true if this class contained the method, false otherwise\n+     */\n+    public boolean removeDeclaredMethod(String name, Class[] paramTypes) {\n+        if (paramTypes == null) {\n+            return removeDeclaredMethod(name, (String[]) null);\n+        }\n+\n+        String[] paramNames = new String[paramTypes.length];\n+\n+        for (int i = 0; i < paramTypes.length; i++)\n+            paramNames[i] = paramTypes[i].getName();\n+\n+        return removeDeclaredMethod(name, paramNames);\n+    }\n+\n+    /**\n+      *  Removes a method from this class.  After this method, the removed method\n+     *  will be invalid, and the result of any operations on it is undefined.\n+     *  Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n+     *  and static initializers are named <code>&lt;clinit&gt;</code>.\n+     *\n+     *  @return true if this class contained the method, false otherwise\n+     */\n+    public boolean removeDeclaredMethod(String name, BCClass[] paramTypes) {\n+        if (paramTypes == null) {\n+            return removeDeclaredMethod(name, (String[]) null);\n+        }\n+\n+        String[] paramNames = new String[paramTypes.length];\n+\n+        for (int i = 0; i < paramTypes.length; i++)\n+            paramNames[i] = paramTypes[i].getName();\n+\n+        return removeDeclaredMethod(name, paramNames);\n+    }\n+\n+    ///////////////////////\n+    // Convenience methods\n+    ///////////////////////\n+\n+    /**\n+     *  Convenience method to add a default constructor to this class.\n+     *  If a default constructor already exists, this method will return it\n+     *  without modification.\n+     *  This method can only be        called if the superclass has been set.\n+      *\n+     *  @return the default constructor\n+     */\n+    public BCMethod addDefaultConstructor() {\n+        BCMethod method = getDeclaredMethod(\"<init>\", (String[]) null);\n+\n+        if (method != null) {\n+            return method;\n+        }\n+\n+        method = declareMethod(\"<init>\", void.class, null);\n+\n+        Code code = method.getCode(true);\n+        code.setMaxStack(1);\n+        code.setMaxLocals(1);\n+\n+        code.xload().setThis();\n+        code.invokespecial()\n+            .setMethod(getSuperclassName(), \"<init>\", \"void\", null);\n+        code.vreturn();\n+\n+        return method;\n+    }\n+\n+    /**\n+     *  Return source file information for the class.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @param add                if true, a new source file attribute will be added\n+     *                                  if not already present\n+     *  @return the source file information, or null if none and the\n+     *                                  <code>add</code> param is set to false\n+     */\n+    public SourceFile getSourceFile(boolean add) {\n+        SourceFile source = (SourceFile) getAttribute(Constants.ATTR_SOURCE);\n+\n+        if (!add || (source != null)) {\n+            return source;\n+        }\n+\n+        return (SourceFile) addAttribute(Constants.ATTR_SOURCE);\n+    }\n+\n+    /**\n+     *  Remove the source file attribute for the class.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @return true if there was a file to remove\n+     */\n+    public boolean removeSourceFile() {\n+        return removeAttribute(Constants.ATTR_SOURCE);\n+    }\n+\n+    /**\n+     *  Return inner classes information for the class.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @param add                if true, a new inner classes attribute will be added\n+     *                                  if not already present\n+     *  @return the inner classes information, or null if none and the\n+     *                                  <code>add</code> param is set to false\n+     */\n+    public InnerClasses getInnerClasses(boolean add) {\n+        InnerClasses inner = (InnerClasses) getAttribute(Constants.ATTR_INNERCLASS);\n+\n+        if (!add || (inner != null)) {\n+            return inner;\n+        }\n+\n+        return (InnerClasses) addAttribute(Constants.ATTR_INNERCLASS);\n+    }\n+\n+    /**\n+     *  Remove the inner classes attribute for the class.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @return true if there was an attribute to remove\n+     */\n+    public boolean removeInnerClasses() {\n+        return removeAttribute(Constants.ATTR_INNERCLASS);\n+    }\n+\n+    /**\n+     *  Convenience method to return deprecation information for the class.\n+     *  Acts internally through the {@link Attributes} interface.\n+     */\n+    public boolean isDeprecated() {\n+        return getAttribute(Constants.ATTR_DEPRECATED) != null;\n+    }\n+\n+    /**\n+     *  Convenience method to set whether this class should be considered\n+     *  deprecated.\n+     *  Acts internally through the {@link Attributes} interface.\n+     */\n+    public void setDeprecated(boolean on) {\n+        if (!on) {\n+            removeAttribute(Constants.ATTR_DEPRECATED);\n+        } else if (!isDeprecated()) {\n+            addAttribute(Constants.ATTR_DEPRECATED);\n+        }\n+    }\n+\n+    ///////////////////////////////////\n+    // Implementation of VisitAcceptor\n+    ///////////////////////////////////\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterBCClass(this);\n+\n+        ConstantPool pool = null;\n+\n+        try {\n+            pool = _state.getPool();\n+        } catch (UnsupportedOperationException uoe) {\n+        }\n+\n+        if (pool != null) {\n+            pool.acceptVisit(visit);\n+        }\n+\n+        BCField[] fields = getDeclaredFields();\n+\n+        for (int i = 0; i < fields.length; i++) {\n+            visit.enterBCMember(fields[i]);\n+            fields[i].acceptVisit(visit);\n+            visit.exitBCMember(fields[i]);\n+        }\n+\n+        BCMethod[] methods = getDeclaredMethods();\n+\n+        for (int i = 0; i < methods.length; i++) {\n+            visit.enterBCMember(methods[i]);\n+            methods[i].acceptVisit(visit);\n+            visit.exitBCMember(methods[i]);\n+        }\n+\n+        visitAttributes(visit);\n+        visit.exitBCClass(this);\n+    }\n+\n+    ////////////////////////////////\n+    // Implementation of Attributes\n+    ////////////////////////////////\n+    public Project getProject() {\n+        return _project;\n+    }\n+\n+    public ConstantPool getPool() {\n+        return _state.getPool();\n+    }\n+\n+    public ClassLoader getClassLoader() {\n+        if (_loader != null) {\n+            return _loader;\n+        }\n+\n+        return Thread.currentThread().getContextClassLoader();\n+    }\n+\n+    public boolean isValid() {\n+        return _project != null;\n+    }\n+\n+    Collection getAttributesHolder() {\n+        return _state.getAttributesHolder();\n+    }\n+\n+    /**\n+     *  Attempts to change the class name with the owning project.  The project\n+     *  can reject the change if a class with the given new name already\n+     *  exists; therefore this method should be called before the change is\n+     *  recorded in the class.\n+     */\n+    private void beforeRename(String oldName, String newName) {\n+        if ((_project != null) && (oldName != null)) {\n+            _project.renameClass(oldName, newName, this);\n+        }\n+    }\n+}"},{"sha":"6e3b8edd44826949ebb50222cef54604ea73fbc3","filename":"serp/src/main/java/serp/bytecode/BCClassLoader.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/BCClassLoader.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/BCClassLoader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCClassLoader.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+\n+/**\n+ *  <p>Class loader that will attempt to find requested classes in a given\n+ *  {@link Project}.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class BCClassLoader extends ClassLoader {\n+    private Project _project = null;\n+\n+    /**\n+     *  Constructor.  Supply the project to use when looking for classes.\n+     */\n+    public BCClassLoader(Project project) {\n+        _project = project;\n+    }\n+\n+    /**\n+     *  Constructor.  Supply the project to use when looking for classes.\n+      *\n+     *  @param parent         the parent classoader\n+     */\n+    public BCClassLoader(Project project, ClassLoader loader) {\n+        super(loader);\n+        _project = project;\n+    }\n+\n+    /**\n+     *  Return this class loader's project.\n+     */\n+    public Project getProject() {\n+        return _project;\n+    }\n+\n+    protected Class findClass(String name) throws ClassNotFoundException {\n+        byte[] bytes;\n+\n+        try {\n+            BCClass type;\n+\n+            if (!_project.containsClass(name)) {\n+                type = createClass(name);\n+            } else {\n+                type = _project.loadClass(name);\n+            }\n+\n+            if (type == null) {\n+                throw new ClassNotFoundException(name);\n+            }\n+\n+            bytes = type.toByteArray();\n+        } catch (RuntimeException re) {\n+            throw new ClassNotFoundException(re.toString());\n+        }\n+\n+        return defineClass(name, bytes, 0, bytes.length);\n+    }\n+\n+    /**\n+     *  Override this method if unfound classes should be created on-the-fly.\n+     *  Returns null by default.\n+     */\n+    protected BCClass createClass(String name) {\n+        return null;\n+    }\n+}"},{"sha":"5d5ac85bd43e364b4193f4afb560017d669250a7","filename":"serp/src/main/java/serp/bytecode/BCEntity.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/BCEntity.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/BCEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCEntity.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+\n+/**\n+ *  <p>Interface implemented by all bytecode entities.  Entities must be able\n+ *  to access the project, constant pool, and class loader of the current\n+ *  class.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public interface BCEntity {\n+    /**\n+     *  Return the project of the current class.\n+     */\n+    public Project getProject();\n+\n+    /**\n+     *  Return the constant pool of the current class.\n+     */\n+    public ConstantPool getPool();\n+\n+    /**\n+     *  Return the class loader to use when loading related classes.\n+     */\n+    public ClassLoader getClassLoader();\n+\n+    /**\n+     *  Return false if this entity has been removed from its parent; in this\n+     *  case the results of any operations on the entity are undefined.\n+     */\n+    public boolean isValid();\n+}"},{"sha":"aad057a1dfa82ebbc3e83e281ea3a41829d0428e","filename":"serp/src/main/java/serp/bytecode/BCField.java","status":"added","additions":166,"deletions":0,"changes":166,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/BCField.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/BCField.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCField.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import serp.util.*;\n+\n+\n+/**\n+ *  <p>A field of a class.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class BCField extends BCMember implements VisitAcceptor {\n+    BCField(BCClass owner) {\n+        super(owner);\n+    }\n+\n+    /**\n+     *  Manipulate the field access flags.\n+     */\n+    public boolean isVolatile() {\n+        return (getAccessFlags() & Constants.ACCESS_VOLATILE) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the field access flags.\n+     */\n+    public void setVolatile(boolean on) {\n+        if (on) {\n+            setAccessFlags(getAccessFlags() | Constants.ACCESS_VOLATILE);\n+        } else {\n+            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_VOLATILE);\n+        }\n+    }\n+\n+    /**\n+     *  Manipulate the field access flags.\n+     */\n+    public boolean isTransient() {\n+        return (getAccessFlags() & Constants.ACCESS_TRANSIENT) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the field access flags.\n+     */\n+    public void setTransient(boolean on) {\n+        if (on) {\n+            setAccessFlags(getAccessFlags() | Constants.ACCESS_TRANSIENT);\n+        } else {\n+            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_TRANSIENT);\n+        }\n+    }\n+\n+    /**\n+     *  Return the name of the type of this field.  The name will be given in\n+     *  a form suitable for a {@link Class#forName} call.\n+     *\n+     *  @see BCMember#getDescriptor\n+     */\n+    public String getTypeName() {\n+        return getProject().getNameCache()\n+                   .getExternalForm(getDescriptor(), false);\n+    }\n+\n+    /**\n+     *  Return the {@link Class} object for the type of this field.\n+     */\n+    public Class getType() {\n+        return Strings.toClass(getTypeName(), getClassLoader());\n+    }\n+\n+    /**\n+     *  Return the bytecode for the type of this field.\n+     */\n+    public BCClass getTypeBC() {\n+        return getProject().loadClass(getTypeName(), getClassLoader());\n+    }\n+\n+    /**\n+     *  Set the name of the type of this field.\n+     *\n+     *  @see BCMember#setDescriptor\n+     */\n+    public void setType(String type) {\n+        setDescriptor(type);\n+    }\n+\n+    /**\n+     *  Set the type of this field.\n+     *\n+     *  @see BCMember#setDescriptor\n+     */\n+    public void setType(Class type) {\n+        setType(type.getName());\n+    }\n+\n+    /**\n+     *  Set the type of this field.\n+     *\n+     *  @see BCMember#setDescriptor\n+     */\n+    public void setType(BCClass type) {\n+        setType(type.getName());\n+    }\n+\n+    /**\n+     *  Return the constant value information for the field.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @param add                if true, a new constant value attribute will be added\n+     *                                  if not already present\n+     *  @return the constant value information, or null if none and the\n+     *                                  <code>add</code> param is set to false\n+     */\n+    public ConstantValue getConstantValue(boolean add) {\n+        ConstantValue constant = (ConstantValue) getAttribute(Constants.ATTR_CONST);\n+\n+        if (!add || (constant != null)) {\n+            return constant;\n+        }\n+\n+        if (constant == null) {\n+            constant = (ConstantValue) addAttribute(Constants.ATTR_CONST);\n+        }\n+\n+        return constant;\n+    }\n+\n+    /**\n+     *  Remove the constant value attribute for the field.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @return true if there was a value to remove\n+     */\n+    public boolean removeConstantValue() {\n+        return removeAttribute(Constants.ATTR_CONST);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterBCField(this);\n+        visitAttributes(visit);\n+        visit.exitBCField(this);\n+    }\n+\n+    void initialize(String name, String descriptor) {\n+        super.initialize(name, descriptor);\n+        makePrivate();\n+    }\n+}"},{"sha":"92c80aac39eedc4c19c0ee91676f77f0b8a71848","filename":"serp/src/main/java/serp/bytecode/BCMember.java","status":"added","additions":399,"deletions":0,"changes":399,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/BCMember.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/BCMember.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCMember.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,399 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>A member field or method of a class.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public abstract class BCMember extends Attributes {\n+    private BCClass _owner = null;\n+    private int _access = Constants.ACCESS_PRIVATE;\n+    private int _nameIndex = 0;\n+    private int _descriptorIndex = 0;\n+    private Collection _attrs = new LinkedList();\n+\n+    BCMember(BCClass owner) {\n+        _owner = owner;\n+    }\n+\n+    /**\n+     *  Return the {@link BCClass} that declares this member.\n+     */\n+    public BCClass getDeclarer() {\n+        return _owner;\n+    }\n+\n+    /////////////////////\n+    // Access operations\n+    /////////////////////\n+\n+    /**\n+     *  Return the access flags for this member as a bit array of\n+      *  ACCESS_XXX constants from {@link Constants}.  This can be used to\n+     *  transfer access flags between members without getting/setting each\n+     *  possible access flag.  Defaults to {@link Constants#ACCESS_PRIVATE}\n+     */\n+    public int getAccessFlags() {\n+        return _access;\n+    }\n+\n+    /**\n+     *  Set the access flags for this member as a bit array of\n+      *  ACCESS_XXX constants from {@link Constants}.  This can be used to\n+     *  transfer access flags between members without getting/setting each\n+     *  possible access flag.  Defaults to {@link Constants#ACCESS_PRIVATE}\n+     */\n+    public void setAccessFlags(int access) {\n+        _access = access;\n+    }\n+\n+    /**\n+     *  Manipulate the member access flags.\n+     */\n+    public boolean isPublic() {\n+        return (getAccessFlags() & Constants.ACCESS_PUBLIC) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the member access flags.\n+     */\n+    public void makePublic() {\n+        setAccessFlags(getAccessFlags() | Constants.ACCESS_PUBLIC);\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PRIVATE);\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PROTECTED);\n+    }\n+\n+    /**\n+     *  Manipulate the member access flags.\n+     */\n+    public boolean isProtected() {\n+        return (getAccessFlags() & Constants.ACCESS_PROTECTED) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the member access flags.\n+     */\n+    public void makeProtected() {\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PUBLIC);\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PRIVATE);\n+        setAccessFlags(getAccessFlags() | Constants.ACCESS_PROTECTED);\n+    }\n+\n+    /**\n+     *  Manipulate the member access flags.\n+     */\n+    public boolean isPrivate() {\n+        return (getAccessFlags() & Constants.ACCESS_PRIVATE) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the member access flags.\n+     */\n+    public void makePrivate() {\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PUBLIC);\n+        setAccessFlags(getAccessFlags() | Constants.ACCESS_PRIVATE);\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PROTECTED);\n+    }\n+\n+    /**\n+     *  Manipulate the member access flags.\n+     */\n+    public boolean isPackage() {\n+        boolean hasAccess = false;\n+        hasAccess = hasAccess ||\n+            ((getAccessFlags() & Constants.ACCESS_PRIVATE) > 0);\n+        hasAccess = hasAccess ||\n+            ((getAccessFlags() & Constants.ACCESS_PROTECTED) > 0);\n+        hasAccess = hasAccess ||\n+            ((getAccessFlags() & Constants.ACCESS_PUBLIC) > 0);\n+\n+        return !hasAccess;\n+    }\n+\n+    /**\n+     *  Manipulate the member access flags.\n+     */\n+    public void makePackage() {\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PUBLIC);\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PRIVATE);\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PROTECTED);\n+    }\n+\n+    /**\n+     *  Manipulate the member access flags.\n+     */\n+    public boolean isFinal() {\n+        return (getAccessFlags() & Constants.ACCESS_FINAL) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the member access flags.\n+     */\n+    public void setFinal(boolean on) {\n+        if (on) {\n+            setAccessFlags(getAccessFlags() | Constants.ACCESS_FINAL);\n+        } else {\n+            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_FINAL);\n+        }\n+    }\n+\n+    /**\n+     *  Manipulate the member access flags.\n+     */\n+    public boolean isStatic() {\n+        return (getAccessFlags() & Constants.ACCESS_STATIC) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the member access flags.\n+     */\n+    public void setStatic(boolean on) {\n+        if (on) {\n+            setAccessFlags(getAccessFlags() | Constants.ACCESS_STATIC);\n+        } else {\n+            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_STATIC);\n+        }\n+    }\n+\n+    /////////////////////////\n+    // Descriptor operations\n+    /////////////////////////\n+\n+    /**\n+     *  Return the index in the class {@link ConstantPool} of the\n+     *  {@link UTF8Entry} holding the name of this member.\n+     */\n+    public int getNameIndex() {\n+        return _nameIndex;\n+    }\n+\n+    /**\n+     *  Set the index in the class {@link ConstantPool} of the\n+     *  {@link UTF8Entry} holding the name of this member.\n+     */\n+    public void setNameIndex(int index) {\n+        String origName = getName();\n+        _nameIndex = index;\n+\n+        // change all the references in the owning class\n+        setEntry(origName, getDescriptor());\n+    }\n+\n+    /**\n+     *  Return the index in the class {@link ConstantPool} of the\n+     *  {@link UTF8Entry} holding the descriptor of this member.\n+     */\n+    public int getDescriptorIndex() {\n+        return _descriptorIndex;\n+    }\n+\n+    /**\n+     *  Set the index in the class {@link ConstantPool} of the\n+     *  {@link UTF8Entry} holding the descriptor of this member.\n+     */\n+    public void setDescriptorIndex(int index) {\n+        String origDesc = getDescriptor();\n+        _descriptorIndex = index;\n+\n+        // change all the references in the owning class\n+        setEntry(getName(), origDesc);\n+    }\n+\n+    /**\n+     *  Return the name of this member.\n+     */\n+    public String getName() {\n+        return ((UTF8Entry) getPool().getEntry(_nameIndex)).getValue();\n+    }\n+\n+    /**\n+     *  Set the name of this member.\n+     */\n+    public void setName(String name) {\n+        String origName = getName();\n+\n+        // reset the name\n+        _nameIndex = getPool().findUTF8Entry(name, true);\n+\n+        // change all references in the owning class\n+        setEntry(origName, getDescriptor());\n+    }\n+\n+    /**\n+     *  Return the descriptor of this member, in internal form.\n+     */\n+    public String getDescriptor() {\n+        return ((UTF8Entry) getPool().getEntry(_descriptorIndex)).getValue();\n+    }\n+\n+    /**\n+     *  Set the descriptor of this member.\n+     */\n+    public void setDescriptor(String desc) {\n+        String origDesc = getDescriptor();\n+\n+        // reset the desc\n+        desc = getProject().getNameCache().getInternalForm(desc, true);\n+        _descriptorIndex = getPool().findUTF8Entry(desc, true);\n+\n+        // change all the references in the owning class\n+        setEntry(getName(), origDesc);\n+    }\n+\n+    /**\n+     *  Resets the {@link ComplexEntry} of the owning class corresponding to\n+     *  this member.  Changes in the member will therefore propogate to all\n+     *  code in the class.\n+      */\n+    private void setEntry(String origName, String origDesc) {\n+        // find the entry matching this member, if any\n+        String owner = getProject().getNameCache()\n+                           .getInternalForm(_owner.getName(), false);\n+        ConstantPool pool = getPool();\n+\n+        int index;\n+\n+        if (this instanceof BCField) {\n+            index = pool.findFieldEntry(origName, origDesc, owner, false);\n+        } else if (!_owner.isInterface()) {\n+            index = pool.findMethodEntry(origName, origDesc, owner, false);\n+        } else {\n+            index = pool.findInterfaceMethodEntry(origName, origDesc, owner,\n+                    false);\n+        }\n+\n+        // change the entry to match the new info; this is dones so\n+        // that refs to the member in code will still be valid after the \n+        // change, without changing any other constants that happened to match\n+        // the old name and/or descriptor\n+        if (index != 0) {\n+            ComplexEntry complex = (ComplexEntry) pool.getEntry(index);\n+            int ntIndex = pool.findNameAndTypeEntry(getName(), getDescriptor(),\n+                    true);\n+            complex.setNameAndTypeIndex(ntIndex);\n+        }\n+    }\n+\n+    ///////////////////////\n+    // Convenience methods\n+    ///////////////////////\n+\n+    /**\n+     *  Convenience method to return deprecation information for the member.\n+     *  Acts internally through the {@link Attributes} interface.\n+     */\n+    public boolean isDeprecated() {\n+        return getAttribute(Constants.ATTR_DEPRECATED) != null;\n+    }\n+\n+    /**\n+     *  Convenience method to set whether this member should be considered\n+     *  deprecated.\n+     *  Acts internally through the {@link Attributes} interface.\n+     */\n+    public void setDeprecated(boolean on) {\n+        if (!on) {\n+            removeAttribute(Constants.ATTR_DEPRECATED);\n+        } else if (!isDeprecated()) {\n+            addAttribute(Constants.ATTR_DEPRECATED);\n+        }\n+    }\n+\n+    /**\n+     *  Convenience method to return synthetic information for the member.\n+     *  Acts internally through the {@link Attributes} interface.\n+     */\n+    public boolean isSynthetic() {\n+        return getAttribute(Constants.ATTR_SYNTHETIC) != null;\n+    }\n+\n+    /**\n+     *  Convenience method to set whether this member should be considered\n+     *  synthetic.\n+     *  Acts internally through the {@link Attributes} interface.\n+     */\n+    public void setSynthetic(boolean on) {\n+        if (!on) {\n+            removeAttribute(Constants.ATTR_SYNTHETIC);\n+        } else if (!isSynthetic()) {\n+            addAttribute(Constants.ATTR_SYNTHETIC);\n+        }\n+    }\n+\n+    ////////////////////////////////\n+    // Implementation of Attributes\n+    ////////////////////////////////\n+    public Project getProject() {\n+        return _owner.getProject();\n+    }\n+\n+    public ConstantPool getPool() {\n+        return _owner.getPool();\n+    }\n+\n+    public ClassLoader getClassLoader() {\n+        return _owner.getClassLoader();\n+    }\n+\n+    public boolean isValid() {\n+        return _owner != null;\n+    }\n+\n+    Collection getAttributesHolder() {\n+        return _attrs;\n+    }\n+\n+    /**\n+     *  Either this method or {@link #read} must be called prior to use\n+     *  of this class.  The given descriptor must be in internal form.\n+     */\n+    void initialize(String name, String descriptor) {\n+        _nameIndex = getPool().findUTF8Entry(name, true);\n+        _descriptorIndex = getPool().findUTF8Entry(descriptor, true);\n+    }\n+\n+    /**\n+     *  Used when this member is deleted from its class.\n+     */\n+    void invalidate() {\n+        _owner = null;\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        _access = in.readUnsignedShort();\n+        _nameIndex = in.readUnsignedShort();\n+        _descriptorIndex = in.readUnsignedShort();\n+\n+        readAttributes(in);\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        out.writeShort(_access);\n+        out.writeShort(_nameIndex);\n+        out.writeShort(_descriptorIndex);\n+\n+        writeAttributes(out);\n+    }\n+}"},{"sha":"1803590d086c9c6b32440d3f21a3c2c72f5c444b","filename":"serp/src/main/java/serp/bytecode/BCMethod.java","status":"added","additions":498,"deletions":0,"changes":498,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/BCMethod.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/BCMethod.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCMethod.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,498 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import serp.util.*;\n+\n+\n+/**\n+ *  <p>A method of a class.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class BCMethod extends BCMember implements VisitAcceptor {\n+    BCMethod(BCClass owner) {\n+        super(owner);\n+    }\n+\n+    /////////////////////\n+    // Access operations\n+    /////////////////////\n+\n+    /**\n+     *  Manipulate the method access flags.\n+     */\n+    public boolean isSynchronized() {\n+        return (getAccessFlags() & Constants.ACCESS_SYNCHRONIZED) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the method access flags.\n+     */\n+    public void setSynchronized(boolean on) {\n+        if (on) {\n+            setAccessFlags(getAccessFlags() | Constants.ACCESS_SYNCHRONIZED);\n+        } else {\n+            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_SYNCHRONIZED);\n+        }\n+    }\n+\n+    /**\n+     *  Manipulate the method access flags.\n+     */\n+    public boolean isNative() {\n+        return (getAccessFlags() & Constants.ACCESS_NATIVE) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the method access flags.\n+     */\n+    public void setNative(boolean on) {\n+        if (on) {\n+            setAccessFlags(getAccessFlags() | Constants.ACCESS_NATIVE);\n+        } else {\n+            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_NATIVE);\n+        }\n+    }\n+\n+    /**\n+     *  Manipulate the method access flags.\n+     */\n+    public boolean isAbstract() {\n+        return (getAccessFlags() & Constants.ACCESS_ABSTRACT) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the method access flags.\n+     */\n+    public void setAbstract(boolean on) {\n+        if (on) {\n+            setAccessFlags(getAccessFlags() | Constants.ACCESS_ABSTRACT);\n+        } else {\n+            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_ABSTRACT);\n+        }\n+    }\n+\n+    /**\n+     *  Manipulate the method access flags.\n+     */\n+    public boolean isStrict() {\n+        return (getAccessFlags() & Constants.ACCESS_STRICT) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the method access flags.\n+     */\n+    public void setStrict(boolean on) {\n+        if (on) {\n+            setAccessFlags(getAccessFlags() | Constants.ACCESS_STRICT);\n+        } else {\n+            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_STRICT);\n+        }\n+    }\n+\n+    /////////////////////\n+    // Return operations\n+    /////////////////////\n+\n+    /**\n+     *  Return the name of the type returned by this method.  The name\n+     *  will be given in a form suitable for a {@link Class#forName} call.\n+     *\n+     *  @see BCMember#getDescriptor\n+     */\n+    public String getReturnName() {\n+        return getProject().getNameCache()\n+                   .getExternalForm(getProject().getNameCache()\n+                                        .getDescriptorReturnName(getDescriptor()),\n+            false);\n+    }\n+\n+    /**\n+     *  Return the {@link Class} object for the return type of this method.\n+     *\n+     *  @see BCMember#getDescriptor\n+     */\n+    public Class getReturnType() {\n+        return Strings.toClass(getReturnName(), getClassLoader());\n+    }\n+\n+    /**\n+     *  Return the bytecode for the return type of this method.\n+     *\n+     *  @see BCMember#getDescriptor\n+     */\n+    public BCClass getReturnBC() {\n+        return getProject().loadClass(getReturnName(), getClassLoader());\n+    }\n+\n+    /**\n+      *  Set the return type of this method.\n+     */\n+    public void setReturn(String name) {\n+        setDescriptor(getProject().getNameCache()\n+                          .getDescriptor(name, getParamNames()));\n+    }\n+\n+    /**\n+     *  Set the return type of this method.\n+     */\n+    public void setReturn(Class type) {\n+        setReturn(type.getName());\n+    }\n+\n+    /**\n+     *  Set the return type of this method.\n+     */\n+    public void setReturn(BCClass type) {\n+        setReturn(type.getName());\n+    }\n+\n+    ////////////////////////\n+    // Parameter operations\n+    ////////////////////////\n+\n+    /**\n+     *  Return the names of all the parameter types for this method.  The names\n+     *  will be returned in a form suitable for a {@link Class#forName} call.\n+     *\n+     *  @see BCMember#getDescriptor\n+     */\n+    public String[] getParamNames() {\n+        // get the parameter types from the descriptor\n+        String[] params = getProject().getNameCache()\n+                              .getDescriptorParamNames(getDescriptor());\n+\n+        // convert them to external form\n+        for (int i = 0; i < params.length; i++)\n+            params[i] = getProject().getNameCache()\n+                            .getExternalForm(params[i], false);\n+\n+        return params;\n+    }\n+\n+    /**\n+     *  Return the {@link Class} objects for all the parameter types for this\n+     *  method.\n+     *\n+     *  @see BCMember#getDescriptor\n+     */\n+    public Class[] getParamTypes() {\n+        String[] paramNames = getParamNames();\n+        Class[] params = new Class[paramNames.length];\n+\n+        for (int i = 0; i < paramNames.length; i++)\n+            params[i] = Strings.toClass(paramNames[i], getClassLoader());\n+\n+        return params;\n+    }\n+\n+    /**\n+     *  Return the bytecode for all the parameter types for this\n+     *  method.\n+     *\n+     *  @see BCMember#getDescriptor\n+     */\n+    public BCClass[] getParamBCs() {\n+        String[] paramNames = getParamNames();\n+        BCClass[] params = new BCClass[paramNames.length];\n+\n+        for (int i = 0; i < paramNames.length; i++)\n+            params[i] = getProject().loadClass(paramNames[i], getClassLoader());\n+\n+        return params;\n+    }\n+\n+    /**\n+      *  Set the parameter types of this method.\n+     *\n+     *  @see BCMember#setDescriptor\n+     */\n+    public void setParams(String[] names) {\n+        if (names == null) {\n+            names = new String[0];\n+        }\n+\n+        setDescriptor(getProject().getNameCache()\n+                          .getDescriptor(getReturnName(), names));\n+    }\n+\n+    /**\n+     *  Set the parameter type of this method.\n+     *\n+     *  @see BCMember#setDescriptor\n+     */\n+    public void setParams(Class[] types) {\n+        if (types == null) {\n+            setParams((String[]) null);\n+        } else {\n+            String[] names = new String[types.length];\n+\n+            for (int i = 0; i < types.length; i++)\n+                names[i] = types[i].getName();\n+\n+            setParams(names);\n+        }\n+    }\n+\n+    /**\n+     *  Set the parameter type of this method.\n+     *\n+     *  @see BCMember#setDescriptor\n+     */\n+    public void setParams(BCClass[] types) {\n+        if (types == null) {\n+            setParams((String[]) null);\n+        } else {\n+            String[] names = new String[types.length];\n+\n+            for (int i = 0; i < types.length; i++)\n+                names[i] = types[i].getName();\n+\n+            setParams(names);\n+        }\n+    }\n+\n+    /**\n+     *  Add a parameter type to this method.\n+     */\n+    public void addParam(String type) {\n+        String[] origParams = getParamNames();\n+        String[] params = new String[origParams.length + 1];\n+\n+        for (int i = 0; i < origParams.length; i++)\n+            params[i] = origParams[i];\n+\n+        params[origParams.length] = type;\n+        setParams(params);\n+    }\n+\n+    /**\n+     *  Add a parameter type to this method.\n+     */\n+    public void addParam(Class type) {\n+        addParam(type.getName());\n+    }\n+\n+    /**\n+     *  Add a parameter type to this method.\n+     */\n+    public void addParam(BCClass type) {\n+        addParam(type.getName());\n+    }\n+\n+    /**\n+     *  Add a parameter type to this method.\n+     *\n+     *  @see java.util.List#add(int,Object)\n+     */\n+    public void addParam(int pos, String type) {\n+        String[] origParams = getParamNames();\n+\n+        if ((pos < 0) || (pos >= origParams.length)) {\n+            throw new IndexOutOfBoundsException(\"pos = \" + pos);\n+        }\n+\n+        String[] params = new String[origParams.length + 1];\n+\n+        for (int i = 0, index = 0; i < params.length; i++) {\n+            if (i == pos) {\n+                params[i] = type;\n+            } else {\n+                params[i] = origParams[index++];\n+            }\n+        }\n+\n+        setParams(params);\n+    }\n+\n+    /**\n+     *  Add a parameter type to this method.\n+     *\n+     *  @see java.util.List#add(int,Object)\n+     */\n+    public void addParam(int pos, Class type) {\n+        addParam(pos, type.getName());\n+    }\n+\n+    /**\n+     *  Add a parameter type to this method.\n+     *\n+     *  @see java.util.List#add(int,Object)\n+     */\n+    public void addParam(int pos, BCClass type) {\n+        addParam(pos, type.getName());\n+    }\n+\n+    /**\n+     *  Change a parameter type of this method.\n+     *\n+     *  @see java.util.List#set(int,Object)\n+     */\n+    public void setParam(int pos, String type) {\n+        String[] origParams = getParamNames();\n+\n+        if ((pos < 0) || (pos >= origParams.length)) {\n+            throw new IndexOutOfBoundsException(\"pos = \" + pos);\n+        }\n+\n+        String[] params = new String[origParams.length];\n+\n+        for (int i = 0; i < params.length; i++) {\n+            if (i == pos) {\n+                params[i] = type;\n+            } else {\n+                params[i] = origParams[i];\n+            }\n+        }\n+\n+        setParams(params);\n+    }\n+\n+    /**\n+     *  Change a parameter type of this method.\n+     *\n+     *  @see java.util.List#set(int,Object)\n+     */\n+    public void setParam(int pos, Class type) {\n+        setParam(pos, type.getName());\n+    }\n+\n+    /**\n+     *  Change a parameter type of this method.\n+     *\n+     *  @see java.util.List#set(int,Object)\n+     */\n+    public void setParam(int pos, BCClass type) {\n+        setParam(pos, type.getName());\n+    }\n+\n+    /**\n+     *  Clear all parameters from this method.\n+     */\n+    public void clearParams() {\n+        setParams((String[]) null);\n+    }\n+\n+    /**\n+     *  Remove a parameter from this method.\n+     */\n+    public void removeParam(int pos) {\n+        String[] origParams = getParamNames();\n+\n+        if ((pos < 0) || (pos >= origParams.length)) {\n+            throw new IndexOutOfBoundsException(\"pos = \" + pos);\n+        }\n+\n+        String[] params = new String[origParams.length - 1];\n+\n+        for (int i = 0, index = 0; i < origParams.length; i++)\n+            if (i != pos) {\n+                params[index++] = origParams[i];\n+            }\n+\n+        setParams(params);\n+    }\n+\n+    ///////////////////////\n+    // Convenience methods\n+    ///////////////////////\n+\n+    /**\n+     *  Return the checked exceptions information for the method.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @param add                if true, a new exceptions attribute will be added\n+     *                                  if not already present\n+     *  @return the exceptions information, or null if none and the\n+     *                                  <code>add</code> param is set to false\n+     */\n+    public Exceptions getExceptions(boolean add) {\n+        Exceptions exceptions = (Exceptions) getAttribute(Constants.ATTR_EXCEPTIONS);\n+\n+        if (!add || (exceptions != null)) {\n+            return exceptions;\n+        }\n+\n+        if (exceptions == null) {\n+            exceptions = (Exceptions) addAttribute(Constants.ATTR_EXCEPTIONS);\n+        }\n+\n+        return exceptions;\n+    }\n+\n+    /**\n+     *  Remove the exceptions attribute for the method.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @return true if there was a value to remove\n+     */\n+    public boolean removeExceptions() {\n+        return removeAttribute(Constants.ATTR_EXCEPTIONS);\n+    }\n+\n+    /**\n+     *  Return the code for the method.  If the code already exists, its\n+     *  iterator will be reset to the first instruction.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @param add                if true, a new code attribute will be added\n+     *                                  if not already present\n+     *  @return the code for the metohd, or null if none and the\n+     *                                  <code>add</code> param is set to false\n+     */\n+    public Code getCode(boolean add) {\n+        Code code = (Code) getAttribute(Constants.ATTR_CODE);\n+\n+        if (code != null) {\n+            code.beforeFirst();\n+\n+            return code;\n+        }\n+\n+        if (!add) {\n+            return null;\n+        }\n+\n+        return (Code) addAttribute(Constants.ATTR_CODE);\n+    }\n+\n+    /**\n+     *  Remove the code attribute from the method.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @return true if there was a value to remove\n+     */\n+    public boolean removeCode() {\n+        return removeAttribute(Constants.ATTR_CODE);\n+    }\n+\n+    ////////////////////////////////\n+    // VisitAcceptor implementation\n+    ////////////////////////////////\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterBCMethod(this);\n+        visitAttributes(visit);\n+        visit.exitBCMethod(this);\n+    }\n+\n+    void initialize(String name, String descriptor) {\n+        super.initialize(name, descriptor);\n+        makePublic();\n+    }\n+}"},{"sha":"88e956821decbb6316b972f38ce6c3166296ac78","filename":"serp/src/main/java/serp/bytecode/ClassConstantInstruction.java","status":"added","additions":223,"deletions":0,"changes":223,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ClassConstantInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ClassConstantInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ClassConstantInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Pseudo-instruction used to place {@link Class} objects onto the stack.\n+ *  This logical instruction may actually involve a large chunk of code, and\n+ *  may even add static synthetic fields and methods to the owning class.\n+ *  Therefore, once the type of class being loaded is set, it cannot\n+ *  be changed.  Also, this instruction is invalid as the target of\n+ *  any jump instruction or exception handler.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class ClassConstantInstruction {\n+    private static final Class[] _params = new Class[] { String.class };\n+    private static final Map _wrappers = new HashMap();\n+\n+    static {\n+        _wrappers.put(byte.class.getName(), Byte.class);\n+        _wrappers.put(boolean.class.getName(), Boolean.class);\n+        _wrappers.put(char.class.getName(), Character.class);\n+        _wrappers.put(double.class.getName(), Double.class);\n+        _wrappers.put(float.class.getName(), Float.class);\n+        _wrappers.put(int.class.getName(), Integer.class);\n+        _wrappers.put(long.class.getName(), Long.class);\n+        _wrappers.put(short.class.getName(), Short.class);\n+    }\n+\n+    private Instruction _ins = null;\n+    private Code _code = null;\n+    private BCClass _class = null;\n+    private boolean _invalid = false;\n+\n+    ClassConstantInstruction(BCClass bc, Code code, Instruction nop) {\n+        _class = bc;\n+        _code = code;\n+        _ins = nop;\n+    }\n+\n+    /**\n+     *  Set the type of class being loaded.\n+     *\n+     *  @return the first Instruction of the block added by setting\n+     *                          the type\n+     *  @throws IllegalStateException if type has already been set\n+     */\n+    public Instruction setClass(String name) {\n+        name = _class.getProject().getNameCache().getExternalForm(name, false);\n+        setClassName(name, getWrapperClass(name));\n+\n+        return _ins;\n+    }\n+\n+    /**\n+     *  Set the type of class being loaded.\n+     *\n+     *  @return the first Instruction of the block added by setting\n+     *                          the type\n+     *  @throws IllegalStateException if type has already been set\n+     */\n+    public Instruction setClass(Class type) {\n+        return setClass(type.getName());\n+    }\n+\n+    /**\n+     *  Set the type of class being loaded.\n+     *\n+     *  @return the first Instruction of the block added by setting\n+     *                          the type\n+     *  @throws IllegalStateException if type has already been set\n+     */\n+    public Instruction setClass(BCClass type) {\n+        return setClass(type.getName());\n+    }\n+\n+    /**\n+     *  Set the name of the class to load.\n+     */\n+    private void setClassName(String name, Class wrapper) {\n+        if (_invalid) {\n+            throw new IllegalStateException();\n+        }\n+\n+        // remember the position of the code iterator\n+        Instruction before = (_code.hasNext()) ? _code.next() : null;\n+        _code.before(_ins);\n+        _code.next();\n+\n+        if (wrapper != null) {\n+            _code.getstatic().setField(wrapper, \"TYPE\", Class.class);\n+        } else {\n+            setObject(name);\n+        }\n+\n+        // move to the old position\n+        if (before != null) {\n+            _code.before(before);\n+        } else {\n+            _code.afterLast();\n+        }\n+\n+        _invalid = true;\n+    }\n+\n+    /**\n+     *  Adds fields and methods as necessary to load a class constant of\n+     *  an object type.\n+     */\n+    private void setObject(String name) {\n+        BCField field = addClassField(name);\n+        BCMethod method = addClassLoadMethod();\n+\n+        // copied from the way jikes loads classes\n+        _code.getstatic().setField(field);\n+\n+        JumpInstruction ifnull = _code.ifnull();\n+\n+        _code.getstatic().setField(field);\n+\n+        JumpInstruction go2 = _code.go2();\n+\n+        ifnull.setTarget(_code.constant().setValue(name));\n+        _code.invokestatic().setMethod(method);\n+        _code.dup();\n+        _code.putstatic().setField(field);\n+\n+        go2.setTarget(_code.nop());\n+    }\n+\n+    /**\n+     *  Adds a static field to hold the loaded class constant.\n+     */\n+    private BCField addClassField(String name) {\n+        String fieldName = \"class$L\" +\n+            name.replace('.', '$').replace('[', '$').replace(';', '$');\n+\n+        BCField field = _class.getDeclaredField(fieldName);\n+\n+        if (field == null) {\n+            field = _class.declareField(fieldName, Class.class);\n+            field.makePackage();\n+            field.setStatic(true);\n+            field.setSynthetic(true);\n+        }\n+\n+        return field;\n+    }\n+\n+    /**\n+     *  Adds the standard <code>class$<code> method used inernally by classes\n+     *  to load class constants for object types.\n+     */\n+    private BCMethod addClassLoadMethod() {\n+        BCMethod method = _class.getDeclaredMethod(\"class$\", _params);\n+\n+        if (method != null) {\n+            return method;\n+        }\n+\n+        // add the special synthetic method\n+        method = _class.declareMethod(\"class$\", Class.class, _params);\n+        method.setStatic(true);\n+        method.makePackage();\n+        method.setSynthetic(true);\n+\n+        // copied directly from the output of the jikes compiler\n+        Code code = method.getCode(true);\n+        code.setMaxStack(3);\n+        code.setMaxLocals(2);\n+\n+        Instruction tryStart = code.aload().setLocal(0);\n+        code.invokestatic()\n+            .setMethod(Class.class, \"forName\", Class.class, _params);\n+\n+        Instruction tryEnd = code.areturn();\n+        Instruction handlerStart = code.astore().setLocal(1);\n+        code.anew().setType(NoClassDefFoundError.class);\n+        code.dup();\n+        code.aload().setLocal(1);\n+        code.invokevirtual()\n+            .setMethod(Throwable.class, \"getMessage\", String.class, null);\n+        code.invokespecial()\n+            .setMethod(NoClassDefFoundError.class, \"<init>\", void.class, _params);\n+        code.athrow();\n+\n+        code.addExceptionHandler(tryStart, tryEnd, handlerStart,\n+            ClassNotFoundException.class);\n+\n+        return method;\n+    }\n+\n+    /**\n+     *  Return the wrapper type for the given primitive class, or null\n+     *  if the given name is not a primitive type.  The given name should\n+     *  be in external form.\n+     */\n+    private static Class getWrapperClass(String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+\n+        return (Class) _wrappers.get(name);\n+    }\n+}"},{"sha":"11e707bd0c7f13309f486272341b10a52d4d5d07","filename":"serp/src/main/java/serp/bytecode/ClassInstruction.java","status":"added","additions":135,"deletions":0,"changes":135,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ClassInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ClassInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ClassInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+\n+/**\n+ *  <p>An instruction that takes as an argument a class to operate\n+ *  on.         Examples include <code>anewarray, checkcast, instance, anew</code>,\n+ *  etc.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class ClassInstruction extends TypedInstruction {\n+    private int _index = 0;\n+\n+    ClassInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    public int getLogicalStackChange() {\n+        return getStackChange();\n+    }\n+\n+    public int getStackChange() {\n+        if (getOpcode() == Constants.NEW) {\n+            return 1;\n+        }\n+\n+        return 0;\n+    }\n+\n+    int getLength() {\n+        return super.getLength() + 2;\n+    }\n+\n+    /**\n+     *  Return the {@link ConstantPool} index of the\n+     *  {@link ClassEntry} describing the class for this instruction.\n+     */\n+    public int getTypeIndex() {\n+        return _index;\n+    }\n+\n+    /**\n+     *  Set the {@link ConstantPool} index of the\n+     *  {@link ClassEntry} describing the class for this instruction.\n+     *\n+      *  @return this instruction, for method chaining\n+     */\n+    public ClassInstruction setTypeIndex(int index) {\n+        _index = index;\n+\n+        return this;\n+    }\n+\n+    public String getTypeName() {\n+        if (_index == 0) {\n+            return null;\n+        }\n+\n+        ClassEntry entry = (ClassEntry) getPool().getEntry(_index);\n+\n+        return getProject().getNameCache()\n+                   .getExternalForm(entry.getNameEntry().getValue(), false);\n+    }\n+\n+    public TypedInstruction setType(String type) {\n+        if (type == null) {\n+            setTypeIndex(0);\n+        } else {\n+            type = getProject().getNameCache().getInternalForm(type, false);\n+            setTypeIndex(getPool().findClassEntry(type, true));\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     *  ClassInstructions are equal if the type they reference is the same or\n+     *  unset and if their opcodes are equal.\n+     */\n+    public boolean equalsInstruction(Instruction other) {\n+        if (other == this) {\n+            return true;\n+        }\n+\n+        if (!super.equalsInstruction(other)) {\n+            return false;\n+        }\n+\n+        String type = getTypeName();\n+        String otherType = ((ClassInstruction) other).getTypeName();\n+\n+        return (type == null) || (otherType == null) || type.equals(otherType);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterClassInstruction(this);\n+        visit.exitClassInstruction(this);\n+    }\n+\n+    void read(Instruction other) {\n+        super.read(other);\n+        setType(((ClassInstruction) other).getTypeName());\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        super.read(in);\n+        setTypeIndex(in.readUnsignedShort());\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        super.write(out);\n+        out.writeShort(getTypeIndex());\n+    }\n+}"},{"sha":"23fb0dbd0944c45c1ae18b34530c1d866be267ca","filename":"serp/src/main/java/serp/bytecode/CmpInstruction.java","status":"added","additions":190,"deletions":0,"changes":190,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/CmpInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/CmpInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/CmpInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+\n+/**\n+ *  <p>An instruction comparing two stack values.  Examples include\n+ *  <code>lcmp, fcmpl</code>, etc.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class CmpInstruction extends TypedInstruction {\n+    private static Class[][] _mappings = new Class[][] {\n+            { int.class, long.class },\n+            { byte.class, long.class },\n+            { char.class, long.class },\n+            { short.class, long.class },\n+            { boolean.class, long.class },\n+            { void.class, long.class },\n+            { Object.class, long.class },\n+        };\n+\n+    CmpInstruction(Code owner) {\n+        super(owner);\n+    }\n+\n+    CmpInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    public int getLogicalStackChange() {\n+        switch (getOpcode()) {\n+        case Constants.NOP:\n+            return 0;\n+\n+        default:\n+            return -1;\n+        }\n+    }\n+\n+    public int getStackChange() {\n+        switch (getOpcode()) {\n+        case Constants.LCMP:\n+        case Constants.DCMPL:\n+        case Constants.DCMPG:\n+            return -3;\n+\n+        case Constants.NOP:\n+            return 0;\n+\n+        default:\n+            return -1;\n+        }\n+    }\n+\n+    public String getTypeName() {\n+        switch (getOpcode()) {\n+        case Constants.LCMP:\n+            return long.class.getName();\n+\n+        case Constants.FCMPL:\n+        case Constants.FCMPG:\n+            return float.class.getName();\n+\n+        case Constants.DCMPL:\n+        case Constants.DCMPG:\n+            return double.class.getName();\n+\n+        default:\n+            return null;\n+        }\n+    }\n+\n+    public TypedInstruction setType(String type) {\n+        type = mapType(type, _mappings, true);\n+\n+        if (type == null) {\n+            return (TypedInstruction) setOpcode(Constants.NOP);\n+        }\n+\n+        int opcode = getOpcode();\n+\n+        switch (type.charAt(0)) {\n+        case 'l':\n+            return (TypedInstruction) setOpcode(Constants.LCMP);\n+\n+        case 'f':\n+\n+            if ((opcode == Constants.FCMPL) || (opcode == Constants.DCMPL)) {\n+                return (TypedInstruction) setOpcode(Constants.FCMPL);\n+            }\n+\n+            return (TypedInstruction) setOpcode(Constants.FCMPG);\n+\n+        case 'd':\n+\n+            if ((opcode == Constants.FCMPL) || (opcode == Constants.DCMPL)) {\n+                return (TypedInstruction) setOpcode(Constants.DCMPL);\n+            }\n+\n+            return (TypedInstruction) setOpcode(Constants.DCMPG);\n+\n+        default:\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    /**\n+     *  Return the number that will be placed on the stack if this instruction\n+     *  is of type float or double and one of the operands is NaN.  For\n+     *  FCMPG or DCMPG, this value will be 1; for FCMPL or DCMPL this value\n+     *  will be -1.  For LCMP or if the type is unset, this value will be 0.\n+     */\n+    public int getNaNValue() {\n+        switch (getOpcode()) {\n+        case Constants.FCMPL:\n+        case Constants.DCMPL:\n+            return -1;\n+\n+        case Constants.FCMPG:\n+        case Constants.DCMPG:\n+            return 1;\n+\n+        default:\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     *  Set the number that will be placed on the stack if this instruction\n+     *  is of type float or double and one of the operands is NaN.  For\n+     *  FCMPG or DCMPG, this value should be 1; for FCMPL or DCMPL this value\n+     *  should be -1.  For LCMP, this value should be 0.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public CmpInstruction setNaNValue(int nan) {\n+        switch (getOpcode()) {\n+        case Constants.FCMPL:\n+        case Constants.FCMPG:\n+\n+            if (nan == 1) {\n+                setOpcode(Constants.FCMPG);\n+            } else if (nan == -1) {\n+                setOpcode(Constants.FCMPL);\n+            } else {\n+                throw new IllegalArgumentException(\"Invalid nan for type\");\n+            }\n+\n+        case Constants.DCMPL:\n+        case Constants.DCMPG:\n+\n+            if (nan == 1) {\n+                setOpcode(Constants.DCMPG);\n+            } else if (nan == -1) {\n+                setOpcode(Constants.DCMPL);\n+            } else {\n+                throw new IllegalArgumentException(\"Invalid nan for type\");\n+            }\n+\n+        default:\n+\n+            if (nan != 0) {\n+                throw new IllegalArgumentException(\"Invalid nan for type\");\n+            }\n+        }\n+\n+        return this;\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterCmpInstruction(this);\n+        visit.exitCmpInstruction(this);\n+    }\n+}"},{"sha":"d07ae6df8b5d5fc5de742d27f4c173f349d779cc","filename":"serp/src/main/java/serp/bytecode/Code.java","status":"added","additions":2847,"deletions":0,"changes":2847,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Code.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Code.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Code.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,2847 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Representation of a code block of a class.\n+ *  The methods of this class mimic those of the same name in the\n+ *  {@link java.util.ListIterator} class.  Note that the size and index\n+ *  information of the code block will change as opcodes are added.</p>\n+ *\n+ *  <p>Code blocks are usually obtained from a {@link BCMethod}, but can also\n+ *  be constructed via the default constructor.  Blocks created this way can\n+ *  be used to provide template instructions to the various search/replace\n+ *  methods in this class.</p>\n+ *\n+ *  <p>The code class contains methods named after most JVM instructions, each\n+ *  of which adds the matching opcode to the code block at the\n+ *  current iterator position.  It also contains generic versions of various\n+ *  JVM instructions whose opcodes are not set until their properties are set\n+ *  with additional information.  Almost all instruction types are able to\n+ *  'morph' their opcode on the fly as the arguments to the instruction change.\n+ *  Thus the developer can initially call, for example, the <code>aload</code>\n+ *  opcode, but later change the type to load to <code>int</code> and the\n+ *  opcode will automatically morph to the <code>iload</code> opcode.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class Code extends Attribute {\n+    private final CodeEntry _head;\n+    private final CodeEntry _tail;\n+    private CodeIterator _ci;\n+    private int _maxStack = 0;\n+    private int _maxLocals = 0;\n+    private int _size = 0;\n+    private Collection _handlers = new LinkedList();\n+    private Collection _attrs = new LinkedList();\n+\n+    Code(int nameIndex, Attributes owner) {\n+        super(nameIndex, owner);\n+\n+        _head = new CodeEntry();\n+        _tail = new CodeEntry();\n+        _head.next = _tail;\n+        _tail.prev = _head;\n+\n+        _ci = new CodeIterator(_head, -1);\n+    }\n+\n+    /**\n+     *  The public constructor is for creating template code modules\n+      *  that produce {@link Instruction}s used in matching through\n+     *  the various <code>search</code> and <code>replace</code>\n+     *  methods.\n+     */\n+    public Code() {\n+        this(0,\n+            new Project().loadClass(\"\", null).declareMethod(\"\", void.class, null));\n+    }\n+\n+    /**\n+     *  The owning method.\n+     */\n+    public BCMethod getMethod() {\n+        return (BCMethod) getOwner();\n+    }\n+\n+    Collection getAttributesHolder() {\n+        return _attrs;\n+    }\n+\n+    ////////////////////////////\n+    // Stack, Locals operations\n+    ////////////////////////////\n+\n+    /**\n+     *  Return the maximum stack depth set for this code block.\n+     */\n+    public int getMaxStack() {\n+        return _maxStack;\n+    }\n+\n+    /**\n+     *  Set the maximum stack depth for this code block.\n+     */\n+    public void setMaxStack(int max) {\n+        _maxStack = max;\n+    }\n+\n+    /**\n+     *  Return the maximum number of local variables (including params)\n+     *  set for this method.\n+     */\n+    public int getMaxLocals() {\n+        return _maxLocals;\n+    }\n+\n+    /**\n+     *  Set the maximum number of local variables (including params) in\n+     *  this method.\n+     */\n+    public void setMaxLocals(int max) {\n+        _maxLocals = max;\n+    }\n+\n+    /**\n+     *  Return the local variable index for the paramIndex'th parameter to\n+     *  the method.         Local variable indexes differ from parameter indexes\n+     *  because:\n+     *  a) non-static methods use the 0th local variable for the 'this' ptr, and\n+     *  b) double and long values occupy two spots in the local\n+     *  variable array.\n+     *  Returns -1 if the given index is not valid.\n+     */\n+    public int getLocalsIndex(int paramIndex) {\n+        if (paramIndex < 0) {\n+            return -1;\n+        }\n+\n+        int pos = 0;\n+\n+        if (!getMethod().isStatic()) {\n+            pos = 1;\n+        }\n+\n+        String[] params = getMethod().getParamNames();\n+\n+        for (int i = 0; i < paramIndex; i++, pos++) {\n+            if (i == params.length) {\n+                return -1;\n+            }\n+\n+            if (params[i].equals(long.class.getName()) ||\n+                    params[i].equals(double.class.getName())) {\n+                pos++;\n+            }\n+        }\n+\n+        return pos;\n+    }\n+\n+    /**\n+     *  Return the parameter index for the given local index, or -1 if\n+     *  the given local does not reference a param.\n+     *\n+     *  @see #getLocalsIndex\n+     */\n+    public int getParamsIndex(int localIndex) {\n+        int pos = 0;\n+\n+        if (!getMethod().isStatic()) {\n+            pos = 1;\n+        }\n+\n+        String[] params = getMethod().getParamNames();\n+\n+        for (int i = 0; i < params.length; i++, pos++) {\n+            if (localIndex == pos) {\n+                return i;\n+            }\n+\n+            if (params[i].equals(long.class.getName()) ||\n+                    params[i].equals(double.class.getName())) {\n+                pos++;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    /**\n+     *  Return the next available local variable index.\n+     */\n+    public int getNextLocalsIndex() {\n+        calculateMaxLocals();\n+\n+        return getMaxLocals();\n+    }\n+\n+    /**\n+     *  Calculate and set the number of locals needed based on\n+     *  the instructions used and the parameters of the method this code\n+     *  block is a part of.\n+     *\n+      *  @see #setMaxLocals\n+     */\n+    public void calculateMaxLocals() {\n+        // start off assuming the max number needed is the \n+        // number for all the params\n+        String[] params = getMethod().getParamNames();\n+        int max = 0;\n+\n+        if ((params.length == 0) && !getMethod().isStatic()) {\n+            max = 1;\n+        } else if (params.length > 0) {\n+            max = getLocalsIndex(params.length - 1) + 1;\n+\n+            if (params[params.length - 1].equals(long.class.getName()) ||\n+                    params[params.length - 1].equals(double.class.getName())) {\n+                max++;\n+            }\n+        }\n+\n+        // check to see if there are any store instructions that\n+        // try to reference beyond that point\n+        StoreInstruction store;\n+        int current;\n+\n+        for (CodeEntry entry = _head.next; entry != _tail;\n+                entry = entry.next) {\n+            current = 0;\n+\n+            if (entry instanceof StoreInstruction) {\n+                store = (StoreInstruction) entry;\n+                current = store.getLocal() + 1;\n+\n+                if (store.getType().equals(long.class) ||\n+                        store.getType().equals(double.class)) {\n+                    current++;\n+                }\n+\n+                if (current > max) {\n+                    max = current;\n+                }\n+            }\n+        }\n+\n+        setMaxLocals(max);\n+    }\n+\n+    /**\n+     *  Calculate and set the maximum stack depth needed for\n+     *  the instructions used.\n+      *\n+     *  @see #setMaxStack\n+     */\n+    public void calculateMaxStack() {\n+        int stack = 0;\n+        int max = 0;\n+\n+        ExceptionHandler[] handlers = getExceptionHandlers();\n+        Instruction ins;\n+\n+        for (CodeEntry entry = _head.next; entry != _tail;\n+                entry = entry.next) {\n+            ins = (Instruction) entry;\n+            stack += ins.getStackChange();\n+\n+            // if this is the start of a try, the exception will be placed\n+            // on the stack\n+            for (int j = 0; j < handlers.length; j++)\n+                if (handlers[j].getTryStart() == ins) {\n+                    stack++;\n+                }\n+\n+            if (stack > max) {\n+                max = stack;\n+            }\n+        }\n+\n+        setMaxStack(max);\n+    }\n+\n+    ///////////////////////////////\n+    // ExceptionHandler operations\n+    ///////////////////////////////\n+\n+    /**\n+     *  Return the exception handlers active in this code block, or an\n+     *  empty array if none.\n+     */\n+    public ExceptionHandler[] getExceptionHandlers() {\n+        return (ExceptionHandler[]) _handlers.toArray(new ExceptionHandler[_handlers.size()]);\n+    }\n+\n+    /**\n+     *  Return the exception handler that catches the given exception type;\n+     *  if multiple handlers catch the given type, which is returned is\n+     *  undefined.\n+     */\n+    public ExceptionHandler getExceptionHandler(String catchType) {\n+        catchType = getProject().getNameCache().getExternalForm(catchType, false);\n+\n+        String type;\n+        ExceptionHandler[] handlers = getExceptionHandlers();\n+\n+        for (int i = 0; i < handlers.length; i++) {\n+            type = handlers[i].getCatchName();\n+\n+            if (((type == null) && (catchType == null)) ||\n+                    ((type != null) && type.equals(catchType))) {\n+                return handlers[i];\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     *  Return the exception handler that catches the given exception type;\n+     *  if multiple handlers catch the given type, which is returned is\n+     *  undefined.\n+     */\n+    public ExceptionHandler getExceptionHandler(Class catchType) {\n+        if (catchType == null) {\n+            return getExceptionHandler((String) null);\n+        }\n+\n+        return getExceptionHandler(catchType.getName());\n+    }\n+\n+    /**\n+     *  Return the exception handler that catches the given exception type;\n+     *  if multiple handlers catch the given type, which is returned is\n+     *  undefined.\n+     */\n+    public ExceptionHandler getExceptionHandler(BCClass catchType) {\n+        if (catchType == null) {\n+            return getExceptionHandler((String) null);\n+        }\n+\n+        return getExceptionHandler(catchType.getName());\n+    }\n+\n+    /**\n+     *  Return all exception handlers that catch the given exception type,\n+     *  or an empty array if none.\n+     */\n+    public ExceptionHandler[] getExceptionHandlers(String catchType) {\n+        catchType = getProject().getNameCache().getExternalForm(catchType, false);\n+\n+        List matches = new LinkedList();\n+        String type;\n+        ExceptionHandler[] handlers = getExceptionHandlers();\n+\n+        for (int i = 0; i < handlers.length; i++) {\n+            type = handlers[i].getCatchName();\n+\n+            if (((type == null) && (catchType == null)) ||\n+                    ((type != null) && type.equals(catchType))) {\n+                matches.add(handlers[i]);\n+            }\n+        }\n+\n+        return (ExceptionHandler[]) matches.toArray(new ExceptionHandler[matches.size()]);\n+    }\n+\n+    /**\n+     *  Return all exception handlers that catch the given exception type,\n+     *  or an empty array if none.\n+     */\n+    public ExceptionHandler[] getExceptionHandlers(Class catchType) {\n+        if (catchType == null) {\n+            return getExceptionHandlers((String) null);\n+        }\n+\n+        return getExceptionHandlers(catchType.getName());\n+    }\n+\n+    /**\n+     *  Return all exception handlers that catch the given exception type,\n+     *  or an empty array if none.\n+     */\n+    public ExceptionHandler[] getExceptionHandlers(BCClass catchType) {\n+        if (catchType == null) {\n+            return getExceptionHandlers((String) null);\n+        }\n+\n+        return getExceptionHandlers(catchType.getName());\n+    }\n+\n+    /**\n+     *  Set the exception handlers for this code block.  This method is useful\n+     *  for importing all handlers from another code block.  Set to null or\n+     *  empty array if none.\n+     */\n+    public void setExceptionHandlers(ExceptionHandler[] handlers) {\n+        clearExceptionHandlers();\n+\n+        if (handlers != null) {\n+            for (int i = 0; i < handlers.length; i++)\n+                addExceptionHandler(handlers[i]);\n+        }\n+    }\n+\n+    /**\n+     *  Import the given exception handler from another code block.\n+      */\n+    public ExceptionHandler addExceptionHandler(ExceptionHandler handler) {\n+        ExceptionHandler newHandler = addExceptionHandler();\n+        newHandler.read(handler);\n+\n+        return newHandler;\n+    }\n+\n+    /**\n+     *  Add an exception handler to this code block.\n+     */\n+    public ExceptionHandler addExceptionHandler() {\n+        ExceptionHandler handler = new ExceptionHandler(this);\n+        _handlers.add(handler);\n+\n+        return handler;\n+    }\n+\n+    /**\n+     *  Add an exception handler to this code block.\n+     *\n+     *  @param tryStart                the first instruction of the try {} block\n+      *  @param tryEnd                        the last instruction of the try {} block\n+     *  @param handlerStart        the first instruction of the catch {} block\n+     *  @param catchType                the type of exception being caught\n+      */\n+    public ExceptionHandler addExceptionHandler(Instruction tryStart,\n+        Instruction tryEnd, Instruction handlerStart, String catchType) {\n+        ExceptionHandler handler = addExceptionHandler();\n+        handler.setTryStart(tryStart);\n+        handler.setTryEnd(tryEnd);\n+        handler.setHandlerStart(handlerStart);\n+        handler.setCatch(catchType);\n+\n+        return handler;\n+    }\n+\n+    /**\n+     *  Add an exception handler to this code block.\n+     *\n+     *  @param tryStart                the first instruction of the try {} block\n+      *  @param tryEnd                        the last instruction of the try {} block\n+     *  @param handlerStart        the first instruction of the catch {} block\n+     *  @param catchType                the type of exception being caught\n+     */\n+    public ExceptionHandler addExceptionHandler(Instruction tryStart,\n+        Instruction tryEnd, Instruction handlerStart, Class catchType) {\n+        String catchName = null;\n+\n+        if (catchType != null) {\n+            catchName = catchType.getName();\n+        }\n+\n+        return addExceptionHandler(tryStart, tryEnd, handlerStart, catchName);\n+    }\n+\n+    /**\n+     *  Add an exception handler to this code block.\n+     *\n+     *  @param tryStart                the first instruction of the try {} block\n+      *  @param tryEnd                        the last instruction of the try {} block\n+     *  @param handlerStart        the first instruction of the catch {} block\n+     *  @param catchType                the type of exception being caught\n+     */\n+    public ExceptionHandler addExceptionHandler(Instruction tryStart,\n+        Instruction tryEnd, Instruction handlerStart, BCClass catchType) {\n+        String catchName = null;\n+\n+        if (catchType != null) {\n+            catchName = catchType.getName();\n+        }\n+\n+        return addExceptionHandler(tryStart, tryEnd, handlerStart, catchName);\n+    }\n+\n+    /**\n+     *  Clear all exception handlers.\n+     */\n+    public void clearExceptionHandlers() {\n+        ExceptionHandler handler;\n+\n+        for (Iterator itr = _handlers.iterator(); itr.hasNext();) {\n+            handler = (ExceptionHandler) itr.next();\n+            itr.remove();\n+            handler.invalidate();\n+        }\n+    }\n+\n+    /**\n+      *  Remove the exception handler that catches the given type.\n+     */\n+    public boolean removeExceptionHandler(String catchType) {\n+        return removeExceptionHandler(getExceptionHandler(catchType));\n+    }\n+\n+    /**\n+     *  Remove the exception handler that catches the given type.\n+     *\n+     *  @return true if the handler was removed, false otherwise\n+     */\n+    public boolean removeExceptionHandler(Class catchType) {\n+        if (catchType == null) {\n+            return removeExceptionHandler((String) null);\n+        }\n+\n+        return removeExceptionHandler(catchType.getName());\n+    }\n+\n+    /**\n+     *  Remove the exception handler that catches the given type.\n+     *\n+     *  @return true if the handler was removed, false otherwise\n+     */\n+    public boolean removeExceptionHandler(BCClass catchType) {\n+        if (catchType == null) {\n+            return removeExceptionHandler((String) null);\n+        }\n+\n+        return removeExceptionHandler(catchType.getName());\n+    }\n+\n+    /**\n+     *  Remove an exception handler from this code block.  The given handler\n+     *  must belong to this code block.\n+     */\n+    public boolean removeExceptionHandler(ExceptionHandler handler) {\n+        if ((handler == null) || !_handlers.remove(handler)) {\n+            return false;\n+        }\n+\n+        handler.invalidate();\n+\n+        return true;\n+    }\n+\n+    /////////////////////////\n+    // Code block operations\n+    /////////////////////////\n+\n+    /**\n+     *  Return the number of instructions in the method.\n+     */\n+    public int size() {\n+        return _size;\n+    }\n+\n+    /**\n+      *  Reset the position of the instruction iterator to the first opcode.\n+     */\n+    public void beforeFirst() {\n+        _ci = new CodeIterator(_head, -1);\n+    }\n+\n+    /**\n+     *  Set the position of the instruction iterator to after the last opcode.\n+     */\n+    public void afterLast() {\n+        if (_size == 0) {\n+            _ci = new CodeIterator(_head, -1);\n+        } else {\n+            _ci = new CodeIterator(_tail.prev, _size - 1);\n+        }\n+    }\n+\n+    /**\n+     *  Position the iterator just before the given instruction.  The\n+      *  instruction must belong to this method.\n+     */\n+    public void before(Instruction ins) {\n+        if (ins.getCode() != this) {\n+            throw new IllegalArgumentException(\"ins.code != this\");\n+        }\n+\n+        _ci = new CodeIterator(ins.prev, CodeIterator.UNSET);\n+    }\n+\n+    /**\n+     *  Position the iterator just after the given instruction.  The\n+      *  instruction must belong to this method.\n+     */\n+    public void after(Instruction ins) {\n+        before(ins);\n+        next();\n+    }\n+\n+    /**\n+     *  Return true if a subsequent call to {@link #next} will return an\n+     *  instruction.\n+     */\n+    public boolean hasNext() {\n+        return _ci.hasNext();\n+    }\n+\n+    /**\n+     *  Return true if a subsequent call to {@link #previous} will return an\n+     *  instruction.\n+     */\n+    public boolean hasPrevious() {\n+        return _ci.hasPrevious();\n+    }\n+\n+    /**\n+     *  Return the next instruction.\n+     */\n+    public Instruction next() {\n+        return (Instruction) _ci.next();\n+    }\n+\n+    /**\n+     *  Return the index of the next instruction, or {@link #size} if at end.\n+     */\n+    public int nextIndex() {\n+        return _ci.nextIndex();\n+    }\n+\n+    /**\n+     *  Return the previous instruction.\n+     */\n+    public Instruction previous() {\n+        return (Instruction) _ci.previous();\n+    }\n+\n+    /**\n+     *  Return the index of the previous instruction, or -1 if at beginning.\n+     */\n+    public int previousIndex() {\n+        return _ci.previousIndex();\n+    }\n+\n+    /**\n+     *  Place the iterator before the given list index.\n+     */\n+    public void before(int index) {\n+        if ((index < 0) || (index >= _size)) {\n+            throw new IndexOutOfBoundsException(String.valueOf(index));\n+        }\n+\n+        CodeEntry entry = _head;\n+\n+        for (int i = 0; i < index; entry = entry.next, i++)\n+            ;\n+\n+        _ci = new CodeIterator(entry, index - 1);\n+    }\n+\n+    /**\n+     *  Place the iterator after the given list index.\n+     */\n+    public void after(int index) {\n+        before(index);\n+        next();\n+    }\n+\n+    /**\n+     *  Find the next instruction from the current iterator position that\n+     *  matches the given one, according to        the {@link Object#equals} methods of\n+     *  the instruction types.  This allows for matching based on template\n+     *  instructions, as the equals methods of most instructions return\n+     *  true if the information for the given instruction has not been filled\n+     *  in.  If a match is found, the iterator is placed after the matching\n+      *  Instruction.  If no match is found, moves the iterator to\n+     *  {@link #afterLast}.\n+      *\n+     *  @return true if match found\n+     */\n+    public boolean searchForward(Instruction template) {\n+        if (template == null) {\n+            return false;\n+        }\n+\n+        while (hasNext())\n+\n+            if (template.equalsInstruction(next())) {\n+                return true;\n+            }\n+\n+        return false;\n+    }\n+\n+    /**\n+     *  Find the closest previous instruction from the current iterator\n+     *  position that matches the given one, according to the\n+     *  {@link Object#equals} methods of the instruction types.  This allows\n+     *  for matching based on template instructions, as the equals methods of\n+     *  most instructions return true if the information for the given\n+     *  instruction has not been filled in.  If a match is found, the iterator\n+     *  is placed before the matching Instruction.  If no match is found,\n+     *  moves the iterator to {@link #beforeFirst}.\n+      *\n+     *  @return true if match found\n+     */\n+    public boolean searchBackward(Instruction template) {\n+        if (template == null) {\n+            return false;\n+        }\n+\n+        while (hasPrevious())\n+\n+            if (template.equalsInstruction(previous())) {\n+                return true;\n+            }\n+\n+        return false;\n+    }\n+\n+    /**\n+     *  Adds a copy of the given instruction.\n+      *\n+     *  @return the newly added instruction\n+     */\n+    public Instruction add(Instruction ins) {\n+        Instruction newIns = createInstruction(ins.getOpcode());\n+        newIns.read(ins);\n+        _ci.add(newIns);\n+\n+        return newIns;\n+    }\n+\n+    /**\n+     *  Replaces the last iterated instruction with a copy of the given one.\n+     *  This method will also make sure that all jump points\n+     *  that referenced the old opcode are updated correctly.\n+      *\n+     *  @return the newly added instruction\n+     *\n+     *  @see ListIterator#set\n+     */\n+    public Instruction set(Instruction ins) {\n+        Instruction newIns = createInstruction(ins.getOpcode());\n+        newIns.read(ins);\n+        _ci.set(newIns);\n+\n+        return newIns;\n+    }\n+\n+    /**\n+     *  Replaces all the instructions in this code block that match the\n+     *  given template with the given instruction.  After this method,\n+     *  the iterator will be {@link #afterLast}.\n+     *\n+     *  @return the number of substitutions made\n+     */\n+    public int replace(Instruction template, Instruction with) {\n+        beforeFirst();\n+\n+        int count;\n+\n+        for (count = 0; searchForward(template); count++)\n+            set(with);\n+\n+        return count;\n+    }\n+\n+    /**\n+     *  Equivalent to looping over each given template/replacement\n+     *  pair and calling {@link #replace(Instruction,Instruction)} for each.\n+     */\n+    public int replace(Instruction[] templates, Instruction[] with) {\n+        if ((templates == null) || (with == null)) {\n+            return 0;\n+        }\n+\n+        int count = 0;\n+\n+        for (int i = 0; i < templates.length; i++) {\n+            if (with == null) {\n+                count += replace(templates[i], null);\n+            } else {\n+                count += replace(templates[i], with[i]);\n+            }\n+        }\n+\n+        return count;\n+    }\n+\n+    /**\n+      *  Remove the last iterated instruction.\n+     *\n+     *  @see ListIterator#remove\n+     */\n+    public void remove() {\n+        _ci.remove();\n+    }\n+\n+    //////////////////////////\n+    // Instruction operations\n+    //////////////////////////\n+\n+    /**\n+     *  Load a class constant onto the stack.\n+     *  For primitive types, this translates into a\n+     *  getstatic for the TYPE field of the primitive's wrapper type.\n+     *  For non-primitives, things get much more complex.  Suffice it to\n+     *  say that the operation involves adding synthetic static fields\n+     *  and even methods to the class.  Note that this instruction requires\n+     *  up to 3 stack positions to execute.\n+     */\n+    public ClassConstantInstruction classconstant() {\n+        return new ClassConstantInstruction(getMethod().getDeclarer(), this,\n+            nop());\n+    }\n+\n+    /**\n+     *  Add the <code>nop</code> opcode.\n+     */\n+    public Instruction nop() {\n+        return addInstruction(Constants.NOP);\n+    }\n+\n+    /**\n+     *  Load some constant onto the stack.  The {@link ConstantInstruction}\n+     *  type takes any constant and correctly translates it into the proper\n+     *  opcode, depending on the constant type and value.  For example,\n+     *  if the constant value is set to 0L, the opcode will be set to\n+     *  <code>lconst0</code>.\n+     */\n+    public ConstantInstruction constant() {\n+        return (ConstantInstruction) addInstruction(new ConstantInstruction(\n+                this));\n+    }\n+\n+    /**\n+     *  Load a local variable onto the stack.  This instruction will result\n+     *  in a <code>nop</code> until its type and local index are set.\n+     */\n+    public LoadInstruction xload() {\n+        return (LoadInstruction) addInstruction(new LoadInstruction(this));\n+    }\n+\n+    /**\n+     *  Load an int local variable onto the stack.  This instruction will\n+     *  result in a <code>nop</code> until its local index is set.\n+     */\n+    public LoadInstruction iload() {\n+        return (LoadInstruction) addInstruction(new LoadInstruction(this).setType(\n+                int.class));\n+    }\n+\n+    /**\n+     *  Load a long local variable onto the stack.  This instruction will\n+     *  result in a <code>nop</code> until its local index is set.\n+     */\n+    public LoadInstruction lload() {\n+        return (LoadInstruction) addInstruction(new LoadInstruction(this).setType(\n+                long.class));\n+    }\n+\n+    /**\n+     *  Load a float local variable onto the stack.  This instruction will\n+     *  result in a <code>nop</code> until its local index is set.\n+     */\n+    public LoadInstruction fload() {\n+        return (LoadInstruction) addInstruction(new LoadInstruction(this).setType(\n+                float.class));\n+    }\n+\n+    /**\n+     *  Load a double local variable onto the stack.  This instruction will\n+     *  result in a <code>nop</code> until its local index is set.\n+     */\n+    public LoadInstruction dload() {\n+        return (LoadInstruction) addInstruction(new LoadInstruction(this).setType(\n+                double.class));\n+    }\n+\n+    /**\n+     *  Load an object local variable onto the stack.  This instruction will\n+     *  result in a <code>nop</code> until its local index is set.\n+     */\n+    public LoadInstruction aload() {\n+        return (LoadInstruction) addInstruction(new LoadInstruction(this).setType(\n+                Object.class));\n+    }\n+\n+    /**\n+     *  Store a value from the stack into a local variable.  This instruction\n+     *  will result        in a <code>nop</code> until its type and local index are\n+     *  set.\n+     */\n+    public StoreInstruction xstore() {\n+        return (StoreInstruction) addInstruction(new StoreInstruction(this));\n+    }\n+\n+    /**\n+     *  Store an int value from the stack into a local variable.  This\n+     *  instruction        will result        in a <code>nop</code> until its local index is\n+     *  set.\n+     */\n+    public StoreInstruction istore() {\n+        return (StoreInstruction) addInstruction(new StoreInstruction(this).setType(\n+                int.class));\n+    }\n+\n+    /**\n+     *  Store a long value from the stack into a local variable.  This\n+     *  instruction        will result        in a <code>nop</code> until its local index is\n+     *  set.\n+     */\n+    public StoreInstruction lstore() {\n+        return (StoreInstruction) addInstruction(new StoreInstruction(this).setType(\n+                long.class));\n+    }\n+\n+    /**\n+     *  Store a float value from the stack into a local variable.  This\n+     *  instruction        will result        in a <code>nop</code> until its local index is\n+     *  set.\n+     */\n+    public StoreInstruction fstore() {\n+        return (StoreInstruction) addInstruction(new StoreInstruction(this).setType(\n+                float.class));\n+    }\n+\n+    /**\n+     *  Store a double value from the stack into a local variable.  This\n+     *  instruction        will result        in a <code>nop</code> until its local index is\n+     *  set.\n+     */\n+    public StoreInstruction dstore() {\n+        return (StoreInstruction) addInstruction(new StoreInstruction(this).setType(\n+                double.class));\n+    }\n+\n+    /**\n+     *  Store an object value from the stack into a local variable.  This\n+     *  instruction        will result        in a <code>nop</code> until its local index is\n+     *  set.\n+     */\n+    public StoreInstruction astore() {\n+        return (StoreInstruction) addInstruction(new StoreInstruction(this).setType(\n+                Object.class));\n+    }\n+\n+    /**\n+     *  Add the <code>ret</code> opcode, used in implementing\n+     *  <code>finally</code> clauses.\n+     */\n+    public RetInstruction ret() {\n+        return (RetInstruction) addInstruction(Constants.RET);\n+    }\n+\n+    /**\n+     *  Add the <code>iinc</code> opcode.\n+     */\n+    public IIncInstruction iinc() {\n+        return (IIncInstruction) addInstruction(Constants.IINC);\n+    }\n+\n+    /**\n+     *  Add the <code>wide</code> opcode.\n+     */\n+    public WideInstruction wide() {\n+        return (WideInstruction) addInstruction(Constants.WIDE);\n+    }\n+\n+    /**\n+     *  Load an array value onto the stack.  This instruction will result\n+     *  in a <code>nop</code> until its type is set.\n+     */\n+    public ArrayLoadInstruction xaload() {\n+        return (ArrayLoadInstruction) addInstruction(new ArrayLoadInstruction(\n+                this));\n+    }\n+\n+    /**\n+     *  Load an int array value onto the stack; the <code>iaload</code>\n+     *  opcode.\n+     */\n+    public ArrayLoadInstruction iaload() {\n+        return (ArrayLoadInstruction) addInstruction(Constants.IALOAD);\n+    }\n+\n+    /**\n+     *  Load a long array value onto the stack; the <code>laload</code>\n+     *  opcode.\n+     */\n+    public ArrayLoadInstruction laload() {\n+        return (ArrayLoadInstruction) addInstruction(Constants.LALOAD);\n+    }\n+\n+    /**\n+     *  Load a float array value onto the stack; the <code>faload</code>\n+     *  opcode.\n+     */\n+    public ArrayLoadInstruction faload() {\n+        return (ArrayLoadInstruction) addInstruction(Constants.FALOAD);\n+    }\n+\n+    /**\n+     *  Load a double array value onto the stack; the <code>daload</code>\n+     *  opcode.\n+     */\n+    public ArrayLoadInstruction daload() {\n+        return (ArrayLoadInstruction) addInstruction(Constants.DALOAD);\n+    }\n+\n+    /**\n+     *  Load an object array value onto the stack; the <code>aaload</code>\n+     *  opcode.\n+     */\n+    public ArrayLoadInstruction aaload() {\n+        return (ArrayLoadInstruction) addInstruction(Constants.AALOAD);\n+    }\n+\n+    /**\n+     *  Load a byte array value onto the stack; the <code>baload</code>\n+     *  opcode.\n+     */\n+    public ArrayLoadInstruction baload() {\n+        return (ArrayLoadInstruction) addInstruction(Constants.BALOAD);\n+    }\n+\n+    /**\n+     *  Load a char array value onto the stack; the <code>caload</code>\n+     *  opcode.\n+     */\n+    public ArrayLoadInstruction caload() {\n+        return (ArrayLoadInstruction) addInstruction(Constants.CALOAD);\n+    }\n+\n+    /**\n+     *  Load a short array value onto the stack; the <code>saload</code>\n+     *  opcode.\n+     */\n+    public ArrayLoadInstruction saload() {\n+        return (ArrayLoadInstruction) addInstruction(Constants.SALOAD);\n+    }\n+\n+    /**\n+     *  Store a value from the stack into an array.  This instruction\n+     *  will result in a <code>nop</code> until its type is set.\n+     */\n+    public ArrayStoreInstruction xastore() {\n+        return (ArrayStoreInstruction) addInstruction(new ArrayStoreInstruction(\n+                this));\n+    }\n+\n+    /**\n+     *  Store an int value from the stack into an array; the\n+     *  <code>iastore</code> opcode.\n+     */\n+    public ArrayStoreInstruction iastore() {\n+        return (ArrayStoreInstruction) addInstruction(Constants.IASTORE);\n+    }\n+\n+    /**\n+     *  Store a long value from the stack into an array; the\n+     *  <code>lastore</code> opcode.\n+     */\n+    public ArrayStoreInstruction lastore() {\n+        return (ArrayStoreInstruction) addInstruction(Constants.LASTORE);\n+    }\n+\n+    /**\n+     *  Store a float value from the stack into an array; the\n+     *  <code>fastore</code> opcode.\n+     */\n+    public ArrayStoreInstruction fastore() {\n+        return (ArrayStoreInstruction) addInstruction(Constants.FASTORE);\n+    }\n+\n+    /**\n+     *  Store a double value from the stack into an array; the\n+     *  <code>dastore</code> opcode.\n+     */\n+    public ArrayStoreInstruction dastore() {\n+        return (ArrayStoreInstruction) addInstruction(Constants.DASTORE);\n+    }\n+\n+    /**\n+     *  Store an object value from the stack into an array; the\n+     *  <code>aastore</code> opcode.\n+     */\n+    public ArrayStoreInstruction aastore() {\n+        return (ArrayStoreInstruction) addInstruction(Constants.AASTORE);\n+    }\n+\n+    /**\n+     *  Store a byte value from the stack into an array; the\n+     *  <code>bastore</code> opcode.\n+     */\n+    public ArrayStoreInstruction bastore() {\n+        return (ArrayStoreInstruction) addInstruction(Constants.BASTORE);\n+    }\n+\n+    /**\n+     *  Store a char value from the stack into an array; the\n+     *  <code>castore</code> opcode.\n+     */\n+    public ArrayStoreInstruction castore() {\n+        return (ArrayStoreInstruction) addInstruction(Constants.CASTORE);\n+    }\n+\n+    /**\n+     *  Store a short value from the stack into an array; the\n+     *  <code>sastore</code> opcode.\n+     */\n+    public ArrayStoreInstruction sastore() {\n+        return (ArrayStoreInstruction) addInstruction(Constants.SASTORE);\n+    }\n+\n+    /**\n+     *  The <code>pop</code> opcode.\n+     */\n+    public StackInstruction pop() {\n+        return (StackInstruction) addInstruction(Constants.POP);\n+    }\n+\n+    /**\n+     *  The <code>pop2</code> opcode.\n+     */\n+    public StackInstruction pop2() {\n+        return (StackInstruction) addInstruction(Constants.POP2);\n+    }\n+\n+    /**\n+     *  The <code>dup</code> opcode.\n+     */\n+    public StackInstruction dup() {\n+        return (StackInstruction) addInstruction(Constants.DUP);\n+    }\n+\n+    /**\n+     *  The <code>dupx1</code> opcode.\n+     */\n+    public StackInstruction dupx1() {\n+        return (StackInstruction) addInstruction(Constants.DUPX1);\n+    }\n+\n+    /**\n+     *  The <code>dupx2</code> opcode.\n+     */\n+    public StackInstruction dupx2() {\n+        return (StackInstruction) addInstruction(Constants.DUPX2);\n+    }\n+\n+    /**\n+     *  The <code>dup2</code> opcode.\n+     */\n+    public StackInstruction dup2() {\n+        return (StackInstruction) addInstruction(Constants.DUP2);\n+    }\n+\n+    /**\n+     *  The <code>dup2x1</code> opcode.\n+     */\n+    public StackInstruction dup2x1() {\n+        return (StackInstruction) addInstruction(Constants.DUP2X1);\n+    }\n+\n+    /**\n+     *  The <code>dup2x2</code> opcode.\n+     */\n+    public StackInstruction dup2x2() {\n+        return (StackInstruction) addInstruction(Constants.DUP2X2);\n+    }\n+\n+    /**\n+     *  The <code>swap</code> opcode.\n+     */\n+    public StackInstruction swap() {\n+        return (StackInstruction) addInstruction(Constants.SWAP);\n+    }\n+\n+    /**\n+     *  Perform some math operation on the stack items.  This instruction will\n+     *  result in a <code>nop</code> until its operation and type are set.\n+     */\n+    public MathInstruction math() {\n+        return (MathInstruction) addInstruction(new MathInstruction(this));\n+    }\n+\n+    /**\n+     *  Add the top two stack values.  This instruction will result in\n+     *  a <code>nop</code> until its type is set.\n+     */\n+    public MathInstruction xadd() {\n+        MathInstruction mi = math();\n+\n+        return mi.setOperation(Constants.MATH_ADD);\n+    }\n+\n+    /**\n+     *  Add the top two stack int values; the <code>iadd</code> opcode.\n+     */\n+    public MathInstruction iadd() {\n+        return (MathInstruction) addInstruction(Constants.IADD);\n+    }\n+\n+    /**\n+     *  Add the top two stack long values; the <code>ladd</code> opcode.\n+     */\n+    public MathInstruction ladd() {\n+        return (MathInstruction) addInstruction(Constants.LADD);\n+    }\n+\n+    /**\n+     *  Add the top two stack float values; the <code>fadd</code> opcode.\n+     */\n+    public MathInstruction fadd() {\n+        return (MathInstruction) addInstruction(Constants.FADD);\n+    }\n+\n+    /**\n+     *  Add the top two stack double values; the <code>dadd</code> opcode.\n+     */\n+    public MathInstruction dadd() {\n+        return (MathInstruction) addInstruction(Constants.DADD);\n+    }\n+\n+    /**\n+     *  Subtract the top two stack values.  This instruction will result in\n+     *  a <code>nop</code> until its type is set.\n+     */\n+    public MathInstruction xsub() {\n+        MathInstruction mi = math();\n+\n+        return mi.setOperation(Constants.MATH_SUB);\n+    }\n+\n+    /**\n+     *  Subtract the top two stack int values; the <code>isub</code> opcode.\n+     */\n+    public MathInstruction isub() {\n+        return (MathInstruction) addInstruction(Constants.ISUB);\n+    }\n+\n+    /**\n+     *  Subtract the top two stack long values; the <code>lsub</code> opcode.\n+     */\n+    public MathInstruction lsub() {\n+        return (MathInstruction) addInstruction(Constants.LSUB);\n+    }\n+\n+    /**\n+     *  Subtract the top two stack float values; the <code>fsub</code> opcode.\n+     */\n+    public MathInstruction fsub() {\n+        return (MathInstruction) addInstruction(Constants.FSUB);\n+    }\n+\n+    /**\n+     *  Subtract the top two stack double values; the <code>dsub</code> opcode.\n+     */\n+    public MathInstruction dsub() {\n+        return (MathInstruction) addInstruction(Constants.DSUB);\n+    }\n+\n+    /**\n+     *  Multiply the top two stack values.  This instruction will result in\n+     *  a <code>nop</code> until its type is set.\n+     */\n+    public MathInstruction xmul() {\n+        MathInstruction mi = math();\n+\n+        return mi.setOperation(Constants.MATH_MUL);\n+    }\n+\n+    /**\n+     *  Multiply the top two stack int values; the <code>imul</code> opcode.\n+     */\n+    public MathInstruction imul() {\n+        return (MathInstruction) addInstruction(Constants.IMUL);\n+    }\n+\n+    /**\n+     *  Multiply the top two stack long values; the <code>lmul</code> opcode.\n+     */\n+    public MathInstruction lmul() {\n+        return (MathInstruction) addInstruction(Constants.LMUL);\n+    }\n+\n+    /**\n+     *  Multiply the top two stack float values; the <code>fmul</code> opcode.\n+     */\n+    public MathInstruction fmul() {\n+        return (MathInstruction) addInstruction(Constants.FMUL);\n+    }\n+\n+    /**\n+     *  Multiply the top two stack double values; the <code>dmul</code> opcode.\n+     */\n+    public MathInstruction dmul() {\n+        return (MathInstruction) addInstruction(Constants.DMUL);\n+    }\n+\n+    /**\n+     *  Divide the top two stack values.  This instruction will result in\n+     *  a <code>nop</code> until its type is set.\n+     */\n+    public MathInstruction xdiv() {\n+        MathInstruction mi = math();\n+\n+        return mi.setOperation(Constants.MATH_DIV);\n+    }\n+\n+    /**\n+     *  Divide the top two stack int values; the <code>idiv</code> opcode.\n+     */\n+    public MathInstruction idiv() {\n+        return (MathInstruction) addInstruction(Constants.IDIV);\n+    }\n+\n+    /**\n+     *  Divide the top two stack long values; the <code>ldiv</code> opcode.\n+     */\n+    public MathInstruction ldiv() {\n+        return (MathInstruction) addInstruction(Constants.LDIV);\n+    }\n+\n+    /**\n+     *  Divide the top two stack float values; the <code>fdiv</code> opcode.\n+     */\n+    public MathInstruction fdiv() {\n+        return (MathInstruction) addInstruction(Constants.FDIV);\n+    }\n+\n+    /**\n+     *  Divide the top two stack double values; the <code>ddiv</code> opcode.\n+     */\n+    public MathInstruction ddiv() {\n+        return (MathInstruction) addInstruction(Constants.DDIV);\n+    }\n+\n+    /**\n+     *  Take the remainder of the top two stack values.  This instruction will\n+     *  result in a <code>nop</code> until its type is set.\n+     */\n+    public MathInstruction xrem() {\n+        MathInstruction mi = math();\n+\n+        return mi.setOperation(Constants.MATH_REM);\n+    }\n+\n+    /**\n+     *  Take the remainder of the top two int stack values; the\n+     *  <code>irem</code> opcode.\n+     */\n+    public MathInstruction irem() {\n+        return (MathInstruction) addInstruction(Constants.IREM);\n+    }\n+\n+    /**\n+     *  Take the remainder of the top two long stack values; the\n+     *  <code>lrem</code> opcode.\n+     */\n+    public MathInstruction lrem() {\n+        return (MathInstruction) addInstruction(Constants.LREM);\n+    }\n+\n+    /**\n+     *  Take the remainder of the top two float stack values; the\n+     *  <code>frem</code> opcode.\n+     */\n+    public MathInstruction frem() {\n+        return (MathInstruction) addInstruction(Constants.FREM);\n+    }\n+\n+    /**\n+     *  Take the remainder of the top two double stack values; the\n+     *  <code>drem</code> opcode.\n+     */\n+    public MathInstruction drem() {\n+        return (MathInstruction) addInstruction(Constants.DREM);\n+    }\n+\n+    /**\n+     *  Negate the top stack value.  This instruction will result in a\n+     *  <code>nop</code> until its type is set.\n+     */\n+    public MathInstruction xneg() {\n+        MathInstruction mi = math();\n+\n+        return mi.setOperation(Constants.MATH_NEG);\n+    }\n+\n+    /**\n+     *  Negate the top stack int value; the <code>ineg</code> opcode.\n+     */\n+    public MathInstruction ineg() {\n+        return (MathInstruction) addInstruction(Constants.INEG);\n+    }\n+\n+    /**\n+     *  Negate the top stack long value; the <code>lneg</code> opcode.\n+     */\n+    public MathInstruction lneg() {\n+        return (MathInstruction) addInstruction(Constants.LNEG);\n+    }\n+\n+    /**\n+     *  Negate the top stack float value; the <code>fneg</code> opcode.\n+     */\n+    public MathInstruction fneg() {\n+        return (MathInstruction) addInstruction(Constants.FNEG);\n+    }\n+\n+    /**\n+     *  Negate the top stack double value; the <code>dneg</code> opcode.\n+     */\n+    public MathInstruction dneg() {\n+        return (MathInstruction) addInstruction(Constants.DNEG);\n+    }\n+\n+    /**\n+     *  Shift the top stack values.  This instruction will result in a\n+     *  <code>nop</code> until its type is set.\n+     */\n+    public MathInstruction xshl() {\n+        MathInstruction mi = math();\n+\n+        return mi.setOperation(Constants.MATH_SHL);\n+    }\n+\n+    /**\n+     *  Shift the top stack int values; the <code>ishl</code> opcode.\n+     */\n+    public MathInstruction ishl() {\n+        return (MathInstruction) addInstruction(Constants.ISHL);\n+    }\n+\n+    /**\n+     *  Shift the top stack long values; the <code>lshl</code> opcode.\n+     */\n+    public MathInstruction lshl() {\n+        return (MathInstruction) addInstruction(Constants.LSHL);\n+    }\n+\n+    /**\n+     *  Shift the top stack values.  This instruction will result in a\n+     *  <code>nop</code> until its type is set.\n+     */\n+    public MathInstruction xshr() {\n+        MathInstruction mi = math();\n+\n+        return mi.setOperation(Constants.MATH_SHR);\n+    }\n+\n+    /**\n+     *  Shift the top stack int values; the <code>ishr</code> opcode.\n+     */\n+    public MathInstruction ishr() {\n+        return (MathInstruction) addInstruction(Constants.ISHR);\n+    }\n+\n+    /**\n+     *  Shift the top stack long values; the <code>lshr</code> opcode.\n+     */\n+    public MathInstruction lshr() {\n+        return (MathInstruction) addInstruction(Constants.LSHR);\n+    }\n+\n+    /**\n+     *  Shift the top stack values.  This instruction will result in a\n+     *  <code>nop</code> until its type is set.\n+     */\n+    public MathInstruction xushr() {\n+        MathInstruction mi = math();\n+\n+        return mi.setOperation(Constants.MATH_USHR);\n+    }\n+\n+    /**\n+     *  Shift the top stack int values; the <code>iushr</code> opcode.\n+     */\n+    public MathInstruction iushr() {\n+        return (MathInstruction) addInstruction(Constants.IUSHR);\n+    }\n+\n+    /**\n+     *  Shift the top stack long values; the <code>lushr</code> opcode.\n+     */\n+    public MathInstruction lushr() {\n+        return (MathInstruction) addInstruction(Constants.LUSHR);\n+    }\n+\n+    /**\n+     *  Take the mathematical and of the top two stack values.  This instruction\n+      *  results in a <code>nop</code> until its type is set.\n+     */\n+    public MathInstruction xand() {\n+        MathInstruction mi = math();\n+\n+        return mi.setOperation(Constants.MATH_AND);\n+    }\n+\n+    /**\n+     *  Take the mathematical and of the top two stack int values; the\n+     *  <code>iand</code> opcode.\n+     */\n+    public MathInstruction iand() {\n+        return (MathInstruction) addInstruction(Constants.IAND);\n+    }\n+\n+    /**\n+     *  Take the mathematical and of the top two stack long values; the\n+     *  <code>land</code> opcode.\n+     */\n+    public MathInstruction land() {\n+        return (MathInstruction) addInstruction(Constants.LAND);\n+    }\n+\n+    /**\n+     *  Take the mathematical or of the top two stack values.  This instruction\n+      *  results in a <code>nop</code> until its type is set.\n+     */\n+    public MathInstruction xor() {\n+        MathInstruction mi = math();\n+\n+        return mi.setOperation(Constants.MATH_OR);\n+    }\n+\n+    /**\n+     *  Take the mathematical or of the top two stack int values; the\n+     *  <code>ior</code> opcode.\n+     */\n+    public MathInstruction ior() {\n+        return (MathInstruction) addInstruction(Constants.IOR);\n+    }\n+\n+    /**\n+     *  Take the mathematical or of the top two stack long values; the\n+     *  <code>lor</code> opcode.\n+     */\n+    public MathInstruction lor() {\n+        return (MathInstruction) addInstruction(Constants.LOR);\n+    }\n+\n+    /**\n+     *  Take the mathematical xor of the top two stack values.  This instruction\n+      *  results in a <code>nop</code> until its type is set.\n+     */\n+    public MathInstruction xxor() {\n+        MathInstruction mi = math();\n+\n+        return mi.setOperation(Constants.MATH_XOR);\n+    }\n+\n+    /**\n+     *  Take the mathematical xor of the top two stack int values; the\n+     *  <code>ixor</code> opcode.\n+     */\n+    public MathInstruction ixor() {\n+        return (MathInstruction) addInstruction(Constants.IXOR);\n+    }\n+\n+    /**\n+     *  Take the mathematical xor of the top two stack long values; the\n+     *  <code>lxor</code> opcode.\n+     */\n+    public MathInstruction lxor() {\n+        return (MathInstruction) addInstruction(Constants.LXOR);\n+    }\n+\n+    /**\n+     *  Convert the top stack value to another type.  This instruction\n+     *  will result in a <code>nop</code> until the types to convert\n+     *  between are set.\n+     */\n+    public ConvertInstruction convert() {\n+        return (ConvertInstruction) addInstruction(new ConvertInstruction(this));\n+    }\n+\n+    /**\n+     *  Compare the top two stack values.  This instruction will result in a\n+     *  <code>nop</code> until its type is set.\n+     */\n+    public CmpInstruction xcmp() {\n+        return (CmpInstruction) addInstruction(new CmpInstruction(this));\n+    }\n+\n+    /**\n+     *  Compare the top two stack values; the <code>lcmp</code> opcode.\n+     */\n+    public CmpInstruction lcmp() {\n+        return (CmpInstruction) addInstruction(Constants.LCMP);\n+    }\n+\n+    /**\n+     *  Compare the top two stack values; the <code>fcmpl</code> opcode.\n+     */\n+    public CmpInstruction fcmpl() {\n+        return (CmpInstruction) addInstruction(Constants.FCMPL);\n+    }\n+\n+    /**\n+     *  Compare the top two stack values; the <code>fcmpg</code> opcode.\n+     */\n+    public CmpInstruction fcmpg() {\n+        return (CmpInstruction) addInstruction(Constants.FCMPG);\n+    }\n+\n+    /**\n+     *  Compare the top two stack values; the <code>dcmpl</code> opcode.\n+     */\n+    public CmpInstruction dcmpl() {\n+        return (CmpInstruction) addInstruction(Constants.DCMPL);\n+    }\n+\n+    /**\n+     *  Compare the top two stack values; the <code>dcmpg</code> opcode.\n+     */\n+    public CmpInstruction dcmpg() {\n+        return (CmpInstruction) addInstruction(Constants.DCMPG);\n+    }\n+\n+    /**\n+     *  The <code>ifeq</code> opcode.\n+     */\n+    public IfInstruction ifeq() {\n+        return (IfInstruction) addInstruction(Constants.IFEQ);\n+    }\n+\n+    /**\n+     *  The <code>ifne</code> opcode.\n+     */\n+    public IfInstruction ifne() {\n+        return (IfInstruction) addInstruction(Constants.IFNE);\n+    }\n+\n+    /**\n+     *  The <code>iflt</code> opcode.\n+     */\n+    public IfInstruction iflt() {\n+        return (IfInstruction) addInstruction(Constants.IFLT);\n+    }\n+\n+    /**\n+     *  The <code>ifge</code> opcode.\n+     */\n+    public IfInstruction ifge() {\n+        return (IfInstruction) addInstruction(Constants.IFGE);\n+    }\n+\n+    /**\n+     *  The <code>ifgt</code> opcode.\n+     */\n+    public IfInstruction ifgt() {\n+        return (IfInstruction) addInstruction(Constants.IFGT);\n+    }\n+\n+    /**\n+     *  The <code>ifle</code> opcode.\n+     */\n+    public IfInstruction ifle() {\n+        return (IfInstruction) addInstruction(Constants.IFLE);\n+    }\n+\n+    /**\n+     *  The <code>ificmpeq</code> opcode.\n+     */\n+    public IfInstruction ificmpeq() {\n+        return (IfInstruction) addInstruction(Constants.IFICMPEQ);\n+    }\n+\n+    /**\n+     *  The <code>ificmpne</code> opcode.\n+     */\n+    public IfInstruction ificmpne() {\n+        return (IfInstruction) addInstruction(Constants.IFICMPNE);\n+    }\n+\n+    /**\n+     *  The <code>ificmplt</code> opcode.\n+     */\n+    public IfInstruction ificmplt() {\n+        return (IfInstruction) addInstruction(Constants.IFICMPLT);\n+    }\n+\n+    /**\n+     *  The <code>ificmpge</code> opcode.\n+     */\n+    public IfInstruction ificmpge() {\n+        return (IfInstruction) addInstruction(Constants.IFICMPGE);\n+    }\n+\n+    /**\n+     *  The <code>ificmpgt</code> opcode.\n+     */\n+    public IfInstruction ificmpgt() {\n+        return (IfInstruction) addInstruction(Constants.IFICMPGT);\n+    }\n+\n+    /**\n+     *  The <code>ificmple</code> opcode.\n+     */\n+    public IfInstruction ificmple() {\n+        return (IfInstruction) addInstruction(Constants.IFICMPLE);\n+    }\n+\n+    /**\n+     *  The <code>ifacmpeq</code> opcode.\n+     */\n+    public IfInstruction ifacmpeq() {\n+        return (IfInstruction) addInstruction(Constants.IFACMPEQ);\n+    }\n+\n+    /**\n+     *  The <code>ifacmpne</code> opcode.\n+     */\n+    public IfInstruction ifacmpne() {\n+        return (IfInstruction) addInstruction(Constants.IFACMPNE);\n+    }\n+\n+    /**\n+     *  The <code>ifnull</code> opcode.\n+     */\n+    public IfInstruction ifnull() {\n+        return (IfInstruction) addInstruction(Constants.IFNULL);\n+    }\n+\n+    /**\n+     *  The <code>ifnonnull</code> opcode.\n+     */\n+    public IfInstruction ifnonnull() {\n+        return (IfInstruction) addInstruction(Constants.IFNONNULL);\n+    }\n+\n+    /**\n+     *  The <code>go2</code> opcode.\n+     */\n+    public JumpInstruction go2() {\n+        return (JumpInstruction) addInstruction(Constants.GOTO);\n+    }\n+\n+    /**\n+     *  The <code>jsr</code> opcode used in implementing <code>finally</code>\n+     *  clauses.\n+     */\n+    public JumpInstruction jsr() {\n+        return (JumpInstruction) addInstruction(Constants.JSR);\n+    }\n+\n+    /**\n+     *  The <code>tableswitch</code> opcode.\n+     */\n+    public TableSwitchInstruction tableswitch() {\n+        return (TableSwitchInstruction) addInstruction(Constants.TABLESWITCH);\n+    }\n+\n+    /**\n+     *  The <code>lookupswitch</code> opcode.\n+     */\n+    public LookupSwitchInstruction lookupswitch() {\n+        return (LookupSwitchInstruction) addInstruction(Constants.LOOKUPSWITCH);\n+    }\n+\n+    /**\n+     *  Return from a method.  This method will result in a\n+     *  <code>nop</code> until its type is set.\n+     */\n+    public ReturnInstruction xreturn() {\n+        return (ReturnInstruction) addInstruction(new ReturnInstruction(this));\n+    }\n+\n+    /**\n+     *  Return void from a method; the <code>return</code> opcode.\n+     */\n+    public ReturnInstruction vreturn() {\n+        return (ReturnInstruction) addInstruction(Constants.RETURN);\n+    }\n+\n+    /**\n+     *  Return an int from a method; the <code>ireturn</code> opcode.\n+     */\n+    public ReturnInstruction ireturn() {\n+        return (ReturnInstruction) addInstruction(Constants.IRETURN);\n+    }\n+\n+    /**\n+     *  Return a long from a method; the <code>lreturn</code> opcode.\n+     */\n+    public ReturnInstruction lreturn() {\n+        return (ReturnInstruction) addInstruction(Constants.LRETURN);\n+    }\n+\n+    /**\n+     *  Return a float from a method; the <code>freturn</code> opcode.\n+     */\n+    public ReturnInstruction freturn() {\n+        return (ReturnInstruction) addInstruction(Constants.FRETURN);\n+    }\n+\n+    /**\n+     *  Return a double from a method; the <code>dreturn</code> opcode.\n+     */\n+    public ReturnInstruction dreturn() {\n+        return (ReturnInstruction) addInstruction(Constants.DRETURN);\n+    }\n+\n+    /**\n+     *  Return an object from a method; the <code>areturn</code> opcode.\n+     */\n+    public ReturnInstruction areturn() {\n+        return (ReturnInstruction) addInstruction(Constants.ARETURN);\n+    }\n+\n+    /**\n+     *  Load the value from a field onto the stack; the <code>getfield</code>\n+     *  opcode.\n+     */\n+    public GetFieldInstruction getfield() {\n+        return (GetFieldInstruction) addInstruction(Constants.GETFIELD);\n+    }\n+\n+    /**\n+     *  Load the value from a static field onto the stack; the\n+     *  <code>getstatic</code> opcode.\n+     */\n+    public GetFieldInstruction getstatic() {\n+        return (GetFieldInstruction) addInstruction(Constants.GETSTATIC);\n+    }\n+\n+    /**\n+     *  Place the value of a field onto the stack; the <code>putfield</code>\n+     *  opcode.\n+     */\n+    public PutFieldInstruction putfield() {\n+        return (PutFieldInstruction) addInstruction(Constants.PUTFIELD);\n+    }\n+\n+    /**\n+     *  Place the value of a static field onto the stack; the\n+     *  <code>putstatic</code> opcode.\n+     */\n+    public PutFieldInstruction putstatic() {\n+        return (PutFieldInstruction) addInstruction(Constants.PUTSTATIC);\n+    }\n+\n+    /**\n+     *  Invoke a virtual method; the <code>invokevirtual</code> opcode.\n+     */\n+    public MethodInstruction invokevirtual() {\n+        return (MethodInstruction) addInstruction(Constants.INVOKEVIRTUAL);\n+    }\n+\n+    /**\n+     *  Invoke a method non-virtually, as for constructors and superclass\n+     *  methods; the <code>invokespecial</code> opcode.\n+     */\n+    public MethodInstruction invokespecial() {\n+        return (MethodInstruction) addInstruction(Constants.INVOKESPECIAL);\n+    }\n+\n+    /**\n+     *  Invoke a method on an interface; the <code>invokeinterface</code>\n+     *  opcode.\n+     */\n+    public MethodInstruction invokeinterface() {\n+        return (MethodInstruction) addInstruction(Constants.INVOKEINTERFACE);\n+    }\n+\n+    /**\n+     *  Invoke a static method; the <code>invokestatic</code> opcode.\n+     */\n+    public MethodInstruction invokestatic() {\n+        return (MethodInstruction) addInstruction(Constants.INVOKESTATIC);\n+    }\n+\n+    /**\n+     *  Create a new instance of an object; the <code>new</code> opcode.\n+     */\n+    public ClassInstruction anew() {\n+        return (ClassInstruction) addInstruction(Constants.NEW);\n+    }\n+\n+    /**\n+     *  Create a new instance of an object array; the <code>anew</code> opcode.\n+     */\n+    public ClassInstruction anewarray() {\n+        return (ClassInstruction) addInstruction(Constants.ANEWARRAY);\n+    }\n+\n+    /**\n+     *  Cast an object on the stack to another type; the <code>checkcast</code>\n+     *  opcode.\n+     */\n+    public ClassInstruction checkcast() {\n+        return (ClassInstruction) addInstruction(Constants.CHECKCAST);\n+    }\n+\n+    /**\n+     *  Test if a stack object is an instance of a class; the\n+     *  <code>instanceof</code> opcode.\n+     */\n+    public ClassInstruction isinstance() {\n+        return (ClassInstruction) addInstruction(Constants.INSTANCEOF);\n+    }\n+\n+    /**\n+     *  Create a new multidimensional array; the <code>multianewarray</code>\n+     *  opcode.\n+     */\n+    public MultiANewArrayInstruction multianewarray() {\n+        return (MultiANewArrayInstruction) addInstruction(Constants.MULTIANEWARRAY);\n+    }\n+\n+    /**\n+     *  Create a new array of a primitive type; the <code>newarray</code>\n+     *  opcode.\n+     */\n+    public NewArrayInstruction newarray() {\n+        return (NewArrayInstruction) addInstruction(Constants.NEWARRAY);\n+    }\n+\n+    /**\n+     *  Get the length of an array on the stack; the <code>arraylength</code>\n+     *  opcode.\n+     */\n+    public Instruction arraylength() {\n+        return addInstruction(Constants.ARRAYLENGTH);\n+    }\n+\n+    /**\n+     *  Throw an exception; the <code>athrow</code> opcode.\n+     */\n+    public Instruction athrow() {\n+        return addInstruction(Constants.ATHROW);\n+    }\n+\n+    /**\n+     *  The <code>monitorenter</code> opcode.\n+     */\n+    public MonitorEnterInstruction monitorenter() {\n+        return (MonitorEnterInstruction) addInstruction(Constants.MONITORENTER);\n+    }\n+\n+    /**\n+     *  The <code>monitorexit</code> opcode.\n+     */\n+    public MonitorExitInstruction monitorexit() {\n+        return (MonitorExitInstruction) addInstruction(Constants.MONITOREXIT);\n+    }\n+\n+    /////////////////////////\n+    // Wholisitic operations\n+    /////////////////////////\n+\n+    /**\n+     *  Return all the Instructions of this method.\n+     */\n+    public Instruction[] getInstructions() {\n+        Instruction[] arr = new Instruction[_size];\n+        int i = 0;\n+\n+        for (CodeEntry entry = _head.next; entry != _tail;\n+                entry = entry.next)\n+            arr[i++] = (Instruction) entry;\n+\n+        return arr;\n+    }\n+\n+    int getLength() {\n+        // covers maxStack, maxLocals, codeLength, exceptionTableLength,\n+        // attributeCount\n+        int length = 12;\n+\n+        // add code\n+        try {\n+            length += toByteArray().length;\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe.toString());\n+        }\n+\n+        // add exception reps; each is 8 bytes\n+        length += (8 * _handlers.size());\n+\n+        // add all attribute lengths\n+        Attribute[] attrs = getAttributes();\n+\n+        for (int i = 0; i < attrs.length; i++)\n+            length += (attrs[i].getLength() + 6);\n+\n+        return length;\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterCode(this);\n+\n+        Instruction ins;\n+\n+        for (CodeEntry entry = _head.next; entry != _tail;\n+                entry = entry.next) {\n+            ins = (Instruction) entry;\n+            visit.enterInstruction(ins);\n+            ins.acceptVisit(visit);\n+            visit.exitInstruction(ins);\n+        }\n+\n+        for (Iterator i = _handlers.iterator(); i.hasNext();)\n+            ((ExceptionHandler) i.next()).acceptVisit(visit);\n+\n+        visitAttributes(visit);\n+\n+        visit.exitCode(this);\n+    }\n+\n+    //////////////////////////\n+    // Convenience operations\n+    //////////////////////////\n+\n+    /**\n+     *  Return line number information for the code.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @param add                if true, a new line number table will be added\n+     *                                  if not already present\n+     *  @return the line number information, or null if none\n+     *                                  and the <code>add</code> param is set to false\n+     */\n+    public LineNumberTable getLineNumberTable(boolean add) {\n+        LineNumberTable attr = (LineNumberTable) getAttribute(Constants.ATTR_LINENUMBERS);\n+\n+        if (!add || (attr != null)) {\n+            return attr;\n+        }\n+\n+        return (LineNumberTable) addAttribute(Constants.ATTR_LINENUMBERS);\n+    }\n+\n+    /**\n+     *  Remove the line number table for the code.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @return true if there was a table to remove\n+     */\n+    public boolean removeLineNumberTable() {\n+        return removeAttribute(Constants.ATTR_LINENUMBERS);\n+    }\n+\n+    /**\n+     *  Return local variable information for the code.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @param add                if true, a new local variable table will be\n+     *                                  added if not already present\n+     *  @return the local variable information, or null if none\n+     *                                  and the <code>add</code> param is set to false\n+     */\n+    public LocalVariableTable getLocalVariableTable(boolean add) {\n+        LocalVariableTable attr = (LocalVariableTable) getAttribute(Constants.ATTR_LOCALS);\n+\n+        if (!add || (attr != null)) {\n+            return attr;\n+        }\n+\n+        return (LocalVariableTable) addAttribute(Constants.ATTR_LOCALS);\n+    }\n+\n+    /**\n+     *  Remove the local variable table for the code.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @return true if there was a table to remove\n+     */\n+    public boolean removeLocalVariableTables() {\n+        return removeAttribute(Constants.ATTR_LOCALS);\n+    }\n+\n+    /**\n+     *  Return local variable generics information for the code.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @param add                if true, a new local variable type table will be\n+     *                                  added if not already present\n+     *  @return the local variable type information, or null if none\n+     *                                  and the <code>add</code> param is set to false\n+     */\n+    public LocalVariableTypeTable getLocalVariableTypeTable(boolean add) {\n+        LocalVariableTypeTable attr = (LocalVariableTypeTable) getAttribute(Constants.ATTR_LOCAL_TYPES);\n+\n+        if (!add || (attr != null)) {\n+            return attr;\n+        }\n+\n+        return (LocalVariableTypeTable) addAttribute(Constants.ATTR_LOCAL_TYPES);\n+    }\n+\n+    /**\n+     *  Remove the local variable type table for the code.\n+     *  Acts internally through the {@link Attributes} interface.\n+     *\n+     *  @return true if there was a table to remove\n+     */\n+    public boolean removeLocalVariableTypeTables() {\n+        return removeAttribute(Constants.ATTR_LOCAL_TYPES);\n+    }\n+\n+    //////////////////\n+    // I/O operations\n+    //////////////////\n+    void read(Attribute attr) {\n+        Code orig = (Code) attr;\n+\n+        _maxStack = orig.getMaxStack();\n+        _maxLocals = orig.getMaxLocals();\n+\n+        // clear existing code\n+        _head.next = _tail;\n+        _tail.prev = _head;\n+        _size = 0;\n+        beforeFirst();\n+        _handlers.clear();\n+\n+        // copy all instructions; don't set constant instruction values until\n+        // instruction ptrs have been updated in case the instruction width\n+        // changes because of differences in the constant pool (LDC vs LDCW)\n+        Instruction ins;\n+        Instruction origIns;\n+\n+        for (CodeEntry entry = orig._head.next; entry != orig._tail;\n+                entry = entry.next) {\n+            origIns = (Instruction) entry;\n+            ins = addInstruction(origIns.getOpcode());\n+\n+            if (!(ins instanceof ConstantInstruction)) {\n+                ins.read(origIns);\n+            }\n+        }\n+\n+        // copy exception handlers\n+        ExceptionHandler[] origHandlers = orig.getExceptionHandlers();\n+        ExceptionHandler handler;\n+\n+        for (int i = 0; i < origHandlers.length; i++) {\n+            handler = addExceptionHandler();\n+            handler.read(origHandlers[i]);\n+            handler.updateTargets();\n+        }\n+\n+        // reset all opcode ptrs to the new copied opcodes\n+        updateInstructionPointers();\n+        setAttributes(orig.getAttributes());\n+\n+        // setup local variable markers\n+        LocalVariableTable locals = getLocalVariableTable(false);\n+\n+        if (locals != null) {\n+            locals.updateTargets();\n+        }\n+\n+        // setup local variable markers\n+        LocalVariableTypeTable localTypes = getLocalVariableTypeTable(false);\n+\n+        if (localTypes != null) {\n+            localTypes.updateTargets();\n+        }\n+\n+        // setup line number markers\n+        LineNumberTable lines = getLineNumberTable(false);\n+\n+        if (lines != null) {\n+            lines.updateTargets();\n+        }\n+\n+        // now copy constant instruction values\n+        CodeEntry copy = _head.next;\n+\n+        for (CodeEntry entry = orig._head.next; entry != orig._tail;\n+                entry = entry.next, copy = copy.next) {\n+            if (entry instanceof ConstantInstruction) {\n+                ((ConstantInstruction) copy).read((Instruction) entry);\n+            }\n+        }\n+\n+        beforeFirst();\n+    }\n+\n+    void read(DataInput in, int length) throws IOException {\n+        _maxStack = in.readUnsignedShort();\n+        _maxLocals = in.readUnsignedShort();\n+\n+        readCode(in, in.readInt());\n+\n+        _handlers.clear();\n+\n+        int exceptionCount = in.readUnsignedShort();\n+        ExceptionHandler excep;\n+\n+        for (int i = 0; i < exceptionCount; i++) {\n+            excep = addExceptionHandler();\n+            excep.read(in);\n+            excep.updateTargets();\n+        }\n+\n+        readAttributes(in);\n+\n+        // setup local variable markers\n+        LocalVariableTable locals = getLocalVariableTable(false);\n+\n+        if (locals != null) {\n+            locals.updateTargets();\n+        }\n+\n+        // setup local variable markers\n+        LocalVariableTypeTable localTypes = getLocalVariableTypeTable(false);\n+\n+        if (localTypes != null) {\n+            localTypes.updateTargets();\n+        }\n+\n+        // setup line number markers\n+        LineNumberTable lines = getLineNumberTable(false);\n+\n+        if (lines != null) {\n+            lines.updateTargets();\n+        }\n+    }\n+\n+    void write(DataOutput out, int length) throws IOException {\n+        out.writeShort(_maxStack);\n+        out.writeShort(_maxLocals);\n+\n+        byte[] code = toByteArray();\n+        out.writeInt(code.length);\n+        out.write(code);\n+\n+        out.writeShort(_handlers.size());\n+\n+        for (Iterator itr = _handlers.iterator(); itr.hasNext();)\n+            ((ExceptionHandler) itr.next()).write(out);\n+\n+        writeAttributes(out);\n+    }\n+\n+    private void readCode(DataInput in, int len) throws IOException {\n+        _head.next = _tail;\n+        _tail.prev = _head;\n+        _size = 0;\n+        beforeFirst();\n+\n+        Instruction ins;\n+\n+        for (int byteIndex = 0; byteIndex < len;) {\n+            ins = addInstruction(in.readUnsignedByte());\n+            ins.read(in);\n+            byteIndex += ins.getLength();\n+        }\n+\n+        updateInstructionPointers();\n+        beforeFirst();\n+    }\n+\n+    /**\n+     *  Ensures that all the opcode targets are set up correctly.\n+     */\n+    private void updateInstructionPointers() {\n+        for (CodeEntry entry = _head.next; entry != _tail;\n+                entry = entry.next)\n+            if (entry instanceof InstructionPtr) {\n+                ((InstructionPtr) entry).updateTargets();\n+            }\n+    }\n+\n+    /**\n+     *  Returns the byteIndex of the given instruction.\n+     */\n+    int getByteIndex(Instruction ins) {\n+        int byteIndex = 0;\n+\n+        for (CodeEntry entry = _head.next; entry != _tail;\n+                entry = entry.next) {\n+            if (entry == ins) {\n+                return byteIndex;\n+            }\n+\n+            byteIndex += ((Instruction) entry).getLength();\n+        }\n+\n+        throw new IllegalArgumentException(\"ins.owner != this\");\n+    }\n+\n+    /**\n+     *  Returns the instruction in this code block found at the given\n+     *  byte index.\n+     */\n+    Instruction getInstruction(int byteIndex) {\n+        if (byteIndex < 0) {\n+            return null;\n+        }\n+\n+        int curIndex = 0;\n+\n+        for (CodeEntry entry = _head.next; entry != _tail;\n+                entry = entry.next) {\n+            if (byteIndex == curIndex) {\n+                return (Instruction) entry;\n+            }\n+\n+            curIndex += ((Instruction) entry).getLength();\n+        }\n+\n+        throw new IllegalArgumentException(String.valueOf(byteIndex));\n+    }\n+\n+    /**\n+     *  Returns the number of instructions that occur before 'ins'\n+     *  in this code block that 'ins' is a part of.\n+     *\n+     *  @throws IllegalArgumentException if this code block is not the owner\n+     *                  of ins\n+     */\n+    private int indexOf(Instruction ins) {\n+        int i = 0;\n+\n+        for (CodeEntry entry = _head.next; entry != _tail;\n+                entry = entry.next, i++)\n+            if (entry == ins) {\n+                return i;\n+            }\n+\n+        throw new IllegalArgumentException(\"ins.code != this\");\n+    }\n+\n+    private void writeCode(DataOutput out) throws IOException {\n+        Instruction ins;\n+\n+        for (CodeEntry entry = _head.next; entry != _tail;\n+                entry = entry.next) {\n+            ins = (Instruction) entry;\n+            out.writeByte(ins.getOpcode());\n+            ins.write(out);\n+        }\n+    }\n+\n+    private byte[] toByteArray() throws IOException {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n+        DataOutputStream stream = new DataOutputStream(byteStream);\n+\n+        try {\n+            writeCode(stream);\n+\n+            return byteStream.toByteArray();\n+        } finally {\n+            try {\n+                stream.close();\n+            } catch (Exception e) {\n+            }\n+        }\n+    }\n+\n+    private void fromByteArray(byte[] code) throws IOException {\n+        if (code == null) {\n+            _head.next = _tail;\n+            _tail.prev = _head;\n+            _size = 0;\n+        } else {\n+            DataInputStream stream = new DataInputStream(new ByteArrayInputStream(\n+                        code));\n+\n+            try {\n+                readCode(stream, code.length);\n+            } finally {\n+                try {\n+                    stream.close();\n+                } catch (Exception e) {\n+                }\n+            }\n+        }\n+    }\n+\n+    private Instruction addInstruction(Instruction ins) {\n+        _ci.add(ins);\n+\n+        return ins;\n+    }\n+\n+    private Instruction addInstruction(int opcode) {\n+        return addInstruction(createInstruction(opcode));\n+    }\n+\n+    /**\n+     *  Creates an Instruction, with this code block as the owner.\n+     *  Note that the Instruction is not added to this Code block.\n+     */\n+    private Instruction createInstruction(int opcode) {\n+        switch (opcode) {\n+        case Constants.NOP:\n+        case Constants.ARRAYLENGTH:\n+        case Constants.ATHROW:\n+            return new Instruction(this, opcode);\n+\n+        case Constants.ACONSTNULL:\n+        case Constants.ICONSTM1:\n+        case Constants.ICONST0:\n+        case Constants.ICONST1:\n+        case Constants.ICONST2:\n+        case Constants.ICONST3:\n+        case Constants.ICONST4:\n+        case Constants.ICONST5:\n+        case Constants.LCONST0:\n+        case Constants.LCONST1:\n+        case Constants.FCONST0:\n+        case Constants.FCONST1:\n+        case Constants.FCONST2:\n+        case Constants.DCONST0:\n+        case Constants.DCONST1:\n+        case Constants.BIPUSH:\n+        case Constants.SIPUSH:\n+        case Constants.LDC:\n+        case Constants.LDCW:\n+        case Constants.LDC2W:\n+            return new ConstantInstruction(this, opcode);\n+\n+        case Constants.ILOAD:\n+        case Constants.LLOAD:\n+        case Constants.FLOAD:\n+        case Constants.DLOAD:\n+        case Constants.ALOAD:\n+        case Constants.ILOAD0:\n+        case Constants.ILOAD1:\n+        case Constants.ILOAD2:\n+        case Constants.ILOAD3:\n+        case Constants.LLOAD0:\n+        case Constants.LLOAD1:\n+        case Constants.LLOAD2:\n+        case Constants.LLOAD3:\n+        case Constants.FLOAD0:\n+        case Constants.FLOAD1:\n+        case Constants.FLOAD2:\n+        case Constants.FLOAD3:\n+        case Constants.DLOAD0:\n+        case Constants.DLOAD1:\n+        case Constants.DLOAD2:\n+        case Constants.DLOAD3:\n+        case Constants.ALOAD0:\n+        case Constants.ALOAD1:\n+        case Constants.ALOAD2:\n+        case Constants.ALOAD3:\n+            return new LoadInstruction(this, opcode);\n+\n+        case Constants.IALOAD:\n+        case Constants.LALOAD:\n+        case Constants.FALOAD:\n+        case Constants.DALOAD:\n+        case Constants.AALOAD:\n+        case Constants.BALOAD:\n+        case Constants.CALOAD:\n+        case Constants.SALOAD:\n+            return new ArrayLoadInstruction(this, opcode);\n+\n+        case Constants.ISTORE:\n+        case Constants.LSTORE:\n+        case Constants.FSTORE:\n+        case Constants.DSTORE:\n+        case Constants.ASTORE:\n+        case Constants.ISTORE0:\n+        case Constants.ISTORE1:\n+        case Constants.ISTORE2:\n+        case Constants.ISTORE3:\n+        case Constants.LSTORE0:\n+        case Constants.LSTORE1:\n+        case Constants.LSTORE2:\n+        case Constants.LSTORE3:\n+        case Constants.FSTORE0:\n+        case Constants.FSTORE1:\n+        case Constants.FSTORE2:\n+        case Constants.FSTORE3:\n+        case Constants.DSTORE0:\n+        case Constants.DSTORE1:\n+        case Constants.DSTORE2:\n+        case Constants.DSTORE3:\n+        case Constants.ASTORE0:\n+        case Constants.ASTORE1:\n+        case Constants.ASTORE2:\n+        case Constants.ASTORE3:\n+            return new StoreInstruction(this, opcode);\n+\n+        case Constants.IASTORE:\n+        case Constants.LASTORE:\n+        case Constants.FASTORE:\n+        case Constants.DASTORE:\n+        case Constants.AASTORE:\n+        case Constants.BASTORE:\n+        case Constants.CASTORE:\n+        case Constants.SASTORE:\n+            return new ArrayStoreInstruction(this, opcode);\n+\n+        case Constants.POP:\n+        case Constants.POP2:\n+        case Constants.DUP:\n+        case Constants.DUPX1:\n+        case Constants.DUPX2:\n+        case Constants.DUP2:\n+        case Constants.DUP2X1:\n+        case Constants.DUP2X2:\n+        case Constants.SWAP:\n+            return new StackInstruction(this, opcode);\n+\n+        case Constants.IADD:\n+        case Constants.LADD:\n+        case Constants.FADD:\n+        case Constants.DADD:\n+        case Constants.ISUB:\n+        case Constants.LSUB:\n+        case Constants.FSUB:\n+        case Constants.DSUB:\n+        case Constants.IMUL:\n+        case Constants.LMUL:\n+        case Constants.FMUL:\n+        case Constants.DMUL:\n+        case Constants.IDIV:\n+        case Constants.LDIV:\n+        case Constants.FDIV:\n+        case Constants.DDIV:\n+        case Constants.IREM:\n+        case Constants.LREM:\n+        case Constants.FREM:\n+        case Constants.DREM:\n+        case Constants.INEG:\n+        case Constants.LNEG:\n+        case Constants.FNEG:\n+        case Constants.DNEG:\n+        case Constants.ISHL:\n+        case Constants.LSHL:\n+        case Constants.ISHR:\n+        case Constants.LSHR:\n+        case Constants.IUSHR:\n+        case Constants.LUSHR:\n+        case Constants.IAND:\n+        case Constants.LAND:\n+        case Constants.IOR:\n+        case Constants.LOR:\n+        case Constants.IXOR:\n+        case Constants.LXOR:\n+            return new MathInstruction(this, opcode);\n+\n+        case Constants.IINC:\n+            return new IIncInstruction(this);\n+\n+        case Constants.I2L:\n+        case Constants.I2F:\n+        case Constants.I2D:\n+        case Constants.L2I:\n+        case Constants.L2F:\n+        case Constants.L2D:\n+        case Constants.F2I:\n+        case Constants.F2L:\n+        case Constants.F2D:\n+        case Constants.D2I:\n+        case Constants.D2L:\n+        case Constants.D2F:\n+        case Constants.I2B:\n+        case Constants.I2C:\n+        case Constants.I2S:\n+            return new ConvertInstruction(this, opcode);\n+\n+        case Constants.LCMP:\n+        case Constants.FCMPL:\n+        case Constants.FCMPG:\n+        case Constants.DCMPL:\n+        case Constants.DCMPG:\n+            return new CmpInstruction(this, opcode);\n+\n+        case Constants.IFEQ:\n+        case Constants.IFNE:\n+        case Constants.IFLT:\n+        case Constants.IFGE:\n+        case Constants.IFGT:\n+        case Constants.IFLE:\n+        case Constants.IFICMPEQ:\n+        case Constants.IFICMPNE:\n+        case Constants.IFICMPLT:\n+        case Constants.IFICMPGE:\n+        case Constants.IFICMPGT:\n+        case Constants.IFICMPLE:\n+        case Constants.IFACMPEQ:\n+        case Constants.IFACMPNE:\n+        case Constants.IFNULL:\n+        case Constants.IFNONNULL:\n+            return new IfInstruction(this, opcode);\n+\n+        case Constants.GOTO:\n+        case Constants.JSR:\n+        case Constants.GOTOW:\n+        case Constants.JSRW:\n+            return new JumpInstruction(this, opcode);\n+\n+        case Constants.RET:\n+            return new RetInstruction(this);\n+\n+        case Constants.TABLESWITCH:\n+            return new TableSwitchInstruction(this);\n+\n+        case Constants.LOOKUPSWITCH:\n+            return new LookupSwitchInstruction(this);\n+\n+        case Constants.IRETURN:\n+        case Constants.LRETURN:\n+        case Constants.FRETURN:\n+        case Constants.DRETURN:\n+        case Constants.ARETURN:\n+        case Constants.RETURN:\n+            return new ReturnInstruction(this, opcode);\n+\n+        case Constants.GETSTATIC:\n+        case Constants.GETFIELD:\n+            return new GetFieldInstruction(this, opcode);\n+\n+        case Constants.PUTSTATIC:\n+        case Constants.PUTFIELD:\n+            return new PutFieldInstruction(this, opcode);\n+\n+        case Constants.INVOKEVIRTUAL:\n+        case Constants.INVOKESPECIAL:\n+        case Constants.INVOKESTATIC:\n+        case Constants.INVOKEINTERFACE:\n+            return new MethodInstruction(this, opcode);\n+\n+        case Constants.NEW:\n+        case Constants.ANEWARRAY:\n+        case Constants.CHECKCAST:\n+        case Constants.INSTANCEOF:\n+            return new ClassInstruction(this, opcode);\n+\n+        case Constants.NEWARRAY:\n+            return new NewArrayInstruction(this);\n+\n+        case Constants.MONITORENTER:\n+            return new MonitorEnterInstruction(this);\n+\n+        case Constants.MONITOREXIT:\n+            return new MonitorExitInstruction(this);\n+\n+        case Constants.WIDE:\n+            return new WideInstruction(this);\n+\n+        case Constants.MULTIANEWARRAY:\n+            return new MultiANewArrayInstruction(this);\n+\n+        default:\n+            throw new IllegalArgumentException(\"Illegal opcode: \" + opcode);\n+        }\n+    }\n+\n+    /**\n+     *  Returns another listIterator view of the Instructions in this\n+     *  code block.  Useful for performing read-only searches through\n+     *  Instructions without effecting the pointer location of the main\n+     *  code block.\n+     */\n+    public ListIterator listIterator() {\n+        return new CodeIterator(_head, -1);\n+    }\n+\n+    /**\n+     *  Helper class to handle invalidation of instructions on removal\n+     *  and notification of modification on addition.\n+     */\n+    private class CodeIterator implements ListIterator {\n+        public static final int UNSET = -99;\n+        private CodeEntry _bn = null; // \"before next\" entry\n+        private Instruction _last = null; // last entry returned\n+        private int _index = UNSET; // index of _bn\n+\n+        public CodeIterator(CodeEntry entry, int index) {\n+            _bn = entry;\n+            _index = index;\n+        }\n+\n+        public boolean hasNext() {\n+            return _bn.next != _tail;\n+        }\n+\n+        public boolean hasPrevious() {\n+            return _bn != _head;\n+        }\n+\n+        public Object next() {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+\n+            _bn = _bn.next;\n+            _last = (Instruction) _bn;\n+\n+            if (_index != UNSET) {\n+                _index++;\n+            }\n+\n+            return _last;\n+        }\n+\n+        public int nextIndex() {\n+            return initIndex() + 1;\n+        }\n+\n+        public Object previous() {\n+            if (!hasPrevious()) {\n+                throw new NoSuchElementException();\n+            }\n+\n+            _last = (Instruction) _bn;\n+            _bn = _bn.prev;\n+\n+            if (_index != UNSET) {\n+                _index--;\n+            }\n+\n+            return _last;\n+        }\n+\n+        public int previousIndex() {\n+            return initIndex();\n+        }\n+\n+        private int initIndex() {\n+            if (_index == UNSET) {\n+                if (_bn == _head) {\n+                    _index = -1;\n+                } else {\n+                    _index = indexOf((Instruction) _bn);\n+                }\n+            }\n+\n+            return _index;\n+        }\n+\n+        public void add(Object obj) {\n+            if (obj == null) {\n+                throw new NullPointerException(\"obj = null\");\n+            }\n+\n+            Instruction ins = (Instruction) obj;\n+\n+            if (_size == 0) {\n+                _head.next = ins;\n+                _tail.prev = ins;\n+                ins.prev = _head;\n+                ins.next = _tail;\n+                _index = 0;\n+            } else {\n+                CodeEntry next = _bn.next;\n+                _bn.next = ins;\n+                next.prev = ins;\n+                ins.prev = _bn;\n+                ins.next = next;\n+\n+                if (_index != UNSET) {\n+                    _index++;\n+                }\n+            }\n+\n+            _bn = ins;\n+            _last = ins;\n+            _size++;\n+        }\n+\n+        public void set(Object obj) {\n+            if (obj == null) {\n+                throw new NullPointerException(\"obj = null\");\n+            }\n+\n+            if (_last == null) {\n+                throw new IllegalStateException();\n+            }\n+\n+            Instruction ins = (Instruction) obj;\n+            ins.prev = _last.prev;\n+            ins.next = _last.next;\n+            ins.prev.next = ins;\n+            ins.next.prev = ins;\n+\n+            replaceTarget(_last, ins);\n+            _last.invalidate();\n+\n+            if (_bn == _last) {\n+                _bn = ins;\n+            }\n+\n+            _last = ins;\n+        }\n+\n+        public void remove() {\n+            if (_last == null) {\n+                throw new IllegalStateException();\n+            }\n+\n+            if (_bn == _last) {\n+                _bn = _last.prev;\n+            }\n+\n+            _index--;\n+\n+            _last.prev.next = _last.next;\n+            _last.next.prev = _last.prev;\n+            _size--;\n+\n+            Instruction orig = _last;\n+            Instruction replace = null;\n+\n+            if (orig.next != _tail) {\n+                replace = (Instruction) orig.next;\n+            } else {\n+                replace = nop();\n+            }\n+\n+            replaceTarget(orig, replace);\n+\n+            orig.invalidate();\n+            _last = null;\n+        }\n+\n+        private void replaceTarget(Instruction orig, Instruction replace) {\n+            for (CodeEntry entry = _head.next; entry != _tail;\n+                    entry = entry.next)\n+                if (entry instanceof InstructionPtr) {\n+                    ((InstructionPtr) entry).replaceTarget(orig, replace);\n+                }\n+\n+            // update the ExceptionHandler pointers\n+            ExceptionHandler[] handlers = getExceptionHandlers();\n+\n+            for (int i = 0; i < handlers.length; i++)\n+                handlers[i].replaceTarget(orig, replace);\n+\n+            // update LineNumber pointers\n+            LineNumberTable lineNumbers = getLineNumberTable(false);\n+\n+            if (lineNumbers != null) {\n+                lineNumbers.replaceTarget(orig, replace);\n+            }\n+\n+            // update LocalVariable pointers\n+            LocalVariableTable variables = getLocalVariableTable(false);\n+\n+            if (variables != null) {\n+                variables.replaceTarget(orig, replace);\n+            }\n+\n+            // update LocalVariableType pointers\n+            LocalVariableTypeTable types = getLocalVariableTypeTable(false);\n+\n+            if (types != null) {\n+                types.replaceTarget(orig, replace);\n+            }\n+        }\n+    }\n+}"},{"sha":"ef18b0a7ceaadf19be91df290e1ec44ffd0a3e40","filename":"serp/src/main/java/serp/bytecode/CodeEntry.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/CodeEntry.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/CodeEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/CodeEntry.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,27 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+\n+/**\n+ *  <p>An entry in a code block.</p>\n+ *\n+ *  @author Abe White\n+ */\n+class CodeEntry {\n+    CodeEntry next = null;\n+    CodeEntry prev = null;\n+}"},{"sha":"28290ac990cf6e044283a13be605cb80b4cc2085","filename":"serp/src/main/java/serp/bytecode/ConstantInstruction.java","status":"added","additions":531,"deletions":0,"changes":531,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ConstantInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ConstantInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ConstantInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,531 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import serp.util.*;\n+\n+import java.io.*;\n+\n+\n+/**\n+ *  <p>An instruction that that loads a constant onto the stack.\n+ *  The opcode represented by this instruction may change depending on the\n+ *  type and value of the constant set.  For example, if the constant value\n+ *  is initially set to 5, the opcode will be <code>iconst5</code>; if later\n+ *  incremented        to 6, the opcode will be changed to <code>bipush(6)</code>.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class ConstantInstruction extends TypedInstruction {\n+    private int _arg = -1;\n+\n+    ConstantInstruction(Code owner) {\n+        super(owner);\n+    }\n+\n+    ConstantInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    int getLength() {\n+        switch (getOpcode()) {\n+        case Constants.BIPUSH:\n+        case Constants.LDC:\n+            return super.getLength() + 1;\n+\n+        case Constants.SIPUSH:\n+        case Constants.LDCW:\n+        case Constants.LDC2W:\n+            return super.getLength() + 2;\n+\n+        default:\n+            return super.getLength();\n+        }\n+    }\n+\n+    public int getStackChange() {\n+        String type = getTypeName();\n+\n+        if (double.class.getName().equals(type) ||\n+                long.class.getName().equals(type)) {\n+            return 2;\n+        }\n+\n+        return 1;\n+    }\n+\n+    public int getLogicalStackChange() {\n+        return 1;\n+    }\n+\n+    public String getTypeName() {\n+        int opcode = getOpcode();\n+\n+        switch (opcode) {\n+        case Constants.NOP:\n+            return null;\n+\n+        case Constants.ACONSTNULL:\n+            return Object.class.getName();\n+\n+        case Constants.ICONSTM1:\n+        case Constants.ICONST0:\n+        case Constants.ICONST1:\n+        case Constants.ICONST2:\n+        case Constants.ICONST3:\n+        case Constants.ICONST4:\n+        case Constants.ICONST5:\n+        case Constants.BIPUSH:\n+        case Constants.SIPUSH:\n+            return int.class.getName();\n+\n+        case Constants.LCONST0:\n+        case Constants.LCONST1:\n+            return long.class.getName();\n+\n+        case Constants.FCONST0:\n+        case Constants.FCONST1:\n+        case Constants.FCONST2:\n+            return float.class.getName();\n+\n+        case Constants.DCONST0:\n+        case Constants.DCONST1:\n+            return double.class.getName();\n+        }\n+\n+        Entry entry = getPool().getEntry(_arg);\n+\n+        switch (entry.getType()) {\n+        case Entry.UTF8:\n+        case Entry.STRING:\n+            return String.class.getName();\n+\n+        case Entry.INT:\n+            return int.class.getName();\n+\n+        case Entry.FLOAT:\n+            return float.class.getName();\n+\n+        case Entry.LONG:\n+            return long.class.getName();\n+\n+        case Entry.DOUBLE:\n+            return double.class.getName();\n+\n+        case Entry.CLASS:\n+            return Class.class.getName();\n+\n+        default:\n+            return null;\n+        }\n+    }\n+\n+    public TypedInstruction setType(String type) {\n+        throw new UnsupportedOperationException(\"Use setValue\");\n+    }\n+\n+    /**\n+     *  Return the value of the constant as its wrapper type, or null if\n+     *  not set.  Returns class values as the class name.\n+     */\n+    public Object getValue() {\n+        int opcode = getOpcode();\n+\n+        switch (opcode) {\n+        case Constants.NOP:\n+        case Constants.ACONSTNULL:\n+            return null;\n+\n+        case Constants.ICONSTM1:\n+        case Constants.ICONST0:\n+        case Constants.ICONST1:\n+        case Constants.ICONST2:\n+        case Constants.ICONST3:\n+        case Constants.ICONST4:\n+        case Constants.ICONST5:\n+            return Numbers.valueOf(opcode - Constants.ICONST0);\n+\n+        case Constants.LCONST0:\n+        case Constants.LCONST1:\n+            return Numbers.valueOf((long) (opcode - Constants.LCONST0));\n+\n+        case Constants.FCONST0:\n+        case Constants.FCONST1:\n+        case Constants.FCONST2:\n+            return new Float(opcode - Constants.FCONST0);\n+\n+        case Constants.DCONST0:\n+        case Constants.DCONST1:\n+            return new Double(opcode - Constants.DCONST0);\n+\n+        case Constants.BIPUSH:\n+        case Constants.SIPUSH:\n+            return Numbers.valueOf(_arg);\n+\n+        default:\n+\n+            Entry entry = getPool().getEntry(_arg);\n+            Object val = ((ConstantEntry) entry).getConstant();\n+\n+            if (entry.getType() == Entry.CLASS) {\n+                return getProject().getNameCache()\n+                           .getExternalForm((String) val, false);\n+            }\n+\n+            return val;\n+        }\n+    }\n+\n+    /**\n+     *  Set the constant to the given value.  The value should be\n+     *  an instance of String, Integer, Long, Double, Float, Class, BCClass, or\n+     *  null depending on the constant type.  If the given value is not\n+     *  supported directly, it will be converted accordingly.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public ConstantInstruction setValue(Object value) {\n+        if (value instanceof Boolean) {\n+            value = Numbers.valueOf((((Boolean) value).booleanValue()) ? 1 : 0);\n+        } else if (value instanceof Character) {\n+            value = Numbers.valueOf((int) ((Character) value).charValue());\n+        } else if (value instanceof Byte) {\n+            value = Numbers.valueOf(((Byte) value).intValue());\n+        } else if (value instanceof Short) {\n+            value = Numbers.valueOf(((Short) value).intValue());\n+        } else if ((value != null) && !(value instanceof Number) &&\n+                !(value instanceof String) && !(value instanceof Class) &&\n+                !(value instanceof BCClass)) {\n+            throw new IllegalArgumentException(\"value = \" + value);\n+        }\n+\n+        calculateOpcode(value, false);\n+\n+        return this;\n+    }\n+\n+    /**\n+      *  Return the string value of this constant, or null if not set.\n+     */\n+    public String getStringValue() {\n+        return (String) getValue();\n+    }\n+\n+    /**\n+      *  Return the int value of this constant, or 0 if not set.\n+     */\n+    public int getIntValue() {\n+        Object value = getValue();\n+\n+        return (value == null) ? 0 : ((Number) value).intValue();\n+    }\n+\n+    /**\n+      *  Return the long value of this constant, or 0 if not set.\n+     */\n+    public long getLongValue() {\n+        Object value = getValue();\n+\n+        return (value == null) ? 0L : ((Number) value).longValue();\n+    }\n+\n+    /**\n+      *  Return the float value of this constant, or 0 if not set.\n+     */\n+    public float getFloatValue() {\n+        Object value = getValue();\n+\n+        return (value == null) ? 0F : ((Number) value).floatValue();\n+    }\n+\n+    /**\n+      *  Return the double value of this constant, or 0 if not set.\n+     */\n+    public double getDoubleValue() {\n+        Object value = getValue();\n+\n+        return (value == null) ? 0D : ((Number) value).doubleValue();\n+    }\n+\n+    /**\n+      *  Return the class value of this constant, or null if not set.\n+     */\n+    public String getClassNameValue() {\n+        return (String) getValue();\n+    }\n+\n+    /**\n+     *  Set this constant to null.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public ConstantInstruction setNull() {\n+        calculateOpcode(null, false);\n+\n+        return this;\n+    }\n+\n+    /**\n+      *  Set the value of this constant.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public ConstantInstruction setValue(String value) {\n+        calculateOpcode(value, false);\n+\n+        return this;\n+    }\n+\n+    /**\n+      *  Set the value of this constant.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public ConstantInstruction setValue(Class value) {\n+        calculateOpcode(value, false);\n+\n+        return this;\n+    }\n+\n+    /**\n+      *  Set the value of this constant.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public ConstantInstruction setValue(BCClass value) {\n+        calculateOpcode(value, false);\n+\n+        return this;\n+    }\n+\n+    /**\n+      *  Set the value of this constant.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public ConstantInstruction setValue(int value) {\n+        calculateOpcode(Numbers.valueOf(value), false);\n+\n+        return this;\n+    }\n+\n+    /**\n+      *  Set the value of this constant.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public ConstantInstruction setValue(long value) {\n+        calculateOpcode(Numbers.valueOf(value), false);\n+\n+        return this;\n+    }\n+\n+    /**\n+      *  Set the value of this constant.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public ConstantInstruction setValue(float value) {\n+        calculateOpcode(new Float(value), false);\n+\n+        return this;\n+    }\n+\n+    /**\n+      *  Set the value of this constant.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public ConstantInstruction setValue(double value) {\n+        calculateOpcode(new Double(value), false);\n+\n+        return this;\n+    }\n+\n+    /**\n+     *  Set the value of this constant; note that this type is converted\n+     *  to int.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public ConstantInstruction setValue(boolean value) {\n+        return setValue((value) ? 1 : 0);\n+    }\n+\n+    /**\n+     *  Set the value of this constant; note that this type is converted\n+     *  to int.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public ConstantInstruction setValue(short value) {\n+        return setValue((int) value);\n+    }\n+\n+    /**\n+     *  Set the value of this constant; note that this type is converted\n+     *  to int.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public ConstantInstruction setValue(char value) {\n+        return setValue((int) value);\n+    }\n+\n+    /**\n+     *  ConstantInstructions are equal if the const they reference is the same,\n+     *  or if the const of either is unset.\n+     */\n+    public boolean equalsInstruction(Instruction other) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (!(other instanceof ConstantInstruction)) {\n+            return false;\n+        }\n+\n+        Object value = getValue();\n+        Object otherValue = ((ConstantInstruction) other).getValue();\n+\n+        return (value == null) || (otherValue == null) ||\n+        value.equals(otherValue);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterConstantInstruction(this);\n+        visit.exitConstantInstruction(this);\n+    }\n+\n+    void read(Instruction orig) {\n+        super.read(orig);\n+\n+        ConstantInstruction ci = (ConstantInstruction) orig;\n+        calculateOpcode(ci.getValue(), ci.getOpcode() == Constants.LDCW);\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        super.read(in);\n+\n+        switch (getOpcode()) {\n+        case Constants.BIPUSH:\n+        case Constants.LDC:\n+            _arg = in.readUnsignedByte();\n+\n+            break;\n+\n+        case Constants.SIPUSH:\n+        case Constants.LDCW:\n+        case Constants.LDC2W:\n+            _arg = in.readUnsignedShort();\n+        }\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        super.write(out);\n+\n+        switch (getOpcode()) {\n+        case Constants.BIPUSH:\n+        case Constants.LDC:\n+            out.writeByte(_arg);\n+\n+            break;\n+\n+        case Constants.SIPUSH:\n+        case Constants.LDCW:\n+        case Constants.LDC2W:\n+            out.writeShort(_arg);\n+\n+            break;\n+        }\n+    }\n+\n+    private void calculateOpcode(Object value, boolean wide) {\n+        _arg = -1;\n+\n+        if (value == null) {\n+            setOpcode(Constants.ACONSTNULL);\n+        } else if (value instanceof Float) {\n+            float floatVal = ((Float) value).floatValue();\n+\n+            if ((floatVal == 0) || (floatVal == 1) || (floatVal == 2)) {\n+                setOpcode(Constants.FCONST0 + (int) floatVal);\n+            } else {\n+                _arg = getPool().findFloatEntry((float) floatVal, true);\n+                setOpcode(((_arg > 255) || wide) ? Constants.LDCW : Constants.LDC);\n+            }\n+        } else if (value instanceof Long) {\n+            long longVal = ((Long) value).longValue();\n+\n+            if ((longVal == 0) || (longVal == 1)) {\n+                setOpcode(Constants.LCONST0 + (int) longVal);\n+            } else {\n+                _arg = getPool().findLongEntry(longVal, true);\n+                setOpcode(Constants.LDC2W);\n+            }\n+        } else if (value instanceof Double) {\n+            double doubleVal = ((Double) value).doubleValue();\n+\n+            if ((doubleVal == 0) || (doubleVal == 1)) {\n+                setOpcode(Constants.DCONST0 + (int) doubleVal);\n+            } else {\n+                _arg = getPool().findDoubleEntry(doubleVal, true);\n+                setOpcode(Constants.LDC2W);\n+            }\n+        } else if (value instanceof Integer) {\n+            int intVal = ((Integer) value).intValue();\n+\n+            if ((intVal >= -1) && (intVal <= 5)) {\n+                setOpcode(Constants.ICONST0 + intVal);\n+            } else if ((intVal >= -(2 << 6)) && (intVal < (2 << 6))) {\n+                setOpcode(Constants.BIPUSH);\n+                _arg = intVal;\n+            } else if ((intVal >= -(2 << 14)) && (intVal < (2 << 14))) {\n+                setOpcode(Constants.SIPUSH);\n+                _arg = intVal;\n+            } else {\n+                _arg = getPool().findIntEntry(intVal, true);\n+                setOpcode(((_arg > 255) || wide) ? Constants.LDCW : Constants.LDC);\n+            }\n+        } else if (value instanceof String) {\n+            _arg = getPool().findStringEntry((String) value, true);\n+            setOpcode(((_arg > 255) || wide) ? Constants.LDCW : Constants.LDC);\n+        } else if (value instanceof Class) {\n+            String name = getProject().getNameCache()\n+                              .getInternalForm(((Class) value).getName(), false);\n+            _arg = getPool().findClassEntry(name, true);\n+            setOpcode(Constants.LDCW);\n+        } else if (value instanceof BCClass) {\n+            BCClass bc = (BCClass) value;\n+            ClassEntry entry = (ClassEntry) bc.getPool().getEntry(bc.getIndex());\n+\n+            if (bc.getPool() == getPool()) {\n+                _arg = getPool().indexOf(entry);\n+            } else {\n+                _arg = getPool()\n+                           .findClassEntry((String) entry.getConstant(), true);\n+            }\n+\n+            setOpcode(Constants.LDCW);\n+        } else {\n+            throw new IllegalArgumentException(String.valueOf(value));\n+        }\n+    }\n+}"},{"sha":"e1283bac5374f904867ffd579eab8feeefd1a6c7","filename":"serp/src/main/java/serp/bytecode/ConstantValue.java","status":"added","additions":263,"deletions":0,"changes":263,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ConstantValue.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ConstantValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ConstantValue.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+\n+/**\n+ *  <p>A constant value for a member field.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class ConstantValue extends Attribute {\n+    int _valueIndex = 0;\n+\n+    ConstantValue(int nameIndex, Attributes owner) {\n+        super(nameIndex, owner);\n+    }\n+\n+    int getLength() {\n+        return 2;\n+    }\n+\n+    /**\n+     *  Return the owning field.\n+      */\n+    public BCField getField() {\n+        return (BCField) getOwner();\n+    }\n+\n+    /**\n+     *  Return the {@link ConstantPool} index of the {@link ConstantEntry}\n+     *  holding the value of this constant.  Defaults to 0.\n+     */\n+    public int getValueIndex() {\n+        return _valueIndex;\n+    }\n+\n+    /**\n+     *  Set the {@link ConstantPool} of the {@link ConstantEntry}\n+     *  holding the value of this constant.\n+     */\n+    public void setValueIndex(int valueIndex) {\n+        _valueIndex = valueIndex;\n+    }\n+\n+    /**\n+     *  Return the type of constant this attribute represents, or null if\n+     *  not set.\n+     */\n+    public String getTypeName() {\n+        Class type = getType();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return type.getName();\n+    }\n+\n+    /**\n+     *  Return the type of constant this attribute represents (String.class,\n+     *  int.class, etc), or null if not set.\n+     */\n+    public Class getType() {\n+        Object value = getValue();\n+\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        Class type = value.getClass();\n+\n+        if (type == Integer.class) {\n+            return int.class;\n+        }\n+\n+        if (type == Float.class) {\n+            return float.class;\n+        }\n+\n+        if (type == Double.class) {\n+            return double.class;\n+        }\n+\n+        if (type == Long.class) {\n+            return long.class;\n+        }\n+\n+        return String.class;\n+    }\n+\n+    /**\n+     *  Return the bytecode for the type of constant this attribute\n+     *  represents.\n+     */\n+    public BCClass getTypeBC() {\n+        return getProject().loadClass(getType());\n+    }\n+\n+    /**\n+     *  Return the value of this constant as an Object of the appropriate\n+     *  type (String, Integer, Double, etc), or null if not set.\n+     */\n+    public Object getValue() {\n+        if (_valueIndex <= 0) {\n+            return null;\n+        }\n+\n+        return ((ConstantEntry) getPool().getEntry(_valueIndex)).getConstant();\n+    }\n+\n+    /**\n+     *  Set the value of this constant using the appropriate wrapper Object\n+     *  type (String, Integer, Double, etc).  Types that are not directly\n+     *  supported will be converted accordingly if possible.\n+     */\n+    public void setValue(Object value) {\n+        Class type = value.getClass();\n+\n+        if (type == Boolean.class) {\n+            setIntValue((((Boolean) value).booleanValue()) ? 1 : 0);\n+        } else if (type == Character.class) {\n+            setIntValue((int) ((Character) value).charValue());\n+        } else if ((type == Byte.class) || (type == Integer.class) ||\n+                (type == Short.class)) {\n+            setIntValue(((Number) value).intValue());\n+        } else if (type == Float.class) {\n+            setFloatValue(((Number) value).floatValue());\n+        } else if (type == Double.class) {\n+            setDoubleValue(((Number) value).doubleValue());\n+        } else if (type == Long.class) {\n+            setLongValue(((Number) value).longValue());\n+        } else {\n+            setStringValue(value.toString());\n+        }\n+    }\n+\n+    /**\n+     *  Get the value of this int constant, or 0 if not set.\n+     */\n+    public int getIntValue() {\n+        if (getValueIndex() <= 0) {\n+            return 0;\n+        }\n+\n+        return ((IntEntry) getPool().getEntry(getValueIndex())).getValue();\n+    }\n+\n+    /**\n+     *  Set the value of this int constant.\n+     */\n+    public void setIntValue(int value) {\n+        setValueIndex(getPool().findIntEntry(value, true));\n+    }\n+\n+    /**\n+     *  Get the value of this float constant.\n+     */\n+    public float getFloatValue() {\n+        if (getValueIndex() <= 0) {\n+            return 0F;\n+        }\n+\n+        return ((FloatEntry) getPool().getEntry(getValueIndex())).getValue();\n+    }\n+\n+    /**\n+     *  Set the value of this float constant.\n+     */\n+    public void setFloatValue(float value) {\n+        setValueIndex(getPool().findFloatEntry(value, true));\n+    }\n+\n+    /**\n+     *  Get the value of this double constant.\n+     */\n+    public double getDoubleValue() {\n+        if (getValueIndex() <= 0) {\n+            return 0D;\n+        }\n+\n+        return ((DoubleEntry) getPool().getEntry(getValueIndex())).getValue();\n+    }\n+\n+    /**\n+     *  Set the value of this double constant.\n+     */\n+    public void setDoubleValue(double value) {\n+        setValueIndex(getPool().findDoubleEntry(value, true));\n+    }\n+\n+    /**\n+     *  Get the value of this long constant.\n+     */\n+    public long getLongValue() {\n+        if (getValueIndex() <= 0) {\n+            return 0L;\n+        }\n+\n+        return ((LongEntry) getPool().getEntry(getValueIndex())).getValue();\n+    }\n+\n+    /**\n+     *  Set the value of this long constant.\n+     */\n+    public void setLongValue(long value) {\n+        setValueIndex(getPool().findLongEntry(value, true));\n+    }\n+\n+    /**\n+     *  Get the value of this string constant.\n+     */\n+    public String getStringValue() {\n+        if (getValueIndex() <= 0) {\n+            return null;\n+        }\n+\n+        return ((StringEntry) getPool().getEntry(getValueIndex())).getStringEntry()\n+                .getValue();\n+    }\n+\n+    /**\n+     *  Set the value of this string constant.\n+     */\n+    public void setStringValue(String value) {\n+        setValueIndex(getPool().findStringEntry(value, true));\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterConstantValue(this);\n+        visit.exitConstantValue(this);\n+    }\n+\n+    void read(Attribute other) {\n+        setValue(((ConstantValue) other).getValue());\n+    }\n+\n+    void read(DataInput in, int length) throws IOException {\n+        setValueIndex(in.readUnsignedShort());\n+    }\n+\n+    void write(DataOutput out, int length) throws IOException {\n+        out.writeShort(getValueIndex());\n+    }\n+}"},{"sha":"d78a191ab7a21ba802c04f47e7ebdfc5defe21c3","filename":"serp/src/main/java/serp/bytecode/Constants.java","status":"added","additions":324,"deletions":0,"changes":324,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Constants.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Constants.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Constants.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,324 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+\n+/**\n+ *  <p>Interface to track constants used in bytecode.  Entities can access these\n+ *  constants using the static <code>Constants.</code> field prefix,\n+ *  or implement this interface themselves to conveniently import the\n+ *  constants into their own namespace.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public interface Constants {\n+    // class magic number\n+    public static final int VALID_MAGIC = 0xcafebabe;\n+\n+    // standard major, minor versions\n+    public static final int MAJOR_VERSION = 45;\n+    public static final int MINOR_VERSION = 3;\n+\n+    // access constants for classes, fields, methods\n+    public static final int ACCESS_PUBLIC = 0x0001;\n+    public static final int ACCESS_PRIVATE = 0x0002;\n+    public static final int ACCESS_PROTECTED = 0x0004;\n+    public static final int ACCESS_STATIC = 0x0008;\n+    public static final int ACCESS_FINAL = 0x0010;\n+    public static final int ACCESS_SUPER = 0x0020;\n+    public static final int ACCESS_SYNCHRONIZED = 0x0020;\n+    public static final int ACCESS_VOLATILE = 0x0040;\n+    public static final int ACCESS_TRANSIENT = 0x0080;\n+    public static final int ACCESS_NATIVE = 0x0100;\n+    public static final int ACCESS_INTERFACE = 0x0200;\n+    public static final int ACCESS_ABSTRACT = 0x0400;\n+    public static final int ACCESS_STRICT = 0x0800;\n+\n+    // attribute types the compiler must support\n+    public static final String ATTR_CODE = \"Code\";\n+    public static final String ATTR_CONST = \"ConstantValue\";\n+    public static final String ATTR_DEPRECATED = \"Deprecated\";\n+    public static final String ATTR_EXCEPTIONS = \"Exceptions\";\n+    public static final String ATTR_INNERCLASS = \"InnerClasses\";\n+    public static final String ATTR_LINENUMBERS = \"LineNumberTable\";\n+    public static final String ATTR_LOCALS = \"LocalVariableTable\";\n+    public static final String ATTR_LOCAL_TYPES = \"LocalVariableTypeTable\";\n+    public static final String ATTR_SOURCE = \"SourceFile\";\n+    public static final String ATTR_SYNTHETIC = \"Synthetic\";\n+    public static final String ATTR_UNKNOWN = \"Unknown\";\n+\n+    // opcodes\n+    public static final int NOP = 0;\n+    public static final int ACONSTNULL = 1;\n+    public static final int ICONSTM1 = 2;\n+    public static final int ICONST0 = 3;\n+    public static final int ICONST1 = 4;\n+    public static final int ICONST2 = 5;\n+    public static final int ICONST3 = 6;\n+    public static final int ICONST4 = 7;\n+    public static final int ICONST5 = 8;\n+    public static final int LCONST0 = 9;\n+    public static final int LCONST1 = 10;\n+    public static final int FCONST0 = 11;\n+    public static final int FCONST1 = 12;\n+    public static final int FCONST2 = 13;\n+    public static final int DCONST0 = 14;\n+    public static final int DCONST1 = 15;\n+    public static final int BIPUSH = 16;\n+    public static final int SIPUSH = 17;\n+    public static final int LDC = 18;\n+    public static final int LDCW = 19;\n+    public static final int LDC2W = 20;\n+    public static final int ILOAD = 21;\n+    public static final int LLOAD = 22;\n+    public static final int FLOAD = 23;\n+    public static final int DLOAD = 24;\n+    public static final int ALOAD = 25;\n+    public static final int ILOAD0 = 26;\n+    public static final int ILOAD1 = 27;\n+    public static final int ILOAD2 = 28;\n+    public static final int ILOAD3 = 29;\n+    public static final int LLOAD0 = 30;\n+    public static final int LLOAD1 = 31;\n+    public static final int LLOAD2 = 32;\n+    public static final int LLOAD3 = 33;\n+    public static final int FLOAD0 = 34;\n+    public static final int FLOAD1 = 35;\n+    public static final int FLOAD2 = 36;\n+    public static final int FLOAD3 = 37;\n+    public static final int DLOAD0 = 38;\n+    public static final int DLOAD1 = 39;\n+    public static final int DLOAD2 = 40;\n+    public static final int DLOAD3 = 41;\n+    public static final int ALOAD0 = 42;\n+    public static final int ALOAD1 = 43;\n+    public static final int ALOAD2 = 44;\n+    public static final int ALOAD3 = 45;\n+    public static final int IALOAD = 46;\n+    public static final int LALOAD = 47;\n+    public static final int FALOAD = 48;\n+    public static final int DALOAD = 49;\n+    public static final int AALOAD = 50;\n+    public static final int BALOAD = 51;\n+    public static final int CALOAD = 52;\n+    public static final int SALOAD = 53;\n+    public static final int ISTORE = 54;\n+    public static final int LSTORE = 55;\n+    public static final int FSTORE = 56;\n+    public static final int DSTORE = 57;\n+    public static final int ASTORE = 58;\n+    public static final int ISTORE0 = 59;\n+    public static final int ISTORE1 = 60;\n+    public static final int ISTORE2 = 61;\n+    public static final int ISTORE3 = 62;\n+    public static final int LSTORE0 = 63;\n+    public static final int LSTORE1 = 64;\n+    public static final int LSTORE2 = 65;\n+    public static final int LSTORE3 = 66;\n+    public static final int FSTORE0 = 67;\n+    public static final int FSTORE1 = 68;\n+    public static final int FSTORE2 = 69;\n+    public static final int FSTORE3 = 70;\n+    public static final int DSTORE0 = 71;\n+    public static final int DSTORE1 = 72;\n+    public static final int DSTORE2 = 73;\n+    public static final int DSTORE3 = 74;\n+    public static final int ASTORE0 = 75;\n+    public static final int ASTORE1 = 76;\n+    public static final int ASTORE2 = 77;\n+    public static final int ASTORE3 = 78;\n+    public static final int IASTORE = 79;\n+    public static final int LASTORE = 80;\n+    public static final int FASTORE = 81;\n+    public static final int DASTORE = 82;\n+    public static final int AASTORE = 83;\n+    public static final int BASTORE = 84;\n+    public static final int CASTORE = 85;\n+    public static final int SASTORE = 86;\n+    public static final int POP = 87;\n+    public static final int POP2 = 88;\n+    public static final int DUP = 89;\n+    public static final int DUPX1 = 90;\n+    public static final int DUPX2 = 91;\n+    public static final int DUP2 = 92;\n+    public static final int DUP2X1 = 93;\n+    public static final int DUP2X2 = 94;\n+    public static final int SWAP = 95;\n+    public static final int IADD = 96;\n+    public static final int LADD = 97;\n+    public static final int FADD = 98;\n+    public static final int DADD = 99;\n+    public static final int ISUB = 100;\n+    public static final int LSUB = 101;\n+    public static final int FSUB = 102;\n+    public static final int DSUB = 103;\n+    public static final int IMUL = 104;\n+    public static final int LMUL = 105;\n+    public static final int FMUL = 106;\n+    public static final int DMUL = 107;\n+    public static final int IDIV = 108;\n+    public static final int LDIV = 109;\n+    public static final int FDIV = 110;\n+    public static final int DDIV = 111;\n+    public static final int IREM = 112;\n+    public static final int LREM = 113;\n+    public static final int FREM = 114;\n+    public static final int DREM = 115;\n+    public static final int INEG = 116;\n+    public static final int LNEG = 117;\n+    public static final int FNEG = 118;\n+    public static final int DNEG = 119;\n+    public static final int ISHL = 120;\n+    public static final int LSHL = 121;\n+    public static final int ISHR = 122;\n+    public static final int LSHR = 123;\n+    public static final int IUSHR = 124;\n+    public static final int LUSHR = 125;\n+    public static final int IAND = 126;\n+    public static final int LAND = 127;\n+    public static final int IOR = 128;\n+    public static final int LOR = 129;\n+    public static final int IXOR = 130;\n+    public static final int LXOR = 131;\n+    public static final int IINC = 132;\n+    public static final int I2L = 133;\n+    public static final int I2F = 134;\n+    public static final int I2D = 135;\n+    public static final int L2I = 136;\n+    public static final int L2F = 137;\n+    public static final int L2D = 138;\n+    public static final int F2I = 139;\n+    public static final int F2L = 140;\n+    public static final int F2D = 141;\n+    public static final int D2I = 142;\n+    public static final int D2L = 143;\n+    public static final int D2F = 144;\n+    public static final int I2B = 145;\n+    public static final int I2C = 146;\n+    public static final int I2S = 147;\n+    public static final int LCMP = 148;\n+    public static final int FCMPL = 149;\n+    public static final int FCMPG = 150;\n+    public static final int DCMPL = 151;\n+    public static final int DCMPG = 152;\n+    public static final int IFEQ = 153;\n+    public static final int IFNE = 154;\n+    public static final int IFLT = 155;\n+    public static final int IFGE = 156;\n+    public static final int IFGT = 157;\n+    public static final int IFLE = 158;\n+    public static final int IFICMPEQ = 159;\n+    public static final int IFICMPNE = 160;\n+    public static final int IFICMPLT = 161;\n+    public static final int IFICMPGE = 162;\n+    public static final int IFICMPGT = 163;\n+    public static final int IFICMPLE = 164;\n+    public static final int IFACMPEQ = 165;\n+    public static final int IFACMPNE = 166;\n+    public static final int GOTO = 167;\n+    public static final int JSR = 168;\n+    public static final int RET = 169;\n+    public static final int TABLESWITCH = 170;\n+    public static final int LOOKUPSWITCH = 171;\n+    public static final int IRETURN = 172;\n+    public static final int LRETURN = 173;\n+    public static final int FRETURN = 174;\n+    public static final int DRETURN = 175;\n+    public static final int ARETURN = 176;\n+    public static final int RETURN = 177;\n+    public static final int GETSTATIC = 178;\n+    public static final int PUTSTATIC = 179;\n+    public static final int GETFIELD = 180;\n+    public static final int PUTFIELD = 181;\n+    public static final int INVOKEVIRTUAL = 182;\n+    public static final int INVOKESPECIAL = 183;\n+    public static final int INVOKESTATIC = 184;\n+    public static final int INVOKEINTERFACE = 185;\n+    public static final int NEW = 187;\n+    public static final int NEWARRAY = 188;\n+    public static final int ANEWARRAY = 189;\n+    public static final int ARRAYLENGTH = 190;\n+    public static final int ATHROW = 191;\n+    public static final int CHECKCAST = 192;\n+    public static final int INSTANCEOF = 193;\n+    public static final int MONITORENTER = 194;\n+    public static final int MONITOREXIT = 195;\n+    public static final int WIDE = 196;\n+    public static final int MULTIANEWARRAY = 197;\n+    public static final int IFNULL = 198;\n+    public static final int IFNONNULL = 199;\n+    public static final int GOTOW = 200;\n+    public static final int JSRW = 201;\n+\n+    // array types\n+    public static final int ARRAY_BOOLEAN = 4;\n+    public static final int ARRAY_CHAR = 5;\n+    public static final int ARRAY_FLOAT = 6;\n+    public static final int ARRAY_DOUBLE = 7;\n+    public static final int ARRAY_BYTE = 8;\n+    public static final int ARRAY_SHORT = 9;\n+    public static final int ARRAY_INT = 10;\n+    public static final int ARRAY_LONG = 11;\n+\n+    // math operations\n+    public static final int MATH_ADD = IADD;\n+    public static final int MATH_SUB = ISUB;\n+    public static final int MATH_MUL = IMUL;\n+    public static final int MATH_DIV = IDIV;\n+    public static final int MATH_REM = IREM;\n+    public static final int MATH_NEG = INEG;\n+    public static final int MATH_SHL = ISHL;\n+    public static final int MATH_SHR = ISHR;\n+    public static final int MATH_USHR = IUSHR;\n+    public static final int MATH_AND = IAND;\n+    public static final int MATH_OR = IOR;\n+    public static final int MATH_XOR = IXOR;\n+\n+    // human-readable opcode names\n+    public static final String[] OPCODE_NAMES = new String[] {\n+            \"nop\", \"aconstnull\", \"iconstm1\", \"iconst0\", \"iconst1\", \"iconst2\",\n+            \"iconst3\", \"iconst4\", \"iconst5\", \"lconst0\", \"lconst1\", \"fconst0\",\n+            \"fconst1\", \"fconst2\", \"dconst0\", \"dconst1\", \"bipush\", \"sipush\",\n+            \"ldc\", \"ldcw\", \"ldc2w\", \"iload\", \"lload\", \"fload\", \"dload\", \"aload\",\n+            \"iload0\", \"iload1\", \"iload2\", \"iload3\", \"lload0\", \"lload1\", \"lload2\",\n+            \"lload3\", \"fload0\", \"fload1\", \"fload2\", \"fload3\", \"dload0\", \"dload1\",\n+            \"dload2\", \"dload3\", \"aload0\", \"aload1\", \"aload2\", \"aload3\", \"iaload\",\n+            \"laload\", \"faload\", \"daload\", \"aaload\", \"baload\", \"caload\", \"saload\",\n+            \"istore\", \"lstore\", \"fstore\", \"dstore\", \"astore\", \"istore0\",\n+            \"istore1\", \"istore2\", \"istore3\", \"lstore0\", \"lstore1\", \"lstore2\",\n+            \"lstore3\", \"fstore0\", \"fstore1\", \"fstore2\", \"fstore3\", \"dstore0\",\n+            \"dstore1\", \"dstore2\", \"dstore3\", \"astore0\", \"astore1\", \"astore2\",\n+            \"astore3\", \"iastore\", \"lastore\", \"fastore\", \"dastore\", \"aastore\",\n+            \"bastore\", \"castore\", \"sastore\", \"pop\", \"pop2\", \"dup\", \"dupx1\",\n+            \"dupx2\", \"dup2\", \"dup2x1\", \"dup2x2\", \"swap\", \"iadd\", \"ladd\", \"fadd\",\n+            \"dadd\", \"isub\", \"lsub\", \"fsub\", \"dsub\", \"imul\", \"lmul\", \"fmul\",\n+            \"dmul\", \"idiv\", \"ldiv\", \"fdiv\", \"ddiv\", \"irem\", \"lrem\", \"frem\",\n+            \"drem\", \"ineg\", \"lneg\", \"fneg\", \"dneg\", \"ishl\", \"lshl\", \"ishr\",\n+            \"lshr\", \"iushr\", \"lushr\", \"iand\", \"land\", \"ior\", \"lor\", \"ixor\",\n+            \"lxor\", \"iinc\", \"i2l\", \"i2f\", \"i2d\", \"l2i\", \"l2f\", \"l2d\", \"f2i\",\n+            \"f2l\", \"f2d\", \"d2i\", \"d2l\", \"d2f\", \"i2b\", \"i2c\", \"i2s\", \"lcmp\",\n+            \"fcmpl\", \"fcmpg\", \"dcmpl\", \"dcmpg\", \"ifeq\", \"ifne\", \"iflt\", \"ifge\",\n+            \"ifgt\", \"ifle\", \"ificmpeq\", \"ificmpne\", \"ificmplt\", \"ificmpge\",\n+            \"ificmpgt\", \"ificmple\", \"ifacmpeq\", \"ifacmpne\", \"goto\", \"jsr\", \"ret\",\n+            \"tableswitch\", \"lookupswitch\", \"ireturn\", \"lreturn\", \"freturn\",\n+            \"dreturn\", \"areturn\", \"return\", \"getstatic\", \"putstatic\", \"getfield\",\n+            \"putfield\", \"invokevirtual\", \"invokespecial\", \"invokestatic\",\n+            \"invokeinterface\", \"??\", \"new\", \"newarray\", \"anewarray\",\n+            \"arraylength\", \"athrow\", \"checkcast\", \"instanceof\", \"monitorenter\",\n+            \"monitorexit\", \"wide\", \"multianewarray\", \"ifnull\", \"ifnonnull\",\n+            \"gotow\", \"jsrw\",\n+        };\n+}"},{"sha":"e4e137400a8d4068d80bf45353b0c8c491fba9ce","filename":"serp/src/main/java/serp/bytecode/ConvertInstruction.java","status":"added","additions":440,"deletions":0,"changes":440,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ConvertInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ConvertInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ConvertInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,440 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import serp.util.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>A conversion opcode such as <code>i2l, f2i</code>, etc.\n+ *  Changing the types of the instruction will automatically\n+ *  update the underlying opcode.  Converting from one type to the same\n+ *  type will result in a <code>nop</code>.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class ConvertInstruction extends TypedInstruction {\n+    private static final Class[][] _mappings = new Class[][] {\n+            { boolean.class, int.class },\n+            { void.class, int.class },\n+            { Object.class, int.class },\n+        };\n+    private static final Class[][] _fromMappings = new Class[][] {\n+            { boolean.class, int.class },\n+            { void.class, int.class },\n+            { Object.class, int.class },\n+            { byte.class, int.class },\n+            { char.class, int.class },\n+            { short.class, int.class },\n+        };\n+    String _toType = null;\n+    String _fromType = null;\n+\n+    ConvertInstruction(Code owner) {\n+        super(owner);\n+    }\n+\n+    ConvertInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    public int getLogicalStackChange() {\n+        return 0;\n+    }\n+\n+    public int getStackChange() {\n+        switch (getOpcode()) {\n+        case Constants.I2L:\n+        case Constants.I2D:\n+        case Constants.F2L:\n+        case Constants.F2D:\n+            return 1;\n+\n+        case Constants.L2I:\n+        case Constants.L2F:\n+        case Constants.D2I:\n+        case Constants.D2F:\n+            return -1;\n+\n+        default:\n+            return 0;\n+        }\n+    }\n+\n+    public String getTypeName() {\n+        switch (getOpcode()) {\n+        case Constants.L2I:\n+        case Constants.F2I:\n+        case Constants.D2I:\n+            return int.class.getName();\n+\n+        case Constants.I2L:\n+        case Constants.F2L:\n+        case Constants.D2L:\n+            return long.class.getName();\n+\n+        case Constants.I2F:\n+        case Constants.L2F:\n+        case Constants.D2F:\n+            return float.class.getName();\n+\n+        case Constants.I2D:\n+        case Constants.L2D:\n+        case Constants.F2D:\n+            return double.class.getName();\n+\n+        case Constants.I2B:\n+            return byte.class.getName();\n+\n+        case Constants.I2C:\n+            return char.class.getName();\n+\n+        case Constants.I2S:\n+            return short.class.getName();\n+\n+        default:\n+            return _toType;\n+        }\n+    }\n+\n+    public TypedInstruction setType(String type) {\n+        String toType = mapType(type, _mappings, true);\n+        String fromType = getFromTypeName();\n+\n+        // if no valid opcode, remember current types in case they reset one\n+        // to create a valid opcode\n+        if ((toType == null) || (fromType == null) || toType.equals(fromType)) {\n+            _toType = toType;\n+            _fromType = fromType;\n+\n+            return (TypedInstruction) setOpcode(Constants.NOP);\n+        }\n+\n+        // ok, valid conversion possible, forget saved types\n+        _toType = null;\n+        _fromType = null;\n+\n+        char to = toType.charAt(0);\n+        char from = fromType.charAt(0);\n+\n+        switch (to) {\n+        case 'i':\n+\n+            switch (from) {\n+            case 'l':\n+                return (TypedInstruction) setOpcode(Constants.L2I);\n+\n+            case 'f':\n+                return (TypedInstruction) setOpcode(Constants.F2I);\n+\n+            case 'd':\n+                return (TypedInstruction) setOpcode(Constants.D2I);\n+            }\n+\n+        case 'l':\n+\n+            switch (from) {\n+            case 'i':\n+                return (TypedInstruction) setOpcode(Constants.I2L);\n+\n+            case 'f':\n+                return (TypedInstruction) setOpcode(Constants.F2L);\n+\n+            case 'd':\n+                return (TypedInstruction) setOpcode(Constants.D2L);\n+            }\n+\n+        case 'f':\n+\n+            switch (from) {\n+            case 'i':\n+                return (TypedInstruction) setOpcode(Constants.I2F);\n+\n+            case 'l':\n+                return (TypedInstruction) setOpcode(Constants.L2F);\n+\n+            case 'd':\n+                return (TypedInstruction) setOpcode(Constants.D2F);\n+            }\n+\n+        case 'd':\n+\n+            switch (from) {\n+            case 'i':\n+                return (TypedInstruction) setOpcode(Constants.I2D);\n+\n+            case 'l':\n+                return (TypedInstruction) setOpcode(Constants.L2D);\n+\n+            case 'f':\n+                return (TypedInstruction) setOpcode(Constants.F2D);\n+            }\n+\n+        case 'b':\n+\n+            if (from == 'i') {\n+                return (TypedInstruction) setOpcode(Constants.I2B);\n+            }\n+\n+        case 'C':\n+\n+            if (from == 'i') {\n+                return (TypedInstruction) setOpcode(Constants.I2C);\n+            }\n+\n+        case 'S':\n+\n+            if (from == 'i') {\n+                return (TypedInstruction) setOpcode(Constants.I2S);\n+            }\n+\n+        default:\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    /**\n+     *  Return the name of the type being converted from.\n+     *  If neither type has been set, this method will return null.\n+     */\n+    public String getFromTypeName() {\n+        switch (getOpcode()) {\n+        case Constants.I2L:\n+        case Constants.I2F:\n+        case Constants.I2D:\n+        case Constants.I2B:\n+        case Constants.I2S:\n+        case Constants.I2C:\n+            return int.class.getName();\n+\n+        case Constants.L2I:\n+        case Constants.L2F:\n+        case Constants.L2D:\n+            return long.class.getName();\n+\n+        case Constants.F2I:\n+        case Constants.F2L:\n+        case Constants.F2D:\n+            return float.class.getName();\n+\n+        case Constants.D2I:\n+        case Constants.D2L:\n+        case Constants.D2F:\n+            return double.class.getName();\n+\n+        default:\n+            return _fromType;\n+        }\n+    }\n+\n+    /**\n+     *  Return the {@link Class} of the type being converted from.\n+     *  If neither type has been set, this method will return null.\n+     */\n+    public Class getFromType() {\n+        String type = getFromTypeName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return Strings.toClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Return the bytecode of the type being converted from.\n+     *  If neither type has been set, this method will return null.\n+     */\n+    public BCClass getFromTypeBC() {\n+        String type = getFromTypeName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return getProject().loadClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Set the type being converted from.  Types that have no direct\n+     *  support will be converted accordingly.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public ConvertInstruction setFromType(String type) {\n+        String fromType = mapType(type, _fromMappings, true);\n+        String toType = getTypeName();\n+\n+        // if no valid opcode, remember current types in case they reset one\n+        // to create a valid opcode\n+        if ((toType == null) || (fromType == null) || toType.equals(fromType)) {\n+            _toType = toType;\n+            _fromType = fromType;\n+\n+            return (ConvertInstruction) setOpcode(Constants.NOP);\n+        }\n+\n+        // ok, valid conversion possible, forget saved types\n+        _toType = null;\n+        _fromType = null;\n+\n+        char to = toType.charAt(0);\n+        char from = fromType.charAt(0);\n+\n+        switch (from) {\n+        case 'i':\n+\n+            switch (to) {\n+            case 'l':\n+                return (ConvertInstruction) setOpcode(Constants.I2L);\n+\n+            case 'f':\n+                return (ConvertInstruction) setOpcode(Constants.I2F);\n+\n+            case 'd':\n+                return (ConvertInstruction) setOpcode(Constants.I2D);\n+\n+            case 'b':\n+                return (ConvertInstruction) setOpcode(Constants.I2B);\n+\n+            case 'c':\n+                return (ConvertInstruction) setOpcode(Constants.I2C);\n+\n+            case 's':\n+                return (ConvertInstruction) setOpcode(Constants.I2S);\n+            }\n+\n+        case 'l':\n+\n+            switch (to) {\n+            case 'i':\n+                return (ConvertInstruction) setOpcode(Constants.L2I);\n+\n+            case 'f':\n+                return (ConvertInstruction) setOpcode(Constants.L2F);\n+\n+            case 'd':\n+                return (ConvertInstruction) setOpcode(Constants.L2D);\n+            }\n+\n+        case 'f':\n+\n+            switch (to) {\n+            case 'i':\n+                return (ConvertInstruction) setOpcode(Constants.F2I);\n+\n+            case 'l':\n+                return (ConvertInstruction) setOpcode(Constants.F2L);\n+\n+            case 'd':\n+                return (ConvertInstruction) setOpcode(Constants.F2D);\n+            }\n+\n+        case 'd':\n+\n+            switch (to) {\n+            case 'i':\n+                return (ConvertInstruction) setOpcode(Constants.D2I);\n+\n+            case 'l':\n+                return (ConvertInstruction) setOpcode(Constants.D2L);\n+\n+            case 'f':\n+                return (ConvertInstruction) setOpcode(Constants.D2F);\n+            }\n+\n+        default:\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    /**\n+     *  Set the type being converted from.  Types that have no direct\n+     *  support will be converted accordingly.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public ConvertInstruction setFromType(Class type) {\n+        if (type == null) {\n+            return setFromType((String) null);\n+        }\n+\n+        return setFromType(type.getName());\n+    }\n+\n+    /**\n+     *  Set the type being converted from.  Types that have no direct\n+     *  support will be converted accordingly.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public ConvertInstruction setFromType(BCClass type) {\n+        if (type == null) {\n+            return setFromType((String) null);\n+        }\n+\n+        return setFromType(type.getName());\n+    }\n+\n+    /**\n+     *  ConvertInstructions are equal if the types they convert between are\n+     *  either equal or unset.\n+     */\n+    public boolean equalsInstruction(Instruction other) {\n+        if (other == this) {\n+            return true;\n+        }\n+\n+        if (!(other instanceof ConvertInstruction)) {\n+            return false;\n+        }\n+\n+        ConvertInstruction ins = (ConvertInstruction) other;\n+\n+        if ((getOpcode() != Constants.NOP) && (getOpcode() == ins.getOpcode())) {\n+            return true;\n+        }\n+\n+        String type = getTypeName();\n+        String otherType = ins.getTypeName();\n+\n+        if (!((type == null) || (otherType == null) || type.equals(otherType))) {\n+            return false;\n+        }\n+\n+        type = getFromTypeName();\n+        otherType = ins.getFromTypeName();\n+\n+        return (type == null) || (otherType == null) || type.equals(otherType);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterConvertInstruction(this);\n+        visit.exitConvertInstruction(this);\n+    }\n+\n+    void read(Instruction orig) {\n+        super.read(orig);\n+\n+        ConvertInstruction ins = (ConvertInstruction) orig;\n+        _toType = ins._toType;\n+        _fromType = ins._fromType;\n+    }\n+}"},{"sha":"77c5b45c63a20b6943b3d919085b777a527278e8","filename":"serp/src/main/java/serp/bytecode/Deprecated.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Deprecated.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Deprecated.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Deprecated.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+\n+/**\n+ *  <p>Attribute signifying that a method or class is deprecated.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class Deprecated extends Attribute {\n+    Deprecated(int nameIndex, Attributes owner) {\n+        super(nameIndex, owner);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterDeprecated(this);\n+        visit.exitDeprecated(this);\n+    }\n+}"},{"sha":"2cc5cbd414d47e112a5633a8e583365afa7a6db1","filename":"serp/src/main/java/serp/bytecode/ExceptionHandler.java","status":"added","additions":310,"deletions":0,"changes":310,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ExceptionHandler.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ExceptionHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ExceptionHandler.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import serp.util.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Represents a <code>try {} catch() {}</code> statement in bytecode.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class ExceptionHandler implements InstructionPtr, BCEntity,\n+    VisitAcceptor {\n+    private int _catchIndex = 0;\n+    private Code _owner = null;\n+    private InstructionPtrStrategy _tryStart = new InstructionPtrStrategy(this);\n+    private InstructionPtrStrategy _tryEnd = new InstructionPtrStrategy(this);\n+    private InstructionPtrStrategy _tryHandler = new InstructionPtrStrategy(this);\n+\n+    ExceptionHandler(Code owner) {\n+        _owner = owner;\n+    }\n+\n+    /**\n+     *  Return the owning code block.\n+     */\n+    public Code getCode() {\n+        return _owner;\n+    }\n+\n+    ///////////////////\n+    // Body operations\n+    ///////////////////\n+\n+    /**\n+      *  Return the instruction marking the beginning of the try {} block.\n+     */\n+    public Instruction getTryStart() {\n+        return _tryStart.getTargetInstruction();\n+    }\n+\n+    /**\n+     *  Set the {@link Instruction} marking the beginning of the try block.\n+     *  The instruction must already be a part of the method.\n+     */\n+    public void setTryStart(Instruction instruction) {\n+        _tryStart.setTargetInstruction(instruction);\n+    }\n+\n+    /**\n+      *  Return the instruction at the end of the try {} block.\n+     */\n+    public Instruction getTryEnd() {\n+        return _tryEnd.getTargetInstruction();\n+    }\n+\n+    /**\n+     *  Set the Instruction at the end of the try block.  The\n+     *  Instruction must already be a part of the method.\n+     */\n+    public void setTryEnd(Instruction instruction) {\n+        _tryEnd.setTargetInstruction(instruction);\n+    }\n+\n+    //////////////////////\n+    // Handler operations\n+    //////////////////////\n+\n+    /**\n+      *  Return the instruction marking the beginning of the catch {} block.\n+     */\n+    public Instruction getHandlerStart() {\n+        return _tryHandler.getTargetInstruction();\n+    }\n+\n+    /**\n+     *  Set the {@link Instruction} marking the beginning of the catch block.\n+     *  The instruction must already be a part of the method.\n+     *  WARNING: if this instruction is deleted, the results are undefined.\n+     */\n+    public void setHandlerStart(Instruction instruction) {\n+        _tryHandler.setTargetInstruction(instruction);\n+    }\n+\n+    ////////////////////\n+    // Catch operations\n+    ////////////////////\n+\n+    /**\n+     *  Return the index into the class {@link ConstantPool} of the\n+     *  {@link ClassEntry} describing the exception type this handler catches.\n+     */\n+    public int getCatchIndex() {\n+        return _catchIndex;\n+    }\n+\n+    /**\n+     *  Set the index into the class {@link ConstantPool} of the\n+     *  {@link ClassEntry} describing the exception type this handler catches.\n+     */\n+    public void setCatchIndex(int catchTypeIndex) {\n+        _catchIndex = catchTypeIndex;\n+    }\n+\n+    /**\n+     *  Return the name of the exception type; returns null for catch-all\n+     *  clauses used to implement finally blocks.  The name will be returned\n+     *  in a forum suitable for a {@link Class#forName} call.\n+     */\n+    public String getCatchName() {\n+        if (_catchIndex == 0) {\n+            return null;\n+        }\n+\n+        ClassEntry entry = (ClassEntry) getPool().getEntry(_catchIndex);\n+\n+        return getProject().getNameCache()\n+                   .getExternalForm(entry.getNameEntry().getValue(), false);\n+    }\n+\n+    /**\n+     *  Return the {@link Class} of the exception type; returns null for\n+     *  catch-all clauses used to implement finally blocks.\n+     */\n+    public Class getCatchType() {\n+        String name = getCatchName();\n+\n+        if (name == null) {\n+            return null;\n+        }\n+\n+        return Strings.toClass(name, getClassLoader());\n+    }\n+\n+    /**\n+     *  Return the bytecode of the exception type; returns null for\n+     *  catch-all clauses used to implement finally blocks.\n+     */\n+    public BCClass getCatchBC() {\n+        String name = getCatchName();\n+\n+        if (name == null) {\n+            return null;\n+        }\n+\n+        return getProject().loadClass(name, getClassLoader());\n+    }\n+\n+    /**\n+     *  Set the class of the exception type, or null for catch-all clauses used\n+     *  with finally blocks.\n+     */\n+    public void setCatch(String name) {\n+        if (name == null) {\n+            _catchIndex = 0;\n+        } else {\n+            _catchIndex = getPool()\n+                              .findClassEntry(getProject().getNameCache()\n+                                                  .getInternalForm(name, false),\n+                    true);\n+        }\n+    }\n+\n+    /**\n+     *  Set the class of the exception type, or null for catch-all clauses used\n+     *  for finally blocks.\n+     */\n+    public void setCatch(Class type) {\n+        if (type == null) {\n+            setCatch((String) null);\n+        } else {\n+            setCatch(type.getName());\n+        }\n+    }\n+\n+    /**\n+     *  Set the class of the exception type, or null for catch-all clauses used\n+     *  for finally blocks.\n+     */\n+    public void setCatch(BCClass type) {\n+        if (type == null) {\n+            setCatch((String) null);\n+        } else {\n+            setCatch(type.getName());\n+        }\n+    }\n+\n+    /////////////////////////////////\n+    // InstructionPtr implementation\n+    /////////////////////////////////\n+    public void updateTargets() {\n+        _tryStart.updateTargets();\n+        _tryEnd.updateTargets();\n+        _tryHandler.updateTargets();\n+    }\n+\n+    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n+        _tryStart.replaceTarget(oldTarget, newTarget);\n+        _tryEnd.replaceTarget(oldTarget, newTarget);\n+        _tryHandler.replaceTarget(oldTarget, newTarget);\n+    }\n+\n+    ///////////////////////////\n+    // BCEntity implementation\n+    ///////////////////////////\n+    public Project getProject() {\n+        return _owner.getProject();\n+    }\n+\n+    public ConstantPool getPool() {\n+        return _owner.getPool();\n+    }\n+\n+    public ClassLoader getClassLoader() {\n+        return _owner.getClassLoader();\n+    }\n+\n+    public boolean isValid() {\n+        return _owner != null;\n+    }\n+\n+    ////////////////////////////////\n+    // VisitAcceptor implementation\n+    ////////////////////////////////\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterExceptionHandler(this);\n+        visit.exitExceptionHandler(this);\n+    }\n+\n+    //////////////////\n+    // I/O operations\n+    //////////////////\n+    void read(ExceptionHandler orig) {\n+        _tryStart.setByteIndex(orig._tryStart.getByteIndex());\n+        _tryEnd.setByteIndex(orig._tryEnd.getByteIndex());\n+        _tryHandler.setByteIndex(orig._tryHandler.getByteIndex());\n+\n+        // done at a high level so that if the name isn't in our constant pool,\n+        // it will be added\n+        setCatch(orig.getCatchName());\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        setTryStart(in.readUnsignedShort());\n+        setTryEnd(in.readUnsignedShort());\n+        setHandlerStart(in.readUnsignedShort());\n+        setCatchIndex(in.readUnsignedShort());\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        out.writeShort(getTryStartPc());\n+        out.writeShort(getTryEndPc());\n+        out.writeShort(getHandlerStartPc());\n+        out.writeShort(getCatchIndex());\n+    }\n+\n+    public void setTryStart(int start) {\n+        _tryStart.setByteIndex(start);\n+    }\n+\n+    public int getTryStartPc() {\n+        return _tryStart.getByteIndex();\n+    }\n+\n+    public void setTryEnd(int end) {\n+        setTryEnd((Instruction) _owner.getInstruction(end).prev);\n+    }\n+\n+    /**\n+     *  Return the program counter end position for this exception handler.\n+     *  This represents an index into the code byte array.\n+     */\n+    public int getTryEndPc() {\n+        return _tryEnd.getByteIndex() + getTryEnd().getLength();\n+    }\n+\n+    public void setHandlerStart(int handler) {\n+        _tryHandler.setByteIndex(handler);\n+    }\n+\n+    public int getHandlerStartPc() {\n+        return _tryHandler.getByteIndex();\n+    }\n+\n+    void invalidate() {\n+        _owner = null;\n+    }\n+}"},{"sha":"8ab929b88a89d56018efcb6a00694224d7fa6c5a","filename":"serp/src/main/java/serp/bytecode/Exceptions.java","status":"added","additions":330,"deletions":0,"changes":330,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Exceptions.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Exceptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Exceptions.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import serp.util.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Attribute declaring the checked exceptions a method can throw.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class Exceptions extends Attribute {\n+    private List _indexes = new LinkedList();\n+\n+    Exceptions(int nameIndex, Attributes owner) {\n+        super(nameIndex, owner);\n+    }\n+\n+    int getLength() {\n+        return 2 + (2 * _indexes.size());\n+    }\n+\n+    /**\n+     *  Return the owning method.\n+     */\n+    public BCMethod getMethod() {\n+        return (BCMethod) getOwner();\n+    }\n+\n+    /**\n+      *  Return the indexes in the class {@link ConstantPool} of the\n+     *  {@link ClassEntry}s        for the exception types thrown by this method, or\n+     *  an empty array if none.\n+     */\n+    public int[] getExceptionIndexes() {\n+        int[] indexes = new int[_indexes.size()];\n+        Iterator itr = _indexes.iterator();\n+\n+        for (int i = 0; i < indexes.length; i++)\n+            indexes[i] = ((Integer) itr.next()).intValue();\n+\n+        return indexes;\n+    }\n+\n+    /**\n+      *  Set the indexes in the class {@link ConstantPool} of the\n+     *  {@link ClassEntry}s        for the exception types thrown by this method.  Use\n+     *  null or an empty array for none.\n+     */\n+    public void setExceptionIndexes(int[] exceptionIndexes) {\n+        _indexes.clear();\n+\n+        if (exceptionIndexes != null) {\n+            for (int i = 0; i < exceptionIndexes.length; i++)\n+                _indexes.add(Numbers.valueOf(exceptionIndexes[i]));\n+        }\n+    }\n+\n+    /**\n+     *  Return the names of the exception types for this method, or an empty\n+     *  array if none.  The names will be in a form suitable for a\n+     *  {@link Class#forName} call.\n+     */\n+    public String[] getExceptionNames() {\n+        String[] names = new String[_indexes.size()];\n+        Iterator itr = _indexes.iterator();\n+        int index;\n+        ClassEntry entry;\n+\n+        for (int i = 0; i < names.length; i++) {\n+            index = ((Number) itr.next()).intValue();\n+            entry = (ClassEntry) getPool().getEntry(index);\n+            names[i] = getProject().getNameCache()\n+                           .getExternalForm(entry.getNameEntry().getValue(),\n+                    false);\n+        }\n+\n+        return names;\n+    }\n+\n+    /**\n+     *  Return the {@link Class} objects for the exception types for this\n+     *  method, or an empty        array if none.\n+     */\n+    public Class[] getExceptionTypes() {\n+        String[] names = getExceptionNames();\n+        Class[] types = new Class[names.length];\n+\n+        for (int i = 0; i < names.length; i++)\n+            types[i] = Strings.toClass(names[i], getClassLoader());\n+\n+        return types;\n+    }\n+\n+    /**\n+     *  Return bytecode for the exception types of this\n+     *  method, or an empty        array if none.\n+     */\n+    public BCClass[] getExceptionBCs() {\n+        String[] names = getExceptionNames();\n+        BCClass[] types = new BCClass[names.length];\n+\n+        for (int i = 0; i < names.length; i++)\n+            types[i] = getProject().loadClass(names[i], getClassLoader());\n+\n+        return types;\n+    }\n+\n+    /**\n+     *  Set the checked exceptions thrown by this method.  Use null or an\n+     *  empty array for none.\n+     */\n+    public void setExceptions(String[] exceptions) {\n+        if (exceptions != null) {\n+            for (int i = 0; i < exceptions.length; i++)\n+                if (exceptions[i] == null) {\n+                    throw new NullPointerException(\"exceptions[\" + i +\n+                        \"] = null\");\n+                }\n+        }\n+\n+        clear();\n+\n+        if (exceptions != null) {\n+            for (int i = 0; i < exceptions.length; i++)\n+                addException(exceptions[i]);\n+        }\n+    }\n+\n+    /**\n+     *  Set the checked exceptions thrown by this method.  Use null or an\n+     *  empty array for none.\n+     */\n+    public void setExceptions(Class[] exceptions) {\n+        String[] names = null;\n+\n+        if (exceptions != null) {\n+            names = new String[exceptions.length];\n+\n+            for (int i = 0; i < exceptions.length; i++)\n+                names[i] = exceptions[i].getName();\n+        }\n+\n+        setExceptions(names);\n+    }\n+\n+    /**\n+     *  Set the checked exceptions thrown by this method.  Use null or an\n+     *  empty array for none.\n+     */\n+    public void setExceptions(BCClass[] exceptions) {\n+        String[] names = null;\n+\n+        if (exceptions != null) {\n+            names = new String[exceptions.length];\n+\n+            for (int i = 0; i < exceptions.length; i++)\n+                names[i] = exceptions[i].getName();\n+        }\n+\n+        setExceptions(names);\n+    }\n+\n+    /**\n+     *  Clear this method of all exception declarations.\n+     */\n+    public void clear() {\n+        _indexes.clear();\n+    }\n+\n+    /**\n+     *  Remove an exception type thrown by this method.\n+     *\n+     *  @return true if the method had the exception type, false otherwise\n+     */\n+    public boolean removeException(String type) {\n+        String internalForm = getProject().getNameCache()\n+                                  .getInternalForm(type, false);\n+        ClassEntry entry;\n+\n+        for (Iterator itr = _indexes.iterator(); itr.hasNext();) {\n+            entry = (ClassEntry) getPool()\n+                                     .getEntry(((Integer) itr.next()).intValue());\n+\n+            if (entry.getNameEntry().getValue().equals(internalForm)) {\n+                itr.remove();\n+\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     *  Remove an exception thrown by this method.\n+     *\n+     *  @return true if the method had the exception type, false otherwise\n+     */\n+    public boolean removeException(Class type) {\n+        if (type == null) {\n+            return false;\n+        }\n+\n+        return removeException(type.getName());\n+    }\n+\n+    /**\n+     *  Remove an exception thrown by this method.\n+     *\n+     *  @return true if the method had the exception type, false otherwise\n+     */\n+    public boolean removeException(BCClass type) {\n+        if (type == null) {\n+            return false;\n+        }\n+\n+        return removeException(type.getName());\n+    }\n+\n+    /**\n+      *  Add an exception type to those thrown by this method.\n+     */\n+    public void addException(String type) {\n+        int index = getPool()\n+                        .findClassEntry(getProject().getNameCache()\n+                                            .getInternalForm(type, false), true);\n+        _indexes.add(Numbers.valueOf(index));\n+    }\n+\n+    /**\n+      *  Add an exception to those thrown by this method.\n+     */\n+    public void addException(Class type) {\n+        addException(type.getName());\n+    }\n+\n+    /**\n+      *  Add an exception to those thrown by this method.\n+     */\n+    public void addException(BCClass type) {\n+        addException(type.getName());\n+    }\n+\n+    /**\n+     *  Return true if the method declares that it throws the given\n+     *  exception type.\n+     */\n+    public boolean throwsException(String type) {\n+        String[] exceptions = getExceptionNames();\n+\n+        for (int i = 0; i < exceptions.length; i++)\n+            if (exceptions[i].equals(type)) {\n+                return true;\n+            }\n+\n+        return false;\n+    }\n+\n+    /**\n+     *  Return true if the method declares that it throws the given\n+     *  exception type.\n+     */\n+    public boolean throwsException(Class type) {\n+        if (type == null) {\n+            return false;\n+        }\n+\n+        return throwsException(type.getName());\n+    }\n+\n+    /**\n+     *  Return true if the method declares that it throws the given\n+     *  exception type.\n+     */\n+    public boolean throwsException(BCClass type) {\n+        if (type == null) {\n+            return false;\n+        }\n+\n+        return throwsException(type.getName());\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterExceptions(this);\n+        visit.exitExceptions(this);\n+    }\n+\n+    void read(Attribute other) {\n+        setExceptions(((Exceptions) other).getExceptionNames());\n+    }\n+\n+    void read(DataInput in, int length) throws IOException {\n+        _indexes.clear();\n+\n+        int exceptionCount = in.readUnsignedShort();\n+\n+        for (int i = 0; i < exceptionCount; i++)\n+            _indexes.add(Numbers.valueOf((int) in.readUnsignedShort()));\n+    }\n+\n+    void write(DataOutput out, int length) throws IOException {\n+        out.writeShort(_indexes.size());\n+\n+        for (Iterator itr = _indexes.iterator(); itr.hasNext();)\n+            out.writeShort(((Number) itr.next()).shortValue());\n+    }\n+}"},{"sha":"ca93a91f92fbe8d6060715d0830a5452faa24e24","filename":"serp/src/main/java/serp/bytecode/FieldInstruction.java","status":"added","additions":499,"deletions":0,"changes":499,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/FieldInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/FieldInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/FieldInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,499 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import serp.util.*;\n+\n+import java.io.*;\n+\n+import java.lang.reflect.*;\n+\n+\n+/**\n+ *  <p>Instruction that takes as an argument a field to operate\n+ *  on. Examples include <code>getfield, getstatic, setfield,\n+ *  setstatic</code>.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public abstract class FieldInstruction extends Instruction {\n+    private int _index = 0;\n+\n+    FieldInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    int getLength() {\n+        return super.getLength() + 2;\n+    }\n+\n+    ////////////////////\n+    // Field operations\n+    ////////////////////\n+\n+    /**\n+     *  Return the index in the class {@link ConstantPool} of the\n+     *  {@link ComplexEntry} describing the field to operate on.\n+     */\n+    public int getFieldIndex() {\n+        return _index;\n+    }\n+\n+    /**\n+     *  Set the index in the class {@link ConstantPool} of the\n+     *  {@link ComplexEntry} describing the field to operate on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setFieldIndex(int index) {\n+        _index = index;\n+\n+        return this;\n+    }\n+\n+    /**\n+     *  Return the field this instruction operates on, or null if not set.\n+     */\n+    public BCField getField() {\n+        String dec = getFieldDeclarerName();\n+\n+        if (dec == null) {\n+            return null;\n+        }\n+\n+        BCClass bc = getProject().loadClass(dec, getClassLoader());\n+        BCField[] fields = bc.getFields(getFieldName());\n+\n+        if (fields.length == 0) {\n+            return null;\n+        }\n+\n+        return fields[0];\n+    }\n+\n+    /**\n+     *  Set the field this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setField(BCField field) {\n+        if (field == null) {\n+            return setFieldIndex(0);\n+        }\n+\n+        return setField(field.getDeclarer().getName(), field.getName(),\n+            field.getTypeName());\n+    }\n+\n+    /**\n+     *  Set the field this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setField(Field field) {\n+        if (field == null) {\n+            return setFieldIndex(0);\n+        }\n+\n+        return setField(field.getDeclaringClass(), field.getName(),\n+            field.getType());\n+    }\n+\n+    /**\n+     *  Set the field this instruction operates on.\n+     *\n+     *  @param dec                the full class name of the field's declaring class\n+     *  @param name        the field name\n+     *  @param type        the full class name of the field type\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setField(String dec, String name, String type) {\n+        if ((dec == null) && (name == null) && (type == null)) {\n+            return setFieldIndex(0);\n+        }\n+\n+        if (dec == null) {\n+            dec = \"\";\n+        }\n+\n+        if (name == null) {\n+            name = \"\";\n+        }\n+\n+        if (type == null) {\n+            type = \"\";\n+        }\n+\n+        dec = getProject().getNameCache().getInternalForm(dec, false);\n+        type = getProject().getNameCache().getInternalForm(type, true);\n+\n+        return setFieldIndex(getPool().findFieldEntry(dec, name, type, true));\n+    }\n+\n+    /**\n+     *  Set the field this instruction operates on, for fields that are\n+     *  declared by the current class.\n+     *\n+     *  @param name        the field name\n+     *  @param type        the full class name of the field type\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setField(String name, String type) {\n+        BCClass owner = getCode().getMethod().getDeclarer();\n+\n+        return setField(owner.getName(), name, type);\n+    }\n+\n+    /**\n+     *  Set the field this instruction operates on.\n+     *\n+     *  @param dec                the field's declaring class\n+     *  @param name        the field name\n+     *  @param type        the class of the field type\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setField(Class dec, String name, Class type) {\n+        String decName = (dec == null) ? null : dec.getName();\n+        String typeName = (type == null) ? null : type.getName();\n+\n+        return setField(decName, name, typeName);\n+    }\n+\n+    /**\n+     *  Set the field this instruction operates on, for fields that are\n+     *  declared by the current class.\n+     *\n+     *  @param name        the field name\n+     *  @param type        the class of the field type\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setField(String name, Class type) {\n+        BCClass owner = getCode().getMethod().getDeclarer();\n+        String typeName = (type == null) ? null : type.getName();\n+\n+        return setField(owner.getName(), name, typeName);\n+    }\n+\n+    /**\n+     *  Set the field this instruction operates on.\n+     *\n+     *  @param dec                the field's declaring class\n+     *  @param name        the field name\n+     *  @param type        the class of the field type\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setField(BCClass dec, String name, BCClass type) {\n+        String decName = (dec == null) ? null : dec.getName();\n+        String typeName = (type == null) ? null : type.getName();\n+\n+        return setField(decName, name, typeName);\n+    }\n+\n+    /**\n+     *  Set the field this instruction operates on, for fields that are\n+     *  declared by the current class.\n+     *\n+     *  @param name        the field name\n+     *  @param type        the class of the field type\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setField(String name, BCClass type) {\n+        BCClass owner = getCode().getMethod().getDeclarer();\n+        String typeName = (type == null) ? null : type.getName();\n+\n+        return setField(owner.getName(), name, typeName);\n+    }\n+\n+    ////////////////////////////////\n+    // Name, Type, Owner operations\n+    ////////////////////////////////\n+\n+    /**\n+      *  Return the name of the field this instruction operates on, or null\n+     *  if not set.\n+     */\n+    public String getFieldName() {\n+        int index = getFieldIndex();\n+\n+        if (index == 0) {\n+            return null;\n+        }\n+\n+        ComplexEntry entry = (ComplexEntry) getPool().getEntry(index);\n+        String name = entry.getNameAndTypeEntry().getNameEntry().getValue();\n+\n+        if (name.length() == 0) {\n+            return null;\n+        }\n+\n+        return name;\n+    }\n+\n+    /**\n+     *  Set the name of the field this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setFieldName(String name) {\n+        return setField(getFieldDeclarerName(), name, getFieldTypeName());\n+    }\n+\n+    /**\n+     *  Return the type of the field this instruction operates on, or null\n+     *  if not set.\n+     */\n+    public String getFieldTypeName() {\n+        int index = getFieldIndex();\n+\n+        if (index == 0) {\n+            return null;\n+        }\n+\n+        ComplexEntry entry = (ComplexEntry) getPool().getEntry(index);\n+        String name = getProject().getNameCache()\n+                          .getExternalForm(entry.getNameAndTypeEntry()\n+                                                .getDescriptorEntry().getValue(),\n+                false);\n+\n+        if (name.length() == 0) {\n+            return null;\n+        }\n+\n+        return name;\n+    }\n+\n+    /**\n+     *  Return the type of the field this instruction operates on, or null\n+     *  if not set.\n+     */\n+    public Class getFieldType() {\n+        String type = getFieldTypeName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return Strings.toClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Return the type of the field this instruction operates on, or null\n+     *  if not set.\n+     */\n+    public BCClass getFieldTypeBC() {\n+        String type = getFieldTypeName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return getProject().loadClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Set the type of the field this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setFieldType(String type) {\n+        return setField(getFieldDeclarerName(), getFieldName(), type);\n+    }\n+\n+    /**\n+     *  Set the type of the field this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setFieldType(Class type) {\n+        String name = null;\n+\n+        if (type != null) {\n+            name = type.getName();\n+        }\n+\n+        return setFieldType(name);\n+    }\n+\n+    /**\n+     *  Set the type of the field this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setFieldType(BCClass type) {\n+        String name = null;\n+\n+        if (type != null) {\n+            name = type.getName();\n+        }\n+\n+        return setFieldType(name);\n+    }\n+\n+    /**\n+     *  Return the declaring class of the field this instruction operates on,\n+     *  or null if not set.\n+     */\n+    public String getFieldDeclarerName() {\n+        int index = getFieldIndex();\n+\n+        if (index == 0) {\n+            return null;\n+        }\n+\n+        ComplexEntry entry = (ComplexEntry) getPool().getEntry(index);\n+        String name = getProject().getNameCache()\n+                          .getExternalForm(entry.getClassEntry().getNameEntry()\n+                                                .getValue(), false);\n+\n+        if (name.length() == 0) {\n+            return null;\n+        }\n+\n+        return name;\n+    }\n+\n+    /**\n+     *  Return the declaring class of the field this instruction operates on,\n+     *  or null if not set.\n+     */\n+    public Class getFieldDeclarerType() {\n+        String type = getFieldDeclarerName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return Strings.toClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Return the declaring class of the field this instruction operates on,\n+     *  or null        if not set.\n+     */\n+    public BCClass getFieldDeclarerBC() {\n+        String type = getFieldDeclarerName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return getProject().loadClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Set the declaring class of the field this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setFieldDeclarer(String type) {\n+        return setField(type, getFieldName(), getFieldTypeName());\n+    }\n+\n+    /**\n+     *  Set the declaring class of the field this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setFieldDeclarer(Class type) {\n+        String name = null;\n+\n+        if (type != null) {\n+            name = type.getName();\n+        }\n+\n+        return setFieldDeclarer(name);\n+    }\n+\n+    /**\n+     *  Set the declaring class of the field this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public FieldInstruction setFieldDeclarer(BCClass type) {\n+        String name = null;\n+\n+        if (type != null) {\n+            name = type.getName();\n+        }\n+\n+        return setFieldDeclarer(name);\n+    }\n+\n+    /**\n+     *  FieldInstructions are equal if the field they reference is the same,\n+     *  or if the field of either is unset.\n+     */\n+    public boolean equalsInstruction(Instruction other) {\n+        if (other == this) {\n+            return true;\n+        }\n+\n+        if (!(other instanceof FieldInstruction)) {\n+            return false;\n+        }\n+\n+        if (!super.equalsInstruction(other)) {\n+            return false;\n+        }\n+\n+        FieldInstruction ins = (FieldInstruction) other;\n+\n+        String s1 = getFieldName();\n+        String s2 = ins.getFieldName();\n+\n+        if (!((s1 == null) || (s2 == null) || s1.equals(s2))) {\n+            return false;\n+        }\n+\n+        s1 = getFieldTypeName();\n+        s2 = ins.getFieldTypeName();\n+\n+        if (!((s1 == null) || (s2 == null) || s1.equals(s2))) {\n+            return false;\n+        }\n+\n+        s1 = getFieldDeclarerName();\n+        s2 = ins.getFieldDeclarerName();\n+\n+        if (!((s1 == null) || (s2 == null) || s1.equals(s2))) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    void read(Instruction orig) {\n+        super.read(orig);\n+\n+        FieldInstruction ins = (FieldInstruction) orig;\n+        setField(ins.getFieldDeclarerName(), ins.getFieldName(),\n+            ins.getFieldTypeName());\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        super.read(in);\n+        setFieldIndex(in.readUnsignedShort());\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        super.write(out);\n+        out.writeShort(getFieldIndex());\n+    }\n+}"},{"sha":"af27da4538ffb41b0bfd6452145a95b3f7593ff4","filename":"serp/src/main/java/serp/bytecode/GetFieldInstruction.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/GetFieldInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/GetFieldInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/GetFieldInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+\n+/**\n+ *  <p>Loads a value from a field onto the stack.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class GetFieldInstruction extends FieldInstruction {\n+    GetFieldInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    public int getLogicalStackChange() {\n+        if (getOpcode() == Constants.GETSTATIC) {\n+            return 1;\n+        }\n+\n+        return 0;\n+    }\n+\n+    public int getStackChange() {\n+        String type = getFieldTypeName();\n+\n+        if (type == null) {\n+            return 0;\n+        }\n+\n+        int stack = 0;\n+\n+        if (long.class.getName().equals(type) ||\n+                double.class.getName().equals(type)) {\n+            stack++;\n+        }\n+\n+        if (getOpcode() == Constants.GETSTATIC) {\n+            stack++;\n+        }\n+\n+        return stack;\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterGetFieldInstruction(this);\n+        visit.exitGetFieldInstruction(this);\n+    }\n+}"},{"sha":"54ae769eb536b533c689896d5e01f6f423568a5b","filename":"serp/src/main/java/serp/bytecode/IIncInstruction.java","status":"added","additions":97,"deletions":0,"changes":97,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/IIncInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/IIncInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/IIncInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+\n+/**\n+ *  <p>The <code>iinc</code> instruction.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class IIncInstruction extends LocalVariableInstruction {\n+    private int _inc = 0;\n+\n+    IIncInstruction(Code owner) {\n+        super(owner, Constants.IINC);\n+    }\n+\n+    int getLength() {\n+        return super.getLength() + 2;\n+    }\n+\n+    /**\n+     *  Return the increment for this IINC instruction.\n+      */\n+    public int getIncrement() {\n+        return _inc;\n+    }\n+\n+    /**\n+     *  Set the increment on this IINC instruction.\n+     *\n+     *  @return this Instruction, for method chaining\n+     */\n+    public IIncInstruction setIncrement(int val) {\n+        _inc = val;\n+\n+        return this;\n+    }\n+\n+    public boolean equalsInstruction(Instruction other) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (!(other instanceof IIncInstruction)) {\n+            return false;\n+        }\n+\n+        if (!super.equalsInstruction(other)) {\n+            return false;\n+        }\n+\n+        IIncInstruction ins = (IIncInstruction) other;\n+\n+        return ((getIncrement() == 0) || (ins.getIncrement() == 0) ||\n+        (getIncrement() == ins.getIncrement()));\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterIIncInstruction(this);\n+        visit.exitIIncInstruction(this);\n+    }\n+\n+    void read(Instruction other) {\n+        super.read(other);\n+        setIncrement(((IIncInstruction) other).getIncrement());\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        super.read(in);\n+        setLocal(in.readUnsignedByte());\n+        setIncrement(in.readByte());\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        super.write(out);\n+        out.writeByte(getLocal());\n+        out.writeByte(getIncrement());\n+    }\n+}"},{"sha":"053dfa84771cef2bae43aa5db51df7459856e160","filename":"serp/src/main/java/serp/bytecode/IfInstruction.java","status":"added","additions":81,"deletions":0,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/IfInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/IfInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/IfInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+\n+/**\n+ *  <p>An if instruction such as <code>ifnull, ifeq</code>, etc.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class IfInstruction extends JumpInstruction {\n+    IfInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    public int getLogicalStackChange() {\n+        return getStackChange();\n+    }\n+\n+    public int getStackChange() {\n+        switch (getOpcode()) {\n+        case Constants.IFACMPEQ:\n+        case Constants.IFACMPNE:\n+        case Constants.IFICMPEQ:\n+        case Constants.IFICMPNE:\n+        case Constants.IFICMPLT:\n+        case Constants.IFICMPGT:\n+        case Constants.IFICMPLE:\n+        case Constants.IFICMPGE:\n+            return -2;\n+\n+        case Constants.IFEQ:\n+        case Constants.IFNE:\n+        case Constants.IFLT:\n+        case Constants.IFGT:\n+        case Constants.IFLE:\n+        case Constants.IFGE:\n+        case Constants.IFNULL:\n+        case Constants.IFNONNULL:\n+            return -1;\n+\n+        default:\n+            return super.getStackChange();\n+        }\n+    }\n+\n+    public String getTypeName() {\n+        switch (getOpcode()) {\n+        case Constants.IFACMPEQ:\n+        case Constants.IFACMPNE:\n+        case Constants.IFNULL:\n+        case Constants.IFNONNULL:\n+            return \"java.lang.Object\";\n+\n+        default:\n+            return \"I\";\n+        }\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterIfInstruction(this);\n+        visit.exitIfInstruction(this);\n+    }\n+}"},{"sha":"0e7f58f62047f640ea9f4bfcd36a9c62de9e11bb","filename":"serp/src/main/java/serp/bytecode/InnerClass.java","status":"added","additions":466,"deletions":0,"changes":466,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/InnerClass.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/InnerClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/InnerClass.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,466 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import serp.util.*;\n+\n+import java.io.*;\n+\n+\n+/**\n+ *  <p>Any referenced class that is not a package member is represented by\n+ *  this structure.  This includes member classes and interfaces.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class InnerClass implements BCEntity, VisitAcceptor {\n+    private int _index = 0;\n+    private int _nameIndex = 0;\n+    private int _ownerIndex = 0;\n+    private int _access = Constants.ACCESS_PRIVATE;\n+    private InnerClasses _owner = null;\n+\n+    InnerClass(InnerClasses owner) {\n+        _owner = owner;\n+    }\n+\n+    /**\n+     *  Inner classes are stored in an {@link InnerClasses} attribute.\n+     */\n+    public InnerClasses getOwner() {\n+        return _owner;\n+    }\n+\n+    void invalidate() {\n+        _owner = null;\n+    }\n+\n+    /////////////////////\n+    // Access operations\n+    /////////////////////\n+\n+    /**\n+      *  Return the access flags of the inner class.\n+     */\n+    public int getAccessFlags() {\n+        return _access;\n+    }\n+\n+    /**\n+      *  Set the access flags of the inner class.\n+     */\n+    public void setAccessFlags(int accessFlags) {\n+        _access = accessFlags;\n+    }\n+\n+    /**\n+     *  Manipulate the inner class access flags.\n+     */\n+    public boolean isPublic() {\n+        return (getAccessFlags() & Constants.ACCESS_PUBLIC) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the inner class access flags.\n+     */\n+    public void makePublic() {\n+        setAccessFlags(getAccessFlags() | Constants.ACCESS_PUBLIC);\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PRIVATE);\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PROTECTED);\n+    }\n+\n+    /**\n+     *  Manipulate the inner class access flags.\n+     */\n+    public boolean isProtected() {\n+        return (getAccessFlags() & Constants.ACCESS_PROTECTED) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the inner class access flags.\n+     */\n+    public void makeProtected() {\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PUBLIC);\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PRIVATE);\n+        setAccessFlags(getAccessFlags() | Constants.ACCESS_PROTECTED);\n+    }\n+\n+    /**\n+     *  Manipulate the inner class access flags.\n+     */\n+    public boolean isPrivate() {\n+        return (getAccessFlags() & Constants.ACCESS_PRIVATE) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the inner class access flags.\n+     */\n+    public void makePrivate() {\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PUBLIC);\n+        setAccessFlags(getAccessFlags() | Constants.ACCESS_PRIVATE);\n+        setAccessFlags(getAccessFlags() & ~Constants.ACCESS_PROTECTED);\n+    }\n+\n+    /**\n+     *  Manipulate the inner class access flags.\n+     */\n+    public boolean isFinal() {\n+        return (getAccessFlags() & Constants.ACCESS_FINAL) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the inner class access flags.\n+     */\n+    public void setFinal(boolean on) {\n+        if (on) {\n+            setAccessFlags(getAccessFlags() | Constants.ACCESS_FINAL);\n+        } else {\n+            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_FINAL);\n+        }\n+    }\n+\n+    /**\n+     *  Manipulate the inner class access flags.\n+     */\n+    public boolean isStatic() {\n+        return (getAccessFlags() & Constants.ACCESS_STATIC) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the inner class access flags.\n+     */\n+    public void setStatic(boolean on) {\n+        if (on) {\n+            setAccessFlags(getAccessFlags() | Constants.ACCESS_STATIC);\n+        } else {\n+            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_STATIC);\n+        }\n+    }\n+\n+    /**\n+     *  Manipulate the class access flags.\n+     */\n+    public boolean isInterface() {\n+        return (getAccessFlags() & Constants.ACCESS_INTERFACE) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the class access flags.\n+     */\n+    public void setInterface(boolean on) {\n+        if (on) {\n+            setAccessFlags(getAccessFlags() | Constants.ACCESS_INTERFACE);\n+            setAbstract(true);\n+        } else {\n+            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_INTERFACE);\n+        }\n+    }\n+\n+    /**\n+     *  Manipulate the class access flags.\n+     */\n+    public boolean isAbstract() {\n+        return (getAccessFlags() & Constants.ACCESS_ABSTRACT) > 0;\n+    }\n+\n+    /**\n+     *  Manipulate the class access flags.\n+     */\n+    public void setAbstract(boolean on) {\n+        if (on) {\n+            setAccessFlags(getAccessFlags() | Constants.ACCESS_INTERFACE);\n+        } else {\n+            setAccessFlags(getAccessFlags() & ~Constants.ACCESS_INTERFACE);\n+        }\n+    }\n+\n+    ////////////////////////////////\n+    // Name, type, owner operations\n+    ////////////////////////////////\n+\n+    /**\n+     *  Return the {@link ConstantPool} index of the {@link UTF8Entry} that\n+     *  describes the simple name this class is referred to in source, or\n+     *  0 for anonymous classes.\n+     */\n+    public int getNameIndex() {\n+        return _nameIndex;\n+    }\n+\n+    /**\n+     *  Set the {@link ConstantPool} index of the {@link UTF8Entry} that\n+     *  describes the simple name this class is referred to in source, or\n+     *  0 for anonymous classes.\n+     */\n+    public void setNameIndex(int nameIndex) {\n+        _nameIndex = nameIndex;\n+    }\n+\n+    /**\n+     *  Return the simple name of this inner class, or null if anonymous.\n+     */\n+    public String getName() {\n+        if (getNameIndex() == 0) {\n+            return null;\n+        }\n+\n+        return ((UTF8Entry) getPool().getEntry(getNameIndex())).getValue();\n+    }\n+\n+    /**\n+     *  Set the simple name of this inner class.\n+     */\n+    public void setName(String name) {\n+        if (name == null) {\n+            setNameIndex(0);\n+        } else {\n+            setNameIndex(getPool().findUTF8Entry(name, true));\n+        }\n+    }\n+\n+    /**\n+     *  Return the {@link ConstantPool} index of the {@link ClassEntry} that\n+     *  describes this class, or 0 if none.\n+     */\n+    public int getTypeIndex() {\n+        return _index;\n+    }\n+\n+    /**\n+     *  Set the {@link ConstantPool} index of the {@link ClassEntry} that\n+     *  describes this class.\n+     */\n+    public void setTypeIndex(int index) {\n+        _index = index;\n+    }\n+\n+    /**\n+     *  Return the full name of the inner class, or null if unset.\n+     */\n+    public String getTypeName() {\n+        if (getTypeIndex() == 0) {\n+            return null;\n+        }\n+\n+        ClassEntry entry = (ClassEntry) getPool()\n+                                            .getEntry(getTypeIndex());\n+\n+        return getProject().getNameCache()\n+                   .getExternalForm(entry.getNameEntry().getValue(), false);\n+    }\n+\n+    /**\n+     *  Return the type of the inner class.\n+     *  If the type has not been set, this method will return null.\n+     */\n+    public Class getType() {\n+        String type = getTypeName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return Strings.toClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Return the type for this instruction.\n+     *  If the type has not been set, this method will return null.\n+     */\n+    public BCClass getTypeBC() {\n+        String type = getTypeName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return getProject().loadClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Set the type of this inner class.\n+     */\n+    public void setType(String type) {\n+        if (type == null) {\n+            setTypeIndex(0);\n+        } else {\n+            type = getProject().getNameCache().getInternalForm(type, false);\n+            setTypeIndex(getPool().findClassEntry(type, true));\n+        }\n+    }\n+\n+    /**\n+     *  Set the type of this inner class.\n+     */\n+    public void setType(Class type) {\n+        if (type == null) {\n+            setType((String) null);\n+        } else {\n+            setType(type.getName());\n+        }\n+    }\n+\n+    /**\n+     *  Set the type of this inner class.\n+     */\n+    public void setType(BCClass type) {\n+        if (type == null) {\n+            setType((String) null);\n+        } else {\n+            setType(type.getName());\n+        }\n+    }\n+\n+    /**\n+     *  Return the {@link ConstantPool} index of the {@link ClassEntry} that\n+     *  describes the declaring class, or 0 if this class is not a member class.\n+     */\n+    public int getDeclarerIndex() {\n+        return _ownerIndex;\n+    }\n+\n+    /**\n+     *  Set the {@link ConstantPool} index of the {@link ClassEntry} that\n+     *  describes the declaring class, or 0 if this class is not a member class.\n+     */\n+    public void setDeclarerIndex(int ownerIndex) {\n+        _ownerIndex = ownerIndex;\n+    }\n+\n+    /**\n+     *  Return the full name of the declaring class, or null if unset/not a\n+     *  member.\n+     */\n+    public String getDeclarerName() {\n+        if (getDeclarerIndex() == 0) {\n+            return null;\n+        }\n+\n+        ClassEntry entry = (ClassEntry) getPool().getEntry(getDeclarerIndex());\n+\n+        return getProject().getNameCache()\n+                   .getExternalForm(entry.getNameEntry().getValue(), false);\n+    }\n+\n+    /**\n+     *  Return the type of the declaring class.\n+     *  If the type has not been set or the class is not a member, this method\n+     *  will return null.\n+     */\n+    public Class getDeclarerType() {\n+        String type = getDeclarerName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return Strings.toClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Return the type for this instruction.\n+     *  If the type has not been set or the class is not a member, this method\n+     *  will return null.\n+     */\n+    public BCClass getDeclarerBC() {\n+        String type = getDeclarerName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return getProject().loadClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Set the type of this declaring class.\n+     */\n+    public void setDeclarer(String type) {\n+        if (type == null) {\n+            setDeclarerIndex(0);\n+        } else {\n+            type = getProject().getNameCache().getInternalForm(type, false);\n+            setDeclarerIndex(getPool().findClassEntry(type, true));\n+        }\n+    }\n+\n+    /**\n+     *  Set the type of this declaring class.\n+     */\n+    public void setDeclarer(Class type) {\n+        if (type == null) {\n+            setDeclarer((String) null);\n+        } else {\n+            setDeclarer(type.getName());\n+        }\n+    }\n+\n+    /**\n+     *  Set the type of this declaring class.\n+     */\n+    public void setDeclarer(BCClass type) {\n+        if (type == null) {\n+            setDeclarer((String) null);\n+        } else {\n+            setDeclarer(type.getName());\n+        }\n+    }\n+\n+    ///////////////////////////\n+    // BCEntity implementation\n+    ///////////////////////////\n+    public Project getProject() {\n+        return _owner.getProject();\n+    }\n+\n+    public ConstantPool getPool() {\n+        return _owner.getPool();\n+    }\n+\n+    public ClassLoader getClassLoader() {\n+        return _owner.getClassLoader();\n+    }\n+\n+    public boolean isValid() {\n+        return _owner != null;\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterInnerClass(this);\n+        visit.exitInnerClass(this);\n+    }\n+\n+    //////////////////\n+    // I/O operations\n+    //////////////////\n+    void read(DataInput in) throws IOException {\n+        setTypeIndex(in.readUnsignedShort());\n+        setDeclarerIndex(in.readUnsignedShort());\n+        setNameIndex(in.readUnsignedShort());\n+        setAccessFlags(in.readUnsignedShort());\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        out.writeShort(getTypeIndex());\n+        out.writeShort(getDeclarerIndex());\n+        out.writeShort(getNameIndex());\n+        out.writeShort(getAccessFlags());\n+    }\n+}"},{"sha":"a9652b680998a413bdb1c7554bb40bfe92557326","filename":"serp/src/main/java/serp/bytecode/InnerClasses.java","status":"added","additions":246,"deletions":0,"changes":246,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/InnerClasses.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/InnerClasses.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/InnerClasses.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Attribute describing all referenced classes that are not package\n+ *  members.  This includes all member interfaces and classes.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class InnerClasses extends Attribute {\n+    private List _innerClasses = new LinkedList();\n+\n+    InnerClasses(int nameIndex, Attributes owner) {\n+        super(nameIndex, owner);\n+    }\n+\n+    /**\n+     *  Return all referenced inner classes, or empty array if none.\n+     */\n+    public InnerClass[] getInnerClasses() {\n+        return (InnerClass[]) _innerClasses.toArray(new InnerClass[_innerClasses.size()]);\n+    }\n+\n+    /**\n+     *  Return the inner class with the given name.  If multiple inner classes\n+     *  share the name, which is returned is undefined.  Use null to retrieve\n+      *  anonymous classes.\n+     */\n+    public InnerClass getInnerClass(String name) {\n+        InnerClass[] inners = getInnerClasses();\n+        String inner;\n+\n+        for (int i = 0; i < inners.length; i++) {\n+            inner = inners[i].getName();\n+\n+            if (((inner == null) && (name == null)) ||\n+                    ((inner != null) && inner.equals(name))) {\n+                return inners[i];\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     *  Return all inner classes with the given name, or empty array if none.\n+     *  Use null to retrieve anonymous classes.\n+     */\n+    public InnerClass[] getInnerClasses(String name) {\n+        List matches = new LinkedList();\n+        InnerClass[] inners = getInnerClasses();\n+        String inner;\n+\n+        for (int i = 0; i < inners.length; i++) {\n+            inner = inners[i].getName();\n+\n+            if (((inner == null) && (name == null)) ||\n+                    ((inner != null) && inner.equals(name))) {\n+                matches.add(inners[i]);\n+            }\n+        }\n+\n+        return (InnerClass[]) matches.toArray(new InnerClass[matches.size()]);\n+    }\n+\n+    /**\n+     *  Set the inner class references for this class.  This method is\n+     *  useful when importing inner class references from another class.\n+     */\n+    public void setInnerClasses(InnerClass[] inners) {\n+        clear();\n+\n+        if (inners != null) {\n+            for (int i = 0; i < inners.length; i++)\n+                addInnerClass(inners[i]);\n+        }\n+    }\n+\n+    /**\n+     *  Import an inner class from another entity, or make a copy of one\n+     *  on this entity.\n+     *\n+     *  @return the newly added inner class\n+     */\n+    public InnerClass addInnerClass(InnerClass inner) {\n+        InnerClass newInner = addInnerClass(inner.getName(),\n+                inner.getTypeName(), inner.getDeclarerName());\n+        newInner.setAccessFlags(inner.getAccessFlags());\n+\n+        return newInner;\n+    }\n+\n+    /**\n+     *  Add an inner class.\n+     */\n+    public InnerClass addInnerClass() {\n+        InnerClass inner = new InnerClass(this);\n+        _innerClasses.add(inner);\n+\n+        return inner;\n+    }\n+\n+    /**\n+      *  Add an inner class.\n+     *\n+     *  @param name        the simple name of the class, or null if anonymous\n+     *  @param type        the full class name of the inner class\n+     *  @param owner        the declaring class, or null if not a member class\n+     */\n+    public InnerClass addInnerClass(String name, String type, String owner) {\n+        InnerClass inner = addInnerClass();\n+        inner.setName(name);\n+        inner.setType(type);\n+        inner.setDeclarer(owner);\n+\n+        return inner;\n+    }\n+\n+    /**\n+      *  Add an inner class.\n+     *\n+     *  @param name        the simple name of the class, or null if anonymous\n+     *  @param type        the class of the inner class\n+     *  @param owner        the declaring class, or null if not a member class\n+     */\n+    public InnerClass addInnerClass(String name, Class type, Class owner) {\n+        String typeName = (type == null) ? null : type.getName();\n+        String ownerName = (owner == null) ? null : owner.getName();\n+\n+        return addInnerClass(name, typeName, ownerName);\n+    }\n+\n+    /**\n+      *  Add an inner class.\n+     *\n+     *  @param name        the simple name of the class, or null if anonymous\n+     *  @param type        the class of the inner class\n+     *  @param owner        the declaring class, or null if not a member class\n+     */\n+    public InnerClass addInnerClass(String name, BCClass type, BCClass owner) {\n+        String typeName = (type == null) ? null : type.getName();\n+        String ownerName = (owner == null) ? null : owner.getName();\n+\n+        return addInnerClass(name, typeName, ownerName);\n+    }\n+\n+    /**\n+     *  Clear all inner classes from this entity.\n+     */\n+    public void clear() {\n+        InnerClass inner;\n+\n+        for (Iterator itr = _innerClasses.iterator(); itr.hasNext();) {\n+            inner = (InnerClass) itr.next();\n+            itr.remove();\n+            inner.invalidate();\n+        }\n+    }\n+\n+    /**\n+     *  Remove the inner class with the given name.  Use null for anonymous\n+     *  classes.\n+     *\n+     *  @return true if an inner class was removed, false otherwise\n+     */\n+    public boolean removeInnerClass(String name) {\n+        return removeInnerClass(getInnerClass(name));\n+    }\n+\n+    /**\n+     *  Remove the given inner class.  After being removed, the given inner\n+     *  class is invalid, and the result of any operations on it are undefined.\n+     *\n+     *  @return true if the inner class was removed, false otherwise\n+     */\n+    public boolean removeInnerClass(InnerClass innerClass) {\n+        if ((innerClass == null) || !_innerClasses.remove(innerClass)) {\n+            return false;\n+        }\n+\n+        innerClass.invalidate();\n+\n+        return true;\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterInnerClasses(this);\n+\n+        InnerClass[] inners = getInnerClasses();\n+\n+        for (int i = 0; i < inners.length; i++)\n+            inners[i].acceptVisit(visit);\n+\n+        visit.exitInnerClasses(this);\n+    }\n+\n+    int getLength() {\n+        return 2 + (8 * _innerClasses.size());\n+    }\n+\n+    void read(Attribute other) {\n+        setInnerClasses(((InnerClasses) other).getInnerClasses());\n+    }\n+\n+    void read(DataInput in, int length) throws IOException {\n+        clear();\n+\n+        int numInnerClasses = in.readUnsignedShort();\n+\n+        InnerClass innerClass;\n+\n+        for (int i = 0; i < numInnerClasses; i++) {\n+            innerClass = addInnerClass();\n+            innerClass.read(in);\n+        }\n+    }\n+\n+    void write(DataOutput out, int length) throws IOException {\n+        InnerClass[] inners = getInnerClasses();\n+        out.writeShort(inners.length);\n+\n+        for (int i = 0; i < inners.length; i++)\n+            inners[i].write(out);\n+    }\n+}"},{"sha":"899eef649f16fc62f892ea5411272e4daf4be35f","filename":"serp/src/main/java/serp/bytecode/Instruction.java","status":"added","additions":191,"deletions":0,"changes":191,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Instruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Instruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Instruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>An opcode in a method of a class.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class Instruction extends CodeEntry implements BCEntity, VisitAcceptor {\n+    private Code _owner = null;\n+    private int _opcode = Constants.NOP;\n+\n+    Instruction(Code owner) {\n+        _owner = owner;\n+    }\n+\n+    Instruction(Code owner, int opcode) {\n+        _owner = owner;\n+        _opcode = opcode;\n+    }\n+\n+    /**\n+     *  Return the code block that owns this instruction.\n+     */\n+    public Code getCode() {\n+        return _owner;\n+    }\n+\n+    /**\n+      *  Return the name of this instruction.\n+     */\n+    public String getName() {\n+        return Constants.OPCODE_NAMES[_opcode];\n+    }\n+\n+    /**\n+     *  Return the opcode this instruction represents.\n+     */\n+    public int getOpcode() {\n+        return _opcode;\n+    }\n+\n+    /**\n+     *  Set the opcode this instruction represents.  For internal use only.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    Instruction setOpcode(int opcode) {\n+        _opcode = opcode;\n+\n+        return this;\n+    }\n+\n+    /**\n+     *  Return the index in the method code byte block at which this opcode\n+     *  starts.  Note that this information may be out of date if the code\n+     *  block has been modified since last read/written.\n+     */\n+    public int getByteIndex() {\n+        if (_owner != null) {\n+            return _owner.getByteIndex(this);\n+        }\n+\n+        return 0;\n+    }\n+\n+    /**\n+     *  Return the line number of this instruction, or null if none.  This\n+     *  method is subject to the validity constraints of {@link #getByteIndex}.\n+     *\n+     *  @see LineNumberTable#getLineNumber(Instruction)\n+     */\n+    public LineNumber getLineNumber() {\n+        LineNumberTable table = _owner.getLineNumberTable(false);\n+\n+        if (table == null) {\n+            return null;\n+        }\n+\n+        return table.getLineNumber(this);\n+    }\n+\n+    /**\n+     *  Return the length in bytes of this opcode, including all arguments.\n+     *  For many opcodes this method relies on an up-to-date byte index.\n+     */\n+    int getLength() {\n+        return 1;\n+    }\n+\n+    /**\n+     *  Return the logical number of stack positions changed by this\n+     *  instruction.  In other words, ignore weirdness with longs and doubles\n+     *  taking two stack positions.\n+     */\n+    public int getLogicalStackChange() {\n+        return getStackChange();\n+    }\n+\n+    /**\n+     *  Return the number of stack positions this instruction pushes\n+     *  or pops during its execution.\n+     *\n+     *  @return 0 if the stack is not affected by this instruction, a\n+     *                          positive number if it pushes onto the stack, and a negative\n+     *                          number if it pops from the stack\n+     */\n+    public int getStackChange() {\n+        return 0;\n+    }\n+\n+    /**\n+     *  Instructions are equal if their opcodes are the same.  Subclasses\n+     *  should override this method to perform a template comparison:\n+     *  instructions should compare equal to other instructions of the same\n+     *  type where the data is either the same or the data is unset.\n+     */\n+    public boolean equalsInstruction(Instruction other) {\n+        if (other == this) {\n+            return true;\n+        }\n+\n+        return other.getOpcode() == getOpcode();\n+    }\n+\n+    public Project getProject() {\n+        return _owner.getProject();\n+    }\n+\n+    public ConstantPool getPool() {\n+        return _owner.getPool();\n+    }\n+\n+    public ClassLoader getClassLoader() {\n+        return _owner.getClassLoader();\n+    }\n+\n+    public boolean isValid() {\n+        return _owner != null;\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+    }\n+\n+    void invalidate() {\n+        _owner = null;\n+    }\n+\n+    /**\n+     *  Copy the given instruction data.\n+     */\n+    void read(Instruction orig) {\n+    }\n+\n+    /**\n+     *  Read the arguments for this opcode from the given stream.\n+     *  This method should be overridden by opcodes that take arguments.\n+     */\n+    void read(DataInput in) throws IOException {\n+    }\n+\n+    /**\n+     *  Write the arguments for this opcode to the given stream.\n+     *  This method should be overridden by opcodes that take arguments.\n+     */\n+    void write(DataOutput out) throws IOException {\n+    }\n+}"},{"sha":"4a64cbc981df4d68cc8a10af8a575a0b0a1b165f","filename":"serp/src/main/java/serp/bytecode/InstructionPtr.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/InstructionPtr.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/InstructionPtr.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/InstructionPtr.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>An entity that maintains ptrs to instructions in a code block.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public interface InstructionPtr {\n+    /**\n+      *  Use the byte indexes read from the class file to calculate and\n+     *  set references to the target instruction(s) for this ptr.\n+     *  This method will be called after the byte code\n+      *  has been read in for the first time and before it is written after\n+     *  modification.\n+     */\n+    public void updateTargets();\n+\n+    /**\n+     *  Replace the given old, likely invalid, target with a new target.  The\n+     *  new target Instruction is guaranteed to be in the same code\n+     *  block as this InstructionPtr.\n+     */\n+    public void replaceTarget(Instruction oldTarget, Instruction newTarget);\n+\n+    /**\n+     *  Returns the Code block that owns the Instruction(s) this\n+     *  InstructionPtr points to.\n+     */\n+    public Code getCode();\n+}"},{"sha":"84fbb0a933fd37f6355b8f1f7834293df962f21d","filename":"serp/src/main/java/serp/bytecode/InstructionPtrStrategy.java","status":"added","additions":120,"deletions":0,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/InstructionPtrStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/InstructionPtrStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/InstructionPtrStrategy.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,120 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+\n+/**\n+ *  <p>InstructionPtrStrategy handles the different strategies for finding the\n+ *  Instructions that InstructionPtrs point to.  These strategies include,\n+ *  from least desirable to most desirable, using byte indexes,\n+ *  and storing a reference to the target Instruction proper.</p>\n+ *\n+ *  @author Eric Lindauer\n+ *  @date 2002.7.26\n+ */\n+class InstructionPtrStrategy implements InstructionPtr {\n+    // the Instruction doing the targetting\n+    private InstructionPtr _pointer;\n+\n+    // two different ways to find the target from the pointer.\n+    // _target is used first, then _byteIndex\n+    private Instruction _target = null;\n+    private int _byteIndex = -1;\n+\n+    public InstructionPtrStrategy(InstructionPtr pointer) {\n+        _pointer = pointer;\n+    }\n+\n+    public InstructionPtrStrategy(InstructionPtr pointer, Instruction target) {\n+        this(pointer);\n+        setTargetInstruction(target);\n+    }\n+\n+    /**\n+     *  Sets the byteIndex where the target Instruction can be found.\n+     *  This target will now be using byte indices as its target finding\n+     *  strategy, which is the least robust option.  Changing the Code block\n+     *  or importing it into another Method may result in an invalid target.\n+     */\n+    public void setByteIndex(int index) {\n+        if ((index < 0) && (index != -1)) {\n+            throw new IllegalArgumentException(String.valueOf(index));\n+        }\n+\n+        _byteIndex = index;\n+        _target = null;\n+    }\n+\n+    /**\n+     *  Changes the target Instruction.  The target is in the best state\n+     *  possible and should maintain this information even in the face\n+     *  of Code imports and Code changes.\n+     */\n+    public void setTargetInstruction(Instruction ins) {\n+        if (ins.getCode() != getCode()) {\n+            throw new IllegalArgumentException(\"Instruction pointers and \" +\n+                \"targets must be part of the same code block.\");\n+        }\n+\n+        _target = ins;\n+        _byteIndex = -1;\n+    }\n+\n+    /**\n+     *  Returns the Instruction this Target is targetting.  This request\n+     *  does not change the targetting strategy for this Target.\n+     */\n+    public Instruction getTargetInstruction() {\n+        if (_target != null) {\n+            return _target;\n+        }\n+\n+        return getCode().getInstruction(_byteIndex);\n+    }\n+\n+    /**\n+     *  Returns the byteIndex at which the target instruction can be found.\n+     *  This call does not change the Target strategy.\n+     */\n+    public int getByteIndex() {\n+        if (_target == null) {\n+            return _byteIndex;\n+        }\n+\n+        return _target.getByteIndex();\n+    }\n+\n+    /**\n+     *  Same as getInstruction, but this method alters the Target strategy\n+     *  to use the returned Instruction.  This method alters the Target\n+     *  strategy (and Instruction) iff it was previously using byte indexes.\n+     */\n+    public void updateTargets() {\n+        if (_target == null) {\n+            _target = getCode().getInstruction(_byteIndex);\n+        }\n+    }\n+\n+    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n+        if (getTargetInstruction() == oldTarget) {\n+            setTargetInstruction(newTarget);\n+        }\n+    }\n+\n+    public Code getCode() {\n+        return _pointer.getCode();\n+    }\n+}"},{"sha":"58161375bd2bf93deadb755fe23ddb5fe296c7c5","filename":"serp/src/main/java/serp/bytecode/JumpInstruction.java","status":"added","additions":186,"deletions":0,"changes":186,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/JumpInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/JumpInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/JumpInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>An instruction that specifies a position in the code block to jump to.\n+ *  Examples include <code>go2, jsr</code>, etc.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class JumpInstruction extends Instruction implements InstructionPtr {\n+    private InstructionPtrStrategy _target = new InstructionPtrStrategy(this);\n+\n+    JumpInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    public int getLogicalStackChange() {\n+        return getStackChange();\n+    }\n+\n+    public int getStackChange() {\n+        if (getOpcode() == Constants.JSR) {\n+            return 1;\n+        }\n+\n+        return 0;\n+    }\n+\n+    int getLength() {\n+        switch (getOpcode()) {\n+        case Constants.GOTOW:\n+        case Constants.JSRW:\n+            return super.getLength() + 4;\n+\n+        default:\n+            return super.getLength() + 2;\n+        }\n+    }\n+\n+    /**\n+      *  Get the current target instruction to jump to, if it has been set.\n+     */\n+    public Instruction getTarget() {\n+        return _target.getTargetInstruction();\n+    }\n+\n+    /**\n+      *  Set the instruction to jump to; the instruction must already be\n+     *  added to the code block.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public JumpInstruction setTarget(Instruction instruction) {\n+        _target.setTargetInstruction(instruction);\n+\n+        return this;\n+    }\n+\n+    /**\n+      *  JumpInstructions are equal if they represent the same operation and\n+     *  the instruction they jump to is the\n+     *  same, or if the jump Instruction of either is unset.\n+     */\n+    public boolean equalsInstruction(Instruction other) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (!super.equalsInstruction(other)) {\n+            return false;\n+        }\n+\n+        Instruction target = ((JumpInstruction) other).getTarget();\n+\n+        return ((target == null) || (getTarget() == null) ||\n+        (target == getTarget()));\n+    }\n+\n+    public void updateTargets() {\n+        _target.updateTargets();\n+    }\n+\n+    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n+        _target.replaceTarget(oldTarget, newTarget);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterJumpInstruction(this);\n+        visit.exitJumpInstruction(this);\n+    }\n+\n+    void read(Instruction orig) {\n+        super.read(orig);\n+        _target.setByteIndex(((JumpInstruction) orig)._target.getByteIndex());\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        super.read(in);\n+\n+        switch (getOpcode()) {\n+        case Constants.GOTOW:\n+        case Constants.JSRW:\n+            setOffset(in.readInt());\n+\n+            break;\n+\n+        default:\n+            setOffset(in.readShort());\n+        }\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        super.write(out);\n+\n+        switch (getOpcode()) {\n+        case Constants.GOTOW:\n+        case Constants.JSRW:\n+            out.writeInt(getOffset());\n+\n+            break;\n+\n+        default:\n+            out.writeShort(getOffset());\n+        }\n+    }\n+\n+    void calculateOpcode() {\n+        int offset;\n+\n+        switch (getOpcode()) {\n+        case Constants.GOTO:\n+        case Constants.GOTOW:\n+            offset = getOffset();\n+\n+            if (offset < (2 << 16)) {\n+                setOpcode(Constants.GOTO);\n+            } else {\n+                setOpcode(Constants.GOTOW);\n+            }\n+\n+            break;\n+\n+        case Constants.JSR:\n+        case Constants.JSRW:\n+            offset = getOffset();\n+\n+            if (offset < (2 << 16)) {\n+                setOpcode(Constants.JSR);\n+            } else {\n+                setOpcode(Constants.JSRW);\n+            }\n+\n+            break;\n+        }\n+    }\n+\n+    public void setOffset(int offset) {\n+        _target.setByteIndex(getByteIndex() + offset);\n+        calculateOpcode();\n+    }\n+\n+    public int getOffset() {\n+        return _target.getByteIndex() - getByteIndex();\n+    }\n+}"},{"sha":"1340715639ce67c1d294457b83b54a8acb507e38","filename":"serp/src/main/java/serp/bytecode/LineNumber.java","status":"added","additions":162,"deletions":0,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LineNumber.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LineNumber.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LineNumber.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>A line number corresponds to a sequence of opcodes that map logically\n+ *  to a line of source code.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class LineNumber implements Comparable, InstructionPtr, BCEntity,\n+    VisitAcceptor {\n+    private int _line = 0;\n+    private LineNumberTable _owner = null;\n+    InstructionPtrStrategy _target = new InstructionPtrStrategy(this);\n+\n+    LineNumber(LineNumberTable owner) {\n+        _owner = owner;\n+    }\n+\n+    LineNumber(LineNumberTable owner, int startPc) {\n+        this(owner);\n+        setStartPc(startPc);\n+    }\n+\n+    /**\n+     *  Line numbers are stored in a {@link LineNumberTable}.\n+     */\n+    public LineNumberTable getTable() {\n+        return _owner;\n+    }\n+\n+    void invalidate() {\n+        _owner = null;\n+    }\n+\n+    /**\n+     *  Return source line number.\n+     */\n+    public int getLine() {\n+        return _line;\n+    }\n+\n+    /**\n+     *  Set the source line number.\n+     */\n+    public void setLine(int lineNumber) {\n+        _line = lineNumber;\n+    }\n+\n+    /**\n+      *  Return the instruction marking the beginning of this line.\n+     */\n+    public Instruction getStart() {\n+        return _target.getTargetInstruction();\n+    }\n+\n+    /**\n+      *  Return the index into the code byte array at which this line starts.\n+     */\n+    public int getStartPc() {\n+        return _target.getByteIndex();\n+    }\n+\n+    /**\n+      *  Set the index into the code byte array at which this line starts.\n+     */\n+    public void setStartPc(int startPc) {\n+        _target.setByteIndex(startPc);\n+    }\n+\n+    /**\n+     *  Set the {@link Instruction} marking the beginning this line.\n+     *  The instruction must already be a part of the method.\n+     */\n+    public void setStart(Instruction instruction) {\n+        _target.setTargetInstruction(instruction);\n+    }\n+\n+    public void updateTargets() {\n+        _target.updateTargets();\n+    }\n+\n+    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n+        _target.replaceTarget(oldTarget, newTarget);\n+    }\n+\n+    public Project getProject() {\n+        return _owner.getProject();\n+    }\n+\n+    public ConstantPool getPool() {\n+        return _owner.getPool();\n+    }\n+\n+    public ClassLoader getClassLoader() {\n+        return _owner.getClassLoader();\n+    }\n+\n+    public boolean isValid() {\n+        return _owner != null;\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterLineNumber(this);\n+        visit.exitLineNumber(this);\n+    }\n+\n+    public int compareTo(Object other) {\n+        if (!(other instanceof LineNumber)) {\n+            return -1;\n+        }\n+\n+        LineNumber ln = (LineNumber) other;\n+\n+        if (getStartPc() == ln.getStartPc()) {\n+            return 0;\n+        }\n+\n+        if (getStartPc() < ln.getStartPc()) {\n+            return -1;\n+        }\n+\n+        return 1;\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        setStartPc(in.readUnsignedShort());\n+        setLine(in.readUnsignedShort());\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        out.writeShort(getStartPc());\n+        out.writeShort(getLine());\n+    }\n+\n+    public Code getCode() {\n+        return _owner.getCode();\n+    }\n+}"},{"sha":"01decb563897b29d4568221859c07db9091edba0","filename":"serp/src/main/java/serp/bytecode/LineNumberTable.java","status":"added","additions":227,"deletions":0,"changes":227,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LineNumberTable.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LineNumberTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LineNumberTable.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,227 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Code blocks compiled from source have line number tables mapping\n+ *  opcodes to source lines.  This table automatically maintains line\n+ *  numbers in ascending order by their start program counter position\n+ *  at all times.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class LineNumberTable extends Attribute implements InstructionPtr {\n+    private List _lineNumbers = new ArrayList();\n+\n+    LineNumberTable(int nameIndex, Attributes owner) {\n+        super(nameIndex, owner);\n+    }\n+\n+    /**\n+     *  Return the line numbers held in this table.\n+     */\n+    public LineNumber[] getLineNumbers() {\n+        Collections.sort(_lineNumbers);\n+\n+        return (LineNumber[]) _lineNumbers.toArray(new LineNumber[_lineNumbers.size()]);\n+    }\n+\n+    /**\n+     *  Return the line number for the given program counter, or null if none.\n+     */\n+    public LineNumber getLineNumber(int pc) {\n+        for (int i = _lineNumbers.size() - 1; i >= 0; i--)\n+            if (((LineNumber) _lineNumbers.get(i))._target.getByteIndex() <= pc) {\n+                return (LineNumber) _lineNumbers.get(i);\n+            }\n+\n+        return null;\n+    }\n+\n+    /**\n+     *  Return the line number for the given instruction, or null if none.\n+     */\n+    public LineNumber getLineNumber(Instruction ins) {\n+        if (ins == null) {\n+            return null;\n+        }\n+\n+        return getLineNumber(ins.getByteIndex());\n+    }\n+\n+    /**\n+     *  Set the line numbers for the table.  This method is useful when\n+     *  importing line numbers from another method.\n+     */\n+    public void setLineNumbers(LineNumber[] lines) {\n+        clear();\n+\n+        if (lines != null) {\n+            for (int i = 0; i < lines.length; i++)\n+                addLineNumber(lines[i]);\n+        }\n+    }\n+\n+    /**\n+     *  Import a line number from another method.\n+     *\n+     *  @return the newly added line number\n+     */\n+    public LineNumber addLineNumber(LineNumber ln) {\n+        LineNumber line = addLineNumber();\n+        line.setStartPc(ln.getStartPc());\n+        line.setLine(ln.getLine());\n+\n+        return line;\n+    }\n+\n+    /**\n+     *  Add a new line number to this table.\n+     */\n+    public LineNumber addLineNumber() {\n+        LineNumber ln = new LineNumber(this);\n+        _lineNumbers.add(ln);\n+\n+        return ln;\n+    }\n+\n+    /**\n+     *  Add a new line number to this table.\n+      */\n+    public LineNumber addLineNumber(int startPc, int line) {\n+        LineNumber ln = addLineNumber();\n+        ln.setStartPc(startPc);\n+        ln.setLine(line);\n+\n+        return ln;\n+    }\n+\n+    /**\n+     *  Add a new line number to this table.\n+      */\n+    public LineNumber addLineNumber(Instruction start, int line) {\n+        LineNumber ln = addLineNumber();\n+        ln.setStart(start);\n+        ln.setLine(line);\n+\n+        return ln;\n+    }\n+\n+    /**\n+     *  Clear the line numbers.\n+     */\n+    public void clear() {\n+        for (int i = 0; i < _lineNumbers.size(); i++)\n+            ((LineNumber) _lineNumbers.get(i)).invalidate();\n+\n+        _lineNumbers.clear();\n+    }\n+\n+    /**\n+     *  Remove the given line.\n+     *\n+     *  @return true if the line was removed, false otherwise\n+     */\n+    public boolean removeLineNumber(LineNumber ln) {\n+        if ((ln == null) || !_lineNumbers.remove(ln)) {\n+            return false;\n+        }\n+\n+        ln.invalidate();\n+\n+        return true;\n+    }\n+\n+    /**\n+     *  Remove the line number for the given program counter.\n+     *\n+     *  @return true if the line was removed, false otherwise\n+     */\n+    public boolean removeLineNumber(int pc) {\n+        return removeLineNumber(getLineNumber(pc));\n+    }\n+\n+    /**\n+     *  Remove the line number for the given instruction.\n+     *\n+     *  @return true if the line was removed, false otherwise\n+     */\n+    public boolean removeLineNumber(Instruction ins) {\n+        return removeLineNumber(getLineNumber(ins));\n+    }\n+\n+    public void updateTargets() {\n+        for (int i = 0; i < _lineNumbers.size(); i++)\n+            ((LineNumber) _lineNumbers.get(i)).updateTargets();\n+    }\n+\n+    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n+        for (int i = 0; i < _lineNumbers.size(); i++)\n+            ((LineNumber) _lineNumbers.get(i)).replaceTarget(oldTarget,\n+                newTarget);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterLineNumberTable(this);\n+\n+        LineNumber[] lines = getLineNumbers();\n+\n+        for (int i = 0; i < lines.length; i++)\n+            lines[i].acceptVisit(visit);\n+\n+        visit.exitLineNumberTable(this);\n+    }\n+\n+    int getLength() {\n+        return 2 + (4 * _lineNumbers.size());\n+    }\n+\n+    void read(Attribute other) {\n+        setLineNumbers(((LineNumberTable) other).getLineNumbers());\n+    }\n+\n+    void read(DataInput in, int length) throws IOException {\n+        clear();\n+\n+        int numLines = in.readUnsignedShort();\n+\n+        LineNumber lineNumber;\n+\n+        for (int i = 0; i < numLines; i++) {\n+            lineNumber = addLineNumber();\n+            lineNumber.read(in);\n+        }\n+    }\n+\n+    void write(DataOutput out, int length) throws IOException {\n+        LineNumber[] lines = getLineNumbers();\n+        out.writeShort(lines.length);\n+\n+        for (int i = 0; i < lines.length; i++)\n+            lines[i].write(out);\n+    }\n+\n+    public Code getCode() {\n+        return (Code) getOwner();\n+    }\n+}"},{"sha":"a3b3d05c9071f703847d281b8f4a9d91fbce1840","filename":"serp/src/main/java/serp/bytecode/LoadInstruction.java","status":"added","additions":299,"deletions":0,"changes":299,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LoadInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LoadInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LoadInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+\n+/**\n+ *  <p>Loads a value from the locals table to the stack.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class LoadInstruction extends LocalVariableInstruction {\n+    private static final Class[][] _mappings = new Class[][] {\n+            { byte.class, int.class },\n+            { boolean.class, int.class },\n+            { char.class, int.class },\n+            { short.class, int.class },\n+            { void.class, int.class },\n+        };\n+    String _type = null;\n+\n+    LoadInstruction(Code owner) {\n+        super(owner);\n+    }\n+\n+    LoadInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    int getLength() {\n+        switch (getOpcode()) {\n+        case Constants.ILOAD:\n+        case Constants.LLOAD:\n+        case Constants.FLOAD:\n+        case Constants.DLOAD:\n+        case Constants.ALOAD:\n+            return super.getLength() + 1;\n+\n+        default:\n+            return super.getLength();\n+        }\n+    }\n+\n+    public int getStackChange() {\n+        switch (getOpcode()) {\n+        case Constants.LLOAD:\n+        case Constants.LLOAD0:\n+        case Constants.LLOAD1:\n+        case Constants.LLOAD2:\n+        case Constants.LLOAD3:\n+        case Constants.DLOAD:\n+        case Constants.DLOAD0:\n+        case Constants.DLOAD1:\n+        case Constants.DLOAD2:\n+        case Constants.DLOAD3:\n+            return 2;\n+\n+        case Constants.NOP:\n+            return 0;\n+\n+        default:\n+            return 1;\n+        }\n+    }\n+\n+    public int getLogicalStackChange() {\n+        switch (getOpcode()) {\n+        case Constants.NOP:\n+            return 0;\n+\n+        default:\n+            return 1;\n+        }\n+    }\n+\n+    public String getTypeName() {\n+        switch (getOpcode()) {\n+        case Constants.ILOAD:\n+        case Constants.ILOAD0:\n+        case Constants.ILOAD1:\n+        case Constants.ILOAD2:\n+        case Constants.ILOAD3:\n+            return int.class.getName();\n+\n+        case Constants.LLOAD:\n+        case Constants.LLOAD0:\n+        case Constants.LLOAD1:\n+        case Constants.LLOAD2:\n+        case Constants.LLOAD3:\n+            return long.class.getName();\n+\n+        case Constants.FLOAD:\n+        case Constants.FLOAD0:\n+        case Constants.FLOAD1:\n+        case Constants.FLOAD2:\n+        case Constants.FLOAD3:\n+            return float.class.getName();\n+\n+        case Constants.DLOAD:\n+        case Constants.DLOAD0:\n+        case Constants.DLOAD1:\n+        case Constants.DLOAD2:\n+        case Constants.DLOAD3:\n+            return double.class.getName();\n+\n+        case Constants.ALOAD:\n+        case Constants.ALOAD0:\n+        case Constants.ALOAD1:\n+        case Constants.ALOAD2:\n+        case Constants.ALOAD3:\n+            return Object.class.getName();\n+\n+        default:\n+            return _type;\n+        }\n+    }\n+\n+    public TypedInstruction setType(String type) {\n+        type = mapType(type, _mappings, true);\n+\n+        int local = getLocal();\n+\n+        // if an invalid type or local, revert to nop\n+        if ((type == null) || (local < 0)) {\n+            _type = type;\n+\n+            return (TypedInstruction) setOpcode(Constants.NOP);\n+        }\n+\n+        // valid opcode, unset saved type\n+        _type = null;\n+\n+        switch (type.charAt(0)) {\n+        case 'i':\n+            return (TypedInstruction) setOpcode((local > 3) ? Constants.ILOAD\n+                                                            : (Constants.ILOAD0 +\n+                local));\n+\n+        case 'l':\n+            return (TypedInstruction) setOpcode((local > 3) ? Constants.LLOAD\n+                                                            : (Constants.LLOAD0 +\n+                local));\n+\n+        case 'f':\n+            return (TypedInstruction) setOpcode((local > 3) ? Constants.FLOAD\n+                                                            : (Constants.FLOAD0 +\n+                local));\n+\n+        case 'd':\n+            return (TypedInstruction) setOpcode((local > 3) ? Constants.DLOAD\n+                                                            : (Constants.DLOAD0 +\n+                local));\n+\n+        default:\n+            return (TypedInstruction) setOpcode((local > 3) ? Constants.ALOAD\n+                                                            : (Constants.ALOAD0 +\n+                local));\n+        }\n+    }\n+\n+    /**\n+     *  Equivalent to <code>setLocal (0).setType (Object.class)</code>; the\n+     *  <code>this</code> ptr is always passed in local variable 0.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public LoadInstruction setThis() {\n+        return (LoadInstruction) setLocal(0).setType(Object.class);\n+    }\n+\n+    /**\n+     *  Equivalent to <code>getLocal () == 0 && getType () ==\n+     *  Object.class</code>; the <code>this</code> ptr\n+     *  is always passed in local variable 0.\n+     */\n+    public boolean isThis() {\n+        return (getLocal() == 0) && (getType() == Object.class);\n+    }\n+\n+    /**\n+     *  LoadInstructions are equal if the type they reference the same\n+     *  type and locals index or if either is unset.\n+     */\n+    public boolean equalsInstruction(Instruction other) {\n+        if (other == this) {\n+            return true;\n+        }\n+\n+        if (!super.equalsInstruction(other)) {\n+            return false;\n+        }\n+\n+        String type = getTypeName();\n+        String otherType = ((LoadInstruction) other).getTypeName();\n+\n+        return (type == null) || (otherType == null) || type.equals(otherType);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterLoadInstruction(this);\n+        visit.exitLoadInstruction(this);\n+    }\n+\n+    void read(Instruction orig) {\n+        super.read(orig);\n+\n+        LoadInstruction ins = (LoadInstruction) orig;\n+        _type = ins._type;\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        super.read(in);\n+\n+        switch (getOpcode()) {\n+        case Constants.ILOAD:\n+        case Constants.LLOAD:\n+        case Constants.FLOAD:\n+        case Constants.DLOAD:\n+        case Constants.ALOAD:\n+            setLocal(in.readUnsignedByte());\n+\n+            break;\n+        }\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        super.write(out);\n+\n+        switch (getOpcode()) {\n+        case Constants.ILOAD:\n+        case Constants.LLOAD:\n+        case Constants.FLOAD:\n+        case Constants.DLOAD:\n+        case Constants.ALOAD:\n+            out.writeByte(getLocal());\n+        }\n+    }\n+\n+    void calculateOpcode() {\n+        // taken care of when setting type\n+        setType(getTypeName());\n+    }\n+\n+    void calculateLocal() {\n+        switch (getOpcode()) {\n+        case Constants.ILOAD0:\n+        case Constants.LLOAD0:\n+        case Constants.FLOAD0:\n+        case Constants.DLOAD0:\n+        case Constants.ALOAD0:\n+            setLocal(0);\n+\n+            break;\n+\n+        case Constants.ILOAD1:\n+        case Constants.LLOAD1:\n+        case Constants.FLOAD1:\n+        case Constants.DLOAD1:\n+        case Constants.ALOAD1:\n+            setLocal(1);\n+\n+            break;\n+\n+        case Constants.ILOAD2:\n+        case Constants.LLOAD2:\n+        case Constants.FLOAD2:\n+        case Constants.DLOAD2:\n+        case Constants.ALOAD2:\n+            setLocal(2);\n+\n+            break;\n+\n+        case Constants.ILOAD3:\n+        case Constants.LLOAD3:\n+        case Constants.FLOAD3:\n+        case Constants.DLOAD3:\n+        case Constants.ALOAD3:\n+            setLocal(3);\n+\n+            break;\n+        }\n+    }\n+}"},{"sha":"3f875afa1be31b25d6e229c062175bbf07f3c29a","filename":"serp/src/main/java/serp/bytecode/Local.java","status":"added","additions":272,"deletions":0,"changes":272,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Local.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Local.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Local.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,272 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import serp.util.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>A local variable or local variable type.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public abstract class Local implements BCEntity, InstructionPtr {\n+    private LocalTable _owner = null;\n+    private InstructionPtrStrategy _target = new InstructionPtrStrategy(this);\n+    private int _length = 0;\n+    private int _nameIndex = 0;\n+    private int _descriptorIndex = 0;\n+    private int _index = 0;\n+\n+    Local(LocalTable owner) {\n+        _owner = owner;\n+    }\n+\n+    /**\n+     *  The owning table.\n+     */\n+    public LocalTable getTable() {\n+        return _owner;\n+    }\n+\n+    void invalidate() {\n+        _owner = null;\n+    }\n+\n+    //////////////////////////\n+    // Local index operations\n+    //////////////////////////\n+\n+    /**\n+     *  Get the local variable index of the current frame for this local.\n+     */\n+    public int getLocal() {\n+        return _index;\n+    }\n+\n+    /**\n+     *  Set the local variable index of the current frame for this local.\n+     */\n+    public void setLocal(int index) {\n+        _index = index;\n+    }\n+\n+    /**\n+     *  Return the parameter that this local corresponds to, or -1 if none.\n+     */\n+    public int getParam() {\n+        return getCode().getParamsIndex(getLocal());\n+    }\n+\n+    /**\n+     *  Set the method parameter that this local corresponds to.\n+     */\n+    public void setParam(int param) {\n+        setLocal(_owner.getCode().getLocalsIndex(param));\n+    }\n+\n+    /**\n+      *  Return the index into the code byte array at which this local starts.\n+     */\n+    public int getStartPc() {\n+        return _target.getByteIndex();\n+    }\n+\n+    ////////////////////////////\n+    // Start, Length operations\n+    ////////////////////////////\n+\n+    /**\n+      *  Return the instruction marking the beginning of this local.\n+     */\n+    public Instruction getStart() {\n+        return _target.getTargetInstruction();\n+    }\n+\n+    /**\n+      *  Set the index into the code byte array at which this local starts.\n+     */\n+    public void setStartPc(int startPc) {\n+        _target.setByteIndex(startPc);\n+    }\n+\n+    /**\n+     *  Set the {@link Instruction} marking the beginning this local.\n+     *  The instruction must already be a part of the method.\n+     *  WARNING: if this instruction is deleted, the results are undefined.\n+     */\n+    public void setStart(Instruction instruction) {\n+        _target.setTargetInstruction(instruction);\n+    }\n+\n+    public void updateTargets() {\n+        _target.updateTargets();\n+    }\n+\n+    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n+        _target.replaceTarget(oldTarget, newTarget);\n+    }\n+\n+    /**\n+     *  Get the number of bytes for which this local has a value in\n+     *  the code byte array.\n+     */\n+    public int getLength() {\n+        return _length;\n+    }\n+\n+    /**\n+     *  Set the number of bytes for which this local has a value in\n+     *  the code byte array.\n+     */\n+    public void setLength(int length) {\n+        _length = length;\n+    }\n+\n+    /////////////////////////\n+    // Name, Type operations\n+    /////////////////////////\n+\n+    /**\n+     *  Return the {@link ConstantPool} index of the {@link UTF8Entry} that\n+     *  describes the name of this local.  Defaults to 0.\n+     */\n+    public int getNameIndex() {\n+        return _nameIndex;\n+    }\n+\n+    /**\n+     *  Set the {@link ConstantPool} index of the {@link UTF8Entry} that\n+     *  describes the name of this local.\n+     */\n+    public void setNameIndex(int nameIndex) {\n+        _nameIndex = nameIndex;\n+    }\n+\n+    /**\n+     *  Return the name of this local, or null if unset.\n+     */\n+    public String getName() {\n+        if (getNameIndex() == 0) {\n+            return null;\n+        }\n+\n+        return ((UTF8Entry) getPool().getEntry(getNameIndex())).getValue();\n+    }\n+\n+    /**\n+     *  Set the name of this inner local.\n+     */\n+    public void setName(String name) {\n+        if (name == null) {\n+            setNameIndex(0);\n+        } else {\n+            setNameIndex(getPool().findUTF8Entry(name, true));\n+        }\n+    }\n+\n+    /**\n+     *  Return the {@link ConstantPool} index of the {@link UTF8Entry} that\n+     *  describes this local.  Defaults to 0.\n+     */\n+    public int getTypeIndex() {\n+        return _descriptorIndex;\n+    }\n+\n+    /**\n+     *  Set the {@link ConstantPool} index of the {@link UTF8Entry} that\n+     *  describes this local.\n+     */\n+    public void setTypeIndex(int index) {\n+        _descriptorIndex = index;\n+    }\n+\n+    /**\n+     *  Return the full name of the local's type, or null if unset.\n+     */\n+    public String getTypeName() {\n+        if (getTypeIndex() == 0) {\n+            return null;\n+        }\n+\n+        UTF8Entry entry = (UTF8Entry) getPool().getEntry(getTypeIndex());\n+\n+        return getProject().getNameCache()\n+                   .getExternalForm(entry.getValue(), false);\n+    }\n+\n+    /**\n+     *  Set the type of this local.\n+     */\n+    public void setType(String type) {\n+        if (type == null) {\n+            setTypeIndex(0);\n+        } else {\n+            type = getProject().getNameCache().getInternalForm(type, true);\n+            setTypeIndex(getPool().findUTF8Entry(type, true));\n+        }\n+    }\n+\n+    ///////////////////////////\n+    // BCEntity implementation\n+    ///////////////////////////\n+    public Project getProject() {\n+        return _owner.getProject();\n+    }\n+\n+    public ConstantPool getPool() {\n+        return _owner.getPool();\n+    }\n+\n+    public ClassLoader getClassLoader() {\n+        return _owner.getClassLoader();\n+    }\n+\n+    public boolean isValid() {\n+        return _owner != null;\n+    }\n+\n+    //////////////////\n+    // I/O operations\n+    //////////////////\n+    void read(DataInput in) throws IOException {\n+        setStartPc(in.readUnsignedShort());\n+        setLength(in.readUnsignedShort());\n+        setNameIndex(in.readUnsignedShort());\n+        setTypeIndex(in.readUnsignedShort());\n+        setLocal(in.readUnsignedShort());\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        out.writeShort(getStartPc());\n+        out.writeShort(getLength());\n+        out.writeShort(getNameIndex());\n+        out.writeShort(getTypeIndex());\n+        out.writeShort(getLocal());\n+    }\n+\n+    public Code getCode() {\n+        return _owner.getCode();\n+    }\n+}"},{"sha":"71be28609d2ec8db1dbd77cfd13d02396d1cc3f4","filename":"serp/src/main/java/serp/bytecode/LocalTable.java","status":"added","additions":238,"deletions":0,"changes":238,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LocalTable.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LocalTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalTable.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Code blocks compiled from source have local tables mapping\n+ *  locals used in opcodes to their names and descriptions.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public abstract class LocalTable extends Attribute implements InstructionPtr {\n+    private List _locals = new ArrayList();\n+\n+    LocalTable(int nameIndex, Attributes owner) {\n+        super(nameIndex, owner);\n+    }\n+\n+    /**\n+     *  Return all the locals of this method.\n+     */\n+    public Local[] getLocals() {\n+        return (Local[]) _locals.toArray(newLocalArray(_locals.size()));\n+    }\n+\n+    /**\n+     *  Return the local with the given locals index, or null if none.\n+     */\n+    public Local getLocal(int local) {\n+        for (int i = 0; i < _locals.size(); i++)\n+            if (((Local) _locals.get(i)).getLocal() == local) {\n+                return (Local) _locals.get(i);\n+            }\n+\n+        return null;\n+    }\n+\n+    /**\n+     *  Return the local with the given name, or null if none.  If multiple\n+     *  locals have the given name, which is returned is undefined.\n+     */\n+    public Local getLocal(String name) {\n+        String loc;\n+\n+        for (int i = 0; i < _locals.size(); i++) {\n+            loc = ((Local) _locals.get(i)).getName();\n+\n+            if (((loc == null) && (name == null)) ||\n+                    ((loc != null) && loc.equals(name))) {\n+                return (Local) _locals.get(i);\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     *  Return all locals with the given name, or empty array if none.\n+     */\n+    public Local[] getLocals(String name) {\n+        List matches = new LinkedList();\n+        String loc;\n+\n+        for (int i = 0; i < _locals.size(); i++) {\n+            loc = ((Local) _locals.get(i)).getName();\n+\n+            if (((loc == null) && (name == null)) ||\n+                    ((loc != null) && loc.equals(name))) {\n+                matches.add(_locals.get(i));\n+            }\n+        }\n+\n+        return (Local[]) matches.toArray(newLocalArray(matches.size()));\n+    }\n+\n+    /**\n+     *  Set the locals of this table.  This method is useful when\n+     *  importing locals from another method.\n+     */\n+    public void setLocals(Local[] locals) {\n+        clear();\n+\n+        if (locals != null) {\n+            for (int i = 0; i < locals.length; i++)\n+                addLocal(locals[i]);\n+        }\n+    }\n+\n+    /**\n+     *  Import a local from another method/class.  Note that\n+     *  the program counter and length from the given local is copied\n+      *  directly, and thus will be incorrect unless this method is the same\n+      *  as the one the local is copied from, or the pc and length are reset.\n+     */\n+    public Local addLocal(Local local) {\n+        Local newLocal = addLocal(local.getName(), local.getTypeName());\n+        newLocal.setStartPc(local.getStartPc());\n+        newLocal.setLength(local.getLength());\n+\n+        return newLocal;\n+    }\n+\n+    /**\n+     *  Add a local to this table.\n+     */\n+    public Local addLocal() {\n+        Local local = newLocal();\n+        _locals.add(local);\n+\n+        return local;\n+    }\n+\n+    /**\n+     *  Create a new element of this table.\n+     */\n+    protected abstract Local newLocal();\n+\n+    /**\n+     *  Create a new array.\n+     */\n+    protected abstract Local[] newLocalArray(int size);\n+\n+    /**\n+     *  Add a local to this table.\n+     */\n+    public Local addLocal(String name, String type) {\n+        Local local = addLocal();\n+        local.setName(name);\n+        local.setType(type);\n+\n+        return local;\n+    }\n+\n+    /**\n+     *  Clear all locals from this table.\n+     */\n+    public void clear() {\n+        for (int i = 0; i < _locals.size(); i++)\n+            ((Local) _locals.get(i)).invalidate();\n+\n+        _locals.clear();\n+    }\n+\n+    /**\n+     *  Removes the local with the given locals index from the table.\n+     *\n+     *  @return true if a local was removed, false otherwise\n+     */\n+    public boolean removeLocal(int local) {\n+        return removeLocal(getLocal(local));\n+    }\n+\n+    /**\n+     *  Removes the local with the given name from this method.\n+     *\n+     *  @return true if a local was removed, false otherwise\n+     */\n+    public boolean removeLocal(String name) {\n+        return removeLocal(getLocal(name));\n+    }\n+\n+    /**\n+      *  Removes a local from this method.  After this method, the local\n+     *  will be invalid, and the result of any operations on it is undefined.\n+     *\n+     *  @return true if a local was removed, false otherwise\n+     */\n+    public boolean removeLocal(Local local) {\n+        if ((local == null) || !_locals.remove(local)) {\n+            return false;\n+        }\n+\n+        local.invalidate();\n+\n+        return true;\n+    }\n+\n+    public void updateTargets() {\n+        for (int i = 0; i < _locals.size(); i++)\n+            ((Local) _locals.get(i)).updateTargets();\n+    }\n+\n+    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n+        for (int i = 0; i < _locals.size(); i++)\n+            ((Local) _locals.get(i)).replaceTarget(oldTarget, newTarget);\n+    }\n+\n+    public Code getCode() {\n+        return (Code) getOwner();\n+    }\n+\n+    int getLength() {\n+        return 2 + (10 * _locals.size());\n+    }\n+\n+    void read(Attribute other) {\n+        setLocals(((LocalTable) other).getLocals());\n+    }\n+\n+    void read(DataInput in, int length) throws IOException {\n+        clear();\n+\n+        int numLocals = in.readUnsignedShort();\n+\n+        Local Local;\n+\n+        for (int i = 0; i < numLocals; i++) {\n+            Local = addLocal();\n+            Local.read(in);\n+        }\n+    }\n+\n+    void write(DataOutput out, int length) throws IOException {\n+        out.writeShort(_locals.size());\n+\n+        for (int i = 0; i < _locals.size(); i++)\n+            ((Local) _locals.get(i)).write(out);\n+    }\n+}"},{"sha":"fffc6bb585153efdb321a5c6d17fc42085032e4f","filename":"serp/src/main/java/serp/bytecode/LocalVariable.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LocalVariable.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LocalVariable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalVariable.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import serp.util.*;\n+\n+\n+/**\n+ *  <p>A local variable contains the name, description, index and scope\n+ *  of a local used in opcodes.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class LocalVariable extends Local {\n+    LocalVariable(LocalVariableTable owner) {\n+        super(owner);\n+    }\n+\n+    /**\n+     *  The owning table.\n+     */\n+    public LocalVariableTable getLocalVariableTable() {\n+        return (LocalVariableTable) getTable();\n+    }\n+\n+    /**\n+     *  Return the type of this local.\n+     *  If the type has not been set, this method will return null.\n+     */\n+    public Class getType() {\n+        String type = getTypeName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return Strings.toClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Return the type of this local.\n+     *  If the type has not been set, this method will return null.\n+     */\n+    public BCClass getTypeBC() {\n+        String type = getTypeName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return getProject().loadClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Set the type of this local.\n+     */\n+    public void setType(Class type) {\n+        if (type == null) {\n+            setType((String) null);\n+        } else {\n+            setType(type.getName());\n+        }\n+    }\n+\n+    /**\n+     *  Set the type of this local.\n+     */\n+    public void setType(BCClass type) {\n+        if (type == null) {\n+            setType((String) null);\n+        } else {\n+            setType(type.getName());\n+        }\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterLocalVariable(this);\n+        visit.exitLocalVariable(this);\n+    }\n+}"},{"sha":"4ab6be9c47d49ea53f82de3a8662082699d6f3b7","filename":"serp/src/main/java/serp/bytecode/LocalVariableInstruction.java","status":"added","additions":177,"deletions":0,"changes":177,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LocalVariableInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LocalVariableInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalVariableInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,177 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+\n+/**\n+ *  <p>An instruction that has an argument of an index into the\n+ *  local variable table of the current frame.  This includes most of the\n+ *  <code>load</code> and <code>store</code> instructions.</p>\n+ *\n+ *  <p>The local variable table size is fixed by the <code>maxLocals</code>\n+ *  property of the code block.  Long and double types take up 2 local variable\n+ *  indexes.</p>\n+ *\n+ *  <p>Parameter values to methods are loaded into the local variable table\n+ *  prior to the execution of the first instruction.  The 0 index of the\n+ *  table is set to the instance of the class the method is being invoked\n+ *  on.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public abstract class LocalVariableInstruction extends TypedInstruction {\n+    private int _index = -1;\n+\n+    LocalVariableInstruction(Code owner) {\n+        super(owner);\n+    }\n+\n+    LocalVariableInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+        calculateLocal();\n+    }\n+\n+    public String getTypeName() {\n+        return null;\n+    }\n+\n+    public TypedInstruction setType(String type) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+      *  Return the index of the local variable that this instruction\n+     *  operates on.\n+     */\n+    public int getLocal() {\n+        return _index;\n+    }\n+\n+    /**\n+      *  Set the index of the local variable that this instruction\n+     *  operates on.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public LocalVariableInstruction setLocal(int index) {\n+        _index = index;\n+        calculateOpcode();\n+\n+        return this;\n+    }\n+\n+    /**\n+     *  Return the parameter that this instruction operates on, or -1 if none.\n+     */\n+    public int getParam() {\n+        return getCode().getParamsIndex(getLocal());\n+    }\n+\n+    /**\n+     *  Set the method parameter that this instruction operates on.  This\n+     *  will set both the local index and the type of the instruction based\n+     *  on the current method parameters.\n+     */\n+    public LocalVariableInstruction setParam(int param) {\n+        int local = getCode().getLocalsIndex(param);\n+\n+        if (local != -1) {\n+            BCMethod method = getCode().getMethod();\n+            setType(method.getParamNames()[param]);\n+        }\n+\n+        return setLocal(local);\n+    }\n+\n+    /**\n+      *  Return the local variable object this instruction\n+     *  operates on, or null if none.\n+     *\n+     *  @see LocalVariableTable#getLocalVariable(int)\n+     */\n+    public LocalVariable getLocalVariable() {\n+        LocalVariableTable table = getCode().getLocalVariableTable(false);\n+\n+        if (table == null) {\n+            return null;\n+        }\n+\n+        return table.getLocalVariable(getLocal());\n+    }\n+\n+    /**\n+      *  Set the local variable object this instruction\n+     *  operates on.  This method will set both the type and local index\n+     *  of this instruction from the given local variable.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public LocalVariableInstruction setLocalVariable(LocalVariable local) {\n+        if (local == null) {\n+            return setLocal(-1);\n+        } else {\n+            String type = local.getTypeName();\n+\n+            if (type != null) {\n+                setType(type);\n+            }\n+\n+            return setLocal(local.getLocal());\n+        }\n+    }\n+\n+    /**\n+     *  Two local variable instructions are equal if the local index they\n+     *  reference is equal or if either index is 0/unset.\n+     */\n+    public boolean equalsInstruction(Instruction other) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (!getClass().equals(other.getClass())) {\n+            return false;\n+        }\n+\n+        LocalVariableInstruction ins = (LocalVariableInstruction) other;\n+        int index = getLocal();\n+        int insIndex = ins.getLocal();\n+\n+        return (index == -1) || (insIndex == -1) || (index == insIndex);\n+    }\n+\n+    void read(Instruction orig) {\n+        super.read(orig);\n+        setLocal(((LocalVariableInstruction) orig).getLocal());\n+    }\n+\n+    /**\n+     *  Subclasses with variable opcodes can use this method to be\n+     *  notified that information possibly affecting the opcode has been\n+     *  changed.\n+     */\n+    void calculateOpcode() {\n+    }\n+\n+    /**\n+     *  Subclasses can use this method to calculate\n+     *  the locals index based on their opcode.\n+     */\n+    void calculateLocal() {\n+    }\n+}"},{"sha":"9238d9babe8c6a9de2998845188ab89460a4a2dc","filename":"serp/src/main/java/serp/bytecode/LocalVariableTable.java","status":"added","additions":121,"deletions":0,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LocalVariableTable.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LocalVariableTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalVariableTable.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+\n+/**\n+ *  <p>Code blocks compiled from source have local variable tables mapping\n+ *  locals used in opcodes to their names and descriptions.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class LocalVariableTable extends LocalTable {\n+    LocalVariableTable(int nameIndex, Attributes owner) {\n+        super(nameIndex, owner);\n+    }\n+\n+    /**\n+     *  Return all the locals of this method.\n+     */\n+    public LocalVariable[] getLocalVariables() {\n+        return (LocalVariable[]) getLocals();\n+    }\n+\n+    /**\n+     *  Return the local with the given locals index, or null if none.\n+     */\n+    public LocalVariable getLocalVariable(int local) {\n+        return (LocalVariable) getLocal(local);\n+    }\n+\n+    /**\n+     *  Return the local with the given name, or null if none.  If multiple\n+     *  locals have the given name, which is returned is undefined.\n+     */\n+    public LocalVariable getLocalVariable(String name) {\n+        return (LocalVariable) getLocal(name);\n+    }\n+\n+    /**\n+     *  Return all locals with the given name, or empty array if none.\n+     */\n+    public LocalVariable[] getLocalVariables(String name) {\n+        return (LocalVariable[]) getLocals(name);\n+    }\n+\n+    /**\n+     *  Import a local from another method/class.  Note that\n+     *  the program counter and length from the given local is copied\n+      *  directly, and thus will be incorrect unless this method is the same\n+      *  as the one the local is copied from, or the pc and length are reset.\n+     */\n+    public LocalVariable addLocalVariable(LocalVariable local) {\n+        return (LocalVariable) addLocal(local);\n+    }\n+\n+    /**\n+     *  Add a local to this table.\n+     */\n+    public LocalVariable addLocalVariable() {\n+        return (LocalVariable) addLocal();\n+    }\n+\n+    /**\n+     *  Add a local to this table.\n+     */\n+    public LocalVariable addLocalVariable(String name, String type) {\n+        return (LocalVariable) addLocal(name, type);\n+    }\n+\n+    /**\n+     *  Add a local to this table.\n+     */\n+    public LocalVariable addLocalVariable(String name, Class type) {\n+        String typeName = (type == null) ? null : type.getName();\n+\n+        return addLocalVariable(name, typeName);\n+    }\n+\n+    /**\n+     *  Add a local to this table.\n+     */\n+    public LocalVariable addLocalVariable(String name, BCClass type) {\n+        String typeName = (type == null) ? null : type.getName();\n+\n+        return addLocalVariable(name, typeName);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterLocalVariableTable(this);\n+\n+        LocalVariable[] locals = (LocalVariable[]) getLocals();\n+\n+        for (int i = 0; i < locals.length; i++)\n+            locals[i].acceptVisit(visit);\n+\n+        visit.exitLocalVariableTable(this);\n+    }\n+\n+    protected Local newLocal() {\n+        return new LocalVariable(this);\n+    }\n+\n+    protected Local[] newLocalArray(int size) {\n+        return new LocalVariable[size];\n+    }\n+}"},{"sha":"c18a66ac7438dc6b0b768baa9bf50bbf90c45ac8","filename":"serp/src/main/java/serp/bytecode/LocalVariableType.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LocalVariableType.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LocalVariableType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalVariableType.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+\n+/**\n+ *  <p>A local variable type contains the name, signature, index and scope\n+ *  of a generics-using local used in opcodes.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class LocalVariableType extends Local {\n+    LocalVariableType(LocalVariableTypeTable owner) {\n+        super(owner);\n+    }\n+\n+    /**\n+     *  The owning table.\n+     */\n+    public LocalVariableTypeTable getLocalVariableTypeTable() {\n+        return (LocalVariableTypeTable) getTable();\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterLocalVariableType(this);\n+        visit.exitLocalVariableType(this);\n+    }\n+}"},{"sha":"de44a4b9cbaa803a00d2e7fd11638fb126ea9e8e","filename":"serp/src/main/java/serp/bytecode/LocalVariableTypeTable.java","status":"added","additions":103,"deletions":0,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LocalVariableTypeTable.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LocalVariableTypeTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalVariableTypeTable.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+\n+/**\n+ *  <p>Code blocks compiled from source have local variable type tables mapping\n+ *  generics-using locals used in opcodes to their names and signatures.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class LocalVariableTypeTable extends LocalTable {\n+    LocalVariableTypeTable(int nameIndex, Attributes owner) {\n+        super(nameIndex, owner);\n+    }\n+\n+    /**\n+     *  Return all the locals of this method.\n+     */\n+    public LocalVariableType[] getLocalVariableTypes() {\n+        return (LocalVariableType[]) getLocals();\n+    }\n+\n+    /**\n+     *  Return the local with the given locals index, or null if none.\n+     */\n+    public LocalVariableType getLocalVariableType(int local) {\n+        return (LocalVariableType) getLocal(local);\n+    }\n+\n+    /**\n+     *  Return the local with the given name, or null if none.  If multiple\n+     *  locals have the given name, which is returned is undefined.\n+     */\n+    public LocalVariableType getLocalVariableType(String name) {\n+        return (LocalVariableType) getLocal(name);\n+    }\n+\n+    /**\n+     *  Return all locals with the given name, or empty array if none.\n+     */\n+    public LocalVariableType[] getLocalVariableTypes(String name) {\n+        return (LocalVariableType[]) getLocals(name);\n+    }\n+\n+    /**\n+     *  Import a local from another method/class.  Note that\n+     *  the program counter and length from the given local is copied\n+      *  directly, and thus will be incorrect unless this method is the same\n+      *  as the one the local is copied from, or the pc and length are reset.\n+     */\n+    public LocalVariableType addLocalVariableType(LocalVariableType local) {\n+        return (LocalVariableType) addLocal(local);\n+    }\n+\n+    /**\n+     *  Add a local to this table.\n+     */\n+    public LocalVariableType addLocalVariableType() {\n+        return (LocalVariableType) addLocal();\n+    }\n+\n+    /**\n+     *  Add a local to this table.\n+     */\n+    public LocalVariableType addLocalVariableType(String name, String type) {\n+        return (LocalVariableType) addLocal(name, type);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterLocalVariableTypeTable(this);\n+\n+        LocalVariableType[] locals = (LocalVariableType[]) getLocals();\n+\n+        for (int i = 0; i < locals.length; i++)\n+            locals[i].acceptVisit(visit);\n+\n+        visit.exitLocalVariableTypeTable(this);\n+    }\n+\n+    protected Local newLocal() {\n+        return new LocalVariableType(this);\n+    }\n+\n+    protected Local[] newLocalArray(int size) {\n+        return new LocalVariableType[size];\n+    }\n+}"},{"sha":"51ab34a94cc9ff0a55cb4733d9acfa05357038f0","filename":"serp/src/main/java/serp/bytecode/LookupSwitchInstruction.java","status":"added","additions":255,"deletions":0,"changes":255,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LookupSwitchInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/LookupSwitchInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LookupSwitchInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,255 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import serp.util.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>The <code>lookupswitch</code> instruction.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class LookupSwitchInstruction extends JumpInstruction {\n+    // case info\n+    private List _matches = new LinkedList();\n+    private List _cases = new LinkedList();\n+\n+    LookupSwitchInstruction(Code owner) {\n+        super(owner, Constants.LOOKUPSWITCH);\n+    }\n+\n+    int getLength() {\n+        // don't call super.getLength(), cause JumpInstruction will return\n+        // value assuming this is an 'if' or 'goto' instruction\n+        int length = 1;\n+\n+        // make the first byte of the 'default' a multiple of 4 from the\n+        // start of the method\n+        int byteIndex = getByteIndex() + 1;\n+\n+        for (; (byteIndex % 4) != 0; byteIndex++, length++)\n+            ;\n+\n+        // default, npairs\n+        length += 8;\n+\n+        // pairs\n+        length += (8 * _matches.size());\n+\n+        return length;\n+    }\n+\n+    public int getLogicalStackChange() {\n+        return getStackChange();\n+    }\n+\n+    public int getStackChange() {\n+        return -1;\n+    }\n+\n+    /**\n+     *  Synonymous with {@link #getTarget}.\n+     */\n+    public Instruction getDefaultTarget() {\n+        return getTarget();\n+    }\n+\n+    /**\n+     *  Synonymous with {@link #setTarget}.\n+     */\n+    public LookupSwitchInstruction setDefaultTarget(Instruction ins) {\n+        return (LookupSwitchInstruction) setTarget(ins);\n+    }\n+\n+    /**\n+     *  Synonymous with {@link #getOffset}.\n+     */\n+    public int getDefaultOffset() {\n+        return getOffset();\n+    }\n+\n+    /**\n+     *  Synonymous with {@link #setOffset}.\n+     */\n+    public LookupSwitchInstruction setDefaultOffset(int offset) {\n+        setOffset(offset);\n+\n+        return this;\n+    }\n+\n+    /**\n+     *  Set the match-jumppt pairs for this switch.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public LookupSwitchInstruction setCases(int[] matches, Instruction[] targets) {\n+        _matches.clear();\n+        _cases.clear();\n+\n+        for (int i = 0; i < matches.length; i++)\n+            _matches.add(Numbers.valueOf(matches[i]));\n+\n+        for (int i = 0; i < targets.length; i++) {\n+            InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n+            next.setTargetInstruction(targets[i]);\n+            _cases.add(next);\n+        }\n+\n+        return this;\n+    }\n+\n+    public int[] getOffsets() {\n+        int bi = getByteIndex();\n+        int[] offsets = new int[_cases.size()];\n+\n+        for (int i = 0; i < offsets.length; i++)\n+            offsets[i] = ((InstructionPtrStrategy) _cases.get(i)).getByteIndex() -\n+                bi;\n+\n+        return offsets;\n+    }\n+\n+    /**\n+     *  Return the values of the case statements for this switch.\n+     */\n+    public int[] getMatches() {\n+        int[] matches = new int[_matches.size()];\n+        Iterator itr = _matches.iterator();\n+\n+        for (int i = 0; i < matches.length; i++)\n+            matches[i] = ((Integer) itr.next()).intValue();\n+\n+        return matches;\n+    }\n+\n+    /**\n+     *  Return the targets of the case statements for this switch.\n+     */\n+    public Instruction[] getTargets() {\n+        Instruction[] result = new Instruction[_cases.size()];\n+\n+        for (int i = 0; i < result.length; i++)\n+            result[i] = ((InstructionPtrStrategy) _cases.get(i)).getTargetInstruction();\n+\n+        return result;\n+    }\n+\n+    /**\n+     *  Add a case to this switch.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public LookupSwitchInstruction addCase(int match, Instruction target) {\n+        _matches.add(Numbers.valueOf(match));\n+        _cases.add(new InstructionPtrStrategy(this, target));\n+\n+        return this;\n+    }\n+\n+    private Instruction findJumpPoint(int jumpByteIndex, List inss) {\n+        Instruction ins;\n+\n+        for (Iterator itr = inss.iterator(); itr.hasNext();) {\n+            ins = (Instruction) itr.next();\n+\n+            if (ins.getByteIndex() == jumpByteIndex) {\n+                return ins;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public void updateTargets() {\n+        super.updateTargets();\n+\n+        for (Iterator itr = _cases.iterator(); itr.hasNext();)\n+            ((InstructionPtrStrategy) itr.next()).updateTargets();\n+    }\n+\n+    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n+        super.replaceTarget(oldTarget, newTarget);\n+\n+        for (Iterator itr = _cases.iterator(); itr.hasNext();)\n+            ((InstructionPtrStrategy) itr.next()).replaceTarget(oldTarget,\n+                newTarget);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterLookupSwitchInstruction(this);\n+        visit.exitLookupSwitchInstruction(this);\n+    }\n+\n+    void read(Instruction orig) {\n+        super.read(orig);\n+\n+        LookupSwitchInstruction ins = (LookupSwitchInstruction) orig;\n+        _matches = new LinkedList(ins._matches);\n+        _cases.clear();\n+\n+        for (Iterator itr = ins._cases.iterator(); itr.hasNext();) {\n+            InstructionPtrStrategy origPtr = (InstructionPtrStrategy) itr.next();\n+            InstructionPtrStrategy newPtr = new InstructionPtrStrategy(this);\n+            newPtr.setByteIndex(origPtr.getByteIndex());\n+            _cases.add(newPtr);\n+        }\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        // don't call super\n+        int bi = getByteIndex();\n+\n+        for (int byteIndex = bi + 1; (byteIndex % 4) != 0; byteIndex++)\n+            in.readByte();\n+\n+        setOffset(in.readInt());\n+\n+        _matches.clear();\n+        _cases.clear();\n+\n+        for (int i = 0, pairCount = in.readInt(); i < pairCount; i++) {\n+            _matches.add(Numbers.valueOf(in.readInt()));\n+\n+            InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n+            next.setByteIndex(bi + in.readInt());\n+            _cases.add(next);\n+        }\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        // don't call super\n+        int bi = getByteIndex();\n+\n+        for (int byteIndex = bi + 1; (byteIndex % 4) != 0; byteIndex++)\n+            out.writeByte(0);\n+\n+        out.writeInt(getOffset());\n+        out.writeInt(_matches.size());\n+\n+        for (int i = 0; i < _matches.size(); i++) {\n+            out.writeInt(((Integer) _matches.get(i)).intValue());\n+            out.writeInt(((InstructionPtrStrategy) _cases.get(i)).getByteIndex() -\n+                bi);\n+        }\n+    }\n+}"},{"sha":"b3a541b60125897b28ff75f8a92810e7c03dd392","filename":"serp/src/main/java/serp/bytecode/MathInstruction.java","status":"added","additions":294,"deletions":0,"changes":294,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/MathInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/MathInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MathInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>One of the math operations defined in the {@link Constants} interface.\n+ *  Changing the type or operation of the instruction will automatically\n+ *  update the underlying opcode.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class MathInstruction extends TypedInstruction {\n+    private static final Class[][] _mappings = new Class[][] {\n+            { byte.class, int.class },\n+            { boolean.class, int.class },\n+            { char.class, int.class },\n+            { short.class, int.class },\n+            { void.class, int.class },\n+            { Object.class, int.class },\n+        };\n+    private int _op = -1;\n+    private String _type = null;\n+\n+    MathInstruction(Code owner) {\n+        super(owner);\n+    }\n+\n+    MathInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+        _op = getOperation();\n+    }\n+\n+    public int getStackChange() {\n+        int op = getOperation();\n+\n+        if ((op == Constants.MATH_NEG) || (getOpcode() == Constants.NOP)) {\n+            return 0;\n+        }\n+\n+        String type = getTypeName();\n+\n+        if (long.class.getName().equals(type) ||\n+                double.class.getName().equals(type)) {\n+            switch (getOpcode()) {\n+            case (Constants.LSHL):\n+            case (Constants.LSHR):\n+            case (Constants.LUSHR):\n+                return -1;\n+\n+            default:\n+                return -2;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    public int getLogicalStackChange() {\n+        int op = getOperation();\n+\n+        if ((op == Constants.MATH_NEG) || (getOpcode() == Constants.NOP)) {\n+            return 0;\n+        }\n+\n+        return -1;\n+    }\n+\n+    public String getTypeName() {\n+        switch (getOpcode()) {\n+        case Constants.IADD:\n+        case Constants.ISUB:\n+        case Constants.IMUL:\n+        case Constants.IDIV:\n+        case Constants.IREM:\n+        case Constants.INEG:\n+        case Constants.ISHL:\n+        case Constants.ISHR:\n+        case Constants.IUSHR:\n+        case Constants.IAND:\n+        case Constants.IOR:\n+        case Constants.IXOR:\n+            return int.class.getName();\n+\n+        case Constants.LADD:\n+        case Constants.LSUB:\n+        case Constants.LMUL:\n+        case Constants.LDIV:\n+        case Constants.LREM:\n+        case Constants.LNEG:\n+        case Constants.LSHL:\n+        case Constants.LSHR:\n+        case Constants.LUSHR:\n+        case Constants.LAND:\n+        case Constants.LOR:\n+        case Constants.LXOR:\n+            return long.class.getName();\n+\n+        case Constants.FADD:\n+        case Constants.FSUB:\n+        case Constants.FMUL:\n+        case Constants.FDIV:\n+        case Constants.FREM:\n+        case Constants.FNEG:\n+            return float.class.getName();\n+\n+        case Constants.DADD:\n+        case Constants.DSUB:\n+        case Constants.DMUL:\n+        case Constants.DDIV:\n+        case Constants.DREM:\n+        case Constants.DNEG:\n+            return double.class.getName();\n+\n+        default:\n+            return _type;\n+        }\n+    }\n+\n+    public TypedInstruction setType(String type) {\n+        type = mapType(type, _mappings, true);\n+\n+        // if an invalid type or op, revert to nop\n+        if ((type == null) || (_op < 0)) {\n+            _type = type;\n+\n+            return (TypedInstruction) setOpcode(Constants.NOP);\n+        }\n+\n+        // valid opcode, unset saved type\n+        _type = null;\n+\n+        switch (type.charAt(0)) {\n+        case 'i':\n+            return (TypedInstruction) setOpcode(_op);\n+\n+        case 'l':\n+            return (TypedInstruction) setOpcode(_op + 1);\n+\n+        case 'f':\n+            return (TypedInstruction) setOpcode(_op + 2);\n+\n+        case 'd':\n+            return (TypedInstruction) setOpcode(_op + 3);\n+\n+        default:\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    /**\n+      *  Set the math operation to be performed.  This should be one of the\n+     *  math constant defined in {@link Constants}.\n+      *\n+     *  @return this instruction, for method chaining\n+     */\n+    public MathInstruction setOperation(int operation) {\n+        _op = operation;\n+\n+        // this calculates the opcode\n+        setType(getTypeName());\n+\n+        return this;\n+    }\n+\n+    /**\n+      *  Return the operation for this math instruction; will be one of the\n+     *  math constant defined in {@link Constants}, or -1 if\n+      *  unset.\n+     */\n+    public int getOperation() {\n+        switch (getOpcode()) {\n+        case Constants.IADD:\n+        case Constants.LADD:\n+        case Constants.FADD:\n+        case Constants.DADD:\n+            return Constants.MATH_ADD;\n+\n+        case Constants.ISUB:\n+        case Constants.LSUB:\n+        case Constants.FSUB:\n+        case Constants.DSUB:\n+            return Constants.MATH_SUB;\n+\n+        case Constants.IMUL:\n+        case Constants.LMUL:\n+        case Constants.FMUL:\n+        case Constants.DMUL:\n+            return Constants.MATH_MUL;\n+\n+        case Constants.IDIV:\n+        case Constants.LDIV:\n+        case Constants.FDIV:\n+        case Constants.DDIV:\n+            return Constants.MATH_DIV;\n+\n+        case Constants.IREM:\n+        case Constants.LREM:\n+        case Constants.FREM:\n+        case Constants.DREM:\n+            return Constants.MATH_REM;\n+\n+        case Constants.INEG:\n+        case Constants.LNEG:\n+        case Constants.FNEG:\n+        case Constants.DNEG:\n+            return Constants.MATH_NEG;\n+\n+        case Constants.ISHL:\n+        case Constants.LSHL:\n+            return Constants.MATH_SHL;\n+\n+        case Constants.ISHR:\n+        case Constants.LSHR:\n+            return Constants.MATH_SHR;\n+\n+        case Constants.IUSHR:\n+        case Constants.LUSHR:\n+            return Constants.MATH_USHR;\n+\n+        case Constants.IAND:\n+        case Constants.LAND:\n+            return Constants.MATH_AND;\n+\n+        case Constants.IOR:\n+        case Constants.LOR:\n+            return Constants.MATH_OR;\n+\n+        case Constants.IXOR:\n+        case Constants.LXOR:\n+            return Constants.MATH_XOR;\n+\n+        default:\n+            return _op;\n+        }\n+    }\n+\n+    /**\n+     *  MathInstructions are equal if they have the same operation and type,\n+     *  or the operation and type of either is unset.\n+     */\n+    public boolean equalsInstruction(Instruction other) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (!(other instanceof MathInstruction)) {\n+            return false;\n+        }\n+\n+        MathInstruction ins = (MathInstruction) other;\n+\n+        int op = getOperation();\n+        int otherOp = ins.getOperation();\n+        boolean opEq = (op == -1) || (otherOp == -1) || (op == otherOp);\n+\n+        String type = getTypeName();\n+        String otherType = ins.getTypeName();\n+        boolean typeEq = (type == null) || (otherType == null) ||\n+            type.equals(otherType);\n+\n+        return opEq && typeEq;\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterMathInstruction(this);\n+        visit.exitMathInstruction(this);\n+    }\n+\n+    void read(Instruction orig) {\n+        super.read(orig);\n+\n+        MathInstruction ins = (MathInstruction) orig;\n+        _type = ins._type;\n+        _op = ins._op;\n+    }\n+}"},{"sha":"86eab36e45851ae89d33d48ced4d315b0a1daf35","filename":"serp/src/main/java/serp/bytecode/MethodInstruction.java","status":"added","additions":777,"deletions":0,"changes":777,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/MethodInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/MethodInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MethodInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,777 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import serp.util.*;\n+\n+import java.io.*;\n+\n+import java.lang.reflect.*;\n+\n+\n+/**\n+ *  <p>An instruction that invokes a method.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class MethodInstruction extends Instruction {\n+    private int _index = 0;\n+\n+    MethodInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    int getLength() {\n+        if (getOpcode() == Constants.INVOKEINTERFACE) {\n+            return super.getLength() + 4;\n+        }\n+\n+        return super.getLength() + 2;\n+    }\n+\n+    public int getLogicalStackChange() {\n+        String ret = getMethodReturnName();\n+\n+        if (ret == null) {\n+            return 0;\n+        }\n+\n+        int stack = 0;\n+\n+        // subtract a stack pos for the this ptr\n+        if (getOpcode() != Constants.INVOKESTATIC) {\n+            stack--;\n+        }\n+\n+        // and for each arg\n+        String[] params = getMethodParamNames();\n+\n+        for (int i = 0; i < params.length; i++)\n+            stack--;\n+\n+        // add for the return value, if any\n+        if (!void.class.getName().equals(ret)) {\n+            stack++;\n+        }\n+\n+        return stack;\n+    }\n+\n+    public int getStackChange() {\n+        String ret = getMethodReturnName();\n+\n+        if (ret == null) {\n+            return 0;\n+        }\n+\n+        int stack = 0;\n+\n+        // subtract a stack pos for the this ptr\n+        if (getOpcode() != Constants.INVOKESTATIC) {\n+            stack--;\n+        }\n+\n+        // and for each arg (2 for longs, doubles)\n+        String[] params = getMethodParamNames();\n+\n+        for (int i = 0; i < params.length; i++, stack--)\n+            if (long.class.getName().equals(params[i]) ||\n+                    double.class.getName().equals(params[i])) {\n+                stack--;\n+            }\n+\n+        // add for the return value, if any\n+        if (!void.class.getName().equals(ret)) {\n+            stack++;\n+        }\n+\n+        if (long.class.getName().equals(ret) ||\n+                double.class.getName().equals(ret)) {\n+            stack++;\n+        }\n+\n+        return stack;\n+    }\n+\n+    /////////////////////\n+    // Method operations\n+    /////////////////////\n+\n+    /**\n+     *  Return the index in the class {@link ConstantPool} of the\n+     *  {@link ComplexEntry} describing the method to operate on.\n+     */\n+    public int getMethodIndex() {\n+        return _index;\n+    }\n+\n+    /**\n+     *  Set the index in the class {@link ConstantPool} of the\n+     *  {@link ComplexEntry} describing the method to operate on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethodIndex(int index) {\n+        _index = index;\n+\n+        return this;\n+    }\n+\n+    /**\n+     *  Return the method this instruction operates on, or null if not set.\n+     */\n+    public BCMethod getMethod() {\n+        String dec = getMethodDeclarerName();\n+\n+        if (dec == null) {\n+            return null;\n+        }\n+\n+        BCClass bc = getProject().loadClass(dec, getClassLoader());\n+        BCMethod[] meths = bc.getMethods(getMethodName(), getMethodParamNames());\n+\n+        if (meths.length == 0) {\n+            return null;\n+        }\n+\n+        return meths[0];\n+    }\n+\n+    /**\n+      *  Set the method this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethod(BCMethod method) {\n+        if (method == null) {\n+            return setMethodIndex(0);\n+        }\n+\n+        return setMethod(method.getDeclarer().getName(), method.getName(),\n+            method.getReturnName(), method.getParamNames());\n+    }\n+\n+    /**\n+     *  Set the method this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethod(Method method) {\n+        if (method == null) {\n+            return setMethodIndex(0);\n+        }\n+\n+        return setMethod(method.getDeclaringClass(), method.getName(),\n+            method.getReturnType(), method.getParameterTypes());\n+    }\n+\n+    /**\n+     *  Set the method this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethod(Constructor method) {\n+        if (method == null) {\n+            return setMethodIndex(0);\n+        }\n+\n+        setOpcode(Constants.INVOKESPECIAL);\n+\n+        return setMethod(method.getDeclaringClass(), \"<init>\", void.class,\n+            method.getParameterTypes());\n+    }\n+\n+    /**\n+     *  Set the method this instruction operates on.\n+     *\n+     *  @param dec                        the full class name of the method's declaring class\n+     *  @param name                the method name\n+     *  @param returnType        the full class name of the method return type\n+     *  @param param                the full class names of the method param types\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethod(String dec, String name,\n+        String returnType, String[] params) {\n+        if ((name == null) && (returnType == null) && (dec == null) &&\n+                ((params == null) || (params.length == 0))) {\n+            return setMethodIndex(0);\n+        }\n+\n+        if (dec == null) {\n+            dec = \"\";\n+        }\n+\n+        if (name == null) {\n+            name = \"\";\n+        }\n+\n+        if (returnType == null) {\n+            returnType = \"\";\n+        }\n+\n+        if (params == null) {\n+            params = new String[0];\n+        }\n+\n+        NameCache cache = getProject().getNameCache();\n+        returnType = cache.getInternalForm(returnType, true);\n+        dec = cache.getInternalForm(dec, false);\n+\n+        for (int i = 0; i < params.length; i++)\n+            params[i] = cache.getInternalForm(params[i], true);\n+\n+        String desc = cache.getDescriptor(returnType, params);\n+\n+        if (getOpcode() == Constants.INVOKEINTERFACE) {\n+            return setMethodIndex(getPool()\n+                                      .findInterfaceMethodEntry(dec, name,\n+                    desc, true));\n+        }\n+\n+        return setMethodIndex(getPool().findMethodEntry(dec, name, desc, true));\n+    }\n+\n+    /**\n+     *  Set the method this instruction operates on, for methods that are\n+     *  declared by the current class.\n+      *\n+     *  @param name                the method name\n+     *  @param returnType        the full class name of the method return type\n+     *  @param param                the full class names of the method param types\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethod(String name, String returnType,\n+        String[] params) {\n+        BCClass owner = getCode().getMethod().getDeclarer();\n+\n+        return setMethod(owner.getName(), name, returnType, params);\n+    }\n+\n+    /**\n+     *  Set the method this instruction operates on.\n+     *\n+     *  @param dec                        the method's declaring class\n+     *  @param name                the method name\n+     *  @param returnType        the class of the method return type\n+     *  @param param                the class of the method param types\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethod(Class dec, String name,\n+        Class returnType, Class[] params) {\n+        String decName = (dec == null) ? null : dec.getName();\n+        String returnName = (returnType == null) ? null : returnType.getName();\n+        String[] paramNames = null;\n+\n+        if (params != null) {\n+            paramNames = new String[params.length];\n+\n+            for (int i = 0; i < params.length; i++)\n+                paramNames[i] = params[i].getName();\n+        }\n+\n+        return setMethod(decName, name, returnName, paramNames);\n+    }\n+\n+    /**\n+     *  Set the method this instruction operates on, for methods that are\n+     *  declared by the current class.\n+      *\n+     *  @param name                the method name\n+     *  @param returnType        the class of the method return type\n+     *  @param param                the class of the method param types\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethod(String name, Class returnType,\n+        Class[] params) {\n+        BCClass owner = getCode().getMethod().getDeclarer();\n+        String returnName = (returnType == null) ? null : returnType.getName();\n+        String[] paramNames = null;\n+\n+        if (params != null) {\n+            paramNames = new String[params.length];\n+\n+            for (int i = 0; i < params.length; i++)\n+                paramNames[i] = params[i].getName();\n+        }\n+\n+        return setMethod(owner.getName(), name, returnName, paramNames);\n+    }\n+\n+    /**\n+     *  Set the method this instruction operates on.\n+     *\n+     *  @param dec                        the method's declaring class\n+     *  @param name                the method name\n+     *  @param returnType        the class of the method return type\n+     *  @param param                the class of the method param types\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethod(BCClass dec, String name,\n+        BCClass returnType, BCClass[] params) {\n+        String decName = (dec == null) ? null : dec.getName();\n+        String returnName = (returnType == null) ? null : returnType.getName();\n+        String[] paramNames = null;\n+\n+        if (params != null) {\n+            paramNames = new String[params.length];\n+\n+            for (int i = 0; i < params.length; i++)\n+                paramNames[i] = params[i].getName();\n+        }\n+\n+        return setMethod(decName, name, returnName, paramNames);\n+    }\n+\n+    /**\n+     *  Set the method this instruction operates on, for methods that are\n+     *  declared by the current class.\n+      *\n+     *  @param name                the method name\n+     *  @param returnType        the class of the method return type\n+     *  @param param                the class of the method param types\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethod(String name, BCClass returnType,\n+        BCClass[] params) {\n+        BCClass owner = getCode().getMethod().getDeclarer();\n+        String returnName = (returnType == null) ? null : returnType.getName();\n+        String[] paramNames = null;\n+\n+        if (params != null) {\n+            paramNames = new String[params.length];\n+\n+            for (int i = 0; i < params.length; i++)\n+                paramNames[i] = params[i].getName();\n+        }\n+\n+        return setMethod(owner.getName(), name, returnName, paramNames);\n+    }\n+\n+    /////////////////////////////////////////\n+    // Name, Return, Param, Owner operations\n+    /////////////////////////////////////////\n+\n+    /**\n+     *  Return the name of the method this instruction operates on, or null\n+     *  if not set.\n+     */\n+    public String getMethodName() {\n+        int index = getMethodIndex();\n+\n+        if (index == 0) {\n+            return null;\n+        }\n+\n+        ComplexEntry entry = (ComplexEntry) getPool().getEntry(index);\n+        String name = entry.getNameAndTypeEntry().getNameEntry().getValue();\n+\n+        if (name.length() == 0) {\n+            return null;\n+        }\n+\n+        return name;\n+    }\n+\n+    /**\n+     *  Set the name of the method this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethodName(String name) {\n+        return setMethod(getMethodDeclarerName(), name, getMethodReturnName(),\n+            getMethodParamNames());\n+    }\n+\n+    /**\n+     *  Return the return type of the method this instruction operates on,\n+     *  or null        if not set.\n+     */\n+    public String getMethodReturnName() {\n+        int index = getMethodIndex();\n+\n+        if (index == 0) {\n+            return null;\n+        }\n+\n+        ComplexEntry entry = (ComplexEntry) getPool().getEntry(index);\n+        String desc = entry.getNameAndTypeEntry().getDescriptorEntry().getValue();\n+        NameCache cache = getProject().getNameCache();\n+        String name = cache.getExternalForm(cache.getDescriptorReturnName(desc),\n+                false);\n+\n+        if (name.length() == 0) {\n+            return null;\n+        }\n+\n+        return name;\n+    }\n+\n+    /**\n+     *  Return the return type of the method this instruction operates on,\n+     *  or null        if not set.\n+     */\n+    public Class getMethodReturnType() {\n+        String type = getMethodReturnName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return Strings.toClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Return the return type of the method this instruction operates on,\n+     *  or null        if not set.\n+     */\n+    public BCClass getMethodReturnBC() {\n+        String type = getMethodReturnName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return getProject().loadClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Set the return type of the method this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethodReturn(String type) {\n+        return setMethod(getMethodDeclarerName(), getMethodName(), type,\n+            getMethodParamNames());\n+    }\n+\n+    /**\n+     *  Set the return type of the method this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethodReturn(Class type) {\n+        String name = null;\n+\n+        if (type != null) {\n+            name = type.getName();\n+        }\n+\n+        return setMethodReturn(name);\n+    }\n+\n+    /**\n+     *  Set the return type of the method this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethodReturn(BCClass type) {\n+        String name = null;\n+\n+        if (type != null) {\n+            name = type.getName();\n+        }\n+\n+        return setMethodReturn(name);\n+    }\n+\n+    /**\n+     *  Return the param types of the method this instruction operates on,\n+     *  or empty array if none.\n+     */\n+    public String[] getMethodParamNames() {\n+        int index = getMethodIndex();\n+\n+        if (index == 0) {\n+            return null;\n+        }\n+\n+        ComplexEntry entry = (ComplexEntry) getPool().getEntry(index);\n+        String desc = entry.getNameAndTypeEntry().getDescriptorEntry().getValue();\n+        NameCache cache = getProject().getNameCache();\n+        String[] names = cache.getDescriptorParamNames(desc);\n+\n+        for (int i = 0; i < names.length; i++)\n+            names[i] = cache.getExternalForm(names[i], false);\n+\n+        return names;\n+    }\n+\n+    /**\n+     *  Return the param types of the method this instruction operates on,\n+     *  or empty array if none.\n+     */\n+    public Class[] getMethodParamTypes() {\n+        String[] paramNames = getMethodParamNames();\n+        Class[] params = new Class[paramNames.length];\n+\n+        for (int i = 0; i < paramNames.length; i++)\n+            params[i] = Strings.toClass(paramNames[i], getClassLoader());\n+\n+        return params;\n+    }\n+\n+    /**\n+     *  Return the param types of the method this instruction operates on,\n+     *  or empty array if none.\n+     */\n+    public BCClass[] getMethodParamBCs() {\n+        String[] paramNames = getMethodParamNames();\n+        BCClass[] params = new BCClass[paramNames.length];\n+\n+        for (int i = 0; i < paramNames.length; i++)\n+            params[i] = getProject().loadClass(paramNames[i], getClassLoader());\n+\n+        return params;\n+    }\n+\n+    /**\n+     *  Set the param types of the method this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethodParams(String[] types) {\n+        return setMethod(getMethodDeclarerName(), getMethodName(),\n+            getMethodReturnName(), types);\n+    }\n+\n+    /**\n+     *  Set the param types of the method this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public void setMethodParams(Class[] types) {\n+        if (types == null) {\n+            setMethodParams((String[]) null);\n+        } else {\n+            String[] names = new String[types.length];\n+\n+            for (int i = 0; i < types.length; i++)\n+                names[i] = types[i].getName();\n+\n+            setMethodParams(names);\n+        }\n+    }\n+\n+    /**\n+     *  Set the param types of the method this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public void setMethodParams(BCClass[] types) {\n+        if (types == null) {\n+            setMethodParams((String[]) null);\n+        } else {\n+            String[] names = new String[types.length];\n+\n+            for (int i = 0; i < types.length; i++)\n+                names[i] = types[i].getName();\n+\n+            setMethodParams(names);\n+        }\n+    }\n+\n+    /**\n+     *  Return the declaring type of the method this instruction operates on,\n+     *  or null        if not set.\n+     */\n+    public String getMethodDeclarerName() {\n+        int index = getMethodIndex();\n+\n+        if (index == 0) {\n+            return null;\n+        }\n+\n+        ComplexEntry entry = (ComplexEntry) getPool().getEntry(index);\n+        String name = getProject().getNameCache()\n+                          .getExternalForm(entry.getClassEntry().getNameEntry()\n+                                                .getValue(), false);\n+\n+        if (name.length() == 0) {\n+            return null;\n+        }\n+\n+        return name;\n+    }\n+\n+    /**\n+     *  Return the declaring type of the method this instruction operates on,\n+     *  or null        if not set.\n+     */\n+    public Class getMethodDeclarerType() {\n+        String type = getMethodDeclarerName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return Strings.toClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Return the declaring type of the method this instruction operates on,\n+     *  or null        if not set.\n+     */\n+    public BCClass getMethodDeclarerBC() {\n+        String type = getMethodDeclarerName();\n+\n+        if (type == null) {\n+            return null;\n+        }\n+\n+        return getProject().loadClass(type, getClassLoader());\n+    }\n+\n+    /**\n+     *  Set the declaring type of the method this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethodDeclarer(String type) {\n+        return setMethod(type, getMethodName(), getMethodReturnName(),\n+            getMethodParamNames());\n+    }\n+\n+    /**\n+     *  Set the declaring type of the method this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethodDeclarer(Class type) {\n+        String name = null;\n+\n+        if (type != null) {\n+            name = type.getName();\n+        }\n+\n+        return setMethodDeclarer(name);\n+    }\n+\n+    /**\n+     *  Set the declaring type of the method this instruction operates on.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public MethodInstruction setMethodDeclarer(BCClass type) {\n+        String name = null;\n+\n+        if (type != null) {\n+            name = type.getName();\n+        }\n+\n+        return setMethodDeclarer(name);\n+    }\n+\n+    /**\n+     *  MethodInstructions are equal if the method they reference is the same,\n+     *  or if the method of either is unset.\n+     */\n+    public boolean equalsInstruction(Instruction other) {\n+        if (other == this) {\n+            return true;\n+        }\n+\n+        if (!(other instanceof MethodInstruction)) {\n+            return false;\n+        }\n+\n+        if (!super.equalsInstruction(other)) {\n+            return false;\n+        }\n+\n+        MethodInstruction ins = (MethodInstruction) other;\n+\n+        String s1 = getMethodName();\n+        String s2 = ins.getMethodName();\n+\n+        if (!((s1 == null) || (s2 == null) || s1.equals(s2))) {\n+            return false;\n+        }\n+\n+        s1 = getMethodReturnName();\n+        s2 = ins.getMethodReturnName();\n+\n+        if (!((s1 == null) || (s2 == null) || s1.equals(s2))) {\n+            return false;\n+        }\n+\n+        s1 = getMethodDeclarerName();\n+        s2 = ins.getMethodDeclarerName();\n+\n+        if (!((s1 == null) || (s2 == null) || s1.equals(s2))) {\n+            return false;\n+        }\n+\n+        String[] p1 = getMethodParamNames();\n+        String[] p2 = ins.getMethodParamNames();\n+\n+        if (!((p1.length == 0) || (p2.length == 0) || (p1.length == p2.length))) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < p1.length; i++)\n+            if (!((p1[i] == null) || (p2[i] == null) || p1[i].equals(p2[i]))) {\n+                return false;\n+            }\n+\n+        return true;\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterMethodInstruction(this);\n+        visit.exitMethodInstruction(this);\n+    }\n+\n+    void read(Instruction orig) {\n+        super.read(orig);\n+\n+        MethodInstruction ins = (MethodInstruction) orig;\n+        setMethod(ins.getMethodDeclarerName(), ins.getMethodName(),\n+            ins.getMethodReturnName(), ins.getMethodParamNames());\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        super.read(in);\n+        setMethodIndex(in.readUnsignedShort());\n+\n+        if (getOpcode() == Constants.INVOKEINTERFACE) {\n+            in.readByte();\n+            in.readByte();\n+        }\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        super.write(out);\n+        out.writeShort(getMethodIndex());\n+\n+        if (getOpcode() == Constants.INVOKEINTERFACE) {\n+            String[] args = getMethodParamNames();\n+            int count = 1;\n+\n+            for (int i = 0; i < args.length; i++, count++)\n+                if (long.class.getName().equals(args[i]) ||\n+                        double.class.getName().equals(args[i])) {\n+                    count++;\n+                }\n+\n+            out.writeByte(count);\n+            out.writeByte(0);\n+        }\n+    }\n+}"},{"sha":"8fa1226577130ec206fbe2af28e3f8a7054940ad","filename":"serp/src/main/java/serp/bytecode/MonitorEnterInstruction.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/MonitorEnterInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/MonitorEnterInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MonitorEnterInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+\n+/**\n+ *  <p>The <code>monitorenter</code> instruction.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class MonitorEnterInstruction extends MonitorInstruction {\n+    MonitorEnterInstruction(Code owner) {\n+        super(owner, Constants.MONITORENTER);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterMonitorEnterInstruction(this);\n+        visit.exitMonitorEnterInstruction(this);\n+    }\n+}"},{"sha":"aa2072754e4eb88b5d9f64be717901138518f16d","filename":"serp/src/main/java/serp/bytecode/MonitorExitInstruction.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/MonitorExitInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/MonitorExitInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MonitorExitInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+\n+/**\n+ *  <p>The <code>monitorexit</code> instruction.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class MonitorExitInstruction extends MonitorInstruction {\n+    MonitorExitInstruction(Code owner) {\n+        super(owner, Constants.MONITOREXIT);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterMonitorExitInstruction(this);\n+        visit.exitMonitorExitInstruction(this);\n+    }\n+}"},{"sha":"356981220e98fc77d41c7f401f821368eb022b06","filename":"serp/src/main/java/serp/bytecode/MonitorInstruction.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/MonitorInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/MonitorInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MonitorInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+\n+/**\n+ *  <p>A synchronization instruction.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public abstract class MonitorInstruction extends Instruction {\n+    MonitorInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    public int getLogicalStackChange() {\n+        return getStackChange();\n+    }\n+\n+    public int getStackChange() {\n+        return -1;\n+    }\n+}"},{"sha":"01a17d1d84e0f0c5ec9568dbe55b375df662c2c5","filename":"serp/src/main/java/serp/bytecode/MultiANewArrayInstruction.java","status":"added","additions":110,"deletions":0,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/MultiANewArrayInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/MultiANewArrayInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MultiANewArrayInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+\n+/**\n+ *  <p>The <code>multianewarray</code> instruction, which creates a new\n+ *  multi-dimensional array.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class MultiANewArrayInstruction extends ClassInstruction {\n+    private int _dims = -1;\n+\n+    MultiANewArrayInstruction(Code owner) {\n+        super(owner, Constants.MULTIANEWARRAY);\n+    }\n+\n+    int getLength() {\n+        return super.getLength() + 1;\n+    }\n+\n+    public int getLogicalStackChange() {\n+        return getStackChange();\n+    }\n+\n+    public int getStackChange() {\n+        return -(getDimensions()) + 1;\n+    }\n+\n+    /**\n+      *  Return the dimensions of the array, or -1 if not set.\n+     */\n+    public int getDimensions() {\n+        return _dims;\n+    }\n+\n+    /**\n+     *  Set the dimensions of the array.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public MultiANewArrayInstruction setDimensions(int dims) {\n+        _dims = dims;\n+\n+        return this;\n+    }\n+\n+    /**\n+     *  Two MultiANewArray instructions are equal if they have the same\n+     *  type and dimensions, or if the type and dimensions of either\n+     *  is unset.\n+     */\n+    public boolean equalsInstruction(Instruction other) {\n+        if (other == this) {\n+            return true;\n+        }\n+\n+        if (!(other instanceof MultiANewArrayInstruction)) {\n+            return false;\n+        }\n+\n+        if (!super.equalsInstruction(other)) {\n+            return false;\n+        }\n+\n+        MultiANewArrayInstruction ins = (MultiANewArrayInstruction) other;\n+        int dims = getDimensions();\n+        int otherDims = ins.getDimensions();\n+\n+        return (dims == -1) || (otherDims == -1) || (dims == otherDims);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterMultiANewArrayInstruction(this);\n+        visit.exitMultiANewArrayInstruction(this);\n+    }\n+\n+    void read(Instruction orig) {\n+        super.read(orig);\n+        setDimensions(((MultiANewArrayInstruction) orig).getDimensions());\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        super.read(in);\n+        setDimensions(in.readUnsignedByte());\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        super.write(out);\n+        out.writeByte(getDimensions());\n+    }\n+}"},{"sha":"3b02a47ede3e91c4862bfeb2dc7cd577d725cf3b","filename":"serp/src/main/java/serp/bytecode/NameCache.java","status":"added","additions":296,"deletions":0,"changes":296,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/NameCache.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/NameCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/NameCache.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,296 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Caching and conversion of names in both internal and external form.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class NameCache {\n+    static final Object[][] _codes = new Object[][] {\n+            { byte.class, \"B\" },\n+            { char.class, \"C\" },\n+            { double.class, \"D\" },\n+            { float.class, \"F\" },\n+            { int.class, \"I\" },\n+            { long.class, \"J\" },\n+            { short.class, \"S\" },\n+            { boolean.class, \"Z\" },\n+            { void.class, \"V\" },\n+        };\n+\n+    // caches of internal and external forms of strings\n+    private final Map _internal = new HashMap();\n+    private final Map _internalDescriptor = new HashMap();\n+    private final Map _external = new HashMap();\n+    private final Map _externalHuman = new HashMap();\n+\n+    /**\n+      *  Converts the given class name to its internal form.\n+     *\n+     *  @param className        the name to convert\n+     *  @param descriptor        true if the name is to be used for a descriptor\n+     *                                          section -- the difference seems to be that for\n+     *                                          descriptors, non-primitives are prefixed with 'L'\n+     *                                          and ended with ';'\n+     */\n+    public String getInternalForm(String className, boolean descriptor) {\n+        if ((className == null) || (className.length() == 0)) {\n+            return className;\n+        }\n+\n+        Map cache = (descriptor) ? _internalDescriptor : _internal;\n+        String cached = (String) cache.get(className);\n+\n+        if (cached != null) {\n+            return cached;\n+        }\n+\n+        String ret = getInternalFormInternal(className, descriptor);\n+        cache.put(className, ret);\n+\n+        return ret;\n+    }\n+\n+    /**\n+     *  @see #getInternalForm\n+     */\n+    private String getInternalFormInternal(String cls, boolean descriptor) {\n+        // handle array types, whether already in internal form or not\n+        StringBuffer prefix = new StringBuffer();\n+\n+        while (true) {\n+            if (cls.endsWith(\"[]\")) {\n+                prefix.append(\"[\");\n+                cls = cls.substring(0, cls.length() - 2);\n+            } else if (cls.startsWith(\"[\")) {\n+                prefix.append(\"[\");\n+                cls = cls.substring(1);\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        // handle primitive array types\n+        for (int i = 0; i < _codes.length; i++)\n+            if (cls.equals(_codes[i][1].toString()) ||\n+                    cls.equals(_codes[i][0].toString())) {\n+                return prefix.append(_codes[i][1]).toString();\n+            }\n+\n+        // if in descriptor form, strip leading 'L' and trailing ';'\n+        if (cls.startsWith(\"L\") && cls.endsWith(\";\")) {\n+            cls = cls.substring(1, cls.length() - 1);\n+        }\n+\n+        // non-primitive; make sure we don't prefix method descriptors with 'L'\n+        cls = cls.replace('.', '/');\n+\n+        if ((descriptor || (prefix.length() > 0)) && (cls.charAt(0) != '(')) {\n+            return prefix.append(\"L\").append(cls).append(\";\").toString();\n+        }\n+\n+        return prefix.append(cls).toString();\n+    }\n+\n+    /**\n+     *  Given the internal name of the class, return the 'normal' java name.\n+     *\n+     *  @param internalName        the internal name being used\n+     *  @param humanReadable        if the returned name should be in human-readable\n+     *                                                  form, rather than a form suitable for a\n+     *                                                  {@link Class#forName} call -- the difference\n+     *                                                  lies in the handling of        arrays\n+     */\n+    public String getExternalForm(String internalName, boolean humanReadable) {\n+        if ((internalName == null) || (internalName.length() == 0)) {\n+            return internalName;\n+        }\n+\n+        Map cache = (humanReadable) ? _externalHuman : _external;\n+        String cached = (String) cache.get(internalName);\n+\n+        if (cached != null) {\n+            return cached;\n+        }\n+\n+        String ret = getExternalFormInternal(internalName, humanReadable);\n+        cache.put(internalName, ret);\n+\n+        return ret;\n+    }\n+\n+    /**\n+     *  @see #getExternalForm\n+     */\n+    private String getExternalFormInternal(String intern, boolean humanReadable) {\n+        if (!humanReadable) {\n+            // check against primitives\n+            for (int i = 0; i < _codes.length; i++) {\n+                if (intern.equals(_codes[i][1].toString())) {\n+                    return _codes[i][0].toString();\n+                }\n+\n+                if (intern.equals(_codes[i][0].toString())) {\n+                    return intern;\n+                }\n+            }\n+\n+            intern = getInternalForm(intern, false);\n+\n+            return intern.replace('/', '.');\n+        }\n+\n+        // handle arrays\n+        StringBuffer postfix = new StringBuffer(2);\n+\n+        while (intern.startsWith(\"[\")) {\n+            intern = intern.substring(1);\n+            postfix.append(\"[]\");\n+        }\n+\n+        // strip off leading 'L' and trailing ';'\n+        if (intern.endsWith(\";\")) {\n+            intern = intern.substring(1, intern.length() - 1);\n+        }\n+\n+        // check primitives\n+        for (int i = 0; i < _codes.length; i++)\n+            if (intern.equals(_codes[i][1].toString())) {\n+                return _codes[i][0].toString() + postfix;\n+            }\n+\n+        return intern.replace('/', '.') + postfix;\n+    }\n+\n+    /**\n+     *  Construct a method descriptor from the given return and parameter\n+     *  types, which will be converted to internal form.\n+     */\n+    public String getDescriptor(String returnType, String[] paramTypes) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"(\");\n+\n+        if (paramTypes != null) {\n+            for (int i = 0; i < paramTypes.length; i++) {\n+                if (paramTypes[i] == null) {\n+                    throw new NullPointerException(\"paramTypes[\" + i +\n+                        \"] = null\");\n+                }\n+\n+                buf.append(getInternalForm(paramTypes[i], true));\n+            }\n+        }\n+\n+        buf.append(\")\");\n+\n+        if (returnType == null) {\n+            throw new NullPointerException(\"returnType = null\");\n+        }\n+\n+        buf.append(getInternalForm(returnType, true));\n+\n+        return buf.toString();\n+    }\n+\n+    /**\n+     *  Return the return type, in internal form, for the given method\n+     *  descriptor string.\n+     */\n+    public String getDescriptorReturnName(String descriptor) {\n+        int index = descriptor.indexOf(')');\n+\n+        if (index == -1) {\n+            return \"\";\n+        }\n+\n+        return descriptor.substring(descriptor.indexOf(')') + 1);\n+    }\n+\n+    /**\n+     *  Return the parameter types, in internal form, for the given method\n+     *  descriptor string.\n+     */\n+    public String[] getDescriptorParamNames(String descriptor) {\n+        if ((descriptor == null) || (descriptor.length() == 0)) {\n+            return new String[0];\n+        }\n+\n+        int index = descriptor.indexOf(')');\n+\n+        if (index == -1) {\n+            return new String[0];\n+        }\n+\n+        // get rid of the parens and the return type\n+        descriptor = descriptor.substring(1, index);\n+\n+        // break the param string into individual params\n+        List tokens = new LinkedList();\n+\n+        while (descriptor.length() > 0) {\n+            index = 0;\n+\n+            // skip the '[' up to the first letter code\n+            while (!Character.isLetter(descriptor.charAt(index)))\n+                index++;\n+\n+            // non-primitives always start with 'L' and end with ';'\n+            if (descriptor.charAt(index) == 'L') {\n+                index = descriptor.indexOf(';');\n+            }\n+\n+            tokens.add(descriptor.substring(0, index + 1));\n+            descriptor = descriptor.substring(index + 1);\n+        }\n+\n+        return (String[]) tokens.toArray(new String[tokens.size()]);\n+    }\n+\n+    /**\n+     *  Return the component type name for the given array type, or null\n+     *  if the given string does not represent an array type name.  The name\n+     *  given should be in proper {@link Class#forName} form.\n+     */\n+    public String getComponentName(String name) {\n+        if ((name == null) || !name.startsWith(\"[\")) {\n+            return null;\n+        }\n+\n+        name = name.substring(1);\n+\n+        if (!name.startsWith(\"[\") && name.endsWith(\";\")) {\n+            name = name.substring(1, name.length() - 1);\n+        }\n+\n+        // will convert primitive type codes to names\n+        return getExternalForm(name, false);\n+    }\n+\n+    /**\n+     *  Clear the cache.\n+     */\n+    public void clear() {\n+        _internal.clear();\n+        _internalDescriptor.clear();\n+        _external.clear();\n+        _externalHuman.clear();\n+    }\n+}"},{"sha":"ac28ca419402092ab5d7ec6d84350bed9072c140","filename":"serp/src/main/java/serp/bytecode/NewArrayInstruction.java","status":"added","additions":173,"deletions":0,"changes":173,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/NewArrayInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/NewArrayInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/NewArrayInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,173 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>The <code>newarray</code> instruction, which is used to create new\n+ *  arrays of primitive types.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class NewArrayInstruction extends TypedInstruction {\n+    private static final Class[][] _mappings = new Class[][] {\n+            { void.class, int.class },\n+            { Object.class, int.class },\n+        };\n+    private int _code = -1;\n+\n+    NewArrayInstruction(Code owner) {\n+        super(owner, Constants.NEWARRAY);\n+    }\n+\n+    int getLength() {\n+        return super.getLength() + 1;\n+    }\n+\n+    public String getTypeName() {\n+        switch (getTypeCode()) {\n+        case Constants.ARRAY_BOOLEAN:\n+            return boolean.class.getName();\n+\n+        case Constants.ARRAY_CHAR:\n+            return char.class.getName();\n+\n+        case Constants.ARRAY_FLOAT:\n+            return float.class.getName();\n+\n+        case Constants.ARRAY_DOUBLE:\n+            return double.class.getName();\n+\n+        case Constants.ARRAY_BYTE:\n+            return byte.class.getName();\n+\n+        case Constants.ARRAY_SHORT:\n+            return short.class.getName();\n+\n+        case Constants.ARRAY_INT:\n+            return int.class.getName();\n+\n+        case Constants.ARRAY_LONG:\n+            return long.class.getName();\n+\n+        default:\n+            return null;\n+        }\n+    }\n+\n+    public TypedInstruction setType(String type) {\n+        type = mapType(type, _mappings, true);\n+\n+        if (type == null) {\n+            return setTypeCode(-1);\n+        }\n+\n+        switch (type.charAt(0)) {\n+        case 'b':\n+\n+            if (boolean.class.getName().equals(type)) {\n+                return setTypeCode(Constants.ARRAY_BOOLEAN);\n+            }\n+\n+            return setTypeCode(Constants.ARRAY_BYTE);\n+\n+        case 'c':\n+            return setTypeCode(Constants.ARRAY_CHAR);\n+\n+        case 'f':\n+            return setTypeCode(Constants.ARRAY_FLOAT);\n+\n+        case 'd':\n+            return setTypeCode(Constants.ARRAY_DOUBLE);\n+\n+        case 's':\n+            return setTypeCode(Constants.ARRAY_SHORT);\n+\n+        case 'i':\n+            return setTypeCode(Constants.ARRAY_INT);\n+\n+        case 'l':\n+            return setTypeCode(Constants.ARRAY_LONG);\n+\n+        default:\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    /**\n+     *  Return the array code used in the lowlevel bytecode, or -1 if unset.\n+     */\n+    public int getTypeCode() {\n+        return _code;\n+    }\n+\n+    /**\n+     *  Set the array code used in the lowlevel bytecode.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public NewArrayInstruction setTypeCode(int code) {\n+        _code = code;\n+\n+        return this;\n+    }\n+\n+    /**\n+     *  NewArray instructions are equal if the array type is the same,\n+     *  of if the array type of either is unset.\n+     */\n+    public boolean equalsInstruction(Instruction other) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (!(other instanceof NewArrayInstruction)) {\n+            return false;\n+        }\n+\n+        NewArrayInstruction ins = (NewArrayInstruction) other;\n+        int code = getTypeCode();\n+        int otherCode = ins.getTypeCode();\n+\n+        return (code == -1) || (otherCode == -1) || (code == otherCode);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterNewArrayInstruction(this);\n+        visit.exitNewArrayInstruction(this);\n+    }\n+\n+    void read(Instruction orig) {\n+        super.read(orig);\n+        setTypeCode(((NewArrayInstruction) orig).getTypeCode());\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        super.read(in);\n+        setTypeCode(in.readUnsignedByte());\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        super.write(out);\n+        out.writeByte(getTypeCode());\n+    }\n+}"},{"sha":"9ae3d8beed611a411dfcf0bc08b4ebb9c45e9b5e","filename":"serp/src/main/java/serp/bytecode/ObjectState.java","status":"added","additions":143,"deletions":0,"changes":143,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ObjectState.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ObjectState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ObjectState.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>State implementing the behavior of an object type.</p>\n+ *\n+ *  @author Abe White\n+ */\n+class ObjectState extends State {\n+    private final ConstantPool _pool = new ConstantPool();\n+    private final NameCache _names;\n+    private int _index = 0;\n+    private int _superclassIndex = 0;\n+    private int _magic = Constants.VALID_MAGIC;\n+    private int _major = Constants.MAJOR_VERSION;\n+    private int _minor = Constants.MINOR_VERSION;\n+    private int _access = Constants.ACCESS_PUBLIC | Constants.ACCESS_SUPER;\n+    private final Collection _interfaces = new HashSet();\n+    private final Collection _fields = new LinkedList();\n+    private final Collection _methods = new LinkedList();\n+    private final Collection _attributes = new LinkedList();\n+\n+    public ObjectState(NameCache names) {\n+        _names = names;\n+    }\n+\n+    public int getMagic() {\n+        return _magic;\n+    }\n+\n+    public void setMagic(int magic) {\n+        _magic = magic;\n+    }\n+\n+    public int getMajorVersion() {\n+        return _major;\n+    }\n+\n+    public void setMajorVersion(int major) {\n+        _major = major;\n+    }\n+\n+    public int getMinorVersion() {\n+        return _minor;\n+    }\n+\n+    public void setMinorVersion(int minor) {\n+        _minor = minor;\n+    }\n+\n+    public int getAccessFlags() {\n+        return _access;\n+    }\n+\n+    public void setAccessFlags(int access) {\n+        _access = access;\n+    }\n+\n+    public int getIndex() {\n+        return _index;\n+    }\n+\n+    public void setIndex(int index) {\n+        _index = index;\n+    }\n+\n+    public int getSuperclassIndex() {\n+        return _superclassIndex;\n+    }\n+\n+    public void setSuperclassIndex(int index) {\n+        _superclassIndex = index;\n+    }\n+\n+    public Collection getInterfacesHolder() {\n+        return _interfaces;\n+    }\n+\n+    public Collection getFieldsHolder() {\n+        return _fields;\n+    }\n+\n+    public Collection getMethodsHolder() {\n+        return _methods;\n+    }\n+\n+    public Collection getAttributesHolder() {\n+        return _attributes;\n+    }\n+\n+    public ConstantPool getPool() {\n+        return _pool;\n+    }\n+\n+    public String getName() {\n+        if (_index == 0) {\n+            return null;\n+        }\n+\n+        return _names.getExternalForm(((ClassEntry) _pool.getEntry(_index)).getNameEntry()\n+                                       .getValue(), false);\n+    }\n+\n+    public String getSuperclassName() {\n+        if (_superclassIndex == 0) {\n+            return null;\n+        }\n+\n+        return _names.getExternalForm(((ClassEntry) _pool.getEntry(\n+                _superclassIndex)).getNameEntry().getValue(), false);\n+    }\n+\n+    public String getComponentName() {\n+        return null;\n+    }\n+\n+    public boolean isPrimitive() {\n+        return false;\n+    }\n+\n+    public boolean isArray() {\n+        return false;\n+    }\n+}"},{"sha":"1d87bf01082e19f4f58eb58adf5ce35a4333cb96","filename":"serp/src/main/java/serp/bytecode/PrimitiveState.java","status":"added","additions":96,"deletions":0,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/PrimitiveState.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/PrimitiveState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/PrimitiveState.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>State implementing the behavior of a primitive class.</p>\n+ *\n+ *  @author Abe White\n+ */\n+class PrimitiveState extends State {\n+    private final Class _type;\n+    private final NameCache _names;\n+\n+    public PrimitiveState(Class type, NameCache names) {\n+        _type = type;\n+        _names = names;\n+    }\n+\n+    public int getMagic() {\n+        return Constants.VALID_MAGIC;\n+    }\n+\n+    public int getMajorVersion() {\n+        return Constants.MAJOR_VERSION;\n+    }\n+\n+    public int getMinorVersion() {\n+        return Constants.MINOR_VERSION;\n+    }\n+\n+    public int getAccessFlags() {\n+        return Constants.ACCESS_PUBLIC | Constants.ACCESS_FINAL;\n+    }\n+\n+    public int getIndex() {\n+        return 0;\n+    }\n+\n+    public int getSuperclassIndex() {\n+        return 0;\n+    }\n+\n+    public Collection getInterfacesHolder() {\n+        return Collections.EMPTY_LIST;\n+    }\n+\n+    public Collection getFieldsHolder() {\n+        return Collections.EMPTY_LIST;\n+    }\n+\n+    public Collection getMethodsHolder() {\n+        return Collections.EMPTY_LIST;\n+    }\n+\n+    public Collection getAttributesHolder() {\n+        return Collections.EMPTY_LIST;\n+    }\n+\n+    public String getName() {\n+        return _names.getExternalForm(_type.getName(), false);\n+    }\n+\n+    public String getSuperclassName() {\n+        return null;\n+    }\n+\n+    public String getComponentName() {\n+        return null;\n+    }\n+\n+    public boolean isPrimitive() {\n+        return true;\n+    }\n+\n+    public boolean isArray() {\n+        return false;\n+    }\n+}"},{"sha":"c66b978c81374f517a4d539db6736fc23cf40a81","filename":"serp/src/main/java/serp/bytecode/Project.java","status":"added","additions":451,"deletions":0,"changes":451,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Project.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Project.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Project.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,451 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import serp.util.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>The Project represents a working set of classes.  It caches parsed\n+ *  bytecode and is responsible for bytecode class creation.  Currently\n+ *  changes made in one class are <strong>not</strong> reflected in other\n+ *  classes, though this will be an option in the future.</p>\n+ *\n+ *  <p>Bytecode that has been parsed is held in a cache so that retrieving\n+ *  a class with the same name multiple times always returns the same\n+ *  {@link BCClass} instance.</p>\n+ *\n+ *  <p>A future goal is to eventually have facilities for traversing jars\n+ *  or directory structures to find classes that meet a given criteria (such\n+ *  as implementing a given interface, etc) and to perform operations on entire\n+ *  projects, similar to aspect-oriented programming.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class Project implements VisitAcceptor {\n+    private final String _name;\n+    private final HashMap _cache = new HashMap();\n+    private final NameCache _names = new NameCache();\n+\n+    /**\n+     *  Default constructor.\n+     */\n+    public Project() {\n+        this(null);\n+    }\n+\n+    /**\n+     *  Construct a named project.\n+     */\n+    public Project(String name) {\n+        _name = name;\n+    }\n+\n+    /**\n+     *  Return the project name, or null if unset.\n+     */\n+    public String getName() {\n+        return _name;\n+    }\n+\n+    /**\n+     *  Return the name cache, which includes utilities for converting names\n+     *  from internal to external form and vice versa.\n+     */\n+    public NameCache getNameCache() {\n+        return _names;\n+    }\n+\n+    /**\n+     *  Load a class with the given name.\n+     *\n+     *  @see #loadClass(String,ClassLoader)\n+     */\n+    public BCClass loadClass(String name) {\n+        return loadClass(name, null);\n+    }\n+\n+    /**\n+     *  Load the bytecode for the class with the given name.\n+     *  If a {@link BCClass} with the given name already exists in this project,\n+     *  it will be returned.  Otherwise, a new {@link BCClass} will be created\n+     *  with the given name and returned.  If the name represents an existing\n+     *  type, the returned instance will contain the parsed bytecode for\n+     *  that type.  If the name is of a primitive or array type, the returned\n+     *  instance will act accordingly.\n+     *\n+     *  @param name        the name of the class, including package\n+     *  @param loader        the class loader to use to search for an existing\n+     *                                  class with the given name; if null defaults to the\n+     *                                  context loader of the current thread\n+     *  @throws RuntimeException on parse error\n+     */\n+    public BCClass loadClass(String name, ClassLoader loader) {\n+        // convert to proper Class.forName() form\n+        name = _names.getExternalForm(name, false);\n+\n+        BCClass cached = checkCache(name);\n+\n+        if (cached != null) {\n+            return cached;\n+        }\n+\n+        // check for existing type\n+        if (loader == null) {\n+            loader = Thread.currentThread().getContextClassLoader();\n+        }\n+\n+        try {\n+            return loadClass(Strings.toClass(name, loader));\n+        } catch (Exception e) {\n+        }\n+\n+        String componentName = _names.getComponentName(name);\n+        BCClass ret = new BCClass(this);\n+\n+        if (componentName != null) {\n+            ret.setState(new ArrayState(name, componentName));\n+        } else {\n+            ret.setState(new ObjectState(_names));\n+            ret.setName(name);\n+            ret.setSuperclass(Object.class);\n+        }\n+\n+        cache(name, ret);\n+\n+        return ret;\n+    }\n+\n+    /**\n+     *  Load the bytecode for the given class.\n+     *  If a {@link BCClass} with the name of the given class already exists in\n+     *  this project, it will be returned.  Otherwise, the bytecode of the given\n+     *  class will be parsed and returned as a new {@link BCClass}.  If the\n+     *  given class is an array or primitive type, the returned instance will\n+     *  act accordingly.\n+     *\n+     *  @param type        the class to parse\n+     *  @throws RuntimeException on parse error\n+     */\n+    public BCClass loadClass(Class type) {\n+        BCClass cached = checkCache(type.getName());\n+\n+        if (cached != null) {\n+            return cached;\n+        }\n+\n+        BCClass ret = new BCClass(this);\n+\n+        if (type.isPrimitive()) {\n+            ret.setState(new PrimitiveState(type, _names));\n+        } else if (type.isArray()) {\n+            ret.setState(new ArrayState(type.getName(),\n+                    _names.getExternalForm(type.getComponentType().getName(),\n+                        false)));\n+        } else {\n+            ret.setState(new ObjectState(_names));\n+\n+            try {\n+                ret.read(type);\n+            } catch (IOException ioe) {\n+                throw new RuntimeException(ioe.toString());\n+            }\n+        }\n+\n+        cache(type.getName(), ret);\n+\n+        return ret;\n+    }\n+\n+    /**\n+     *  Load the bytecode from the given class file.\n+     *  If this project        already contains the class in the given file, it will\n+     *  be returned.  Otherwise a new {@link BCClass} will be created from the\n+     *  given bytecode.\n+      *\n+     *  @throws RuntimeException on parse error\n+     */\n+    public BCClass loadClass(File classFile) {\n+        return loadClass(classFile, null);\n+    }\n+\n+    /**\n+     *  Load the bytecode from the given class file.\n+     *  If this project        already contains the class in the given file, it will\n+     *  be returned.  Otherwise a new {@link BCClass} will be created from the\n+     *  given bytecode.\n+      *\n+     *  @throws RuntimeException on parse error\n+     */\n+    public BCClass loadClass(File classFile, ClassLoader loader) {\n+        // parse the bytecode from the file\n+        BCClass ret = new BCClass(this);\n+        ret.setState(new ObjectState(_names));\n+\n+        try {\n+            ret.read(classFile, loader);\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe.toString());\n+        }\n+\n+        String name = ret.getName();\n+        BCClass cached = checkCache(name);\n+\n+        if (cached != null) {\n+            return cached;\n+        }\n+\n+        cache(name, ret);\n+\n+        return ret;\n+    }\n+\n+    /**\n+     *  Load the bytecode from the given stream.\n+     *  If this project        already contains the class in the given stream,\n+     *  it will be returned.  Otherwise a new {@link BCClass} will be created\n+     *  from the given bytecode.\n+     *\n+     *  @throws RuntimeException on parse error\n+     */\n+    public BCClass loadClass(InputStream in) {\n+        return loadClass(in, null);\n+    }\n+\n+    /**\n+     *  Load the bytecode from the given stream.\n+     *  If this project        already contains the class in the given stream,\n+     *  it will be returned.  Otherwise a new {@link BCClass} will be created\n+     *  from the given bytecode.\n+     *\n+     *  @throws RuntimeException on parse error\n+     */\n+    public BCClass loadClass(InputStream in, ClassLoader loader) {\n+        BCClass ret = new BCClass(this);\n+        ret.setState(new ObjectState(_names));\n+\n+        try {\n+            ret.read(in, loader);\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe.toString());\n+        }\n+\n+        String name = ret.getName();\n+        BCClass cached = checkCache(name);\n+\n+        if (cached != null) {\n+            return cached;\n+        }\n+\n+        cache(name, ret);\n+\n+        return ret;\n+    }\n+\n+    /**\n+     *  Import the given bytecode from another project.  If a {@link BCClass}\n+     *  with the same name already exists in this project, it will be returned.\n+     *  Otherwise, a new {@link BCClass} will be created from the\n+     *  information in the given class.\n+     */\n+    public BCClass loadClass(BCClass bc) {\n+        String name = bc.getName();\n+        BCClass cached = checkCache(name);\n+\n+        if (cached != null) {\n+            return cached;\n+        }\n+\n+        BCClass ret = new BCClass(this);\n+\n+        if (bc.isPrimitive()) {\n+            ret.setState(new PrimitiveState(bc.getType(), _names));\n+        } else if (bc.isArray()) {\n+            ret.setState(new ArrayState(bc.getName(), bc.getComponentName()));\n+        } else {\n+            ret.setState(new ObjectState(_names));\n+            ret.read(bc);\n+        }\n+\n+        cache(name, ret);\n+\n+        return ret;\n+    }\n+\n+    /**\n+     *  Clears all classes from this project.\n+     */\n+    public void clear() {\n+        Collection values = _cache.values();\n+        BCClass bc;\n+\n+        for (Iterator itr = values.iterator(); itr.hasNext();) {\n+            bc = (BCClass) itr.next();\n+            itr.remove();\n+            bc.invalidate();\n+        }\n+\n+        _names.clear();\n+    }\n+\n+    /**\n+     *  Remove a class from this project.  After removal, the result of any\n+     *  further operations on the class is undefined.\n+     *\n+     *  @return true if the class belonged to this project, false\n+     *                          otherwise\n+     */\n+    public boolean removeClass(String type) {\n+        return removeClass(checkCache(type));\n+    }\n+\n+    /**\n+     *  Remove a class from this project.  After removal, the result of any\n+     *  further operations on the class is undefined.\n+     *\n+     *  @return true if the class belonged to this project, false\n+     *                          otherwise\n+     */\n+    public boolean removeClass(Class type) {\n+        if (type == null) {\n+            return false;\n+        }\n+\n+        return removeClass(checkCache(type.getName()));\n+    }\n+\n+    /**\n+     *  Remove a class from this project.  After removal, the result of any\n+     *  further operations on the class is undefined.\n+     *\n+     *  @return true if the class belonged to this project, false\n+     *                          otherwise\n+     */\n+    public boolean removeClass(BCClass type) {\n+        if (type == null) {\n+            return false;\n+        }\n+\n+        if (!removeFromCache(type.getName(), type)) {\n+            return false;\n+        }\n+\n+        type.invalidate();\n+\n+        return true;\n+    }\n+\n+    /**\n+     *  Return all loaded classes in the project.\n+     */\n+    public BCClass[] getClasses() {\n+        Collection values = _cache.values();\n+\n+        return (BCClass[]) values.toArray(new BCClass[values.size()]);\n+    }\n+\n+    /**\n+     *  Return true if the project already contains the given class.\n+     */\n+    public boolean containsClass(String type) {\n+        return _cache.containsKey(type);\n+    }\n+\n+    /**\n+     *  Return true if the project already contains the given class.\n+     */\n+    public boolean containsClass(Class type) {\n+        return (type == null) ? false : containsClass(type.getName());\n+    }\n+\n+    /**\n+     *  Return true if the project already contains the given class.\n+     */\n+    public boolean containsClass(BCClass type) {\n+        return (type == null) ? false : containsClass(type.getName());\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterProject(this);\n+\n+        BCClass[] classes = getClasses();\n+\n+        for (int i = 0; i < classes.length; i++)\n+            classes[i].acceptVisit(visit);\n+\n+        visit.exitProject(this);\n+    }\n+\n+    /**\n+     *  Renames the given class within this project.  Used internally by\n+     *  {@link BCClass} instances when their name is modified.\n+     *\n+     *  @throws IllegalStateException if a class with the new name already\n+     *                          exists\n+     */\n+    void renameClass(String oldName, String newName, BCClass bc) {\n+        if (oldName.equals(newName)) {\n+            return;\n+        }\n+\n+        BCClass cached = (BCClass) checkCache(newName);\n+\n+        if (cached != null) {\n+            throw new IllegalStateException(\"A class with name \" + newName +\n+                \" already exists in this project\");\n+        }\n+\n+        removeFromCache(oldName, bc);\n+        cache(newName, bc);\n+    }\n+\n+    /**\n+     *  Check the cache for a loaded type.\n+     */\n+    private BCClass checkCache(String name) {\n+        return (BCClass) _cache.get(name);\n+    }\n+\n+    /**\n+     *  Cache a class.\n+     */\n+    private void cache(String name, BCClass bc) {\n+        _cache.put(name, bc);\n+    }\n+\n+    /**\n+     *  Remove a cached class.\n+     */\n+    private boolean removeFromCache(String name, BCClass bc) {\n+        BCClass rem = (BCClass) checkCache(name);\n+\n+        if (rem != bc) {\n+            return false;\n+        }\n+\n+        _cache.remove(name);\n+\n+        return true;\n+    }\n+}"},{"sha":"8251a85dd12cda2e1f5931ed11b8fc557e614112","filename":"serp/src/main/java/serp/bytecode/PutFieldInstruction.java","status":"added","additions":68,"deletions":0,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/PutFieldInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/PutFieldInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/PutFieldInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+\n+/**\n+ *  <p>Stores a value from the stack into a field.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class PutFieldInstruction extends FieldInstruction {\n+    PutFieldInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    public int getLogicalStackChange() {\n+        if (getFieldTypeName() == null) {\n+            return 0;\n+        }\n+\n+        if (getOpcode() == Constants.PUTSTATIC) {\n+            return -1;\n+        }\n+\n+        return -2;\n+    }\n+\n+    public int getStackChange() {\n+        String type = getFieldTypeName();\n+\n+        if (type == null) {\n+            return 0;\n+        }\n+\n+        int stack = -2;\n+\n+        if (long.class.getName().equals(type) ||\n+                double.class.getName().equals(type)) {\n+            stack++;\n+        }\n+\n+        if (getOpcode() == Constants.PUTSTATIC) {\n+            stack++;\n+        }\n+\n+        return stack;\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterPutFieldInstruction(this);\n+        visit.exitPutFieldInstruction(this);\n+    }\n+}"},{"sha":"156c4b0398ecec5afebba1e8265db868fb1c7b49","filename":"serp/src/main/java/serp/bytecode/RetInstruction.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/RetInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/RetInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/RetInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+\n+/**\n+ *  <p>The <code>ret</code> instruction is used in the implementation of\n+ *  finally.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class RetInstruction extends LocalVariableInstruction {\n+    RetInstruction(Code owner) {\n+        super(owner, Constants.RET);\n+    }\n+\n+    int getLength() {\n+        return super.getLength() + 1;\n+    }\n+\n+    public boolean equalsInstruction(Instruction other) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (!(other instanceof RetInstruction)) {\n+            return false;\n+        }\n+\n+        return super.equalsInstruction(other);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterRetInstruction(this);\n+        visit.exitRetInstruction(this);\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        super.read(in);\n+        setLocal(in.readUnsignedByte());\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        super.write(out);\n+        out.writeByte(getLocal());\n+    }\n+}"},{"sha":"d3eb42645428cc156203c5ae204ac5fb61b5fa4b","filename":"serp/src/main/java/serp/bytecode/ReturnInstruction.java","status":"added","additions":128,"deletions":0,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ReturnInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/ReturnInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ReturnInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>Returns a value (or void) from a method.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class ReturnInstruction extends TypedInstruction {\n+    private static final Class[][] _mappings = new Class[][] {\n+            { byte.class, int.class },\n+            { char.class, int.class },\n+            { short.class, int.class },\n+            { boolean.class, int.class },\n+        };\n+\n+    ReturnInstruction(Code owner) {\n+        super(owner);\n+    }\n+\n+    ReturnInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    public String getTypeName() {\n+        switch (getOpcode()) {\n+        case Constants.IRETURN:\n+            return int.class.getName();\n+\n+        case Constants.LRETURN:\n+            return long.class.getName();\n+\n+        case Constants.FRETURN:\n+            return float.class.getName();\n+\n+        case Constants.DRETURN:\n+            return double.class.getName();\n+\n+        case Constants.ARETURN:\n+            return Object.class.getName();\n+\n+        case Constants.RETURN:\n+            return void.class.getName();\n+\n+        default:\n+            return null;\n+        }\n+    }\n+\n+    public TypedInstruction setType(String type) {\n+        type = mapType(type, _mappings, true);\n+\n+        if (type == null) {\n+            return (TypedInstruction) setOpcode(Constants.NOP);\n+        }\n+\n+        switch (type.charAt(0)) {\n+        case 'i':\n+            return (TypedInstruction) setOpcode(Constants.IRETURN);\n+\n+        case 'l':\n+            return (TypedInstruction) setOpcode(Constants.LRETURN);\n+\n+        case 'f':\n+            return (TypedInstruction) setOpcode(Constants.FRETURN);\n+\n+        case 'd':\n+            return (TypedInstruction) setOpcode(Constants.DRETURN);\n+\n+        case 'v':\n+            return (TypedInstruction) setOpcode(Constants.RETURN);\n+\n+        default:\n+            return (TypedInstruction) setOpcode(Constants.ARETURN);\n+        }\n+    }\n+\n+    public int getLogicalStackChange() {\n+        switch (getOpcode()) {\n+        case Constants.NOP:\n+            return 0;\n+\n+        default:\n+            return -1;\n+        }\n+    }\n+\n+    public int getStackChange() {\n+        switch (getOpcode()) {\n+        case Constants.RETURN:\n+        case Constants.NOP:\n+            return 0;\n+\n+        case Constants.LRETURN:\n+        case Constants.DRETURN:\n+            return -2;\n+\n+        default:\n+            return -1;\n+        }\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterReturnInstruction(this);\n+        visit.exitReturnInstruction(this);\n+    }\n+}"},{"sha":"ce8e22c2f33498900eccab6e6b715d3e00116415","filename":"serp/src/main/java/serp/bytecode/SourceFile.java","status":"added","additions":135,"deletions":0,"changes":135,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/SourceFile.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/SourceFile.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/SourceFile.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+\n+/**\n+ *  <p>Attribute naming the source file for this class.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class SourceFile extends Attribute {\n+    int _sourceFileIndex = 0;\n+\n+    SourceFile(int nameIndex, Attributes owner) {\n+        super(nameIndex, owner);\n+    }\n+\n+    int getLength() {\n+        return 2;\n+    }\n+\n+    /**\n+     *  Return the index into the class {@link ConstantPool} of the\n+     *  {@link UTF8Entry} naming the source file for this class, or 0 if\n+     *  not set.\n+     */\n+    public int getFileIndex() {\n+        return _sourceFileIndex;\n+    }\n+\n+    /**\n+     *  Set the index into the class {@link ConstantPool} of the\n+     *  {@link UTF8Entry} naming the source file for this class.\n+     */\n+    public void setFileIndex(int sourceFileIndex) {\n+        if (sourceFileIndex < 0) {\n+            sourceFileIndex = 0;\n+        }\n+\n+        _sourceFileIndex = sourceFileIndex;\n+    }\n+\n+    /**\n+     *  Return the name of the source file, or null if not set.\n+     */\n+    public String getFileName() {\n+        if (_sourceFileIndex == 0) {\n+            return null;\n+        }\n+\n+        return ((UTF8Entry) getPool().getEntry(_sourceFileIndex)).getValue();\n+    }\n+\n+    /**\n+     *  Return the file object for the source file, or null if not set.\n+     *\n+     *  @param dir                the directory of the file, or null\n+     */\n+    public File getFile(File dir) {\n+        String name = getFileName();\n+\n+        if (name == null) {\n+            return null;\n+        }\n+\n+        return new File(dir, name);\n+    }\n+\n+    /**\n+     *  Set the name of the source file.  The name should be the file name\n+     *  only; it should not include the path to the file.\n+      */\n+    public void setFile(String name) {\n+        if (name == null) {\n+            setFileIndex(0);\n+        } else {\n+            setFileIndex(getPool().findUTF8Entry(name, true));\n+        }\n+    }\n+\n+    /**\n+     *  Set the source file.  Note that only the file name is recorded;\n+     *  the path to the file is discarded.\n+     */\n+    public void setFile(File file) {\n+        if (file == null) {\n+            setFile((String) null);\n+        } else {\n+            setFile(file.getName());\n+        }\n+    }\n+\n+    /**\n+      *  Set the file name from the current class name plus the .java extension.\n+     */\n+    public void setFromClassName() {\n+        setFile(((BCClass) getOwner()).getClassName() + \".java\");\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterSourceFile(this);\n+        visit.exitSourceFile(this);\n+    }\n+\n+    void read(Attribute other) {\n+        setFile(((SourceFile) other).getFileName());\n+    }\n+\n+    void read(DataInput in, int length) throws IOException {\n+        setFileIndex(in.readUnsignedShort());\n+    }\n+\n+    void write(DataOutput out, int length) throws IOException {\n+        out.writeShort(getFileIndex());\n+    }\n+}"},{"sha":"0bf25a6da260b61a5794f65d80363511697acb50","filename":"serp/src/main/java/serp/bytecode/StackInstruction.java","status":"added","additions":177,"deletions":0,"changes":177,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/StackInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/StackInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/StackInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,177 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import serp.bytecode.visitor.*;\n+\n+\n+/**\n+ *  <p>Represents an instruction that manipulates the stack of the current\n+ *  frame.  Using the {@link #setType} methods is a hint about the type being\n+ *  manipulated that might cause this instruction to use the wide version\n+ *  of the opcode it represents (if manipulating a long or double).  This\n+ *  saves the developer from having to decide at compile time whether to\n+ *  use <code>pop</code> or <code>pop2</code>, etc.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class StackInstruction extends TypedInstruction {\n+    StackInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    public int getLogicalStackChange() {\n+        return getStackChange();\n+    }\n+\n+    public int getStackChange() {\n+        switch (getOpcode()) {\n+        case Constants.POP:\n+            return -1;\n+\n+        case Constants.POP2:\n+            return -2;\n+\n+        case Constants.DUP:\n+        case Constants.DUPX1:\n+        case Constants.DUPX2:\n+            return 1;\n+\n+        case Constants.DUP2:\n+        case Constants.DUP2X1:\n+        case Constants.DUP2X2:\n+            return 2;\n+\n+        default:\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     *  This method will always return null; use {@link #isWide} to determine\n+     *  if this is pop2, dup2, etc.\n+     */\n+    public String getTypeName() {\n+        return null;\n+    }\n+\n+    public TypedInstruction setType(String type) {\n+        type = getProject().getNameCache().getExternalForm(type, false);\n+\n+        return setWide(long.class.getName().equals(type) ||\n+            double.class.getName().equals(type));\n+    }\n+\n+    /**\n+     *  Return whether to use the wide form of the current opcode for\n+     *  operations on longs or doubles.\n+     */\n+    public boolean isWide() {\n+        switch (getOpcode()) {\n+        case Constants.POP2:\n+        case Constants.DUP2:\n+        case Constants.DUP2X1:\n+        case Constants.DUP2X2:\n+            return true;\n+\n+        default:\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     *  Set whether to use the wide form of the current opcode for operations\n+     *  on longs or doubles.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public StackInstruction setWide(boolean wide) {\n+        switch (getOpcode()) {\n+        case Constants.POP:\n+\n+            if (wide) {\n+                setOpcode(Constants.POP2);\n+            }\n+\n+            break;\n+\n+        case Constants.POP2:\n+\n+            if (!wide) {\n+                setOpcode(Constants.POP);\n+            }\n+\n+            break;\n+\n+        case Constants.DUP:\n+\n+            if (wide) {\n+                setOpcode(Constants.DUP2);\n+            }\n+\n+            break;\n+\n+        case Constants.DUP2:\n+\n+            if (!wide) {\n+                setOpcode(Constants.DUP);\n+            }\n+\n+            break;\n+\n+        case Constants.DUPX1:\n+\n+            if (wide) {\n+                setOpcode(Constants.DUP2X1);\n+            }\n+\n+            break;\n+\n+        case Constants.DUP2X1:\n+\n+            if (!wide) {\n+                setOpcode(Constants.DUPX1);\n+            }\n+\n+            break;\n+\n+        case Constants.DUPX2:\n+\n+            if (wide) {\n+                setOpcode(Constants.DUP2X2);\n+            }\n+\n+            break;\n+\n+        case Constants.DUP2X2:\n+\n+            if (!wide) {\n+                setOpcode(Constants.DUPX2);\n+            }\n+\n+            break;\n+        }\n+\n+        return this;\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterStackInstruction(this);\n+        visit.exitStackInstruction(this);\n+    }\n+}"},{"sha":"e4c282f56ad167a30d04a672496ae3f72bfbfe1a","filename":"serp/src/main/java/serp/bytecode/State.java","status":"added","additions":208,"deletions":0,"changes":208,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/State.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/State.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/State.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,208 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>The State type is extended by various concrete types to change\n+ *  the behavior of a {@link BCClass}.  All methods in this base\n+ *  implementation throw an {@link UnsupportedOperationException}</p>\n+ *\n+ *  @author Abe White\n+ */\n+class State {\n+    /**\n+     *  A singleton instance of this type that can be used to make a\n+     *  class invalid.\n+     */\n+    public static final State INVALID = new State();\n+\n+    /**\n+     *  Return the magic number of the bytecode class.\n+     */\n+    public int getMagic() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Set the magic number of the bytecode class.\n+     */\n+    public void setMagic(int magic) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Return the major number of the bytecode class.\n+     */\n+    public int getMajorVersion() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Set the major version of the bytecode class.\n+     */\n+    public void setMajorVersion(int major) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Return the minor number of the bytecode class.\n+     */\n+    public int getMinorVersion() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Set the minor version of the bytecode class.\n+     */\n+    public void setMinorVersion(int minor) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Return the access flags of the bytecode class.\n+     */\n+    public int getAccessFlags() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Set the access flags of the bytecode class.\n+     */\n+    public void setAccessFlags(int access) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Return the {@link ConstantPool} index of the {@link ClassEntry}\n+     *  for this class, or 0 if none.\n+     */\n+    public int getIndex() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Set the {@link ConstantPool} index of the {@link ClassEntry}\n+     *  for this class.\n+     */\n+    public void setIndex(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Return the {@link ConstantPool} index of the {@link ClassEntry}\n+     *  for the superclass of this class, or 0 if none.\n+     */\n+    public int getSuperclassIndex() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Set the {@link ConstantPool} index of the {@link ClassEntry}\n+     *  for the superclass of this class.  Throws\n+     *  {@link UnsupportedOperationException} by default.\n+     */\n+    public void setSuperclassIndex(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Return the {@link ConstantPool} indexes of the {@link ClassEntry}s\n+     *  for the indexes of this class, or empty collection if none.  If the\n+     *  state does not support changing the interfaces, the returned\n+     *  collection should be immutable.\n+     */\n+    public Collection getInterfacesHolder() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Return the {@link BCField}s of this class, or empty collection if none.\n+     *  If the state does not support changing the fields, the returned\n+     *  collection should be immutable.\n+     */\n+    public Collection getFieldsHolder() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Return the {@link BCMethod}s of this class, or empty collection if none.\n+     *  If the state does not support changing the methods, the returned\n+     *  collection should be immutable.\n+     */\n+    public Collection getMethodsHolder() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Return the {@link Attribute}s of this class, or empty collection if\n+     *  none.  If the state does not support changing the attributes, the\n+     *  returned collection should be immutable.\n+     */\n+    public Collection getAttributesHolder() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Return the constant pool of the class.\n+     */\n+    public ConstantPool getPool() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Return the name of the class.  The name should be in a form suitable\n+     *  for a {@link Class#forName} call.\n+     */\n+    public String getName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Return the name of the superclass.  The name should be in a form\n+     *  suitable for a {@link Class#forName} call, or null if none.\n+     */\n+    public String getSuperclassName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Return the name of the component type of this array, or null if not\n+     *  an array.  The name should be in a form suitable for a\n+     *  {@link Class#forName} call.\n+     */\n+    public String getComponentName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Return true if this class is a primitive.\n+     */\n+    public boolean isPrimitive() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     *  Return true if this class is an array.\n+     */\n+    public boolean isArray() {\n+        throw new UnsupportedOperationException();\n+    }\n+}"},{"sha":"bbc747ee1e051c2bf6ad7c92372ee8312b64419a","filename":"serp/src/main/java/serp/bytecode/StoreInstruction.java","status":"added","additions":281,"deletions":0,"changes":281,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/StoreInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/StoreInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/StoreInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+\n+/**\n+ *  <p>An instruction to store a value from a local variable onto\n+ *  the stack.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class StoreInstruction extends LocalVariableInstruction {\n+    private static final Class[][] _mappings = new Class[][] {\n+            { byte.class, int.class },\n+            { boolean.class, int.class },\n+            { char.class, int.class },\n+            { short.class, int.class },\n+            { void.class, int.class },\n+        };\n+    String _type = null;\n+\n+    StoreInstruction(Code owner) {\n+        super(owner);\n+    }\n+\n+    StoreInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    int getLength() {\n+        switch (getOpcode()) {\n+        case Constants.ISTORE:\n+        case Constants.LSTORE:\n+        case Constants.FSTORE:\n+        case Constants.DSTORE:\n+        case Constants.ASTORE:\n+            return super.getLength() + 1;\n+\n+        default:\n+            return super.getLength();\n+        }\n+    }\n+\n+    public int getLogicalStackChange() {\n+        switch (getOpcode()) {\n+        case Constants.NOP:\n+            return 0;\n+\n+        default:\n+            return -1;\n+        }\n+    }\n+\n+    public int getStackChange() {\n+        switch (getOpcode()) {\n+        case Constants.LSTORE:\n+        case Constants.LSTORE0:\n+        case Constants.LSTORE1:\n+        case Constants.LSTORE2:\n+        case Constants.LSTORE3:\n+        case Constants.DSTORE:\n+        case Constants.DSTORE0:\n+        case Constants.DSTORE1:\n+        case Constants.DSTORE2:\n+        case Constants.DSTORE3:\n+            return -2;\n+\n+        case Constants.NOP:\n+            return 0;\n+\n+        default:\n+            return -1;\n+        }\n+    }\n+\n+    public String getTypeName() {\n+        switch (getOpcode()) {\n+        case Constants.ISTORE:\n+        case Constants.ISTORE0:\n+        case Constants.ISTORE1:\n+        case Constants.ISTORE2:\n+        case Constants.ISTORE3:\n+            return int.class.getName();\n+\n+        case Constants.LSTORE:\n+        case Constants.LSTORE0:\n+        case Constants.LSTORE1:\n+        case Constants.LSTORE2:\n+        case Constants.LSTORE3:\n+            return long.class.getName();\n+\n+        case Constants.FSTORE:\n+        case Constants.FSTORE0:\n+        case Constants.FSTORE1:\n+        case Constants.FSTORE2:\n+        case Constants.FSTORE3:\n+            return float.class.getName();\n+\n+        case Constants.DSTORE:\n+        case Constants.DSTORE0:\n+        case Constants.DSTORE1:\n+        case Constants.DSTORE2:\n+        case Constants.DSTORE3:\n+            return double.class.getName();\n+\n+        case Constants.ASTORE:\n+        case Constants.ASTORE0:\n+        case Constants.ASTORE1:\n+        case Constants.ASTORE2:\n+        case Constants.ASTORE3:\n+            return Object.class.getName();\n+\n+        default:\n+            return _type;\n+        }\n+    }\n+\n+    public TypedInstruction setType(String type) {\n+        type = mapType(type, _mappings, true);\n+\n+        int local = getLocal();\n+\n+        // if an invalid type or local, revert to nop\n+        if ((type == null) || (local < 0)) {\n+            _type = type;\n+\n+            return (TypedInstruction) setOpcode(Constants.NOP);\n+        }\n+\n+        // valid opcode, unset saved type\n+        _type = null;\n+\n+        switch (type.charAt(0)) {\n+        case 'i':\n+            return (TypedInstruction) setOpcode((local > 3) ? Constants.ISTORE\n+                                                            : (Constants.ISTORE0 +\n+                local));\n+\n+        case 'l':\n+            return (TypedInstruction) setOpcode((local > 3) ? Constants.LSTORE\n+                                                            : (Constants.LSTORE0 +\n+                local));\n+\n+        case 'f':\n+            return (TypedInstruction) setOpcode((local > 3) ? Constants.FSTORE\n+                                                            : (Constants.FSTORE0 +\n+                local));\n+\n+        case 'd':\n+            return (TypedInstruction) setOpcode((local > 3) ? Constants.DSTORE\n+                                                            : (Constants.DSTORE0 +\n+                local));\n+\n+        default:\n+            return (TypedInstruction) setOpcode((local > 3) ? Constants.ASTORE\n+                                                            : (Constants.ASTORE0 +\n+                local));\n+        }\n+    }\n+\n+    /**\n+     *  StoreInstructions are equal if the type they reference the same\n+     *  type and locals index or if either is unset.\n+     */\n+    public boolean equalsInstruction(Instruction other) {\n+        if (other == this) {\n+            return true;\n+        }\n+\n+        if (!super.equalsInstruction(other)) {\n+            return false;\n+        }\n+\n+        String type = getTypeName();\n+        String otherType = ((StoreInstruction) other).getTypeName();\n+\n+        return (type == null) || (otherType == null) || type.equals(otherType);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterStoreInstruction(this);\n+        visit.exitStoreInstruction(this);\n+    }\n+\n+    void read(Instruction orig) {\n+        super.read(orig);\n+\n+        StoreInstruction ins = (StoreInstruction) orig;\n+        _type = ins._type;\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        super.read(in);\n+\n+        switch (getOpcode()) {\n+        case Constants.ISTORE:\n+        case Constants.LSTORE:\n+        case Constants.FSTORE:\n+        case Constants.DSTORE:\n+        case Constants.ASTORE:\n+            setLocal(in.readUnsignedByte());\n+\n+            break;\n+        }\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        super.write(out);\n+\n+        switch (getOpcode()) {\n+        case Constants.ISTORE:\n+        case Constants.LSTORE:\n+        case Constants.FSTORE:\n+        case Constants.DSTORE:\n+        case Constants.ASTORE:\n+            out.writeByte(getLocal());\n+        }\n+    }\n+\n+    void calculateOpcode() {\n+        // taken care of when setting type\n+        setType(getTypeName());\n+    }\n+\n+    void calculateLocal() {\n+        switch (getOpcode()) {\n+        case Constants.ISTORE0:\n+        case Constants.LSTORE0:\n+        case Constants.FSTORE0:\n+        case Constants.DSTORE0:\n+        case Constants.ASTORE0:\n+            setLocal(0);\n+\n+            break;\n+\n+        case Constants.ISTORE1:\n+        case Constants.LSTORE1:\n+        case Constants.FSTORE1:\n+        case Constants.DSTORE1:\n+        case Constants.ASTORE1:\n+            setLocal(1);\n+\n+            break;\n+\n+        case Constants.ISTORE2:\n+        case Constants.LSTORE2:\n+        case Constants.FSTORE2:\n+        case Constants.DSTORE2:\n+        case Constants.ASTORE2:\n+            setLocal(2);\n+\n+            break;\n+\n+        case Constants.ISTORE3:\n+        case Constants.LSTORE3:\n+        case Constants.FSTORE3:\n+        case Constants.DSTORE3:\n+        case Constants.ASTORE3:\n+            setLocal(3);\n+\n+            break;\n+        }\n+    }\n+}"},{"sha":"53573ab77a25d160d261a967257842a5cf7846ff","filename":"serp/src/main/java/serp/bytecode/SwitchInstruction.java","status":"added","additions":247,"deletions":0,"changes":247,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/SwitchInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/SwitchInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/SwitchInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import java.io.DataInput;\n+import java.io.IOException;\n+\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+/**\n+ *  Contains functionality common to the different switch types\n+ *  (TableSwitch and LookupSwitch).\n+ *\n+ *  @author Eric Lindauer\n+ */\n+public abstract class SwitchInstruction extends JumpInstruction {\n+    private List _cases = new LinkedList();\n+\n+    public SwitchInstruction(Code owner, int opcode) {\n+        super(owner, opcode);\n+    }\n+\n+    /**\n+     *  Returns the current byte offsets for the different\n+     *  switch cases in this Instruction.\n+     */\n+    public int[] getOffsets() {\n+        int bi = getByteIndex();\n+        int[] offsets = new int[_cases.size()];\n+\n+        for (int i = 0; i < offsets.length; i++)\n+            offsets[i] = ((InstructionPtrStrategy) _cases.get(i)).getByteIndex() -\n+                bi;\n+\n+        return offsets;\n+    }\n+\n+    /**\n+     *  Sets the offsets for the instructions representing the different\n+     *  switch statement cases.  WARNING: these offsets will not be changed\n+     *  in the event that the code is modified following this call. It is\n+     *  typically a good idea to follow this call with a call to updateTargets\n+     *  as soon as the instructions at the given offsets are valid, at which\n+     *  point the Instructions themselves will be used as the targets and the\n+     *  offsets will be updated as expected.\n+     */\n+    public void setOffsets(int[] offsets) {\n+        int bi = getByteIndex();\n+        _cases.clear();\n+\n+        for (int i = 0; i < offsets.length; i++) {\n+            InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n+            next.setByteIndex(offsets[i] + bi);\n+            _cases.add(next);\n+        }\n+    }\n+\n+    public int countTargets() {\n+        return _cases.size();\n+    }\n+\n+    int getLength() {\n+        // don't call super.getLength(), cause JumpInstruction will return\n+        // value assuming this is an 'if' or 'goto' instruction\n+        int length = 1;\n+\n+        // make the first byte of the 'default' a multiple of 4 from the\n+        // start of the method\n+        int byteIndex = getByteIndex() + 1;\n+\n+        for (; (byteIndex % 4) != 0; byteIndex++, length++)\n+            ;\n+\n+        return length;\n+    }\n+\n+    /**\n+     *  Synonymous with {@link #getTarget}.\n+     */\n+    public Instruction getDefaultTarget() {\n+        return getTarget();\n+    }\n+\n+    /**\n+     *  Synonymous with {@link #getOffset}.\n+     */\n+    public int getDefaultOffset() {\n+        return getOffset();\n+    }\n+\n+    /**\n+     *  Synonymous with {@link #setOffset}.\n+     */\n+    public SwitchInstruction setDefaultOffset(int offset) {\n+        setOffset(offset);\n+\n+        return this;\n+    }\n+\n+    /**\n+     *  Synonymous with {@link #setTarget}.\n+     */\n+    public SwitchInstruction setDefaultTarget(Instruction ins) {\n+        return (SwitchInstruction) setTarget(ins);\n+    }\n+\n+    /**\n+     *  Return the targets for this switch, or empty array if not set.\n+     */\n+    public Instruction[] getTargets() {\n+        Instruction[] result = new Instruction[_cases.size()];\n+\n+        for (int i = 0; i < _cases.size(); i++)\n+            result[i] = ((InstructionPtrStrategy) _cases.get(i)).getTargetInstruction();\n+\n+        return result;\n+    }\n+\n+    /**\n+     *  Set the jump points for this switch.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public SwitchInstruction setTargets(Instruction[] targets) {\n+        _cases.clear();\n+\n+        if (targets != null) {\n+            for (int i = 0; i < targets.length; i++)\n+                addTarget(targets[i]);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     *  Add a target to this switch.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public SwitchInstruction addTarget(Instruction target) {\n+        _cases.add(new InstructionPtrStrategy(this, target));\n+\n+        return this;\n+    }\n+\n+    public int getLogicalStackChange() {\n+        return getStackChange();\n+    }\n+\n+    public int getStackChange() {\n+        return -1;\n+    }\n+\n+    public void updateTargets() {\n+        super.updateTargets();\n+\n+        for (Iterator itr = _cases.iterator(); itr.hasNext();)\n+            ((InstructionPtrStrategy) itr.next()).updateTargets();\n+    }\n+\n+    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n+        super.replaceTarget(oldTarget, newTarget);\n+\n+        for (Iterator itr = _cases.iterator(); itr.hasNext();)\n+            ((InstructionPtrStrategy) itr.next()).replaceTarget(oldTarget,\n+                newTarget);\n+    }\n+\n+    void read(Instruction orig) {\n+        super.read(orig);\n+\n+        SwitchInstruction ins = (SwitchInstruction) orig;\n+        _cases.clear();\n+\n+        for (Iterator itr = ins._cases.iterator(); itr.hasNext();) {\n+            InstructionPtrStrategy incoming = (InstructionPtrStrategy) itr.next();\n+            InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n+            next.setByteIndex(incoming.getByteIndex());\n+            _cases.add(next);\n+        }\n+    }\n+\n+    void clearTargets() {\n+        _cases.clear();\n+    }\n+\n+    void readTarget(DataInput in) throws IOException {\n+        InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n+        next.setByteIndex(getByteIndex() + in.readInt());\n+        _cases.add(next);\n+    }\n+\n+    /**\n+     *  Set the match-jumppt pairs for this switch.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public SwitchInstruction setCases(int[] matches, Instruction[] targets) {\n+        setMatches(matches);\n+        setTargets(targets);\n+\n+        return this;\n+    }\n+\n+    public SwitchInstruction setMatches(int[] matches) {\n+        clearMatches();\n+\n+        for (int i = 0; i < matches.length; i++)\n+            addMatch(matches[i]);\n+\n+        return this;\n+    }\n+\n+    /**\n+     *  Add a case to this switch.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public SwitchInstruction addCase(int match, Instruction target) {\n+        addMatch(match);\n+        addTarget(target);\n+\n+        return this;\n+    }\n+\n+    public abstract SwitchInstruction addMatch(int match);\n+\n+    public abstract int[] getMatches();\n+\n+    abstract void clearMatches();\n+}"},{"sha":"c17947bed73222acd98efc6f053575facb4921d9","filename":"serp/src/main/java/serp/bytecode/Synthetic.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Synthetic.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/Synthetic.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Synthetic.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+\n+/**\n+ *  <p>Attribute marking a member as synthetic, or not present in the class\n+ *  source code.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class Synthetic extends Attribute {\n+    Synthetic(int nameIndex, Attributes owner) {\n+        super(nameIndex, owner);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterSynthetic(this);\n+        visit.exitSynthetic(this);\n+    }\n+}"},{"sha":"8a7cfa8b2ec0818f21a74679225d2b03ca9eeee7","filename":"serp/src/main/java/serp/bytecode/TableSwitchInstruction.java","status":"added","additions":272,"deletions":0,"changes":272,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/TableSwitchInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/TableSwitchInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/TableSwitchInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89","patch":"@@ -0,0 +1,272 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package serp.bytecode;\n+\n+import serp.bytecode.visitor.*;\n+\n+import java.io.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ *  <p>The <code>tableswitch</code> instruction.</p>\n+ *\n+ *  @author Abe White\n+ */\n+public class TableSwitchInstruction extends JumpInstruction {\n+    // case info\n+    private int _low = 0;\n+    private int _high = 0;\n+    private List _cases = new LinkedList();\n+\n+    TableSwitchInstruction(Code owner) {\n+        super(owner, Constants.TABLESWITCH);\n+    }\n+\n+    /**\n+     *  Returns the current byte offsets for the different\n+     *  switch cases in this Instruction.\n+     */\n+    public int[] getOffsets() {\n+        int bi = getByteIndex();\n+        int[] offsets = new int[_cases.size()];\n+\n+        for (int i = 0; i < _cases.size(); i++)\n+            offsets[i] = ((InstructionPtrStrategy) _cases.get(i)).getByteIndex() -\n+                bi;\n+\n+        return offsets;\n+    }\n+\n+    /**\n+     *  Sets the offsets for the instructions representing the different\n+     *  switch statement cases.  WARNING: these offsets will not be changed\n+     *  in the event that the code is modified following this call. It is\n+     *  typically a good idea to follow this call with a call to updateTargets\n+     *  as soon as the instructions at the given offsets are valid, at which\n+     *  point the Instructions themselves will be used as the targets and the\n+     *  offsets will be updated as expected.\n+     */\n+    public void setOffsets(int[] offsets) {\n+        int bi = getByteIndex();\n+        _cases.clear();\n+\n+        for (int i = 0; i < offsets.length; i++) {\n+            InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n+            next.setByteIndex(offsets[i] + bi);\n+            _cases.add(next);\n+        }\n+    }\n+\n+    int getLength() {\n+        // don't call super\n+        int length = 1;\n+\n+        // make the first byte of the 'default' a multiple of 4 from the\n+        // start of the method\n+        int byteIndex = getByteIndex() + 1;\n+\n+        for (; (byteIndex % 4) != 0; byteIndex++, length++)\n+            ;\n+\n+        // default, low, high\n+        length += 12;\n+\n+        // offsets\n+        length += (4 * _cases.size());\n+\n+        return length;\n+    }\n+\n+    /**\n+     *  Synonymous with {@link #getTarget}.\n+     */\n+    public Instruction getDefaultTarget() {\n+        return getTarget();\n+    }\n+\n+    /**\n+     *  Synonymous with {@link #setTarget}.\n+     */\n+    public TableSwitchInstruction setDefaultTarget(Instruction ins) {\n+        return (TableSwitchInstruction) setTarget(ins);\n+    }\n+\n+    /**\n+     *  Synonymous with {@link #getOffset}.\n+     */\n+    public int getDefaultOffset() {\n+        return getOffset();\n+    }\n+\n+    /**\n+     *  Synonymous with {@link #setOffset}.\n+     */\n+    public TableSwitchInstruction setDefaultOffset(int offset) {\n+        setOffset(offset);\n+\n+        return this;\n+    }\n+\n+    public int getLow() {\n+        return _low;\n+    }\n+\n+    public TableSwitchInstruction setLow(int low) {\n+        _low = low;\n+\n+        return this;\n+    }\n+\n+    public int getHigh() {\n+        return _high;\n+    }\n+\n+    public TableSwitchInstruction setHigh(int high) {\n+        _high = high;\n+\n+        return this;\n+    }\n+\n+    /**\n+     *  Return the targets for this switch, or empty array if not set.\n+     */\n+    public Instruction[] getTargets() {\n+        Instruction[] result = new Instruction[_cases.size()];\n+\n+        for (int i = 0; i < _cases.size(); i++)\n+            result[i] = ((InstructionPtrStrategy) _cases.get(i)).getTargetInstruction();\n+\n+        return result;\n+    }\n+\n+    /**\n+     *  Set the jump points for this switch.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public TableSwitchInstruction setTargets(Instruction[] targets) {\n+        _cases.clear();\n+\n+        if (targets != null) {\n+            for (int i = 0; i < targets.length; i++)\n+                addTarget(targets[i]);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     *  Add a target to this switch.\n+     *\n+     *  @return this instruction, for method chaining\n+     */\n+    public TableSwitchInstruction addTarget(Instruction target) {\n+        _cases.add(new InstructionPtrStrategy(this, target));\n+\n+        return this;\n+    }\n+\n+    public int getStackChange() {\n+        return -1;\n+    }\n+\n+    private Instruction findTarget(int jumpByteIndex, List inss) {\n+        Instruction ins;\n+\n+        for (Iterator itr = inss.iterator(); itr.hasNext();) {\n+            ins = (Instruction) itr.next();\n+\n+            if (ins.getByteIndex() == jumpByteIndex) {\n+                return ins;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public void updateTargets() {\n+        super.updateTargets();\n+\n+        for (Iterator itr = _cases.iterator(); itr.hasNext();)\n+            ((InstructionPtrStrategy) itr.next()).updateTargets();\n+    }\n+\n+    public void replaceTarget(Instruction oldTarget, Instruction newTarget) {\n+        super.replaceTarget(oldTarget, newTarget);\n+\n+        for (Iterator itr = _cases.iterator(); itr.hasNext();)\n+            ((InstructionPtrStrategy) itr.next()).replaceTarget(oldTarget,\n+                newTarget);\n+    }\n+\n+    public void acceptVisit(BCVisitor visit) {\n+        visit.enterTableSwitchInstruction(this);\n+        visit.exitTableSwitchInstruction(this);\n+    }\n+\n+    void read(Instruction orig) {\n+        super.read(orig);\n+\n+        TableSwitchInstruction ins = (TableSwitchInstruction) orig;\n+        setLow(ins.getLow());\n+        setHigh(ins.getHigh());\n+\n+        for (Iterator itr = ins._cases.iterator(); itr.hasNext();) {\n+            InstructionPtrStrategy incoming = (InstructionPtrStrategy) itr.next();\n+            InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n+            next.setByteIndex(incoming.getByteIndex());\n+            _cases.add(next);\n+        }\n+    }\n+\n+    void read(DataInput in) throws IOException {\n+        // don't call super\n+        int bi = getByteIndex();\n+\n+        for (int byteIndex = bi + 1; (byteIndex % 4) != 0; byteIndex++)\n+            in.readByte();\n+\n+        setOffset(in.readInt());\n+        setLow(in.readInt());\n+        setHigh(in.readInt());\n+\n+        _cases.clear();\n+\n+        for (int i = 0; i < (_high - _low + 1); i++) {\n+            InstructionPtrStrategy next = new InstructionPtrStrategy(this);\n+            next.setByteIndex(bi + in.readInt());\n+            _cases.add(next);\n+        }\n+    }\n+\n+    void write(DataOutput out) throws IOException {\n+        // don't call super\n+        int bi = getByteIndex();\n+\n+        for (int byteIndex = bi + 1; (byteIndex % 4) != 0; byteIndex++)\n+            out.writeByte(0);\n+\n+        out.writeInt(getOffset());\n+        out.writeInt(getLow());\n+        out.writeInt(getHigh());\n+\n+        for (Iterator itr = _cases.iterator(); itr.hasNext();)\n+            out.writeInt(((InstructionPtrStrategy) itr.next()).getByteIndex() -\n+                bi);\n+    }\n+}"},{"sha":"3bba8ac604fa89707c7e7c46a59e5c7317941c93","filename":"serp/src/main/java/serp/bytecode/TypedInstruction.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/TypedInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/TypedInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/TypedInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"8f55134998ef7b7b06588c493f43febe066070b2","filename":"serp/src/main/java/serp/bytecode/UnknownAttribute.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/UnknownAttribute.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/UnknownAttribute.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/UnknownAttribute.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"9c467e3331a0562810f9ad530112f161d77b0ef8","filename":"serp/src/main/java/serp/bytecode/WideInstruction.java","status":"added","additions":427,"deletions":0,"changes":427,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/WideInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/WideInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/WideInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"d32da4f755a4e1cb57226a79aa41df488743fb54","filename":"serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java","status":"added","additions":101,"deletions":0,"changes":101,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"dec9db1927e7938005e301f243c8b27dc093b227","filename":"serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java","status":"added","additions":115,"deletions":0,"changes":115,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"9172e739e1b21d715a51c135718299b0a775aa53","filename":"serp/src/main/java/serp/bytecode/lowlevel/ConstantEntry.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/ConstantEntry.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/ConstantEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ConstantEntry.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"bd3efd25494c76e8af3b41475db44fd43bfca57e","filename":"serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java","status":"added","additions":725,"deletions":0,"changes":725,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"cf38888bbb06e80e19586b39718f1d7ac8c66b46","filename":"serp/src/main/java/serp/bytecode/lowlevel/ConstantPoolTable.java","status":"added","additions":207,"deletions":0,"changes":207,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/ConstantPoolTable.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/ConstantPoolTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ConstantPoolTable.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"6646eca713d3a9d7ed3157726290803453efd044","filename":"serp/src/main/java/serp/bytecode/lowlevel/DoubleEntry.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/DoubleEntry.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/DoubleEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/DoubleEntry.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"e5cd5b1eeac4fe0266a798484fed14e5b679bd69","filename":"serp/src/main/java/serp/bytecode/lowlevel/Entry.java","status":"added","additions":188,"deletions":0,"changes":188,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/Entry.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/Entry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/Entry.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"48e6a2b76d291118cee665e8b9f25aafbdfa594f","filename":"serp/src/main/java/serp/bytecode/lowlevel/FieldEntry.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/FieldEntry.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/FieldEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/FieldEntry.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"0907cd28bd66d1cce51cbfd78843c17aa1dc6731","filename":"serp/src/main/java/serp/bytecode/lowlevel/FloatEntry.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/FloatEntry.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/FloatEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/FloatEntry.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"c9d5237e1030fb3497f649107d3ae7f6b0273473","filename":"serp/src/main/java/serp/bytecode/lowlevel/IntEntry.java","status":"added","additions":88,"deletions":0,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/IntEntry.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/IntEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/IntEntry.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"b3ea1d4582add3b59c3f419d7cb5924978354126","filename":"serp/src/main/java/serp/bytecode/lowlevel/InterfaceMethodEntry.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/InterfaceMethodEntry.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/InterfaceMethodEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/InterfaceMethodEntry.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"c1cd1319d79d0d16f4823c5ae42c1d8b10700908","filename":"serp/src/main/java/serp/bytecode/lowlevel/LongEntry.java","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/LongEntry.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/LongEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/LongEntry.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"582813a3dfe6f64bf3552b10a52cbd4ceebe2da4","filename":"serp/src/main/java/serp/bytecode/lowlevel/MethodEntry.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/MethodEntry.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/MethodEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/MethodEntry.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"efe8260fdd1c7f39a053cadd383c71e02210f3b5","filename":"serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java","status":"added","additions":124,"deletions":0,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"533d854f07ff5446e0e49d020f972e18bdff05c7","filename":"serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"b6ef9f1c2c699596a62f7d0a8355cb8bb2d1d040","filename":"serp/src/main/java/serp/bytecode/lowlevel/UTF8Entry.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/UTF8Entry.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/UTF8Entry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/UTF8Entry.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"9b61b691167d33b2ead1a80e6031e497d68630cf","filename":"serp/src/main/java/serp/bytecode/lowlevel/package.html","status":"added","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/package.html","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/lowlevel/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/package.html?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"12ce4d8a6ef06a94dfae435223db8ef11463557b","filename":"serp/src/main/java/serp/bytecode/package.html","status":"added","additions":139,"deletions":0,"changes":139,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/package.html","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/package.html?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"00c2799afcc4d6f7611760e533fd7bf7aca3fcd8","filename":"serp/src/main/java/serp/bytecode/visitor/BCVisitor.java","status":"added","additions":415,"deletions":0,"changes":415,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/visitor/BCVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/visitor/BCVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/visitor/BCVisitor.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"cff04aff4583c69ab581d30a07892c3d27723d24","filename":"serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java","status":"added","additions":459,"deletions":0,"changes":459,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"509e7143be563e5fb23bb69b3f5ed9e908e19755","filename":"serp/src/main/java/serp/bytecode/visitor/VisitAcceptor.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/visitor/VisitAcceptor.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/visitor/VisitAcceptor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/visitor/VisitAcceptor.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"8321df185f5665c15102187820cadc50f8153579","filename":"serp/src/main/java/serp/bytecode/visitor/package.html","status":"added","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/visitor/package.html","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/bytecode/visitor/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/visitor/package.html?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"fde9ac3584ea3279dcce5729a368be001222cd3b","filename":"serp/src/main/java/serp/util/Numbers.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/util/Numbers.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/util/Numbers.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/util/Numbers.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"648008baa538d301f1b38ab114391b66e8003eb5","filename":"serp/src/main/java/serp/util/Strings.java","status":"added","additions":417,"deletions":0,"changes":417,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/util/Strings.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/util/Strings.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/util/Strings.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"b894612ee2ff760c2d1b6dc311c04c46e827889c","filename":"serp/src/main/java/serp/util/package.html","status":"added","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/util/package.html","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/main/java/serp/util/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/util/package.html?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"05f11aa0ae596114d253cb8c698ae8a1818013f7","filename":"serp/src/test/java/serp/bytecode/AbstractStateTest.java","status":"added","additions":207,"deletions":0,"changes":207,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/AbstractStateTest.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/AbstractStateTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/AbstractStateTest.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"176048c655685d144ec6128bb02b61f309d029a3","filename":"serp/src/test/java/serp/bytecode/TestArray.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestArray.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestArray.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestArray.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"12d6312bdf9d83e6dc2491686bb2efa359b17aeb","filename":"serp/src/test/java/serp/bytecode/TestArrayLoadInstruction.java","status":"added","additions":96,"deletions":0,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestArrayLoadInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestArrayLoadInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestArrayLoadInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"9016d9c3ceb5b6bb45904c9cb90b0bc2ad02cd69","filename":"serp/src/test/java/serp/bytecode/TestArrayStoreInstruction.java","status":"added","additions":96,"deletions":0,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestArrayStoreInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestArrayStoreInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestArrayStoreInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"f05508339129bda749ef06afa310e5b06c9e3d2e","filename":"serp/src/test/java/serp/bytecode/TestAttributes.java","status":"added","additions":155,"deletions":0,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestAttributes.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestAttributes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestAttributes.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"229ab2a390cd8c7491abfac992c7505b38bd0517","filename":"serp/src/test/java/serp/bytecode/TestBCClass.java","status":"added","additions":269,"deletions":0,"changes":269,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestBCClass.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestBCClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestBCClass.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"9c54b00d4eb52d37477ebe81ee8609a0ae5f47fb","filename":"serp/src/test/java/serp/bytecode/TestCode.java","status":"added","additions":142,"deletions":0,"changes":142,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestCode.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestCode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestCode.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"9ab0ea917a3c52f01494a3c3873376f708a285d6","filename":"serp/src/test/java/serp/bytecode/TestConstantInstruction.java","status":"added","additions":125,"deletions":0,"changes":125,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestConstantInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestConstantInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestConstantInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"1434eaf665bc890d6c815809819fe0ee00f3bb32","filename":"serp/src/test/java/serp/bytecode/TestConvertInstruction.java","status":"added","additions":99,"deletions":0,"changes":99,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestConvertInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestConvertInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestConvertInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"44ac535a7528467830e9f375c64516e8993e714b","filename":"serp/src/test/java/serp/bytecode/TestLoadInstruction.java","status":"added","additions":179,"deletions":0,"changes":179,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestLoadInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestLoadInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestLoadInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"59b61b9b7b984aa44c8c666d4819d0a4650c1abb","filename":"serp/src/test/java/serp/bytecode/TestMathInstruction.java","status":"added","additions":347,"deletions":0,"changes":347,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestMathInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestMathInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestMathInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"f4830f75ccc5e710ad093cdb32ff3aba5c97284b","filename":"serp/src/test/java/serp/bytecode/TestNameCache.java","status":"added","additions":217,"deletions":0,"changes":217,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestNameCache.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestNameCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestNameCache.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"45631b5d0c8ca80870c50a865624fe654a2c6043","filename":"serp/src/test/java/serp/bytecode/TestPrimitive.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestPrimitive.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestPrimitive.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestPrimitive.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"6218379fb94706bcad78ff6fb142544a4f3512f8","filename":"serp/src/test/java/serp/bytecode/TestProject.java","status":"added","additions":333,"deletions":0,"changes":333,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestProject.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestProject.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestProject.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"291cedadeed1e5784cb1e13cd32dc0ba5fc2d60f","filename":"serp/src/test/java/serp/bytecode/TestStoreInstruction.java","status":"added","additions":179,"deletions":0,"changes":179,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestStoreInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/TestStoreInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestStoreInstruction.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"23e53cf96292aef7ac790969603fc13dd32e9c10","filename":"serp/src/test/java/serp/bytecode/lowlevel/TestConstantPool.java","status":"added","additions":360,"deletions":0,"changes":360,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/lowlevel/TestConstantPool.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/bytecode/lowlevel/TestConstantPool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/lowlevel/TestConstantPool.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"},{"sha":"80505bdf777c754a3e298726829c90ac743a30bb","filename":"serp/src/test/java/serp/util/TestStrings.java","status":"added","additions":128,"deletions":0,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/util/TestStrings.java","raw_url":"https://github.com/apache/openjpa/raw/46e7dbf647b3ae5653e242218f7723f0b0dd5e89/serp/src/test/java/serp/util/TestStrings.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/util/TestStrings.java?ref=46e7dbf647b3ae5653e242218f7723f0b0dd5e89"}]}

