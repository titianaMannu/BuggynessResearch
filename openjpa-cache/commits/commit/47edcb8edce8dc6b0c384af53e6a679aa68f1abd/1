{"sha":"47edcb8edce8dc6b0c384af53e6a679aa68f1abd","node_id":"MDY6Q29tbWl0MjA2MzY0OjQ3ZWRjYjhlZGNlOGRjNmIwYzM4NGFmNTNlNmE2NzlhYTY4ZjFhYmQ=","commit":{"author":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-09-14T23:41:30Z"},"committer":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-09-14T23:41:30Z"},"message":"Don't use a subselect for non-distinct projections of DISTINCT_AUTO queries \nwith to-many joins in their filter if the projections are all for variable \npaths.  (As opposed to candidate path projections, where the subselect is \nnecessary to filter out duplicates caused by relational joins).\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@443519 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"06a865a73c08b034657bc496d51856b42d047fa6","url":"https://api.github.com/repos/apache/openjpa/git/trees/06a865a73c08b034657bc496d51856b42d047fa6"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/47edcb8edce8dc6b0c384af53e6a679aa68f1abd","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/47edcb8edce8dc6b0c384af53e6a679aa68f1abd","html_url":"https://github.com/apache/openjpa/commit/47edcb8edce8dc6b0c384af53e6a679aa68f1abd","comments_url":"https://api.github.com/repos/apache/openjpa/commits/47edcb8edce8dc6b0c384af53e6a679aa68f1abd/comments","author":null,"committer":null,"parents":[{"sha":"c6c683e8acfc4b188fa4af2f0293a43a33e39a4c","url":"https://api.github.com/repos/apache/openjpa/commits/c6c683e8acfc4b188fa4af2f0293a43a33e39a4c","html_url":"https://github.com/apache/openjpa/commit/c6c683e8acfc4b188fa4af2f0293a43a33e39a4c"}],"stats":{"total":63,"additions":57,"deletions":6},"files":[{"sha":"7606c9d8086d5bfcb3e360becc1bc64852ea54cf","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/47edcb8edce8dc6b0c384af53e6a679aa68f1abd/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","raw_url":"https://github.com/apache/openjpa/raw/47edcb8edce8dc6b0c384af53e6a679aa68f1abd/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java?ref=47edcb8edce8dc6b0c384af53e6a679aa68f1abd","patch":"@@ -129,6 +129,13 @@ public boolean isUnaccessedVariable() {\n         return _type == UNACCESSED_VAR;\n     }\n \n+    /**\n+     * Return whether this is a path involving a variable.\n+     */\n+    public boolean isVariablePath() {\n+        return _type != PATH;\n+    }\n+\n     /**\n      * If this path is part of a contains clause, then alias it to the\n      * proper contains id before initialization."},{"sha":"e9364758e9718a2f7c1f25c560ed946199f0f488","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java","status":"modified","additions":50,"deletions":6,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/47edcb8edce8dc6b0c384af53e6a679aa68f1abd/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java","raw_url":"https://github.com/apache/openjpa/raw/47edcb8edce8dc6b0c384af53e6a679aa68f1abd/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java?ref=47edcb8edce8dc6b0c384af53e6a679aa68f1abd","patch":"@@ -25,8 +25,11 @@\n import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.exps.AbstractExpressionVisitor;\n+import org.apache.openjpa.kernel.exps.Constant;\n import org.apache.openjpa.kernel.exps.Expression;\n import org.apache.openjpa.kernel.exps.QueryExpressions;\n+import org.apache.openjpa.kernel.exps.Value;\n \n /**\n  * Turns parsed queries into selects.\n@@ -120,8 +123,7 @@ private Select newSelect(ExpContext ctx, Select parent,\n             else if ((exps.distinct & exps.DISTINCT_FALSE) != 0)\n                 sel.setDistinct(false);\n         } else if (exps.projections.length > 0) {\n-            if (!sel.isDistinct() && (exps.distinct & exps.DISTINCT_TRUE) != 0)\n-            {\n+            if (!sel.isDistinct() && (exps.distinct & exps.DISTINCT_TRUE) != 0){\n                 // if the select is not distinct but the query is, force\n                 // the select to be distinct\n                 sel.setDistinct(true);\n@@ -133,19 +135,28 @@ else if ((exps.distinct & exps.DISTINCT_FALSE) != 0)\n                 // get unique candidate values) and needed field values and\n                 // applies the where conditions; the outer select applies\n                 // ordering, grouping, etc\n-                if (exps.isAggregate() \n-                    || (exps.distinct & exps.DISTINCT_TRUE) == 0) {\n+                boolean agg = exps.isAggregate();\n+                boolean candidate = ProjectionExpressionVisitor.\n+                    hasCandidateProjections(exps.projections);\n+                if (agg || (candidate \n+                    && (exps.distinct & exps.DISTINCT_TRUE) == 0)) {\n                     DBDictionary dict = ctx.store.getDBDictionary();\n                     dict.assertSupport(dict.supportsSubselect,\n                         \"SupportsSubselect\");\n \n                     Select inner = sel;\n                     sel = ctx.store.getSQLFactory().newSelect();\n                     sel.setParent(parent, alias);\n-                    sel.setDistinct(exps.isAggregate()\n+                    sel.setDistinct(agg\n                         && (exps.distinct & exps.DISTINCT_TRUE) != 0);\n                     sel.setFromSelect(inner);\n-                }\n+\n+                // auto-distincting happens to get unique candidate instances\n+                // back; don't auto-distinct if the user isn't selecting \n+                // candidate data\n+                } else if (!candidate \n+                    && (exps.distinct & exps.DISTINCT_TRUE) == 0) \n+                    sel.setDistinct(false);\n             }\n         }\n         return sel;\n@@ -295,4 +306,37 @@ public void select(Select sel, ExpContext ctx, ClassMapping mapping,\n                 ? inner : sel, subclasses, joins);\n         }\n     }\n+\n+    /**\n+     * Used to check whether a query's result projections are on the candidate.\n+     */\n+    private static class ProjectionExpressionVisitor\n+        extends AbstractExpressionVisitor {\n+\n+        private boolean _candidate = false;\n+        private int _level = 0;\n+\n+        public static boolean hasCandidateProjections(Value[] projs) {\n+            ProjectionExpressionVisitor v = new ProjectionExpressionVisitor();\n+            for (int i = 0; i < projs.length; i++) {\n+                projs[i].acceptVisit(v);\n+                if (v._candidate)\n+                    return true;\n+            }\n+            return false;\n+        }\n+\n+        public void enter(Value val) {\n+            if (!_candidate) {\n+                _candidate = (_level == 0 && val instanceof Constant)\n+                    || (val instanceof PCPath \n+                    && !((PCPath) val).isVariablePath());\n+            }\n+            _level++;\n+        }\n+\n+        public void exit(Value val) {\n+            _level--;\n+        }\n+    }\n }"}]}

