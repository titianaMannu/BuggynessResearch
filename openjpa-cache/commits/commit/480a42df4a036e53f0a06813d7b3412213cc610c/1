{"sha":"480a42df4a036e53f0a06813d7b3412213cc610c","node_id":"MDY6Q29tbWl0MjA2MzY0OjQ4MGE0MmRmNGEwMzZlNTNmMGEwNjgxM2Q3YjM0MTIyMTNjYzYxMGM=","commit":{"author":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-09-20T18:40:28Z"},"committer":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-09-20T18:40:28Z"},"message":"Perform JDBC sequence ops outside of synchronization blocks in case of JDBC\nhangs.  Also should improve concurrency.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@448298 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"3355530f6784ccee8e6e011365535230e8c6fea1","url":"https://api.github.com/repos/apache/openjpa/git/trees/3355530f6784ccee8e6e011365535230e8c6fea1"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/480a42df4a036e53f0a06813d7b3412213cc610c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/480a42df4a036e53f0a06813d7b3412213cc610c","html_url":"https://github.com/apache/openjpa/commit/480a42df4a036e53f0a06813d7b3412213cc610c","comments_url":"https://api.github.com/repos/apache/openjpa/commits/480a42df4a036e53f0a06813d7b3412213cc610c/comments","author":null,"committer":null,"parents":[{"sha":"cdcfea47d4568f69783c6733b27dfbc33e3ba621","url":"https://api.github.com/repos/apache/openjpa/commits/cdcfea47d4568f69783c6733b27dfbc33e3ba621","html_url":"https://github.com/apache/openjpa/commit/cdcfea47d4568f69783c6733b27dfbc33e3ba621"}],"stats":{"total":209,"additions":101,"deletions":108},"files":[{"sha":"c4f99c5b90dae2bc9cb66f53a4700e8d71769a9a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java","status":"modified","additions":17,"deletions":38,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/480a42df4a036e53f0a06813d7b3412213cc610c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/480a42df4a036e53f0a06813d7b3412213cc610c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java?ref=480a42df4a036e53f0a06813d7b3412213cc610c","patch":"@@ -41,18 +41,14 @@\n     protected int type = TYPE_DEFAULT;\n     protected Object current = null;\n \n-    // used to track current conn so that we can close it\n-    private Connection _conn = null;\n-    private boolean _commit = false;\n-\n     /**\n      * Records the sequence type.\n      */\n     public void setType(int type) {\n         this.type = type;\n     }\n \n-    public synchronized Object next(StoreContext ctx, ClassMetaData meta) {\n+    public Object next(StoreContext ctx, ClassMetaData meta) {\n         JDBCStore store = getStore(ctx);\n         try {\n             current = nextInternal(store, (ClassMapping) meta);\n@@ -63,12 +59,10 @@ public synchronized Object next(StoreContext ctx, ClassMetaData meta) {\n             throw SQLExceptions.getStore(se, store.getDBDictionary());\n         } catch (Exception e) {\n             throw new StoreException(e);\n-        } finally {\n-            closeConnection();\n         }\n     }\n \n-    public synchronized Object current(StoreContext ctx, ClassMetaData meta) {\n+    public Object current(StoreContext ctx, ClassMetaData meta) {\n         JDBCStore store = getStore(ctx);\n         try {\n             return currentInternal(store, (ClassMapping) meta);\n@@ -78,13 +72,10 @@ public synchronized Object current(StoreContext ctx, ClassMetaData meta) {\n             throw SQLExceptions.getStore(se, store.getDBDictionary());\n         } catch (Exception e) {\n             throw new StoreException(e);\n-        } finally {\n-            closeConnection();\n         }\n     }\n \n-    public synchronized void allocate(int additional, StoreContext ctx,\n-        ClassMetaData meta) {\n+    public void allocate(int additional, StoreContext ctx, ClassMetaData meta) {\n         JDBCStore store = getStore(ctx);\n         try {\n             allocateInternal(additional, store, (ClassMapping) meta);\n@@ -94,8 +85,6 @@ public synchronized void allocate(int additional, StoreContext ctx,\n             throw SQLExceptions.getStore(se, store.getDBDictionary());\n         } catch (Exception e) {\n             throw new StoreException(e);\n-        } finally {\n-            closeConnection();\n         }\n     }\n \n@@ -121,7 +110,7 @@ protected abstract Object nextInternal(JDBCStore store,\n     /**\n      * Return the current sequence object. By default returns the last\n      * sequence value used, or null if no sequence values have been requested\n-     * yet.\n+     * yet. Default implementation is not threadsafe.\n      */\n     protected Object currentInternal(JDBCStore store, ClassMapping mapping)\n         throws Exception {\n@@ -149,41 +138,31 @@ private JDBCStore getStore(StoreContext ctx) {\n      */\n     protected Connection getConnection(JDBCStore store)\n         throws SQLException {\n-        // close previous connection if user is asking for another connection\n-        closeConnection();\n-\n         if (type == TYPE_TRANSACTIONAL || type == TYPE_CONTIGUOUS)\n-            _conn = store.getConnection();\n-        else {\n-            JDBCConfiguration conf = store.getConfiguration();\n-            DataSource ds = conf.getDataSource2(store.getContext());\n-            _conn = ds.getConnection();\n-            if (_conn.getAutoCommit())\n-                _conn.setAutoCommit(false);\n-            _commit = true;\n-        }\n-        return _conn;\n+            return store.getConnection();\n+\n+        JDBCConfiguration conf = store.getConfiguration();\n+        DataSource ds = conf.getDataSource2(store.getContext());\n+        Connection conn = ds.getConnection();\n+        if (conn.getAutoCommit())\n+            conn.setAutoCommit(false);\n+        return conn;\n     }\n \n     /**\n      * Close the current connection.\n      */\n-    protected void closeConnection() {\n-        if (_conn == null)\n+    protected void closeConnection(Connection conn) {\n+        if (conn == null)\n             return;\n \n         try {\n-            if (_commit)\n-                _conn.commit();\n+            if (type == TYPE_TRANSACTIONAL || type == TYPE_CONTIGUOUS)\n+                conn.commit();\n         } catch (SQLException se) {\n             throw SQLExceptions.getStore(se);\n         } finally {\n-            try {\n-                _conn.close();\n-            } catch (SQLException se) {\n-            }\n-            _conn = null;\n-            _commit = false;\n+            try { conn.close(); } catch (SQLException se) {}\n         }\n     }\n }"},{"sha":"e5ca574def8f1f215db581fa41c36025d01bdcce","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/480a42df4a036e53f0a06813d7b3412213cc610c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/480a42df4a036e53f0a06813d7b3412213cc610c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java?ref=480a42df4a036e53f0a06813d7b3412213cc610c","patch":"@@ -44,8 +44,8 @@\n public class ClassTableJDBCSeq \n     extends TableJDBCSeq {\n \n-    private static final Localizer _loc = Localizer\n-        .forPackage(ClassTableJDBCSeq.class);\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ClassTableJDBCSeq.class);\n \n     private final Map _stats = new HashMap();\n     private boolean _ignore = false;\n@@ -95,7 +95,7 @@ public void setUseAliases(boolean aliases) {\n         _aliases = aliases;\n     }\n \n-    protected Status getStatus(ClassMapping mapping) {\n+    protected synchronized Status getStatus(ClassMapping mapping) {\n         if (mapping == null)\n             return null;\n         String key = getKey(mapping, false);"},{"sha":"33a542c701c8edce64c9b55b05bdd24b09ccfe0a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","status":"modified","additions":6,"deletions":2,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/480a42df4a036e53f0a06813d7b3412213cc610c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/480a42df4a036e53f0a06813d7b3412213cc610c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java?ref=480a42df4a036e53f0a06813d7b3412213cc610c","patch":"@@ -199,8 +199,12 @@ public void endConfiguration() {\n \n     protected Object nextInternal(JDBCStore store, ClassMapping mapping)\n         throws SQLException {\n-        long next = getSequence(getConnection(store));\n-        return Numbers.valueOf(next);\n+        Connection conn = getConnection(store);\n+        try {\n+            return Numbers.valueOf(getSequence(conn));\n+        } finally {\n+            closeConnection(conn);\n+        }\n     }\n \n     /**"},{"sha":"4613eb7774a42b6a1a555ce9c96921dbc40c733a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java","status":"modified","additions":75,"deletions":65,"changes":140,"blob_url":"https://github.com/apache/openjpa/blob/480a42df4a036e53f0a06813d7b3412213cc610c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/480a42df4a036e53f0a06813d7b3412213cc610c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java?ref=480a42df4a036e53f0a06813d7b3412213cc610c","patch":"@@ -213,20 +213,29 @@ protected Object nextInternal(JDBCStore store, ClassMapping mapping)\n             throw new InvalidStateException(_loc.get(\"bad-seq-type\",\n                 getClass(), mapping));\n \n-        // make sure seq is at least 1, since autoassigned ids of 0 can\n-        // conflict with uninitialized values\n-        stat.seq = Math.max(stat.seq, 1);\n-        if (stat.seq >= stat.max)\n+        while (true) {\n+            synchronized (stat) {\n+                // make sure seq is at least 1, since autoassigned ids of 0 can\n+                // conflict with uninitialized values\n+                stat.seq = Math.max(stat.seq, 1);\n+                if (stat.seq < stat.max)\n+                    return Numbers.valueOf(stat.seq++);\n+            }\n             allocateSequence(store, mapping, stat, _alloc, true);\n-        return Numbers.valueOf(stat.seq++);\n+        }\n     }\n \n     protected Object currentInternal(JDBCStore store, ClassMapping mapping)\n         throws Exception {\n         if (current == null) {\n-            long cur = getSequence(mapping, getConnection(store));\n-            if (cur != -1)\n-                current = Numbers.valueOf(cur);\n+            Connection conn = getConnection(store);\n+            try {\n+                long cur = getSequence(mapping, getConnection(store));\n+                if (cur != -1)\n+                    current = Numbers.valueOf(cur);\n+            } finally {\n+                closeConnection(conn);\n+            }\n         }\n         return super.currentInternal(store, mapping);\n     }\n@@ -235,9 +244,18 @@ protected void allocateInternal(int count, JDBCStore store,\n         ClassMapping mapping)\n         throws SQLException {\n         Status stat = getStatus(mapping);\n-        if (stat != null && stat.max - stat.seq < count)\n-            allocateSequence(store, mapping, stat,\n-                count - (int) (stat.max - stat.seq), false);\n+        if (stat == null)\n+            return;\n+\n+        while (true) {\n+            int available;\n+            synchronized (stat) {\n+                available = (int) (stat.max - stat.seq);\n+                if (available >= count)\n+                    return;\n+            }\n+            allocateSequence(store, mapping, stat, count - available, false);\n+        }\n     }\n \n     /**\n@@ -295,40 +313,45 @@ private void buildTable() {\n      * Updates the max available sequence value.\n      */\n     private void allocateSequence(JDBCStore store, ClassMapping mapping,\n-        Status stat, int alloc, boolean updateStatSeq) {\n+        Status stat, int alloc, boolean updateStatSeq) \n+        throws SQLException {\n+        Connection conn = getConnection(store);\n+        try { \n+            if (setSequence(mapping, stat, alloc, updateStatSeq, conn))\n+                return;\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(_loc.get(\"bad-seq-up\", _table),\n+                se, _conf.getDBDictionaryInstance());\n+        } finally {\n+            closeConnection(conn);\n+        }\n+        \n         try {\n-            // if the update fails, probably because row doesn't exist yet\n-            if (!setSequence(mapping, stat, alloc, updateStatSeq,\n-                getConnection(store))) {\n-                closeConnection();\n-\n-                // possible that we might get errors when inserting if\n-                // another thread/process is inserting same pk at same time\n-                SQLException err = null;\n-                Connection conn = _conf.getDataSource2(store.getContext()).\n-                    getConnection();\n-                try {\n-                    insertSequence(mapping, conn);\n-                } catch (SQLException se) {\n-                    err = se;\n-                } finally {\n-                    try {\n-                        conn.close();\n-                    } catch (SQLException se) {\n-                    }\n-                }\n+            // possible that we might get errors when inserting if\n+            // another thread/process is inserting same pk at same time\n+            SQLException err = null;\n+            conn = _conf.getDataSource2(store.getContext()).getConnection();\n+            try {\n+                insertSequence(mapping, conn);\n+            } catch (SQLException se) {\n+                err = se;\n+            } finally {\n+                try { conn.close(); } catch (SQLException se) {}\n+            }\n \n-                // now we should be able to update...\n-                if (!setSequence(mapping, stat, alloc, updateStatSeq,\n-                    getConnection(store)))\n-                    throw(err != null) ? err : new SQLException(_loc.get\n+            // now we should be able to update...\n+            conn = getConnection(store);\n+            try {\n+                if (!setSequence(mapping, stat, alloc, updateStatSeq, conn))\n+                    throw (err != null) ? err : new SQLException(_loc.get\n                         (\"no-seq-row\", mapping, _table).getMessage());\n+            } finally {\n+                closeConnection(conn);\n             }\n-        }\n-        catch (SQLException se2) {\n+        } catch (SQLException se2) {\n             throw SQLExceptions.getStore(_loc.get(\"bad-seq-up\", _table),\n                 se2, _conf.getDBDictionaryInstance());\n-        }\n+        } \n     }\n \n     /**\n@@ -362,10 +385,7 @@ private void insertSequence(ClassMapping mapping, Connection conn)\n             stmnt.executeUpdate();\n         } finally {\n             if (stmnt != null)\n-                try {\n-                    stmnt.close();\n-                } catch (SQLException se) {\n-                }\n+                try { stmnt.close(); } catch (SQLException se) {}\n             if (!wasAuto)\n                 conn.setAutoCommit(false);\n         }\n@@ -401,14 +421,8 @@ protected long getSequence(ClassMapping mapping, Connection conn)\n             return dict.getLong(rs, 1);\n         } finally {\n             if (rs != null)\n-                try {\n-                    rs.close();\n-                } catch (SQLException se) {\n-                }\n-            try {\n-                stmnt.close();\n-            } catch (SQLException se) {\n-            }\n+                try { rs.close(); } catch (SQLException se) {}\n+            try { stmnt.close(); } catch (SQLException se) {}\n         }\n     }\n \n@@ -433,8 +447,7 @@ protected boolean setSequence(ClassMapping mapping, Status stat, int inc,\n         SQLBuffer where = new SQLBuffer(dict).append(_pkColumn).append(\" = \").\n             appendValue(pk, _pkColumn);\n \n-        // not all databases support locking, so loop until we have a\n-        // successful atomic select/update sequence\n+        // loop until we have a successful atomic select/update sequence\n         long cur = 0;\n         PreparedStatement stmnt;\n         ResultSet rs;\n@@ -459,23 +472,20 @@ protected boolean setSequence(ClassMapping mapping, Status stat, int inc,\n                 stmnt = upd.prepareStatement(conn);\n                 updates = stmnt.executeUpdate();\n             } finally {\n-                if (rs != null)\n-                    try {\n-                        rs.close();\n-                    } catch (SQLException se) {\n-                    }\n+                if (rs != null) \n+                    try { rs.close(); } catch (SQLException se) {}\n                 if (stmnt != null)\n-                    try {\n-                        stmnt.close();\n-                    } catch (SQLException se) {\n-                    }\n+                    try { stmnt.close(); } catch (SQLException se) {}\n             }\n         }\n \n         // setup new sequence range\n-        if (updateStatSeq)\n-            stat.seq = cur;\n-        stat.max = cur + inc;\n+        synchronized (stat) {\n+            if (updateStatSeq && stat.seq < cur)\n+                stat.seq = cur;\n+            if (stat.max < cur + inc)\n+                stat.max = cur + inc;\n+        }\n         return true;\n     }\n "}]}

