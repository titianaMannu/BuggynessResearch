{"sha":"492a19573c98f9e933c3e5c66d191ef92c371c86","node_id":"MDY6Q29tbWl0MjA2MzY0OjQ5MmExOTU3M2M5OGY5ZTkzM2MzZTVjNjZkMTkxZWY5MmMzNzFjODY=","commit":{"author":{"name":"Donald Woods","email":"dwoods@apache.org","date":"2009-09-14T19:39:36Z"},"committer":{"name":"Donald Woods","email":"dwoods@apache.org","date":"2009-09-14T19:39:36Z"},"message":"OPENJPA-1151 Cache the current-time timestamp in AbstractQueryCache.onTypesChanged().  Updated tests contributed by Jody Grassel.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@814802 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"2d8492bea9b79dbde3bb38946cc35af43b3f3933","url":"https://api.github.com/repos/apache/openjpa/git/trees/2d8492bea9b79dbde3bb38946cc35af43b3f3933"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/492a19573c98f9e933c3e5c66d191ef92c371c86","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/492a19573c98f9e933c3e5c66d191ef92c371c86","html_url":"https://github.com/apache/openjpa/commit/492a19573c98f9e933c3e5c66d191ef92c371c86","comments_url":"https://api.github.com/repos/apache/openjpa/commits/492a19573c98f9e933c3e5c66d191ef92c371c86/comments","author":null,"committer":null,"parents":[{"sha":"b8dde5761fd5ce9452db8422f3a83dc7cb222463","url":"https://api.github.com/repos/apache/openjpa/commits/b8dde5761fd5ce9452db8422f3a83dc7cb222463","html_url":"https://github.com/apache/openjpa/commit/b8dde5761fd5ce9452db8422f3a83dc7cb222463"}],"stats":{"total":515,"additions":348,"deletions":167},"files":[{"sha":"f5c399ae55acfb6fe580cdf7bbe6a9ec0fdf2863","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/AbstractQueryCacheTest.java","status":"added","additions":274,"deletions":0,"changes":274,"blob_url":"https://github.com/apache/openjpa/blob/492a19573c98f9e933c3e5c66d191ef92c371c86/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/AbstractQueryCacheTest.java","raw_url":"https://github.com/apache/openjpa/raw/492a19573c98f9e933c3e5c66d191ef92c371c86/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/AbstractQueryCacheTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/AbstractQueryCacheTest.java?ref=492a19573c98f9e933c3e5c66d191ef92c371c86","patch":"@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.jdbc.query.cache;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.Query;\n+\n+import org.apache.openjpa.datacache.ConcurrentQueryCache;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactory;\n+import org.apache.openjpa.persistence.OpenJPAPersistence;\n+import org.apache.openjpa.persistence.QueryResultCacheImpl;\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+import org.apache.openjpa.util.CacheMap;\n+\n+public abstract class AbstractQueryCacheTest extends SingleEMFTestCase {\n+    private Class[] entityClassTypes = { Part.class, PartBase.class, \n+            PartComposite.class, Supplier.class, Usage.class};\n+    \n+    protected boolean deleteData = false;\n+    protected boolean recreateData = true;\n+    \n+    public void setUp(Object... props) {\n+        int arrLen = entityClassTypes.length + props.length;\n+        Object args[] = new Object[arrLen];\n+        \n+        // Add the entity class types supported by this testing\n+        int idx = 0;\n+        for (Class clazz : entityClassTypes) {\n+            args[idx++] = clazz;\n+        }\n+        \n+        // Add the property parameters passed in by the subclass\n+        for (Object obj : props) {\n+            args[idx++] = obj;\n+        }\n+        \n+        // Invoke superclass' implementation of setUp()...\n+        super.setUp(args);\n+\n+        // Not all databases support GenerationType.IDENTITY column(s)\n+        if (checkSupportsIdentityGenerationType() && recreateData) {\n+            // deletes any data leftover data in the database due to the failed\n+            // last run of this testcase\n+            deleteAllData(); \n+            reCreateData();\n+        }\n+    }\n+    \n+    public void tearDown() throws Exception {\n+        if (deleteData) {\n+            deleteAllData();\n+        }\n+    }    \n+    \n+    /**\n+     * Populate the database with data that is consumable by the query cache\n+     * tests.\n+     * \n+     */\n+    protected void reCreateData() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+\n+        Supplier s1 = new Supplier(1, \"S1\");\n+        em.persist(s1);\n+        Supplier s2 = new Supplier(2, \"S2\");\n+        em.persist(s2);\n+        Supplier s3 = new Supplier(3, \"S3\");\n+        em.persist(s3);\n+\n+        PartBase p1 = new PartBase(10, \"Wheel\", 150, 15.00);\n+        em.persist(p1);\n+        PartBase p2 = new PartBase(11, \"Frame\", 550.00, 25.00);\n+        em.persist(p2);\n+        PartBase p3 = new PartBase(12, \"HandleBar\", 125.00, 80.00);\n+        em.persist(p3);\n+\n+        s1.addPart(p1).addPart(p2).addPart(p3);\n+        s2.addPart(p1).addPart(p3);\n+\n+        PartComposite p4 = new PartComposite(20, \"Bike\", 180, 1.0);\n+        em.persist(p4);\n+        p4.addSubPart(em, 2, p1).addSubPart(em, 1, p2).addSubPart(em, 1, p3);\n+\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    /**\n+     * Remove all rows from the database.\n+     * \n+     */\n+    protected void deleteAllData() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+\n+        em.createNativeQuery(\"delete from supplier_part\").executeUpdate();\n+        em.createQuery(\"delete from PartBase s\").executeUpdate();\n+        em.createQuery(\"delete from Supplier s\").executeUpdate();\n+        em.createQuery(\"delete from Usage u\").executeUpdate();\n+        em.createQuery(\"delete from Part p\").executeUpdate();\n+\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+    \n+    /**\n+     * Populate the query cache with 35 entries.\n+     * \n+     */\n+    protected void loadQueryCache() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        String qry = \"select p from PartBase p where p.cost > ?1\";\n+        for (int i=120; i<155; i++) {\n+            Query q = em.createQuery(qry);\n+            q.setParameter(1, new Double(i));\n+            q.getResultList();\n+        }\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    /**\n+     * Update an entity that is associated with the queries in the \n+     * query cache.\n+     * \n+     */\n+    protected void updateAnEntity() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+\n+        // Update entity\n+        PartBase p = em.find(PartBase.class,11);\n+        double oldcost = p.getCost();\n+        if (p != null) {\n+            p.setCost((oldcost + 10.0));\n+        }\n+\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    /**\n+     * Fetches a reference to the EntityManagerFactory's query cache \n+     * object.\n+     * \n+     */\n+    protected ConcurrentQueryCache getQueryCache() {\n+        OpenJPAEntityManagerFactory oemf = OpenJPAPersistence.cast(emf);\n+        QueryResultCacheImpl scache = \n+            (QueryResultCacheImpl) oemf.getQueryResultCache();\n+\n+        return (ConcurrentQueryCache) scache.getDelegate();\n+    }\n+\n+    /**\n+     * Returns the current size of the EntityManagerFactory's \n+     * query cache.\n+     * \n+     */\n+    protected int queryCacheGet() {\n+        ConcurrentQueryCache dcache = getQueryCache();\n+        CacheMap map = dcache.getCacheMap();\n+        return map.size();\n+    }\n+    \n+    /**\n+     * Returns true if the database supports GenerationType.IDENTITY column(s),\n+     * false if it does not.\n+     * \n+     */\n+    protected boolean checkSupportsIdentityGenerationType() {\n+        return (((JDBCConfiguration) emf.getConfiguration()).\n+                getDBDictionaryInstance().supportsAutoAssign);\n+    }\n+    \n+    /*\n+     * Common tests -- the following tests are common to any eviction policy\n+     * used by OpenJPA's query cache implementation.\n+     * \n+     */\n+    \n+    /**\n+     * Tests the query cache eviction function with the following test logic:\n+     * \n+     * 1) Populate the query cache with the entries supplied by loadQueryCache()\n+     * 2) Sleep 20ms (to avoid race conditions with the Timestamp eviction\n+     *                policy.)\n+     * 3) Update one of the entities associated with the cached queries, in\n+     *    order to dirty the query cache\n+     * 4) Insert a row into the database via native queries (this approach\n+     *    avoids dirtying the query cache, ensuring step #3 remains the\n+     *    control step.)\n+     * 5) With a common criteria of all part entities with a cost > 120,\n+     *    examine the query result list sizes from both a native query\n+     *    select invocation, and a JPA query invocation.  Because the\n+     *    query cache was dirtied by step #3, the JPA query should invoke\n+     *    a fresh SELECT operation on the database.   \n+     * \n+     */\n+    public void testEviction() {\n+        // Not all databases support GenerationType.IDENTITY column(s)\n+        if (!checkSupportsIdentityGenerationType()) {\n+            return;\n+        }\n+        \n+        loadQueryCache();\n+        try {\n+            Thread.sleep(20);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+        updateAnEntity();\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+\n+        String insert1 = \n+            \"insert into part(partno,parttype,name,cost,mass)\" +\n+            \" values(13,'PartBase','breakes',1000.0,100.0)\";\n+        em.createNativeQuery(insert1).executeUpdate();\n+        String insert2 = \n+            \"insert into supplier_part(suppliers_sid,supplies_partno)\" + \n+            \" values(1,13)\";\n+        em.createNativeQuery(insert2).executeUpdate();\n+\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+\n+        String sql = \"select partno from part where cost > 120 \";\n+        Query nativeq = em.createNativeQuery(sql);\n+        int nativelistSize = nativeq.getResultList().size();\n+\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        Query q = em.createQuery(\"select p from PartBase p where p.cost>?1\");\n+        q.setParameter(1, new Double(120));\n+        int jpalistSize = q.getResultList().size();\n+\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        // The resultlist of nativelist and jpalist should be the same \n+        // in both eviction policies(dafault/timestamp)\n+        assertEquals(nativelistSize,jpalistSize);\n+\n+        this.deleteData = true;\n+        this.recreateData = true;\n+    }\n+}"},{"sha":"4d42f15ce55233446da7720f9eb0505ee13f0975","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestQueryDefaultEviction.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/492a19573c98f9e933c3e5c66d191ef92c371c86/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestQueryDefaultEviction.java","raw_url":"https://github.com/apache/openjpa/raw/492a19573c98f9e933c3e5c66d191ef92c371c86/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestQueryDefaultEviction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestQueryDefaultEviction.java?ref=492a19573c98f9e933c3e5c66d191ef92c371c86","patch":"@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.jdbc.query.cache;\n+\n+import org.apache.openjpa.datacache.ConcurrentQueryCache;\n+import org.apache.openjpa.datacache.AbstractQueryCache.EvictPolicy;\n+\n+public class TestQueryDefaultEviction extends AbstractQueryCacheTest {\n+    public void setUp() throws Exception {\n+        super.setUp(\n+                \"openjpa.DataCache\", \"true\",\n+                \"openjpa.QueryCache\",\n+                \"CacheSize=1000\",\n+                \"openjpa.RemoteCommitProvider\", \"sjvm\");\n+    }\n+\n+    /**\n+     * Verify that the persistent unit property configuration is enabling\n+     * the DEFAULT Eviction Policy.\n+     */\n+    public void testTimestampEvictionEnablement() {\n+        ConcurrentQueryCache qc = getQueryCache();\n+        EvictPolicy ep = qc.getEvictPolicy();\n+        assertTrue(ep == EvictPolicy.DEFAULT);\n+    }\n+    \n+    public void testLoadQueries() {\n+        // Not all databases support GenerationType.IDENTITY column(s)\n+        if (!checkSupportsIdentityGenerationType()) {\n+            return;\n+        }\n+        \n+        loadQueryCache();\n+        int cacheSizeBeforeUpdate = queryCacheGet();\n+        updateAnEntity();\n+        int cacheSizeAfterUpdate = queryCacheGet();\n+\n+        // If evictPolicy is default the query cache size should not be equal to\n+        // cacheSizeBeforeUpdate value.\n+        assertNotEquals(cacheSizeBeforeUpdate, cacheSizeAfterUpdate);\n+\n+        this.recreateData = false;\n+    }\n+}"},{"sha":"d30d36b03d0bb4ac4a7e1d856a7e55b6de0e97cc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestQueryTimestampEviction.java","status":"modified","additions":14,"deletions":167,"changes":181,"blob_url":"https://github.com/apache/openjpa/blob/492a19573c98f9e933c3e5c66d191ef92c371c86/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestQueryTimestampEviction.java","raw_url":"https://github.com/apache/openjpa/raw/492a19573c98f9e933c3e5c66d191ef92c371c86/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestQueryTimestampEviction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestQueryTimestampEviction.java?ref=492a19573c98f9e933c3e5c66d191ef92c371c86","patch":"@@ -18,40 +18,29 @@\n  */\n package org.apache.openjpa.persistence.jdbc.query.cache;\n \n-import javax.persistence.EntityManager;\n-import javax.persistence.Query;\n-\n import org.apache.openjpa.datacache.ConcurrentQueryCache;\n+import org.apache.openjpa.datacache.AbstractQueryCache.EvictPolicy;\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n-import org.apache.openjpa.persistence.OpenJPAEntityManagerFactory;\n-import org.apache.openjpa.persistence.OpenJPAPersistence;\n-import org.apache.openjpa.persistence.QueryResultCacheImpl;\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n-import org.apache.openjpa.util.CacheMap;\n-\n-public class TestQueryTimestampEviction extends SingleEMFTestCase {\n-\n-    private boolean deleteData = false;\n-    private boolean recreateData = true;\n \n+public class TestQueryTimestampEviction extends AbstractQueryCacheTest {\n     public void setUp() throws Exception {\n-        super.setUp(Part.class, PartBase.class, PartComposite.class,\n-                Supplier.class, Usage.class,\n+        super.setUp(\n                 \"openjpa.DataCache\", \"true\",\n                 \"openjpa.QueryCache\",\n                 \"CacheSize=1000, EvictPolicy='timestamp'\",\n                 \"openjpa.RemoteCommitProvider\", \"sjvm\");\n-\n-        // Not all databases support GenerationType.IDENTITY column(s)\n-        if (((JDBCConfiguration) emf.getConfiguration()).\n-            getDBDictionaryInstance().supportsAutoAssign && recreateData) {\n-            // deletes any data leftover data in the database due to the failed\n-            // last run of this testcase\n-            deleteAllData(); \n-            reCreateData();\n-        }\n     }\n \n+    /**\n+     * Verify that the persistent unit property configuration is enabling\n+     * the TIMESTAMP Eviction Policy.\n+     */\n+    public void testTimestampEvictionEnablement() {\n+        ConcurrentQueryCache qc = getQueryCache();\n+        EvictPolicy ep = qc.getEvictPolicy();\n+        assertTrue(ep == EvictPolicy.TIMESTAMP);\n+    }\n+    \n     public void testLoadQueries() {\n         // Not all databases support GenerationType.IDENTITY column(s)\n         if (!((JDBCConfiguration) emf.getConfiguration()).\n@@ -69,147 +58,5 @@ public void testLoadQueries() {\n \n         this.recreateData = false;\n     }\n-\n-    public void testEviction() {\n-        // Not all databases support GenerationType.IDENTITY column(s)\n-        if (!((JDBCConfiguration) emf.getConfiguration()).\n-            getDBDictionaryInstance().supportsAutoAssign) {\n-            return;\n-        }\n-        loadQueryCache();\n-        try {\n-            Thread.sleep(20);\n-        } catch (InterruptedException e) {\n-            e.printStackTrace();\n-        }\n-        updateAnEntity();\n-\n-        EntityManager em = emf.createEntityManager();\n-        em.getTransaction().begin();\n-\n-        String insert1 = \"insert into Part(partno,parttype,name,cost,mass)\" +\n-            \" values(13,'PartBase','breakes',1000.0,100.0)\";\n-        em.createNativeQuery(insert1).executeUpdate();\n-        String insert2 = \"insert into Supplier_Part(suppliers_sid,\" +\n-            \"supplies_partno) values(1,13)\";\n-        em.createNativeQuery(insert2).executeUpdate();\n-\n-        em.getTransaction().commit();\n-        em.close();\n-\n-        em = emf.createEntityManager();\n-        em.getTransaction().begin();\n-\n-        String sql = \"select partno from Part where cost > 120 \";\n-        Query nativeq = em.createNativeQuery(sql);\n-        int nativelistSize = nativeq.getResultList().size();\n-\n-        em.getTransaction().commit();\n-        em.close();\n-\n-        em = emf.createEntityManager();\n-        em.getTransaction().begin();\n-        Query q = em.createQuery(\"select p from PartBase p where p.cost>?1\");\n-        q.setParameter(1, new Double(120));\n-        int jpalistSize = q.getResultList().size();\n-\n-        em.getTransaction().commit();\n-        em.close();\n-\n-        // The resultlist of nativelist and jpalist should be the same \n-        // in both eviction policies(dafault/timestamp)\n-        assertEquals(nativelistSize,jpalistSize);\n-\n-        this.deleteData = true;\n-        this.recreateData = true;\n-    }\n-\n-    private void loadQueryCache() {\n-        EntityManager em = emf.createEntityManager();\n-        em.getTransaction().begin();\n-        String qry = \"select p from PartBase p where p.cost > ?1\";\n-        for (int i=120; i<155; i++) {\n-            Query q = em.createQuery(qry);\n-            q.setParameter(1, new Double(i));\n-            q.getResultList();\n-        }\n-        em.getTransaction().commit();\n-        em.close();\n-    }\n-\n-    private void updateAnEntity() {\n-        EntityManager em = emf.createEntityManager();\n-        em.getTransaction().begin();\n-\n-        //Update entity\n-        PartBase p = em.find(PartBase.class,11);\n-        double oldcost = p.getCost();\n-        if (p != null) \n-            p.setCost((oldcost + 10.0));\n-\n-        em.getTransaction().commit();\n-        em.close();\n-    }\n-\n-    private ConcurrentQueryCache getQueryCache() {\n-        OpenJPAEntityManagerFactory oemf = OpenJPAPersistence.cast(emf);\n-        QueryResultCacheImpl scache = (QueryResultCacheImpl) oemf.\n-        getQueryResultCache();\n-\n-        return (ConcurrentQueryCache ) scache.getDelegate();\n-    }\n-\n-    private int  queryCacheGet() {\n-        ConcurrentQueryCache dcache = getQueryCache();\n-        CacheMap map = dcache.getCacheMap();\n-        return map.size();\n-    }\n-\n-    public void tearDown() throws Exception {\n-        if (deleteData)\n-            deleteAllData();\n-    }\n-\n-    private void reCreateData() {\n-        EntityManager em = emf.createEntityManager();\n-        em.getTransaction().begin();\n-\n-        Supplier s1 = new Supplier(1, \"S1\");\n-        em.persist(s1);\n-        Supplier s2 = new Supplier(2, \"S2\");\n-        em.persist(s2);\n-        Supplier s3 = new Supplier(3, \"S3\");\n-        em.persist(s3);\n-\n-        PartBase p1 = new PartBase(10, \"Wheel\", 150, 15.00);\n-        em.persist(p1);\n-        PartBase p2 = new PartBase(11, \"Frame\", 550.00, 25.00);\n-        em.persist(p2);\n-        PartBase p3 = new PartBase(12, \"HandleBar\", 125.00, 80.00);\n-        em.persist(p3);\n-\n-        s1.addPart(p1).addPart(p2).addPart(p3);\n-        s2.addPart(p1).addPart(p3);\n-\n-        PartComposite p4 = new PartComposite(20, \"Bike\", 180, 1.0);\n-        em.persist(p4);\n-        p4.addSubPart(em, 2, p1).addSubPart(em, 1, p2).addSubPart(em, 1, p3);\n-\n-        em.getTransaction().commit();\n-        em.close();\n-    }\n-\n-    private void deleteAllData() {\n-        EntityManager em = emf.createEntityManager();\n-        em.getTransaction().begin();\n-\n-        em.createNativeQuery(\"delete from Supplier_Part\").executeUpdate();\n-        em.createQuery(\"delete from PartBase s\").executeUpdate();\n-        em.createQuery(\"delete from Supplier s\").executeUpdate();\n-        em.createQuery(\"delete from Usage u\").executeUpdate();\n-        em.createQuery(\"delete from Part p\").executeUpdate();\n-\n-        em.getTransaction().commit();\n-        em.close();\n-    }\n }\n+"}]}

