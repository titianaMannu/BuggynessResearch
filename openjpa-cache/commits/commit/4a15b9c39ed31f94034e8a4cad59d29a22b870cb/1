{"sha":"4a15b9c39ed31f94034e8a4cad59d29a22b870cb","node_id":"MDY6Q29tbWl0MjA2MzY0OjRhMTViOWMzOWVkMzFmOTQwMzRlOGE0Y2FkNTlkMjlhMjJiODcwY2I=","commit":{"author":{"name":"Marc Prud'hommeaux","email":"mprudhom@apache.org","date":"2007-05-18T23:22:10Z"},"committer":{"name":"Marc Prud'hommeaux","email":"mprudhom@apache.org","date":"2007-05-18T23:22:10Z"},"message":"OPENJPA-235 Reverted patch since it was causing TCK failures\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@539627 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"e8d387175dd33f073bb9e486497121f48f908e19","url":"https://api.github.com/repos/apache/openjpa/git/trees/e8d387175dd33f073bb9e486497121f48f908e19"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/4a15b9c39ed31f94034e8a4cad59d29a22b870cb","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/4a15b9c39ed31f94034e8a4cad59d29a22b870cb","html_url":"https://github.com/apache/openjpa/commit/4a15b9c39ed31f94034e8a4cad59d29a22b870cb","comments_url":"https://api.github.com/repos/apache/openjpa/commits/4a15b9c39ed31f94034e8a4cad59d29a22b870cb/comments","author":null,"committer":null,"parents":[{"sha":"add6a29be4017c1cf670034811ab5942f756ce94","url":"https://api.github.com/repos/apache/openjpa/commits/add6a29be4017c1cf670034811ab5942f756ce94","html_url":"https://github.com/apache/openjpa/commit/add6a29be4017c1cf670034811ab5942f756ce94"}],"stats":{"total":154,"additions":10,"deletions":144},"files":[{"sha":"1059d613b97ce1437b8c68bc1d3c58b93c99dd60","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/OperationOrderUpdateManager.java","status":"modified","additions":10,"deletions":144,"changes":154,"blob_url":"https://github.com/apache/openjpa/blob/4a15b9c39ed31f94034e8a4cad59d29a22b870cb/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/OperationOrderUpdateManager.java","raw_url":"https://github.com/apache/openjpa/raw/4a15b9c39ed31f94034e8a4cad59d29a22b870cb/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/OperationOrderUpdateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/OperationOrderUpdateManager.java?ref=4a15b9c39ed31f94034e8a4cad59d29a22b870cb","patch":"@@ -14,21 +14,16 @@\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n- * under the License.\n+ * under the License.    \n  */\n package org.apache.openjpa.jdbc.kernel;\n \n import java.sql.Connection;\n import java.sql.SQLException;\n import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.HashMap;\n import java.util.Iterator;\n-import java.util.List;\n-import java.util.Stack;\n-import java.util.Map;\n \n-import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.sql.PrimaryRow;\n import org.apache.openjpa.jdbc.sql.Row;\n@@ -39,7 +34,7 @@\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n \n /**\n- * Update manager that writes SQL in object-level operation order\n+ * Update manager that writes SQL in object-level operation order.\n  *\n  * @author Abe White\n  */\n@@ -71,20 +66,13 @@ protected Collection flush(RowManager rowMgr,\n \n         // now do any 'all row' updates, which typically null keys\n         flush(rmimpl.getAllRowUpdates(), psMgr);\n-        \n-        // map statemanagers to primaryrows\n-        Map smMap = mapStateManagers(rmimpl.getOrdered());\n-        \n-        // order rows to avoid constraint violations\n-        List orderedRows = orderRows(rmimpl, smMap);\n \n         // gather any updates we need to avoid fk constraints on deletes\n         Collection constraintUpdates = null;\n-        for (Iterator itr = orderedRows.iterator(); itr.hasNext();) {\n+        for (Iterator itr = rmimpl.getDeletes().iterator(); itr.hasNext();) {\n             try {\n                 constraintUpdates = analyzeDeleteConstraints(rmimpl,\n-                    (PrimaryRow) itr.next(), constraintUpdates, smMap,\n-                    orderedRows);\n+                    (PrimaryRow) itr.next(), constraintUpdates);\n             } catch (SQLException se) {\n                 exceps = addException(exceps, SQLExceptions.getStore\n                     (se, dict));\n@@ -94,18 +82,17 @@ protected Collection flush(RowManager rowMgr,\n             flush(constraintUpdates, psMgr);\n             constraintUpdates.clear();\n         }\n-        \n+\n         // flush primary rows in order\n-        for (Iterator itr = orderedRows.iterator(); itr.hasNext();) {\n+        for (Iterator itr = rmimpl.getOrdered().iterator(); itr.hasNext();) {\n             try {\n                 constraintUpdates = flushPrimaryRow(rmimpl, (PrimaryRow)\n-                    itr.next(), psMgr, constraintUpdates, smMap, orderedRows);\n+                    itr.next(), psMgr, constraintUpdates);\n             } catch (SQLException se) {\n                 exceps = addException(exceps, SQLExceptions.getStore\n                     (se, dict));\n             }\n         }\n-\n         if (constraintUpdates != null)\n             flush(constraintUpdates, psMgr);\n \n@@ -119,122 +106,14 @@ protected Collection flush(RowManager rowMgr,\n         return exceps;\n     }\n \n-    /**\n-     * Reorders all rows provided by the specified RowManagerImpl such that\n-     * no foreign key constraints are violated (assuming a proper schema).\n-     * @param rmimpl RowManagerImpl\n-     */\n-    private List orderRows(RowManagerImpl rmimpl, Map smMap) {\n-        List orderedRows = new ArrayList();\n-        if (rmimpl.getOrdered().size() > 0) {\n-            List inserts = new ArrayList(rmimpl.getInserts());\n-            List updates = new ArrayList(rmimpl.getUpdates());\n-            List deletes = new ArrayList(rmimpl.getDeletes());\n-\n-            orderedRows.addAll(orderRows(inserts, smMap));\n-            orderedRows.addAll(updates);\n-            orderedRows.addAll(orderRows(deletes, smMap));\n-        }\n-        return orderedRows;\n-    }\n-\n-    private List orderRows(List unorderedList, Map smMap) {\n-        List orderedList = new ArrayList();\n-        // this iterates in a while loop instead of with an iterator to\n-        // avoid ConcurrentModificationExceptions, as unorderedList is\n-        // mutated in the orderRow() invocation.\n-        while (!unorderedList.isEmpty()) {\n-            PrimaryRow nextRow = (PrimaryRow) unorderedList.get(0);\n-            orderRow(nextRow, unorderedList, orderedList, smMap, new Stack());\n-        }\n-        return orderedList;\n-    }\n-\n-    private void orderRow(PrimaryRow currentRow, Collection unordered,\n-        List orderedList, Map smMap, Stack visitedRows) {\n-        if (orderedList.contains(currentRow)) {\n-            return;\n-        }\n-\n-        // a circular reference found which means there is a problem\n-        // with the underlying database schema and/or class metadata\n-        // definitions. nothing can be done here to correct the problem.\n-        if (visitedRows.contains(currentRow)) {\n-            orderedList.addAll(unordered);\n-            unordered.clear();\n-            return;\n-        }\n-\n-        if (currentRow.getAction() == Row.ACTION_INSERT) {\n-            ForeignKey[] fks = currentRow.getTable().getForeignKeys();\n-            OpenJPAStateManager sm;\n-            for (int i = 0; i < fks.length; i++) {\n-                sm = currentRow.getForeignKeySet(fks[i]);\n-                if (sm == null)\n-                    continue;\n-                // if the foreign key is new and it's primary key is\n-                // auto assigned\n-                PrimaryRow fkRow = (PrimaryRow) smMap.get(sm);\n-                if (fkRow.getAction() == Row.ACTION_INSERT) {\n-                    boolean nullable = true;\n-                    Column[] columns = fks[i].getColumns();\n-                    for (int j = 0; j < columns.length; j++) {\n-                        if (columns[j].isNotNull()) {\n-                            nullable = false;\n-                            break;\n-                        }\n-                    }\n-                    if (!nullable) {\n-                        visitedRows.push(currentRow);\n-                        PrimaryRow nextRow = (PrimaryRow) smMap.get(sm);\n-                        orderRow(nextRow, unordered, orderedList, smMap,\n-                            visitedRows);\n-                        visitedRows.pop();\n-                    }\n-                }\n-            }\n-            if (!orderedList.contains(currentRow)) {\n-                unordered.remove(currentRow);\n-                orderedList.add(currentRow);\n-            }\n-        } else if (currentRow.getAction() == Row.ACTION_DELETE) {\n-            ForeignKey[] fks = currentRow.getTable().getForeignKeys();\n-            OpenJPAStateManager sm;\n-            for (int i = 0; i < fks.length; i++) {\n-                sm = currentRow.getForeignKeySet(fks[i]);\n-                if (sm == null)\n-                    continue;\n-                PrimaryRow fkRow = (PrimaryRow) smMap.get(sm);\n-                // if the foreign key is going to be deleted\n-                if (!orderedList.contains(fkRow)\n-                    && fkRow.getAction() == Row.ACTION_DELETE) {\n-                    visitedRows.add(currentRow);\n-                    orderRow(fkRow, unordered, orderedList, smMap, visitedRows);\n-                    visitedRows.remove(currentRow);\n-                }\n-            }\n-            unordered.remove(currentRow);\n-            orderedList.add(0, currentRow);\n-        }\n-    }\n-\n-    private Map mapStateManagers(List rowList) {\n-        Map smMap = new HashMap();\n-        for (Iterator iter = rowList.iterator(); iter.hasNext();) {\n-            PrimaryRow row = (PrimaryRow) iter.next();\n-            smMap.put(row.getPrimaryKey(), row);\n-        }\n-        return smMap;\n-    }\n-\n     /**\n      * Analyze the delete constraints on the given row, gathering necessary\n      * updates to null fks before deleting.\n      */\n     private Collection analyzeDeleteConstraints(RowManagerImpl rowMgr,\n-        PrimaryRow row, Collection updates, Map smMap, List orderedRows)\n+        PrimaryRow row, Collection updates)\n         throws SQLException {\n-        if (!row.isValid() || row.getAction() != Row.ACTION_DELETE)\n+        if (!row.isValid())\n             return updates;\n \n         ForeignKey[] fks = row.getTable().getForeignKeys();\n@@ -248,11 +127,6 @@ private Collection analyzeDeleteConstraints(RowManagerImpl rowMgr,\n                 sm = row.getForeignKeyWhere(fks[i]);\n             if (sm == null)\n                 continue;\n-            PrimaryRow fkRow = (PrimaryRow) smMap.get(sm);\n-            int fkIndex = orderedRows.indexOf(fkRow);\n-            int rIndex = orderedRows.indexOf(row);\n-            if (fkIndex > rIndex)\n-                continue;\n \n             // only need an update if we have an fk to a row that's being\n             // deleted before we are\n@@ -278,8 +152,7 @@ private Collection analyzeDeleteConstraints(RowManagerImpl rowMgr,\n      * Flush the given row, creating deferred updates for dependencies.\n      */\n     private Collection flushPrimaryRow(RowManagerImpl rowMgr, PrimaryRow row,\n-        PreparedStatementManager psMgr, Collection updates, Map smMap,\n-        List orderedRows)\n+        PreparedStatementManager psMgr, Collection updates)\n         throws SQLException {\n         if (!row.isValid())\n             return updates;\n@@ -299,13 +172,6 @@ private Collection flushPrimaryRow(RowManagerImpl rowMgr, PrimaryRow row,\n             if (sm == null)\n                 continue;\n \n-            PrimaryRow fkRow = (PrimaryRow) smMap.get(sm);\n-            int fkIndex = orderedRows.indexOf(fkRow);\n-            int rIndex = orderedRows.indexOf(row);\n-            // consider sm flushed, no need to defer\n-            if (rIndex > fkIndex)\n-                continue;\n-\n             // only need an update if we have an fk to a row that's being\n             // inserted after we are; if row is dependent on itself and no\n             // fk, must be an auto-inc because otherwise we wouldn't have"}]}

