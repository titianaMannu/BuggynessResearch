{"sha":"4ca9dbd7418f4193daceccf00131f0c67dedcfe5","node_id":"MDY6Q29tbWl0MjA2MzY0OjRjYTlkYmQ3NDE4ZjQxOTNkYWNlY2NmMDAxMzFmMGM2N2RlZGNmZTU=","commit":{"author":{"name":"Heath Thomann","email":"hthomann@apache.org","date":"2015-01-14T21:56:22Z"},"committer":{"name":"Heath Thomann","email":"hthomann@apache.org","date":"2015-01-14T21:56:22Z"},"message":"OPENJPA-2547: When two threads attempt to get a Pessimistic Lock, one thread gets a 'false' lock.  Applied fix to trunk.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@1651847 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4304089338974dfd1e9c82f2060874976e2729c9","url":"https://api.github.com/repos/apache/openjpa/git/trees/4304089338974dfd1e9c82f2060874976e2729c9"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/4ca9dbd7418f4193daceccf00131f0c67dedcfe5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/4ca9dbd7418f4193daceccf00131f0c67dedcfe5","html_url":"https://github.com/apache/openjpa/commit/4ca9dbd7418f4193daceccf00131f0c67dedcfe5","comments_url":"https://api.github.com/repos/apache/openjpa/commits/4ca9dbd7418f4193daceccf00131f0c67dedcfe5/comments","author":null,"committer":null,"parents":[{"sha":"69f3a6e1c92d317ec35ce2740dc0407766eef599","url":"https://api.github.com/repos/apache/openjpa/commits/69f3a6e1c92d317ec35ce2740dc0407766eef599","html_url":"https://github.com/apache/openjpa/commit/69f3a6e1c92d317ec35ce2740dc0407766eef599"}],"stats":{"total":241,"additions":240,"deletions":1},"files":[{"sha":"99dff9be500f0f258e3dc68e66eaebe9cfed3710","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/4ca9dbd7418f4193daceccf00131f0c67dedcfe5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/4ca9dbd7418f4193daceccf00131f0c67dedcfe5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java?ref=4ca9dbd7418f4193daceccf00131f0c67dedcfe5","patch":"@@ -34,6 +34,7 @@\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.SQLFactory;\n import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.LockLevels;\n import org.apache.openjpa.kernel.LockScopes;\n import org.apache.openjpa.kernel.MixedLockLevels;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n@@ -127,7 +128,12 @@ private void lockRow(OpenJPAStateManager sm, int timeout, int level) {\n         Object id = sm.getObjectId();\n         ClassMapping mapping = (ClassMapping) sm.getMetaData();\n \n-        List<SQLBuffer> sqls = sm.getLock() == null\n+        //Code changed for OPENJPA-2449, code updated for OPENJPA-2547.  OPENJPA-2547 added\n+        //one check to determine if the lock is a value of LockLevels.LOCK_NONE.  The first \n+        //time a thread attempts to get a lock the lock will be null.  If the thread can't \n+        //get the lock because another thread holds it, the lock will be non-null and have \n+        //a value of LockLevels.LOCK_NONE.\n+        List<SQLBuffer> sqls = (sm.getLock() == null || sm.getLock().equals(LockLevels.LOCK_NONE))\n             ?  getLockRows(dict, id, mapping, fetch, _store.getSQLFactory())\n             : new ArrayList<SQLBuffer>();\n         if (ctx.getFetchConfiguration().getLockScope() == LockScopes.LOCKSCOPE_EXTENDED)"},{"sha":"3b15dd28dd2434462a45dea5c2f822b5cf55fccf","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/PessimisticLockEntity.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/4ca9dbd7418f4193daceccf00131f0c67dedcfe5/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/PessimisticLockEntity.java","raw_url":"https://github.com/apache/openjpa/raw/4ca9dbd7418f4193daceccf00131f0c67dedcfe5/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/PessimisticLockEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/PessimisticLockEntity.java?ref=4ca9dbd7418f4193daceccf00131f0c67dedcfe5","patch":"@@ -0,0 +1,47 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.persistence.kernel;\r\n+\r\n+import javax.persistence.Entity;\r\n+import javax.persistence.Id;\r\n+\r\n+@Entity\r\n+public class PessimisticLockEntity {\r\n+\r\n+    @Id\r\n+    int id;\r\n+    \r\n+    String name;\r\n+\r\n+    public String getName() {\r\n+        return name;\r\n+    }\r\n+\r\n+    public void setName(String name) {\r\n+        this.name = name;\r\n+    }\r\n+\r\n+    public int getId() {\r\n+        return id;\r\n+    }\r\n+\r\n+    public void setId(int id) {\r\n+        this.id = id;\r\n+    }\r\n+}\r"},{"sha":"fb5e830eae518957453374cf59aa840e3a8be650","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestPessimisticLockException.java","status":"added","additions":186,"deletions":0,"changes":186,"blob_url":"https://github.com/apache/openjpa/blob/4ca9dbd7418f4193daceccf00131f0c67dedcfe5/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestPessimisticLockException.java","raw_url":"https://github.com/apache/openjpa/raw/4ca9dbd7418f4193daceccf00131f0c67dedcfe5/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestPessimisticLockException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestPessimisticLockException.java?ref=4ca9dbd7418f4193daceccf00131f0c67dedcfe5","patch":"@@ -0,0 +1,186 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.persistence.kernel;\r\n+\r\n+import javax.persistence.EntityManager;\r\n+import javax.persistence.LockModeType;\r\n+\r\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n+import org.apache.openjpa.jdbc.sql.DB2Dictionary;\r\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\r\n+import org.apache.openjpa.jdbc.sql.OracleDictionary;\r\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\r\n+import org.apache.openjpa.persistence.OpenJPAPersistence;\r\n+import org.apache.openjpa.persistence.PessimisticLockException;\r\n+import org.apache.openjpa.persistence.test.SQLListenerTestCase;\r\n+\r\n+public class TestPessimisticLockException extends SQLListenerTestCase {\r\n+    int pKey = 1;\r\n+    static boolean doSleep = true;\r\n+\r\n+    @Override\r\n+    public void setUp() throws Exception {\r\n+        super.setUp(PessimisticLockEntity.class);\r\n+    }\r\n+    \r\n+    /*\r\n+     * This test has only been verified on DB2 and Oracle.\r\n+     */\r\n+    protected boolean skipTest() {\r\n+        if (emf.getConfiguration() instanceof JDBCConfiguration) {\r\n+            DBDictionary inst = ((JDBCConfiguration) emf.getConfiguration()).getDBDictionaryInstance();\r\n+            return !((inst instanceof DB2Dictionary) || (inst instanceof OracleDictionary));\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    /*\r\n+     * This test will verify that two threads get a an appropriate pessimistic lock\r\n+     * when they both request one at the same time.  See JIRA OPENJPA-2547 for a more\r\n+     * detailed description of this test.\r\n+     */\r\n+    public void testPessimisticLockException() {\r\n+        if (!skipTest()) {\r\n+\r\n+            populate();\r\n+\r\n+            TestThread t1 = new TestThread();\r\n+            TestThread t2 = new TestThread();\r\n+            t1.start();\r\n+            t2.start();\r\n+\r\n+            while ((t1.isAlive() || t2.isAlive())) {\r\n+                try {\r\n+                    Thread.sleep(5000);\r\n+                } catch (InterruptedException e) {\r\n+                }\r\n+            }\r\n+\r\n+            // One, and only one, thread should get a PersistenceException\r\n+            if (t1.gotPLEx && t2.gotPLEx) {\r\n+                fail(\"Both threads got a PersistenceLockException!  \"\r\n+                    + \"Only one thread should have received a PersistenceLockException\");\r\n+            } else if (t1.gotPLEx == false && t2.gotPLEx == false) {\r\n+                fail(\"Neither thread got a PersistenceLockException!  \"\r\n+                    + \"One thread should have received a PersistenceLockException\");\r\n+            } else if (t1.count < 2 && t2.count < 2) {\r\n+                fail(\"PersistenceLockException was received, but not the expected number of times!  \"\r\n+                    + \"One thread should have received a PersistenceLockException at least twice.\");\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private class TestThread extends Thread {\r\n+        boolean gotPLEx = false;\r\n+        int count = 0;\r\n+\r\n+        public synchronized void run() {\r\n+            OpenJPAEntityManager oem = OpenJPAPersistence.cast(emf.createEntityManager());\r\n+            oem.getTransaction().begin();\r\n+\r\n+            PessimisticLockEntity entity = oem.find(PessimisticLockEntity.class, pKey);\r\n+\r\n+            boolean locked = false;\r\n+            while (!locked) {\r\n+                try {\r\n+                    oem.getFetchPlan().setLockTimeout(5000);\r\n+                    oem.lock(entity, LockModeType.PESSIMISTIC_READ);\r\n+                    locked = true;\r\n+                } catch (PessimisticLockException ple) {\r\n+                    gotPLEx = true;\r\n+                    count++;\r\n+\r\n+                    try {\r\n+                        Thread.sleep(100);\r\n+                    } catch (final InterruptedException ie) {\r\n+                    }\r\n+                    oem.refresh(entity);\r\n+                } catch (Throwable pe) {\r\n+                    pe.printStackTrace();\r\n+                    fail(\"Caught an unexepected exception: \" + pe);\r\n+                }\r\n+\r\n+                // Only one thread needs to sleep (don't care about synchronization of 'doSleep' at this \r\n+                // point - if both threads happen to get here at the same time we will test for that later.)\r\n+                if (doSleep) {\r\n+                    doSleep = false;\r\n+                    try {\r\n+                        // Sleep log enough to ensure the other thread times out at least two times.\r\n+                        Thread.sleep(15000);\r\n+                    } catch (final InterruptedException ie) {\r\n+                    }\r\n+                }\r\n+\r\n+                if (!oem.getTransaction().getRollbackOnly()) {\r\n+                    oem.getTransaction().commit();\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    /*\r\n+     * This test verifies the correct number of SQL statements when using a pessimistic \r\n+     * lock (See JIRA OPENJPA-2449).  Prior to OPENJPA-2449, when requesting a pessimistic lock\r\n+     * we would do a 'select' to get the entity, and turn around and do another select to get a \r\n+     * Pessimistic lock...in other words, we'd generate (on DB2) these two SQL statements for the refresh:\r\n+     * \r\n+     * SELECT t0.name FROM PessimisticLockEntity t0 WHERE t0.id = ?\r\n+     * SELECT t0.name FROM PessimisticLockEntity t0 WHERE t0.id = ?  FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS\r\n+     *     \r\n+     * With the fix of OPENJPA-2449, we generate only one select, as follows:\r\n+     * \r\n+     * SELECT t0.name FROM PessimisticLockEntity t0 WHERE t0.id = ?  FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS\r\n+     * \r\n+     * Not only does this save an SQL, but more importantly, the few millisecond delay between the two selects\r\n+     * won't occur.....in a multi-threaded env this delay could cause another thread to get the lock over this\r\n+     * one when the refresh occurs at the same time.\r\n+     */\r\n+    public void testSQLCount() {\r\n+        if (!skipTest()) {\r\n+\r\n+            populate();\r\n+            resetSQL();\r\n+\r\n+            EntityManager em = emf.createEntityManager();\r\n+            em.getTransaction().begin();\r\n+\r\n+            PessimisticLockEntity plEnt = em.find(PessimisticLockEntity.class, pKey);\r\n+\r\n+            em.refresh(plEnt, LockModeType.PESSIMISTIC_WRITE);\r\n+\r\n+            plEnt.setName(\"test\");\r\n+            em.getTransaction().commit();\r\n+            em.close();\r\n+            assertEquals(\"There should only be 3 SQL statements\", 3, getSQLCount());\r\n+        }\r\n+    }\r\n+\r\n+    public void populate() {\r\n+        EntityManager em = emf.createEntityManager();\r\n+        em.getTransaction().begin();\r\n+\r\n+        PessimisticLockEntity pt = new PessimisticLockEntity();\r\n+        pt.setId(pKey);\r\n+\r\n+        em.persist(pt);\r\n+\r\n+        em.getTransaction().commit();\r\n+        em.close();\r\n+    }\r\n+}\r"}]}

