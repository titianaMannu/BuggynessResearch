{"sha":"4f0c54211df547e848b6a7605b2f255563634fda","node_id":"MDY6Q29tbWl0MjA2MzY0OjRmMGM1NDIxMWRmNTQ3ZTg0OGI2YTc2MDViMmYyNTU1NjM2MzRmZGE=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-01-18T19:26:39Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-01-18T19:26:39Z"},"message":"test case for OPENJPA-102 and OPENJPA-104\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@497547 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"f8c9b8056a8872b9bff9feccf448817367440a8d","url":"https://api.github.com/repos/apache/openjpa/git/trees/f8c9b8056a8872b9bff9feccf448817367440a8d"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/4f0c54211df547e848b6a7605b2f255563634fda","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/4f0c54211df547e848b6a7605b2f255563634fda","html_url":"https://github.com/apache/openjpa/commit/4f0c54211df547e848b6a7605b2f255563634fda","comments_url":"https://api.github.com/repos/apache/openjpa/commits/4f0c54211df547e848b6a7605b2f255563634fda/comments","author":null,"committer":null,"parents":[{"sha":"fa5eb3a7af517f27625cc53ad25dba21b6555466","url":"https://api.github.com/repos/apache/openjpa/commits/fa5eb3a7af517f27625cc53ad25dba21b6555466","html_url":"https://github.com/apache/openjpa/commit/fa5eb3a7af517f27625cc53ad25dba21b6555466"}],"stats":{"total":120,"additions":120,"deletions":0},"files":[{"sha":"bf3b4c85aaab1d8329ba2324bd635d4759ffff3f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/TestGetReferenceAndImplicitDetachment.java","status":"added","additions":120,"deletions":0,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/4f0c54211df547e848b6a7605b2f255563634fda/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/TestGetReferenceAndImplicitDetachment.java","raw_url":"https://github.com/apache/openjpa/raw/4f0c54211df547e848b6a7605b2f255563634fda/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/TestGetReferenceAndImplicitDetachment.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/TestGetReferenceAndImplicitDetachment.java?ref=4f0c54211df547e848b6a7605b2f255563634fda","patch":"@@ -0,0 +1,120 @@\n+package org.apache.openjpa.persistence.detachment;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.Persistence;\n+import javax.persistence.RollbackException;\n+\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactory;\n+import org.apache.openjpa.persistence.OpenJPAPersistence;\n+\n+import junit.framework.TestCase;\n+\n+\n+public class TestGetReferenceAndImplicitDetachment\n+    extends TestCase {\n+\n+    private OpenJPAEntityManagerFactory emf;\n+\n+    public void setUp() {\n+        String types = DetachmentOneManyParent.class.getName() + \";\"\n+            + DetachmentOneManyChild.class.getName(); \n+        Map props = new HashMap(System.getProperties());\n+        props.put(\"openjpa.MetaDataFactory\", \"jpa(Types=\" + types + \")\");\n+        props.put(\"openjpa.DetachState\", \"fgs\");\n+        emf = (OpenJPAEntityManagerFactory) Persistence.\n+            createEntityManagerFactory(\"test\", props);\n+        deleteAll();\n+    }\n+\n+    public void tearDown() {\n+        if (emf == null)\n+            return;\n+        try {\n+            deleteAll();\n+            emf.close();\n+        } catch (Exception e) {\n+        }\n+    }\n+    \n+    private void deleteAll() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        em.createQuery(\"delete from DetachmentOneManyChild\").\n+            executeUpdate();\n+        em.createQuery(\"delete from DetachmentOneManyParent\").\n+            executeUpdate();\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testNonexistentGetReferenceDetachmentInTxWithCommit() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        DetachmentOneManyParent o = \n+            em.getReference(DetachmentOneManyParent.class, 0);\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        // the close detachment should leave these invalid objects in a \n+        // transient state\n+        assertFalse(((PersistenceCapable) o).pcIsTransactional());\n+        assertFalse(((PersistenceCapable) o).pcIsPersistent());\n+        // pcIsDetached() will give a false positive in this configuration\n+        // assertFalse(((PersistenceCapable) o).pcIsDetached());\n+    }\n+\n+    public void testNonexistentGetReferenceDetachmentOutsideTx() {\n+        EntityManager em = emf.createEntityManager();\n+        DetachmentOneManyParent o = \n+            em.getReference(DetachmentOneManyParent.class, 0);\n+        em.close();\n+\n+        // the close detachment should leave these invalid objects in a \n+        // transient state\n+        assertFalse(((PersistenceCapable) o).pcIsTransactional());\n+        assertFalse(((PersistenceCapable) o).pcIsPersistent());\n+        // pcIsDetached() will give a false positive in this configuration\n+        // assertFalse(((PersistenceCapable) o).pcIsDetached());\n+    }\n+\n+    public void testNonexistentGetReferenceDetachmentInTxWithRollback() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        DetachmentOneManyParent o = \n+            em.getReference(DetachmentOneManyParent.class, 0);\n+        em.getTransaction().rollback();\n+\n+        // the rollback should cause a detachment\n+        assertFalse(OpenJPAPersistence.cast(em).isTransactional(o));\n+        assertFalse(OpenJPAPersistence.cast(em).isPersistent(o));\n+        // pcIsDetached() will give a false positive in this configuration\n+        // assertFalse(OpenJPAPersistence.cast(em).isDetached(o));\n+\n+        em.close();\n+    }\n+\n+    public void testNonexistentGetReferenceDetachmentInTxWithFailedCommit() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        DetachmentOneManyParent o = \n+            em.getReference(DetachmentOneManyParent.class, 0);\n+        em.getTransaction().setRollbackOnly();\n+        try {\n+            em.getTransaction().commit();\n+        } catch (RollbackException re) {\n+            // expected\n+        }\n+\n+        // the failed commit should cause a detachment\n+        assertFalse(OpenJPAPersistence.cast(em).isTransactional(o));\n+        assertFalse(OpenJPAPersistence.cast(em).isPersistent(o));\n+        // pcIsDetached() will give a false positive in this configuration\n+        // assertFalse(OpenJPAPersistence.cast(em).isDetached(o));\n+\n+        em.close();\n+    }\n+}"}]}

