{"sha":"5016fc69f876b56f961f062b538440af8bdc7497","node_id":"MDY6Q29tbWl0MjA2MzY0OjUwMTZmYzY5Zjg3NmI1NmY5NjFmMDYyYjUzODQ0MGFmOGJkYzc0OTc=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-10-28T03:43:27Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-10-28T03:43:27Z"},"message":"OPENJPA-944: Indirect recursion in fetch. Solution provided by Yanko Zhikov. \n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@830431 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"e59fcad1e7cab87d57f0b759cd9271cf800bd257","url":"https://api.github.com/repos/apache/openjpa/git/trees/e59fcad1e7cab87d57f0b759cd9271cf800bd257"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/5016fc69f876b56f961f062b538440af8bdc7497","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/5016fc69f876b56f961f062b538440af8bdc7497","html_url":"https://github.com/apache/openjpa/commit/5016fc69f876b56f961f062b538440af8bdc7497","comments_url":"https://api.github.com/repos/apache/openjpa/commits/5016fc69f876b56f961f062b538440af8bdc7497/comments","author":null,"committer":null,"parents":[{"sha":"3ec0fbf66fd6fd433d25e9884e2bd3453e78f1f4","url":"https://api.github.com/repos/apache/openjpa/commits/3ec0fbf66fd6fd433d25e9884e2bd3453e78f1f4","html_url":"https://github.com/apache/openjpa/commit/3ec0fbf66fd6fd433d25e9884e2bd3453e78f1f4"}],"stats":{"total":553,"additions":468,"deletions":85},"files":[{"sha":"2dacc018518231b04c679be7dc849b63e489355a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","status":"modified","additions":12,"deletions":12,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/5016fc69f876b56f961f062b538440af8bdc7497/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/5016fc69f876b56f961f062b538440af8bdc7497/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java?ref=5016fc69f876b56f961f062b538440af8bdc7497","patch":"@@ -70,7 +70,7 @@\n \n \n     /**\n-     * Return the context assiciated with this configuration;\n+     * Return the context associated with this configuration;\n      * may be null if it has not been set or this object has been serialized.\n      */\n     public StoreContext getContext();\n@@ -168,7 +168,7 @@\n      * will use when loading objects. Defaults to the\n      * <code>openjpa.FetchGroups</code> setting.  This set is not thread safe.\n      */\n-    public Set getFetchGroups();\n+    public Set<String> getFetchGroups();\n \n     /**\n      * Return true if the given fetch group has been added.\n@@ -185,7 +185,7 @@\n      * Adds <code>groups</code> to the set of fetch group names to\n      * use when loading objects.\n      */\n-    public FetchConfiguration addFetchGroups(Collection groups);\n+    public FetchConfiguration addFetchGroups(Collection<String> groups);\n \n     /**\n      * Remove the given fetch group.\n@@ -196,7 +196,7 @@\n      * Removes <code>groups</code> from the set of fetch group names\n      * to use when loading objects.\n      */\n-    public FetchConfiguration removeFetchGroups(Collection groups);\n+    public FetchConfiguration removeFetchGroups(Collection<String> groups);\n \n     /**\n      * Clears the set of fetch group names to use when loading\n@@ -216,7 +216,7 @@\n      * will use when loading objects. Defaults to the empty set.  This set is\n      * not thread safe.\n      */\n-    public Set getFields();\n+    public Set<String> getFields();\n \n     /**\n      * Return true if the given fully-qualified field has been added.\n@@ -233,7 +233,7 @@\n      * Adds <code>fields</code> to the set of fully-qualified field names to\n      * use when loading objects.\n      */\n-    public FetchConfiguration addFields(Collection fields);\n+    public FetchConfiguration addFields(Collection<String> fields);\n \n     /**\n      * Remove the given fully-qualified field.\n@@ -244,7 +244,7 @@\n      * Removes <code>fields</code> from the set of fully-qualified field names\n      * to use when loading objects.\n      */\n-    public FetchConfiguration removeFields(Collection fields);\n+    public FetchConfiguration removeFields(Collection<String> fields);\n \n     /**\n      * Clears the set of field names to use when loading\n@@ -344,7 +344,7 @@\n     /**\n      * Return a new result list for the current fetch configuration.\n      */\n-    public ResultList newResultList(ResultObjectProvider rop);\n+    public ResultList<?> newResultList(ResultObjectProvider rop);\n \n     /**\n      * Sets an arbitrary query hint that may be utilized during\n@@ -394,22 +394,22 @@\n     /**\n      * Root classes for recursive operations. This set is not thread safe.\n      */\n-    public Set getRootClasses();\n+    public Set<Class<?>> getRootClasses();\n \n     /**\n      * Root classes for recursive operations.\n      */\n-    public FetchConfiguration setRootClasses(Collection classes);\n+    public FetchConfiguration setRootClasses(Collection<Class<?>> classes);\n \n     /**\n      * Root instances for recursive operations. This set is not thread safe.\n      */\n-    public Set getRootInstances();\n+    public Set<Object> getRootInstances();\n \n     /**\n      * Root instances for recursive operations.\n      */\n-    public FetchConfiguration setRootInstances(Collection roots);\n+    public FetchConfiguration setRootInstances(Collection<?> roots);\n \n     /**\n      * Synchronize on internal lock if multithreaded is true."},{"sha":"cf46395222fd98bc707c1fb04a1db4055942a70c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","status":"modified","additions":77,"deletions":73,"changes":150,"blob_url":"https://github.com/apache/openjpa/blob/5016fc69f876b56f961f062b538440af8bdc7497/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/5016fc69f876b56f961f062b538440af8bdc7497/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java?ref=5016fc69f876b56f961f062b538440af8bdc7497","patch":"@@ -58,6 +58,7 @@\n  * @author Pinaki Poddar\n  * @nojavadoc\n  */\n+@SuppressWarnings(\"serial\")\n public class FetchConfigurationImpl\n     implements FetchConfiguration, Cloneable {\n \n@@ -80,11 +81,11 @@\n         public int lockMode = 0;\n         public int readLockLevel = LOCK_NONE;\n         public int writeLockLevel = LOCK_NONE;\n-        public Set fetchGroups = null;\n-        public Set fields = null;\n-        public Set rootClasses;\n-        public Set rootInstances;\n-        public Map hints = null;\n+        public Set<String> fetchGroups = null;\n+        public Set<String> fields = null;\n+        public Set<Class<?>> rootClasses;\n+        public Set<Object> rootInstances;\n+        public Map<String,Object> hints = null;\n         public boolean fetchGroupContainsDefault = false;\n         public boolean fetchGroupContainsAll = false;\n         public boolean extendedPathLookup = false;\n@@ -95,7 +96,7 @@\n     private final ConfigurationState _state;\n     private FetchConfigurationImpl _parent;\n     private String _fromField;\n-    private Class _fromType;\n+    private Class<?> _fromType;\n     private String _directRelationOwner;\n     private boolean _load = true;\n     private int _availableRecursion;\n@@ -188,7 +189,7 @@ void copyHints(FetchConfiguration fetch) {\n         if (this._state == null)\n             return;\n         if (this._state.hints == null)\n-            this._state.hints = new HashMap();\n+            this._state.hints = new HashMap<String,Object>();\n         this._state.hints.putAll(from._state.hints);\n     }\n     \n@@ -258,9 +259,9 @@ else if (flush != DEFAULT)\n         return this;\n     }\n \n-    public Set getFetchGroups() {\n-        return (_state.fetchGroups == null) ? Collections.EMPTY_SET \n-            : _state.fetchGroups;\n+    public Set<String> getFetchGroups() {\n+        if (_state.fetchGroups == null) return Collections.emptySet();\n+        return _state.fetchGroups;\n     }\n \n     public boolean hasFetchGroup(String group) {\n@@ -286,7 +287,7 @@ public FetchConfiguration addFetchGroup(String name) {\n         lock();\n         try {\n             if (_state.fetchGroups == null)\n-                _state.fetchGroups = new HashSet();\n+                _state.fetchGroups = new HashSet<String>();\n             _state.fetchGroups.add(name);\n             if (FetchGroup.NAME_ALL.equals(name))\n                 _state.fetchGroupContainsAll = true;\n@@ -298,11 +299,11 @@ else if (FetchGroup.NAME_DEFAULT.equals(name))\n         return this;\n     }\n \n-    public FetchConfiguration addFetchGroups(Collection groups) {\n+    public FetchConfiguration addFetchGroups(Collection<String> groups) {\n         if (groups == null || groups.isEmpty())\n             return this;\n-        for (Iterator itr = groups.iterator(); itr.hasNext();)\n-            addFetchGroup((String) itr.next());\n+        for (String group : groups)\n+            addFetchGroup(group);\n         return this;\n     }\n \n@@ -322,12 +323,12 @@ else if (FetchGroup.NAME_DEFAULT.equals(group))\n         return this;\n     }\n \n-    public FetchConfiguration removeFetchGroups(Collection groups) {\n+    public FetchConfiguration removeFetchGroups(Collection<String> groups) {\n         lock();\n         try {\n             if (_state.fetchGroups != null && groups != null)\n-                for (Object group : groups)\n-                    removeFetchGroup(group.toString());\n+                for (String group : groups)\n+                    removeFetchGroup(group);\n         } finally {\n             unlock();\n         }\n@@ -356,8 +357,9 @@ public FetchConfiguration resetFetchGroups() {\n         return this;\n     }\n \n-    public Set getFields() {\n-        return (_state.fields == null) ? Collections.EMPTY_SET : _state.fields;\n+    public Set<String> getFields() {\n+        if (_state.fields == null) return Collections.emptySet();\n+        return _state.fields;\n     }\n \n     public boolean hasField(String field) {\n@@ -371,22 +373,22 @@ public FetchConfiguration addField(String field) {\n         lock();\n         try {\n             if (_state.fields == null)\n-                _state.fields = new HashSet();\n+                _state.fields = new HashSet<String>();\n             _state.fields.add(field);\n         } finally {\n             unlock();\n         }\n         return this;\n     }\n \n-    public FetchConfiguration addFields(Collection fields) {\n+    public FetchConfiguration addFields(Collection<String> fields) {\n         if (fields == null || fields.isEmpty())\n             return this;\n \n         lock();\n         try {\n             if (_state.fields == null)\n-                _state.fields = new HashSet();\n+                _state.fields = new HashSet<String>();\n             _state.fields.addAll(fields);\n         } finally {\n             unlock();\n@@ -405,7 +407,7 @@ public FetchConfiguration removeField(String field) {\n         return this;\n     }\n \n-    public FetchConfiguration removeFields(Collection fields) {\n+    public FetchConfiguration removeFields(Collection<String> fields) {\n         lock();\n         try {\n             if (_state.fields != null)\n@@ -427,6 +429,22 @@ public FetchConfiguration clearFields() {\n         return this;\n     }\n \n+    public DataCacheRetrieveMode getCacheRetrieveMode() {\n+        return _state.cacheRetrieveMode;\n+    }\n+\n+    public DataCacheStoreMode getCacheStoreMode() {\n+        return _state.cacheStoreMode;\n+    }\n+\n+    public void setCacheRetrieveMode(DataCacheRetrieveMode mode) {\n+        _state.cacheRetrieveMode = mode;\n+    }\n+\n+    public void setCacheStoreMode(DataCacheStoreMode mode) {\n+        _state.cacheStoreMode = mode;\n+    }\n+\n     public int getLockTimeout() {\n         return _state.lockTimeout;\n     }\n@@ -554,7 +572,7 @@ public FetchConfiguration setWriteLockLevel(int level) {\n         return this;\n     }\n \n-    public ResultList newResultList(ResultObjectProvider rop) {\n+    public ResultList<?> newResultList(ResultObjectProvider rop) {\n         if (rop instanceof ListResultObjectProvider)\n             return new SimpleResultList(rop);\n         if (_state.fetchBatchSize < 0)\n@@ -589,7 +607,7 @@ public void addHint(String name, Object value) {\n         lock();\n         try {\n             if (_state.hints == null)\n-                _state.hints = new HashMap();\n+                _state.hints = new HashMap<String,Object>();\n             _state.hints.put(name, value);\n         } finally {\n             unlock();\n@@ -606,27 +624,27 @@ public Object removeHint(String name) {\n     \n     public Map<String, Object> getHints() {\n         if (_state.hints == null)\n-            return (Map<String, Object>)Collections.EMPTY_MAP;\n+            return Collections.emptyMap();\n         Map<String, Object> result = new TreeMap<String, Object>();\n         for (Object key : _state.hints.keySet()) {\n             result.put(key.toString(), _state.hints.get(key));\n         }\n         return result;\n     }\n \n-    public Set getRootClasses() {\n-        return (_state.rootClasses == null) ? Collections.EMPTY_SET \n-            : _state.rootClasses;\n+    public Set<Class<?>> getRootClasses() {\n+        if (_state.rootClasses == null) return Collections.emptySet(); \n+        return _state.rootClasses;\n     }\n \n-    public FetchConfiguration setRootClasses(Collection classes) {\n+    public FetchConfiguration setRootClasses(Collection<Class<?>> classes) {\n         lock();\n         try {\n             if (_state.rootClasses != null)\n                 _state.rootClasses.clear();\n             if (classes != null && !classes.isEmpty()) {\n                 if (_state.rootClasses == null)\n-                    _state.rootClasses = new HashSet(classes);\n+                    _state.rootClasses = new HashSet<Class<?>>(classes);\n                 else \n                     _state.rootClasses.addAll(classes);\n             }\n@@ -636,21 +654,22 @@ public FetchConfiguration setRootClasses(Collection classes) {\n         return this;\n     }\n \n-    public Set getRootInstances() {\n-        return (_state.rootInstances == null) ? Collections.EMPTY_SET \n-            : _state.rootInstances;\n+    public Set<Object> getRootInstances() {\n+        if (_state.rootInstances == null) return Collections.emptySet(); \n+        return _state.rootInstances;\n     }\n \n-    public FetchConfiguration setRootInstances(Collection instances) {\n+    public FetchConfiguration setRootInstances(Collection<?> instances) {\n         lock();\n         try {\n             if (_state.rootInstances != null)\n                 _state.rootInstances.clear();\n             if (instances != null && !instances.isEmpty()) {\n-                if (_state.rootInstances == null)\n-                    _state.rootInstances = new HashSet(instances);\n-                else \n+                if (_state.rootInstances == null) {\n+                    _state.rootInstances = new HashSet<Object>(instances);\n+                } else { \n                     _state.rootInstances.addAll(instances);\n+                }\n             }\n         } finally {\n             unlock();\n@@ -676,7 +695,7 @@ public int requiresFetch(FieldMetaData fm) {\n         if (!includes(fm))\n             return FETCH_NONE;\n         \n-        Class type = getRelationType(fm);\n+        Class<?> type = getRelationType(fm);\n         if (type == null)\n             return FETCH_LOAD;\n         if (_availableDepth == 0)\n@@ -686,12 +705,13 @@ public int requiresFetch(FieldMetaData fm) {\n         // the field is in our fetch groups, so can't possibly not select\n         if (_parent == null) \n             return FETCH_LOAD;\n-\n-        int rdepth = getAvailableRecursionDepth(fm, type, false);\n+        \n+        String fieldName = fm.getFullName(false);\n+        int rdepth = getAvailableRecursionDepth(fm, type, fieldName, false);\n         if (rdepth != FetchGroup.DEPTH_INFINITE && rdepth <= 0)\n             return FETCH_NONE;\n \n-        if (StringUtils.equals(_directRelationOwner, fm.getFullName()))\n+        if (StringUtils.equals(_directRelationOwner, fieldName))\n             return FETCH_REF;\n         return FETCH_LOAD;\n     }\n@@ -701,7 +721,7 @@ public boolean requiresLoad() {\n     }\n \n     public FetchConfiguration traverse(FieldMetaData fm) {\n-        Class type = getRelationType(fm);\n+        Class<?> type = getRelationType(fm);\n         if (type == null)\n             return this;\n \n@@ -710,7 +730,7 @@ public FetchConfiguration traverse(FieldMetaData fm) {\n         clone._availableDepth = reduce(_availableDepth);\n         clone._fromField = fm.getFullName(false);\n         clone._fromType = type;\n-        clone._availableRecursion = getAvailableRecursionDepth(fm, type, true);\n+        clone._availableRecursion = getAvailableRecursionDepth(fm, type, fm.getFullName(false), true);\n         if (StringUtils.equals(_directRelationOwner, fm.getFullName(false)))\n             clone._load = false;\n         else\n@@ -752,12 +772,13 @@ private boolean hasExtendedLookupPath(FieldMetaData fmd) {\n      *\n      * @param traverse whether we're traversing the field\n      */\n-    private int getAvailableRecursionDepth(FieldMetaData fm, Class type, \n+    private int getAvailableRecursionDepth(FieldMetaData fm, Class<?> type, String fromField,\n         boolean traverse) {\n         // see if there's a previous limit\n         int avail = Integer.MIN_VALUE;\n         for (FetchConfigurationImpl f = this; f != null; f = f._parent) {\n-            if (ImplHelper.isAssignable(f._fromType, type)) {\n+            if (StringUtils.equals(f._fromField, fromField) \n+                && ImplHelper.isAssignable(f._fromType, type)) {\n                 avail = f._availableRecursion;\n                 if (traverse)\n                     avail = reduce(avail);\n@@ -804,7 +825,7 @@ private int getAvailableRecursionDepth(FieldMetaData fm, Class type,\n     /**\n      * Return the relation type of the given field.\n      */\n-    private static Class getRelationType(FieldMetaData fm) {\n+    private static Class<?> getRelationType(FieldMetaData fm) {\n         if (fm.isDeclaredTypePC())\n             return fm.getDeclaredType();\n         if (fm.getElement().isDeclaredTypePC())\n@@ -853,17 +874,17 @@ String getTraversedFromField() {\n         return _fromField;\n     }\n \n-    Class getTraversedFromType() {\n+    Class<?> getTraversedFromType() {\n         return _fromType;\n     }\n \n-    List getPath() {\n+    List<FetchConfigurationImpl> getPath() {\n         if (isRoot())\n-            return Collections.EMPTY_LIST;\n-        return trackPath(new ArrayList());\n+            return Collections.emptyList();\n+        return trackPath(new ArrayList<FetchConfigurationImpl>());\n     }\n     \n-    List trackPath(List path) {\n+    List<FetchConfigurationImpl> trackPath(List<FetchConfigurationImpl> path) {\n         if (_parent != null)\n             _parent.trackPath(path);\n         path.add(this);\n@@ -875,34 +896,17 @@ public String toString() {\n             + \" (\" + _availableDepth + \")\" + getPathString();\n     }\n     \n-    private String getPathString()\n-    {\n-        List path = getPath();\n+    private String getPathString() {\n+        List<FetchConfigurationImpl> path = getPath();\n         if (path.isEmpty())\n             return \"\";\n         StringBuffer buf = new StringBuffer().append (\": \");\n-        for (Iterator itr = path.iterator(); itr.hasNext();) {\n-            buf.append(((FetchConfigurationImpl) itr.next()).\n-                getTraversedFromField());\n+        for (Iterator<FetchConfigurationImpl> itr = path.iterator(); itr.hasNext();) {\n+            buf.append(itr.next().getTraversedFromField());\n             if (itr.hasNext())\n                 buf.append(\"->\");\n         }\n         return buf.toString();\n     }\n \n-    public DataCacheRetrieveMode getCacheRetrieveMode() {\n-        return _state.cacheRetrieveMode;\n-    }\n-\n-    public DataCacheStoreMode getCacheStoreMode() {\n-        return _state.cacheStoreMode;\n-    }\n-\n-    public void setCacheRetrieveMode(DataCacheRetrieveMode mode) {\n-        _state.cacheRetrieveMode = mode;\n-    }\n-\n-    public void setCacheStoreMode(DataCacheStoreMode mode) {\n-        _state.cacheStoreMode = mode;\n-    }\n }"},{"sha":"5337db2e8243d8a870ed1394058db4162b8dee6c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestIndirectRecursion.java","status":"added","additions":198,"deletions":0,"changes":198,"blob_url":"https://github.com/apache/openjpa/blob/5016fc69f876b56f961f062b538440af8bdc7497/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestIndirectRecursion.java","raw_url":"https://github.com/apache/openjpa/raw/5016fc69f876b56f961f062b538440af8bdc7497/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestIndirectRecursion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestIndirectRecursion.java?ref=5016fc69f876b56f961f062b538440af8bdc7497","patch":"@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.kernel;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.Query;\n+\n+import org.apache.openjpa.persistence.FetchPlan;\n+import org.apache.openjpa.persistence.OpenJPAPersistence;\n+import org.apache.openjpa.persistence.kernel.common.apps.State;\n+import org.apache.openjpa.persistence.kernel.common.apps.Transition;\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+/**\n+ * Test complex relationship graph fetch.\n+ * The graph is represented by State (node) and Transition(edges).\n+ * Graph nodes (State) holds pair of list of incoming/outgoing edges (Transition).\n+ * The problem report [1] showed that traversal from a root node (incorrectly) terminates\n+ * at a depth of 1 irrespective of the value of recursion depth and/or max depth depth.\n+ * \n+ * The test data featureSelection is originally reported in \n+ * [1] FetchGroup Recursion Problem\n+ * <A HREF=\"http://n2.nabble.com/Fetchgroups-recursion-problem-tc3874382.html#a3874382\">mailing list</A>.\n+ * \n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public class TestIndirectRecursion extends SingleEMFTestCase {\n+    // The connection matrix\n+    static byte[][] transitions = { \n+      //  s1 s2 s3 s4 s5    \n+        { 0, 1, 0, 0, 0 }, // s1 \n+        { 1, 0, 1, 1, 0 }, // s2\n+        { 1, 1, 0, 1, 0 }, // s3\n+        { 0, 0, 0, 0, 1 }, // s4\n+        { 0, 0, 0, 0, 0 }  // s5\n+    };\n+\n+    public void setUp() {\n+        super.setUp(CLEAR_TABLES, State.class, Transition.class);\n+    }\n+\n+    public void testFetch() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+\n+        int N = transitions.length;\n+        State[] states = new State[N];\n+        // create nodes \n+        for (int i = 1; i <= N; i++) {\n+            State s = new State();\n+            s.setName(\"s\" + i);\n+            em.persist(s);\n+            states[i - 1] = s;\n+        }\n+        // create edges as per the transition matrix \n+        for (int i = 0; i < N; i++) {\n+            for (int j = 0; j < N; j++) {\n+                if (transitions[i][j] == 1) {\n+                    newTransition(states[i], states[j]);\n+                }\n+            }\n+        }\n+        em.getTransaction().commit();\n+\n+        em.clear();\n+        \n+        // Select root (state 1)\n+        Query query = em.createQuery(\"select s from State s where s.name=:name\");\n+        FetchPlan fetch = OpenJPAPersistence.cast(query).getFetchPlan();\n+        fetch.setMaxFetchDepth(15);\n+        fetch.addField(State.class, \"incomingTransitions\");\n+        fetch.addField(State.class, \"outgoingTransitions\");\n+        fetch.addField(Transition.class, \"toState\");\n+        fetch.addField(Transition.class, \"fromState\");\n+        State qs1 = (State) query.setParameter(\"name\", \"s1\").getSingleResult();\n+\n+        em.close(); // will not load anything anymore\n+\n+        byte[][] actualTransitionMatrix = new byte[5][5];\n+        fillTransitionMatrix(actualTransitionMatrix, new HashSet<State>(), qs1);\n+        assertMatrixEqual(transitions, actualTransitionMatrix);\n+\n+    }\n+    \n+    void assertMatrixEqual(byte[][] expected, byte[][] actual) {\n+        int N = transitions.length;\n+        for (int i = 0; i < N; i++) {\n+            for (int j = 0; j < N; j++) {\n+                assertEquals(\"Transition(s\" + (i+1) + \", s\" + (j+1) + \") does not match\", expected[i][j], actual[i][j]);\n+            }\n+        }\n+    }\n+\n+    void fillTransitionMatrix(byte[][] matrix, Set<State> visited, State s) {\n+        if (visited.contains(s))\n+            return;\n+        List<Transition> outgoings = s.getOutgoingTransitions();\n+        if (outgoings != null) {\n+            for (Transition t : outgoings) {\n+                fillTransitionMatrix(matrix, t);\n+            }\n+        }\n+        visited.add(s);\n+\n+        if (outgoings != null) {\n+            for (Transition t : outgoings) {\n+                fillTransitionMatrix(matrix, visited, t.getToState());\n+            }\n+        }\n+\n+    }\n+\n+    void fillTransitionMatrix(byte[][] matrix, Transition t) {\n+        matrix[getIndex(t.getFromState())][getIndex(t.getToState())] = 1;\n+    }\n+\n+    int getIndex(State s) {\n+        return Integer.parseInt(s.getName().substring(1)) - 1;\n+    }\n+\n+    Transition newTransition(State from, State to) {\n+        Transition t = new Transition();\n+        t.setFromState(from);\n+        t.setToState(to);\n+        t.setName(from.getName()+\"->\"+to.getName());\n+        from.addOutgoingTransitions(t);\n+        to.addIncomingTransitions(t);\n+        return t;\n+    }\n+\n+    /**\n+     * Find a state of the given name in the list of outgoing transition of the\n+     * given State.\n+     */\n+    State findOutgoingState(String name, State root) {\n+        List<Transition> transitions = root.getOutgoingTransitions();\n+        for (Transition t : transitions) {\n+            if (t.getToState().getName().equals(name))\n+                return t.getToState();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Find a state of the given name in the list of incoming transition of the\n+     * given State.\n+     */\n+    State findIncomingState(String name, State root) {\n+        List<Transition> transitions = root.getIncomingTransitions();\n+        for (Transition t : transitions) {\n+            if (t.getFromState().getName().equals(name))\n+                return t.getFromState();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Asserts the the origin state has the given incoming states.\n+     */\n+    void assertIncomingStates(State origin, State... expected) {\n+        assertNotNull(origin);\n+        for (State e : expected) {\n+            assertNotNull(e + \" in not an incoimng states of \" + origin, findIncomingState(e.getName(), origin));\n+        }\n+    }\n+\n+    /**\n+     * Asserts the the origin state has the given outgoing states.\n+     */\n+    void assertOutgoingStates(State origin, State... expected) {\n+        assertNotNull(origin);\n+        for (State e : expected) {\n+            assertNotNull(e + \" in not an incoimng states of \" + origin, findOutgoingState(e.getName(), origin));\n+        }\n+    }\n+}"},{"sha":"869197d03d2e81cead59dd6ac3dd09795c25c1cb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/common/apps/State.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/apache/openjpa/blob/5016fc69f876b56f961f062b538440af8bdc7497/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/common/apps/State.java","raw_url":"https://github.com/apache/openjpa/raw/5016fc69f876b56f961f062b538440af8bdc7497/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/common/apps/State.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/common/apps/State.java?ref=5016fc69f876b56f961f062b538440af8bdc7497","patch":"@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.kernel.common.apps;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.OneToMany;\n+\n+import org.apache.openjpa.persistence.FetchGroup;\n+import org.apache.openjpa.persistence.FetchAttribute;\n+import org.apache.openjpa.persistence.FetchGroups;\n+import org.apache.openjpa.persistence.kernel.TestIndirectRecursion;\n+\n+/**\n+ * Represents a graph node.\n+ * Used in testing {@linkplain TestIndirectRecursion}.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+@SuppressWarnings(\"serial\")\n+@Entity\n+@FetchGroups( {\n+        @FetchGroup(name = \"State_OutgoingTransitions\", attributes = { @FetchAttribute(name = \"outgoingTransitions\") }),\n+        @FetchGroup(name = \"State_IncomingTransitions\", attributes = { @FetchAttribute(name = \"incomingTransitions\")})})\n+public class State implements Serializable {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Long id;\n+\n+    @Column(length = 64)\n+    private String name;\n+\n+    @OneToMany(mappedBy = \"fromState\", cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REFRESH })\n+    private List<Transition> outgoingTransitions;\n+\n+    @OneToMany(mappedBy = \"toState\", cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REFRESH })\n+    private List<Transition> incomingTransitions;\n+    \n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public List<Transition> getOutgoingTransitions() {\n+        return outgoingTransitions;\n+    }\n+\n+    public void addOutgoingTransitions(Transition outgoingTransition) {\n+        if (outgoingTransitions == null)\n+            outgoingTransitions = new ArrayList<Transition>();\n+        outgoingTransitions.add(outgoingTransition);\n+    }\n+\n+    public List<Transition> getIncomingTransitions() {\n+        return incomingTransitions;\n+    }\n+\n+    public void addIncomingTransitions(Transition incomingTransition) {\n+        if (incomingTransitions == null)\n+            incomingTransitions = new ArrayList<Transition>();\n+        incomingTransitions.add(incomingTransition);\n+    }\n+}"},{"sha":"787a381fc82f19f2e866c3f350f1c00622b26aeb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/common/apps/Transition.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/5016fc69f876b56f961f062b538440af8bdc7497/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/common/apps/Transition.java","raw_url":"https://github.com/apache/openjpa/raw/5016fc69f876b56f961f062b538440af8bdc7497/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/common/apps/Transition.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/common/apps/Transition.java?ref=5016fc69f876b56f961f062b538440af8bdc7497","patch":"@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.kernel.common.apps;\n+\n+import java.io.Serializable;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+\n+import org.apache.openjpa.persistence.kernel.TestIndirectRecursion;\n+\n+/**\n+ * Represents a graph edge.\n+ * Used in testing {@linkplain TestIndirectRecursion}.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+@SuppressWarnings(\"serial\")\n+@Entity\n+public class Transition implements Serializable {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Long id;\n+\n+    @Column(length = 64)\n+    private String name;\n+\n+    @ManyToOne(cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REFRESH })\n+    @JoinColumn(name = \"FROM_STATE_ID\", referencedColumnName = \"ID\")\n+    private State fromState;\n+\n+    @ManyToOne(cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REFRESH })\n+    @JoinColumn(name = \"TO_STATE_ID\", referencedColumnName = \"ID\")\n+    private State toState;\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public State getFromState() {\n+        return fromState;\n+    }\n+\n+    public void setFromState(State fromState) {\n+        this.fromState = fromState;\n+    }\n+\n+    public State getToState() {\n+        return toState;\n+    }\n+\n+    public void setToState(State toState) {\n+        this.toState = toState;\n+    }\n+}"}]}

