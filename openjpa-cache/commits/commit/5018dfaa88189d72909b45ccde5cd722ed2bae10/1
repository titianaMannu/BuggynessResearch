{"sha":"5018dfaa88189d72909b45ccde5cd722ed2bae10","node_id":"MDY6Q29tbWl0MjA2MzY0OjUwMThkZmFhODgxODlkNzI5MDliNDVjY2RlNWNkNzIyZWQyYmFlMTA=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-11-21T17:40:54Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-11-21T17:40:54Z"},"message":"OPENJPA-126: EntityManager serializability. Also includes a fix to make LoadListener.afterRefresh() work. Committing directly (not via remote queue) as I'm about to lose my internet connection for a while. Hopefully, my local testing is accurate.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@597155 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5fb5f1f161ba1602bec780dcf75a19e531732b3a","url":"https://api.github.com/repos/apache/openjpa/git/trees/5fb5f1f161ba1602bec780dcf75a19e531732b3a"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/5018dfaa88189d72909b45ccde5cd722ed2bae10","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/5018dfaa88189d72909b45ccde5cd722ed2bae10","html_url":"https://github.com/apache/openjpa/commit/5018dfaa88189d72909b45ccde5cd722ed2bae10","comments_url":"https://api.github.com/repos/apache/openjpa/commits/5018dfaa88189d72909b45ccde5cd722ed2bae10/comments","author":null,"committer":null,"parents":[{"sha":"fad6f352012ad403752eee463a5b6b3456fc0d74","url":"https://api.github.com/repos/apache/openjpa/commits/fad6f352012ad403752eee463a5b6b3456fc0d74","html_url":"https://github.com/apache/openjpa/commit/fad6f352012ad403752eee463a5b6b3456fc0d74"}],"stats":{"total":2289,"additions":1870,"deletions":419},"files":[{"sha":"84741971200e086ebd42746f1a0c6d7e115872b7","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSavepointManager.java","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSavepointManager.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSavepointManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSavepointManager.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -18,6 +18,9 @@\n  */\n package org.apache.openjpa.jdbc.kernel;\n \n+import java.io.IOException;\n+import java.io.NotSerializableException;\n+import java.io.ObjectOutputStream;\n import java.sql.Connection;\n import java.util.Collection;\n \n@@ -134,5 +137,10 @@ public void save(Collection states) {\n             AbstractJDBCSavepointManager.this.setDataStore(this);\n             super.save(states);\n         }\n+\n+        private void writeObject(ObjectOutputStream out)\n+            throws IOException {\n+            throw new NotSerializableException();\n+        }\n     }\n }"},{"sha":"e792d118057ff819eb331202fa354fc820fb0a02","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -582,8 +582,8 @@ public OpenJPAStateManager getOwner() {\n             return _owner;\n         }\n \n-        public ValueMetaData getOwnerMetaData() {\n-            return _vmd;\n+        public int getOwnerIndex() {\n+            return _vmd.getFieldMetaData().getIndex();\n         }\n \n         public boolean isEmbedded() {"},{"sha":"aa45abee0dd436171e62e3b71c59573e13cb978c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","status":"modified","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -245,6 +245,36 @@ static String toPCSubclassName(Class cls) {\n             + cls.getName().replace('.', '$') + \"$pcsubclass\";\n     }\n \n+    /**\n+     * Whether or not <code>className</code> is the name for a\n+     * dynamically-created persistence-capable subclass.\n+     *\n+     * @since 1.1.0\n+     */\n+    public static boolean isPCSubclassName(String className) {\n+        return className.startsWith(Strings.getPackageName(PCEnhancer.class))\n+            && className.endsWith(\"$pcsubclass\");\n+    }\n+\n+    /**\n+     * If <code>className</code> is a dynamically-created persistence-capable\n+     * subclass name, returns the name of the class that it subclasses.\n+     * Otherwise, returns <code>className</code>.\n+     *\n+     * @since 1.1.0\n+     */\n+    public static String toManagedTypeName(String className) {\n+        if (isPCSubclassName(className)) {\n+            className = className.substring(\n+                Strings.getPackageName(PCEnhancer.class).length() + 1);\n+            className = className.substring(0, className.lastIndexOf(\"$\"));\n+            // this is not correct for nested PCs\n+            className = className.replace('$', '.');\n+        }\n+        \n+        return className;\n+    }\n+\n     /**\n      * Constructor. Supply configuration, type, and metadata.\n      */\n@@ -2718,6 +2748,9 @@ private void addSerializationCode() {\n             return;\n \n         if (getCreateSubclass()) {\n+            // ##### what should happen if a type is Externalizable? It looks\n+            // ##### like Externalizable classes will not be serialized as PCs\n+            // ##### based on this logic.\n             if (!Externalizable.class.isAssignableFrom(\n                 _meta.getDescribedType()))\n                 addSubclassSerializationCode();"},{"sha":"d69efafecff02eab0f258591dd7ad5f861ec0b40","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -121,6 +121,17 @@ public static PersistenceCapable newInstance(Class pcClass,\n         return (meta.pc == null) ? null : meta.pc.pcNewInstance(sm, oid, clear);\n     }\n \n+    /**\n+     * Return the persistence-capable type for <code>type</code>. This might\n+     * be a generated subclass of <code>type</code>.\n+     *\n+     * @since 1.1.0\n+     */\n+    public static Class getPCType(Class type) {\n+        Meta meta = getMeta(type);\n+        return (meta.pc == null) ? null : meta.pc.getClass();\n+    }\n+\n     /**\n      * Create a new identity object for the given\n      * <code>PersistenceCapable</code> class."},{"sha":"869c5e81ff3c35ee28d684eadae4ab7318572f2e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","status":"modified","additions":49,"deletions":15,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -18,17 +18,23 @@\n  */\r\n package org.apache.openjpa.enhance;\r\n \r\n+import java.io.IOException;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.Serializable;\r\n import java.lang.reflect.Field;\r\n import java.lang.reflect.Method;\r\n \r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.kernel.StateManagerImpl;\r\n import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n import org.apache.openjpa.util.ApplicationIds;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n import org.apache.openjpa.util.InternalException;\r\n import org.apache.openjpa.util.ObjectId;\r\n-import org.apache.openjpa.kernel.StateManagerImpl;\r\n \r\n /**\r\n  * Implementation of the {@link PersistenceCapable} interface that can handle\r\n@@ -38,12 +44,19 @@\n  * @since 1.0.0\r\n  */\r\n public class ReflectingPersistenceCapable\r\n-    implements PersistenceCapable, ManagedInstanceProvider {\r\n+    implements PersistenceCapable, ManagedInstanceProvider, Serializable {\r\n \r\n     private Object o;\r\n     private StateManager sm;\r\n-    private PersistenceCapable pcSubclassInstance;\r\n-    private ClassMetaData meta;\r\n+\r\n+    // this will be reconstituted in readObject()\r\n+    private transient PersistenceCapable pcSubclassInstance;\r\n+\r\n+    // this will reconstituted by a call to pcReplaceStateManager() by the\r\n+    // instance that has a reference to the deserialized data\r\n+    private transient ClassMetaData meta;\r\n+\r\n+    private boolean serializationUserVisible = true;\r\n \r\n     public ReflectingPersistenceCapable(Object o, OpenJPAConfiguration conf) {\r\n         this.o = o;\r\n@@ -70,6 +83,8 @@ public StateManager pcGetStateManager() {\n \r\n     public void pcReplaceStateManager(StateManager sm) {\r\n         this.sm = sm;\r\n+        if (meta == null && sm instanceof OpenJPAStateManager)\r\n+            meta = ((OpenJPAStateManager) sm).getMetaData();\r\n     }\r\n \r\n     public void pcProvideField(int i) {\r\n@@ -169,6 +184,10 @@ public void pcCopyField(Object fromObject, int i) {\n     }\r\n \r\n     public void pcCopyFields(Object fromObject, int[] fieldIndices) {\r\n+        if (fromObject instanceof ReflectingPersistenceCapable)\r\n+            fromObject = ((ReflectingPersistenceCapable) fromObject)\r\n+                .getManagedInstance();\r\n+        \r\n         for(int i = 0; i < fieldIndices.length; i++)\r\n             pcCopyField(fromObject, fieldIndices[i]);\r\n     }\r\n@@ -305,21 +324,23 @@ public void pcSetDetachedState(Object state) {\n         // ##### we can implement this if a state field has been set\r\n     }\r\n \r\n+    public void pcSetSerializationUserVisible(boolean userVisible) {\r\n+        serializationUserVisible = userVisible;\r\n+    }\r\n+\r\n+    public boolean pcIsSerializationUserVisible() {\r\n+        return serializationUserVisible;\r\n+    }\r\n+\r\n     public Object getManagedInstance() {\r\n         return o;\r\n     }\r\n \r\n     private Object getValue(int i, Object o) {\r\n         if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\r\n-            if (!meta.isIntercepting()) {\r\n-                Method meth = Reflection.findGetter(meta.getDescribedType(),\r\n-                    meta.getField(i).getName(), true);\r\n-                return Reflection.get(o, meth);\r\n-            } else {\r\n-                Field field = Reflection.findField(meta.getDescribedType(),\r\n-                    toFieldName(i), true);\r\n-                return Reflection.get(o, field);\r\n-            }\r\n+            Field field = Reflection.findField(meta.getDescribedType(),\r\n+                toFieldName(i), true);\r\n+            return Reflection.get(o, field);\r\n         } else {\r\n             Field field = (Field) meta.getField(i).getBackingMember();\r\n             return Reflection.get(o, field);\r\n@@ -350,4 +371,17 @@ private void setValue(int i, Object o, Object val) {\n             Reflection.set(o, field, val);\r\n         }\r\n     }\r\n+\r\n+    private void writeObject(ObjectOutputStream out) throws IOException {\r\n+        out.defaultWriteObject();\r\n+        out.writeObject(meta.getDescribedType());\r\n+    }\r\n+\r\n+    private void readObject(ObjectInputStream in)\r\n+        throws ClassNotFoundException, IOException {\r\n+        in.defaultReadObject();\r\n+        Class type = (Class) in.readObject();\r\n+        pcSubclassInstance = PCRegistry.newInstance(type, null, false);\r\n+        ImplHelper.registerPersistenceCapable(this);\r\n+    }\r\n }\r"},{"sha":"66bdbb219b35112525ffe115829b339afdd20bc9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.openjpa.event;\n \n+import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n@@ -44,7 +45,7 @@\n  * @nojavadoc\n  */\n public class LifecycleEventManager\n-    implements CallbackModes {\n+    implements CallbackModes, Serializable {\n \n     private static final Exception[] EMPTY_EXCEPTIONS = new Exception[0];\n "},{"sha":"3544d51112124d395915dd165224a6a92eeee288","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"modified","additions":70,"deletions":38,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -19,16 +19,16 @@\n package org.apache.openjpa.kernel;\n \n import java.io.ObjectStreamException;\n+import java.lang.reflect.InvocationTargetException;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Iterator;\n-import java.util.Map;\n-import java.util.Properties;\n import java.util.LinkedList;\n import java.util.List;\n-import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+import java.util.Properties;\n import javax.transaction.Status;\n import javax.transaction.Synchronization;\n import javax.transaction.Transaction;\n@@ -41,23 +41,24 @@\n import org.apache.openjpa.ee.ManagedRuntime;\n import org.apache.openjpa.enhance.PCRegistry;\n import org.apache.openjpa.enhance.PersistenceCapable;\n-import org.apache.openjpa.event.RemoteCommitEventManager;\n import org.apache.openjpa.event.BrokerFactoryEvent;\n+import org.apache.openjpa.event.RemoteCommitEventManager;\n import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.Configurations;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.J2DoPrivHelper;\n+import org.apache.openjpa.lib.util.JavaVersions;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.lib.util.ReferenceHashSet;\n-import org.apache.openjpa.lib.util.JavaVersions;\n import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;\n import org.apache.openjpa.lib.util.concurrent.ReentrantLock;\n import org.apache.openjpa.meta.MetaDataRepository;\n import org.apache.openjpa.util.GeneralException;\n+import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.InvalidStateException;\n import org.apache.openjpa.util.OpenJPAException;\n import org.apache.openjpa.util.UserException;\n-import org.apache.openjpa.util.InternalException;\n \n /**\n  * Abstract implementation of the {@link BrokerFactory}\n@@ -114,19 +115,31 @@ public static AbstractBrokerFactory getPooledFactory(\n \n     /**\n      * Return an internal factory pool key for the given configuration.\n-     * We use the conf properties as given by the user because that is what's\n-     * passed to {@link #getPooledFactory} when looking for an existing factory.\n      */\n-    private static Map toPoolKey(OpenJPAConfiguration conf) {\n-        return conf.toProperties(false);\n+    private static Object toPoolKey(OpenJPAConfiguration conf) {\n+        if (conf.getId() != null)\n+            return conf.getId();\n+        else\n+            return conf.toProperties(false);\n     }\n \n     /**\n      * Return the pooled factory matching the given configuration data, or null\n      * if none.\n      */\n     protected static AbstractBrokerFactory getPooledFactory(Map map) {\n-        return (AbstractBrokerFactory) _pool.get(map);\n+        Object key = Configurations.getProperty(\"Id\", map);\n+        if (key == null)\n+            key = map;\n+        return getPooledFactoryForKey(key);\n+    }\n+\n+    /**\n+     * Return the pooled factory matching the given key, or null\n+     * if none. The key must be of the form created by {@link #getPoolKey}.\n+     */\n+    public static AbstractBrokerFactory getPooledFactoryForKey(Object key) {\n+        return (AbstractBrokerFactory) _pool.get(key);\n     }\n \n     /**\n@@ -174,32 +187,9 @@ public Broker newBroker(String user, String pass, boolean managed,\n             if (findExisting)\n                 broker = findBroker(user, pass, managed);\n             if (broker == null) {\n-                // decorate the store manager for data caching and custom\n-                // result object providers; always make sure it's a delegating\n-                // store manager, because it's easier for users to deal with\n-                // that way\n-                StoreManager sm = newStoreManager();\n-                DelegatingStoreManager dsm = null;\n-                if (_conf.getDataCacheManagerInstance().getSystemDataCache()\n-                    != null)\n-                    dsm = new DataCacheStoreManager(sm);\n-                dsm = new ROPStoreManager((dsm == null) ? sm : dsm);\n-\n                 broker = newBrokerImpl(user, pass);\n-                broker.initialize(this, dsm, managed, connRetainMode);\n-                addListeners(broker);\n-\n-                // if we're using remote events, register the event manager so\n-                // that it can broadcast commit notifications from the broker\n-                RemoteCommitEventManager remote = _conf.\n-                    getRemoteCommitEventManager();\n-                if (remote.areRemoteEventsEnabled())\n-                    broker.addTransactionListener(remote);\n-\n-                loadPersistentTypes(broker.getClassLoader());\n+                initializeBroker(managed, connRetainMode, broker, false);\n             }\n-            _brokers.add(broker);\n-            _conf.setReadOnly(Configuration.INIT_STATE_FROZEN);\n             return broker;\n         } catch (OpenJPAException ke) {\n             throw ke;\n@@ -208,6 +198,39 @@ public Broker newBroker(String user, String pass, boolean managed,\n         }\n     }\n \n+    void initializeBroker(boolean managed, int connRetainMode,\n+        BrokerImpl broker, boolean fromDeserialization) {\n+        assertOpen();\n+        makeReadOnly();\n+\n+        // decorate the store manager for data caching and custom\n+        // result object providers; always make sure it's a delegating\n+        // store manager, because it's easier for users to deal with\n+        // that way\n+        StoreManager sm = newStoreManager();\n+        DelegatingStoreManager dsm = null;\n+        if (_conf.getDataCacheManagerInstance().getSystemDataCache()\n+            != null)\n+            dsm = new DataCacheStoreManager(sm);\n+        dsm = new ROPStoreManager((dsm == null) ? sm : dsm);\n+\n+        broker.initialize(this, dsm, managed, connRetainMode,\n+            fromDeserialization);\n+        if (!fromDeserialization)\n+            addListeners(broker);\n+\n+        // if we're using remote events, register the event manager so\n+        // that it can broadcast commit notifications from the broker\n+        RemoteCommitEventManager remote = _conf.\n+            getRemoteCommitEventManager();\n+        if (remote.areRemoteEventsEnabled())\n+            broker.addTransactionListener(remote);\n+\n+        loadPersistentTypes(broker.getClassLoader());\n+        _brokers.add(broker);\n+        _conf.setReadOnly(Configuration.INIT_STATE_FROZEN);\n+    }\n+\n     /**\n      * Add factory-registered lifecycle listeners to the broker.\n      */\n@@ -374,10 +397,10 @@ public void close() {\n             assertNoActiveTransaction();\n \n             // remove from factory pool\n-            Map map = toPoolKey(_conf);\n+            Object key = toPoolKey(_conf);\n             synchronized (_pool) {\n-                if (_pool.get(map) == this)\n-                    _pool.remove(map);\n+                if (_pool.get(key) == this)\n+                    _pool.remove(key);\n             }\n \n             // close all brokers\n@@ -756,6 +779,15 @@ public Collection getOpenBrokers() {\n         return Collections.unmodifiableCollection(_brokers);\n     }\n \n+    /**\n+     * @return a key that can be used to obtain this broker factory from the\n+     * pool at a later time.\n+     * @since 1.1.0\n+     */\n+    public Object getPoolKey() {\n+        return toPoolKey(getConfiguration());\n+    }\n+\n     /**\n      * Simple synchronization listener to remove completed transactions\n      * from our cache."},{"sha":"17ac0e9da759dc9e33848231f6cf840fc783e0b0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":121,"deletions":303,"changes":424,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -18,6 +18,9 @@\n  */\n package org.apache.openjpa.kernel;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n import java.io.Serializable;\n import java.lang.reflect.Modifier;\n import java.security.AccessController;\n@@ -91,7 +94,7 @@\n  * @author Abe White\n  */\n public class BrokerImpl\n-    implements Broker, FindCallbacks, Cloneable {\n+    implements Broker, FindCallbacks, Cloneable, Serializable {\n \n     /**\n      * Incremental flush.\n@@ -132,30 +135,35 @@\n     private static final int FLAG_RETAINED_CONN = 2 << 10;\n     private static final int FLAG_TRANS_ENDING = 2 << 11;\n \n+    private static final Object[] EMPTY_OBJECTS = new Object[0];\n+\n     private static final Localizer _loc =\n         Localizer.forPackage(BrokerImpl.class);\n \n     //\tthe store manager in use; this may be a decorator such as a\n     //\tdata cache store manager around the native store manager\n-    private DelegatingStoreManager _store = null;\n+    private transient DelegatingStoreManager _store = null;\n \n-    // ref to producing factory and configuration\n-    private AbstractBrokerFactory _factory = null;\n-    private OpenJPAConfiguration _conf = null;\n-    private Compatibility _compat = null;\n     private FetchConfiguration _fc = null;\n-    private Log _log = null;\n     private String _user = null;\n     private String _pass = null;\n-    private ManagedRuntime _runtime = null;\n-    private LockManager _lm = null;\n-    private InverseManager _im = null;\n-    private ReentrantLock _lock = null;\n-    private OpCallbacks _call = null;\n-    private RuntimeExceptionTranslator _extrans = null;\n+\n+    // these must be rebuilt by the facade layer during its deserialization\n+    private transient Log _log = null;\n+    private transient Compatibility _compat = null;\n+    private transient ManagedRuntime _runtime = null;\n+    private transient LockManager _lm = null;\n+    private transient InverseManager _im = null;\n+    private transient ReentrantLock _lock = null;\n+    private transient OpCallbacks _call = null;\n+    private transient RuntimeExceptionTranslator _extrans = null;\n+\n+    // ref to producing factory and configuration\n+    private transient AbstractBrokerFactory _factory = null;\n+    private transient OpenJPAConfiguration _conf = null;\n \n     // cache class loader associated with the broker\n-    private ClassLoader _loader = null;\n+    private transient ClassLoader _loader = null;\n \n     // user state\n     private Synchronization _sync = null;\n@@ -167,8 +175,11 @@\n     private Set _transAdditions = null;\n     private Set _derefCache = null;\n     private Set _derefAdditions = null;\n-    private Map _loading = null;\n-    private Set _operating = null;\n+\n+    // these are used for method-internal state only\n+    private transient Map _loading = null;\n+    private transient Set _operating = null;\n+\n     private Set _persistedClss = null;\n     private Set _updatedClss = null;\n     private Set _deletedClss = null;\n@@ -179,14 +190,15 @@\n     // (the first uses the transactional cache)\n     private Set _savepointCache = null;\n     private LinkedMap _savepoints = null;\n-    private SavepointManager _spm = null;\n+    private transient SavepointManager _spm = null;\n \n     // track open queries and extents so we can free their resources on close\n-    private ReferenceHashSet _queries = null;\n-    private ReferenceHashSet _extents = null;\n+    private transient ReferenceHashSet _queries = null;\n+    private transient ReferenceHashSet _extents = null;\n \n-    // track operation stack depth\n-    private int _operationCount = 0;\n+    // track operation stack depth. Transient because operations cannot\n+    // span serialization.\n+    private transient int _operationCount = 0;\n \n     // options\n     private boolean _nontransRead = false;\n@@ -210,17 +222,21 @@\n \n     // status\n     private int _flags = 0;\n-    private boolean _closed = false;\n-    private RuntimeException _closedException = null;\n+\n+    // this is not in status because it should not be serialized\n+    private transient boolean _isSerializing = false;\n+\n+    // transient because closed brokers can't be serialized\n+    private transient boolean _closed = false;\n+    private transient RuntimeException _closedException = null;\n \n     // event managers\n     private TransactionEventManager _transEventManager = null;\n     private int _transCallbackMode = 0;\n     private LifecycleEventManager _lifeEventManager = null;\n     private int _lifeCallbackMode = 0;\n \n-    private boolean _initializeWasInvoked = false;\n-    private static final Object[] EMPTY_OBJECTS = new Object[0];\n+    private transient boolean _initializeWasInvoked = false;\n \n     /**\n      * Set the persistence manager's authentication. This is the first\n@@ -245,17 +261,22 @@ public void setAuthentication(String user, String pass) {\n      * handle interaction with the data store\n      * @param managed the transaction mode\n      * @param connMode the connection retain mode\n+     * @param fromDeserialization whether this call happened because of a\n+     * deserialization or creation of a new BrokerImpl.\n      */\n-    public void initialize(AbstractBrokerFactory factory,\n-        DelegatingStoreManager sm, boolean managed, int connMode) {\n+    void initialize(AbstractBrokerFactory factory,\n+        DelegatingStoreManager sm, boolean managed, int connMode,\n+        boolean fromDeserialization) {\n         _initializeWasInvoked = true;\n         _loader = (ClassLoader) AccessController.doPrivileged(\n             J2DoPrivHelper.getContextClassLoaderAction());\n-        _conf = factory.getConfiguration();\n+        if (!fromDeserialization)\n+            _conf = factory.getConfiguration();\n         _compat = _conf.getCompatibilityInstance();\n         _factory = factory;\n         _log = _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\n-        _cache = new ManagedCache();\n+        if (!fromDeserialization)\n+            _cache = new ManagedCache(this);\n         initializeOperatingSet();\n         _connRetainMode = connMode;\n         _managed = managed;\n@@ -264,15 +285,17 @@ public void initialize(AbstractBrokerFactory factory,\n         else\n             _runtime = new LocalManagedRuntime(this);\n \n-        _lifeEventManager = new LifecycleEventManager();\n-        _transEventManager = new TransactionEventManager();\n-        int cmode = _conf.getMetaDataRepositoryInstance().\n-            getMetaDataFactory().getDefaults().getCallbackMode();\n-        setLifecycleListenerCallbackMode(cmode);\n-        setTransactionListenerCallbackMode(cmode);\n+        if (!fromDeserialization) {\n+            _lifeEventManager = new LifecycleEventManager();\n+            _transEventManager = new TransactionEventManager();\n+            int cmode = _conf.getMetaDataRepositoryInstance().\n+                getMetaDataFactory().getDefaults().getCallbackMode();\n+            setLifecycleListenerCallbackMode(cmode);\n+            setTransactionListenerCallbackMode(cmode);\n \n-        // setup default options\n-        _factory.configureBroker(this);\n+            // setup default options\n+            _factory.configureBroker(this);\n+        }\n \n         // make sure to do this after configuring broker so that store manager\n         // can look to broker configuration; we set both store and lock managers\n@@ -287,8 +310,10 @@ public void initialize(AbstractBrokerFactory factory,\n \n         if (_connRetainMode == CONN_RETAIN_ALWAYS)\n             retainConnection();\n-        _fc = _store.newFetchConfiguration();\n-        _fc.setContext(this);\n+        if (!fromDeserialization) {\n+            _fc = _store.newFetchConfiguration();\n+            _fc.setContext(this);\n+        }\n \n         // synch with the global transaction in progress, if any\n         if (_factory.syncWithManagedTransaction(this, false))\n@@ -749,7 +774,7 @@ protected Object find(Object oid, FetchConfiguration fetch, BitSet exclude,\n \n             // cached instance?\n             StateManagerImpl sm = getStateManagerImplById(oid,\n-                (flags & OID_ALLOW_NEW) != 0 || (_flags & FLAG_FLUSHED) != 0);\n+                (flags & OID_ALLOW_NEW) != 0 || hasFlushed());\n             if (sm != null) {\n                 if (!requiresLoad(sm, true, fetch, edata, flags))\n                     return call.processReturn(oid, sm);\n@@ -911,7 +936,7 @@ protected StateManagerImpl initialize(StateManagerImpl sm, boolean load,\n                 // if we don't have a cached instance or it is not transactional\n                 // and is hollow or we need to validate, load it\n                 sm = getStateManagerImplById(oid, (flags & OID_ALLOW_NEW) != 0\n-                    || (_flags & FLAG_FLUSHED) != 0);\n+                    || hasFlushed());\n                 initialized = sm != null;\n                 if (!initialized)\n                     sm = newStateManagerImpl(oid, (flags & OID_COPY) != 0);\n@@ -986,6 +1011,10 @@ protected StateManagerImpl initialize(StateManagerImpl sm, boolean load,\n         }\n     }\n \n+    private boolean hasFlushed() {\n+        return (_flags & FLAG_FLUSHED) != 0;\n+    }\n+\n     /**\n      * Return whether the given instance needs loading before being returned\n      * to the user.\n@@ -1457,8 +1486,7 @@ public void setSavepoint(String name) {\n             if (_savepoints != null && _savepoints.containsKey(name))\n                 throw new UserException(_loc.get(\"savepoint-exists\", name));\n \n-            if ((_flags & FLAG_FLUSHED) != 0\n-                && !_spm.supportsIncrementalFlush())\n+            if (hasFlushed() && !_spm.supportsIncrementalFlush())\n                 throw new UnsupportedException(_loc.get\n                     (\"savepoint-flush-not-supported\"));\n \n@@ -2359,8 +2387,7 @@ public OpenJPAStateManager persist(Object obj, Object id, boolean explicit,\n \n                 // an embedded field; notify the owner that the value has\n                 // changed by becoming independently persistent\n-                sm.getOwner().dirty(sm.getOwnerMetaData().\n-                    getFieldMetaData().getIndex());\n+                sm.getOwner().dirty(sm.getOwnerIndex());\n                 _cache.persist(sm);\n                 pc = sm.getPersistenceCapable();\n             } else {\n@@ -4357,278 +4384,69 @@ public Object processReturn(Object oid, OpenJPAStateManager sm) {\n         return (sm == null) ? null : sm.getManagedInstance();\n     }\n \n-    /**\n-     * Cache of managed objects.\n-     */\n-    private class ManagedCache {\n-\n-        private Map _main; // oid -> sm\n-        private Map _conflicts = null; // conflict oid -> new sm\n-        private Map _news = null; // tmp id -> new sm\n-        private Collection _embeds = null; // embedded/non-persistent sms\n-        private Collection _untracked = null; // hard refs to untracked sms\n-\n-        /**\n-         * Constructor; supply primary cache map.\n-         */\n-        private ManagedCache() {\n-            _main = newManagedObjectCache();\n-        }\n-\n-        /**\n-         * Return the instance for the given oid, optionally allowing\n-         * new instances.\n-         */\n-        public StateManagerImpl getById(Object oid, boolean allowNew) {\n-            if (oid == null)\n-                return null;\n-\n-            // check main cache for oid\n-            StateManagerImpl sm = (StateManagerImpl) _main.get(oid);\n-            StateManagerImpl sm2;\n-            if (sm != null) {\n-                // if it's a new instance, we know it's the only match, because\n-                // other pers instances override new instances in _cache\n-                if (sm.isNew())\n-                    return (allowNew) ? sm : null;\n-                if (!allowNew || !sm.isDeleted())\n-                    return sm;\n-\n-                // sm is deleted; check conflict cache\n-                if (_conflicts != null) {\n-                    sm2 = (StateManagerImpl) _conflicts.get(oid);\n-                    if (sm2 != null)\n-                        return sm2;\n-                }\n-            }\n-\n-            // at this point sm is null or deleted; check the new cache for\n-            // any matches. this allows us to match app id objects to new\n-            // instances without permanant oids\n-            if (allowNew && _news != null && !_news.isEmpty()) {\n-                sm2 = (StateManagerImpl) _news.get(oid);\n-                if (sm2 != null)\n-                    return sm2;\n-            }\n-            return sm;\n-        }\n-\n-        /**\n-         * Call this method when a new state manager initializes itself.\n-         */\n-        public void add(StateManagerImpl sm) {\n-            if (!sm.isIntercepting()) {\n-                if (_untracked == null)\n-                    _untracked = new HashSet();\n-                _untracked.add(sm);\n-            }\n-\n-            if (!sm.isPersistent() || sm.isEmbedded()) {\n-                if (_embeds == null)\n-                    _embeds = new ReferenceHashSet(ReferenceHashSet.WEAK);\n-                _embeds.add(sm);\n-                return;\n-            }\n-\n-            // initializing new instance; put in new cache because won't have\n-            // permanent oid yet\n-            if (sm.isNew()) {\n-                if (_news == null)\n-                    _news = new HashMap();\n-                _news.put(sm.getId(), sm);\n-                return;\n-            }\n-\n-            // initializing persistent instance; put in main cache\n-            StateManagerImpl orig = (StateManagerImpl) _main.put\n-                (sm.getObjectId(), sm);\n-            if (orig != null) {\n-                _main.put(sm.getObjectId(), orig);\n-                throw new UserException(_loc.get(\"dup-load\",\n-                    sm.getObjectId(), Exceptions.toString\n-                    (orig.getManagedInstance()))).\n-                    setFailedObject(sm.getManagedInstance());\n-            }\n-        }\n-\n-        /**\n-         * Remove the given state manager from the cache when it transitions\n-         * to transient.\n-         */\n-        public void remove(Object id, StateManagerImpl sm) {\n-            // if it has a permanent oid, remove from main / conflict cache,\n-            // else remove from embedded/nontrans cache, and if not there\n-            // remove from new cache\n-            Object orig;\n-            if (sm.getObjectId() != null) {\n-                orig = _main.remove(id);\n-                if (orig != sm) {\n-                    if (orig != null)\n-                        _main.put(id, orig); // put back\n-                    if (_conflicts != null) {\n-                        orig = _conflicts.remove(id);\n-                        if (orig != null && orig != sm)\n-                            _conflicts.put(id, orig); // put back\n-                    }\n-                }\n-            } else if ((_embeds == null || !_embeds.remove(sm))\n-                && _news != null) {\n-                orig = _news.remove(id);\n-                if (orig != null && orig != sm)\n-                    _news.put(id, orig); // put back\n-            }\n-\n-            if (_untracked != null)\n-                _untracked.remove(sm);\n-        }\n-\n-        /**\n-         * An embedded or nonpersistent managed instance has been persisted.\n-         */\n-        public void persist(StateManagerImpl sm) {\n-            if (_embeds != null)\n-                _embeds.remove(sm);\n-        }\n-\n-        /**\n-         * A new instance has just been assigned a permanent oid.\n-         */\n-        public void assignObjectId(Object id, StateManagerImpl sm) {\n-            // if assigning oid, remove from new cache and put in primary; may\n-            // not be in new cache if another new instance had same id\n-            StateManagerImpl orig = (StateManagerImpl) _news.remove(id);\n-            if (orig != null && orig != sm)\n-                _news.put(id, orig); // put back\n-\n-            // put in main cache, but make sure we don't replace another\n-            // instance with the same oid\n-            orig = (StateManagerImpl) _main.put(sm.getObjectId(), sm);\n-            if (orig != null) {\n-                _main.put(sm.getObjectId(), orig);\n-                if (!orig.isDeleted())\n-                    throw new UserException(_loc.get(\"dup-oid-assign\",\n-                        sm.getObjectId(), Exceptions.toString\n-                        (sm.getManagedInstance()))).\n-                        setFailedObject(sm.getManagedInstance());\n-\n-                // same oid as deleted instance; put in conflict cache\n-                if (_conflicts == null)\n-                    _conflicts = new HashMap();\n-                _conflicts.put(sm.getObjectId(), sm);\n-            }\n-        }\n-\n-        /**\n-         * A new instance has committed; recache under permanent oid.\n-         */\n-        public void commitNew(Object id, StateManagerImpl sm) {\n-            // if the id didn't change, the instance was already assigned an\n-            // id, but it could have been in conflict cache\n-            StateManagerImpl orig;\n-            if (sm.getObjectId() == id) {\n-                orig = (_conflicts == null) ? null\n-                    : (StateManagerImpl) _conflicts.remove(id);\n-                if (orig == sm) {\n-                    orig = (StateManagerImpl) _main.put(id, sm);\n-                    if (orig != null && !orig.isDeleted()) {\n-                        _main.put(sm.getObjectId(), orig);\n-                        throw new UserException(_loc.get(\"dup-oid-assign\",\n-                            sm.getObjectId(), Exceptions.toString\n-                            (sm.getManagedInstance()))).setFailedObject\n-                            (sm.getManagedInstance()).setFatal(true);\n-                    }\n-                }\n-                return;\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        assertOpen();\n+        lock();\n+        try {\n+            if (isActive()) {\n+                if (!getOptimistic())\n+                    throw new InvalidStateException(\n+                        _loc.get(\"cant-serialize-pessimistic-broker\"));\n+                if (hasFlushed())\n+                    throw new InvalidStateException(\n+                        _loc.get(\"cant-serialize-flushed-broker\"));\n+                if (hasConnection())\n+                    throw new InvalidStateException(\n+                        _loc.get(\"cant-serialize-connected-broker\"));\n             }\n \n-            // oid changed, so it must previously have been a new instance\n-            // without an assigned oid.  remove it from the new cache; ok if\n-            // we end up removing another instance with same id\n-            if (_news != null)\n-                _news.remove(id);\n-\n-            // and put into main cache now that id is asssigned\n-            orig = (StateManagerImpl) _main.put(sm.getObjectId(), sm);\n-            if (orig != null && orig != sm && !orig.isDeleted()) {\n-                // put back orig and throw error\n-                _main.put(sm.getObjectId(), orig);\n-                throw new UserException(_loc.get(\"dup-oid-assign\",\n-                    sm.getObjectId(), Exceptions.toString\n-                    (sm.getManagedInstance()))).setFailedObject\n-                    (sm.getManagedInstance()).setFatal(true);\n+            try {\n+                _isSerializing = true;\n+                out.writeObject(_factory.getPoolKey());\n+                out.defaultWriteObject();\n+            } finally {\n+                _isSerializing = false;\n             }\n+        } finally {\n+            unlock();\n         }\n+    }\n \n-        /**\n-         * Return a copy of all cached persistent objects.\n-         */\n-        public Collection copy() {\n-            // proxies not included here because the state manager is always\n-            // present in other caches too\n-\n-            int size = _main.size();\n-            if (_conflicts != null)\n-                size += _conflicts.size();\n-            if (_news != null)\n-                size += _news.size();\n-            if (_embeds != null)\n-                size += _embeds.size();\n-            if (size == 0)\n-                return Collections.EMPTY_LIST;\n-\n-            List copy = new ArrayList(size);\n-            for (Iterator itr = _main.values().iterator(); itr.hasNext();)\n-                copy.add(itr.next());\n-            if (_conflicts != null && !_conflicts.isEmpty())\n-                for (Iterator itr = _conflicts.values().iterator();\n-                    itr.hasNext();)\n-                    copy.add(itr.next());\n-            if (_news != null && !_news.isEmpty())\n-                for (Iterator itr = _news.values().iterator(); itr.hasNext();)\n-                    copy.add(itr.next());\n-            if (_embeds != null && !_embeds.isEmpty())\n-                for (Iterator itr = _embeds.iterator(); itr.hasNext();)\n-                    copy.add(itr.next());\n-            return copy;\n-        }\n+    private void readObject(ObjectInputStream in)\n+        throws ClassNotFoundException, IOException {\n+        Object factoryKey = in.readObject();\n+        AbstractBrokerFactory factory =\n+            AbstractBrokerFactory.getPooledFactoryForKey(factoryKey);\n \n-        /**\n-         * Clear the cache.\n-         */\n-        public void clear() {\n-            _main = newManagedObjectCache();\n-            if (_conflicts != null)\n-                _conflicts = null;\n-            if (_news != null)\n-                _news = null;\n-            if (_embeds != null)\n-                _embeds = null;\n-            if (_untracked != null)\n-                _untracked = null;\n-        }\n+        // this needs to happen before defaultReadObject so that it's\n+        // available for calls to broker.getConfiguration() during\n+        // StateManager deserialization\n+        _conf = factory.getConfiguration();\n+        \n+        in.defaultReadObject();\n+        factory.initializeBroker(_managed, _connRetainMode, this, true);\n \n-        /**\n-         * Clear new instances without permanent oids.\n-         */\n-        public void clearNew() {\n-            if (_news != null)\n-                _news = null;\n-        }\n+        // re-initialize the lock if needed.\n+        setMultithreaded(_multithreaded);\n \n-        private void dirtyCheck() {\n-            if (_untracked == null)\n-                return;\n+        if (isActive() && _runtime instanceof LocalManagedRuntime)\n+            ((LocalManagedRuntime) _runtime).begin();\n+    }\n \n-            for (Iterator iter = _untracked.iterator(); iter.hasNext(); )\n-                ((StateManagerImpl) iter.next()).dirtyCheck();\n-        }\n+    /**\n+     * Whether or not this broker is in the midst of being serialized.\n+     *\n+     * @since 1.1.0 \n+     */\n+    boolean isSerializing() {\n+        return _isSerializing;\n     }\n \n     /**\n      * Transactional cache that holds soft refs to clean instances.\n      */\n-    private static class TransactionalCache\n-        implements Set {\n+    static class TransactionalCache\n+        implements Set, Serializable {\n \n         private final boolean _orderDirty;\n         private Set _dirty = null;"},{"sha":"51fc74de7e785bae8b940863b20de5d602dc154f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -171,8 +171,7 @@ public Object attach(AttachManager manager, Object toAttach,\n                 BitSet toLoad = (BitSet) fields.clone();\n                 toLoad.andNot(sm.getLoaded()); // skip already loaded fields\n                 if (toLoad.length() > 0)\n-                    sm.loadFields(toLoad, null, LockLevels.LOCK_NONE, null,\n-                        false);\n+                    sm.loadFields(toLoad, null, LockLevels.LOCK_NONE, null);\n                 //### we should calculate lock level above\n             }\n             Object version = state[offset];"},{"sha":"aafa6db890fb9804b20b6e43f582a070af16baf6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -145,7 +145,7 @@ public Object attach(AttachManager manager, Object toAttach,\n                 }\n             }\n             FetchConfiguration fc = broker.getFetchConfiguration();\n-            sm.loadFields(load, fc, fc.getWriteLockLevel(), null, true);\n+            sm.loadFields(load, fc, fc.getWriteLockLevel(), null);\n         }        \n         Object origVersion = sm.getVersion();\n         sm.setVersion(_version);\n@@ -698,7 +698,7 @@ public OpenJPAStateManager getOwner() {\n         throw new UnsupportedOperationException();\n     }\n \n-    public ValueMetaData getOwnerMetaData() {\n+    public int getOwnerIndex() {\n         throw new UnsupportedOperationException();\n     }\n "},{"sha":"174e70dcd5b856075a2df8d32df43fb3bca94971","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -88,8 +88,8 @@ public OpenJPAStateManager getOwner() {\n         return null;\n     }\n \n-    public ValueMetaData getOwnerMetaData() {\n-        return null;\n+    public int getOwnerIndex() {\n+        throw new UnsupportedOperationException();\n     }\n \n     public boolean isEmbedded() {"},{"sha":"698d65ebabae4a1a3ca05717df09febf196e6bb7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java","status":"added","additions":309,"deletions":0,"changes":309,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -0,0 +1,309 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.io.Serializable;\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.ReferenceHashSet;\r\n+import org.apache.openjpa.util.Exceptions;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Cache of managed objects. Must be static for serialization reasons.\r\n+ */\r\n+class ManagedCache implements Serializable {\r\n+\r\n+    private static final Localizer _loc =\r\n+        Localizer.forPackage(ManagedCache.class);\r\n+\r\n+    private Map _main; // oid -> sm\r\n+    private Map _conflicts = null; // conflict oid -> new sm\r\n+    private Map _news = null; // tmp id -> new sm\r\n+    private Collection _embeds = null; // embedded/non-persistent sms\r\n+    private Collection _untracked = null; // hard refs to untracked sms\r\n+    private BrokerImpl broker;\r\n+\r\n+    /**\r\n+     * Constructor; supply primary cache map.\r\n+     */\r\n+    ManagedCache(BrokerImpl broker) {\r\n+        this.broker = broker;\r\n+        _main = broker.newManagedObjectCache();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the instance for the given oid, optionally allowing\r\n+     * new instances.\r\n+     */\r\n+    public StateManagerImpl getById(Object oid, boolean allowNew) {\r\n+        if (oid == null)\r\n+            return null;\r\n+\r\n+        // check main cache for oid\r\n+        StateManagerImpl sm = (StateManagerImpl) _main.get(oid);\r\n+        StateManagerImpl sm2;\r\n+        if (sm != null) {\r\n+            // if it's a new instance, we know it's the only match, because\r\n+            // other pers instances override new instances in _cache\r\n+            if (sm.isNew())\r\n+                return (allowNew) ? sm : null;\r\n+            if (!allowNew || !sm.isDeleted())\r\n+                return sm;\r\n+\r\n+            // sm is deleted; check conflict cache\r\n+            if (_conflicts != null) {\r\n+                sm2 = (StateManagerImpl) _conflicts.get(oid);\r\n+                if (sm2 != null)\r\n+                    return sm2;\r\n+            }\r\n+        }\r\n+\r\n+        // at this point sm is null or deleted; check the new cache for\r\n+        // any matches. this allows us to match app id objects to new\r\n+        // instances without permanant oids\r\n+        if (allowNew && _news != null && !_news.isEmpty()) {\r\n+            sm2 = (StateManagerImpl) _news.get(oid);\r\n+            if (sm2 != null)\r\n+                return sm2;\r\n+        }\r\n+        return sm;\r\n+    }\r\n+\r\n+    /**\r\n+     * Call this method when a new state manager initializes itself.\r\n+     */\r\n+    public void add(StateManagerImpl sm) {\r\n+        if (!sm.isIntercepting()) {\r\n+            if (_untracked == null)\r\n+                _untracked = new HashSet();\r\n+            _untracked.add(sm);\r\n+        }\r\n+\r\n+        if (!sm.isPersistent() || sm.isEmbedded()) {\r\n+            if (_embeds == null)\r\n+                _embeds = new ReferenceHashSet(ReferenceHashSet.WEAK);\r\n+            _embeds.add(sm);\r\n+            return;\r\n+        }\r\n+\r\n+        // initializing new instance; put in new cache because won't have\r\n+        // permanent oid yet\r\n+        if (sm.isNew()) {\r\n+            if (_news == null)\r\n+                _news = new HashMap();\r\n+            _news.put(sm.getId(), sm);\r\n+            return;\r\n+        }\r\n+\r\n+        // initializing persistent instance; put in main cache\r\n+        StateManagerImpl orig = (StateManagerImpl) _main.put\r\n+            (sm.getObjectId(), sm);\r\n+        if (orig != null) {\r\n+            _main.put(sm.getObjectId(), orig);\r\n+            throw new UserException(_loc.get(\"dup-load\", sm.getObjectId(),\r\n+                Exceptions.toString(orig.getManagedInstance())))\r\n+                .setFailedObject(sm.getManagedInstance());\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove the given state manager from the cache when it transitions\r\n+     * to transient.\r\n+     */\r\n+    public void remove(Object id, StateManagerImpl sm) {\r\n+        // if it has a permanent oid, remove from main / conflict cache,\r\n+        // else remove from embedded/nontrans cache, and if not there\r\n+        // remove from new cache\r\n+        Object orig;\r\n+        if (sm.getObjectId() != null) {\r\n+            orig = _main.remove(id);\r\n+            if (orig != sm) {\r\n+                if (orig != null)\r\n+                    _main.put(id, orig); // put back\r\n+                if (_conflicts != null) {\r\n+                    orig = _conflicts.remove(id);\r\n+                    if (orig != null && orig != sm)\r\n+                        _conflicts.put(id, orig); // put back\r\n+                }\r\n+            }\r\n+        } else if ((_embeds == null || !_embeds.remove(sm))\r\n+            && _news != null) {\r\n+            orig = _news.remove(id);\r\n+            if (orig != null && orig != sm)\r\n+                _news.put(id, orig); // put back\r\n+        }\r\n+\r\n+        if (_untracked != null)\r\n+            _untracked.remove(sm);\r\n+    }\r\n+\r\n+    /**\r\n+     * An embedded or nonpersistent managed instance has been persisted.\r\n+     */\r\n+    public void persist(StateManagerImpl sm) {\r\n+        if (_embeds != null)\r\n+            _embeds.remove(sm);\r\n+    }\r\n+\r\n+    /**\r\n+     * A new instance has just been assigned a permanent oid.\r\n+     */\r\n+    public void assignObjectId(Object id, StateManagerImpl sm) {\r\n+        // if assigning oid, remove from new cache and put in primary; may\r\n+        // not be in new cache if another new instance had same id\r\n+        StateManagerImpl orig = null;\r\n+        if (_news != null) {\r\n+            orig = (StateManagerImpl) _news.remove(id);\r\n+            if (orig != null && orig != sm)\r\n+                _news.put(id, orig); // put back\r\n+        }\r\n+\r\n+        // put in main cache, but make sure we don't replace another\r\n+        // instance with the same oid\r\n+        orig = (StateManagerImpl) _main.put(sm.getObjectId(), sm);\r\n+        if (orig != null) {\r\n+            _main.put(sm.getObjectId(), orig);\r\n+            if (!orig.isDeleted())\r\n+                throw new UserException(_loc.get(\"dup-oid-assign\",\r\n+                    sm.getObjectId(),\r\n+                    Exceptions.toString(sm.getManagedInstance())))\r\n+                    .setFailedObject(sm.getManagedInstance());\r\n+\r\n+            // same oid as deleted instance; put in conflict cache\r\n+            if (_conflicts == null)\r\n+                _conflicts = new HashMap();\r\n+            _conflicts.put(sm.getObjectId(), sm);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * A new instance has committed; recache under permanent oid.\r\n+     */\r\n+    public void commitNew(Object id, StateManagerImpl sm) {\r\n+        // if the id didn't change, the instance was already assigned an\r\n+        // id, but it could have been in conflict cache\r\n+        StateManagerImpl orig;\r\n+        if (sm.getObjectId() == id) {\r\n+            orig = (_conflicts == null) ? null\r\n+                : (StateManagerImpl) _conflicts.remove(id);\r\n+            if (orig == sm) {\r\n+                orig = (StateManagerImpl) _main.put(id, sm);\r\n+                if (orig != null && !orig.isDeleted()) {\r\n+                    _main.put(sm.getObjectId(), orig);\r\n+                    throw new UserException(_loc.get(\"dup-oid-assign\",\r\n+                        sm.getObjectId(), Exceptions.toString(\r\n+                            sm.getManagedInstance())))\r\n+                        .setFailedObject(sm.getManagedInstance())\r\n+                        .setFatal(true);\r\n+                }\r\n+            }\r\n+            return;\r\n+        }\r\n+\r\n+        // oid changed, so it must previously have been a new instance\r\n+        // without an assigned oid.  remove it from the new cache; ok if\r\n+        // we end up removing another instance with same id\r\n+        if (_news != null)\r\n+            _news.remove(id);\r\n+\r\n+        // and put into main cache now that id is asssigned\r\n+        orig = (StateManagerImpl) _main.put(sm.getObjectId(), sm);\r\n+        if (orig != null && orig != sm && !orig.isDeleted()) {\r\n+            // put back orig and throw error\r\n+            _main.put(sm.getObjectId(), orig);\r\n+            throw new UserException(_loc.get(\"dup-oid-assign\",\r\n+                sm.getObjectId(), Exceptions.toString(sm.getManagedInstance())))\r\n+                    .setFailedObject(sm.getManagedInstance()).setFatal(true);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a copy of all cached persistent objects.\r\n+     */\r\n+    public Collection copy() {\r\n+        // proxies not included here because the state manager is always\r\n+        // present in other caches too\r\n+\r\n+        int size = _main.size();\r\n+        if (_conflicts != null)\r\n+            size += _conflicts.size();\r\n+        if (_news != null)\r\n+            size += _news.size();\r\n+        if (_embeds != null)\r\n+            size += _embeds.size();\r\n+        if (size == 0)\r\n+            return Collections.EMPTY_LIST;\r\n+\r\n+        List copy = new ArrayList(size);\r\n+        for (Iterator itr = _main.values().iterator(); itr.hasNext();)\r\n+            copy.add(itr.next());\r\n+        if (_conflicts != null && !_conflicts.isEmpty())\r\n+            for (Iterator itr = _conflicts.values().iterator();\r\n+                itr.hasNext();)\r\n+                copy.add(itr.next());\r\n+        if (_news != null && !_news.isEmpty())\r\n+            for (Iterator itr = _news.values().iterator(); itr.hasNext();)\r\n+                copy.add(itr.next());\r\n+        if (_embeds != null && !_embeds.isEmpty())\r\n+            for (Iterator itr = _embeds.iterator(); itr.hasNext();)\r\n+                copy.add(itr.next());\r\n+        return copy;\r\n+    }\r\n+\r\n+    /**\r\n+     * Clear the cache.\r\n+     */\r\n+    public void clear() {\r\n+        _main = broker.newManagedObjectCache();\r\n+        if (_conflicts != null)\r\n+            _conflicts = null;\r\n+        if (_news != null)\r\n+            _news = null;\r\n+        if (_embeds != null)\r\n+            _embeds = null;\r\n+        if (_untracked != null)\r\n+            _untracked = null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Clear new instances without permanent oids.\r\n+     */\r\n+    public void clearNew() {\r\n+        if (_news != null)\r\n+            _news = null;\r\n+    }\r\n+\r\n+    void dirtyCheck() {\r\n+        if (_untracked == null)\r\n+            return;\r\n+\r\n+        for (Iterator iter = _untracked.iterator(); iter.hasNext(); )\r\n+            ((StateManagerImpl) iter.next()).dirtyCheck();\r\n+    }\r\n+}\r"},{"sha":"99cdcaab6642a673675a9f86ae2f80a4089efbca","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -309,8 +309,8 @@ public OpenJPAStateManager getOwner() {\n         return _owner;\n     }\n \n-    public ValueMetaData getOwnerMetaData() {\n-        return _vmd;\n+    public int getOwnerIndex() {\n+        return _vmd.getFieldMetaData().getIndex();\n     }\n \n     public boolean isEmbedded() {"},{"sha":"3effd27e0d3a956e8d18b437ca4ddf9a6e7d5c08","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.openjpa.kernel;\n \n+import java.io.Serializable;\n import java.util.Collection;\n import java.util.HashMap;\n import java.util.Iterator;\n@@ -30,7 +31,7 @@\n  * @author Steve Kim\n  * @since 0.3.4\n  */\n-public class OpenJPASavepoint {\n+public class OpenJPASavepoint implements Serializable {\n \n     private final Broker _broker;\n     private final String _name;"},{"sha":"a6f44dc4386223b86642d2b36933eadb728e61c9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java","status":"modified","additions":4,"deletions":2,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -102,9 +102,11 @@\n     public OpenJPAStateManager getOwner();\n \n     /**\n-     * Return the owning value.\n+     * Return the owning value's field index\n+     *\n+     * @since 1.1.0\n      */\n-    public ValueMetaData getOwnerMetaData();\n+    public int getOwnerIndex();\n \n     /**\n      * Return true if this instance has an owner, meaning it is an embedded"},{"sha":"9a8b0f45b1c4911b72dbe6238efacf964d297f53","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","status":"modified","additions":23,"deletions":8,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -18,13 +18,16 @@\n  */\n package org.apache.openjpa.kernel;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n import java.util.BitSet;\n import java.util.Collection;\n import java.util.Date;\n import java.util.Map;\n \n import org.apache.openjpa.enhance.PersistenceCapable;\n-import org.apache.openjpa.enhance.Reflection;\n import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.util.ProxyManager;\n@@ -35,13 +38,14 @@\n  * @author Abe White\n  */\n public class SaveFieldManager\n-    extends ClearFieldManager {\n+    extends ClearFieldManager\n+    implements Serializable {\n \n     private final StateManagerImpl _sm;\n     private final BitSet _unloaded;\n     private BitSet _saved = null;\n     private int[] _copyField = null;\n-    private PersistenceCapable _state = null;\n+    private transient PersistenceCapable _state = null;\n \n     // used to track field value during store/fetch cycle\n     private Object _field = null;\n@@ -140,7 +144,7 @@ public boolean saveField(int field) {\n         if (_copyField == null)\n             _copyField = new int[1];\n         _copyField[0] = field;\n-        _state.pcCopyFields(_sm.getPersistenceCapable(), _copyField);\n+        getState().pcCopyFields(_sm.getPersistenceCapable(), _copyField);\n         return false;\n     }\n \n@@ -164,7 +168,7 @@ public boolean restoreField(int field) {\n         if (_copyField == null)\n             _copyField = new int[1];\n         _copyField[0] = field;\n-        _sm.getPersistenceCapable().pcCopyFields(_state, _copyField);\n+        _sm.getPersistenceCapable().pcCopyFields(getState(), _copyField);\n         return false;\n     }\n \n@@ -177,12 +181,12 @@ public boolean isFieldEqual(int field, Object current) {\n         // if the field is not available, assume that it has changed.\n         if (_saved == null || !_saved.get(field))\n             return false;\n-        if (!(_state.pcGetStateManager() instanceof StateManagerImpl))\n+        if (!(getState().pcGetStateManager() instanceof StateManagerImpl))\n             return false;\n \n-        StateManagerImpl sm = (StateManagerImpl) _state.pcGetStateManager();\n+        StateManagerImpl sm = (StateManagerImpl) getState().pcGetStateManager();\n         SingleFieldManager single = new SingleFieldManager(sm, sm.getBroker());\n-        sm.provideField(_state, single, field);\n+        sm.provideField(getState(), single, field);\n         Object old = single.fetchObjectField(field);\n         return current == old || current != null && current.equals(old);\n     }\n@@ -227,4 +231,15 @@ public void storeObjectField(int field, Object curVal) {\n             _saved.clear(field);\n \t\t}\n \t}\n+\n+    private void writeObject(ObjectOutputStream oos) throws IOException {\n+        oos.defaultWriteObject();\n+        _sm.writePC(oos, _state);\n+    }\n+\n+    private void readObject(ObjectInputStream ois)\n+        throws IOException, ClassNotFoundException {\n+        ois.defaultReadObject();\n+        _state = _sm.readPC(ois);\n+    }\n }"},{"sha":"b68890f6b4c2d5fe6509c4fa4625a5efc8042a88","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java","status":"modified","additions":18,"deletions":2,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -18,6 +18,10 @@\n  */\n package org.apache.openjpa.kernel;\n \n+import java.io.Serializable;\n+import java.io.ObjectOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n import java.util.BitSet;\n import java.util.Collection;\n import java.util.Date;\n@@ -37,7 +41,8 @@\n  * @since 0.3.4\n  */\n class SavepointFieldManager\n-    extends ClearFieldManager {\n+    extends ClearFieldManager\n+    implements Serializable {\n \n     private static final Localizer _loc = Localizer.forPackage\n         (SavepointFieldManager.class);\n@@ -47,7 +52,7 @@\n     private final BitSet _dirty;\n     private final BitSet _flush;\n     private final PCState _state;\n-    private PersistenceCapable _copy;\n+    private transient PersistenceCapable _copy;\n \n     private final Object _version;\n     private final Object _loadVersion;\n@@ -227,4 +232,15 @@ public void storeObjectField(int field, Object curVal) {\n         if (curVal != null && _field == null)\n             throw new InternalException(_loc.get(\"no-savepoint-copy\", fmd));\n \t}\n+\n+    private void writeObject(ObjectOutputStream oos) throws IOException {\n+        oos.defaultWriteObject();\n+        _sm.writePC(oos, _copy);\n+    }\n+\n+    private void readObject(ObjectInputStream ois)\n+        throws IOException, ClassNotFoundException {\n+        ois.defaultReadObject();\n+        _copy = _sm.readPC(ois);\n+    }\n }"},{"sha":"d303c0b456afd1f8a1e3fdb62a3408c61a804285","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -20,6 +20,7 @@\n \n import java.io.IOException;\n import java.io.ObjectOutput;\n+import java.io.Serializable;\n import java.sql.Timestamp;\n import java.util.Arrays;\n import java.util.Calendar;\n@@ -50,7 +51,8 @@\n  * @author Abe White\n  */\n class SingleFieldManager\n-    extends TransferFieldManager {\n+    extends TransferFieldManager\n+    implements Serializable {\n \n     private static final Localizer _loc = Localizer.forPackage\n         (SingleFieldManager.class);\n@@ -235,7 +237,7 @@ private void releaseEmbedded(ValueMetaData vmd, Object obj) {\n \n         StateManagerImpl sm = _broker.getStateManagerImpl(obj, false);\n         if (sm != null && sm.getOwner() == _sm\n-            && sm.getOwnerMetaData() == vmd)\n+            && sm.getOwnerIndex() == vmd.getFieldMetaData().getIndex())\n             sm.release(true);\n     }\n \n@@ -380,7 +382,8 @@ void delete(ValueMetaData vmd, Object obj, OpCallbacks call) {\n         // delete if unknowned or this isn't an embedded field or if owned by us\n         StateManagerImpl sm = _broker.getStateManagerImpl(obj, false);\n         if (sm != null && (sm.getOwner() == null || !vmd.isEmbeddedPC()\n-            || (sm.getOwner() == _sm && sm.getOwnerMetaData() == vmd)))\n+            || (sm.getOwner() == _sm\n+            && sm.getOwnerIndex() == vmd.getFieldMetaData().getIndex())))\n             _broker.delete(sm.getManagedInstance(), sm, call);\n     }\n "},{"sha":"c11fa18f66bb86f8e9847caa36f52a0afa105519","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":89,"deletions":15,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -19,7 +19,11 @@\n package org.apache.openjpa.kernel;\n \n import java.io.IOException;\n+import java.io.NotSerializableException;\n+import java.io.ObjectInputStream;\n import java.io.ObjectOutput;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n import java.lang.reflect.Modifier;\n import java.util.ArrayList;\n import java.util.Arrays;\n@@ -77,7 +81,7 @@\n  * @author Abe White\n  */\n public class StateManagerImpl\n-    implements OpenJPAStateManager {\n+    implements OpenJPAStateManager, Serializable {\n \n     public static final int LOAD_FGS = 0;\n     public static final int LOAD_ALL = 1;\n@@ -105,8 +109,8 @@\n         (StateManagerImpl.class);\n \n     // information about the instance\n-    private PersistenceCapable _pc = null;\n-    private ClassMetaData _meta = null;\n+    private transient PersistenceCapable _pc = null;\n+    private transient ClassMetaData _meta = null;\n     private BitSet _loaded = null;\n     private BitSet _dirty = null;\n     private BitSet _flush = null;\n@@ -121,7 +125,7 @@\n     private Object _oid = null;\n \n     // the managing persistence manager and lifecycle state\n-    private final BrokerImpl _broker;\n+    private transient BrokerImpl _broker; // this is serialized specially\n     private PCState _state = PCState.TRANSIENT;\n \n     // the current and last loaded version indicators, and the lock object\n@@ -142,7 +146,7 @@\n \n     // information about the owner of this instance, if it is embedded\n     private StateManagerImpl _owner = null;\n-    private ValueMetaData _ownerMeta = null;\n+    private int _ownerIndex = -1;\n \n     /**\n      * Constructor; supply id, type metadata, and owning persistence manager.\n@@ -163,7 +167,7 @@ protected StateManagerImpl(Object id, ClassMetaData meta,\n      */\n     void setOwner(StateManagerImpl owner, ValueMetaData ownerMeta) {\n         _owner = owner;\n-        _ownerMeta = ownerMeta;\n+        _ownerIndex = ownerMeta.getFieldMetaData().getIndex();\n     }\n \n     /**\n@@ -371,7 +375,7 @@ protected boolean load(FetchConfiguration fetch, int loadMode,\n         // care of checking if the DFG is loaded, making sure version info\n         // is loaded, etc\n         int lockLevel = calculateLockLevel(active, forWrite, fetch);\n-        boolean ret = loadFields(fields, fetch, lockLevel, sdata, forWrite);\n+        boolean ret = loadFields(fields, fetch, lockLevel, sdata);\n         obtainLocks(active, forWrite, lockLevel, fetch, sdata);\n         return ret;\n     }\n@@ -395,8 +399,8 @@ public OpenJPAStateManager getOwner() {\n         return _owner;\n     }\n \n-    public ValueMetaData getOwnerMetaData() {\n-        return _ownerMeta;\n+    public int getOwnerIndex() {\n+        return _ownerIndex;\n     }\n \n     public boolean isEmbedded() {\n@@ -594,9 +598,9 @@ private boolean assignField(int field, boolean preFlushing) {\n         \n         // Throw exception if field already has a value assigned.\n         // @GeneratedValue overrides POJO initial values and setter methods\n-        if (!isDefaultValue(field) && !fmd.isValueGenerated())\n+        if (!fmd.isValueGenerated() && !isDefaultValue(field))\n             throw new InvalidStateException(_loc.get(\n-                    \"existing-value-override-excep\", fmd.getFullName(false)));\n+                \"existing-value-override-excep\", fmd.getFullName(false)));\n \n         // for primary key fields, assign the object id and recache so that\n         // to the user, so it looks like the oid always matches the pk fields\n@@ -1318,7 +1322,16 @@ private void releaseLocks() {\n     // Implementation of StateManager interface\n     ////////////////////////////////////////////\n \n+    /**\n+     * @return whether or not unloaded fields should be closed.\n+     */\n     public boolean serializing() {\n+        // if the broker is in the midst of a serialization, then no special\n+        // handling should be performed on the instance, and no subsequent\n+        // load should happen\n+        if (_broker.isSerializing())\n+            return false;\n+\n         try {\n             if (_meta.isDetachable())\n                 return DetachManager.preSerialize(this);\n@@ -1510,8 +1523,7 @@ private Boolean dirty(int field, Boolean mutate, boolean loadFetchGroup) {\n \n             if (isEmbedded()) {\n                 // notify owner of change\n-                _owner.dirty(_ownerMeta.getFieldMetaData().getIndex(),\n-                    Boolean.TRUE, loadFetchGroup);\n+                _owner.dirty(_ownerIndex, Boolean.TRUE, loadFetchGroup);\n             }\n \n             // is this a direct mutation of an sco field?\n@@ -2862,7 +2874,7 @@ void cascadePersist(OpCallbacks call) {\n      * Return true if any data is loaded, false otherwise.\n      */\n     boolean loadFields(BitSet fields, FetchConfiguration fetch, int lockLevel,\n-        Object sdata, boolean forWrite) {\n+        Object sdata) {\n         // can't load version field from store\n         if (fields != null) {\n             FieldMetaData vfield = _meta.getVersionField();\n@@ -2956,7 +2968,7 @@ protected void loadField(int field, int lockLevel, boolean forWrite,\n         // call this method even if there are no unloaded fields; loadFields\n         // takes care of things like loading version info and setting PC flags\n         try {\n-            loadFields(fields, fetch, lockLevel, null, forWrite);\n+            loadFields(fields, fetch, lockLevel, null);\n         } finally {\n             if (lfgAdded)\n                 fetch.removeFetchGroup(lfg);\n@@ -3154,4 +3166,66 @@ protected void unlock ()\n \t\t// manager lock and broker lock being obtained in different orders\n \t\t_broker.unlock ();\n \t}\n+\n+    private void writeObject(ObjectOutputStream oos) throws IOException {\n+        oos.writeObject(_broker);\n+        oos.defaultWriteObject();\n+        oos.writeObject(_meta.getDescribedType());\n+        writePC(oos, _pc);\n+    }\n+\n+    /**\n+     * Write <code>pc</code> to <code>oos</code>, handling internal-form\n+     * serialization. <code>pc</code> must be of the same type that this\n+     * state manager manages.\n+     *\n+     * @since 1.1.0\n+     */\n+    void writePC(ObjectOutputStream oos, PersistenceCapable pc)\n+        throws IOException {\n+        if (!Serializable.class.isAssignableFrom(_meta.getDescribedType()))\n+            throw new NotSerializableException(\n+                _meta.getDescribedType().getName());\n+\n+        oos.writeObject(pc);\n+    }\n+\n+    private void readObject(ObjectInputStream in)\n+        throws IOException, ClassNotFoundException {\n+        _broker = (BrokerImpl) in.readObject();\n+        in.defaultReadObject();\n+\n+        // we need to store the class before the pc instance so that we can\n+        // create _meta before calling readPC(), which relies on _meta being\n+        // non-null when reconstituting ReflectingPC instances. Sadly, this\n+        // penalizes the serialization footprint of non-ReflectingPC SMs also.\n+        Class managedType = (Class) in.readObject();\n+        _meta = _broker.getConfiguration().getMetaDataRepositoryInstance()\n+            .getMetaData(managedType, null, true);\n+\n+        _pc = readPC(in);\n+    }\n+\n+    /**\n+     * Converts the deserialized <code>o</code> to a {@link PersistenceCapable}\n+     * instance appropriate for storing in <code>_pc</code>.\n+     *\n+     * @since 1.1.0\n+     */\n+    PersistenceCapable readPC(ObjectInputStream in)\n+        throws ClassNotFoundException, IOException {\n+        Object o = in.readObject();\n+\n+        if (o == null)\n+            return null;\n+\n+        PersistenceCapable pc;\n+        if (!(o instanceof PersistenceCapable))\n+            pc = ImplHelper.toPersistenceCapable(o, this);\n+        else\n+            pc = (PersistenceCapable) o;\n+\n+        pc.pcReplaceStateManager(this);\n+        return pc;\n+    }\n }"},{"sha":"d56d783b728eb45963af9c4a9946f14d308345b3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneralException.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneralException.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneralException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneralException.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -47,6 +47,10 @@ public GeneralException(Message msg, Throwable cause) {\n         super(msg, cause);\n     }\n \n+    public GeneralException(String msg, Throwable cause) {\n+        super(msg, cause);\n+    }\n+\n     public int getType() {\n         return GENERAL;\n     }"},{"sha":"74acea0c97da07e764ce03c52d833804676f384f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -304,6 +304,11 @@ else if (ctx instanceof StateManager\n         }\n     }\n \n+    public static void registerPersistenceCapable(\n+        ReflectingPersistenceCapable pc) {\n+        _unenhancedInstanceMap.put(pc.getManagedInstance(), pc);\n+    }\n+\n     /**\n      * @return the user-visible representation of <code>o</code>.\n      * @since 1.0.0"},{"sha":"1cc80eecbef881fa1e691f98ddf65a002359db4e","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","status":"modified","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -390,3 +390,9 @@ multi-threaded-access: Multiple concurrent threads attempted to access a \\\n     openjpa.Multithreaded property to true to override the default behavior.\n no-saved-fields: No state snapshot is available for \"{0}\", but this instance \\\n     uses state-comparison for dirty detection.\n+cant-serialize-flushed-broker: Serialization not allowed once a broker has \\\n+    been flushed.\n+cant-serialize-pessimistic-broker: Serialization not allowed for brokers with \\\n+    an active datastore (pessimistic) transaction.\n+cant-serialize-connected-broker: Serialization not allowed for brokers with \\\n+    an active connection to the database.\n\\ No newline at end of file"},{"sha":"f337f2628d72b402f8f183b612fa65f47a9ee77d","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -0,0 +1,32 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import junit.framework.TestCase;\r\n+\r\n+public class TestPCSubclassNameConversion\r\n+    extends TestCase {\r\n+\r\n+    public void testPCSubclassNameConversion() {\r\n+        String name = PCEnhancer.toPCSubclassName(Object.class);\r\n+        assertTrue(PCEnhancer.isPCSubclassName(name));\r\n+        assertEquals(Object.class.getName(),\r\n+            PCEnhancer.toManagedTypeName(name));\r\n+    }\r\n+}\n\\ No newline at end of file"},{"sha":"4816be519d40e3876c129e3975b4233a4aa2f58f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java","status":"modified","additions":6,"deletions":4,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -648,13 +648,15 @@ public void fromProperties(Map map) {\n         Configurations.removeProperty(\"properties\", remaining);\n         \n         // now warn if there are any remaining properties that there\n-        // is an unhandled prop\n+        // is an unhandled prop, and remove the unknown properties\n         Map.Entry entry;\n         for (Iterator itr = remaining.entrySet().iterator(); itr.hasNext();) {\n             entry = (Map.Entry) itr.next();\n-            if (entry.getKey() != null)\n-                warnInvalidProperty((String) entry.getKey());\n-            ser &= entry.getValue() instanceof Serializable;\n+            Object key = entry.getKey();\n+            if (key != null) {\n+                warnInvalidProperty((String) key);\n+                map.remove(key);\n+            }\n         }\n \n         // cache properties"},{"sha":"9c5642b724c4775ac55d40ed973cac013ede265e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceHashSet.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceHashSet.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceHashSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ReferenceHashSet.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -49,7 +49,11 @@\n      */\n     public static final int WEAK = 2;\n \n-    private static final Object DUMMY_VAL = new Object();\n+    private static final Object DUMMY_VAL = new Serializable() {\n+        public String toString() {\n+            return ReferenceHashSet.class.getName() + \".DUMMY_VAL\";\n+        }\n+    };\n \n     private final Set _set;\n "},{"sha":"05f4cc17bcbd9c00ab6d259a938eef5d00260fbe","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractConcurrentEventManager.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractConcurrentEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractConcurrentEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractConcurrentEventManager.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.openjpa.lib.util.concurrent;\n \n+import java.io.Serializable;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Iterator;\n@@ -35,7 +36,8 @@\n  *\n  * @author Abe White\n  */\n-public abstract class AbstractConcurrentEventManager implements EventManager {\n+public abstract class AbstractConcurrentEventManager\n+    implements EventManager, Serializable {\n \n     private static Exception[] EMPTY_EXCEPTIONS = new Exception[0];\n "},{"sha":"028f34ffdbea93b567c501bb7e62c622f6639359","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -102,6 +102,7 @@ public void testPCRegistry() {\n         PersistenceCapable pc = PCRegistry.newInstance(\r\n             getUnenhancedClass(), null, false);\r\n         assertNotNull(pc);\r\n+        assertEquals(pc.getClass(), PCRegistry.getPCType(getUnenhancedClass()));\r\n     }\r\n \r\n     public void testClearingOnSubtypeInstance() {\r"},{"sha":"7d8d44b02ae7ac654b5ab2ec197c5f3d6489d793","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java","status":"added","additions":446,"deletions":0,"changes":446,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -0,0 +1,446 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.ByteArrayOutputStream;\r\n+import java.io.IOException;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.Serializable;\r\n+import java.util.HashMap;\r\n+import java.util.Map;\r\n+import javax.persistence.EntityManager;\r\n+\r\n+import org.apache.openjpa.event.AbstractLifecycleListener;\r\n+import org.apache.openjpa.event.AbstractTransactionListener;\r\n+import org.apache.openjpa.event.LifecycleEvent;\r\n+import org.apache.openjpa.event.TransactionEvent;\r\n+import org.apache.openjpa.persistence.InvalidStateException;\r\n+import org.apache.openjpa.persistence.JPAFacadeHelper;\r\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\r\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactory;\r\n+import org.apache.openjpa.persistence.jdbc.JDBCFetchPlan;\r\n+import org.apache.openjpa.persistence.jdbc.JoinSyntax;\r\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n+\r\n+/*\r\n+ * To test:\r\n+ *  - managed transactions\r\n+ *  - converting non-enhanced classes to enhanced subclasses\r\n+ *    (maybe an ugly ThreadLocal, maybe through PCData?)\r\n+ */\r\n+public abstract class AbstractBrokerSerializationTest<T>\r\n+    extends SingleEMFTestCase {\r\n+\r\n+    private static LifeListener deserializedLifeListener;\r\n+    private static int testGlobalRefreshCount = 0;\r\n+\r\n+    private static TxListener deserializedTxListener;\r\n+    private static int testGlobalBeginCount = 0;\r\n+\r\n+\r\n+    private Object id;\r\n+\r\n+    public void setUp() {\r\n+        testGlobalRefreshCount = 0;\r\n+        deserializedLifeListener = null;\r\n+        testGlobalBeginCount = 0;\r\n+        deserializedTxListener = null;\r\n+\r\n+        setUp(getManagedType(), getSecondaryType(), CLEAR_TABLES,\r\n+            \"openjpa.EntityManagerFactoryPool\", \"true\");\r\n+        \r\n+        T e = newManagedInstance();\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        em.getTransaction().begin();\r\n+        em.persist(e);\r\n+        em.getTransaction().commit();\r\n+        id = em.getObjectId(e);\r\n+        em.close();\r\n+    }\r\n+\r\n+    @Override\r\n+    public void tearDown() throws Exception {\r\n+        super.tearDown();\r\n+        testGlobalRefreshCount = 0;\r\n+        deserializedLifeListener = null;\r\n+        testGlobalBeginCount = 0;\r\n+        deserializedTxListener = null;\r\n+    }\r\n+\r\n+    public void testEmptyBrokerSerialization() {\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        OpenJPAEntityManager em2 = deserializeEM(serialize(em));\r\n+\r\n+        assertTrue(em != em2);\r\n+        assertTrue(\r\n+            JPAFacadeHelper.toBroker(em) != JPAFacadeHelper.toBroker(em2));\r\n+        assertSame(em.getEntityManagerFactory(), em2.getEntityManagerFactory());\r\n+\r\n+        assertSame(em2, JPAFacadeHelper.toBroker(em2)\r\n+            .getUserObject(JPAFacadeHelper.EM_KEY));\r\n+\r\n+        em.close();\r\n+        assertTrue(em2.isOpen());\r\n+        em2.close();\r\n+    }\r\n+\r\n+    public void testNontransactionalBrokerSerialization() {\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        T e = em.find(getManagedType(), id);\r\n+        OpenJPAEntityManager em2 = deserializeEM(serialize(em));\r\n+\r\n+        assertFalse(em2.getTransaction().isActive());\r\n+\r\n+        assertFalse(em2.contains(e));\r\n+        assertEquals(1*graphSize(), em2.getManagedObjects().size());\r\n+        T e2 = em2.find(getManagedType(), id);\r\n+        assertEquals(em.getObjectId(e), em2.getObjectId(e2));\r\n+\r\n+        em.close();\r\n+        em2.close();\r\n+    }\r\n+\r\n+    public void testUnflushedOptimisticTxBrokerSerialization() {\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        T e = em.find(getManagedType(), id);\r\n+        OpenJPAEntityManager em2 = null;\r\n+        OpenJPAEntityManager em3 = null;\r\n+        try {\r\n+            em.getTransaction().begin();\r\n+            modifyInstance(e);\r\n+            T newe = newManagedInstance();\r\n+            em.persist(newe);\r\n+            em2 = deserializeEM(serialize(em));\r\n+\r\n+            assertTrue(em2.getTransaction().isActive());\r\n+\r\n+            assertFalse(em2.contains(e));\r\n+            T e2 = em2.find(getManagedType(), id);\r\n+            assertEquals(em.getObjectId(e), em2.getObjectId(e2));\r\n+\r\n+            assertEquals(\"modified\", getModifiedValue(e2));\r\n+\r\n+            em.getTransaction().rollback();\r\n+            assertTrue(em2.getTransaction().isActive());\r\n+            em2.getTransaction().commit();\r\n+\r\n+            em3 = emf.createEntityManager();\r\n+            T e3 = em3.find(getManagedType(), id);\r\n+            assertEquals(getModifiedValue(e2), getModifiedValue(e3));\r\n+            assertTrue(1 < ((Number) em3.createQuery(\"select count(o) from \"\r\n+                + getManagedType().getName() + \" o\").getSingleResult())\r\n+                .intValue());\r\n+        } finally {\r\n+            close(em);\r\n+            close(em2);\r\n+            close(em3);\r\n+        }\r\n+    }\r\n+\r\n+    public void testFlushedOptimisticTxBrokerSerialization() {\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        T e = em.find(getManagedType(), id);\r\n+        em.getTransaction().begin();\r\n+        modifyInstance(e);\r\n+        em.flush();\r\n+        try {\r\n+            serialize(em);\r\n+        } catch (InvalidStateException ise) {\r\n+            // expected\r\n+            assertTrue(ise.getMessage().contains(\"flushed\"));\r\n+        } finally {\r\n+            em.getTransaction().rollback();\r\n+            em.close();\r\n+        }\r\n+    }\r\n+\r\n+    public void testConnectedOptimisticTxBrokerSerialization() {\r\n+        Map m = new HashMap();\r\n+        m.put(\"openjpa.ConnectionRetainMode\", \"always\");\r\n+        OpenJPAEntityManager em = emf.createEntityManager(m);\r\n+        try {\r\n+            serialize(em);\r\n+        } catch (InvalidStateException ise) {\r\n+            // expected\r\n+            assertTrue(ise.getMessage().contains(\"connected\"));\r\n+        } finally {\r\n+            em.close();\r\n+        }\r\n+    }\r\n+\r\n+    public void testEmptyPessimisticTxBrokerSerialization() {\r\n+        Map m = new HashMap();\r\n+        m.put(\"openjpa.Optimistic\", \"false\");\r\n+        OpenJPAEntityManager em = emf.createEntityManager(m);\r\n+        em.getTransaction().begin();\r\n+        try {\r\n+            serialize(em);\r\n+            fail(\"should not be able to serialize\");\r\n+        } catch (InvalidStateException ise) {\r\n+            // expected\r\n+            assertTrue(ise.getMessage().contains(\"datastore (pessimistic)\"));\r\n+        } finally {\r\n+            em.getTransaction().rollback();\r\n+            em.close();\r\n+        }\r\n+    }\r\n+\r\n+    public void testNonEmptyPessimisticTxBrokerSerialization() {\r\n+        Map m = new HashMap();\r\n+        m.put(\"openjpa.Optimistic\", \"false\");\r\n+        OpenJPAEntityManager em = emf.createEntityManager(m);\r\n+        T e = em.find(getManagedType(), id);\r\n+        em.getTransaction().begin();\r\n+        try {\r\n+            serialize(em);\r\n+            fail(\"should not be able to serialize\");\r\n+        } catch (InvalidStateException ise) {\r\n+            // expected\r\n+            assertTrue(ise.getMessage().contains(\"datastore (pessimistic)\"));\r\n+        } finally {\r\n+            em.getTransaction().rollback();\r\n+            em.close();\r\n+        }\r\n+    }\r\n+\r\n+    public void testFetchConfigurationMutations() {\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        JDBCFetchPlan plan = (JDBCFetchPlan) em.getFetchPlan();\r\n+\r\n+        assertNotEquals(17, plan.getLockTimeout());\r\n+        assertNotEquals(JoinSyntax.TRADITIONAL, plan.getJoinSyntax());\r\n+\r\n+        plan.setLockTimeout(17);\r\n+        plan.setJoinSyntax(JoinSyntax.TRADITIONAL);\r\n+\r\n+        OpenJPAEntityManager em2 = deserializeEM(serialize(em));\r\n+        JDBCFetchPlan plan2 = (JDBCFetchPlan) em2.getFetchPlan();\r\n+        assertEquals(17, plan2.getLockTimeout());\r\n+        assertEquals(JoinSyntax.TRADITIONAL, plan2.getJoinSyntax());\r\n+    }\r\n+\r\n+    public void testInMemorySavepointsWithNewInstances() {\r\n+        emf.close();\r\n+        OpenJPAEntityManagerFactory emf = createEMF(\r\n+            getManagedType(), getSecondaryType(),\r\n+            \"openjpa.EntityManagerFactoryPool\", \"true\",\r\n+            \"openjpa.SavepointManager\", \"in-mem\");\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        OpenJPAEntityManager em2 = null;\r\n+        try {\r\n+            em.getTransaction().begin();\r\n+            T t = newManagedInstance();\r\n+            Object orig = getModifiedValue(t);\r\n+            em.persist(t);\r\n+            Object id = em.getObjectId(t);\r\n+            em.setSavepoint(\"foo\");\r\n+            modifyInstance(t);\r\n+            assertNotEquals(orig, getModifiedValue(t));\r\n+\r\n+            em2 = deserializeEM(serialize(em));\r\n+            T t2 = em2.find(getManagedType(), id);\r\n+            assertNotEquals(orig, getModifiedValue(t2));\r\n+\r\n+            em.rollbackToSavepoint(\"foo\");\r\n+            assertEquals(orig, getModifiedValue(t));\r\n+\r\n+            em2.rollbackToSavepoint(\"foo\");\r\n+            assertEquals(orig, getModifiedValue(t2));\r\n+        } finally {\r\n+            close(em);\r\n+            close(em2);\r\n+        }\r\n+    }\r\n+\r\n+    public void testInMemorySavepointsWithModifiedInstances() {\r\n+        emf.close();\r\n+        OpenJPAEntityManagerFactory emf = createEMF(\r\n+            getManagedType(), getSecondaryType(),\r\n+            \"openjpa.EntityManagerFactoryPool\", \"true\",\r\n+            \"openjpa.SavepointManager\", \"in-mem\");\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        OpenJPAEntityManager em2 = null;\r\n+        try {\r\n+            em.getTransaction().begin();\r\n+            T t = em.find(getManagedType(), id);\r\n+            Object orig = getModifiedValue(t);\r\n+            em.setSavepoint(\"foo\");\r\n+            modifyInstance(t);\r\n+            assertNotEquals(orig, getModifiedValue(t));\r\n+\r\n+            em2 = deserializeEM(serialize(em));\r\n+            T t2 = em2.find(getManagedType(), id);\r\n+            assertNotEquals(orig, getModifiedValue(t2));\r\n+\r\n+            em.rollbackToSavepoint(\"foo\");\r\n+            assertEquals(orig, getModifiedValue(t));\r\n+\r\n+            em2.rollbackToSavepoint(\"foo\");\r\n+            assertEquals(orig, getModifiedValue(t2));\r\n+        } finally {\r\n+            close(em);\r\n+            close(em2);\r\n+        }\r\n+    }\r\n+\r\n+    public void testEventManagers() {\r\n+        TxListener txListener = new TxListener();\r\n+        emf.addTransactionListener(txListener);\r\n+        LifeListener lifeListener = new LifeListener();\r\n+        emf.addLifecycleListener(lifeListener, null);\r\n+\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        T t = em.find(getManagedType(), id);\r\n+        assertEquals(0, lifeListener.refreshCount);\r\n+        em.refresh(t);\r\n+        assertEquals(1*graphSize(), lifeListener.refreshCount);\r\n+        em.getTransaction().begin();\r\n+        em.getTransaction().commit();\r\n+        em.getTransaction().begin();\r\n+        em.getTransaction().commit();\r\n+        assertEquals(2, txListener.beginCount);\r\n+\r\n+        OpenJPAEntityManager em2 = deserializeEM(serialize(em));\r\n+        assertNotNull(deserializedLifeListener);\r\n+        assertEquals(1* graphSize(),\r\n+            deserializedLifeListener.refreshCount);\r\n+        assertNotSame(lifeListener, deserializedLifeListener);\r\n+        T t2 = em2.find(getManagedType(), id);\r\n+        em2.refresh(t2);\r\n+        assertEquals(2* graphSize(),\r\n+            deserializedLifeListener.refreshCount);\r\n+\r\n+        // if this is 3*refreshMultiplier(), that means that there are\r\n+        // extra registered listeners\r\n+        assertEquals(2* graphSize(), testGlobalRefreshCount);\r\n+\r\n+\r\n+        assertNotNull(deserializedTxListener);\r\n+        assertEquals(2, deserializedTxListener.beginCount);\r\n+        assertNotSame(txListener, deserializedTxListener);\r\n+        em2.getTransaction().begin();\r\n+        em2.getTransaction().rollback();\r\n+        assertEquals(3, deserializedTxListener.beginCount);\r\n+\r\n+        // if this is 4, that means that there are extra registered listeners\r\n+        assertEquals(3, testGlobalBeginCount);\r\n+    }\r\n+\r\n+    byte[] serialize(Object o) {\r\n+        try {\r\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n+            ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n+            oos.writeObject(o);\r\n+            oos.flush();\r\n+            return baos.toByteArray();\r\n+        } catch (IOException ioe) {\r\n+            throw new RuntimeException(ioe);\r\n+        }\r\n+    }\r\n+\r\n+    OpenJPAEntityManager deserializeEM(byte[] bytes) {\r\n+        return (OpenJPAEntityManager) deserialize(bytes);\r\n+    }\r\n+\r\n+    private Object deserialize(byte[] bytes) {\r\n+        try {\r\n+            ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\r\n+            ObjectInputStream ois = new ObjectInputStream(bais);\r\n+            return ois.readObject();\r\n+        } catch (IOException ioe) {\r\n+            throw new RuntimeException(ioe);\r\n+        } catch (ClassNotFoundException e) {\r\n+            throw new RuntimeException(e);\r\n+        }\r\n+    }\r\n+\r\n+    void close(EntityManager em) {\r\n+        if (em != null && em.isOpen() && em.getTransaction().isActive())\r\n+            em.getTransaction().rollback();\r\n+        if (em != null && em.isOpen())\r\n+            em.close();\r\n+    }\r\n+\r\n+    protected abstract Class<T> getManagedType();\r\n+\r\n+    protected abstract T newManagedInstance();\r\n+\r\n+    protected abstract void modifyInstance(T t);\r\n+\r\n+    protected abstract Object getModifiedValue(T t);\r\n+\r\n+    /**\r\n+     * The number of instances in the graph created\r\n+     * by {@link #newManagedInstance()} of type T.\r\n+     */\r\n+    protected int graphSize() {\r\n+        return 1;\r\n+    }\r\n+\r\n+    /**\r\n+     * An additional type that must be available in this PC. May be null.\r\n+     */\r\n+    protected Class getSecondaryType() {\r\n+        return null;\r\n+    }\r\n+\r\n+    private static class TxListener\r\n+        extends AbstractTransactionListener\r\n+        implements Serializable {\r\n+\r\n+        private int beginCount = 0;\r\n+\r\n+        public TxListener() {\r\n+\r\n+        }\r\n+\r\n+        @Override\r\n+        public void afterBegin(TransactionEvent event) {\r\n+            beginCount++;\r\n+            testGlobalBeginCount++;\r\n+        }\r\n+\r\n+        private void readObject(ObjectInputStream in)\r\n+            throws ClassNotFoundException, IOException {\r\n+            in.defaultReadObject();\r\n+            deserializedTxListener = this;\r\n+        }\r\n+    }\r\n+\r\n+    private static class LifeListener\r\n+        extends AbstractLifecycleListener\r\n+        implements Serializable {\r\n+\r\n+        private int refreshCount = 0;\r\n+\r\n+        @Override\r\n+        public void afterRefresh(LifecycleEvent event) {\r\n+            refreshCount++;\r\n+            testGlobalRefreshCount++;\r\n+        }\r\n+\r\n+        private void readObject(ObjectInputStream in)\r\n+            throws ClassNotFoundException, IOException {\r\n+            in.defaultReadObject();\r\n+            deserializedLifeListener = this;\r\n+        }\r\n+    }\r\n+}\n\\ No newline at end of file"},{"sha":"f8f0a817be0b5de27e49d538eea51e667cdf4639","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -0,0 +1,52 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import org.apache.openjpa.enhance.PersistenceCapable;\r\n+import org.apache.openjpa.enhance.UnenhancedSubtype;\r\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n+\r\n+public abstract class AbstractUnenhancedRelationBrokerSerializationTest<T>\r\n+    extends AbstractBrokerSerializationTest<T> {\r\n+\r\n+    public void testNewUnenhancedSMsRegisteredGlobally() {\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        OpenJPAEntityManager em2 = null;\r\n+        try {\r\n+            em.getTransaction().begin();\r\n+            UnenhancedSubtype newe = (UnenhancedSubtype) newManagedInstance();\r\n+            em.persist(newe);\r\n+            em2 = deserializeEM(serialize(em));\r\n+\r\n+            for (Object o : em2.getManagedObjects()) {\r\n+                assertFalse(o instanceof PersistenceCapable);\r\n+                assertNotNull(ImplHelper.toPersistenceCapable(o,\r\n+                    emf.getConfiguration()));\r\n+                if (o instanceof UnenhancedSubtype)\r\n+                    assertNotNull(ImplHelper.toPersistenceCapable(\r\n+                        ((UnenhancedSubtype) o).getRelated(),\r\n+                            emf.getConfiguration()));\r\n+            }\r\n+        } finally {\r\n+            close(em);\r\n+            close(em2);\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"ceb8f257dfd3a1c0c02c8cabc5f77feb708b739a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -0,0 +1,52 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import org.apache.openjpa.enhance.PersistenceCapable;\r\n+import org.apache.openjpa.persistence.query.SimpleEntity;\r\n+\r\n+public class TestEnhancedInstanceBrokerSerialization\r\n+    extends AbstractBrokerSerializationTest<SimpleEntity> {\r\n+\r\n+    @Override\r\n+    public void setUp() {\r\n+        assertTrue(\r\n+            PersistenceCapable.class.isAssignableFrom(SimpleEntity.class));\r\n+        super.setUp();\r\n+    }\r\n+\r\n+    protected Class<SimpleEntity> getManagedType() {\r\n+        return SimpleEntity.class;\r\n+    }\r\n+\r\n+    protected SimpleEntity newManagedInstance() {\r\n+        SimpleEntity e = new SimpleEntity();\r\n+        e.setName(\"foo\");\r\n+        e.setValue(\"bar\");\r\n+        return e;\r\n+    }\r\n+\r\n+    protected void modifyInstance(SimpleEntity e) {\r\n+        e.setValue(\"modified\");\r\n+    }\r\n+\r\n+    protected Object getModifiedValue(SimpleEntity e) {\r\n+        return e.getValue();\r\n+    }\r\n+}\n\\ No newline at end of file"},{"sha":"f61a62c682b5012785e60ca9f765910f0b9dbf07","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -0,0 +1,53 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.Map;\r\n+import javax.persistence.EntityManagerFactory;\r\n+import javax.persistence.Persistence;\r\n+\r\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n+\r\n+public class TestEntityManagerFactoryPool\r\n+    extends SingleEMFTestCase {\r\n+\r\n+    public void setUp() {\r\n+        setUp(\"openjpa.EntityManagerFactoryPool\", Boolean.TRUE);\r\n+\r\n+        emf.createEntityManager().close();\r\n+    }\r\n+\r\n+    public void testBrokerFactoryPoolHit() {\r\n+        Map m = new HashMap();\r\n+        // also tests string values for the property\r\n+        m.put(\"openjpa.EntityManagerFactoryPool\", \"True\");\r\n+        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\r\n+            \"test\", m);\r\n+        assertSame(this.emf, emf);\r\n+    }\r\n+\r\n+    public void testBrokerFactoryPoolMiss() {\r\n+        Map m = new HashMap();\r\n+        m.put(\"openjpa.EntityManagerFactoryPool\", Boolean.TRUE);\r\n+        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\r\n+            \"second-persistence-unit\", m);\r\n+        assertNotSame(this.emf, emf);\r\n+    }\r\n+}\n\\ No newline at end of file"},{"sha":"4fc26d412c3f7cec0d82234948ca8c0940640e57","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -0,0 +1,51 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import org.apache.openjpa.persistence.query.ManyOneEntity;\r\n+\r\n+public class TestInstanceGraphBrokerSerialization\r\n+    extends AbstractBrokerSerializationTest<ManyOneEntity> {\r\n+\r\n+    protected Class<ManyOneEntity> getManagedType() {\r\n+        return ManyOneEntity.class;\r\n+    }\r\n+\r\n+    protected ManyOneEntity newManagedInstance() {\r\n+        ManyOneEntity e = new ManyOneEntity();\r\n+        e.setName(\"foo\");\r\n+        ManyOneEntity rel = new ManyOneEntity();\r\n+        rel.setName(\"bar\");\r\n+        e.setRel(rel);\r\n+        return e;\r\n+    }\r\n+\r\n+    protected void modifyInstance(ManyOneEntity e) {\r\n+        e.getRel().setName(\"modified\");\r\n+    }\r\n+\r\n+    protected Object getModifiedValue(ManyOneEntity e) {\r\n+        return e.getRel().getName();\r\n+    }\r\n+\r\n+    @Override\r\n+    protected int graphSize() {\r\n+        return 2;\r\n+    }\r\n+}\n\\ No newline at end of file"},{"sha":"1918545d0fe840f6fd44fd2cbb6b4ddf7b253d29","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -0,0 +1,43 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import org.apache.openjpa.enhance.UnenhancedFieldAccess;\r\n+\r\n+public class TestUnenhancedFieldAccessInstanceBrokerSerialization\r\n+    extends AbstractBrokerSerializationTest<UnenhancedFieldAccess> {\r\n+\r\n+    protected Class<UnenhancedFieldAccess> getManagedType() {\r\n+        return UnenhancedFieldAccess.class;\r\n+    }\r\n+\r\n+    protected UnenhancedFieldAccess newManagedInstance() {\r\n+        UnenhancedFieldAccess e = new UnenhancedFieldAccess();\r\n+        e.setStringField(\"foo\");\r\n+        return e;\r\n+    }\r\n+\r\n+    protected void modifyInstance(UnenhancedFieldAccess e) {\r\n+        e.setStringField(\"modified\");\r\n+    }\r\n+\r\n+    protected Object getModifiedValue(UnenhancedFieldAccess e) {\r\n+        return e.getStringField();\r\n+    }\r\n+}\n\\ No newline at end of file"},{"sha":"02ac209d121b22c7d86435742d8be4364ad2728b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -0,0 +1,57 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import org.apache.openjpa.enhance.UnenhancedFieldAccess;\r\n+import org.apache.openjpa.enhance.UnenhancedFieldAccessSubclass;\r\n+\r\n+public class TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization\r\n+    extends AbstractUnenhancedRelationBrokerSerializationTest\r\n+        <UnenhancedFieldAccessSubclass> {\r\n+\r\n+    protected Class getSecondaryType() {\r\n+        return UnenhancedFieldAccess.class;\r\n+    }\r\n+\r\n+    protected Class<UnenhancedFieldAccessSubclass> getManagedType() {\r\n+        return UnenhancedFieldAccessSubclass.class;\r\n+    }\r\n+\r\n+    protected UnenhancedFieldAccessSubclass newManagedInstance() {\r\n+        UnenhancedFieldAccessSubclass e = new UnenhancedFieldAccessSubclass();\r\n+        e.setStringField(\"foo\");\r\n+        UnenhancedFieldAccess related = new UnenhancedFieldAccess();\r\n+        related.setStringField(\"bar\");\r\n+        e.setRelated(related);\r\n+        return e;\r\n+    }\r\n+\r\n+    protected void modifyInstance(UnenhancedFieldAccessSubclass e) {\r\n+        e.getRelated().setStringField(\"modified\");\r\n+    }\r\n+\r\n+    protected Object getModifiedValue(UnenhancedFieldAccessSubclass e) {\r\n+        return e.getRelated().getStringField();\r\n+    }\r\n+\r\n+    @Override\r\n+    protected int graphSize() {\r\n+        return 2;\r\n+    }\r\n+}\n\\ No newline at end of file"},{"sha":"3c49949483b7d34af86072cb61fb7020ae3f6ca7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -0,0 +1,43 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import org.apache.openjpa.enhance.UnenhancedPropertyAccess;\r\n+\r\n+public class TestUnenhancedPropertyAccessInstanceBrokerSerialization\r\n+    extends AbstractBrokerSerializationTest<UnenhancedPropertyAccess> {\r\n+\r\n+    protected Class<UnenhancedPropertyAccess> getManagedType() {\r\n+        return UnenhancedPropertyAccess.class;\r\n+    }\r\n+\r\n+    protected UnenhancedPropertyAccess newManagedInstance() {\r\n+        UnenhancedPropertyAccess e = new UnenhancedPropertyAccess();\r\n+        e.setStringField(\"foo\");\r\n+        return e;\r\n+    }\r\n+\r\n+    protected void modifyInstance(UnenhancedPropertyAccess e) {\r\n+        e.setStringField(\"modified\");\r\n+    }\r\n+\r\n+    protected Object getModifiedValue(UnenhancedPropertyAccess e) {\r\n+        return e.getStringField();\r\n+    }\r\n+}\n\\ No newline at end of file"},{"sha":"3f533f7d95fa737d9cf686f691492eb469b74304","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -0,0 +1,58 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import org.apache.openjpa.enhance.UnenhancedPropertyAccess;\r\n+import org.apache.openjpa.enhance.UnenhancedPropertyAccessSubclass;\r\n+\r\n+public class TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization\r\n+    extends AbstractUnenhancedRelationBrokerSerializationTest\r\n+        <UnenhancedPropertyAccessSubclass> {\r\n+\r\n+    protected Class getSecondaryType() {\r\n+        return UnenhancedPropertyAccess.class;\r\n+    }\r\n+\r\n+    protected Class<UnenhancedPropertyAccessSubclass> getManagedType() {\r\n+        return UnenhancedPropertyAccessSubclass.class;\r\n+    }\r\n+\r\n+    protected UnenhancedPropertyAccessSubclass newManagedInstance() {\r\n+        UnenhancedPropertyAccessSubclass e =\r\n+            new UnenhancedPropertyAccessSubclass();\r\n+        e.setStringField(\"foo\");\r\n+        UnenhancedPropertyAccess related = new UnenhancedPropertyAccess();\r\n+        related.setStringField(\"bar\");\r\n+        e.setRelated(related);\r\n+        return e;\r\n+    }\r\n+\r\n+    protected void modifyInstance(UnenhancedPropertyAccessSubclass e) {\r\n+        e.getRelated().setStringField(\"modified\");\r\n+    }\r\n+\r\n+    protected Object getModifiedValue(UnenhancedPropertyAccessSubclass e) {\r\n+        return e.getRelated().getStringField();\r\n+    }\r\n+\r\n+    @Override\r\n+    protected int graphSize() {\r\n+        return 2;\r\n+    }\r\n+}\n\\ No newline at end of file"},{"sha":"0eb18327fc2d697e7f71f264f60b3dadf4836947","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/ManyOneEntity.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/ManyOneEntity.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/ManyOneEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/ManyOneEntity.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -18,6 +18,7 @@\n  */\r\n package org.apache.openjpa.persistence.query;\r\n \r\n+import java.io.Serializable;\r\n import javax.persistence.CascadeType;\r\n import javax.persistence.Entity;\r\n import javax.persistence.GeneratedValue;\r\n@@ -29,7 +30,7 @@\n \r\n @Entity\r\n @Inheritance(strategy=InheritanceType.SINGLE_TABLE)\r\n-public class ManyOneEntity {\r\n+public class ManyOneEntity implements Serializable {\r\n \r\n     @Id\r\n     @GeneratedValue\r"},{"sha":"ba15b9729e45bb5ea95d8d0355096563a5a8a9a7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -18,6 +18,7 @@\n  */\r\n package org.apache.openjpa.persistence.query;\r\n \r\n+import java.io.Serializable;\r\n import javax.persistence.Basic;\r\n import javax.persistence.Column;\r\n import javax.persistence.Entity;\r\n@@ -43,7 +44,7 @@\n         @FieldResult(name = \"value\", column = \"VALUE\") }))\r\n @Entity(name = \"simple\")\r\n @Table(name = \"SIMPLE_ENTITY\")\r\n-public class SimpleEntity {\r\n+public class SimpleEntity implements Serializable {\r\n \r\n     @Id\r\n     @GeneratedValue\r"},{"sha":"a06389927a772427b8b9fe4a45c8b4812a9bd980","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","status":"modified","additions":167,"deletions":9,"changes":176,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -18,6 +18,15 @@\n  */\r\n package org.apache.openjpa.persistence;\r\n \r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.ByteArrayOutputStream;\r\n+import java.io.Externalizable;\r\n+import java.io.IOException;\r\n+import java.io.ObjectInput;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutput;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.ObjectStreamClass;\r\n import java.lang.reflect.Array;\r\n import java.util.Arrays;\r\n import java.util.Collection;\r\n@@ -30,6 +39,9 @@\n import org.apache.commons.lang.StringUtils;\r\n import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n import org.apache.openjpa.ee.ManagedRuntime;\r\n+import org.apache.openjpa.enhance.PCEnhancer;\r\n+import org.apache.openjpa.enhance.PCRegistry;\r\n+import org.apache.openjpa.kernel.AbstractBrokerFactory;\r\n import org.apache.openjpa.kernel.Broker;\r\n import org.apache.openjpa.kernel.DelegatingBroker;\r\n import org.apache.openjpa.kernel.FindCallbacks;\r\n@@ -40,8 +52,8 @@\n import org.apache.openjpa.kernel.QueryLanguages;\r\n import org.apache.openjpa.kernel.Seq;\r\n import org.apache.openjpa.kernel.jpql.JPQLParser;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n import org.apache.openjpa.lib.util.Closeable;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n import org.apache.openjpa.meta.ClassMetaData;\r\n import org.apache.openjpa.meta.FieldMetaData;\r\n import org.apache.openjpa.meta.QueryMetaData;\r\n@@ -59,30 +71,36 @@\n  * @nojavadoc\r\n  */\r\n public class EntityManagerImpl\r\n-    implements OpenJPAEntityManagerSPI,\r\n+    implements OpenJPAEntityManagerSPI, Externalizable,\r\n     FindCallbacks, OpCallbacks, Closeable, OpenJPAEntityTransaction {\r\n \r\n     private static final Localizer _loc = Localizer.forPackage\r\n         (EntityManagerImpl.class);\r\n+    private static final Object[] EMPTY_OBJECTS = new Object[0];\r\n \r\n-    private final DelegatingBroker _broker;\r\n-    private final EntityManagerFactoryImpl _emf;\r\n+    private DelegatingBroker _broker;\r\n+    private EntityManagerFactoryImpl _emf;\r\n     private FetchPlan _fetch = null;\r\n-    private static final Object[] EMPTY_OBJECTS = new Object[0];\r\n \r\n     private RuntimeExceptionTranslator ret =\r\n         PersistenceExceptions.getRollbackTranslator(this);\r\n \r\n+    public EntityManagerImpl() {\r\n+        // for Externalizable\r\n+    }\r\n+\r\n     /**\r\n      * Constructor; supply factory and delegate.\r\n      */\r\n     public EntityManagerImpl(EntityManagerFactoryImpl factory,\r\n         Broker broker) {\r\n+        initialize(factory, broker);\r\n+    }\r\n+\r\n+    private void initialize(EntityManagerFactoryImpl factory, Broker broker) {\r\n         _emf = factory;\r\n-        RuntimeExceptionTranslator translator =\r\n-            PersistenceExceptions.getRollbackTranslator(this);\r\n-        _broker = new DelegatingBroker(broker, translator);\r\n-        _broker.setImplicitBehavior(this, translator);\r\n+        _broker = new DelegatingBroker(broker, ret);\r\n+        _broker.setImplicitBehavior(this, ret);\r\n     }\r\n \r\n     /**\r\n@@ -1180,4 +1198,144 @@ public boolean equals(Object other) {\n             return false;\r\n         return _broker.equals(((EntityManagerImpl) other)._broker);\r\n     }\r\n+\r\n+    public void readExternal(ObjectInput in)\r\n+        throws IOException, ClassNotFoundException {\r\n+        try {\r\n+            ret = PersistenceExceptions.getRollbackTranslator(this);\r\n+\r\n+            // this assumes that serialized Brokers are from something\r\n+            // that extends AbstractBrokerFactory.\r\n+            Object factoryKey = in.readObject();\r\n+            AbstractBrokerFactory factory =\r\n+                AbstractBrokerFactory.getPooledFactoryForKey(factoryKey);\r\n+            byte[] brokerBytes = (byte[]) in.readObject();\r\n+            ObjectInputStream innerIn = new BrokerBytesInputStream(brokerBytes,\r\n+                factory.getConfiguration());\r\n+\r\n+            Broker broker = (Broker) innerIn.readObject();\r\n+            EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl)\r\n+                JPAFacadeHelper.toEntityManagerFactory(\r\n+                    broker.getBrokerFactory());\r\n+            broker.putUserObject(JPAFacadeHelper.EM_KEY, this);\r\n+            initialize(emf, broker);\r\n+        } catch (RuntimeException re) {\r\n+            try {\r\n+                re = ret.translate(re);\r\n+            } catch (Exception e) {\r\n+                // ignore\r\n+            }\r\n+            throw re;\r\n+        }\r\n+    }\r\n+\r\n+    public void writeExternal(ObjectOutput out) throws IOException {\r\n+        try {\r\n+            // this requires that only AbstractBrokerFactory-sourced\r\n+            // brokers can be serialized\r\n+            Object factoryKey = ((AbstractBrokerFactory) _broker\r\n+                .getBrokerFactory()).getPoolKey();\r\n+            out.writeObject(factoryKey);\r\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n+            ObjectOutputStream innerOut = new ObjectOutputStream(baos);\r\n+            innerOut.writeObject(_broker.getDelegate());\r\n+            innerOut.flush();\r\n+            out.writeObject(baos.toByteArray());\r\n+        } catch (RuntimeException re) {\r\n+            try {\r\n+                re = ret.translate(re);\r\n+            } catch (Exception e) {\r\n+                // ignore\r\n+            }\r\n+            throw re;\r\n+        }\r\n+    }\r\n+\r\n+    private static class BrokerBytesInputStream extends ObjectInputStream {\r\n+\r\n+        private OpenJPAConfiguration conf;\r\n+\r\n+        BrokerBytesInputStream(byte[] bytes, OpenJPAConfiguration conf)\r\n+            throws IOException {\r\n+            super(new ByteArrayInputStream(bytes));\r\n+            if (conf == null)\r\n+                throw new IllegalArgumentException(\r\n+                    \"Illegal null argument to ObjectInputStreamWithLoader\");\r\n+            this.conf = conf;\r\n+        }\r\n+\r\n+        /**\r\n+         * Make a primitive array class\r\n+         */\r\n+        private Class primitiveType(char type) {\r\n+            switch (type) {\r\n+                case 'B': return byte.class;\r\n+                case 'C': return char.class;\r\n+                case 'D': return double.class;\r\n+                case 'F': return float.class;\r\n+                case 'I': return int.class;\r\n+                case 'J': return long.class;\r\n+                case 'S': return short.class;\r\n+                case 'Z': return boolean.class;\r\n+                default: return null;\r\n+            }\r\n+        }\r\n+\r\n+        protected Class resolveClass(ObjectStreamClass classDesc)\r\n+            throws IOException, ClassNotFoundException {\r\n+\r\n+            String cname = classDesc.getName();\r\n+            if (cname.startsWith(\"[\")) {\r\n+                // An array\r\n+                Class component;\t\t// component class\r\n+                int dcount;\t\t\t    // dimension\r\n+                for (dcount=1; cname.charAt(dcount)=='['; dcount++) ;\r\n+                if (cname.charAt(dcount) == 'L') {\r\n+                    component = lookupClass(cname.substring(dcount+1,\r\n+                        cname.length()-1));\r\n+                } else {\r\n+                    if (cname.length() != dcount+1) {\r\n+                        throw new ClassNotFoundException(cname);// malformed\r\n+                    }\r\n+                    component = primitiveType(cname.charAt(dcount));\r\n+                }\r\n+                int dim[] = new int[dcount];\r\n+                for (int i=0; i<dcount; i++) {\r\n+                    dim[i]=0;\r\n+                }\r\n+                return Array.newInstance(component, dim).getClass();\r\n+            } else {\r\n+                return lookupClass(cname);\r\n+            }\r\n+        }\r\n+\r\n+        /**\r\n+         * If this is a generated subclass, look up the corresponding Class\r\n+         * object via metadata.\r\n+         */\r\n+        private Class lookupClass(String className)\r\n+            throws ClassNotFoundException {\r\n+            try {\r\n+                return Class.forName(className);\r\n+            } catch (ClassNotFoundException e) {\r\n+                if (PCEnhancer.isPCSubclassName(className)) {\r\n+                    String superName = PCEnhancer.toManagedTypeName(className);\r\n+                    ClassMetaData[] metas = conf.getMetaDataRepositoryInstance()\r\n+                        .getMetaDatas();\r\n+                    for (int i = 0; i < metas.length; i++) {\r\n+                        if (superName.equals(\r\n+                            metas[i].getDescribedType().getName())) {\r\n+                            return PCRegistry.getPCType(\r\n+                                metas[i].getDescribedType());\r\n+                        }\r\n+                    }\r\n+\r\n+                    // if it's not found, try to look for it anyways\r\n+                    return Class.forName(className);\r\n+                } else {\r\n+                    throw e;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n }\r"},{"sha":"9d21660e6b60738f9c44d90acba4745a54c8f6cb","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -51,8 +51,8 @@ public RuntimeException translate(RuntimeException re) {\n      * and {@link NonUniqueResultException} in accordance with\n      * section 3.7 of the EJB 3.0 specification.\n      */\n-    public static RuntimeExceptionTranslator getRollbackTranslator\n-        (final OpenJPAEntityManager em) {\n+    public static RuntimeExceptionTranslator getRollbackTranslator(\n+        final OpenJPAEntityManager em) {\n         return new RuntimeExceptionTranslator() {\n             private boolean throwing = false;\n "},{"sha":"cc51f1dd77a6c963990ec652932dedd4365ed778","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","status":"modified","additions":26,"deletions":2,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","raw_url":"https://github.com/apache/openjpa/raw/5018dfaa88189d72909b45ccde5cd722ed2bae10/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java?ref=5018dfaa88189d72909b45ccde5cd722ed2bae10","patch":"@@ -22,6 +22,8 @@\n import java.lang.instrument.IllegalClassFormatException;\n import java.security.ProtectionDomain;\n import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n import javax.persistence.EntityManager;\n import javax.persistence.spi.ClassTransformer;\n import javax.persistence.spi.PersistenceProvider;\n@@ -54,6 +56,7 @@\n     implements PersistenceProvider {\n \n     static final String CLASS_TRANSFORMER_OPTIONS = \"ClassTransformerOptions\";\n+    private static final String EMF_POOL = \"EntityManagerFactoryPool\";\n \n     private static final Localizer _loc = Localizer.forPackage(\n         PersistenceProviderImpl.class);\n@@ -72,17 +75,37 @@ public OpenJPAEntityManagerFactory createEntityManagerFactory(String name,\n         String resource, Map m) {\n         PersistenceProductDerivation pd = new PersistenceProductDerivation();\n         try {\n+            Object poolValue = Configurations.removeProperty(EMF_POOL, m);\n             ConfigurationProvider cp = pd.load(resource, name, m);\n             if (cp == null)\n                 return null;\n \n-            BrokerFactory factory = Bootstrap.newBrokerFactory(cp, null);\n+            BrokerFactory factory = getBrokerFactory(cp, poolValue, null);\n             return JPAFacadeHelper.toEntityManagerFactory(factory);\n         } catch (Exception e) {\n             throw PersistenceExceptions.toPersistenceException(e);\n         }\n     }\n \n+    private BrokerFactory getBrokerFactory(ConfigurationProvider cp,\n+        Object poolValue, ClassLoader loader) {\n+        // handle \"true\" and \"false\"\n+        if (poolValue instanceof String\n+            && (\"true\".equalsIgnoreCase((String) poolValue)\n+                || \"false\".equalsIgnoreCase((String) poolValue)))\n+            poolValue = Boolean.valueOf((String) poolValue);\n+\n+        if (poolValue != null && !(poolValue instanceof Boolean)) {\n+            // we only support boolean settings for this option currently.\n+            throw new IllegalArgumentException(poolValue.toString());\n+        }\n+        \n+        if (poolValue == null || !((Boolean) poolValue).booleanValue())\n+            return Bootstrap.newBrokerFactory(cp, loader);\n+        else\n+            return Bootstrap.getBrokerFactory(cp, loader);\n+    }\n+\n     public OpenJPAEntityManagerFactory createEntityManagerFactory(String name,\n         Map m) {\n         return createEntityManagerFactory(name, null, m);\n@@ -92,6 +115,7 @@ public OpenJPAEntityManagerFactory createContainerEntityManagerFactory(\n         PersistenceUnitInfo pui, Map m) {\n         PersistenceProductDerivation pd = new PersistenceProductDerivation();\n         try {\n+            Object poolValue = Configurations.removeProperty(EMF_POOL, m);\n             ConfigurationProvider cp = pd.load(pui, m);\n             if (cp == null)\n                 return null;\n@@ -117,7 +141,7 @@ public OpenJPAEntityManagerFactory createContainerEntityManagerFactory(\n                     BrokerValue.NON_FINALIZING_ALIAS);\n             }\n \n-            BrokerFactory factory = Bootstrap.newBrokerFactory(cp, \n+            BrokerFactory factory = getBrokerFactory(cp, poolValue,\n                 pui.getClassLoader());\n             if (transformerException != null) {\n                 Log log = factory.getConfiguration().getLog("}]}

