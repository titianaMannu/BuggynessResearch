{"sha":"52e2d925446c06995ebd0979eb1cf93160a8cc31","node_id":"MDY6Q29tbWl0MjA2MzY0OjUyZTJkOTI1NDQ2YzA2OTk1ZWJkMDk3OWViMWNmOTMxNjBhOGNjMzE=","commit":{"author":{"name":"Albert Lee","email":"allee8285@apache.org","date":"2010-02-22T04:29:45Z"},"committer":{"name":"Albert Lee","email":"allee8285@apache.org","date":"2010-02-22T04:29:45Z"},"message":"Re-factor imports and use of generic in BrokerImpl.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@912477 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"504da8c2dd66f8066edca10f1c7af56173e1199c","url":"https://api.github.com/repos/apache/openjpa/git/trees/504da8c2dd66f8066edca10f1c7af56173e1199c"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/52e2d925446c06995ebd0979eb1cf93160a8cc31","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/52e2d925446c06995ebd0979eb1cf93160a8cc31","html_url":"https://github.com/apache/openjpa/commit/52e2d925446c06995ebd0979eb1cf93160a8cc31","comments_url":"https://api.github.com/repos/apache/openjpa/commits/52e2d925446c06995ebd0979eb1cf93160a8cc31/comments","author":null,"committer":null,"parents":[{"sha":"0086e25b8cf904a599529f8475c1cd1bf973e96e","url":"https://api.github.com/repos/apache/openjpa/commits/0086e25b8cf904a599529f8475c1cd1bf973e96e","html_url":"https://github.com/apache/openjpa/commit/0086e25b8cf904a599529f8475c1cd1bf973e96e"}],"stats":{"total":255,"additions":125,"deletions":130},"files":[{"sha":"a0ecab522c294313e6d0c2278b06561582736112","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":125,"deletions":130,"changes":255,"blob_url":"https://github.com/apache/openjpa/blob/52e2d925446c06995ebd0979eb1cf93160a8cc31/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/52e2d925446c06995ebd0979eb1cf93160a8cc31/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=52e2d925446c06995ebd0979eb1cf93160a8cc31","patch":"@@ -38,8 +38,6 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-import java.util.Stack;\n-import java.util.TreeSet;\n import java.util.concurrent.locks.ReentrantLock;\n \n import javax.transaction.Status;\n@@ -175,28 +173,28 @@\n \n     // user state\n     private Synchronization _sync = null;\n-    private Map _userObjects = null;\n+    private Map<Object, Object> _userObjects = null;\n \n     // managed object caches\n     private ManagedCache _cache = null;\n     private TransactionalCache _transCache = null;\n-    private Set _transAdditions = null;\n-    private Set _derefCache = null;\n-    private Set _derefAdditions = null;\n+    private Set<StateManagerImpl> _transAdditions = null;\n+    private Set<StateManagerImpl> _derefCache = null;\n+    private Set<StateManagerImpl> _derefAdditions = null;\n \n     // these are used for method-internal state only\n-    private transient Map _loading = null;\n-    private transient Set _operating = null;\n+    private transient Map<Object, StateManagerImpl> _loading = null;\n+    private transient Set<Object> _operating = null;\n \n-    private Set _persistedClss = null;\n-    private Set _updatedClss = null;\n-    private Set _deletedClss = null;\n-    private Set _pending = null;\n+    private Set<Class<?>> _persistedClss = null;\n+    private Set<Class<?>> _updatedClss = null;\n+    private Set<Class<?>> _deletedClss = null;\n+    private Set<StateManagerImpl> _pending = null;\n     private int findAllDepth = 0;\n \n     // track instances that become transactional after the first savepoint\n     // (the first uses the transactional cache)\n-    private Set _savepointCache = null;\n+    private Set<StateManagerImpl> _savepointCache = null;\n     private LinkedMap _savepoints = null;\n     private transient SavepointManager _spm = null;\n \n@@ -249,7 +247,7 @@\n \n     private transient boolean _initializeWasInvoked = false;\n     private transient boolean _fromWriteBehindCallback = false;\n-    private LinkedList _fcs;\n+    private LinkedList<FetchConfiguration> _fcs;\n     \n     // Set of supported property keys. The keys in this set correspond to bean-style setter methods\n     // that can be set by reflection. The keys are not qualified by any prefix.\n@@ -372,7 +370,7 @@ private void initializeOperatingSet() {\n     /**\n      * Gets the unmodifiable set of instances being operated.\n      */\n-    protected Set getOperatingSet() {\n+    protected Set<Object> getOperatingSet() {\n     \treturn Collections.unmodifiableSet(_operating);\n     }\n \n@@ -390,7 +388,7 @@ public Object clone()\n      * Maps oids to state managers. By default, this creates a\n      * {@link ReferenceMap} with soft values.\n      */\n-    protected Map newManagedObjectCache() {\n+    protected Map<?,?> newManagedObjectCache() {\n         return new ReferenceHashMap(ReferenceMap.HARD, ReferenceMap.SOFT);\n     }\n \n@@ -432,7 +430,7 @@ public FetchConfiguration getFetchConfiguration() {\n \n     public FetchConfiguration pushFetchConfiguration() {\n         if (_fcs == null)\n-            _fcs = new LinkedList();\n+            _fcs = new LinkedList<FetchConfiguration>();\n         _fcs.add(_fc);\n         _fc = (FetchConfiguration) _fc.clone();\n         return _fc;\n@@ -442,7 +440,7 @@ public void popFetchConfiguration() {\n         if (_fcs == null || _fcs.isEmpty())\n             throw new UserException(\n                     _loc.get(\"fetch-configuration-stack-empty\"));\n-        _fc = (FetchConfiguration) _fcs.removeLast();\n+        _fc = _fcs.removeLast();\n     }\n \n     public int getConnectionRetainMode() {\n@@ -514,7 +512,7 @@ public void setNontransactionalRead(boolean val) {\n \n         // make sure the runtime supports it\n         if (val && !_conf.supportedOptions().contains\n-            (_conf.OPTION_NONTRANS_READ))\n+            (OpenJPAConfiguration.OPTION_NONTRANS_READ))\n             throw new UnsupportedException(_loc.get\n                 (\"nontrans-read-not-supported\"));\n \n@@ -544,7 +542,7 @@ public void setOptimistic(boolean val) {\n                 \"Optimistic\"));\n \n         // make sure the runtime supports it\n-        if (val && !_conf.supportedOptions().contains(_conf.OPTION_OPTIMISTIC))\n+        if (val && !_conf.supportedOptions().contains(OpenJPAConfiguration.OPTION_OPTIMISTIC))\n             throw new UnsupportedException(_loc.get\n                 (\"optimistic-not-supported\"));\n \n@@ -671,7 +669,7 @@ public Object putUserObject(Object key, Object val) {\n                 return (_userObjects == null) ? null : _userObjects.remove(key);\n \n             if (_userObjects == null)\n-                _userObjects = new HashMap();\n+                _userObjects = new HashMap<Object, Object>();\n             return _userObjects.put(key, val);\n         } finally {\n             endOperation();\n@@ -685,7 +683,7 @@ public Object putUserObject(Object key, Object val) {\n      * Optimistic flag. \n      */\n     public Map<String, Object> getProperties() {\n-        Map props = _conf.toProperties(true);\n+        Map<String, Object> props = _conf.toProperties(true);\n         for (String s : _supportedPropertyNames) {\n             props.put(\"openjpa.\" + s, Reflection.getValue(this, s, true));\n         }\n@@ -1034,7 +1032,7 @@ protected StateManagerImpl initialize(StateManagerImpl sm, boolean load,\n         // array, so that we make sure not to create multiple sms for equivalent\n         // oids if the user has duplicates in the given array\n         if (_loading == null)\n-            _loading = new HashMap((int) (oids.size() * 1.33 + 1));\n+            _loading = new HashMap<Object, StateManagerImpl>((int) (oids.size() * 1.33 + 1));\n \n         if (call == null)\n             call = this;\n@@ -1046,13 +1044,13 @@ protected StateManagerImpl initialize(StateManagerImpl sm, boolean load,\n             assertNontransactionalRead();\n \n             // collection of state managers to pass to store manager\n-            List load = null;\n+            List<OpenJPAStateManager> load = null;\n             StateManagerImpl sm;\n             boolean initialized;\n             boolean transState = useTransactionalState(fetch);\n             Object obj, oid;\n             int idx = 0;\n-            for (Iterator itr = oids.iterator(); itr.hasNext(); idx++) {\n+            for (Iterator<?> itr = oids.iterator(); itr.hasNext(); idx++) {\n                 // if we've already seen this oid, skip repeats\n                 obj = itr.next();\n                 oid = call.processArgument(obj);\n@@ -1073,7 +1071,7 @@ protected StateManagerImpl initialize(StateManagerImpl sm, boolean load,\n                     if (initialized && !sm.isTransactional() && transState)\n                         sm.transactional();\n                     if (load == null)\n-                        load = new ArrayList(oids.size() - idx);\n+                        load = new ArrayList<OpenJPAStateManager>(oids.size() - idx);\n                     load.add(sm);\n                 } else if (!initialized)\n                     sm.initialize(sm.getMetaData().getDescribedType(),\n@@ -1085,14 +1083,14 @@ protected StateManagerImpl initialize(StateManagerImpl sm, boolean load,\n             if (load != null) {\n                 PCState state = (transState) ? PCState.PCLEAN\n                     : PCState.PNONTRANS;\n-                Collection failed = _store.loadAll(load, state,\n+                Collection<Object> failed = _store.loadAll(load, state,\n                     StoreManager.FORCE_LOAD_NONE, fetch, edata);\n \n                 // set failed instances to null\n                 if (failed != null && !failed.isEmpty()) {\n                     if ((flags & OID_NOVALIDATE) != 0)\n                         throw newObjectNotFoundException(failed);\n-                    for (Iterator itr = failed.iterator(); itr.hasNext();)\n+                    for (Iterator<Object> itr = failed.iterator(); itr.hasNext();)\n                         _loading.put(itr.next(), null);\n                 }\n             }\n@@ -1103,9 +1101,9 @@ protected StateManagerImpl initialize(StateManagerImpl sm, boolean load,\n             boolean active = (_flags & FLAG_ACTIVE) != 0;\n             int level = fetch.getReadLockLevel();\n             idx = 0;\n-            for (Iterator itr = oids.iterator(); itr.hasNext(); idx++) {\n+            for (Iterator<?> itr = oids.iterator(); itr.hasNext(); idx++) {\n                 oid = itr.next();\n-                sm = (StateManagerImpl) _loading.get(oid);\n+                sm = _loading.get(oid);\n                 if (sm != null && requiresLoad(sm, true, fetch, edata, flags)) {\n                     try {\n                         sm.load(fetch, StateManagerImpl.LOAD_FGS,\n@@ -1185,7 +1183,7 @@ public Object findCached(Object oid, FindCallbacks call) {\n         }\n     }\n \n-    public Class getObjectIdType(Class cls) {\n+    public Class<?> getObjectIdType(Class<?> cls) {\n         if (cls == null)\n             return null;\n \n@@ -1209,7 +1207,7 @@ public Class getObjectIdType(Class cls) {\n         }\n     }\n \n-    public Object newObjectId(Class cls, Object val) {\n+    public Object newObjectId(Class<?> cls, Object val) {\n         if (val == null)\n             return null;\n \n@@ -1269,13 +1267,13 @@ private StateManagerImpl newStateManagerImpl(Object oid, boolean copy) {\n         // see if we're in the process of loading this oid in a loadAll call\n         StateManagerImpl sm;\n         if (_loading != null) {\n-            sm = (StateManagerImpl) _loading.get(oid);\n+            sm = _loading.get(oid);\n             if (sm != null && sm.getPersistenceCapable() == null)\n                 return sm;\n         }\n \n         // find metadata for the oid\n-        Class pcType = _store.getManagedType(oid);\n+        Class<?> pcType = _store.getManagedType(oid);\n         MetaDataRepository repos = _conf.getMetaDataRepositoryInstance();\n         ClassMetaData meta;\n         if (pcType != null)\n@@ -1355,7 +1353,7 @@ private void beginInternal() {\n \n         if (_pending != null) {\n             StateManagerImpl sm;\n-            for (Iterator it = _pending.iterator(); it.hasNext();) {\n+            for (Iterator<StateManagerImpl> it = _pending.iterator(); it.hasNext();) {\n                 sm = (StateManagerImpl) it.next();\n                 sm.transactional();\n                 if (sm.isDirty())\n@@ -1734,7 +1732,7 @@ public void rollbackToSavepoint(String savepoint) {\n                 // more info per state\n                 SavepointFieldManager fm;\n                 StateManagerImpl sm;\n-                for (Iterator itr = saved.iterator(); itr.hasNext();) {\n+                for (Iterator<?> itr = saved.iterator(); itr.hasNext();) {\n                     fm = (SavepointFieldManager) itr.next();\n                     sm = fm.getStateManager();\n                     sm.rollbackToSavepoint(fm);\n@@ -1744,7 +1742,7 @@ public void rollbackToSavepoint(String savepoint) {\n                     else\n                         newTransCache.addClean(sm);\n                 }\n-                for (Iterator itr = oldTransCache.iterator(); itr.hasNext();) {\n+                for (Iterator<?> itr = oldTransCache.iterator(); itr.hasNext();) {\n                     sm = (StateManagerImpl) itr.next();\n                     sm.rollback();\n                     removeFromTransaction(sm);\n@@ -1772,7 +1770,7 @@ public void flush() {\n                 return;\n \n             // make sure the runtime supports it\n-            if (!_conf.supportedOptions().contains(_conf.OPTION_INC_FLUSH))\n+            if (!_conf.supportedOptions().contains(OpenJPAConfiguration.OPTION_INC_FLUSH))\n                 throw new UnsupportedException(_loc.get\n                     (\"incremental-flush-not-supported\"));\n             if (_savepoints != null && !_savepoints.isEmpty()\n@@ -1820,7 +1818,7 @@ public void validateChanges() {\n             }\n \n             // make sure the runtime supports inc flush\n-            if (!_conf.supportedOptions().contains(_conf.OPTION_INC_FLUSH))\n+            if (!_conf.supportedOptions().contains(OpenJPAConfiguration.OPTION_INC_FLUSH))\n                 throw new UnsupportedException(_loc.get\n                     (\"incremental-flush-not-supported\"));\n \n@@ -2059,8 +2057,8 @@ protected void flush(int reason) {\n             // dependents\n             _flags |= FLAG_DEREFDELETING;\n             if (flush && _derefCache != null && !_derefCache.isEmpty()) {\n-                for (Iterator itr = _derefCache.iterator(); itr.hasNext();)\n-                    deleteDeref((StateManagerImpl) itr.next());\n+                for (Iterator<StateManagerImpl> itr = _derefCache.iterator(); itr.hasNext();)\n+                    deleteDeref(itr.next());\n                 flushAdditions(transactional, reason);\n             }\n \n@@ -2108,7 +2106,7 @@ protected void flush(int reason) {\n         }\n \n         // flush to store manager\n-        List exceps = null;\n+        List<Exception> exceps = null;\n         try {\n             if (flush && reason != FLUSH_LOGICAL) {\n                 _flags |= FLAG_STORE_FLUSHING;\n@@ -2242,13 +2240,12 @@ private int processArgument(int op, Object obj, OpenJPAStateManager sm,\n      * Throw the proper exception based on the given set of flush errors, or\n      * do nothing if no errors occurred.\n      */\n-    private OpenJPAException newFlushException(Collection exceps) {\n+    private OpenJPAException newFlushException(Collection<Exception> exceps) {\n         if (exceps == null || exceps.isEmpty())\n             return null;\n \n-        Throwable[] t = (Throwable[]) exceps.toArray\n-            (new Throwable[exceps.size()]);\n-        List failed = new ArrayList(t.length);\n+        Throwable[] t = exceps.toArray(new Throwable[exceps.size()]);\n+        List<Object> failed = new ArrayList<Object>(t.length);\n \n         // create fatal exception with nested exceptions for all the failed\n         // objects; if all OL exceptions, throw a top-level OL exception\n@@ -2281,7 +2278,7 @@ protected void endTransaction(int status) {\n         // if a data store transaction was in progress, do the\n         // appropriate transaction change\n         boolean rollback = status != Status.STATUS_COMMITTED;\n-        List exceps = null;\n+        List<Exception> exceps = null;\n \n         try {\n             exceps = add(exceps, endStoreManagerTransaction(rollback));\n@@ -2331,9 +2328,8 @@ protected void endTransaction(int status) {\n         // rely on rollback and commit calls below cause some instances might\n         // not be transactional\n         if (_derefCache != null && !_derefCache.isEmpty()) {\n-            for (Iterator itr = _derefCache.iterator(); itr.hasNext();)\n-                ((StateManagerImpl) itr.next()).setDereferencedDependent\n-                    (false, false);\n+            for (Iterator<StateManagerImpl> itr = _derefCache.iterator(); itr.hasNext();)\n+                itr.next().setDereferencedDependent(false, false);\n             _derefCache = null;\n         }\n \n@@ -2414,11 +2410,11 @@ public void persistAll(Collection objs, boolean explicit,\n             return;\n \n         beginOperation(true);\n-        List exceps = null;\n+        List<Exception> exceps = null;\n         try {\n             assertWriteOperation();\n \n-            for (Iterator itr = objs.iterator(); itr.hasNext();) {\n+            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {\n                 try {\n                     persist(itr.next(), explicit, call);\n                 } catch (UserException ue) {\n@@ -2435,27 +2431,26 @@ public void persistAll(Collection objs, boolean explicit,\n      * If the given element is not null, add it to the given list,\n      * creating the list if necessary.\n      */\n-    private List add(List l, Object o) {\n+    private List<Exception> add(List<Exception> l, Exception o) {\n         if (o == null)\n             return l;\n         if (l == null)\n-            l = new LinkedList();\n+            l = new LinkedList<Exception>();\n         l.add(o);\n         return l;\n     }\n \n     /**\n      * Throw an exception wrapping the given nested exceptions.\n      */\n-    private void throwNestedExceptions(List exceps, boolean datastore) {\n+    private void throwNestedExceptions(List<Exception> exceps, boolean datastore) {\n         if (exceps == null || exceps.isEmpty())\n             return;\n         if (datastore && exceps.size() == 1)\n             throw (RuntimeException) exceps.get(0);\n \n         boolean fatal = false;\n-        Throwable[] t = (Throwable[]) exceps.toArray\n-            (new Throwable[exceps.size()]);\n+        Throwable[] t = exceps.toArray(new Throwable[exceps.size()]);\n         for (int i = 0; i < t.length; i++) {\n             if (t[i] instanceof OpenJPAException\n                 && ((OpenJPAException) t[i]).isFatal())\n@@ -2623,9 +2618,9 @@ public void deleteAll(Collection objs, OpCallbacks call) {\n         try {\n             assertWriteOperation();\n \n-            List exceps = null;\n+            List<Exception> exceps = null;\n             Object obj;\n-            for (Iterator itr = objs.iterator(); itr.hasNext();) {\n+            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {\n                 try {\n                     obj = itr.next();\n                     if (obj != null)\n@@ -2707,8 +2702,8 @@ private OpenJPAException newDetachedException(Object obj,\n     public void releaseAll(Collection objs, OpCallbacks call) {\n         beginOperation(false);\n         try {\n-            List exceps = null;\n-            for (Iterator itr = objs.iterator(); itr.hasNext();) {\n+            List<Exception> exceps = null;\n+            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {\n                 try {\n                     release(itr.next(), call);\n                 } catch (UserException ue) {\n@@ -2777,7 +2772,7 @@ public OpenJPAStateManager embed(Object obj, Object id,\n \n             PersistenceCapable copy;\n             PCState state;\n-            Class type = meta.getDescribedType();\n+            Class<?> type = meta.getDescribedType();\n             if (obj != null) {\n                 // give copy and the original instance the same state manager\n                 // so that we can copy fields from one to the other\n@@ -2837,7 +2832,7 @@ OpenJPAStateManager copy(OpenJPAStateManager copy, PCState state) {\n         try {\n             assertOpen();\n             Object oid = copy.fetchObjectId();\n-            Class type = copy.getManagedInstance().getClass();\n+            Class<?> type = copy.getManagedInstance().getClass();\n             if (oid == null)\n                 throw new InternalException();\n             // cached instance?\n@@ -2867,7 +2862,7 @@ public void refreshAll(Collection objs, OpCallbacks call) {\n         try {\n             assertNontransactionalRead();\n \n-            for (Iterator itr = objs.iterator(); itr.hasNext();) \n+            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) \n                 gatherCascadeRefresh(itr.next(), call);\n             if (_operating.isEmpty())\n             \treturn;\n@@ -2928,13 +2923,13 @@ void gatherCascadeRefresh(Object obj, OpCallbacks call) {\n     protected void refreshInternal(Collection objs, OpCallbacks call) {\n     \tif (objs == null || objs.isEmpty())\n     \t\treturn;\n-        List exceps = null;\n+        List<Exception> exceps = null;\n         try {\n             // collect instances that need a refresh\n-            Collection load = null;\n+            Collection<OpenJPAStateManager> load = null;\n             StateManagerImpl sm;\n             Object obj;\n-            for (Iterator itr = objs.iterator(); itr.hasNext();) {\n+            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {\n                 obj = itr.next();\n                 if (obj == null)\n                     continue;\n@@ -2950,7 +2945,7 @@ protected void refreshInternal(Collection objs, OpCallbacks call) {\n                             throw newDetachedException(obj, \"refresh\");\n                         else if (sm.beforeRefresh(true)) {\n                         \tif (load == null)\n-                        \t\tload = new ArrayList(objs.size());\n+                        \t\tload = new ArrayList<OpenJPAStateManager>(objs.size());\n                             load.add(sm);\n                         }\n                         int level = _fc.getReadLockLevel();\n@@ -2967,14 +2962,14 @@ else if (sm.beforeRefresh(true)) {\n \n             // refresh all\n             if (load != null) {\n-                Collection failed = _store.loadAll(load, null,\n+                Collection<Object> failed = _store.loadAll(load, null,\n                     StoreManager.FORCE_LOAD_REFRESH, _fc, null);\n                 if (failed != null && !failed.isEmpty())\n                     exceps = add(exceps, newObjectNotFoundException(failed));\n \n                 // perform post-refresh transitions and make sure all fetch\n                 // group fields are loaded\n-                for (Iterator itr = load.iterator(); itr.hasNext();) {\n+                for (Iterator<OpenJPAStateManager> itr = load.iterator(); itr.hasNext();) {\n                     sm = (StateManagerImpl) itr.next();\n                     if (failed != null && failed.contains(sm.getId()))\n                         continue;\n@@ -2990,7 +2985,7 @@ else if (sm.beforeRefresh(true)) {\n             }\n \n             // now invoke postRefresh on all the instances\n-            for (Iterator itr = objs.iterator(); itr.hasNext();) {\n+            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {\n                 try {\n                     sm = getStateManagerImpl(itr.next(), true);\n                     if (sm != null && !sm.isDetached())\n@@ -3051,18 +3046,18 @@ public void retrieveAll(Collection objs, boolean dfgOnly,\n             return;\n         }\n \n-        List exceps = null;\n+        List<Exception> exceps = null;\n         beginOperation(true);\n         try {\n             assertOpen();\n             assertNontransactionalRead();\n \n             // collect all hollow instances for load\n             Object obj;\n-            Collection load = null;\n+            Collection<OpenJPAStateManager> load = null;\n             StateManagerImpl sm;\n-            Collection sms = new ArrayList(objs.size());\n-            for (Iterator itr = objs.iterator(); itr.hasNext();) {\n+            Collection<StateManagerImpl> sms = new ArrayList<StateManagerImpl>(objs.size());\n+            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {\n                 obj = itr.next();\n                 if (obj == null)\n                     continue;\n@@ -3080,7 +3075,7 @@ public void retrieveAll(Collection objs, boolean dfgOnly,\n                             sms.add(sm);\n                             if (sm.getPCState() == PCState.HOLLOW) {\n                                 if (load == null)\n-                                    load = new ArrayList();\n+                                    load = new ArrayList<OpenJPAStateManager>();\n                                 load.add(sm);\n                             }\n                         }\n@@ -3093,18 +3088,18 @@ public void retrieveAll(Collection objs, boolean dfgOnly,\n             }\n \n             // load all hollow instances\n-            Collection failed = null;\n+            Collection<Object> failed = null;\n             if (load != null) {\n-                int mode = (dfgOnly) ? _store.FORCE_LOAD_DFG\n-                    : _store.FORCE_LOAD_ALL;\n+                int mode = (dfgOnly) ? StoreManager.FORCE_LOAD_DFG\n+                    : StoreManager.FORCE_LOAD_ALL;\n                 failed = _store.loadAll(load, null, mode, _fc, null);\n                 if (failed != null && !failed.isEmpty())\n                     exceps = add(exceps, newObjectNotFoundException(failed));\n             }\n \n             // retrieve all non-failed instances\n-            for (Iterator itr = sms.iterator(); itr.hasNext();) {\n-                sm = (StateManagerImpl) itr.next();\n+            for (Iterator<StateManagerImpl> itr = sms.iterator(); itr.hasNext();) {\n+                sm = itr.next();\n                 if (failed != null && failed.contains(sm.getId()))\n                     continue;\n \n@@ -3166,10 +3161,10 @@ public void evictAll(OpCallbacks call) {\n         beginOperation(false);\n         try {\n             // evict all PClean and PNonTrans objects\n-            Collection c = getManagedStates();\n+            Collection<StateManagerImpl> c = getManagedStates();\n             StateManagerImpl sm;\n-            for (Iterator itr = c.iterator(); itr.hasNext();) {\n-                sm = (StateManagerImpl) itr.next();\n+            for (Iterator<StateManagerImpl> itr = c.iterator(); itr.hasNext();) {\n+                sm = itr.next();\n                 if (sm.isPersistent() && !sm.isDirty())\n                     evict(sm.getManagedInstance(), call);\n             }\n@@ -3180,10 +3175,10 @@ public void evictAll(OpCallbacks call) {\n     }\n \n     public void evictAll(Collection objs, OpCallbacks call) {\n-        List exceps = null;\n+        List<Exception> exceps = null;\n         beginOperation(false);\n         try {\n-            for (Iterator itr = objs.iterator(); itr.hasNext();) {\n+            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {\n                 try {\n                     evict(itr.next(), call);\n                 } catch (UserException ue) {\n@@ -3203,11 +3198,11 @@ public void evictAll(Extent extent, OpCallbacks call) {\n         beginOperation(false);\n         try {\n             // evict all PClean and PNonTrans objects in extent\n-            Collection c = getManagedStates();\n+            Collection<StateManagerImpl> c = getManagedStates();\n             StateManagerImpl sm;\n-            Class cls;\n-            for (Iterator itr = c.iterator(); itr.hasNext();) {\n-                sm = (StateManagerImpl) itr.next();\n+            Class<?> cls;\n+            for (Iterator<StateManagerImpl> itr = c.iterator(); itr.hasNext();) {\n+                sm = itr.next();\n                 if (sm.isPersistent() && !sm.isDirty()) {\n                     cls = sm.getMetaData().getDescribedType();\n                     if (cls == extent.getElementType()\n@@ -3310,10 +3305,10 @@ public void detachAll(OpCallbacks call, boolean flush) {\n     }\n \n     private void detachAllInternal(OpCallbacks call) {\n-        Collection states = getManagedStates();\n+        Collection<StateManagerImpl> states = getManagedStates();\n         StateManagerImpl sm;\n-        for (Iterator itr = states.iterator(); itr.hasNext();) {\n-            sm = (StateManagerImpl) itr.next();\n+        for (Iterator<StateManagerImpl> itr = states.iterator(); itr.hasNext();) {\n+            sm = itr.next();\n             if (!sm.isPersistent())\n                 itr.remove();\n             else if (!sm.getMetaData().isDetachable()) {\n@@ -3393,8 +3388,8 @@ public Object attach(Object obj, boolean copyNew, OpCallbacks call) {\n     public void nontransactionalAll(Collection objs, OpCallbacks call) {\n         beginOperation(true);\n         try {\n-            List exceps = null;\n-            for (Iterator itr = objs.iterator(); itr.hasNext();) {\n+            List<Exception> exceps = null;\n+            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {\n                 try {\n                     nontransactional(itr.next(), call);\n                 } catch (UserException ue) {\n@@ -3444,13 +3439,13 @@ public void transactionalAll(Collection objs, boolean updateVersion,\n         try {\n             // collect all hollow instances for load, and make unmananged\n             // instances transient-transactional\n-            Collection load = null;\n+            Collection<OpenJPAStateManager> load = null;\n             Object obj;\n             StateManagerImpl sm;\n             ClassMetaData meta;\n-            Collection sms = new LinkedHashSet(objs.size());\n-            List exceps = null;\n-            for (Iterator itr = objs.iterator(); itr.hasNext();) {\n+            Collection<StateManagerImpl> sms = new LinkedHashSet<StateManagerImpl>(objs.size());\n+            List<Exception> exceps = null;\n+            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {\n                 obj = itr.next();\n                 if (obj == null)\n                     continue;\n@@ -3475,7 +3470,7 @@ public void transactionalAll(Collection objs, boolean updateVersion,\n                         sms.add(sm);\n                         if (sm.getPCState() == PCState.HOLLOW) {\n                             if (load == null)\n-                                load = new ArrayList();\n+                                load = new ArrayList<OpenJPAStateManager>();\n                             load.add(sm);\n                         }\n \n@@ -3491,9 +3486,9 @@ public void transactionalAll(Collection objs, boolean updateVersion,\n             }\n \n             // load all hollow instances\n-            Collection failed = null;\n+            Collection<Object> failed = null;\n             if (load != null) {\n-                failed = _store.loadAll(load, null, _store.FORCE_LOAD_NONE,\n+                failed = _store.loadAll(load, null, StoreManager.FORCE_LOAD_NONE,\n                     _fc, null);\n                 if (failed != null && !failed.isEmpty())\n                     exceps = add(exceps,\n@@ -3556,10 +3551,10 @@ public void transactional(Object obj, boolean updateVersion,\n      * Transition the given state managers to transactional.\n      */\n     private void transactionalStatesAll(Collection sms, Collection failed,\n-        List exceps) {\n+        List<Exception> exceps) {\n         // make instances transactional and make sure they are loaded\n         StateManagerImpl sm;\n-        for (Iterator itr = sms.iterator(); itr.hasNext();) {\n+        for (Iterator<?> itr = sms.iterator(); itr.hasNext();) {\n             sm = (StateManagerImpl) itr.next();\n             if (failed != null && failed.contains(sm.getId()))\n                 continue;\n@@ -3791,10 +3786,10 @@ public void lockAll(Collection objs, int level, int timeout,\n         try {\n             assertActiveTransaction();\n \n-            Collection sms = new LinkedHashSet(objs.size());\n+            Collection<StateManagerImpl> sms = new LinkedHashSet<StateManagerImpl>(objs.size());\n             Object obj;\n             StateManagerImpl sm;\n-            for (Iterator itr = objs.iterator(); itr.hasNext();) {\n+            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {\n                 obj = itr.next();\n                 if (obj == null)\n                     continue;\n@@ -3808,8 +3803,8 @@ public void lockAll(Collection objs, int level, int timeout,\n             }\n \n             _lm.lockAll(sms, level, timeout, null);\n-            for (Iterator itr = sms.iterator(); itr.hasNext();)\n-                ((StateManagerImpl) itr.next()).readLocked(level, level);\n+            for (Iterator<StateManagerImpl> itr = sms.iterator(); itr.hasNext();)\n+                itr.next().readLocked(level, level);\n         } catch (OpenJPAException ke) {\n             throw ke;\n         } catch (RuntimeException re) {\n@@ -3846,7 +3841,7 @@ public boolean cancelAll() {\n     public Object getConnection() {\n         assertOpen();\n         if (!_conf.supportedOptions().contains\n-            (_conf.OPTION_DATASTORE_CONNECTION))\n+            (OpenJPAConfiguration.OPTION_DATASTORE_CONNECTION))\n             throw new UnsupportedException(_loc.get(\"conn-not-supported\"));\n \n         return _store.getClientConnection();\n@@ -3969,7 +3964,7 @@ protected Collection getDirtyStates() {\n     protected Collection getPendingTransactionalStates() {\n         if (_pending == null)\n             return Collections.EMPTY_SET;\n-        return new LinkedHashSet(_pending);\n+        return new LinkedHashSet<StateManagerImpl>(_pending);\n     }\n \n     /**\n@@ -4057,7 +4052,7 @@ void setDirty(StateManagerImpl sm, boolean firstDirty) {\n \n         if (_savepoints != null && !_savepoints.isEmpty()) {\n             if (_savepointCache == null)\n-                _savepointCache = new HashSet();\n+                _savepointCache = new HashSet<StateManagerImpl>();\n             _savepointCache.add(sm);\n         }\n \n@@ -4072,15 +4067,15 @@ void setDirty(StateManagerImpl sm, boolean firstDirty) {\n                 // also record that the class is dirty\n                 if (sm.isNew()) {\n                     if (_persistedClss == null)\n-                        _persistedClss = new HashSet();\n+                        _persistedClss = new HashSet<Class<?>>();\n                     _persistedClss.add(sm.getMetaData().getDescribedType());\n                 } else if (sm.isDeleted()) {\n                     if (_deletedClss == null)\n-                        _deletedClss = new HashSet();\n+                        _deletedClss = new HashSet<Class<?>>();\n                     _deletedClss.add(sm.getMetaData().getDescribedType());\n                 } else {\n                     if (_updatedClss == null)\n-                        _updatedClss = new HashSet();\n+                        _updatedClss = new HashSet<Class<?>>();\n                     _updatedClss.add(sm.getMetaData().getDescribedType());\n                 }\n \n@@ -4089,7 +4084,7 @@ void setDirty(StateManagerImpl sm, boolean firstDirty) {\n                 // enter the transaction during pre store\n                 if ((_flags & FLAG_PRESTORING) != 0) {\n                     if (_transAdditions == null)\n-                        _transAdditions = new HashSet();\n+                        _transAdditions = new HashSet<StateManagerImpl>();\n                     _transAdditions.add(sm);\n                 }\n             } finally {\n@@ -4107,7 +4102,7 @@ void addToPendingTransaction(StateManagerImpl sm) {\n         lock();\n         try {\n             if (_pending == null)\n-                _pending = new HashSet();\n+                _pending = new HashSet<StateManagerImpl>();\n             _pending.add(sm);\n         } finally {\n             unlock();\n@@ -4141,11 +4136,11 @@ void addDereferencedDependent(StateManagerImpl sm) {\n             // via instance callbacks, add them to the special additions set\n             if ((_flags & FLAG_DEREFDELETING) != 0) {\n                 if (_derefAdditions == null)\n-                    _derefAdditions = new HashSet();\n+                    _derefAdditions = new HashSet<StateManagerImpl>();\n                 _derefAdditions.add(sm);\n             } else {\n                 if (_derefCache == null)\n-                    _derefCache = new HashSet();\n+                    _derefCache = new HashSet<StateManagerImpl>();\n                 _derefCache.add(sm);\n             }\n         }\n@@ -4181,7 +4176,7 @@ public void dirtyType(Class cls) {\n         beginOperation(false);\n         try {\n             if (_updatedClss == null)\n-                _updatedClss = new HashSet();\n+                _updatedClss = new HashSet<Class<?>>();\n             _updatedClss.add(cls);\n         } finally {\n             endOperation();\n@@ -4272,7 +4267,7 @@ protected void free() {\n         _savepointCache = null;\n \n         if (_queries != null) {\n-            for (Iterator itr = _queries.iterator(); itr.hasNext();) {\n+            for (Iterator<?> itr = _queries.iterator(); itr.hasNext();) {\n                 try {\n                     ((Query) itr.next()).closeResources();\n                 } catch (RuntimeException re) {\n@@ -4283,7 +4278,7 @@ protected void free() {\n \n         if (_extents != null) {\n             Extent e;\n-            for (Iterator itr = _extents.iterator(); itr.hasNext();) {\n+            for (Iterator<?> itr = _extents.iterator(); itr.hasNext();) {\n                 e = (Extent) itr.next();\n                 try {\n                     e.closeAll();\n@@ -4492,7 +4487,7 @@ protected PersistenceCapable assertPersistenceCapable(Object obj) {\n \n         // check for different instances of the PersistenceCapable interface\n         // and throw a better error that mentions the class loaders\n-        Class[] intfs = obj.getClass().getInterfaces();\n+        Class<?>[] intfs = obj.getClass().getInterfaces();\n         for (int i = 0; intfs != null && i < intfs.length; i++) {\n             if (intfs[i].getName().equals(PersistenceCapable.class.getName())) {\n                 throw new UserException(_loc.get(\"pc-loader-different\",\n@@ -4565,7 +4560,7 @@ public void assertWriteOperation() {\n         (Collection failed) {\n         Throwable[] t = new Throwable[failed.size()];\n         int idx = 0;\n-        for (Iterator itr = failed.iterator(); itr.hasNext(); idx++)\n+        for (Iterator<?> itr = failed.iterator(); itr.hasNext(); idx++)\n             t[idx] = new ObjectNotFoundException(itr.next());\n         return new ObjectNotFoundException(failed, t);\n     }\n@@ -4647,8 +4642,8 @@ boolean isSerializing() {\n         implements Set, Serializable {\n \n         private final boolean _orderDirty;\n-        private Set _dirty = null;\n-        private Set _clean = null;\n+        private Set<StateManagerImpl> _dirty = null;\n+        private Set<StateManagerImpl> _clean = null;\n \n         public TransactionalCache(boolean orderDirty) {\n             _orderDirty = orderDirty;\n@@ -4666,10 +4661,10 @@ public Collection copy() {\n             // big by some\n             Set copy = new LinkedHashSet(size());\n             if (_dirty != null)\n-                for (Iterator itr = _dirty.iterator(); itr.hasNext();)\n+                for (Iterator<StateManagerImpl> itr = _dirty.iterator(); itr.hasNext();)\n                     copy.add(itr.next());\n             if (_clean != null)\n-                for (Iterator itr = _clean.iterator(); itr.hasNext();)\n+                for (Iterator<StateManagerImpl> itr = _clean.iterator(); itr.hasNext();)\n                     copy.add(itr.next());\n             return copy;\n         }\n@@ -4680,7 +4675,7 @@ public Collection copy() {\n         public Collection copyDirty() {\n             if (_dirty == null || _dirty.isEmpty())\n                 return Collections.EMPTY_SET;\n-            return new LinkedHashSet(_dirty);\n+            return new LinkedHashSet<StateManagerImpl>(_dirty);\n         }\n \n         /**\n@@ -4713,7 +4708,7 @@ public void addDirty(StateManagerImpl sm) {\n                 if (_orderDirty)\n                     _dirty = MapBackedSet.decorate(new LinkedMap());\n                 else\n-                    _dirty = new HashSet();\n+                    _dirty = new HashSet<StateManagerImpl>();\n             }\n             if (_dirty.add(sm))\n                 removeCleanInternal(sm);\n@@ -4746,7 +4741,7 @@ public boolean contains(Object obj) {\n         }\n \n         public boolean containsAll(Collection coll) {\n-            for (Iterator itr = coll.iterator(); itr.hasNext();)\n+            for (Iterator<?> itr = coll.iterator(); itr.hasNext();)\n                 if (!contains(itr.next()))\n                     return false;\n             return true;"}]}

