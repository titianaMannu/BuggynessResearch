{"sha":"530a190ebb90ffd97adc3a961c6d85c896ea9f41","node_id":"MDY6Q29tbWl0MjA2MzY0OjUzMGExOTBlYmI5MGZmZDk3YWRjM2E5NjFjNmQ4NWM4OTZlYTlmNDE=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-10-28T17:34:45Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-10-28T17:34:45Z"},"message":"OPENJPA-1141: \nOptionally reorder MetaData resolution for entities which use derived IDs\nSubmitted By: Jody Grassel\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@830690 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"71ee3c35bf2bd2b3fcab8c57ad97a2af3d1cc3b8","url":"https://api.github.com/repos/apache/openjpa/git/trees/71ee3c35bf2bd2b3fcab8c57ad97a2af3d1cc3b8"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/530a190ebb90ffd97adc3a961c6d85c896ea9f41","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/530a190ebb90ffd97adc3a961c6d85c896ea9f41","html_url":"https://github.com/apache/openjpa/commit/530a190ebb90ffd97adc3a961c6d85c896ea9f41","comments_url":"https://api.github.com/repos/apache/openjpa/commits/530a190ebb90ffd97adc3a961c6d85c896ea9f41/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"cb31d309b2cb8a8dc77f261abc39195507b6d967","url":"https://api.github.com/repos/apache/openjpa/commits/cb31d309b2cb8a8dc77f261abc39195507b6d967","html_url":"https://github.com/apache/openjpa/commit/cb31d309b2cb8a8dc77f261abc39195507b6d967"}],"stats":{"total":791,"additions":790,"deletions":1},"files":[{"sha":"92635e1f2b896721ed449c6ded0c4f86905ee8a8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","status":"modified","additions":21,"deletions":0,"changes":21,"blob_url":"https://github.com/apache/openjpa/blob/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","raw_url":"https://github.com/apache/openjpa/raw/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java?ref=530a190ebb90ffd97adc3a961c6d85c896ea9f41","patch":"@@ -64,6 +64,7 @@\n     private boolean _superclassDiscriminatorStrategyByDefault = true;\n     private boolean _isAbstractMappingUniDirectional = false;\n     private boolean _isNonDefaultMappingAllowed = false;\n+    private boolean _reorderMetaDataResolution = true;\n     \n     /**\n      * Whether to require exact identity value types when creating object\n@@ -472,5 +473,25 @@ public void setNonDefaultMappingAllowed(boolean isNonDefaultMappingAllowed) {\n     public boolean isNonDefaultMappingAllowed() {\n         return _isNonDefaultMappingAllowed;\n     }\n+    \n+    /**\n+     * Whether OpenJPA should reorder entities in MetaDataRepository.processBuffer() to ensure that the metadata for \n+     * entities with foreign keys in their identity are processed after the entities it depends on.\n+     * \n+     * @return true if the reordering should be performed, false if not.\n+     */\n+    public boolean getReorderMetaDataResolution() {\n+        return _reorderMetaDataResolution;\n+    }\n+    \n+    /**\n+     * Whether OpenJPA should reorder entities in MetaDataRepository.processBuffer() to ensure that the metadata for \n+     * entities with foreign keys in their identity are processed after the entities it depends on.\n+     * \n+     * @param reorderProcessBuffer true if the reordering should be performed, false if not.\n+     */\n+    public void setReorderMetaDataResolution(boolean reorderProcessBuffer) {\n+        _reorderMetaDataResolution = reorderProcessBuffer;\n+    }\n \n }"},{"sha":"9dc45ba557fd93c16e820341317e068d02efb8c3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","status":"modified","additions":199,"deletions":0,"changes":199,"blob_url":"https://github.com/apache/openjpa/blob/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","raw_url":"https://github.com/apache/openjpa/raw/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java?ref=530a190ebb90ffd97adc3a961c6d85c896ea9f41","patch":"@@ -151,6 +151,8 @@\n     private ReentrantLock _lock = null;\n     protected boolean _preload = false;\n     protected boolean _noLock = false;\n+    \n+    private boolean _reorderMetaDataResolution = false;\n \n     /**\n      * Default constructor. Configure via {@link Configurable}.\n@@ -829,6 +831,12 @@ private boolean resolveMapping(ClassMetaData meta) {\n                 buffer.clear();\n             }\n         }\n+        \n+        // Check if process buffer reordering for PCTypes that have relationships to other PCTypes in their identity \n+        // should be performed.\n+        if (_reorderMetaDataResolution) {\n+            processed = resolveFKInPKDependenciesOrdering(processed);\n+        }\n         return processed;\n     }\n \n@@ -1773,6 +1781,7 @@ public void setMetaModel(ClassMetaData meta, Class<?> m2) {\n     public void setConfiguration(Configuration conf) {\n         _conf = (OpenJPAConfiguration) conf;\n         _log = _conf.getLog(OpenJPAConfiguration.LOG_METADATA);\n+        _reorderMetaDataResolution = _conf.getCompatibilityInstance().getReorderMetaDataResolution();\n     }\n \n     public void startConfiguration() {\n@@ -2294,4 +2303,194 @@ protected XMLClassMetaData newXMLClassMetaData(Class<?> type, String name) {\n     public XMLFieldMetaData newXMLFieldMetaData(Class<?> type, String name) {\n         return new XMLFieldMetaData(type, name);\n     }\n+    \n+    /**\n+     * Analyzes the list of ClassMetaData in the supplied list for any which has foreign keys to other ClassMetaData \n+     * instances in its identity (in other words, PCTypes which have primary keys that are foreign keys to other\n+     * tables), and returns a list arranged so that a ClassMetaData that depends on another ClassMetaData appears\n+     * after it in the list.\n+     *\n+     * @param cmdList - List of ClassMetaData to examine\n+     * @return - List of ClassMetaData, with ClassMetaData dependees moved after the last identified dependent \n+     *           ClassMetaData, if any move is necessary.\n+     */\n+    private List<ClassMetaData> resolveFKInPKDependenciesOrdering(List<ClassMetaData> cmdList) {\n+        HashMap<ClassMetaData, CMDDependencyNode> nodeMap = new HashMap<ClassMetaData, CMDDependencyNode>();\n+        HashSet<CMDDependencyNode> nodesWithDependenciesSet = new HashSet<CMDDependencyNode>();\n+        ArrayList<CMDDependencyNode> nodeList = new ArrayList<CMDDependencyNode>(cmdList.size());\n+        \n+        // Initial analysis of ClassMetaData objects -- Populate the linked list with objects in the same order of \n+        // appearance in the original list. Identify CMDs whose identities have a FK to another CMD, and catalog that \n+        // dependency.\n+        for (ClassMetaData cmd : cmdList) {\n+            // Add this node to the list\n+            CMDDependencyNode node = nodeMap.get(cmd);\n+            if (node == null) {\n+                node = new CMDDependencyNode(cmd);\n+                nodeMap.put(cmd, node);\n+            }\n+            nodeList.add(node);\n+            \n+            // Examine its primary key fields, flag any references to another PCType that is defined in cmdList as a \n+            // dependency\n+            FieldMetaData[] fmdArr = cmd.getPrimaryKeyFields();\n+            for (FieldMetaData fmd : fmdArr) {\n+                ValueMetaData vmd = fmd.getValue();\n+                if (vmd.isTypePC()) {\n+                    ClassMetaData targetCMD = vmd.getDeclaredTypeMetaData();\n+\n+                    // Only process entries which are in the cmdList, as we don't want to be adding anything new.\n+                    if (!cmdList.contains(targetCMD)) {\n+                        continue;\n+                    }\n+\n+                    // Register the dependency\n+                    CMDDependencyNode targetNode = null;\n+                    if ((targetNode = nodeMap.get(targetCMD)) == null) {\n+                        targetNode = new CMDDependencyNode(targetCMD);\n+                        nodeMap.put(targetCMD, targetNode);\n+                    }\n+                    node.registerDependentNode(targetNode);\n+                    nodesWithDependenciesSet.add(node);\n+                }\n+            }\n+        }\n+        \n+        // Analysis is complete. For each CMD that has an identity foreign key dependency on another CMD, ensure that it\n+        // appears later in the list then the CMD it is dependent on. If it appears earlier, move it immediately after \n+        // the CMD. If there are multiple CMDs the identity is dependent on, move it after the last dependency in\n+        // the linked list.\n+        for (CMDDependencyNode node : nodesWithDependenciesSet) {\n+            // Check if there is a cycle (dependencies or subdependencies that create a cycle in the graph. If one is \n+            // detected, then this algorithm cannot be used to reorder the CMD list.  Emit a warning, and return the \n+            // original list.\n+            if (node.checkForCycle()) {\n+                if (_log.isWarnEnabled()) {\n+                    _log.warn(_loc.get(\"cmd-discover-cycle\", node.getCmd().getResourceName()));\n+                }\n+                return cmdList;\n+            }\n+ \n+            int nodeIndex = nodeList.indexOf(node);\n+            Set<CMDDependencyNode> dependencies = node.getDependsOnSet();       \n+            \n+            // If the current node has a dependency that appears later in the list, then this node needs\n+            // to be moved to the point immediately after that dependency.\n+            CMDDependencyNode moveAfter = null;\n+            int moveAfterIndex = -1;\n+            for (CMDDependencyNode depNode : dependencies) {               \n+                int dependencyIndex = nodeList.indexOf(depNode);\n+                if ((nodeIndex < dependencyIndex) && (moveAfterIndex < dependencyIndex)) {\n+                    moveAfter = depNode;\n+                    moveAfterIndex = dependencyIndex;\n+                }\n+            }\n+            if (moveAfter != null) {\n+                nodeList.remove(nodeIndex);\n+                nodeList.add(nodeList.indexOf(moveAfter) + 1, node);\n+            }      \n+        }\n+        \n+        // Sorting is complete, build the return list.  Clear the dependsOnSet for the GC.\n+        ArrayList<ClassMetaData> returnList = new ArrayList<ClassMetaData>();\n+        for (CMDDependencyNode current : nodeList) {\n+            returnList.add(current.getCmd());\n+            current.getDependsOnSet().clear();\n+        }\n+        \n+        return returnList;\n+    }\n+\n+\n+    /**\n+     * Linked list node class for managing any foreign keys in the identity of a ClassMetaData instance.\n+     * \n+     */\n+    private class CMDDependencyNode {\n+        private ClassMetaData cmd;\n+\n+        // Marker for quick determination if this node has dependencies\n+        private boolean hasDependencies = false;\n+\n+        // List of ClassMetaData objects this ClassMetaData depends on\n+        private HashSet<CMDDependencyNode> dependsOnSet = new HashSet<CMDDependencyNode>();\n+\n+        /**\n+         * Inner class constructor\n+         */\n+        CMDDependencyNode(ClassMetaData cmd) {\n+            this.cmd = cmd;\n+        }\n+\n+        /**\n+         * Returns the ClassMetaData instance referenced by this node.\n+         */\n+        public ClassMetaData getCmd() {\n+            return cmd;\n+        }\n+\n+        /**\n+         * \n+         * @return true if this node's ClassMetaData has a FK in its identity that refers to another ClassMetaData; \n+         *         false if it does not.\n+         */\n+        public boolean getHasDependencies() {\n+            return hasDependencies;\n+        }\n+\n+        /**\n+         * Registers a ClassMetaData modelled by a CMDDependencyNode as a dependency of this ClassMetaData.\n+         * \n+         */\n+        public void registerDependentNode(CMDDependencyNode node) {\n+            getDependsOnSet().add(node);\n+            hasDependencies = true;\n+        }\n+\n+        /**\n+         * Returns a Set containing all of the CMDDependencyNode instances that this node has a FK in identity \n+         * dependency on.\n+         * \n+         */\n+        public Set<CMDDependencyNode> getDependsOnSet() {\n+            return dependsOnSet;\n+        }\n+\n+        /**\n+         * Checks all dependencies, and sub-dependencies, for any cycles in the dependency graph.\n+         * \n+         * @return true if a cycle was discovered, false if not.\n+         */\n+        public boolean checkForCycle() {\n+            java.util.Stack<CMDDependencyNode> visitStack = new java.util.Stack<CMDDependencyNode>();\n+            return internalCheckForCycle(visitStack);\n+        }\n+\n+        /**\n+         * Internal implementation of the cycle detection.\n+         * \n+         * @param visitStack\n+         * @return true if a cycle is detected, false if no cycle was detected.\n+         */\n+        private boolean internalCheckForCycle(java.util.Stack<CMDDependencyNode> visitStack) {\n+            if (visitStack.contains(this)) {\n+                return true;\n+            }\n+            visitStack.push(this);\n+\n+            try {\n+                for (CMDDependencyNode node : dependsOnSet) {\n+                    if (node.getHasDependencies()) {\n+                        if (node.internalCheckForCycle(visitStack) == true) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            } finally {\n+                visitStack.pop();\n+            }\n+            \n+            return false;\n+        }\n+    }\n }"},{"sha":"e898d71b16906d69defd1da49af0559aead53d37","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties?ref=530a190ebb90ffd97adc3a961c6d85c896ea9f41","patch":"@@ -347,4 +347,7 @@ repos-preload-none: No persistent metadata found for loading during initializati\n \tThe persistent classes must be enlisted in configuration to be loaded during initialization.  \n repos-preloading: Following metadata are being loaded during initialization by \"{0}\": {1}. \n repos-preload-error: Unexpected error during early loading during initialization. \\\n-\tSee nested stacktrace for details. \t  \n\\ No newline at end of file\n+\tSee nested stacktrace for details. \t  \n+cmd-discover-cycle: A cycle was detected while resolving the identity \\\n+    references for type \"{0}\".  The original process buffer ordering \\\n+    will be used.\n\\ No newline at end of file"},{"sha":"ab7cffc9e234c119f76408bd5f1d2aa2cd41148b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/Account.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/Account.java","raw_url":"https://github.com/apache/openjpa/raw/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/Account.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/Account.java?ref=530a190ebb90ffd97adc3a961c6d85c896ea9f41","patch":"@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.identity.entityasidentity;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.IdClass;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.Table;\n+\n+@Entity\n+@Table(name=\"EAIAccount\")\n+@IdClass(AccountId.class)\n+public class Account {\n+    @Id\n+    @Column(name=\"account_id\")\n+    private Integer accountId;\n+    \n+    @Id\n+    @Column(name=\"group_id\")\n+    private Integer groupId;\n+    \n+    @Id\n+    @ManyToOne(cascade = CascadeType.ALL)\n+    @JoinColumn(name=\"accountHolder_id\")\n+    private Person accountHolder;\n+    \n+    private long balanceInDollars;\n+    private int  balanceInCents;\n+    private boolean accountLocked;\n+    \n+    public Account() {\n+        \n+    }\n+\n+    public Integer getAccountId() {\n+        return accountId;\n+    }\n+\n+    public void setAccountId(Integer accountId) {\n+        this.accountId = accountId;\n+    }\n+\n+    public Integer getGroupId() {\n+        return groupId;\n+    }\n+\n+    public void setGroupId(Integer groupId) {\n+        this.groupId = groupId;\n+    }\n+\n+    public Person getAccountHolder() {\n+        return accountHolder;\n+    }\n+\n+    public void setAccountHolder(Person accountHolder) {\n+        this.accountHolder = accountHolder;\n+    }\n+\n+    public long getBalanceInDollars() {\n+        return balanceInDollars;\n+    }\n+\n+    public void setBalanceInDollars(long balanceInDollars) {\n+        this.balanceInDollars = balanceInDollars;\n+    }\n+\n+    public int getBalanceInCents() {\n+        return balanceInCents;\n+    }\n+\n+    public void setBalanceInCents(int balanceInCents) {\n+        this.balanceInCents = balanceInCents;\n+    }\n+\n+    public boolean isAccountLocked() {\n+        return accountLocked;\n+    }\n+\n+    public void setAccountLocked(boolean accountLocked) {\n+        this.accountLocked = accountLocked;\n+    }\n+    \n+    \n+}"},{"sha":"d35d6388750bee1cf1f93a6e8e56d43710130e1f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/AccountGroup.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/AccountGroup.java","raw_url":"https://github.com/apache/openjpa/raw/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/AccountGroup.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/AccountGroup.java?ref=530a190ebb90ffd97adc3a961c6d85c896ea9f41","patch":"@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.identity.entityasidentity;\n+\n+import java.util.Set;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.Id;\n+import javax.persistence.OneToMany;\n+import javax.persistence.Table;\n+\n+@Entity\n+@Table(name=\"EAIAccountGroup\")\n+public class AccountGroup {\n+    @Id\n+    private Integer id;\n+    \n+    @OneToMany(cascade={CascadeType.ALL}, fetch=FetchType.LAZY)\n+    private Set<Account> accountSet;\n+    \n+    public AccountGroup() {\n+        accountSet = new java.util.HashSet<Account>();\n+    }\n+\n+    public Integer getId() {\n+        return id;\n+    }\n+\n+    public void setId(Integer id) {\n+        this.id = id;\n+    }\n+\n+    public Set<Account> getAccountSet() {\n+        return accountSet;\n+    }\n+\n+    public void setAccountSet(Set<Account> accountSet) {\n+        this.accountSet = accountSet;\n+    }\n+    \n+    \n+}"},{"sha":"c89626521de8a6aaa7f13265aeea0e167e16f901","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/AccountId.java","status":"added","additions":84,"deletions":0,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/AccountId.java","raw_url":"https://github.com/apache/openjpa/raw/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/AccountId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/AccountId.java?ref=530a190ebb90ffd97adc3a961c6d85c896ea9f41","patch":"@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.identity.entityasidentity;\n+\n+public class AccountId implements java.io.Serializable {\n+    private static final long serialVersionUID = 4262907482129342511L;\n+    \n+    private Integer accountId;\n+    private Integer groupId;\n+    private Integer accountHolder;\n+    \n+    private Integer hashcode = null;\n+    \n+    public AccountId() {\n+        \n+    }\n+\n+    public Integer getAccountId() {\n+        return accountId;\n+    }\n+\n+    public void setAccountId(Integer accountId) {\n+        this.accountId = accountId;\n+    }\n+    \n+\n+    public Integer getGroupId() {\n+        return groupId;\n+    }\n+\n+    public void setGroupId(Integer groupId) {\n+        this.groupId = groupId;\n+    }\n+\n+    public Integer getAccountHolder() {\n+        return accountHolder;\n+    }\n+\n+    public void setAccountHolder(Integer accountHolder) {\n+        this.accountHolder = accountHolder;\n+    }\n+    \n+    public boolean equals(Object o) {\n+        if (o == this) {\n+            return true;\n+        }\n+            \n+        if (o instanceof AccountId) {\n+            AccountId oId = (AccountId) o;\n+            if (    oId.accountId.equals(this.accountId) && \n+                    oId.accountHolder.equals(this.accountHolder) &&\n+                    oId.groupId.equals(this.groupId)) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    public int hashCode() {\n+        if (hashcode == null) {\n+            String hashStr = this.groupId + \":\" + this.accountHolder + \":\" + this.accountId;\n+            hashcode = hashStr.hashCode();\n+        }\n+        return hashcode.intValue();\n+    }\n+    \n+}"},{"sha":"02e45c351681837400eed475a8cda9438c26eb3c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/Person.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/Person.java","raw_url":"https://github.com/apache/openjpa/raw/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/Person.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/Person.java?ref=530a190ebb90ffd97adc3a961c6d85c896ea9f41","patch":"@@ -0,0 +1,61 @@\n+/*\n+s * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.identity.entityasidentity;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.Table;\n+\n+@Entity\n+@Table(name=\"EAIPerson\")\n+public class Person {\n+    @Id\n+    private Integer id;\n+    \n+    private String firstName;\n+    private String lastName;\n+    \n+    public Person() {\n+        \n+    }\n+\n+    public Integer getId() {\n+        return id;\n+    }\n+\n+    public void setId(Integer id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+\n+    public void setFirstName(String firstName) {\n+        this.firstName = firstName;\n+    }\n+\n+    public String getLastName() {\n+        return lastName;\n+    }\n+\n+    public void setLastName(String lastName) {\n+        this.lastName = lastName;\n+    }\n+}"},{"sha":"0b1f5be8a74f5fc5c88b65fd805b3718e3d8a75e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/TestEntityAsIdentityFields.java","status":"added","additions":257,"deletions":0,"changes":257,"blob_url":"https://github.com/apache/openjpa/blob/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/TestEntityAsIdentityFields.java","raw_url":"https://github.com/apache/openjpa/raw/530a190ebb90ffd97adc3a961c6d85c896ea9f41/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/TestEntityAsIdentityFields.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/entityasidentity/TestEntityAsIdentityFields.java?ref=530a190ebb90ffd97adc3a961c6d85c896ea9f41","patch":"@@ -0,0 +1,257 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.identity.entityasidentity;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.Query;\n+\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+public class TestEntityAsIdentityFields extends SingleEMFTestCase {    \n+    public void setUp() {\n+        setUp(\n+                Account.class, AccountGroup.class, Person.class,\n+                \"openjpa.Compatibility\", \"reorderMetaDataResolution=true\");\n+    }\n+    \n+    /**\n+     * Tests for the NullPointerException in MappingInfo.mergeJoinColumn reported in OpenJPA-1141.\n+     * \n+     */\n+    public void testEntityAsIdentityField001() {\n+        EntityManager em = null;\n+        em = emf.createEntityManager();\n+        \n+        Query query = em.createQuery(\"SELECT ag from AccountGroup ag\");\n+        List resultList = query.getResultList();\n+        \n+        em.close();\n+    }\n+    \n+    /**\n+     * Test EntityManager persist() and find() with entities with entity relationships as\n+     * part of their identity.  Clears persistence context between entity create and find.\n+     * \n+     */\n+    public void testEntityAsIdentityField002A() {\n+        EntityManager em = null;\n+        \n+        try {\n+            em = emf.createEntityManager();\n+            \n+            // Create population\n+            createPopulation(em);\n+            \n+            // Clear persistence context, fetch from database\n+            em.clear();\n+            AccountId aId = new AccountId();\n+            aId.setAccountId(1);\n+            aId.setAccountHolder(1);\n+            aId.setGroupId(1);\n+            Account findAccount = em.find(Account.class, aId);\n+            assertTrue(findAccount != null);\n+        } finally {\n+            // Cleanup\n+            if (em != null) {\n+                if (em.getTransaction().isActive()) {\n+                    em.getTransaction().rollback();\n+                }\n+                em.close();\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Test EntityManager persist() and find() with entities with entity relationships as\n+     * part of their identity.  Does not clear persistence context between entity create and find.\n+     * \n+     */\n+    public void testEntityAsIdentityField002B() {\n+        EntityManager em = null;\n+        \n+        try {\n+            em = emf.createEntityManager();\n+            \n+            // Create population\n+            createPopulation(em);\n+            \n+            // Fetch from database\n+            AccountId aId = new AccountId();\n+            aId.setAccountId(1);\n+            aId.setAccountHolder(1);\n+            aId.setGroupId(1);\n+            Account findAccount = em.find(Account.class, aId);\n+            assertTrue(findAccount != null);\n+        } finally {\n+            // Cleanup\n+            if (em != null) {\n+                if (em.getTransaction().isActive()) {\n+                    em.getTransaction().rollback();\n+                }\n+                em.close();\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Test EntityManager persist() and find() with entities with entity relationships as\n+     * part of their identity.  Uses different EntityManagers for create and find.\n+     * \n+     */\n+    public void testEntityAsIdentityField002C() {\n+        EntityManager em = null;\n+        EntityManager emPop = null;\n+        \n+        try {\n+            emPop = emf.createEntityManager();\n+            em = emf.createEntityManager();\n+            \n+            // Create population\n+            createPopulation(emPop);\n+            \n+            // Clear persistence context, fetch from database\n+            em.clear();\n+            AccountId aId = new AccountId();\n+            aId.setAccountId(1);\n+            aId.setAccountHolder(1);\n+            aId.setGroupId(1);\n+            Account findAccount = em.find(Account.class, aId);\n+            assertTrue(findAccount != null);\n+        } finally {\n+            // Cleanup\n+            if (em != null) {\n+                if (em.getTransaction().isActive()) {\n+                    em.getTransaction().rollback();\n+                }\n+                em.close();\n+            }\n+            if (emPop != null) {\n+                if (emPop.getTransaction().isActive()) {\n+                    emPop.getTransaction().rollback();\n+                }\n+                emPop.close();\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Test a query with a where clause that crosses through the identity relationship.\n+     * Clear persistence context before performing the query.\n+     * \n+     */\n+    public void testEntityAsIdentityField003A() {\n+        EntityManager em = null;\n+        \n+        try {\n+            em = emf.createEntityManager();\n+            \n+            // Create population\n+            createPopulation(em);\n+            em.clear();\n+            \n+            Query query = em.createQuery(\"SELECT a FROM Account a WHERE a.accountHolder.id > 5\");\n+            List resultList = query.getResultList();\n+            assertEquals(5, resultList.size());\n+        } finally {\n+            // Cleanup\n+            if (em != null) {\n+                if (em.getTransaction().isActive()) {\n+                    em.getTransaction().rollback();\n+                }\n+                em.close();\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Test a query with a where clause that crosses through the identity relationship.\n+     * Use a separate EntityManager to populate the database, and a separate EntityManager\n+     * to perform the query\n+     * \n+     */\n+    public void testEntityAsIdentityField004A() {\n+        EntityManager em = null;\n+        EntityManager emPop = null;\n+        \n+        try {\n+            emPop = emf.createEntityManager();\n+            em = emf.createEntityManager();\n+            \n+            // Create population\n+            createPopulation(emPop);\n+            em.clear();\n+            \n+            Query query = em.createQuery(\"SELECT a FROM Account a WHERE a.accountHolder.id > 5\");\n+            List resultList = query.getResultList();\n+            assertEquals(5, resultList.size());\n+        } finally {\n+            // Cleanup\n+            if (em != null) {\n+                if (em.getTransaction().isActive()) {\n+                    em.getTransaction().rollback();\n+                }\n+                em.close();\n+            }\n+            if (emPop != null) {\n+                if (emPop.getTransaction().isActive()) {\n+                    emPop.getTransaction().rollback();\n+                }\n+                emPop.close();\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Database population\n+     * \n+     */\n+    private void createPopulation(EntityManager em) {\n+        em.getTransaction().begin();\n+        \n+        AccountGroup ag = new AccountGroup();\n+        ag.setId(1);\n+        Set<Account> agAccountSet = ag.getAccountSet();\n+        em.persist(ag);\n+        \n+        for (int index = 1; index <= 10; index++) {\n+            Person peep = new Person();\n+            peep.setId(index);\n+            peep.setFirstName(\"John\");\n+            peep.setLastName(\"Doe\");\n+            \n+            Account account = new Account();\n+            account.setAccountId(index);\n+            account.setAccountHolder(peep);\n+            account.setGroupId((index / 5) + 1);\n+            \n+            account.setBalanceInCents(0);\n+            account.setBalanceInDollars(index * 1000);\n+                       \n+            em.persist(peep);\n+            em.persist(account);\n+            \n+            agAccountSet.add(account);\n+        }    \n+        \n+        em.getTransaction().commit();\n+    }\n+}"}]}

