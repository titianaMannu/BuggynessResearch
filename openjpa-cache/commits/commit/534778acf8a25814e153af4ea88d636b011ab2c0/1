{"sha":"534778acf8a25814e153af4ea88d636b011ab2c0","node_id":"MDY6Q29tbWl0MjA2MzY0OjUzNDc3OGFjZjhhMjU4MTRlMTUzYWY0ZWE4OGQ2MzZiMDExYWIyYzA=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-05-23T21:35:32Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-05-23T21:35:32Z"},"message":"OPENJPA-610 Test cases to identify use cases where behavior differs because of DataCache\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@659669 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"478315e0282e010517d8f71a4975baaeeeb1129a","url":"https://api.github.com/repos/apache/openjpa/git/trees/478315e0282e010517d8f71a4975baaeeeb1129a"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/534778acf8a25814e153af4ea88d636b011ab2c0","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/534778acf8a25814e153af4ea88d636b011ab2c0","html_url":"https://github.com/apache/openjpa/commit/534778acf8a25814e153af4ea88d636b011ab2c0","comments_url":"https://api.github.com/repos/apache/openjpa/commits/534778acf8a25814e153af4ea88d636b011ab2c0/comments","author":null,"committer":null,"parents":[{"sha":"93e15d846c2338b979d8a08408bce95c31c4598f","url":"https://api.github.com/repos/apache/openjpa/commits/93e15d846c2338b979d8a08408bce95c31c4598f","html_url":"https://github.com/apache/openjpa/commit/93e15d846c2338b979d8a08408bce95c31c4598f"}],"stats":{"total":783,"additions":783,"deletions":0},"files":[{"sha":"58fad63659245584e3f0da47a20369f17e6850ad","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwned.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/apache/openjpa/blob/534778acf8a25814e153af4ea88d636b011ab2c0/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwned.java","raw_url":"https://github.com/apache/openjpa/raw/534778acf8a25814e153af4ea88d636b011ab2c0/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwned.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwned.java?ref=534778acf8a25814e153af4ea88d636b011ab2c0","patch":"@@ -0,0 +1,89 @@\n+package org.apache.openjpa.persistence.cache.common.apps;\r\n+\r\n+import javax.persistence.*;\r\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+\r\n+/**\r\n+ * A persistent entity that is owned by unidirectional single-valued \r\n+ * relationship.\r\n+ * A unidirectional relationship has only one owning side and the other side\r\n+ * called as owned side is this receiver.\r\n+ * Given the following relationship between Entity A and Entity B:\r\n+ *   Entity A refers a single instance of Entity B \r\n+ *   Entity B does not refer Entity A (owner)\r\n+ * Entity A is called owner and Entity B is called owned with respect\r\n+ * to the above relationship.\r\n+ * \r\n+ * Used to test identical application behavior with or without DataCache.\r\n+ * \r\n+ * @see BidirectionalOne2OneOwned\r\n+ * @see TestDataCacheBehavesIdentical\r\n+ * @see Section 2.1.8.3 of JPA Specification Version 1.0\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ *\r\n+ */\r\n+\r\n+@Entity\r\n+public class BidirectionalOne2OneOwned {\r\n+\t@Id\r\n+\tprivate long id;\r\n+\t\r\n+\tprivate String name;\r\n+\t\r\n+\t@OneToOne(mappedBy=\"owned\")\r\n+\tprivate BidirectionalOne2OneOwner owner;\r\n+\t\r\n+\t@Version\r\n+\tprivate int version;\r\n+\r\n+\tpublic long getId() {\r\n+\t\treturn id;\r\n+\t}\r\n+\r\n+\tpublic void setId(long id) {\r\n+\t\tthis.id = id;\r\n+\t}\r\n+\r\n+\tpublic String getName() {\r\n+\t\treturn name;\r\n+\t}\r\n+\r\n+\tpublic void setName(String name) {\r\n+\t\tthis.name = name;\r\n+\t}\r\n+\r\n+\tpublic BidirectionalOne2OneOwner getOwner() {\r\n+\t\treturn owner;\r\n+\t}\r\n+\r\n+\tpublic void setOwner(BidirectionalOne2OneOwner owner) {\r\n+\t\tthis.owner = owner;\r\n+\t}\r\n+\r\n+\tpublic int getVersion() {\r\n+\t\treturn version;\r\n+\t}\r\n+\t\r\n+\tpublic String toString() {\r\n+\t\treturn this.getClass().getSimpleName() + \":\" + id + \":\" + name;\r\n+\t}\r\n+\r\n+}\r"},{"sha":"6c0c9a9748b38a2cc4011045a29a2480e823fcda","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwner.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/534778acf8a25814e153af4ea88d636b011ab2c0/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwner.java","raw_url":"https://github.com/apache/openjpa/raw/534778acf8a25814e153af4ea88d636b011ab2c0/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwner.java?ref=534778acf8a25814e153af4ea88d636b011ab2c0","patch":"@@ -0,0 +1,86 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+\r\n+package org.apache.openjpa.persistence.cache.common.apps;\r\n+\r\n+import javax.persistence.*;\r\n+\r\n+/**\r\n+ * A persistent entity that owns bidirectional single-valued relationship.\r\n+ * A bidirectional relationship has only an owning side, which is this receiver.\r\n+ * Given the following relationship between Entity A and Entity B:\r\n+ *   Entity A refers to a single instance of Entity B \r\n+ *   Entity B refers to a single instance of Entity A \r\n+ * If Entity B qualifies its relation to the Entity A with mappedBy \r\n+ * annotation qualifier then Entity B is called owned and Entity A is called \r\n+ * owner with respect to the above relationship.\r\n+ * \r\n+ * Used to test identical application behavior with or without DataCache.\r\n+ * \r\n+ * @see BidirectionalOne2OneOwned\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ *\r\n+ */\r\n+@Entity\r\n+public class BidirectionalOne2OneOwner {\r\n+\t@Id\r\n+\tprivate long id;\r\n+\t\r\n+\tprivate String name;\r\n+\t\r\n+\t@OneToOne\r\n+\tprivate BidirectionalOne2OneOwned owned;\r\n+\t\r\n+\t@Version\r\n+\tprivate int version;\r\n+\r\n+\tpublic long getId() {\r\n+\t\treturn id;\r\n+\t}\r\n+\r\n+\tpublic void setId(long id) {\r\n+\t\tthis.id = id;\r\n+\t}\r\n+\r\n+\tpublic String getName() {\r\n+\t\treturn name;\r\n+\t}\r\n+\r\n+\tpublic void setName(String name) {\r\n+\t\tthis.name = name;\r\n+\t}\r\n+\r\n+\tpublic BidirectionalOne2OneOwned getOwned() {\r\n+\t\treturn owned;\r\n+\t}\r\n+\r\n+\tpublic void setOwned(BidirectionalOne2OneOwned owned) {\r\n+\t\tthis.owned = owned;\r\n+\t}\r\n+\t\r\n+\tpublic int getVersion() {\r\n+\t\treturn version;\r\n+\t}\r\n+\t\r\n+\tpublic String toString() {\r\n+\t\treturn this.getClass().getSimpleName() + \":\" + id + \":\" + name;\r\n+\t}\r\n+\r\n+}\r"},{"sha":"35243e180616299804cf8227419f853cede52bc2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwned.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/534778acf8a25814e153af4ea88d636b011ab2c0/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwned.java","raw_url":"https://github.com/apache/openjpa/raw/534778acf8a25814e153af4ea88d636b011ab2c0/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwned.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwned.java?ref=534778acf8a25814e153af4ea88d636b011ab2c0","patch":"@@ -0,0 +1,77 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+\r\n+package org.apache.openjpa.persistence.cache.common.apps;\r\n+\r\n+import javax.persistence.*;\r\n+/**\r\n+ * A persistent entity that is owned by unidirectional single-valued \r\n+ * relationship.\r\n+ * A unidirectional relationship has only one owning side and the other side\r\n+ * called as owned side is this receiver.\r\n+ * Given the following relationship between Entity A and Entity B:\r\n+ *   Entity A refers a single instance of Entity B \r\n+ *   Entity B does not refer Entity A (owner)\r\n+ * Entity A is called owner and Entity B is called owned with respect\r\n+ * to the above relationship.\r\n+ * \r\n+ * Used to test identical application behavior with or without DataCache.\r\n+ * \r\n+ * @see UnidirectionalOne2OneOwned\r\n+ * @see TestDataCacheBehavesIdentical\r\n+ * @see Section 2.1.8.3 of JPA Specification Version 1.0\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ *\r\n+ */\r\n+\r\n+@Entity\r\n+public class UnidirectionalOne2OneOwned {\r\n+\t@Id\r\n+\tprivate long id;\r\n+\t\r\n+\tprivate String name;\r\n+\t\r\n+\t@Version\r\n+\tprivate int version;\r\n+\r\n+\tpublic long getId() {\r\n+\t\treturn id;\r\n+\t}\r\n+\r\n+\tpublic void setId(long id) {\r\n+\t\tthis.id = id;\r\n+\t}\r\n+\r\n+\tpublic String getName() {\r\n+\t\treturn name;\r\n+\t}\r\n+\r\n+\tpublic void setName(String name) {\r\n+\t\tthis.name = name;\r\n+\t}\r\n+\r\n+\tpublic int getVersion() {\r\n+\t\treturn version;\r\n+\t}\r\n+\t\r\n+\tpublic String toString() {\r\n+\t\treturn this.getClass().getSimpleName() + \":\" + id + \":\" + name;\r\n+\t}\r\n+}\r"},{"sha":"84922b101a82b7722795230ef3dbe334789fb08a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwner.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/534778acf8a25814e153af4ea88d636b011ab2c0/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwner.java","raw_url":"https://github.com/apache/openjpa/raw/534778acf8a25814e153af4ea88d636b011ab2c0/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwner.java?ref=534778acf8a25814e153af4ea88d636b011ab2c0","patch":"@@ -0,0 +1,87 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+\r\n+package org.apache.openjpa.persistence.cache.common.apps;\r\n+\r\n+import javax.persistence.*;\r\n+\r\n+/**\r\n+ * A persistent entity that owns unidirectional single-valued relationship.\r\n+ * A unidirectional relationship has only one owning side, which is this \r\n+ * receiver.\r\n+ * Given the following relationship between Entity A and Entity B:\r\n+ *   Entity A refers a single instance of Entity B \r\n+ *   Entity B does not refer Entity A (owner)\r\n+ * Entity A is called owner and Entity B is called owned with respect\r\n+ * to the above relationship.\r\n+ * \r\n+ * Used to test identical application behavior with or without DataCache.\r\n+ * \r\n+ * @see UnidirectionalOne2OneOwned\r\n+ * @see TestDataCacheBehavesIdentical\r\n+ * @see Section 2.1.8.3 of JPA Specification Version 1.0\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ *\r\n+ */\r\n+@Entity\r\n+public class UnidirectionalOne2OneOwner {\r\n+\t@Id\r\n+\tprivate long id;\r\n+\t\r\n+\tprivate String name;\r\n+\t\r\n+\t@OneToOne\r\n+\tprivate UnidirectionalOne2OneOwned owned;\r\n+\t\r\n+\t@Version\r\n+\tprivate int version;\r\n+\r\n+\tpublic long getId() {\r\n+\t\treturn id;\r\n+\t}\r\n+\r\n+\tpublic void setId(long id) {\r\n+\t\tthis.id = id;\r\n+\t}\r\n+\r\n+\tpublic String getName() {\r\n+\t\treturn name;\r\n+\t}\r\n+\r\n+\tpublic void setName(String name) {\r\n+\t\tthis.name = name;\r\n+\t}\r\n+\r\n+\tpublic UnidirectionalOne2OneOwned getOwned() {\r\n+\t\treturn owned;\r\n+\t}\r\n+\r\n+\tpublic void setOwned(UnidirectionalOne2OneOwned owned) {\r\n+\t\tthis.owned = owned;\r\n+\t}\r\n+\t\r\n+\tpublic int getVersion() {\r\n+\t\treturn version;\r\n+\t}\r\n+\t\r\n+\tpublic String toString() {\r\n+\t\treturn this.getClass().getSimpleName() + \":\" + id + \":\" + name;\r\n+\t}\r\n+}\r"},{"sha":"56c800036ae70a3c88861b7707d1c8b7b7e36abb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheBehavesIdentical.java","status":"added","additions":444,"deletions":0,"changes":444,"blob_url":"https://github.com/apache/openjpa/blob/534778acf8a25814e153af4ea88d636b011ab2c0/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheBehavesIdentical.java","raw_url":"https://github.com/apache/openjpa/raw/534778acf8a25814e153af4ea88d636b011ab2c0/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheBehavesIdentical.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheBehavesIdentical.java?ref=534778acf8a25814e153af4ea88d636b011ab2c0","patch":"@@ -0,0 +1,444 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.persistence.datacache;\r\n+\r\n+import javax.persistence.EntityManager;\r\n+import javax.persistence.EntityNotFoundException;\r\n+import javax.persistence.LockModeType;\r\n+\r\n+import org.apache.openjpa.persistence.EntityManagerImpl;\r\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\r\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerSPI;\r\n+import org.apache.openjpa.persistence.StoreCache;\r\n+import org.apache.openjpa.persistence.StoreCacheImpl;\r\n+import org.apache.openjpa.persistence.cache.common.apps.BidirectionalOne2OneOwned;\r\n+import org.apache.openjpa.persistence.cache.common.apps.BidirectionalOne2OneOwner;\r\n+import org.apache.openjpa.persistence.common.utils.AbstractTestCase;\r\n+import org.apache.openjpa.persistence.exception.PObject;\r\n+\r\n+/**\r\n+ * Tests various application behavior with or without DataCache.\r\n+ * Ideally, an application should behave identically irrespective of the \r\n+ * DataCache. However, purpose of this test is to identify specific scenarios\r\n+ * where this ideal is violated. The test case also demonstrates, wherever\r\n+ * possible, what extra step an application may take to ensure that its \r\n+ * behavior with or without DataCache remains identical.   \r\n+ * \r\n+ * So far following use cases are found to demonstrate behavioral differences:\r\n+ * 1. Inconsistent bidirectional relation\r\n+ * 2. Refresh\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ * \r\n+ */\r\n+public class TestDataCacheBehavesIdentical extends AbstractTestCase {\r\n+\tprivate static OpenJPAEntityManagerFactorySPI emfWithDataCache;\r\n+\tprivate static OpenJPAEntityManagerFactorySPI emfWithoutDataCache;\r\n+\t\r\n+\tprivate static final boolean WITH_DATACACHE = true;\r\n+\tprivate static final boolean CONSISTENT = true;\r\n+\tprivate static final boolean DIRTY = true;\r\n+\tprivate static final LockModeType NOLOCK = null;\r\n+\r\n+\tprivate static final String MARKER_DATACACHE = \"in DataCache\";\r\n+\tprivate static final String MARKER_DATABASE  = \"in Database\";\r\n+\tprivate static final String MARKER_CACHE     = \"in Object Cache\";\r\n+\tprivate static final String MARKER_DIRTY_CACHE = \"in Object Cache (dirty)\";\r\n+\tprivate static long ID_COUNTER = System.currentTimeMillis();\r\n+\t\r\n+\r\n+\t/**\r\n+\t * Sets up two EntityManagerFactory: one with DataCache another without.\r\n+\t */\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tsuper.setUp();\r\n+\t\tif (emfWithDataCache == null) {\r\n+\t\t\temfWithDataCache = createEMF(\r\n+\t\t\t\t\t\"openjpa.jdbc.SynchronizeMappings\",\t\"buildSchema\", \r\n+\t\t\t\t\t\"openjpa.RuntimeUnenhancedClasses\",\t\"unsupported\", \r\n+\t\t\t\t\t\"openjpa.DataCache\", \"true\",\r\n+\t\t\t\t\t\"openjpa.RemoteCommitProvider\", \"sjvm\",\r\n+\t\t\t\t\t\"openjpa.jdbc.UpdateManager\", \"constraint\",\r\n+\t\t\t\t\tPObject.class,\r\n+\t\t\t\t\tBidirectionalOne2OneOwner.class,\r\n+\t\t\t\t\tBidirectionalOne2OneOwned.class, CLEAR_TABLES);\r\n+\t\t\temfWithoutDataCache = createEMF(\r\n+\t\t\t\t\t\"openjpa.RuntimeUnenhancedClasses\",\t\"unsupported\", \r\n+\t\t\t\t\t\"openjpa.DataCache\", \"false\",\r\n+\t\t\t\t\t\"openjpa.jdbc.UpdateManager\", \"constraint\",\r\n+\t\t\t\t\tPObject.class,\r\n+\t\t\t\t\tBidirectionalOne2OneOwned.class,\r\n+\t\t\t\t\tBidirectionalOne2OneOwner.class, CLEAR_TABLES);\r\n+\r\n+\t\t\tassertNotNull(emfWithDataCache);\r\n+\t\t\tassertNotNull(emfWithoutDataCache);\r\n+\r\n+\t\t\t// StoreCache is, by design, always non-null \r\n+\t\t\tassertNotNull(emfWithDataCache.getStoreCache());\r\n+\t\t\tassertNotNull(emfWithoutDataCache.getStoreCache());\r\n+\r\n+\t\t\t// however, following distinguishes whether DataCache is active  \r\n+\t\t\tassertTrue(isDataCacheActive(emfWithDataCache));\r\n+\t\t\tassertFalse(isDataCacheActive(emfWithoutDataCache));\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Affirms via internal structures if the given factory is configured with\r\n+\t * active DataCache. Because, even when DataCache is configured to be\r\n+\t * false, a no-op StoreCache is instantiated by design.\r\n+\t */\r\n+\tboolean isDataCacheActive(OpenJPAEntityManagerFactorySPI emf) {\r\n+\t\treturn ((StoreCacheImpl) emf.getStoreCache()).getDelegate() != null\r\n+\t\t    && emf.getConfiguration()\r\n+\t\t          .getDataCacheManagerInstance()\r\n+\t\t          .getSystemDataCache() != null;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create one-to-one bidirectional relation (may or may not be consistent)\r\n+\t * between two pairs of instances. Creates four instances Owner1, Owned1,\r\n+\t * Owner2, Owned2. The first instance has the given id. The id of the other\r\n+\t * instances monotonically increase by 1. The relationship is set either\r\n+\t * consistently or inconsistently. Consistent relation is when Owner1 points\r\n+\t * to Owned1 and Owned1 points back to Owner1. Inconsistent relation is when\r\n+\t * Owner1 points to Owned1 but Owned1 points to Owner2 instead of Owner1.\r\n+\t * \r\n+\t * \r\n+\t * @param em\r\n+\t *            the entity manager to persist the instances\r\n+\t * @param id\r\n+\t *            the identifier of the first owner instance. The identifier for\r\n+\t *            the other instances are sequential in order of creation.\r\n+\t * @param consistent\r\n+\t *            if true sets the relationship as consistent.\r\n+\t */\r\n+\tpublic void createBidirectionalRelation(EntityManager em, long id,\r\n+\t\t\tboolean consistent) {\r\n+\t\tBidirectionalOne2OneOwner owner1 = new BidirectionalOne2OneOwner();\r\n+\t\tBidirectionalOne2OneOwned owned1 = new BidirectionalOne2OneOwned();\r\n+\t\tBidirectionalOne2OneOwner owner2 = new BidirectionalOne2OneOwner();\r\n+\t\tBidirectionalOne2OneOwned owned2 = new BidirectionalOne2OneOwned();\r\n+\t\t\r\n+\t\towner1.setId(id++);\r\n+\t\towned1.setId(id++);\r\n+\t\towner2.setId(id++);\r\n+\t\towned2.setId(id++);\r\n+\t\t\r\n+\t\towner1.setName(\"Owner1\");\r\n+\t\towned1.setName(\"Owned1\");\r\n+\t\towned2.setName(\"Owned2\");\r\n+\t\towner2.setName(\"Owner2\");\r\n+\r\n+\t\towner1.setOwned(owned1);\r\n+\t\towner2.setOwned(owned2);\r\n+\r\n+\t\tif (consistent) {\r\n+\t\t\towned1.setOwner(owner1);\r\n+\t\t\towned2.setOwner(owner2);\r\n+\t\t} else {\r\n+\t\t\towned1.setOwner(owner2);\r\n+\t\t\towned2.setOwner(owner1);\r\n+\t\t}\r\n+\r\n+\t\tem.getTransaction().begin();\r\n+\t\tem.persist(owner1);\r\n+\t\tem.persist(owned1);\r\n+\t\tem.persist(owner2);\r\n+\t\tem.persist(owned2);\r\n+\t\tem.getTransaction().commit();\r\n+\t\tem.clear();\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Verifies that bidirectionally related objects can be persisted \r\n+\t * and later retrieved in a different transaction. \r\n+\t * \r\n+\t * Creates interrelated set of four instances.\r\n+\t * Establish their relation either consistently or inconsistently based\r\n+\t * on the given flag.\r\n+\t * Persist them and then clear the context. \r\n+\t * Fetch the instances in memory again by their identifiers. \r\n+\t * Compare the interrelations between the fetched instances with the \r\n+\t * relations of the original instances (which can be consistent or \r\n+\t * inconsistent). \r\n+\t * \r\n+\t * The mapping specification is such that the bidirectional relation is \r\n+\t * stored in database by a single foreign key. Hence database relation\r\n+\t * is always consistent. Hence the instances retrieved from database are\r\n+\t * always consistently related irrespective of whether they were created\r\n+\t * with consistent or inconsistent relation.\r\n+\t * However, when the instances are retrieved from the data cache, data cache\r\n+\t * will preserve the in-memory relations even when they are inconsistent.\r\n+\t *    \r\n+\t * @param useDataCache\r\n+\t *            use DataCache\r\n+\t * @param consistent\r\n+\t *            assume that the relationship were created as consistent.\r\n+\t */\r\n+\tpublic void verifyBidirectionalRelation(boolean useDataCache,\r\n+\t\t\tboolean createConsistent, boolean expectConsistent) {\r\n+\t\tEntityManager em = (useDataCache) \r\n+\t\t                 ? emfWithDataCache.createEntityManager() \r\n+\t\t                 : emfWithoutDataCache.createEntityManager();\r\n+\t\t                 \r\n+\t\tlong id = ID_COUNTER++;\r\n+\t\tID_COUNTER += 4;\r\n+\t\tcreateBidirectionalRelation(em, id, createConsistent);\r\n+\t\t\r\n+\t\t\r\n+\t\tBidirectionalOne2OneOwner owner1 = em.find(BidirectionalOne2OneOwner.class, id);\r\n+\t\tBidirectionalOne2OneOwned owned1 = em.find(BidirectionalOne2OneOwned.class, id + 1);\r\n+\t\tBidirectionalOne2OneOwner owner2 = em.find(BidirectionalOne2OneOwner.class, id + 2);\r\n+\t\tBidirectionalOne2OneOwned owned2 = em.find(BidirectionalOne2OneOwned.class, id + 3);\r\n+\r\n+\t\tassertNotNull(owner1);\r\n+\t\tassertNotNull(owner2);\r\n+\t\tassertNotNull(owned1);\r\n+\t\tassertNotNull(owned2);\r\n+\r\n+\t\tassertEquals(owner1, expectConsistent \r\n+\t\t\t\t\t? owner1.getOwned().getOwner() \r\n+\t\t\t\t\t: owner2.getOwned().getOwner());\r\n+\t\tassertEquals(owner2, expectConsistent \r\n+\t\t\t\t\t? owner2.getOwned().getOwner() \r\n+\t\t\t\t    : owner1.getOwned().getOwner());\r\n+\r\n+\r\n+\t\tassertEquals(owned1, owner1.getOwned());\r\n+\t\tassertEquals(expectConsistent ? owner1 : owner2, owned1.getOwner());\r\n+\t\tassertEquals(owned2, owner2.getOwned());\r\n+\t\tassertEquals(expectConsistent ? owner2 : owner1, owned2.getOwner());\r\n+\t}\r\n+\r\n+\tpublic void testConsitentBidirectionalRelationIsPreservedWithDataCache() {\r\n+\t\tverifyBidirectionalRelation(WITH_DATACACHE, CONSISTENT, CONSISTENT);\r\n+\t}\r\n+\r\n+\tpublic void testConsitentBidirectionalRelationIsPreservedWithoutDataCache() {\r\n+\t\tverifyBidirectionalRelation(!WITH_DATACACHE, CONSISTENT, CONSISTENT);\r\n+\t}\r\n+\r\n+\tpublic void testInconsitentBidirectionalRelationIsPreservedWithDataCache() {\r\n+\t\tverifyBidirectionalRelation(WITH_DATACACHE, !CONSISTENT, !CONSISTENT);\r\n+\t}\r\n+\r\n+\tpublic void testInconsitentBidirectionalRelationIsNotPreservedWithoutDataCache() {\r\n+\t\tverifyBidirectionalRelation(!WITH_DATACACHE, !CONSISTENT, CONSISTENT);\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Verify that refresh() may fetch state from either the data cache or the\r\n+\t * database based on different conditions. \r\n+\t * The conditions that impact are \r\n+\t * a) whether current lock is stronger than NONE \r\n+\t * b) whether the instance being refreshed is dirty\r\n+\t * \r\n+\t * An instance is created with data cache marker and persisted. \r\n+\t * A native SQL is used to update the database record with database marker. \r\n+\t * The in-memory instance is not aware of this out-of-band update. \r\n+\t * Then the in-memory instance is refreshed. The marker of the refreshed \r\n+\t * instance tells whether the instance is refreshed from the data cache\r\n+\t * of the database. \r\n+\t * \r\n+\t * @param useDataCache flags if data cache is active. if not, then surely\r\n+\t * refresh always fetch state from the database.\r\n+\t * \r\n+\t * @param datacache the marker for the copy of the data cached instance\r\n+\t * @param database the marker for the database record\r\n+\t * @param lock lock to be used\r\n+\t */\r\n+\tpublic void verifyRefresh(boolean useDataCache, LockModeType lock, boolean makeDirtyBeforeRefresh) {\r\n+\t\tOpenJPAEntityManagerFactorySPI emf = (useDataCache)\r\n+\t\t\t? emfWithDataCache : emfWithoutDataCache;\r\n+\t\t\t\r\n+\t\tOpenJPAEntityManagerSPI em = emf.createEntityManager();\r\n+        \r\n+\t\tem.getTransaction().begin();\r\n+\t\tPObject pc = new PObject();\r\n+\t\tpc.setName(useDataCache ? MARKER_DATACACHE : MARKER_CACHE);\r\n+\t\tem.persist(pc);\r\n+\t\tem.getTransaction().commit();\r\n+\t\t\r\n+\t\tObject oid = pc.getId();\r\n+\t\tStoreCache dataCache = emf.getStoreCache();\r\n+\t\tassertEquals(useDataCache, dataCache.contains(PObject.class, oid));\r\n+\t\t\r\n+\t\t// Modify the record in the database in a separate transaction using\r\n+\t\t// native SQL so that the in-memory instance is not altered \r\n+\t\tem.getTransaction().begin();\r\n+\t\tString sql = \"UPDATE POBJECT SET NAME='\"+ MARKER_DATABASE +\"' WHERE id=\"+oid;\r\n+\t\tem.createNativeQuery(sql).executeUpdate();\r\n+\t\tem.getTransaction().commit();\r\n+\t\t\r\n+\t\tassertEquals(useDataCache ? MARKER_DATACACHE : MARKER_CACHE, pc.getName());\r\n+\t\t\r\n+\t\tem.getTransaction().begin();\r\n+\t\tif (makeDirtyBeforeRefresh) {\r\n+\t\t\tpc.setName(MARKER_DIRTY_CACHE);\r\n+\t\t} \r\n+\t\tassertEquals(makeDirtyBeforeRefresh, em.isDirty(pc));\r\n+\r\n+\t\tif (lock != null) {\r\n+\t\t\t((EntityManagerImpl)em).getFetchPlan().setReadLockMode(lock);\r\n+\t\t}\r\n+\t\tem.refresh(pc);\r\n+\t\t\r\n+\t\tString expected = getExpectedMarker(useDataCache, lock, makeDirtyBeforeRefresh);\r\n+\t\tassertEquals(expected, pc.getName());\r\n+\t\tem.getTransaction().commit();\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * The expected marker i.e. where the state is refreshed from depends on\r\n+\t * a) whether DataCache is active\r\n+\t * b) whether current Lock is stronger than NOLOCK\r\n+\t * c) whether the object to be refreshed is dirty\r\n+\t * \r\n+\t * The following truth table enumerates the possibilities\r\n+\t * \r\n+\t * Use Cache?   Lock?   Dirty?     Target\r\n+\t *    Y          Y       Y         Database\r\n+\t *    Y          N       Y         Data Cache\r\n+\t *    Y          Y       N         Data Cache\r\n+\t *    Y          N       N         Data Cache\r\n+\t *    \r\n+\t *    N          Y       Y         Database\r\n+\t *    N          N       Y         Database\r\n+\t *    N          Y       N         Object Cache\r\n+\t *    N          N       N         Object Cache\r\n+\t *    \r\n+\t * @param datacache the marker for \r\n+\t * @param database\r\n+\t * @param useDataCache\r\n+\t * @param lock\r\n+\t * @param makeDirtyBeforeRefresh\r\n+\t * @return\r\n+\t */\r\n+\tString getExpectedMarker(boolean useDataCache, LockModeType lock, boolean makeDirtyBeforeRefresh) {\r\n+\t\tif (useDataCache) {\r\n+\t\t\treturn (lock != null && makeDirtyBeforeRefresh)\r\n+\t\t\t\t? MARKER_DATABASE : MARKER_DATACACHE; \r\n+\t\t} else {\r\n+\t\t\treturn (makeDirtyBeforeRefresh) ? MARKER_DATABASE : MARKER_CACHE;\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\tpublic void testDirtyRefreshWithNoLockHitsDataCache() {\r\n+\t\tverifyRefresh(WITH_DATACACHE, NOLOCK, DIRTY);\r\n+\t}\r\n+\t\r\n+\tpublic void testCleanRefreshWithNoLockHitsDataCache() {\r\n+\t\tverifyRefresh(WITH_DATACACHE, NOLOCK, !DIRTY);\r\n+\t}\r\n+\t\r\n+\tpublic void testDirtyRefreshWithReadLockHitsDatabase() {\r\n+\t\tverifyRefresh(WITH_DATACACHE, LockModeType.READ, DIRTY);\r\n+\t}\r\n+\t\r\n+\tpublic void testCleanRefreshWithReadLockHitsDataCache() {\r\n+\t\tverifyRefresh(WITH_DATACACHE, LockModeType.READ, !DIRTY);\r\n+\t}\r\n+\t\r\n+\tpublic void testDirtyRefreshWithWriteLockHitsDatabase() {\r\n+\t\tverifyRefresh(WITH_DATACACHE, LockModeType.WRITE, DIRTY);\r\n+\t}\r\n+\t\r\n+\tpublic void testCleanRefreshWithWriteLockHitsDatabase() {\r\n+\t\tverifyRefresh(WITH_DATACACHE, LockModeType.WRITE, !DIRTY);\r\n+\t}\r\n+\t\r\n+\tpublic void testDirtyRefreshWithoutDataCacheAlwaysHitsDatabase() {\r\n+\t\tverifyRefresh(!WITH_DATACACHE, NOLOCK, DIRTY);\r\n+\t\tverifyRefresh(!WITH_DATACACHE, LockModeType.READ, DIRTY);\r\n+\t\tverifyRefresh(!WITH_DATACACHE, LockModeType.WRITE, DIRTY);\r\n+\t}\r\n+\t\r\n+\tpublic void testCleanRefreshWithoutDataCacheNeverHitsDatabase() {\r\n+\t\tverifyRefresh(!WITH_DATACACHE, NOLOCK, !DIRTY);\r\n+\t\tverifyRefresh(!WITH_DATACACHE, LockModeType.READ, !DIRTY);\r\n+\t\tverifyRefresh(!WITH_DATACACHE, LockModeType.WRITE, !DIRTY);\r\n+\t}\r\n+\t\r\n+\t\r\n+\tpublic void verifyDeleteDetectionOnRefresh(boolean useDataCache, LockModeType lock) {\r\n+\t\tOpenJPAEntityManagerFactorySPI emf = (useDataCache)\r\n+\t\t\t? emfWithDataCache : emfWithoutDataCache;\r\n+\t\t\t\r\n+\t\tOpenJPAEntityManagerSPI em = emf.createEntityManager();\r\n+        \r\n+\t\tem.getTransaction().begin();\r\n+\t\tPObject pc = new PObject();\r\n+\t\tpc.setName(useDataCache ? MARKER_DATACACHE : MARKER_CACHE);\r\n+\t\tem.persist(pc);\r\n+\t\tem.getTransaction().commit();\r\n+\t\t\r\n+\t\tObject oid = pc.getId();\r\n+\t\tStoreCache dataCache = emf.getStoreCache();\r\n+\t\tassertEquals(useDataCache, dataCache.contains(PObject.class, oid));\r\n+\t\t\r\n+\t\t// delete the record in the database in a separate transaction using\r\n+\t\t// native SQL so that the in-memory instance is not altered \r\n+\t\tem.getTransaction().begin();\r\n+\t\tString sql = \"DELETE FROM POBJECT WHERE id=\"+oid;\r\n+\t\tem.createNativeQuery(sql).executeUpdate();\r\n+\t\tem.getTransaction().commit();\r\n+\t\t\r\n+\t\t// the object cache does not know that the record was deleted\r\n+\t\tassertTrue(em.contains(pc));\r\n+\t\t// nor does the data cache\r\n+\t\tassertEquals(useDataCache, dataCache.contains(PObject.class, oid));\r\n+\t\t\r\n+\t\tassertEquals(useDataCache ? MARKER_DATACACHE : MARKER_CACHE, pc.getName());\r\n+\t\t\r\n+\t\tem.getTransaction().begin();\r\n+\t\tif (lock != null)\r\n+\t\t\tem.getFetchPlan().setReadLockMode(lock);\r\n+\t\ttry {\r\n+\t\t\tem.refresh(pc);\r\n+\t\t\tif (lock == null) {\r\n+\t\t\t\tassertEquals(useDataCache ? MARKER_DATACACHE : MARKER_CACHE, pc.getName());\r\n+\t\t\t} else {\r\n+\t\t\t\tfail(\"expected EntityNotFoundException for PObject:\" + oid);\r\n+\t\t\t}\r\n+\t\t} catch (EntityNotFoundException ex) {\r\n+\t\t\tif (lock != null) {\r\n+\t\t\t\t// we are good\r\n+\t\t\t}\r\n+\t\t} finally {\r\n+\t\t\tem.getTransaction().rollback();\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tpublic void testDeleteIsDetectedOnRefreshWithLockWithActiveDataCache() {\r\n+\t\tverifyDeleteDetectionOnRefresh(WITH_DATACACHE, LockModeType.READ);\r\n+\t\tverifyDeleteDetectionOnRefresh(WITH_DATACACHE, LockModeType.WRITE);\r\n+\t}\r\n+\t\r\n+\tpublic void testDeleteIsNotDetectedOnRefreshWithNoLockWithActiveDataCache() {\r\n+\t\tverifyDeleteDetectionOnRefresh(WITH_DATACACHE, NOLOCK);\r\n+\t}\r\n+\t\r\n+\tpublic void testDeleteIsDetectedOnRefreshAlwaysWithoutDataCache() {\r\n+\t\tverifyDeleteDetectionOnRefresh(!WITH_DATACACHE, NOLOCK);\r\n+\t\tverifyDeleteDetectionOnRefresh(!WITH_DATACACHE, LockModeType.READ);\r\n+\t\tverifyDeleteDetectionOnRefresh(!WITH_DATACACHE, LockModeType.WRITE);\r\n+\t}\r\n+\r\n+}\r"}]}

