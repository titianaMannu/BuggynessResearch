{"sha":"5463700d6c7e120241dde074d2d8aa25c01b3fda","node_id":"MDY6Q29tbWl0MjA2MzY0OjU0NjM3MDBkNmM3ZTEyMDI0MWRkZTA3NGQyZDhhYTI1YzAxYjNmZGE=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-06-06T18:49:30Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-06-06T18:49:30Z"},"message":"OPENJPA-235\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@544918 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"252a886b30a80457626629de546cbbd2296ba451","url":"https://api.github.com/repos/apache/openjpa/git/trees/252a886b30a80457626629de546cbbd2296ba451"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/5463700d6c7e120241dde074d2d8aa25c01b3fda","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/5463700d6c7e120241dde074d2d8aa25c01b3fda","html_url":"https://github.com/apache/openjpa/commit/5463700d6c7e120241dde074d2d8aa25c01b3fda","comments_url":"https://api.github.com/repos/apache/openjpa/commits/5463700d6c7e120241dde074d2d8aa25c01b3fda/comments","author":null,"committer":null,"parents":[{"sha":"4d23f445c608f4ebd5e688d22362150d4f758618","url":"https://api.github.com/repos/apache/openjpa/commits/4d23f445c608f4ebd5e688d22362150d4f758618","html_url":"https://github.com/apache/openjpa/commit/4d23f445c608f4ebd5e688d22362150d4f758618"}],"stats":{"total":1508,"additions":1507,"deletions":1},"files":[{"sha":"a3b5afacbbc05523c6773298b5a884bc0d6233ba","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java?ref=5463700d6c7e120241dde074d2d8aa25c01b3fda","patch":"@@ -214,9 +214,11 @@ public JDBCConfigurationImpl(boolean derivations, boolean loadGlobals) {\n         updateManagerPlugin = addPlugin(\"jdbc.UpdateManager\", true);\n         aliases = new String[]{\n             \"default\",\n-            \"org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager\",\n+            \"org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager\",\n             \"operation-order\",\n             \"org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager\",\n+            \"constraint\",\n+            \"org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager\",\n         };\n         updateManagerPlugin.setAliases(aliases);\n         updateManagerPlugin.setDefault(aliases[0]);"},{"sha":"7b385a9277a74de54c7797aa1235fc98ac493c0e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","status":"added","additions":419,"deletions":0,"changes":419,"blob_url":"https://github.com/apache/openjpa/blob/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","raw_url":"https://github.com/apache/openjpa/raw/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java?ref=5463700d6c7e120241dde074d2d8aa25c01b3fda","patch":"@@ -0,0 +1,419 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.jdbc.kernel;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.SQLException;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n+import org.apache.openjpa.jdbc.schema.Column;\r\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\r\n+import org.apache.openjpa.jdbc.schema.Table;\r\n+import org.apache.openjpa.jdbc.sql.PrimaryRow;\r\n+import org.apache.openjpa.jdbc.sql.Row;\r\n+import org.apache.openjpa.jdbc.sql.RowImpl;\r\n+import org.apache.openjpa.jdbc.sql.RowManager;\r\n+import org.apache.openjpa.jdbc.sql.RowManagerImpl;\r\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.lib.graph.DepthFirstAnalysis;\r\n+import org.apache.openjpa.lib.graph.Edge;\r\n+import org.apache.openjpa.lib.graph.Graph;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import org.apache.openjpa.util.OpenJPAException;\r\n+\r\n+/**\r\n+ * <p>Standard update manager, capable of foreign key constraint evaluation.</p>\r\n+ *\r\n+ * @since 1.0.0\r\n+ */\r\n+public class ConstraintUpdateManager\r\n+    extends AbstractUpdateManager {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (ConstraintUpdateManager.class);\r\n+\r\n+    public boolean orderDirty() {\r\n+        return false;\r\n+    }\r\n+\r\n+    protected PreparedStatementManager newPreparedStatementManager\r\n+        (JDBCStore store, Connection conn) {\r\n+        return new PreparedStatementManagerImpl(store, conn);\r\n+    }\r\n+\r\n+    protected RowManager newRowManager() {\r\n+        return new RowManagerImpl(false);\r\n+    }\r\n+\r\n+    protected Collection flush(RowManager rowMgr,\r\n+        PreparedStatementManager psMgr, Collection exceps) {\r\n+        RowManagerImpl rmimpl = (RowManagerImpl) rowMgr;\r\n+\r\n+        // first take care of all secondary table deletes and 'all row' deletes\r\n+        // (which are probably secondary table deletes), since no foreign\r\n+        // keys ever rely on secondary table pks\r\n+        flush(rmimpl.getAllRowDeletes(), psMgr);\r\n+        flush(rmimpl.getSecondaryDeletes(), psMgr);\r\n+\r\n+        // now do any 'all row' updates\r\n+        flush(rmimpl.getAllRowUpdates(), psMgr);\r\n+\r\n+        // analyze foreign keys\r\n+        Collection inserts = rmimpl.getInserts();\r\n+        Collection updates = rmimpl.getUpdates();\r\n+        Collection deletes = rmimpl.getDeletes();\r\n+        Graph[] graphs = new Graph[2];    // insert graph, delete graph\r\n+        analyzeForeignKeys(inserts, updates, deletes, rmimpl, graphs);\r\n+\r\n+        // flush insert graph, if any\r\n+        boolean autoAssign = rmimpl.hasAutoAssignConstraints();\r\n+        try {\r\n+            flushGraph(graphs[0], psMgr, autoAssign);\r\n+        } catch (SQLException se) {\r\n+            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\r\n+        } catch (OpenJPAException ke) {\r\n+            exceps = addException(exceps, ke);\r\n+        }\r\n+\r\n+        // flush the rest of the inserts and updates; inserts before updates\r\n+        // because some update fks might reference pks that have to be inserted\r\n+        flush(inserts, psMgr);\r\n+        flush(updates, psMgr);\r\n+\r\n+        // flush the delete graph, if any\r\n+        try {\r\n+            flushGraph(graphs[1], psMgr, autoAssign);\r\n+        } catch (SQLException se) {\r\n+            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\r\n+        } catch (OpenJPAException ke) {\r\n+            exceps = addException(exceps, ke);\r\n+        }\r\n+\r\n+        // put the remainder of the deletes after updates because some updates\r\n+        // may be nulling fks to rows that are going to be deleted\r\n+        flush(deletes, psMgr);\r\n+\r\n+        // take care of all secondary table inserts and updates last, since\r\n+        // they may rely on previous inserts or updates, but nothing relies\r\n+        // on them\r\n+        flush(rmimpl.getSecondaryUpdates(), psMgr);\r\n+\r\n+        // flush any left over prepared statements\r\n+        psMgr.flush();\r\n+        return exceps;\r\n+    }\r\n+\r\n+    /**\r\n+     * Analyze foreign key dependencies on the given rows\r\n+     * and create an insert and a delete graph to execute.  The insert\r\n+     * graph will be flushed before all other rows, and the delete graph will\r\n+     * be flushed after them.\r\n+     */\r\n+    private void analyzeForeignKeys(Collection inserts, Collection updates,\r\n+        Collection deletes, RowManagerImpl rowMgr, Graph[] graphs) {\r\n+        // if there are any deletes, we have to map the insert objects on their\r\n+        // oids so we'll be able to detect delete-then-insert-same-pk cases\r\n+        Map insertMap = null;\r\n+        OpenJPAStateManager sm;\r\n+        if (!deletes.isEmpty() && !inserts.isEmpty()) {\r\n+            insertMap = new HashMap((int) (inserts.size() * 1.33 + 1));\r\n+            for (Iterator itr = inserts.iterator(); itr.hasNext();) {\r\n+                sm = ((Row) itr.next()).getPrimaryKey();\r\n+                if (sm != null && sm.getObjectId() != null)\r\n+                    insertMap.put(sm.getObjectId(), sm);\r\n+            }\r\n+        }\r\n+\r\n+        // first construct the graph for deletes; this may expand to include\r\n+        // inserts and updates as well if there are any inserts that rely on\r\n+        // deletes (delete-then-insert-same-pk cases)\r\n+        PrimaryRow row;\r\n+        Row row2;\r\n+        ForeignKey[] fks;\r\n+        OpenJPAStateManager fkVal;\r\n+        boolean ignoreUpdates = true;\r\n+        for (Iterator itr = deletes.iterator(); itr.hasNext();) {\r\n+            row = (PrimaryRow) itr.next();\r\n+            if (!row.isValid())\r\n+                continue;\r\n+\r\n+            row2 = getInsertRow(insertMap, rowMgr, row);\r\n+            if (row2 != null) {\r\n+                ignoreUpdates = false;\r\n+                graphs[1] = addEdge(graphs[1], row, (PrimaryRow) row2, null);\r\n+            }\r\n+\r\n+            // now check this row's fks against other deletes\r\n+            fks = row.getTable().getForeignKeys();\r\n+            for (int j = 0; j < fks.length; j++) {\r\n+                // when deleting ref fks they'll just set a where value, so\r\n+                // check both for fk updates (relation fks) and wheres (ref fks)\r\n+                fkVal = row.getForeignKeySet(fks[j]);\r\n+                if (fkVal == null)\r\n+                    fkVal = row.getForeignKeyWhere(fks[j]);\r\n+                if (fkVal == null)\r\n+                    continue;\r\n+\r\n+                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\r\n+                    Row.ACTION_DELETE, fkVal, false);\r\n+                if (row2 != null && row2.isValid() && row2 != row)\r\n+                    graphs[1] = addEdge(graphs[1], row, (PrimaryRow) row2,\r\n+                        fks[j]);\r\n+            }\r\n+        }\r\n+\r\n+        if (ignoreUpdates)\r\n+            graphs[0] = analyzeAgainstInserts(inserts, rowMgr, graphs[0]);\r\n+        else {\r\n+            // put inserts *and updates* in the delete graph; they all rely\r\n+            // on each other\r\n+            graphs[1] = analyzeAgainstInserts(updates, rowMgr, graphs[1]);\r\n+            graphs[1] = analyzeAgainstInserts(inserts, rowMgr, graphs[1]);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Check to see if there is an insert for for the same table and primary\r\n+     * key values as the given delete row.\r\n+     */\r\n+    private Row getInsertRow(Map insertMap, RowManagerImpl rowMgr, Row row) {\r\n+        if (insertMap == null)\r\n+            return null;\r\n+\r\n+        OpenJPAStateManager sm = row.getPrimaryKey();\r\n+        if (sm == null)\r\n+            return null;\r\n+\r\n+        // look for a new object whose insert id is the same as this delete one\r\n+        Object oid = sm.getObjectId();\r\n+        OpenJPAStateManager nsm = (OpenJPAStateManager) insertMap.get(oid);\r\n+        if (nsm == null)\r\n+            return null;\r\n+\r\n+        // found new object; get its row\r\n+        row = rowMgr.getRow(row.getTable(), Row.ACTION_INSERT, nsm, false);\r\n+        return (row == null || row.isValid()) ? row : null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Analyze the given rows against the inserts, placing dependencies\r\n+     * in the given graph.\r\n+     */\r\n+    private Graph analyzeAgainstInserts(Collection rows, RowManagerImpl rowMgr,\r\n+        Graph graph) {\r\n+        PrimaryRow row;\r\n+        Row row2;\r\n+        ForeignKey[] fks;\r\n+        Column[] cols;\r\n+        for (Iterator itr = rows.iterator(); itr.hasNext();) {\r\n+            row = (PrimaryRow) itr.next();\r\n+            if (!row.isValid())\r\n+                continue;\r\n+\r\n+            // check this row's fks against inserts; a logical fk to an auto-inc\r\n+            // column is treated just as actual database fk because the result\r\n+            // is the same: the pk row has to be inserted before the fk row\r\n+            fks = row.getTable().getForeignKeys();\r\n+            for (int j = 0; j < fks.length; j++) {\r\n+                if (row.getForeignKeySet(fks[j]) == null)\r\n+                    continue;\r\n+\r\n+                // see if this row is dependent on another.  if it's only\r\n+                // depenent on itself, see if the fk is logical or deferred, in\r\n+                // which case it must be an auto-inc because otherwise we\r\n+                // wouldn't have recorded it\r\n+                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\r\n+                    Row.ACTION_INSERT, row.getForeignKeySet(fks[j]), false);\r\n+                if (row2 != null && row2.isValid() && (row2 != row\r\n+                    || fks[j].isDeferred() || fks[j].isLogical()))\r\n+                    graph = addEdge(graph, (PrimaryRow) row2, row, fks[j]);\r\n+            }\r\n+\r\n+            // see if there are any relation id columns dependent on\r\n+            // auto-inc objects\r\n+            cols = row.getTable().getRelationIdColumns();\r\n+            for (int j = 0; j < cols.length; j++) {\r\n+                OpenJPAStateManager sm = row.getRelationIdSet(cols[j]);\r\n+                if (sm == null)\r\n+                    continue;\r\n+\r\n+                row2 = rowMgr.getRow(getBaseTable(sm), Row.ACTION_INSERT,\r\n+                    sm, false);\r\n+                if (row2 != null && row2.isValid())\r\n+                    graph = addEdge(graph, (PrimaryRow) row2, row, cols[j]);\r\n+            }\r\n+        }\r\n+        return graph;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the base table for the given instance.\r\n+     */\r\n+    private static Table getBaseTable(OpenJPAStateManager sm) {\r\n+        ClassMapping cls = (ClassMapping) sm.getMetaData();\r\n+        while (cls.getJoinablePCSuperclassMapping() != null)\r\n+            cls = cls.getJoinablePCSuperclassMapping();\r\n+        return cls.getTable();\r\n+    }\r\n+\r\n+    /**\r\n+     * Add an edge between the given rows in the given foreign key graph.\r\n+     */\r\n+    private Graph addEdge(Graph graph, PrimaryRow row1, PrimaryRow row2,\r\n+        Object fk) {\r\n+        // delay creation of the graph\r\n+        if (graph == null)\r\n+            graph = new Graph();\r\n+\r\n+        row1.setDependent(true);\r\n+        row2.setDependent(true);\r\n+        graph.addNode(row1);\r\n+        graph.addNode(row2);\r\n+\r\n+        // add an edge from row1 to row2, and set the fk causing the\r\n+        // dependency as the user object so we can retrieve it when resolving\r\n+        // circular constraints\r\n+        Edge edge = new Edge(row1, row2, true);\r\n+        edge.setUserObject(fk);\r\n+        graph.addEdge(edge);\r\n+\r\n+        return graph;\r\n+    }\r\n+\r\n+    /**\r\n+     * Flush the given graph of rows in the proper order.\r\n+     * @param graph The graph of statements to be walked\r\n+     * @param psMgr The prepared statement manager to use to issue the\r\n+     * statements\r\n+     * @param autoAssign Whether any of the rows in the graph have any\r\n+     * auto-assign constraints\r\n+     */\r\n+    protected void flushGraph(Graph graph, PreparedStatementManager psMgr,\r\n+        boolean autoAssign)\r\n+        throws SQLException {\r\n+        if (graph == null)\r\n+            return;\r\n+\r\n+        DepthFirstAnalysis dfa = newDepthFirstAnalysis(graph, autoAssign);\r\n+        Collection nodes = dfa.getSortedNodes();\r\n+        Collection backs = dfa.getEdges(Edge.TYPE_BACK);\r\n+\r\n+        // handle circular constraints:\r\n+        // - if deleted row A has a ciricular fk to deleted row B, then use an\r\n+        //   update statement to null A's fk to B\r\n+        // - if inserted row A has a circular fk to updated/inserted row B,\r\n+        //   then null the fk in the B row object, and after flushing, use\r\n+        //   an update to set the fk to back to A\r\n+        Collection insertUpdates = null;\r\n+        Collection deleteUpdates = null;\r\n+        PrimaryRow row;\r\n+        RowImpl update;\r\n+        Edge edge;\r\n+        ForeignKey fk;\r\n+        Column col;\r\n+        for (Iterator itr = backs.iterator(); itr.hasNext();) {\r\n+            edge = (Edge) itr.next();\r\n+            if (edge.getUserObject() == null)\r\n+                throw new InternalException(_loc.get(\"del-ins-cycle\"));\r\n+\r\n+            // use a primary row update to prevent setting pk and fk values\r\n+            // until after flush, to get latest auto-increment values\r\n+            row = (PrimaryRow) edge.getTo();\r\n+            if (row.getAction() == Row.ACTION_DELETE) {\r\n+                // copy where conditions into new update that nulls the fk\r\n+                row = (PrimaryRow) edge.getFrom();\r\n+                update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE,null);\r\n+                row.copyInto(update, true);\r\n+                if (edge.getUserObject() instanceof ForeignKey) {\r\n+                    fk = (ForeignKey) edge.getUserObject();\r\n+                    update.setForeignKey(fk, row.getForeignKeyIO(fk), null);\r\n+                } else\r\n+                    update.setNull((Column) edge.getUserObject());\r\n+\r\n+                if (deleteUpdates == null)\r\n+                    deleteUpdates = new LinkedList();\r\n+                deleteUpdates.add(update);\r\n+            } else {\r\n+                // copy where conditions into new update that sets the fk\r\n+                update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE,null);\r\n+                if (row.getAction() == Row.ACTION_INSERT) {\r\n+                    if (row.getPrimaryKey() == null)\r\n+                        throw new InternalException(_loc.get(\"ref-cycle\"));\r\n+                    update.wherePrimaryKey(row.getPrimaryKey());\r\n+                } else\r\n+                    row.copyInto(update, true);\r\n+                if (edge.getUserObject() instanceof ForeignKey) {\r\n+                    fk = (ForeignKey) edge.getUserObject();\r\n+                    update.setForeignKey(fk, row.getForeignKeyIO(fk),\r\n+                        row.getForeignKeySet(fk));\r\n+                    row.clearForeignKey(fk);\r\n+                } else {\r\n+                    col = (Column) edge.getUserObject();\r\n+                    update.setRelationId(col, row.getRelationIdSet(col),\r\n+                        row.getRelationIdCallback(col));\r\n+                    row.clearRelationId(col);\r\n+                }\r\n+\r\n+                if (insertUpdates == null)\r\n+                    insertUpdates = new LinkedList();\r\n+                insertUpdates.add(update);\r\n+            }\r\n+        }\r\n+\r\n+        // flush delete updates to null fks, then all rows in order, then\r\n+        // the insert updates to set circular fk values\r\n+        if (deleteUpdates != null)\r\n+            flush(deleteUpdates, psMgr);\r\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();)\r\n+            psMgr.flush((RowImpl) itr.next());\r\n+        if (insertUpdates != null)\r\n+            flush(insertUpdates, psMgr);\r\n+\t}\r\n+\r\n+    /**\r\n+     * Create a new {@link DepthFirstAnalysis} suitable for the given graph\r\n+     * and auto-assign settings.\r\n+     */\r\n+    protected DepthFirstAnalysis newDepthFirstAnalysis(Graph graph,\r\n+        boolean autoAssign) {\r\n+        return new DepthFirstAnalysis(graph);\r\n+    }\r\n+\r\n+    /**\r\n+     * Flush the given collection of secondary rows.\r\n+     */\r\n+    protected void flush(Collection rows, PreparedStatementManager psMgr) {\r\n+        if (rows.size() == 0)\r\n+            return;\r\n+\r\n+        RowImpl row;\r\n+        for (Iterator itr = rows.iterator(); itr.hasNext(); ) {\r\n+            row = (RowImpl) itr.next();\r\n+            if (row.isValid() && !row.isDependent())\r\n+                psMgr.flush(row);\r\n+        }\r\n+    }\r\n+}\n\\ No newline at end of file"},{"sha":"16f643ad2b1305b6104bbddd19689607aa71df01","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","status":"added","additions":145,"deletions":0,"changes":145,"blob_url":"https://github.com/apache/openjpa/blob/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","raw_url":"https://github.com/apache/openjpa/raw/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java?ref=5463700d6c7e120241dde074d2d8aa25c01b3fda","patch":"@@ -0,0 +1,145 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.lib.graph;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+/**\r\n+ * <p>Performs a breadth-first walk of a given {@link Graph},\r\n+ * notifying visitors as it sees each node.  See the BFS algorithm\r\n+ * in the book 'Introduction to Algorithms' by Cormen, Leiserson, and\r\n+ * Rivest.</p>\r\n+ * <p/>\r\n+ * <p>Each {@link GraphVisitor} will be notified when a node\r\n+ * is colored black (nodeVisited), edge seen (edgeVisited),\r\n+ * and a node is seen for the first time, i.e. colored gray (nodeSeen).</p>\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @since 1.0.0\r\n+ * @nojavadoc\r\n+ */\r\n+public class BreadthFirstWalk {\r\n+\r\n+    private final Graph _graph;\r\n+    private final Set _visitors = new HashSet();\r\n+    private final List _queue = new LinkedList();\r\n+    private final Map _nodeInfo = new HashMap();\r\n+\r\n+    public BreadthFirstWalk(Graph graph) {\r\n+        _graph = graph;\r\n+    }\r\n+\r\n+    /**\r\n+     * Begins the breadth first traversal.\r\n+     */\r\n+    public void walk() {\r\n+        _queue.clear();\r\n+        _nodeInfo.clear();\r\n+\r\n+        Collection nodes = _graph.getNodes();\r\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();)\r\n+            _nodeInfo.put(itr.next(), new NodeInfo());\r\n+\r\n+        Object node;\r\n+        NodeInfo info;\r\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();) {\r\n+            node = itr.next();\r\n+            info = (NodeInfo) _nodeInfo.get(node);\r\n+            if (info.color == NodeInfo.COLOR_WHITE)\r\n+                enqueue(node, info);\r\n+            processQueue();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Process the queue to see what data needs to be obtained.\r\n+     */\r\n+    private void processQueue() {\r\n+        Object node;\r\n+        Object other;\r\n+        NodeInfo info;\r\n+        NodeInfo otherInfo;\r\n+        Collection edges;\r\n+        Edge edge;\r\n+        while (_queue.size() > 0) {\r\n+            node = _queue.remove(0);\r\n+            info = (NodeInfo) _nodeInfo.get(node);\r\n+            visit(node, info);\r\n+\r\n+            edges = _graph.getEdgesFrom(node);\r\n+            for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n+                edge = (Edge) itr.next();\r\n+                edgeVisited(edge);\r\n+                other = edge.getOther(node);\r\n+                otherInfo = (NodeInfo) _nodeInfo.get(other);\r\n+                if (otherInfo.color == NodeInfo.COLOR_WHITE)\r\n+                    enqueue(other, otherInfo);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Push the given node onto the queue to be processed.\r\n+     * Notify visitors.\r\n+     */\r\n+    protected void enqueue(Object node, NodeInfo info) {\r\n+        _queue.add(node);\r\n+        info.color = NodeInfo.COLOR_GRAY;\r\n+        for (Iterator i = _visitors.iterator(); i.hasNext();)\r\n+            ((GraphVisitor) i.next()).nodeSeen(node);\r\n+    }\r\n+\r\n+    /**\r\n+     * Visit the node.  Mark the node black and notify visitors.\r\n+     */\r\n+    protected void visit(Object node, NodeInfo info) {\r\n+        info.color = NodeInfo.COLOR_BLACK;\r\n+        for (Iterator i = _visitors.iterator(); i.hasNext();)\r\n+            ((GraphVisitor) i.next()).nodeVisited(node);\r\n+    }\r\n+\r\n+    /**\r\n+     * An edge is seen.  Notify visitors.\r\n+     */\r\n+    protected void edgeVisited(Edge edge) {\r\n+        for (Iterator i = _visitors.iterator(); i.hasNext();)\r\n+            ((GraphVisitor) i.next()).edgeVisited(edge);\r\n+    }\r\n+\r\n+    /**\r\n+     * add a {@link GraphVisitor} to be notified during breadth first search.\r\n+     */\r\n+    public void addGraphVisitor(GraphVisitor visitor) {\r\n+        _visitors.add(visitor);\r\n+    }\r\n+\r\n+    /**\r\n+     * remove a given {@link GraphVisitor} from the listener set.\r\n+     */\r\n+    public void removeGraphVisitor(GraphVisitor visitor) {\r\n+        _visitors.remove(visitor);\r\n+    }\r\n+}\r"},{"sha":"99a8fa642147b1833889d17ec0748968ecd2cfcf","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","status":"added","additions":215,"deletions":0,"changes":215,"blob_url":"https://github.com/apache/openjpa/blob/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","raw_url":"https://github.com/apache/openjpa/raw/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java?ref=5463700d6c7e120241dde074d2d8aa25c01b3fda","patch":"@@ -0,0 +1,215 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.lib.graph;\r\n+\r\n+import java.util.AbstractList;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Comparator;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * <p>Performs a depth-first analysis of a given {@link Graph}, caching\r\n+ * information about the graph's nodes and edges.  See the DFS algorithm\r\n+ * in the book 'Introduction to Algorithms' by Cormen, Leiserson, and\r\n+ * Rivest.  The algorithm has been modified to group sibling nodes without\r\n+ * connections together during the topological sort.</p>\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 1.0.0\r\n+ * @nojavadoc\r\n+ */\r\n+public class DepthFirstAnalysis {\r\n+\r\n+    private final Graph _graph;\r\n+    private final Map _nodeInfo = new HashMap();\r\n+    private Comparator _comp;\r\n+\r\n+    /**\r\n+     * Constructor.  Performs the analysis on the given graph and caches\r\n+     * the resulting information.\r\n+     */\r\n+    public DepthFirstAnalysis(Graph graph) {\r\n+        _graph = graph;\r\n+\r\n+        // initialize node infos\r\n+        Collection nodes = graph.getNodes();\r\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();)\r\n+            _nodeInfo.put(itr.next(), new NodeInfo());\r\n+\r\n+        // visit all nodes -- see intro to algo's book\r\n+        NodeInfo info;\r\n+        Object node;\r\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();) {\r\n+            node = itr.next();\r\n+            info = (NodeInfo) _nodeInfo.get(node);\r\n+            if (info.color == NodeInfo.COLOR_WHITE)\r\n+                visit(graph, node, info, 0);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Visit a node.  See Introduction to Algorithms book for details.\r\n+     */\r\n+    private int visit(Graph graph, Object node, NodeInfo info, int time) {\r\n+        // discover node\r\n+        info.color = NodeInfo.COLOR_GRAY;\r\n+\r\n+        // explore all vertices from that node depth first\r\n+        Collection edges = graph.getEdgesFrom(node);\r\n+        Edge edge;\r\n+        Object other;\r\n+        NodeInfo otherInfo;\r\n+        int maxChildTime = time - 1;\r\n+        int childTime;\r\n+        for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n+            edge = (Edge) itr.next();\r\n+            other = edge.getOther(node);\r\n+            otherInfo = (NodeInfo) _nodeInfo.get(other);\r\n+            if (otherInfo.color == NodeInfo.COLOR_WHITE) {\r\n+                // undiscovered node; recurse into it\r\n+                childTime = visit(graph, other, otherInfo, time);\r\n+                edge.setType(Edge.TYPE_TREE);\r\n+            } else if (otherInfo.color == NodeInfo.COLOR_GRAY) {\r\n+                childTime = -1;\r\n+                edge.setType(Edge.TYPE_BACK);\r\n+            } else {\r\n+                childTime = otherInfo.finished;\r\n+                edge.setType(Edge.TYPE_FORWARD);\r\n+            }\r\n+            maxChildTime = Math.max(maxChildTime, childTime);\r\n+        }\r\n+\r\n+        // finished with node\r\n+        info.color = NodeInfo.COLOR_BLACK;\r\n+        info.finished = maxChildTime + 1;\r\n+        return info.finished;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the comparator that should be used for ordering groups of nodes\r\n+     * with the same dependencies.\r\n+     */\r\n+    public void setNodeComparator(Comparator comp) {\r\n+        _comp = comp;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the nodes in topologically-sorted order.  This is often used\r\n+     * to order dependencies.  If each graph edge (u, v) represents a\r\n+     * dependency of v on u, then this method will return the nodes in the\r\n+     * order that they should be evaluated to satisfy all dependencies.  Of\r\n+     * course, if the graph is cyclic (has back edges), then no such ordering\r\n+     * is possible, though this method will still return the correct order\r\n+     * as if edges creating the cycles did not exist.\r\n+     */\r\n+    public List getSortedNodes() {\r\n+        Map.Entry[] entries = (Map.Entry[]) _nodeInfo.entrySet().\r\n+            toArray(new Map.Entry[_nodeInfo.size()]);\r\n+        Arrays.sort(entries, new NodeInfoComparator(_comp));\r\n+        return new NodeList(entries);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return all edges of the given type.  This method can be used to\r\n+     * discover all edges that cause cycles in the graph by passing it\r\n+     * the {@link #EDGE_BACK} edge type.\r\n+     */\r\n+    public Collection getEdges(int type) {\r\n+        Collection typed = null;\r\n+        Edge edge;\r\n+        Object node;\r\n+        for (Iterator nodes = _graph.getNodes().iterator(); nodes.hasNext();) {\r\n+            node = nodes.next();\r\n+            for (Iterator itr = _graph.getEdgesFrom(node).iterator();\r\n+                itr.hasNext();) {\r\n+                edge = (Edge) itr.next();\r\n+                if (edge.getType() == type) {\r\n+                    if (typed == null)\r\n+                        typed = new ArrayList();\r\n+                    typed.add(edge);\r\n+                }\r\n+            }\r\n+        }\r\n+        return (typed == null) ? Collections.EMPTY_LIST : typed;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the logical time that the given node was finished in\r\n+     * the graph walk, or -1 if the node is not part of the graph.\r\n+     */\r\n+    public int getFinishedTime(Object node) {\r\n+        NodeInfo info = (NodeInfo) _nodeInfo.get(node);\r\n+        if (info == null)\r\n+            return -1;\r\n+        return info.finished;\r\n+    }\r\n+\r\n+    /**\r\n+     * Comparator for toplogically sorting entries in the node info map.\r\n+     */\r\n+    private static class NodeInfoComparator\r\n+        implements Comparator {\r\n+\r\n+        private final Comparator _subComp;\r\n+\r\n+        public NodeInfoComparator(Comparator subComp) {\r\n+            _subComp = subComp;\r\n+        }\r\n+\r\n+        public int compare(Object o1, Object o2) {\r\n+            Map.Entry e1 = (Map.Entry) o1;\r\n+            Map.Entry e2 = (Map.Entry) o2;\r\n+            NodeInfo n1 = (NodeInfo) e1.getValue();\r\n+            NodeInfo n2 = (NodeInfo) e2.getValue();\r\n+\r\n+            // reverse finished order\r\n+            int ret = n2.finished - n1.finished;\r\n+            if (ret == 0 && _subComp != null)\r\n+                ret = _subComp.compare(e1.getKey(), e2.getKey());\r\n+            return ret;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     *\tList of node-to-nodeinfo entries that exposes just the nodes.\r\n+     */\r\n+    private static class NodeList\r\n+        extends AbstractList {\r\n+\r\n+        private final Map.Entry[] _entries;\r\n+\r\n+        public NodeList(Map.Entry[] entries) {\r\n+            _entries = entries;\r\n+        }\r\n+\r\n+        public Object get(int idx) {\r\n+            return _entries[idx].getKey();\r\n+        }\r\n+\r\n+        public int size() {\r\n+            return _entries.length;\r\n+\t\t}\r\n+\t}\r\n+}\r"},{"sha":"314afcdd0f6af9db2c02ccfec9a8d22d31291659","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","status":"added","additions":189,"deletions":0,"changes":189,"blob_url":"https://github.com/apache/openjpa/blob/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","raw_url":"https://github.com/apache/openjpa/raw/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java?ref=5463700d6c7e120241dde074d2d8aa25c01b3fda","patch":"@@ -0,0 +1,189 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.lib.graph;\r\n+\r\n+/**\r\n+ * <p>A graph edge.  Includes the from and to nodes, an arbitrary user object,\r\n+ * and a weight.  Edges can be either directed or undirected.</p>\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 1.0.0\r\n+ * @nojavadoc\r\n+ */\r\n+public class Edge {\r\n+\r\n+    /**\r\n+     * An edge (u, v) is a tree edge if node v was first discovered by\r\n+     * traversing the edge.\r\n+     */\r\n+    public static final int TYPE_TREE = 1;\r\n+\r\n+    /**\r\n+     * An edge (u, v) is a back edge if it creates a cycle back to an\r\n+     * ancestor in the graph.\r\n+     */\r\n+    public static final int TYPE_BACK = 2;\r\n+\r\n+    /**\r\n+     * An edge (u, v) is a forward edge if it is not a tree or back edge.\r\n+     */\r\n+    public static final int TYPE_FORWARD = 3;\r\n+\r\n+    private final Object _from;\r\n+    private final Object _to;\r\n+    private final boolean _directed;\r\n+\r\n+    private int _type = 0;\r\n+    private double _weight = 0;\r\n+    private Object _userObj = null;\r\n+\r\n+    /**\r\n+     * Constructor.\r\n+     *\r\n+     * @param    from        the node the edge comes from\r\n+     * @param    to            the node the edge goes to\r\n+     * @param    directed    whether the edge is directed\r\n+     */\r\n+    public Edge(Object from, Object to, boolean directed) {\r\n+        if (from == null)\r\n+            throw new NullPointerException(\"from == null\");\r\n+        if (to == null)\r\n+            throw new NullPointerException(\"to == null\");\r\n+        _from = from;\r\n+        _to = to;\r\n+        _directed = directed;\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor.\r\n+     *\r\n+     * @param    from        the node the edge comes from\r\n+     * @param    to            the node the edge goes to\r\n+     * @param    directed    whether the edge is directed\r\n+     * @param    userObject    an associated object\r\n+     */\r\n+    public Edge(Object from, Object to, boolean directed, Object userObject) {\r\n+        this(from, to, directed);\r\n+        _userObj = userObject;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the node the edge links from.\r\n+     */\r\n+    public Object getFrom() {\r\n+        return _from;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the node the edge links to.\r\n+     */\r\n+    public Object getTo() {\r\n+        return _to;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the node on the opposite end of the given one, or null if the\r\n+     * given node is not part of this edge.\r\n+     */\r\n+    public Object getOther(Object node) {\r\n+        if (_to == node)\r\n+            return _from;\r\n+        if (_from == node)\r\n+            return _to;\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return true if this edge links to the given node.  For undirected edges,\r\n+     * this method returns true if either side is equal to the given node.\r\n+     */\r\n+    public boolean isTo(Object node) {\r\n+        return _to == node || (!_directed && _from == node);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return true if this edge links from the given node.  For undirected\r\n+     * edges, this method returns true if either side is equal to the given\r\n+     * node.\r\n+     */\r\n+    public boolean isFrom(Object node) {\r\n+        return _from == node || (!_directed && _to == node);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether the edge is directed.\r\n+     */\r\n+    public boolean isDirected() {\r\n+        return _directed;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the weight of the edge.\r\n+     */\r\n+    public double getWeight() {\r\n+        return _weight;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the weight of the edge.\r\n+     */\r\n+    public void setWeight(double weight) {\r\n+        _weight = weight;\r\n+    }\r\n+\r\n+    /**\r\n+     * Arbitrary user object associated with the edge.\r\n+     */\r\n+    public Object getUserObject() {\r\n+        return _userObj;\r\n+    }\r\n+\r\n+    /**\r\n+     * Arbitrary user object associated with the edge.\r\n+     */\r\n+    public void setUserObject(Object obj) {\r\n+        _userObj = obj;\r\n+    }\r\n+\r\n+    /**\r\n+     * Traversal bookkeeping info.\r\n+     */\r\n+    public int getType() {\r\n+        return _type;\r\n+    }\r\n+\r\n+    /**\r\n+     * Traversal bookkeeping info.\r\n+     */\r\n+    public void setType(int type) {\r\n+        _type = type;\r\n+    }\r\n+\r\n+    /**\r\n+     * Clear traversal info.\r\n+     */\r\n+    public void clearTraversal() {\r\n+        _type = 0;\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return super.toString() + \"[from=\" + getFrom() + \";to=\" + getTo()\r\n+            + \";directed=\" + isDirected () + \";weight=\" + getWeight () + \"]\";\r\n+\t}\r\n+}\r"},{"sha":"e056bfe73239aaf689a2f30f9ef72e2d65dab545","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","status":"added","additions":199,"deletions":0,"changes":199,"blob_url":"https://github.com/apache/openjpa/blob/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","raw_url":"https://github.com/apache/openjpa/raw/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java?ref=5463700d6c7e120241dde074d2d8aa25c01b3fda","patch":"@@ -0,0 +1,199 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.lib.graph;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * <p>Graph representation using the adjacency list form.  See the book\r\n+ * 'Introduction to Algorithms' by Cormen, Leiserson, and Rivest.</p>\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 1.0.0\r\n+ * @nojavadoc\r\n+ */\r\n+public class Graph {\r\n+\r\n+    // map each node to list of edges from that node\r\n+    private final Map _nodes = new HashMap();\r\n+\r\n+    /**\r\n+     * Clear the graph.\r\n+     */\r\n+    public void clear() {\r\n+        _nodes.clear();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return true if the graph contains the given node.\r\n+     */\r\n+    public boolean containsNode(Object node) {\r\n+        return _nodes.containsKey(node);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a view of all nodes in the graph.\r\n+     */\r\n+    public Collection getNodes() {\r\n+        return _nodes.keySet();\r\n+    }\r\n+\r\n+    /**\r\n+     * Add a node to the graph.  Adding a node a second time has no effect.\r\n+     */\r\n+    public void addNode(Object node) {\r\n+        if (node == null)\r\n+            throw new NullPointerException(\"node = null\");\r\n+        if (!containsNode(node))\r\n+            _nodes.put(node, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove a node from the graph.  All edges to and from the node\r\n+     * will be cleared.\r\n+     *\r\n+     * @return true if the node was removed, false otherwise\r\n+     */\r\n+    public boolean removeNode(Object node) {\r\n+        boolean rem = containsNode(node);\r\n+        if (rem) {\r\n+            Collection edges = getEdgesTo(node);\r\n+            for (Iterator itr = edges.iterator(); itr.hasNext();)\r\n+                removeEdge((Edge) itr.next());\r\n+            _nodes.remove(node);\r\n+        }\r\n+        return rem;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return all edges in the graph.\r\n+     */\r\n+    public Collection getEdges() {\r\n+        Collection all = new HashSet();\r\n+        Collection edges;\r\n+        for (Iterator itr = _nodes.values().iterator(); itr.hasNext();) {\r\n+            edges = (Collection) itr.next();\r\n+            if (edges != null)\r\n+                all.addAll(edges);\r\n+        }\r\n+        return all;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return all the edges from a particular node.\r\n+     */\r\n+    public Collection getEdgesFrom(Object node) {\r\n+        Collection edges = (Collection) _nodes.get(node);\r\n+        return (edges == null) ? Collections.EMPTY_LIST : edges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return all the edges to a particular node.\r\n+     */\r\n+    public Collection getEdgesTo(Object node) {\r\n+        Collection edges = getEdges();\r\n+        Collection to = new ArrayList();\r\n+        Edge edge;\r\n+        for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n+            edge = (Edge) itr.next();\r\n+            if (edge.isTo(node))\r\n+                to.add(edge);\r\n+        }\r\n+        return to;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return all the edges from one node to another.\r\n+     */\r\n+    public Collection getEdges(Object from, Object to) {\r\n+        Collection edges = getEdgesFrom(from);\r\n+        Collection matches = new ArrayList(edges.size());\r\n+        Edge edge;\r\n+        for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n+            edge = (Edge) itr.next();\r\n+            if (edge.isTo(to))\r\n+                matches.add(edge);\r\n+        }\r\n+        return matches;\r\n+    }\r\n+\r\n+    /**\r\n+     * Add an edge to the graph.\r\n+     */\r\n+    public void addEdge(Edge edge) {\r\n+        if (!containsNode(edge.getTo()))\r\n+            throw new IllegalArgumentException(edge.getTo().toString());\r\n+        if (!containsNode(edge.getFrom()))\r\n+            throw new IllegalArgumentException(edge.getFrom().toString());\r\n+\r\n+        Collection from = (Collection) _nodes.get(edge.getFrom());\r\n+        if (from == null) {\r\n+            from = new ArrayList(3);\r\n+            _nodes.put(edge.getFrom(), from);\r\n+        }\r\n+        from.add(edge);\r\n+\r\n+        if (!edge.isDirected() && !edge.getFrom().equals(edge.getTo())) {\r\n+            Collection to = (Collection) _nodes.get(edge.getTo());\r\n+            if (to == null) {\r\n+                to = new ArrayList(3);\r\n+                _nodes.put(edge.getTo(), to);\r\n+            }\r\n+            to.add(edge);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove an edge from the graph.\r\n+     *\r\n+     * @return true if the edge was removed, false if not in the graph\r\n+     */\r\n+    public boolean removeEdge(Edge edge) {\r\n+        Collection edges = (Collection) _nodes.get(edge.getFrom());\r\n+        if (edges == null)\r\n+            return false;\r\n+        boolean rem = edges.remove(edge);\r\n+        if (rem && !edge.isDirected()) {\r\n+            edges = (Collection) _nodes.get(edge.getTo());\r\n+            if (edges != null)\r\n+                edges.remove(edge);\r\n+        }\r\n+        return rem;\r\n+    }\r\n+\r\n+    /**\r\n+     *\tClear all nodes and edges of the bookkeeping information from their\r\n+     *\tlast traversal.\r\n+     */\r\n+    public void clearTraversal() {\r\n+        Collection edges;\r\n+        for (Iterator vals = _nodes.values().iterator(); vals.hasNext();) {\r\n+            edges = (Collection) vals.next();\r\n+            if (edges != null)\r\n+                for (Iterator ed = edges.iterator(); ed.hasNext();)\r\n+                    ((Edge) ed.next()).clearTraversal ();\r\n+\t\t}\r\n+\t}\r\n+}\r"},{"sha":"852602d7d7859bf0a5d35106bcce513f50e45f10","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java?ref=5463700d6c7e120241dde074d2d8aa25c01b3fda","patch":"@@ -0,0 +1,47 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.lib.graph;\r\n+\r\n+/**\r\n+ * <p>A helper interface that allows third parties to be notified of\r\n+ * graph events during graph traversals</p>\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @since 1.0.0\r\n+ * @nojavadoc\r\n+ */\r\n+public interface GraphVisitor {\r\n+\r\n+    /**\r\n+     * May not be called.  The meaning of this method is dependent\r\n+     * on the traversal being used.  See each appropriate graph\r\n+     * walker for details.\r\n+     */\r\n+    public void nodeSeen(Object node);\r\n+\r\n+    /**\r\n+     * will only be called once per node\r\n+     */\r\n+    public void nodeVisited(Object node);\r\n+\r\n+    /**\r\n+     * may visit the node twice (both sides)\r\n+     */\r\n+    public void edgeVisited(Edge edge);\r\n+}\r"},{"sha":"c3dbe01d55b35af8fba1608e9a113645d56565fc","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","raw_url":"https://github.com/apache/openjpa/raw/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java?ref=5463700d6c7e120241dde074d2d8aa25c01b3fda","patch":"@@ -0,0 +1,35 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.lib.graph;\r\n+\r\n+/**\r\n+ * <p>Struct used to track graph node information during traversal.</p>\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 1.0.0\r\n+ */\r\n+class NodeInfo {\r\n+\r\n+    public static final int COLOR_WHITE = 0;\r\n+    public static final int COLOR_GRAY = 1;\r\n+    public static final int COLOR_BLACK = 2;\r\n+\r\n+    public int finished = 0;\r\n+    public int color = COLOR_WHITE;\r\n+}\r"},{"sha":"9095a4ec0368bfd122f7c762215689b7185b19fc","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/package.html","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/package.html","raw_url":"https://github.com/apache/openjpa/raw/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/package.html?ref=5463700d6c7e120241dde074d2d8aa25c01b3fda","patch":"@@ -0,0 +1,27 @@\n+<!--\r\n+ Licensed to the Apache Software Foundation (ASF) under one\r\n+ or more contributor license agreements.  See the NOTICE file\r\n+ distributed with this work for additional information\r\n+ regarding copyright ownership.  The ASF licenses this file\r\n+ to you under the Apache License, Version 2.0 (the\r\n+ \"License\"); you may not use this file except in compliance\r\n+ with the License.  You may obtain a copy of the License at\r\n+\r\n+ http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+ Unless required by applicable law or agreed to in writing,\r\n+ software distributed under the License is distributed on an\r\n+ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ KIND, either express or implied.  See the License for the\r\n+ specific language governing permissions and limitations\r\n+ under the License.\r\n+-->\r\n+<html>\r\n+<body>\r\n+<p><strong>Graph Abstraction</strong></p>\r\n+\r\n+<p>\r\n+    This package provides a graph abstraction and graph-related algorithms.\r\n+</p>\r\n+</body>\r\n+</html>\r"},{"sha":"33fdc99ffad6b8d8c3bb9f369bd984a50d3c7ee8","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","status":"added","additions":80,"deletions":0,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","raw_url":"https://github.com/apache/openjpa/raw/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java?ref=5463700d6c7e120241dde074d2d8aa25c01b3fda","patch":"@@ -0,0 +1,80 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.lib.graph;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.Iterator;\r\n+\r\n+import org.apache.openjpa.lib.test.AbstractTestCase;\r\n+\r\n+/**\r\n+ * <p>Tests the {@link DepthFirstAnalysis} type.</p>\r\n+ *\r\n+ * @author Abe White\r\n+ */\r\n+public class TestDepthFirstAnalysis\r\n+    extends AbstractTestCase {\r\n+\r\n+    private DepthFirstAnalysis _dfa = null;\r\n+\r\n+    public void setUp() {\r\n+        Graph graph = new Graph();\r\n+        Object node1 = new Object();\r\n+        Object node2 = new Object();\r\n+        Object node3 = new Object();\r\n+        Object node4 = new Object();\r\n+        graph.addNode(node1);\r\n+        graph.addNode(node2);\r\n+        graph.addNode(node3);\r\n+        graph.addNode(node4);\r\n+        graph.addEdge(new Edge(node1, node2, true));\r\n+        graph.addEdge(new Edge(node2, node3, true));\r\n+        graph.addEdge(new Edge(node3, node1, true));\r\n+        graph.addEdge(new Edge(node3, node4, true));\r\n+        graph.addEdge(new Edge(node2, node2, true));\r\n+        _dfa = new DepthFirstAnalysis(graph);\r\n+    }\r\n+\r\n+    public void testNodeSorting() {\r\n+        Collection nodes = _dfa.getSortedNodes();\r\n+        assertEquals(4, nodes.size());\r\n+\r\n+        int time = Integer.MAX_VALUE;\r\n+        Object node;\r\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();) {\r\n+            node = itr.next();\r\n+            assertTrue(time >= _dfa.getFinishedTime(node));\r\n+            time = _dfa.getFinishedTime(node);\r\n+        }\r\n+    }\r\n+\r\n+    public void testEdgeTyping() {\r\n+        Collection edges = _dfa.getEdges(Edge.TYPE_BACK);\r\n+        assertEquals(2, edges.size());\r\n+        Iterator itr = edges.iterator();\r\n+        Edge edge0 = (Edge) itr.next();\r\n+        Edge edge1 = (Edge) itr.next();\r\n+        assertTrue((edge0.getTo() == edge0.getFrom())\r\n+            || edge1.getTo() == edge1.getFrom());\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+        main(TestDepthFirstAnalysis.class);\r\n+    }\r\n+}\r"},{"sha":"2c93755c672336c8a98e0fd46a867e687939b7b7","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","status":"added","additions":148,"deletions":0,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","raw_url":"https://github.com/apache/openjpa/raw/5463700d6c7e120241dde074d2d8aa25c01b3fda/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java?ref=5463700d6c7e120241dde074d2d8aa25c01b3fda","patch":"@@ -0,0 +1,148 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.lib.graph;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.Iterator;\r\n+\r\n+import org.apache.openjpa.lib.test.AbstractTestCase;\r\n+\r\n+/**\r\n+ * <p>Tests the {@link Graph} type, and in so doing implicitly tests the\r\n+ * {@link Edge} as well.</p>\r\n+ *\r\n+ * @author Abe White\r\n+ */\r\n+public class TestGraph\r\n+    extends AbstractTestCase {\r\n+\r\n+    private Graph _graph = new Graph();\r\n+    private Object _node1 = new Object();\r\n+    private Object _node2 = new Object();\r\n+    private Object _node3 = new Object();\r\n+    private Edge _edge1 = new Edge(_node1, _node2, true);\r\n+    private Edge _edge2 = new Edge(_node2, _node3, true);\r\n+    private Edge _edge3 = new Edge(_node1, _node3, false);\r\n+    private Edge _edge4 = new Edge(_node2, _node2, false);\r\n+\r\n+    public void setUp() {\r\n+        _graph.addNode(_node1);\r\n+        _graph.addNode(_node2);\r\n+        _graph.addNode(_node3);\r\n+        _graph.addEdge(_edge1);\r\n+        _graph.addEdge(_edge2);\r\n+        _graph.addEdge(_edge3);\r\n+        _graph.addEdge(_edge4);\r\n+    }\r\n+\r\n+    /**\r\n+     * Tests adding and retrieving nodes and edges.\r\n+     */\r\n+    public void testAddRetrieve() {\r\n+        assertEquals(3, _graph.getNodes().size());\r\n+        assertEquals(4, _graph.getEdges().size());\r\n+\r\n+        Collection edges = _graph.getEdgesFrom(_node1);\r\n+        assertEquals(2, edges.size());\r\n+        Iterator itr = edges.iterator();\r\n+        Edge edge0 = (Edge) itr.next();\r\n+        Edge edge1 = (Edge) itr.next();\r\n+        assertTrue((edge0 == _edge1 && edge1 == _edge3)\r\n+            || (edge0 == _edge3 && edge1 == _edge1));\r\n+\r\n+        edges = _graph.getEdgesTo(_node1);\r\n+        assertEquals(1, edges.size());\r\n+        assertEquals(_edge3, edges.iterator().next());\r\n+\r\n+        edges = _graph.getEdges(_node1, _node3);\r\n+        assertEquals(1, edges.size());\r\n+        assertEquals(_edge3, edges.iterator().next());\r\n+        edges = _graph.getEdges(_node3, _node1);\r\n+        assertEquals(1, edges.size());\r\n+        assertEquals(_edge3, edges.iterator().next());\r\n+\r\n+        edges = _graph.getEdgesFrom(_node2);\r\n+        assertEquals(2, edges.size());\r\n+        itr = edges.iterator();\r\n+        edge0 = (Edge) itr.next();\r\n+        edge1 = (Edge) itr.next();\r\n+        assertTrue((edge0 == _edge2 && edge1 == _edge4)\r\n+            || (edge0 == _edge4 && edge1 == _edge2));\r\n+\r\n+        edges = _graph.getEdgesTo(_node2);\r\n+        assertEquals(2, edges.size());\r\n+        itr = edges.iterator();\r\n+        edge0 = (Edge) itr.next();\r\n+        edge1 = (Edge) itr.next();\r\n+        assertTrue((edge0 == _edge1 && edge1 == _edge4)\r\n+            || (edge0 == _edge4 && edge1 == _edge1));\r\n+\r\n+        edges = _graph.getEdges(_node2, _node2);\r\n+        assertEquals(1, edges.size());\r\n+        assertEquals(_edge4, edges.iterator().next());\r\n+\r\n+        edges = _graph.getEdgesFrom(_node3);\r\n+        assertEquals(1, edges.size());\r\n+        assertEquals(_edge3, edges.iterator().next());\r\n+    }\r\n+\r\n+    /**\r\n+     * Test removing edges.\r\n+     */\r\n+    public void testRemoveEdges() {\r\n+        assertTrue(_graph.removeEdge(_edge2));\r\n+        Collection edges = _graph.getEdgesFrom(_node2);\r\n+        assertEquals(1, edges.size());\r\n+        assertEquals(_edge4, edges.iterator().next());\r\n+\r\n+        assertTrue(_graph.removeEdge(_edge3));\r\n+        edges = _graph.getEdgesFrom(_node1);\r\n+        assertEquals(1, edges.size());\r\n+        assertEquals(_edge1, edges.iterator().next());\r\n+        edges = _graph.getEdgesTo(_node1);\r\n+        assertEquals(0, edges.size());\r\n+        edges = _graph.getEdgesTo(_node3);\r\n+        assertEquals(0, edges.size());\r\n+        edges = _graph.getEdgesFrom(_node3);\r\n+        assertEquals(0, edges.size());\r\n+    }\r\n+\r\n+    /**\r\n+     * Test removing nodes.\r\n+     */\r\n+    public void testRemoveNodes() {\r\n+        assertTrue(_graph.removeNode(_node3));\r\n+        Collection edges = _graph.getEdges();\r\n+        assertEquals(2, edges.size());\r\n+        Iterator itr = edges.iterator();\r\n+        Edge edge0 = (Edge) itr.next();\r\n+        Edge edge1 = (Edge) itr.next();\r\n+        assertTrue((edge0 == _edge1 && edge1 == _edge4)\r\n+            || (edge0 == _edge4 && edge1 == _edge1));\r\n+        edges = _graph.getEdgesFrom(_node1);\r\n+        assertEquals(1, edges.size());\r\n+        assertEquals(_edge1, edges.iterator().next());\r\n+        edges = _graph.getEdgesTo(_node1);\r\n+        assertEquals(0, edges.size());\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+        main(TestGraph.class);\r\n+\t}\r\n+}\r"}]}

