{"sha":"574d559860c58a74aead153305aef6dfc44a2fbd","node_id":"MDY6Q29tbWl0MjA2MzY0OjU3NGQ1NTk4NjBjNThhNzRhZWFkMTUzMzA1YWVmNmRmYzQ0YTJmYmQ=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-12-19T00:08:23Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-12-19T00:08:23Z"},"message":"OPENJPA-825: Introduced internal locking for shared contexts (BrokerImpl/QueryImpl).\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@727864 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"e2e8158a30fd5b6264439c3d02107108d0cd1460","url":"https://api.github.com/repos/apache/openjpa/git/trees/e2e8158a30fd5b6264439c3d02107108d0cd1460"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/574d559860c58a74aead153305aef6dfc44a2fbd","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/574d559860c58a74aead153305aef6dfc44a2fbd","html_url":"https://github.com/apache/openjpa/commit/574d559860c58a74aead153305aef6dfc44a2fbd","comments_url":"https://api.github.com/repos/apache/openjpa/commits/574d559860c58a74aead153305aef6dfc44a2fbd/comments","author":null,"committer":null,"parents":[{"sha":"0e6a3bd79db8745bcdc947723bb091354b206663","url":"https://api.github.com/repos/apache/openjpa/commits/0e6a3bd79db8745bcdc947723bb091354b206663","html_url":"https://github.com/apache/openjpa/commit/0e6a3bd79db8745bcdc947723bb091354b206663"}],"stats":{"total":609,"additions":352,"deletions":257},"files":[{"sha":"f9bd6740272b72002edb0ab276fd6277d3866565","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","status":"modified","additions":2,"deletions":8,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java?ref=574d559860c58a74aead153305aef6dfc44a2fbd","patch":"@@ -84,7 +84,6 @@\n public class JDBCStoreQuery \n     extends ExpressionStoreQuery {\n \n-\tprivate boolean _isUnique = false;\n     private static final Table INVALID = new Table();\n \n     // add all standard filter and aggregate listeners to these maps\n@@ -112,11 +111,6 @@ public JDBCStoreQuery(JDBCStore store, ExpressionParser parser) {\n         _store = store;\n     }\n \n-    @Override\n-    public void setContext(QueryContext ctx) {\n-    \tsuper.setContext(ctx);\n-    \t_isUnique = ctx.isUnique();\n-    }\n     /**\n      * Return the store.\n      */\n@@ -348,7 +342,7 @@ private boolean createWhereSelects(List sels, ClassMapping[] mappings,\n                 evaluate(ctx, null, null, exps[i], states[i]);\n             if (optHint != null)\n                sel.setExpectedResultCount(optHint.intValue(), true);\n-            else if (_isUnique)\n+            else if (this.ctx.isUnique())\n                 sel.setExpectedResultCount(1, false);\n             for (int j = 0; j < verts.length; j++) {\n                 selMappings.add(verts[j]);\n@@ -430,7 +424,7 @@ private int calculateEagerMode(QueryExpressions exps, long start,\n         long end) {\n         if (exps.projections.length > 0 || start >= end)\n             return EagerFetchModes.EAGER_NONE;\n-        if (end - start == 1 || _isUnique)\n+        if (end - start == 1 || ctx.isUnique())\n             return EagerFetchModes.EAGER_JOIN;\n         return EagerFetchModes.EAGER_PARALLEL;\n     }"},{"sha":"113b104609172a5c9e2c35fdc13bfec1f106b266","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":20,"deletions":1,"changes":21,"blob_url":"https://github.com/apache/openjpa/blob/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=574d559860c58a74aead153305aef6dfc44a2fbd","patch":"@@ -37,6 +37,7 @@\n import java.util.List;\r\n import java.util.Map;\r\n import java.util.Set;\r\n+import java.util.concurrent.locks.LockSupport;\r\n import java.util.concurrent.locks.ReentrantLock;\r\n \r\n import javax.transaction.Status;\r\n@@ -4161,14 +4162,32 @@ protected void free() {\n     ///////////////////\r\n \r\n     public void lock() {\r\n-        if (_lock != null)\r\n+        if (_lock != null) \r\n             _lock.lock();\r\n     }\r\n \r\n     public void unlock() {\r\n         if (_lock != null)\r\n             _lock.unlock();\r\n     }\r\n+    \r\n+    /**\r\n+     * Creates a locks irrespective of multithreaded support. Used only by \r\n+     * internal implementation to guard access when it spawns its own threads \r\n+     * and user configured the broker for single-threaded access. \r\n+     */\r\n+    public synchronized void startLocking() {\r\n+    \tif (_lock == null)\r\n+    \t\t_lock = new ReentrantLock();\r\n+    }\r\n+    \r\n+    /**\r\n+     * Destroys the lock if not multithreaded support. \r\n+     */\r\n+    public synchronized void stopLocking() {\r\n+    \tif (_lock != null && !getMultithreaded())\r\n+    \t\t_lock = null;\r\n+    }\r\n \r\n     ////////////////////\r\n     // State management\r"},{"sha":"27ed2195d4646537f8044a011d23d114f8294ea2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","status":"modified","additions":17,"deletions":6,"changes":23,"blob_url":"https://github.com/apache/openjpa/blob/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?ref=574d559860c58a74aead153305aef6dfc44a2fbd","patch":"@@ -84,7 +84,7 @@\n     private transient ClassLoader _loader = null;\r\n \r\n     // query has its own internal lock\r\n-    private final ReentrantLock _lock;\r\n+    private ReentrantLock _lock;\r\n \r\n     // unparsed state\r\n     private Class _class = null;\r\n@@ -138,8 +138,6 @@ public QueryImpl(Broker broker, String language, StoreQuery storeQuery) {\n \r\n         if (_broker != null && _broker.getMultithreaded())\r\n             _lock = new ReentrantLock();\r\n-        else\r\n-            _lock = null;\r\n     }\r\n \r\n     /**\r\n@@ -458,8 +456,8 @@ public boolean isUnique() {\n             // no explicit setting; default\r\n             StoreQuery.Executor ex = compileForExecutor();\r\n             if (!ex.isAggregate(_storeQuery))\r\n-                return _unique = false;\r\n-            return _unique = !ex.hasGrouping(_storeQuery);\r\n+                return false;\r\n+            return !ex.hasGrouping(_storeQuery);\r\n         } finally {\r\n             unlock();\r\n         }\r\n@@ -1553,9 +1551,22 @@ public void lock() {\n     }\r\n \r\n     public void unlock() {\r\n-        if (_lock != null && _lock.isLocked())\r\n+        if (_lock != null)\r\n             _lock.unlock();\r\n     }\r\n+    \r\n+    public synchronized void startLocking() {\r\n+    \tif (_lock == null) {\r\n+    \t\t_lock = new ReentrantLock();\r\n+    \t}\r\n+    }\r\n+    \r\n+    public synchronized void stopLocking() {\r\n+    \tif (_lock != null && !_broker.getMultithreaded())\r\n+    \t\t_lock = null;\r\n+    }\r\n+    \r\n+    \r\n \r\n     /////////\r\n     // Utils\r"},{"sha":"55fc4bd761d193abc5a3de19da964a474212d188","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","status":"modified","additions":10,"deletions":9,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java?ref=574d559860c58a74aead153305aef6dfc44a2fbd","patch":"@@ -37,6 +37,8 @@\n \n import javax.persistence.FlushModeType;\n import javax.persistence.LockModeType;\n+import javax.persistence.NoResultException;\n+import javax.persistence.NonUniqueResultException;\n import javax.persistence.Query;\n import javax.persistence.TemporalType;\n \n@@ -444,15 +446,14 @@ public List getResultList() {\n \t */\n \tpublic Object getSingleResult() {\n \t\t_em.assertNotCloseInvoked();\n-\t\t// temporarily set query to unique so that a single result is validated\n-\t\t// and returned; unset again in case the user executes query again\n-\t\t// via getResultList\n-\t\t_query.setUnique(true);\n-\t\ttry {\n-\t\t\treturn execute();\n-\t\t} finally {\n-\t\t\t_query.setUnique(false);\n-\t\t}\n+\t\tList result = getResultList();\n+\t\tif (result == null || result.isEmpty())\n+\t\t\tthrow new NoResultException(_loc.get(\"no-result\", getQueryString())\n+\t\t\t\t.getMessage());\n+\t\tif (result.size() > 1)\n+\t\t\tthrow new NonUniqueResultException(_loc.get(\"non-unique-result\",\n+\t\t\t\tgetQueryString(), result.size()).getMessage());\n+\t\treturn result.get(0);\n \t}\n \n \tpublic int executeUpdate() {"},{"sha":"809d39d7763d61198a39262446183de547b6d47b","filename":"openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties?ref=574d559860c58a74aead153305aef6dfc44a2fbd","patch":"@@ -163,4 +163,5 @@ param-type-null: Parameter \"{0}\" declared in \"{1}\" is set to null, \\\n \tbut this parameter is bound to a field of primitive type \"{2}\".\n version-check-error: An error occurred while attempting to determine the \\\n     version of \"{0}\".\n-\t\n\\ No newline at end of file\n+no-result: Query \"{0}\" selected no result, but expected unique result.\n+non-unique-result: Query \"{0}\" selected {1} results, but expected unique result.\n\\ No newline at end of file"},{"sha":"011b9bcce0319663af243cbb091fbdc64cc5643d","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java?ref=574d559860c58a74aead153305aef6dfc44a2fbd","patch":"@@ -91,4 +91,11 @@ public boolean endOperation() {\n \t    }\r\n \t    return true;\r\n \t}\r\n+\t\r\n+\t/**\r\n+\t * A virtual datastore need not be opened.\r\n+\t */\r\n+\t@Override\r\n+\tpublic void beginStore() {\r\n+\t}\r\n }\r"},{"sha":"dbf2a076531a206e1f1d0bf6e305af4bd9ea9363","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/ProductDerivation.java","status":"modified","additions":17,"deletions":3,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-slice/src/main/java/org/apache/openjpa/slice/ProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-slice/src/main/java/org/apache/openjpa/slice/ProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/ProductDerivation.java?ref=574d559860c58a74aead153305aef6dfc44a2fbd","patch":"@@ -23,6 +23,10 @@\n import org.apache.openjpa.conf.OpenJPAProductDerivation;\r\n import org.apache.openjpa.lib.conf.AbstractProductDerivation;\r\n import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.conf.PluginValue;\r\n+import org.apache.openjpa.lib.conf.Value;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n import org.apache.openjpa.slice.jdbc.DistributedJDBCBrokerFactory;\r\n import org.apache.openjpa.slice.jdbc.DistributedJDBCConfigurationImpl;\r\n \r\n@@ -37,10 +41,12 @@\n  */\r\n public class ProductDerivation extends AbstractProductDerivation implements\r\n \t\tOpenJPAProductDerivation {\r\n+\tprivate static final Localizer _loc = \r\n+\t\tLocalizer.forPackage(ProductDerivation.class);\r\n     /**\r\n      * Prefix for all Slice-specific configuration properties. \r\n      */\r\n-    public static final String PREFIX_SLICE = \"openjpa.slice\";\r\n+    public static final String PREFIX_SLICE   = \"openjpa.slice\";\r\n     \r\n     /**\r\n      * Hint key <code>openjpa.hint.slice.Target </code> to specify a subset of \r\n@@ -74,14 +80,22 @@ public boolean afterSpecificationSet(Configuration c) {\n         DistributedJDBCConfigurationImpl conf = \r\n         \t(DistributedJDBCConfigurationImpl)c;\r\n         boolean modified = false;\r\n+        Log log = conf.getConfigurationLog();\r\n         if (conf.getDistributionPolicyInstance() == null) {\r\n-        \tconf.distributionPolicyPlugin.setString(\"random\");\r\n+        \tforceSet(PREFIX_SLICE, conf.distributionPolicyPlugin,\"random\", log);\r\n         \tmodified = true;\r\n         }\r\n         if (conf.getReplicationPolicyInstance() == null) {\r\n-        \tconf.replicationPolicyPlugin.setString(\"all\");\r\n+        \tforceSet(PREFIX_SLICE, conf.replicationPolicyPlugin, \"all\", log);\r\n         \tmodified = true;\r\n         }\r\n         return modified;\r\n     }\r\n+    \r\n+    void forceSet(String prefix, Value v, String forced, Log log) {\r\n+    \tv.setString(forced);\r\n+    \tif (log.isWarnEnabled())\r\n+        \tlog.warn(_loc.get(\"forced-set-config\", \r\n+        \t\tprefix+\".\"+v.getProperty(), forced));\r\n+    }\r\n }\r"},{"sha":"70c3372c17d2c03531ebd91fe7048b1091bc5bf1","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java","status":"modified","additions":12,"deletions":6,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java?ref=574d559860c58a74aead153305aef6dfc44a2fbd","patch":"@@ -39,6 +39,7 @@\n import org.apache.openjpa.jdbc.kernel.JDBCStoreManager;\r\n import org.apache.openjpa.jdbc.sql.Result;\r\n import org.apache.openjpa.jdbc.sql.ResultSetResult;\r\n+import org.apache.openjpa.kernel.BrokerImpl;\r\n import org.apache.openjpa.kernel.FetchConfiguration;\r\n import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n import org.apache.openjpa.kernel.PCState;\r\n@@ -242,22 +243,22 @@ public Collection flush(Collection sms) {\n         List<Future<Collection>> futures = new ArrayList<Future<Collection>>();\r\n         Map<String, List<OpenJPAStateManager>> subsets = bin(sms, null);\r\n         \r\n-        boolean serialMode = getConfiguration().getMultithreaded();\r\n+        boolean parallel = !getConfiguration().getMultithreaded();\r\n         for (SliceStoreManager slice : _slices) {\r\n             List<OpenJPAStateManager> subset = subsets.get(slice.getName());\r\n             if (subset.isEmpty())\r\n                 continue;\r\n             if (containsReplicated(subset)) {\r\n             \tcollectException(slice.flush(subset), exceptions);\r\n             } else {\r\n-            \tif (serialMode) {\r\n-                \tcollectException(slice.flush(subset), exceptions);\r\n-            \t} else {\r\n+            \tif (parallel) {\r\n             \t\tfutures.add(threadPool.submit(new Flusher(slice, subset)));\r\n+            \t} else {\r\n+                \tcollectException(slice.flush(subset), exceptions);\r\n             \t}\r\n             }\r\n         }\r\n-        if (!serialMode) {\r\n+        if (parallel) {\r\n \t        for (Future<Collection> future : futures) {\r\n \t            try {\r\n \t            \tcollectException(future.get(), exceptions);\r\n@@ -459,7 +460,12 @@ void log(String s) {\n         }\r\n \r\n         public Collection call() throws Exception {\r\n-            return store.flush(toFlush);\r\n+        \t((BrokerImpl)store.getContext()).startLocking();\r\n+        \ttry {\r\n+        \t\treturn store.flush(toFlush);\r\n+        \t} finally {\r\n+            \t((BrokerImpl)store.getContext()).stopLocking();\r\n+        \t}\r\n         }\r\n     }\r\n \r"},{"sha":"1213b3ca4234a4fbd1b3bfd1208d37d5f9eaaefc","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java","status":"modified","additions":239,"deletions":217,"changes":456,"blob_url":"https://github.com/apache/openjpa/blob/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java?ref=574d559860c58a74aead153305aef6dfc44a2fbd","patch":"@@ -28,10 +28,12 @@\n \r\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\r\n import org.apache.openjpa.jdbc.kernel.JDBCStoreQuery;\r\n+import org.apache.openjpa.kernel.BrokerImpl;\r\n import org.apache.openjpa.kernel.ExpressionStoreQuery;\r\n import org.apache.openjpa.kernel.FetchConfiguration;\r\n import org.apache.openjpa.kernel.OrderingMergedResultObjectProvider;\r\n import org.apache.openjpa.kernel.QueryContext;\r\n+import org.apache.openjpa.kernel.QueryImpl;\r\n import org.apache.openjpa.kernel.StoreManager;\r\n import org.apache.openjpa.kernel.StoreQuery;\r\n import org.apache.openjpa.kernel.exps.ExpressionParser;\r\n@@ -44,272 +46,292 @@\n /**\r\n  * A query for distributed databases.\r\n  * \r\n- * @author Pinaki Poddar \r\n- *\r\n+ * @author Pinaki Poddar\r\n+ * \r\n  */\r\n @SuppressWarnings(\"serial\")\r\n class DistributedStoreQuery extends JDBCStoreQuery {\r\n \tprivate List<StoreQuery> _queries = new ArrayList<StoreQuery>();\r\n \tprivate ExpressionParser _parser;\r\n-\tprivate boolean _serialMode;\r\n-\t\r\n+\r\n \tpublic DistributedStoreQuery(JDBCStore store, ExpressionParser parser) {\r\n \t\tsuper(store, parser);\r\n \t\t_parser = parser;\r\n-\t\t_serialMode = store.getContext().getConfiguration().getMultithreaded();\r\n-\t\t\r\n \t}\r\n-\t\r\n+\r\n \tvoid add(StoreQuery q) {\r\n \t\t_queries.add(q);\r\n \t}\r\n-\t\r\n+\r\n \tpublic DistributedStoreManager getDistributedStore() {\r\n-\t\treturn (DistributedStoreManager)getStore();\r\n+\t\treturn (DistributedStoreManager) getStore();\r\n+\t}\r\n+\r\n+\tpublic Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\r\n+\t\tboolean parallel = !getContext().getStoreContext().getBroker()\r\n+\t\t\t.getMultithreaded();\r\n+\t\tParallelExecutor ex = new ParallelExecutor(this, meta, subs, _parser, \r\n+\t\t\tctx.getCompilation(), parallel);\r\n+\t\tfor (StoreQuery q : _queries) {\r\n+\t\t\tex.addExecutor(q.newDataStoreExecutor(meta, subs));\r\n+\t\t}\r\n+\t\treturn ex;\r\n+\t}\r\n+\r\n+\tpublic void setContext(QueryContext ctx) {\r\n+\t\tsuper.setContext(ctx);\r\n+\t\tfor (StoreQuery q : _queries)\r\n+\t\t\tq.setContext(ctx);\r\n+\t}\r\n+\r\n+\tpublic ExecutorService getExecutorServiceInstance() {\r\n+\t\tDistributedJDBCConfiguration conf = ((DistributedJDBCConfiguration) \r\n+\t\t\tgetStore().getConfiguration());\r\n+\t\treturn conf.getExecutorServiceInstance();\r\n \t}\r\n-\t\r\n-    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\r\n-    \tParallelExecutor ex = new ParallelExecutor(this, meta, subs, _parser, \r\n-    \t\t\tctx.getCompilation(), _serialMode);\r\n-        for (StoreQuery q : _queries) {\r\n-            ex.addExecutor(q.newDataStoreExecutor(meta, subs));\r\n-        }\r\n-        return ex;\r\n-    }\r\n-    \r\n-    public void setContext(QueryContext ctx) {\r\n-    \tsuper.setContext(ctx);\r\n-    \tfor (StoreQuery q : _queries) \r\n-    \t\tq.setContext(ctx); \r\n-    }\r\n-    \r\n-    public ExecutorService getExecutorServiceInstance() {\r\n-        DistributedJDBCConfiguration conf = \r\n-            ((DistributedJDBCConfiguration)getStore().getConfiguration());\r\n-        return conf.getExecutorServiceInstance();\r\n-    }\r\n-    \r\n+\r\n \t/**\r\n \t * Executes queries on multiple databases.\r\n \t * \r\n-\t * @author Pinaki Poddar \r\n-\t *\r\n+\t * @author Pinaki Poddar\r\n+\t * \r\n \t */\r\n-\tpublic static class ParallelExecutor extends \r\n-\t\tExpressionStoreQuery.DataStoreExecutor {\r\n+\tpublic static class ParallelExecutor extends\r\n+\t\t\tExpressionStoreQuery.DataStoreExecutor {\r\n \t\tprivate List<Executor> executors = new ArrayList<Executor>();\r\n \t\tprivate DistributedStoreQuery owner = null;\r\n \t\tprivate ExecutorService threadPool = null;\r\n-\t\tprivate final boolean serialMode;\r\n-\t\t\r\n-        public ParallelExecutor(DistributedStoreQuery dsq, ClassMetaData meta, \r\n-        \tboolean subclasses, ExpressionParser parser, Object parsed, \r\n-        \tboolean serial) {\r\n-        \tsuper(dsq, meta, subclasses, parser, parsed);\r\n-        \towner = dsq;\r\n-        \tthreadPool = dsq.getExecutorServiceInstance();\r\n-        \tserialMode = false;//serial;\r\n-        }\r\n-        \r\n+\t\tprivate final boolean parallel;\r\n+\r\n+\t\tpublic ParallelExecutor(DistributedStoreQuery dsq, ClassMetaData meta,\r\n+\t\t\t\tboolean subclasses, ExpressionParser parser, Object parsed, \r\n+\t\t\t\tboolean parallel) {\r\n+\t\t\tsuper(dsq, meta, subclasses, parser, parsed);\r\n+\t\t\towner = dsq;\r\n+\t\t\tthreadPool = dsq.getExecutorServiceInstance();\r\n+\t\t\tthis.parallel = parallel;\r\n+\t\t}\r\n+\r\n \t\tpublic void addExecutor(Executor ex) {\r\n \t\t\texecutors.add(ex);\r\n \t\t}\r\n-\t\t\r\n-        /**\r\n-         * Each child query must be executed with slice context and not the \r\n-         * given query context.\r\n-         */\r\n-        public ResultObjectProvider executeQuery(StoreQuery q,\r\n-                final Object[] params, final Range range) {\r\n-        \tList<Future<ResultObjectProvider>> futures = null;\r\n-        \tfinal List<Executor> usedExecutors = new ArrayList<Executor>();\r\n-        \tfinal List<ResultObjectProvider> rops = \r\n-        \t\tnew ArrayList<ResultObjectProvider>();\r\n-        \tList<SliceStoreManager> targets = findTargets();\r\n-        \tQueryContext ctx = q.getContext();\r\n-        \tboolean isReplicated = containsReplicated(ctx);\r\n-        \tfor (int i = 0; i < owner._queries.size(); i++) {\r\n-        \t\t// if replicated, then execute only on single slice\r\n-        \t\tif (i > 0 && isReplicated) {\r\n-        \t\t\tcontinue;\r\n-        \t\t}\r\n-        \t\tStoreManager sm  = owner.getDistributedStore().getSlice(i);\r\n-        \t\tif (!targets.contains(sm))\r\n-        \t\t\tcontinue;\r\n-         \t\tStoreQuery query = owner._queries.get(i);\r\n-        \t\tExecutor executor = executors.get(i);\r\n-        \t\tif (!targets.contains(sm))\r\n-        \t\t\tcontinue;\r\n-        \t\tusedExecutors.add(executor);\r\n-        \t\tif (serialMode) {\r\n-        \t\t\trops.add(executor.executeQuery(query, params, range));\r\n-        \t\t} else {\r\n-        \t\t\tif (futures == null)\r\n-        \t\t\t\tfutures = new ArrayList<Future<ResultObjectProvider>>();\r\n-\t        \t\tQueryExecutor call = new QueryExecutor();\r\n-\t        \t\tcall.executor = executor;\r\n-\t        \t\tcall.query    = query;\r\n-\t        \t\tcall.params   = params;\r\n-\t        \t\tcall.range    = range;\r\n-\t        \t\tfutures.add(threadPool.submit(call)); \r\n-        \t\t}\r\n-        \t}\r\n-        \tif (!serialMode) {\r\n-\t    \t\tfor (Future<ResultObjectProvider> future:futures) {\r\n-\t        \t\ttry {\r\n+\r\n+\t\t/**\r\n+\t\t * Each child query must be executed with slice context and not the\r\n+\t\t * given query context.\r\n+\t\t */\r\n+\t\tpublic ResultObjectProvider executeQuery(StoreQuery q,\r\n+\t\t\t\tfinal Object[] params, final Range range) {\r\n+\t\t\tList<Future<ResultObjectProvider>> futures = \r\n+\t\t\t\tnew ArrayList<Future<ResultObjectProvider>>();\r\n+\t\t\tfinal List<Executor> usedExecutors = new ArrayList<Executor>();\r\n+\t\t\tfinal List<ResultObjectProvider> rops = \r\n+\t\t\t\tnew ArrayList<ResultObjectProvider>();\r\n+\t\t\tList<SliceStoreManager> targets = findTargets();\r\n+\t\t\tQueryContext ctx = q.getContext();\r\n+\t\t\tboolean isReplicated = containsReplicated(ctx);\r\n+\t\t\tfor (int i = 0; i < owner._queries.size(); i++) {\r\n+\t\t\t\t// if replicated, then execute only on single slice\r\n+\t\t\t\tif (i > 0 && isReplicated) {\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\tStoreManager sm = owner.getDistributedStore().getSlice(i);\r\n+\t\t\t\tif (!targets.contains(sm))\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\tStoreQuery query = owner._queries.get(i);\r\n+\t\t\t\tExecutor executor = executors.get(i);\r\n+\t\t\t\tif (!targets.contains(sm))\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\tusedExecutors.add(executor);\r\n+\t\t\t\tif (!parallel) {\r\n+\t\t\t\t\trops.add(executor.executeQuery(query, params, range));\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tQueryExecutor call = new QueryExecutor();\r\n+\t\t\t\t\tcall.executor = executor;\r\n+\t\t\t\t\tcall.query = query;\r\n+\t\t\t\t\tcall.params = params;\r\n+\t\t\t\t\tcall.range = range;\r\n+\t\t\t\t\tfutures.add(threadPool.submit(call));\r\n+\t\t\t\t}\r\n+\r\n+\t\t\t}\r\n+\t\t\tif (parallel) {\r\n+\t\t\t\tfor (Future<ResultObjectProvider> future : futures) {\r\n+\t\t\t\t\ttry {\r\n \t\t\t\t\t\trops.add(future.get());\r\n \t\t\t\t\t} catch (InterruptedException e) {\r\n \t\t\t\t\t\tthrow new RuntimeException(e);\r\n \t\t\t\t\t} catch (ExecutionException e) {\r\n \t\t\t\t\t\tthrow new StoreException(e.getCause());\r\n \t\t\t\t\t}\r\n-\t        \t}\r\n-        \t}\r\n-        \tResultObjectProvider[] tmp = rops.toArray\r\n-        \t\t(new ResultObjectProvider[rops.size()]);\r\n-        \tResultObjectProvider result = null;\r\n-        \tboolean[] ascending = getAscending(q);\r\n-        \tboolean isAscending = ascending.length > 0;\r\n-        \tboolean isAggregate = ctx.isAggregate();\r\n-        \tboolean hasRange    = ctx.getEndRange() != Long.MAX_VALUE;\r\n-        \tif (isAggregate) {\r\n-        \t    result = new UniqueResultObjectProvider(tmp, q, \r\n-        \t            getQueryExpressions());\r\n-        \t} else if (isAscending) {\r\n-        \t    result = new OrderingMergedResultObjectProvider(tmp, ascending, \r\n-                  usedExecutors.toArray(new Executor[usedExecutors.size()]),\r\n-                  q, params);\r\n-        \t} else {\r\n-        \t    result = new MergedResultObjectProvider(tmp);\r\n-        \t}\r\n-        \tif (hasRange) {\r\n-        \t    result = new RangeResultObjectProvider(result, \r\n-        \t            ctx.getStartRange(), ctx.getEndRange());\r\n-        \t}\r\n-        \treturn result;\r\n-        }\r\n-        \r\n-        /**\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\tResultObjectProvider[] tmp = rops\r\n+\t\t\t\t\t.toArray(new ResultObjectProvider[rops.size()]);\r\n+\t\t\tResultObjectProvider result = null;\r\n+\t\t\tboolean[] ascending = getAscending(q);\r\n+\t\t\tboolean isAscending = ascending.length > 0;\r\n+\t\t\tboolean isAggregate = ctx.isAggregate();\r\n+\t\t\tboolean hasRange = ctx.getEndRange() != Long.MAX_VALUE;\r\n+\t\t\tif (isAggregate) {\r\n+\t\t\t\tresult = new UniqueResultObjectProvider(tmp, q,\r\n+\t\t\t\t\t\tgetQueryExpressions());\r\n+\t\t\t} else if (isAscending) {\r\n+\t\t\t\tresult = new OrderingMergedResultObjectProvider(tmp, ascending,\r\n+\t\t\t\t\tusedExecutors.toArray(new Executor[usedExecutors.size()]),\r\n+\t\t\t\t\tq, params);\r\n+\t\t\t} else {\r\n+\t\t\t\tresult = new MergedResultObjectProvider(tmp);\r\n+\t\t\t}\r\n+\t\t\tif (hasRange) {\r\n+\t\t\t\tresult = new RangeResultObjectProvider(result, ctx\r\n+\t\t\t\t\t\t.getStartRange(), ctx.getEndRange());\r\n+\t\t\t}\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t/**\r\n \t\t * Scans metadata to find out if a replicated class is the candidate.\r\n-        **/\r\n-        boolean containsReplicated(QueryContext query) {\r\n-        \tClass candidate = query.getCandidateType();\r\n-        \tif (candidate != null) {\r\n-        \t\tClassMetaData meta = query.getStoreContext().getConfiguration()\r\n-        \t\t\t.getMetaDataRepositoryInstance()\r\n-        \t\t\t.getMetaData(candidate, null, true);\r\n-        \t\tif (meta != null && meta.isReplicated())\r\n-        \t\t\treturn true;\r\n-        \t}\r\n-        \tClassMetaData[] metas = query.getAccessPathMetaDatas();\r\n-        \tif (metas == null || metas.length < 1)\r\n-        \t\treturn false;\r\n-        \tfor (ClassMetaData type : metas)\r\n-        \t\tif (type.isReplicated())\r\n-        \t\t\treturn true;\r\n-        \treturn false;\r\n-        }\r\n-        \r\n-        public Number executeDelete(StoreQuery q, Object[] params) {\r\n-        \tIterator<StoreQuery> qs = owner._queries.iterator();\r\n-        \tList<Future<Number>> futures = null;\r\n-        \tint result = 0;\r\n-        \tfor (Executor ex:executors) {\r\n-        \t\tif (serialMode) {\r\n-        \t\t\tNumber n = ex.executeDelete(qs.next(), params);    \r\n-        \t\t\tif (n != null)\r\n-        \t\t\t\tresult += n.intValue();\r\n-        \t\t} else {\r\n-        \t\t\tif (futures == null)\r\n-        \t\t\t\tfutures = new ArrayList<Future<Number>>();\r\n-\t        \t\tDeleteExecutor call = new DeleteExecutor();\r\n-\t        \t\tcall.executor = ex;\r\n-\t        \t\tcall.query    = qs.next();\r\n-\t        \t\tcall.params   = params;\r\n-\t        \t\tfutures.add(threadPool.submit(call)); \r\n-        \t\t}\r\n-        \t}\r\n-        \tif (!serialMode) {\r\n-\t        \tfor (Future<Number> future:futures) {\r\n-\t        \t\ttry {\r\n-\t            \t\tNumber n = future.get();\r\n-\t            \t\tif (n != null) \r\n-\t            \t\t\tresult += n.intValue();\r\n-\t\t\t\t\t} catch (InterruptedException e) {\r\n-\t\t\t\t\t\tthrow new RuntimeException(e);\r\n-\t\t\t\t\t} catch (ExecutionException e) {\r\n-\t\t\t\t\t\tthrow new StoreException(e.getCause());\r\n-\t\t\t\t\t}\r\n-\t        \t}\r\n-        \t}\r\n-        \treturn result;\r\n-        }\r\n-        \r\n-        public Number executeUpdate(StoreQuery q, Object[] params) {\r\n-        \tIterator<StoreQuery> qs = owner._queries.iterator();\r\n-        \tList<Future<Number>> futures = null;\r\n-        \tint result = 0;\r\n-        \tfor (Executor ex:executors) {\r\n-        \t\tif (serialMode) {\r\n-        \t\t\tNumber n = ex.executeUpdate(qs.next(), params);\r\n-        \t\t\tresult += (n == null) ? 0 : n.intValue();\r\n-        \t\t} else {\r\n-        \t\t\tif (futures == null)\r\n-        \t\t\t\tfutures = new ArrayList<Future<Number>>();\r\n-        \t\tUpdateExecutor call = new UpdateExecutor();\r\n-        \t\tcall.executor = ex;\r\n-        \t\tcall.query    = qs.next();\r\n-        \t\tcall.params   = params;\r\n-        \t\tfutures.add(threadPool.submit(call)); \r\n-        \t\t}\r\n-        \t}\r\n-        \tif (serialMode) {\r\n-\t        \tfor (Future<Number> future:futures) {\r\n-\t        \t\ttry {\r\n-\t            \t\tNumber n = future.get();\r\n-\t        \t\t\tresult += (n == null) ? 0 : n.intValue();\r\n-\t\t\t\t\t} catch (InterruptedException e) {\r\n-\t\t\t\t\t\tthrow new RuntimeException(e);\r\n-\t\t\t\t\t} catch (ExecutionException e) {\r\n-\t\t\t\t\t\tthrow new StoreException(e.getCause());\r\n-\t\t\t\t\t}\r\n-\t        \t}\r\n-        \t}\r\n-        \treturn result;\r\n-        }\r\n-        \r\n-        List<SliceStoreManager> findTargets() {\r\n-        \tFetchConfiguration fetch = owner.getContext().getFetchConfiguration();\r\n-        \treturn owner.getDistributedStore().getTargets(fetch);\r\n-        }\r\n+\t\t */\r\n+\t\tboolean containsReplicated(QueryContext query) {\r\n+\t\t\tClass candidate = query.getCandidateType();\r\n+\t\t\tif (candidate != null) {\r\n+\t\t\t\tClassMetaData meta = query.getStoreContext().getConfiguration()\r\n+\t\t\t\t\t\t.getMetaDataRepositoryInstance().getMetaData(candidate,\r\n+\t\t\t\t\t\t\t\tnull, true);\r\n+\t\t\t\tif (meta != null && meta.isReplicated())\r\n+\t\t\t\t\treturn true;\r\n+\t\t\t}\r\n+\t\t\tClassMetaData[] metas = query.getAccessPathMetaDatas();\r\n+\t\t\tif (metas == null || metas.length < 1)\r\n+\t\t\t\treturn false;\r\n+\t\t\tfor (ClassMetaData type : metas)\r\n+\t\t\t\tif (type.isReplicated())\r\n+\t\t\t\t\treturn true;\r\n+\t\t\treturn false;\r\n+\t\t}\r\n+\r\n+\t\tpublic Number executeDelete(StoreQuery q, Object[] params) {\r\n+\t\t\tIterator<StoreQuery> qs = owner._queries.iterator();\r\n+\t\t\tList<Future<Number>> futures = null;\r\n+\t\t\tint result = 0;\r\n+\t\t\tfor (Executor ex : executors) {\r\n+\t\t\t\tif (futures == null)\r\n+\t\t\t\t\tfutures = new ArrayList<Future<Number>>();\r\n+\t\t\t\tDeleteExecutor call = new DeleteExecutor();\r\n+\t\t\t\tcall.executor = ex;\r\n+\t\t\t\tcall.query = qs.next();\r\n+\t\t\t\tcall.params = params;\r\n+\t\t\t\tfutures.add(threadPool.submit(call));\r\n+\t\t\t}\r\n+\t\t\tfor (Future<Number> future : futures) {\r\n+\t\t\t\ttry {\r\n+\t\t\t\t\tNumber n = future.get();\r\n+\t\t\t\t\tif (n != null)\r\n+\t\t\t\t\t\tresult += n.intValue();\r\n+\t\t\t\t} catch (InterruptedException e) {\r\n+\t\t\t\t\tthrow new RuntimeException(e);\r\n+\t\t\t\t} catch (ExecutionException e) {\r\n+\t\t\t\t\tthrow new StoreException(e.getCause());\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\tpublic Number executeUpdate(StoreQuery q, Object[] params) {\r\n+\t\t\tIterator<StoreQuery> qs = owner._queries.iterator();\r\n+\t\t\tList<Future<Number>> futures = null;\r\n+\t\t\tint result = 0;\r\n+\t\t\tfor (Executor ex : executors) {\r\n+\t\t\t\tif (futures == null)\r\n+\t\t\t\t\tfutures = new ArrayList<Future<Number>>();\r\n+\t\t\t\tUpdateExecutor call = new UpdateExecutor();\r\n+\t\t\t\tcall.executor = ex;\r\n+\t\t\t\tcall.query = qs.next();\r\n+\t\t\t\tcall.params = params;\r\n+\t\t\t\tfutures.add(threadPool.submit(call));\r\n+\t\t\t}\r\n+\t\t\tfor (Future<Number> future : futures) {\r\n+\t\t\t\ttry {\r\n+\t\t\t\t\tNumber n = future.get();\r\n+\t\t\t\t\tresult += (n == null) ? 0 : n.intValue();\r\n+\t\t\t\t} catch (InterruptedException e) {\r\n+\t\t\t\t\tthrow new RuntimeException(e);\r\n+\t\t\t\t} catch (ExecutionException e) {\r\n+\t\t\t\t\tthrow new StoreException(e.getCause());\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\tList<SliceStoreManager> findTargets() {\r\n+\t\t\tFetchConfiguration fetch = owner.getContext()\r\n+\t\t\t\t\t.getFetchConfiguration();\r\n+\t\t\treturn owner.getDistributedStore().getTargets(fetch);\r\n+\t\t}\r\n \t}\r\n-\t\r\n-\tstatic  class QueryExecutor implements Callable<ResultObjectProvider> {\r\n+\r\n+\tstatic class QueryExecutor implements Callable<ResultObjectProvider> {\r\n \t\tStoreQuery query;\r\n \t\tExecutor executor;\r\n \t\tObject[] params;\r\n \t\tRange range;\r\n+\r\n \t\tpublic ResultObjectProvider call() throws Exception {\r\n-\t\t\treturn executor.executeQuery(query, params, range);\r\n+\t\t\t((QueryImpl)query.getContext()).startLocking();\r\n+\t\t\t((BrokerImpl)query.getContext().getStoreContext()).startLocking();\r\n+\t\t\t((QueryImpl)query.getContext()).lock();\r\n+\t\t\t((BrokerImpl)query.getContext().getStoreContext()).lock();\r\n+\t\t\ttry { \r\n+\t\t\t\treturn executor.executeQuery(query, params, range);\r\n+\t\t\t} finally {\r\n+\t\t\t\t((QueryImpl)query.getContext()).unlock();\r\n+\t\t\t\t((BrokerImpl)query.getContext().getStoreContext()).unlock();\r\n+\t\t\t\t((QueryImpl)query.getContext()).stopLocking();\r\n+\t\t\t\t((BrokerImpl)query.getContext().getStoreContext()).stopLocking();\r\n+\t\t\t}\r\n \t\t}\r\n \t}\r\n-\t\r\n-\tstatic  class DeleteExecutor implements Callable<Number> {\r\n+\r\n+\tstatic class DeleteExecutor implements Callable<Number> {\r\n \t\tStoreQuery query;\r\n \t\tExecutor executor;\r\n \t\tObject[] params;\r\n+\r\n \t\tpublic Number call() throws Exception {\r\n-\t\t\treturn executor.executeDelete(query, params);\r\n+\t\t\t((QueryImpl)query.getContext()).startLocking();\r\n+\t\t\t((BrokerImpl)query.getContext().getStoreContext()).startLocking();\r\n+\t\t\t((QueryImpl)query.getContext()).lock();\r\n+\t\t\t((BrokerImpl)query.getContext().getStoreContext()).lock();\r\n+\t\t\ttry { \r\n+\t\t\t\treturn executor.executeDelete(query, params);\r\n+\t\t\t} finally {\r\n+\t\t\t\t((QueryImpl)query.getContext()).unlock();\r\n+\t\t\t\t((BrokerImpl)query.getContext().getStoreContext()).unlock();\r\n+\t\t\t\t((QueryImpl)query.getContext()).stopLocking();\r\n+\t\t\t\t((BrokerImpl)query.getContext().getStoreContext()).stopLocking();\r\n+\t\t\t}\r\n \t\t}\r\n \t}\r\n-\t\r\n-\tstatic  class UpdateExecutor implements Callable<Number> {\r\n+\r\n+\tstatic class UpdateExecutor implements Callable<Number> {\r\n \t\tStoreQuery query;\r\n \t\tExecutor executor;\r\n \t\tObject[] params;\r\n+\r\n \t\tpublic Number call() throws Exception {\r\n-\t\t\treturn executor.executeUpdate(query, params);\r\n+\t\t\t((QueryImpl)query.getContext()).startLocking();\r\n+\t\t\t((BrokerImpl)query.getContext().getStoreContext()).startLocking();\r\n+\t\t\t((QueryImpl)query.getContext()).lock();\r\n+\t\t\t((BrokerImpl)query.getContext().getStoreContext()).lock();\r\n+\t\t\ttry { \r\n+\t\t\t\treturn executor.executeUpdate(query, params);\r\n+\t\t\t} finally {\r\n+\t\t\t\t((QueryImpl)query.getContext()).unlock();\r\n+\t\t\t\t((BrokerImpl)query.getContext().getStoreContext()).unlock();\r\n+\t\t\t\t((QueryImpl)query.getContext()).stopLocking();\r\n+\t\t\t\t((BrokerImpl)query.getContext().getStoreContext()).stopLocking();\r\n+\t\t\t}\r\n \t\t}\r\n \t}\r\n }\r\n-\r"},{"sha":"4de5818ec382ce9059582798f253e4a0b6cc54d5","filename":"openjpa-slice/src/main/resources/org/apache/openjpa/slice/localizer.properties","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-slice/src/main/resources/org/apache/openjpa/slice/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-slice/src/main/resources/org/apache/openjpa/slice/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/resources/org/apache/openjpa/slice/localizer.properties?ref=574d559860c58a74aead153305aef6dfc44a2fbd","patch":"@@ -17,4 +17,10 @@\n bad-policy-slice:Distribution policy \"{0}\" has returned invalid slice \\\r\n \t\"{1}\" for \"{2}\". The valid slices are {3}. This error may happen \\\r\n \twhen one or more of the originally configured slices are unavailable \\\r\n-\tand Lenient property is set to true.\n\\ No newline at end of file\n+\tand Lenient property is set to true.\r\n+forced-set-config: Configuration property \"{0}\" is not set explicitly. Setting \\\r\n+\tthis value to \"{1}\".\r\n+multithreaded-false: Configuration property \"{0}\" is set to \"false\". \\\r\n+\tIt is recommended to set \"{0}\" to \"true\", because Slice executes database \\\r\n+\toperations per slice in parallel in different threads, setting \"{0}\" to \\\r\n+\t\"false\" may cause unpredictable behavior. \n\\ No newline at end of file"},{"sha":"2ef4211e6dbbd6fe744911edeb0a2d81075b953e","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/TestBasic.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestBasic.java","raw_url":"https://github.com/apache/openjpa/raw/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestBasic.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestBasic.java?ref=574d559860c58a74aead153305aef6dfc44a2fbd","patch":"@@ -218,7 +218,7 @@ public void testPersistReplicatedObjects() {\n      * Disable this test temporarily as we undergo changes in internal slice \r\n      * information structure.\r\n      */\r\n-    public void xtestUpdateReplicatedObjects() {\r\n+    public void testUpdateReplicatedObjects() {\r\n         EntityManager em = emf.createEntityManager();\r\n         em.getTransaction().begin();\r\n         String[] names = {\"USA\", \"India\", \"China\"};\r"},{"sha":"707e7d8e645050ad47b34fdeec8dca0386343596","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQueryMultiThreaded.java","status":"modified","additions":18,"deletions":4,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQueryMultiThreaded.java","raw_url":"https://github.com/apache/openjpa/raw/574d559860c58a74aead153305aef6dfc44a2fbd/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQueryMultiThreaded.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQueryMultiThreaded.java?ref=574d559860c58a74aead153305aef6dfc44a2fbd","patch":"@@ -18,13 +18,19 @@\n  */\r\n package org.apache.openjpa.slice;\r\n \r\n+import java.io.PrintStream;\r\n+import java.io.PrintWriter;\r\n+import java.io.StringWriter;\r\n import java.util.ArrayList;\r\n import java.util.List;\r\n import java.util.concurrent.Callable;\r\n import java.util.concurrent.ExecutionException;\r\n import java.util.concurrent.ExecutorService;\r\n import java.util.concurrent.Executors;\r\n import java.util.concurrent.Future;\r\n+import java.util.concurrent.SynchronousQueue;\r\n+import java.util.concurrent.ThreadFactory;\r\n+import java.util.concurrent.ThreadPoolExecutor;\r\n import java.util.concurrent.TimeUnit;\r\n \r\n import javax.persistence.EntityManager;\r\n@@ -42,7 +48,7 @@\n \tprivate int POBJECT_COUNT = 25;\r\n \tprivate int VALUE_MIN = 100;\r\n \tprivate int VALUE_MAX = VALUE_MIN + POBJECT_COUNT - 1;\r\n-\tprivate static int THREADS = 3;\r\n+\tprivate static int THREADS = 5;\r\n \tprivate ExecutorService group; \r\n \tprivate Future[] futures;\r\n \r\n@@ -57,7 +63,14 @@ public void setUp() throws Exception {\n \t\tif (count == 0) {\r\n \t\t\tcreate(POBJECT_COUNT);\r\n \t\t}\r\n-\t\tgroup = Executors.newCachedThreadPool();\r\n+\t\tgroup = new ThreadPoolExecutor(THREADS, THREADS,\r\n+                60, TimeUnit.SECONDS,\r\n+                new SynchronousQueue<Runnable>(), new ThreadFactory() {\r\n+\t\t\t\t\tpublic Thread newThread(Runnable r) {\r\n+\t\t\t\t\t\treturn new Thread(r);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\t});\r\n \t\tfutures = new Future[THREADS];\r\n \t}\r\n \t\r\n@@ -293,8 +306,9 @@ void waitForTermination() {\n \t\t\t\t\tf.get();\r\n \t\t\t\t} catch (ExecutionException e) {\r\n \t\t\t\t\tThrowable t = e.getCause();\r\n-\t\t\t\t\tt.getCause().printStackTrace();\r\n-\t\t\t\t\tfail(\"Failed \" + t.getCause());\r\n+\t\t\t\t\tStringWriter writer = new StringWriter();\r\n+\t\t\t\t\tt.printStackTrace(new PrintWriter(writer));\r\n+\t\t\t\t\tfail(\"Failed \" + writer.toString());\r\n \t\t\t\t}\r\n \t\t} catch (InterruptedException e) {\r\n \r"}]}

