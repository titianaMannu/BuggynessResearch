{"sha":"59c7001e09e34a7394eb534ec88bc1975b2120d6","node_id":"MDY6Q29tbWl0MjA2MzY0OjU5YzcwMDFlMDllMzRhNzM5NGViNTM0ZWM4OGJjMTk3NWIyMTIwZDY=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2010-06-11T15:14:24Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2010-06-11T15:14:24Z"},"message":"OPENJPA-1686: Support when a parameterized type has parameterized type arguments\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@953717 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"f1ded139c442f39a1bc743a206c77b31d4da2b14","url":"https://api.github.com/repos/apache/openjpa/git/trees/f1ded139c442f39a1bc743a206c77b31d4da2b14"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/59c7001e09e34a7394eb534ec88bc1975b2120d6","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/59c7001e09e34a7394eb534ec88bc1975b2120d6","html_url":"https://github.com/apache/openjpa/commit/59c7001e09e34a7394eb534ec88bc1975b2120d6","comments_url":"https://api.github.com/repos/apache/openjpa/commits/59c7001e09e34a7394eb534ec88bc1975b2120d6/comments","author":null,"committer":null,"parents":[{"sha":"6b38f0cb8eb9362b103b33c1f1b646876f872a92","url":"https://api.github.com/repos/apache/openjpa/commits/6b38f0cb8eb9362b103b33c1f1b646876f872a92","html_url":"https://github.com/apache/openjpa/commit/6b38f0cb8eb9362b103b33c1f1b646876f872a92"}],"stats":{"total":113,"additions":63,"deletions":50},"files":[{"sha":"2eb843f272e3f7a9dd55184fd9b53ab794ef3dbc","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/JavaVersions.java","status":"modified","additions":63,"deletions":50,"changes":113,"blob_url":"https://github.com/apache/openjpa/blob/59c7001e09e34a7394eb534ec88bc1975b2120d6/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/JavaVersions.java","raw_url":"https://github.com/apache/openjpa/raw/59c7001e09e34a7394eb534ec88bc1975b2120d6/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/JavaVersions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/JavaVersions.java?ref=59c7001e09e34a7394eb534ec88bc1975b2120d6","patch":"@@ -23,9 +23,11 @@\n import java.security.AccessController;\n \n /**\n- * Utilities for dealing with different Java spec versions.\n+ * Utilities for dealing with different Java specification versions.\n  *\n  * @author Abe White\n+ * @author Pinaki Poddar\n+ * \n  * @nojavadoc\n  */\n public class JavaVersions {\n@@ -35,15 +37,17 @@\n      */\n     public static final int VERSION;\n \n-    private static final Class[] EMPTY_CLASSES = new Class[0];\n+    private static final Class<?>[] EMPTY_CLASSES = new Class[0];\n \n-    private static Class PARAM_TYPE = null;\n-    private static Class ENUM_TYPE = null;\n-    private static Class ANNO_TYPE = null;\n+    private static Class<?> PARAM_TYPE = null;\n+    private static Class<?> ENUM_TYPE  = null;\n+    private static Class<?> ANNO_TYPE  = null;\n     private static Method GET_STACK = null;\n     private static Method SET_STACK = null;\n     private static Method GET_CAUSE = null;\n     private static Method INIT_CAUSE = null;\n+    private static Object[] NO_ARGS  = null;\n+    private static Class<?>[] NO_CLASS_ARGS = null;\n \n     static {\n         String specVersion = AccessController.doPrivileged(\n@@ -63,8 +67,7 @@ else if (\"1.6\".equals(specVersion))\n \n         if (VERSION >= 5) {\n             try {\n-                PARAM_TYPE = Class.forName\n-                    (\"java.lang.reflect.ParameterizedType\");\n+                PARAM_TYPE = Class.forName(\"java.lang.reflect.ParameterizedType\");\n                 ENUM_TYPE = Class.forName(\"java.lang.Enum\");\n                 ANNO_TYPE = Class.forName(\"java.lang.annotation.Annotation\");\n             } catch (Throwable t) {\n@@ -73,15 +76,11 @@ else if (\"1.6\".equals(specVersion))\n \n         if (VERSION >= 4) {\n             try {\n-                Class stack = Class.forName(\"[Ljava.lang.StackTraceElement;\");\n-                GET_STACK = Throwable.class.getMethod(\"getStackTrace\",\n-                    (Class[]) null);\n-                SET_STACK = Throwable.class.getMethod(\"setStackTrace\",\n-                    new Class[]{ stack });\n-                GET_CAUSE = Throwable.class.getMethod(\"getCause\",\n-                    (Class[]) null);\n-                INIT_CAUSE = Throwable.class.getMethod(\"initCause\",\n-                    new Class[]{ Throwable.class });\n+                Class<?> stack = Class.forName(\"[Ljava.lang.StackTraceElement;\");\n+                GET_STACK = Throwable.class.getMethod(\"getStackTrace\", NO_CLASS_ARGS);\n+                SET_STACK = Throwable.class.getMethod(\"setStackTrace\", new Class[]{ stack });\n+                GET_CAUSE = Throwable.class.getMethod(\"getCause\", NO_CLASS_ARGS);\n+                INIT_CAUSE = Throwable.class.getMethod(\"initCause\", new Class[]{ Throwable.class });\n             } catch (Throwable t) {\n             }\n         }\n@@ -94,7 +93,7 @@ else if (\"1.6\".equals(specVersion))\n      * @return the JDK-version-specific version of the class\n      * @see #getVersionSpecificClass(String)\n      */\n-    public static Class getVersionSpecificClass(Class base) {\n+    public static Class<?> getVersionSpecificClass(Class<?> base) {\n         try {\n             return getVersionSpecificClass(base.getName());\n         } catch (ClassNotFoundException e) {\n@@ -125,14 +124,13 @@ public static Class getVersionSpecificClass(Class base) {\n      * @param base the base name of the class to load\n      * @return the subclass appropriate for the current Java version\n      */\n-    public static Class getVersionSpecificClass(String base)\n+    public static Class<?> getVersionSpecificClass(String base)\n         throws ClassNotFoundException {\n         for (int i = VERSION; i >= 1; i--) {\n             try {\n                 return Class.forName(base + i);\n             } catch (Throwable e) {\n-                // throwables might occur with bytecode that we\n-                // cannot understand\n+                // throwables might occur with bytecode that we cannot understand\n             }\n         }\n         return Class.forName(base);\n@@ -141,29 +139,28 @@ public static Class getVersionSpecificClass(String base)\n     /**\n      * Return true if the given type is an annotation.\n      */\n-    public static boolean isAnnotation(Class cls) {\n+    public static boolean isAnnotation(Class<?> cls) {\n         return ANNO_TYPE != null && ANNO_TYPE.isAssignableFrom(cls);\n     }\n \n     /**\n      * Return true if the given type is an enumeration.\n      */\n-    public static boolean isEnumeration(Class cls) {\n+    public static boolean isEnumeration(Class<?> cls) {\n         return ENUM_TYPE != null && ENUM_TYPE.isAssignableFrom(cls);\n     }\n \n     /**\n      * Collects the parameterized type declarations for a given field.\n      */\n-    public static Class[] getParameterizedTypes(Field f) {\n+    public static Class<?>[] getParameterizedTypes(Field f) {\n         if (f == null)\n             return null;\n         if (VERSION < 5)\n             return EMPTY_CLASSES;\n \n         try {\n-            Object type = Field.class.getMethod(\"getGenericType\",\n-                (Class[]) null).invoke(f, (Object[]) null);\n+            Object type = invokeGetter(f, \"getGenericType\");\n             return collectParameterizedTypes(type, f.getType());\n         } catch (Exception e) {\n             return EMPTY_CLASSES;\n@@ -173,15 +170,14 @@ public static boolean isEnumeration(Class cls) {\n     /**\n      * Collects the parameterized return type declarations for a given method.\n      */\n-    public static Class[] getParameterizedTypes(Method meth) {\n+    public static Class<?>[] getParameterizedTypes(Method meth) {\n         if (meth == null)\n             return null;\n         if (VERSION < 5)\n             return EMPTY_CLASSES;\n \n         try {\n-            Object type = Method.class.getMethod(\"getGenericReturnType\",\n-                (Class[]) null).invoke(meth, (Object[]) null);\n+            Object type = invokeGetter(meth, \"getGenericReturnType\");\n             return collectParameterizedTypes(type, meth.getReturnType());\n         } catch (Exception e) {\n             return EMPTY_CLASSES;\n@@ -191,41 +187,58 @@ public static boolean isEnumeration(Class cls) {\n     /**\n      * Return all parameterized classes for the given type.\n      */\n-    private static Class[] collectParameterizedTypes(Object type, Class<?> cls)\n-        throws Exception {\n-        if (PARAM_TYPE == null || !PARAM_TYPE.isInstance(type)) {\n-            if (cls.getSuperclass() != Object.class) {\n-                return collectParameterizedTypes(cls.getGenericSuperclass(), cls.getSuperclass());\n+    private static Class<?>[] collectParameterizedTypes(Object type, Class<?> cls) throws Exception {\n+        if (isParameterizedType(type)) {\n+            Object[] args = (Object[]) invokeGetter(type, \"getActualTypeArguments\");\n+            Class<?>[] clss = new Class[args.length];\n+            for (int i = 0; i < args.length; i++) {\n+                Class<?> c = extractClass(args[i]);\n+                if (c == null) {\n+                    return EMPTY_CLASSES;\n+                }\n+                clss[i] = c;\n             }\n+            return clss;\n+        } else if (cls.getSuperclass() != Object.class) {\n+            return collectParameterizedTypes(cls.getGenericSuperclass(), cls.getSuperclass());\n+        } else {\n             return EMPTY_CLASSES;\n         }\n-\n-        Object[] args = (Object[]) PARAM_TYPE.getMethod\n-            (\"getActualTypeArguments\", (Class[]) null).invoke(type,\n-            (Object[]) null);\n-        if (args.length == 0)\n-            return EMPTY_CLASSES;\n-\n-        Class[] clss = new Class[args.length];\n-        for (int i = 0; i < args.length; i++) {\n-            if (!(args[i] instanceof Class))\n-                return EMPTY_CLASSES;\n-            clss[i] = (Class) args[i];\n+    }\n+    \n+    /**\n+     * Extracts the class from the given argument, if possible. Null otherwise.\n+     */\n+    static Class<?> extractClass(Object o) throws Exception {\n+        if (o == null)\n+            return null;\n+        if (o instanceof Class)\n+            return (Class<?>)o;\n+        \n+        if (isParameterizedType(o)) {\n+            return extractClass(invokeGetter(o, \"getRawType\"));\n         }\n-        return clss;\n+        return null;\n+    }\n+    \n+    static Object invokeGetter(Object target, String method) throws Exception {\n+        return target.getClass().getMethod(method, NO_CLASS_ARGS).invoke(target, NO_ARGS);\n+    }\n+    \n+    static boolean isParameterizedType(Object cls) {\n+        return PARAM_TYPE != null && PARAM_TYPE.isInstance(cls);\n     }\n \n     /**\n      * Transfer the stack from one throwable to another, or return\n      * false if it cannot be done, possibly due to an unsupported Java version.\n      */\n     public static boolean transferStackTrace(Throwable from, Throwable to) {\n-        if (GET_STACK == null || SET_STACK == null || from == null\n-            || to == null)\n+        if (GET_STACK == null || SET_STACK == null || from == null || to == null)\n             return false;\n \n         try {\n-            Object stack = GET_STACK.invoke(from, (Object[]) null);\n+            Object stack = GET_STACK.invoke(from, NO_ARGS);\n             SET_STACK.invoke(to, new Object[]{ stack });\n             return true;\n         } catch (Throwable t) {\n@@ -241,7 +254,7 @@ public static Throwable getCause(Throwable ex) {\n             return null;\n \n         try {\n-            return (Throwable) GET_CAUSE.invoke(ex, (Object[]) null);\n+            return (Throwable) GET_CAUSE.invoke(ex, NO_ARGS);\n         } catch (Throwable t) {\n             return null;\n         }"}]}

