{"sha":"5a16e92bd964f4e7afd08af2a133c83ef0be44a0","node_id":"MDY6Q29tbWl0MjA2MzY0OjVhMTZlOTJiZDk2NGY0ZTdhZmQwOGFmMmExMzNjODNlZjBiZTQ0YTA=","commit":{"author":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2008-05-09T21:34:29Z"},"committer":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2008-05-09T21:34:29Z"},"message":"OPENJPA-598 Make BatchingPreparedStatementManagerImpl more flexible and extensible, Sub-task of OPENJPA-477\nCommitting patch provided by Fay Wang\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@654942 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"051483bf75a4e3c421d6cc26869f7be89e45f99b","url":"https://api.github.com/repos/apache/openjpa/git/trees/051483bf75a4e3c421d6cc26869f7be89e45f99b"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/5a16e92bd964f4e7afd08af2a133c83ef0be44a0","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/5a16e92bd964f4e7afd08af2a133c83ef0be44a0","html_url":"https://github.com/apache/openjpa/commit/5a16e92bd964f4e7afd08af2a133c83ef0be44a0","comments_url":"https://api.github.com/repos/apache/openjpa/commits/5a16e92bd964f4e7afd08af2a133c83ef0be44a0/comments","author":null,"committer":null,"parents":[{"sha":"01e08029e93ceb75f24297fc3471f3afe299620d","url":"https://api.github.com/repos/apache/openjpa/commits/01e08029e93ceb75f24297fc3471f3afe299620d","html_url":"https://github.com/apache/openjpa/commit/01e08029e93ceb75f24297fc3471f3afe299620d"}],"stats":{"total":134,"additions":92,"deletions":42},"files":[{"sha":"53fb46c58124118de6ec1610f8e26abad7b71e4c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java","status":"modified","additions":92,"deletions":42,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/5a16e92bd964f4e7afd08af2a133c83ef0be44a0/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/5a16e92bd964f4e7afd08af2a133c83ef0be44a0/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java?ref=5a16e92bd964f4e7afd08af2a133c83ef0be44a0","patch":"@@ -83,28 +83,32 @@ protected void flushAndUpdate(RowImpl row) throws SQLException {\n         } else {\n             // process the SQL statement, either execute it immediately or\n             // batch it for later execution.\n-            String sql = row.getSQL(_dict);\n-            if (_batchedSql == null) {\n-                // brand new SQL\n-                _batchedSql = sql;\n-            } else if (!sql.equals(_batchedSql)) {\n-                // SQL statements changed.\n-                switch (_batchedRows.size()) {\n-                case 0:\n-                    break;\n-                case 1:\n-                    // single entry in cache, direct SQL execution. \n-                    super.flushAndUpdate((RowImpl) _batchedRows.get(0));\n-                    _batchedRows.clear();\n-                    break;\n-                default:\n-                    // flush all entries in cache in batch.\n-                    flushBatch();\n-                }\n-                _batchedSql = sql;\n+            batchOrExecuteRow(row);\n+        }\n+    }\n+\n+    protected void batchOrExecuteRow(RowImpl row) throws SQLException {\n+        String sql = row.getSQL(_dict);\n+        if (_batchedSql == null) {\n+            // brand new SQL\n+            _batchedSql = sql;\n+        } else if (!sql.equals(_batchedSql)) {\n+            // SQL statements changed.\n+            switch (_batchedRows.size()) {\n+            case 0:\n+                break;\n+            case 1:\n+                // single entry in cache, direct SQL execution. \n+                super.flushAndUpdate((RowImpl) _batchedRows.get(0));\n+                _batchedRows.clear();\n+                break;\n+            default:\n+                // flush all entries in cache in batch.\n+                flushBatch();\n             }\n-            _batchedRows.add(row);\n+            _batchedSql = sql;\n         }\n+        _batchedRows.add(row);\n     }\n \n     /*\n@@ -113,8 +117,7 @@ protected void flushAndUpdate(RowImpl row) throws SQLException {\n      */\n     private boolean isBatchDisabled(RowImpl row) {\n         boolean rtnVal = true;\n-        if (_batchLimit != 0 && !_disableBatch) {\n-            String sql = row.getSQL(_dict);\n+        if (getBatchLimit() != 0 && !isBatchDisabled()) {\n             OpenJPAStateManager sm = row.getPrimaryKey();\n             ClassMapping cmd = null;\n             if (sm != null)\n@@ -123,9 +126,9 @@ private boolean isBatchDisabled(RowImpl row) {\n             if (row.getAction() == Row.ACTION_INSERT)\n                 autoAssign = row.getTable().getAutoAssignedColumns();\n             // validate batch capability\n-            _disableBatch = _dict\n+            rtnVal = _dict\n                 .validateBatchProcess(row, autoAssign, sm, cmd);\n-            rtnVal = _disableBatch;\n+            setBatchDisabled(rtnVal);\n         }\n         return rtnVal;\n     }\n@@ -135,45 +138,53 @@ private boolean isBatchDisabled(RowImpl row) {\n      * prepared statements.\n      */\n     protected void flushBatch() {\n-        if (_batchedSql != null && _batchedRows.size() > 0) {\n+        List batchedRows = getBatchedRows();\n+        String batchedSql = getBatchedSql();\n+        if (batchedRows == null)\n+            return;\n+\n+        int batchSize = batchedRows.size();\n+        if (batchedSql != null &&  batchSize > 0) {\n             PreparedStatement ps = null;\n             try {\n                 RowImpl onerow = null;\n-                ps = _conn.prepareStatement(_batchedSql);\n-                if (_batchedRows.size() == 1) {\n+                ps = prepareStatement(batchedSql);\n+                if (batchSize == 1) {\n                     // execute a single row.\n-                    onerow = (RowImpl) _batchedRows.get(0);\n+                    onerow = (RowImpl) batchedRows.get(0);\n                     flushSingleRow(onerow, ps);\n                 } else {\n                     // cache has more than one rows, execute as batch.\n                     int count = 0;\n                     int batchedRowsBaseIndex = 0;\n-                    Iterator itr = _batchedRows.iterator();\n+                    Iterator itr = batchedRows.iterator();\n                     while (itr.hasNext()) {\n                         onerow = (RowImpl) itr.next();\n                         if (_batchLimit == 1) {\n                             flushSingleRow(onerow, ps);\n                         } else {\n                             if (count < _batchLimit || _batchLimit == -1) {\n-                                onerow.flush(ps, _dict, _store);\n-                                ps.addBatch();\n+                                if (ps != null)\n+                                    onerow.flush(ps, _dict, _store);\n+                                addBatch(ps, onerow, count);\n                                 count++;\n                             } else {\n                                 // reach the batchLimit, execute the batch\n-                                int[] rtn = ps.executeBatch();\n+                                int[] rtn = executeBatch(ps);\n                                 checkUpdateCount(rtn, batchedRowsBaseIndex);\n \n                                 batchedRowsBaseIndex += _batchLimit;\n \n-                                onerow.flush(ps, _dict, _store);\n-                                ps.addBatch();\n+                                if (ps != null)\n+                                    onerow.flush(ps, _dict, _store);\n+                                addBatch(ps, onerow, count);\n                                 // reset the count to 1 for new batch\n                                 count = 1;\n                             }\n                         }\n                     }\n                     // end of the loop, execute the batch\n-                    int[] rtn = ps.executeBatch();\n+                    int[] rtn = executeBatch(ps);\n                     checkUpdateCount(rtn, batchedRowsBaseIndex);\n                 }\n             } catch (SQLException se) {\n@@ -183,7 +194,7 @@ protected void flushBatch() {\n                 throw SQLExceptions.getStore(sqex, ps, _dict);\n             } finally {\n                 _batchedSql = null;\n-                _batchedRows.clear();\n+                batchedRows.clear();\n                 if (ps != null) {\n                     try {\n                         ps.close();\n@@ -200,8 +211,9 @@ protected void flushBatch() {\n      */\n     private void flushSingleRow(RowImpl row, PreparedStatement ps)\n         throws SQLException {\n-        row.flush(ps, _dict, _store);\n-        int count = ps.executeUpdate();\n+        if (ps != null)\n+            row.flush(ps, _dict, _store);\n+        int count = executeUpdate(ps, row.getSQL(_dict), row);\n         if (count != 1) {\n             Object failed = row.getFailedObject();\n             if (failed != null)\n@@ -219,9 +231,10 @@ private void checkUpdateCount(int[] count, int batchedRowsBaseIndex)\n         throws SQLException {\n         int cnt = 0;\n         Object failed = null;\n+        List batchedRows = getBatchedRows();\n         for (int i = 0; i < count.length; i++) {\n             cnt = count[i];\n-            RowImpl row = (RowImpl) _batchedRows.get(batchedRowsBaseIndex + i);\n+            RowImpl row = (RowImpl) batchedRows.get(batchedRowsBaseIndex + i);\n             failed = row.getFailedObject();\n             switch (cnt) {\n             case Statement.EXECUTE_FAILED: // -3\n@@ -230,14 +243,16 @@ private void checkUpdateCount(int[] count, int batchedRowsBaseIndex)\n                 else if (row.getAction() == Row.ACTION_INSERT)\n                     throw new SQLException(_loc.get(\n                         \"update-failed-no-failed-obj\",\n-                        String.valueOf(count[i]), _batchedSql).getMessage());\n+                        String.valueOf(count[i]), \n+                        row.getSQL(_dict)).getMessage());\n                 break;\n             case Statement.SUCCESS_NO_INFO: // -2\n                 if (failed != null || row.getAction() == Row.ACTION_UPDATE)\n                     _exceptions.add(new OptimisticException(failed));\n                 else if (_log.isTraceEnabled())\n                     _log.trace(_loc.get(\"batch_update_info\",\n-                        String.valueOf(cnt), _batchedSql).getMessage());\n+                        String.valueOf(cnt), \n+                        row.getSQL(_dict)).getMessage());\n                 break;\n             case 0: // no row is inserted, treats it as failed\n                 // case\n@@ -246,8 +261,43 @@ else if (_log.isTraceEnabled())\n                 else if (row.getAction() == Row.ACTION_INSERT)\n                     throw new SQLException(_loc.get(\n                         \"update-failed-no-failed-obj\",\n-                        String.valueOf(count[i]), _batchedSql).getMessage());\n+                        String.valueOf(count[i]), \n+                        row.getSQL(_dict)).getMessage());\n             }\n         }\n     }\n+\n+    public boolean isBatchDisabled() {\n+        return _disableBatch;\n+    }\n+\n+    public void setBatchDisabled(boolean disableBatch) {\n+        _disableBatch = disableBatch;\n+    }\n+\n+    public int getBatchLimit() {\n+        return _batchLimit;\n+    }\n+\n+    public void setBatchLimit(int batchLimit) {\n+        _batchLimit = batchLimit;\n+    }\n+\n+    public List getBatchedRows() {\n+        return _batchedRows;\n+    }\n+\n+    public String getBatchedSql() {\n+        return _batchedSql;\n+    }\n+\n+    protected void addBatch(PreparedStatement ps, RowImpl row, \n+            int count) throws SQLException {\n+        ps.addBatch();\n+    }\n+\n+    protected int[] executeBatch(PreparedStatement ps) \n+    throws SQLException {\n+        return ps.executeBatch();\n+    }\n }"}]}

