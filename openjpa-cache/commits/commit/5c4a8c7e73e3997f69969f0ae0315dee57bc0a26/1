{"sha":"5c4a8c7e73e3997f69969f0ae0315dee57bc0a26","node_id":"MDY6Q29tbWl0MjA2MzY0OjVjNGE4YzdlNzNlMzk5N2Y2OTk2OWYwYWUwMzE1ZGVlNTdiYzBhMjY=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-06-29T23:08:41Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-06-29T23:08:41Z"},"message":"OPENJPA-70. Added new RemoteCommitEvent payload type and logic to fire RemoteCommitEvents when stale records are detected. This logic still gets fired via afterCommit(), even though these checks can happen either after a commit or a flush is issued. Additionally, these events are only fired against local listeners, so actually represent local analysis that is detecting remote events, rather than remote events themselves.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@552059 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5e8e73fd2128b4fc52b2cef93b8a81a0941e4be2","url":"https://api.github.com/repos/apache/openjpa/git/trees/5e8e73fd2128b4fc52b2cef93b8a81a0941e4be2"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/5c4a8c7e73e3997f69969f0ae0315dee57bc0a26","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/5c4a8c7e73e3997f69969f0ae0315dee57bc0a26","html_url":"https://github.com/apache/openjpa/commit/5c4a8c7e73e3997f69969f0ae0315dee57bc0a26","comments_url":"https://api.github.com/repos/apache/openjpa/commits/5c4a8c7e73e3997f69969f0ae0315dee57bc0a26/comments","author":null,"committer":null,"parents":[{"sha":"7db9a7fae5397c99d72efb63b018436a0294a151","url":"https://api.github.com/repos/apache/openjpa/commits/7db9a7fae5397c99d72efb63b018436a0294a151","html_url":"https://github.com/apache/openjpa/commit/7db9a7fae5397c99d72efb63b018436a0294a151"}],"stats":{"total":90,"additions":74,"deletions":16},"files":[{"sha":"91ec050432c7ac2d94ada78b9851c373f1d45269","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","status":"modified","additions":19,"deletions":10,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/5c4a8c7e73e3997f69969f0ae0315dee57bc0a26/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/5c4a8c7e73e3997f69969f0ae0315dee57bc0a26/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java?ref=5c4a8c7e73e3997f69969f0ae0315dee57bc0a26","patch":"@@ -513,7 +513,7 @@ public Collection flush(Collection states) {\n             for (Iterator iter = exceps.iterator(); iter.hasNext(); ) {\n                 Exception e = (Exception) iter.next();\n                 if (e instanceof OptimisticException)\n-                    evictOptimisticLockFailure((OptimisticException) e);\n+                    notifyOptimisticLockFailure((OptimisticException) e);\n             }\n             return exceps;\n         }\n@@ -552,22 +552,25 @@ else if (sm.getPCState() == PCState.PDIRTY) {\n     }\n \n     /**\n-     * Evict from the cache the OID (if available) that resulted in an\n-     * optimistic lock exception iff the version information in the cache \n-     * matches the version information in the state manager for the failed\n-     * instance. This means that we will evict data from the cache for records \n-     * that should have successfully committed according to the data cache but \n+     * Fire local staleness detection events from the cache the OID (if\n+     * available) that resulted in an optimistic lock exception iff the\n+     * version information in the cache matches the version information\n+     * in the state manager for the failed instance. This means that we\n+     * will evict data from the cache for records that should have\n+     * successfully committed according to the data cache but\n      * did not. The only predictable reason that could cause this behavior\n      * is a concurrent out-of-band modification to the database that was not \n      * communicated to the cache. This logic makes OpenJPA's data cache \n      * somewhat tolerant of such behavior, in that the cache will be cleaned \n      * up as failures occur.\n      */\n-    private void evictOptimisticLockFailure(OptimisticException e) {\n-        Object o = ((OptimisticException) e).getFailedObject();\n+    private void notifyOptimisticLockFailure(OptimisticException e) {\n+        Object o = e.getFailedObject();\n         OpenJPAStateManager sm = _ctx.getStateManager(o);\n         if (sm == null)\n             return;\n+        Object oid = sm.getId();\n+        boolean remove;\n \n         // this logic could be more efficient -- we could aggregate\n         // all the cache->oid changes, and then use DataCache.removeAll() \n@@ -579,11 +582,10 @@ private void evictOptimisticLockFailure(OptimisticException e) {\n \n         cache.writeLock();\n         try {\n-            DataCachePCData data = cache.get(sm.getId());\n+            DataCachePCData data = cache.get(oid);\n             if (data == null)\n                 return;\n \n-            boolean remove;\n             switch (compareVersion(sm, sm.getVersion(), data.getVersion())) {\n                 case StoreManager.VERSION_LATER:\n                 case StoreManager.VERSION_SAME:\n@@ -614,10 +616,17 @@ private void evictOptimisticLockFailure(OptimisticException e) {\n                     break;\n             }\n             if (remove)\n+                // remove directly instead of via the RemoteCommitListener\n+                // since we have a write lock here already, so this is more\n+                // efficient than read-locking and then write-locking later.\n                 cache.remove(sm.getId());\n         } finally {\n             cache.writeUnlock();\n         }\n+\n+        // fire off a remote commit stalenesss detection event.\n+        _ctx.getConfiguration().getRemoteCommitEventManager()\n+            .fireLocalStaleNotification(oid);\n     }\n \n     public StoreQuery newQuery(String language) {"},{"sha":"5036e44f836f259ed629e10402443c4ca90586dd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java","status":"modified","additions":15,"deletions":3,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/5c4a8c7e73e3997f69969f0ae0315dee57bc0a26/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java","raw_url":"https://github.com/apache/openjpa/raw/5c4a8c7e73e3997f69969f0ae0315dee57bc0a26/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java?ref=5c4a8c7e73e3997f69969f0ae0315dee57bc0a26","patch":"@@ -40,12 +40,12 @@\n     implements Externalizable {\n \n     /**\n-     * Names of added classes, upated and deleted Object IDs.\n+     * Names of added classes, updated and deleted Object IDs.\n      */\n     public static final int PAYLOAD_OIDS = 0;\n \n     /**\n-     * Names of added classes, added, upated and deleted Object IDs.\n+     * Names of added classes, added, updated and deleted Object IDs.\n      */\n     public static final int PAYLOAD_OIDS_WITH_ADDS = 1;\n \n@@ -54,6 +54,16 @@\n      */\n     public static final int PAYLOAD_EXTENTS = 2;\n \n+    /**\n+     * The local {@link BrokerFactory} detected that local data is out of date\n+     * with the data store. Stale object IDs will be in t he updated set,\n+     * although it is possible that records were actually deleted, rather than\n+     * updated.\n+     *\n+     * @since 1.0.0\n+     */\n+    public static final int PAYLOAD_LOCAL_STALE_DETECTION = 3;\n+\n     private static final Localizer s_loc = Localizer.forPackage\n         (RemoteCommitEvent.class);\n \n@@ -114,7 +124,9 @@ public Collection getPersistedObjectIds() {\n \n     /**\n      * When the event type is not PAYLOAD_EXTENTS, return the set of\n-     * object IDs for updated objects.\n+     * object IDs for updated objects. When the event type is\n+     * PAYLOAD_LOCAL_STALE_DETECTION, items in this list may actually have\n+     * been deleted from the database.\n      */\n     public Collection getUpdatedObjectIds() {\n         if (_payload == PAYLOAD_EXTENTS)"},{"sha":"2dd697e5653abc3b2ec70bd45822da7900a232d2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/5c4a8c7e73e3997f69969f0ae0315dee57bc0a26/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/5c4a8c7e73e3997f69969f0ae0315dee57bc0a26/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java?ref=5c4a8c7e73e3997f69969f0ae0315dee57bc0a26","patch":"@@ -23,6 +23,7 @@\n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Collections;\n \n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.kernel.Broker;\n@@ -116,6 +117,17 @@ protected void fireEvent(Object event, Object listener) {\n         listen.afterCommit(ev);\n     }\n \n+    /**\n+     * Fire an event to local listeners only notifying them of a detected\n+     * stale record.\n+     */\n+    public void fireLocalStaleNotification(Object oid) {\n+        RemoteCommitEvent ev = new RemoteCommitEvent(\n+            RemoteCommitEvent.PAYLOAD_LOCAL_STALE_DETECTION,\n+            null, null, Collections.singleton(oid), null);\n+        fireEvent(ev);\n+    }\n+\n     //////////////////////////////////////\n     // TransactionListener implementation\n     //////////////////////////////////////"},{"sha":"d1433dcebf2dea8ffef4db55ac3b7ebc5861f37e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java","status":"modified","additions":28,"deletions":3,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/5c4a8c7e73e3997f69969f0ae0315dee57bc0a26/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java","raw_url":"https://github.com/apache/openjpa/raw/5c4a8c7e73e3997f69969f0ae0315dee57bc0a26/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java?ref=5c4a8c7e73e3997f69969f0ae0315dee57bc0a26","patch":"@@ -28,17 +28,36 @@\n \r\n import org.apache.openjpa.persistence.OpenJPAPersistence;\r\n import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n+import org.apache.openjpa.event.RemoteCommitListener;\r\n+import org.apache.openjpa.event.RemoteCommitEvent;\r\n \r\n public class TestDataCacheOptimisticLockRecovery\r\n     extends SingleEMFTestCase {\r\n \r\n     private int pk;\r\n+    private int remoteCommitEventStaleCount = 0;\r\n+    private Object staleOid;\r\n \r\n     public void setUp() {\r\n         setUp(\"openjpa.DataCache\", \"true\",\r\n             \"openjpa.RemoteCommitProvider\", \"sjvm\",\r\n             OptimisticLockInstance.class);\r\n \r\n+        emf.getConfiguration().getRemoteCommitEventManager().addListener(\r\n+            new RemoteCommitListener() {\r\n+                public void afterCommit(RemoteCommitEvent e) {\r\n+                    if (e.getPayloadType() ==\r\n+                        RemoteCommitEvent.PAYLOAD_LOCAL_STALE_DETECTION) {\r\n+                        remoteCommitEventStaleCount++;\r\n+                        staleOid = e.getUpdatedObjectIds().iterator().next();\r\n+                    }\r\n+                }\r\n+\r\n+                public void close() {\r\n+                }\r\n+            }\r\n+        );\r\n+\r\n         EntityManager em = emf.createEntityManager();\r\n         em.getTransaction().begin();\r\n         OptimisticLockInstance oli = new OptimisticLockInstance(\"foo\");\r\n@@ -59,6 +78,9 @@ public void testOptimisticLockRecovery()\n         em = emf.createEntityManager();\r\n         em.getTransaction().begin();\r\n         OptimisticLockInstance oli = em.find(OptimisticLockInstance.class, pk);\r\n+        Object oid = OpenJPAPersistence.toOpenJPAObjectId(\r\n+            OpenJPAPersistence.getMetaData(oli),\r\n+            OpenJPAPersistence.cast(em).getObjectId(oli));\r\n         int firstOpLockValue = oli.getOpLock();\r\n         em.lock(oli, LockModeType.READ);\r\n \r\n@@ -90,7 +112,11 @@ public void testOptimisticLockRecovery()\n                 em.getTransaction().rollback();\r\n         }\r\n \r\n-        // 4. obtain the object in a new persistence context and\r\n+        // 4. check that the corresponding remote commit event was fired\r\n+        assertEquals(1, remoteCommitEventStaleCount);\r\n+        assertEquals(oid, staleOid);\r\n+\r\n+        // 5. obtain the object in a new persistence context and\r\n         // assert that the oplock column is set to the one that\r\n         // happened in the out-of-band transaction\r\n         em.close();\r\n@@ -102,14 +128,13 @@ public void testOptimisticLockRecovery()\n         assertEquals(\"data cache is not being cleared when oplock \"\r\n             + \"violations occur\", secondOpLockValue, oli.getOpLock());\r\n \r\n-        // 5. get a read lock on the instance and commit the tx; this\r\n+        // 6. get a read lock on the instance and commit the tx; this\r\n         // time it should go through\r\n         em.getTransaction().begin();\r\n         em.lock(oli, LockModeType.READ);\r\n         try {\r\n             em.getTransaction().commit();\r\n         } catch (RollbackException e) {\r\n-            e.printStackTrace();\r\n             throw e;\r\n         } finally {\r\n             if (em.getTransaction().isActive())\r"}]}

