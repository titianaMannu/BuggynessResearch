{"sha":"5d765ea05b1f786c2bc6d48e3231c5d3a5166269","node_id":"MDY6Q29tbWl0MjA2MzY0OjVkNzY1ZWEwNWIxZjc4NmMyYmM2ZDQ4ZTMyMzFjNWQzYTUxNjYyNjk=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-11-24T20:12:00Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-11-24T20:12:00Z"},"message":"OPENJPA-1386: Improve handling of imports that can hide each other\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@883846 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b3f116a159064d3c45b68fdb70fe5172c8523a71","url":"https://api.github.com/repos/apache/openjpa/git/trees/b3f116a159064d3c45b68fdb70fe5172c8523a71"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/5d765ea05b1f786c2bc6d48e3231c5d3a5166269","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/5d765ea05b1f786c2bc6d48e3231c5d3a5166269","html_url":"https://github.com/apache/openjpa/commit/5d765ea05b1f786c2bc6d48e3231c5d3a5166269","comments_url":"https://api.github.com/repos/apache/openjpa/commits/5d765ea05b1f786c2bc6d48e3231c5d3a5166269/comments","author":null,"committer":null,"parents":[{"sha":"0635172cbbb5049ae10808a1aea635b6275c675a","url":"https://api.github.com/repos/apache/openjpa/commits/0635172cbbb5049ae10808a1aea635b6275c675a","html_url":"https://github.com/apache/openjpa/commit/0635172cbbb5049ae10808a1aea635b6275c675a"}],"stats":{"total":128,"additions":86,"deletions":42},"files":[{"sha":"c24b9b27634022b7abe5812a8cd53954ca912fd7","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/util/SourceCode.java","status":"modified","additions":86,"deletions":42,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/5d765ea05b1f786c2bc6d48e3231c5d3a5166269/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/util/SourceCode.java","raw_url":"https://github.com/apache/openjpa/raw/5d765ea05b1f786c2bc6d48e3231c5d3a5166269/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/util/SourceCode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/util/SourceCode.java?ref=5d765ea05b1f786c2bc6d48e3231c5d3a5166269","patch":"@@ -55,10 +55,10 @@\n     public static final String  DOT           = \".\";\n     public static final String  EQUAL         = \"=\";\n     public static final String  QUOTE         = \"\\\"\";\n-//    public static final String NEWLINE        = \"\\r\\n\";\n-\tprivate static final String[] BRACKET_BLOCK  = {\"{\", \"}\"};\n-\tprivate static final String[] BRACKET_ARGS   = {\"(\", \")\"};\n-    private static final String[] BRACKET_PARAMS = {\"<\", \">\"};\n+\n+\tprivate static final Delimiter BLOCK_DELIMITER  = new Delimiter(\"{}\");\n+\tprivate static final Delimiter ARGS_DELIMITER   = new Delimiter(\"()\");\n+    private static final Delimiter PARAMS_DELIMITER = new Delimiter(\"<>\");\n \t\n \tprivate List<Comment> comments;\n \tprivate final Package pkg;\n@@ -71,7 +71,7 @@\n \t * class name. \n \t */\n \tpublic SourceCode(String c) {\n-\t    ClassName name = new ClassName(c);\n+\t    ClassName name = getOrCreateImport(c);\n \t    this.cls = new Class(c);\n         this.pkg = new Package(name.getPackageName());\n \t}\n@@ -95,7 +95,15 @@ public SourceCode setTabSize(int t) {\n         return this;\n     }\n \n-\tboolean addImport(ClassName name) {\n+    /**\n+     * Adds import to this source code. Adding an import may force the given class name\n+     * to use its full name if it is hidden by other imports.\n+     * \n+     * @param name a ClassName instance\n+     * @return true if the import is added. ClassName starting with <code>java.lang.</code>\n+     * is not added.\n+     */\n+\tprivate boolean addImport(ClassName name) {\n \t\tString pkgName = name.getPackageName();\n \t\tif (\"java.lang\".equals(pkgName))\n \t\t\treturn false;\n@@ -108,6 +116,27 @@ boolean addImport(ClassName name) {\n \t\treturn imports.add(new Import(name));\n \t}\n \t\n+\t/**\n+\t * Get the class name instance for the given fully-qualified class name.\n+\t * If the given class name is already imported, then use the existing instance.\n+\t * Otherwise, creates a new instance and adds it to list of imports. \n+\t * \n+\t * @see #addImport(ClassName)\n+\t * @see ClassName\n+\t * \n+\t * @param name fully-qualified name of a class\n+\t * @return an existing class name instance or a new one. \n+\t */\n+\tClassName getOrCreateImport(String name) {\n+\t    for (Import i : imports) {\n+\t        if (i.name.getFullName().equals(name))\n+\t            return i.name;\n+\t    }\n+\t    ClassName imp = new ClassName(name);\n+\t    addImport(imp);\n+\t    return imp;\n+\t}\n+\t\n \t\n \tpublic SourceCode addComment(boolean inline, String... lines) {\n \t    if (lines == null)\n@@ -178,23 +207,24 @@ static void tab(PrintWriter out, int tab) {\n     }\n \t\n     static void writeList(PrintWriter out, String header, List<?> list) { \n-        writeList(out, header, list, new String[]{BLANK, BLANK}, false);\n+        writeList(out, header, list, new Delimiter(), false);\n     }\n \t\n \tstatic void writeList(PrintWriter out, String header, List<?> list, \n-\t\t\tString[] bracket, boolean writeEmpty) {\n+\t\t\tDelimiter bracket, boolean writeEmpty) {\n \t\tif (list == null || list.isEmpty()) {\n \t\t    if (writeEmpty)\n-\t\t        out.append(bracket[0]+bracket[1]);\n+\t\t        out.append(bracket.start)\n+\t\t           .append(bracket.end);\n \t\t\treturn;\n \t\t}\n \t\tout.append(header);\n-\t\tout.append(bracket[0]);\n+\t\tout.append(bracket.start);\n \t\tfor (int i=0; i<list.size(); i++) {\n \t\t\tout.append(list.get(i).toString());\n \t\t\tif (i!=list.size()-1) out.append(COMMA);\n \t\t}\n-\t\tout.append(bracket[1]);\n+\t\tout.append(bracket.end);\n \t}\n \t\n \tstatic String capitalize(String s) {\n@@ -268,7 +298,7 @@ public Annotation addAnnotation(String a) {\n \t\t}\n \t\t\n \t\tpublic Element<T> addParameter(String param) {\n-\t\t    params.add(new ClassName(param));\n+\t\t    params.add(getOrCreateImport(param));\n \t\t    return this;\n \t\t}\n \t\t\n@@ -334,17 +364,17 @@ public void write(PrintWriter out, int tab) {\n \t    private Set<Method> methods = new TreeSet<Method>();\n \t\t\n \t\tpublic Class(String name) {\n-\t\t\tsuper(name, new ClassName(name));\n+\t\t\tsuper(name, getOrCreateImport(name));\n \t\t\tmakePublic();\n \t\t}\n \t\t\n \t\tpublic Class setSuper(String s) {\n-\t\t\tsuperCls = new ClassName(s);\n+\t\t\tsuperCls = getOrCreateImport(s);\n \t\t\treturn this;\n \t\t}\n \t\t\n \t\tpublic Class addInterface(String s) {\n-\t\t\tinterfaces.add(new ClassName(s));\n+\t\t\tinterfaces.add(getOrCreateImport(s));\n \t\t\treturn this;\n \t\t}\n \t\t\n@@ -371,7 +401,7 @@ public String getPackageName() {\n         }\n         \n         public Field addField(String name, String type) {\n-            return addField(name, new ClassName(type));\n+            return addField(name, getOrCreateImport(type));\n         }\n \n         public Field addField(String f, ClassName type) {\n@@ -388,15 +418,15 @@ public Field addField(String f, ClassName type) {\n \t    }\n \n         public Method addMethod(String m, String retType) {\n-            return addMethod(m, new ClassName(retType));\n+            return addMethod(m, getOrCreateImport(retType));\n         }\n         \n \t    protected Method addMethod(String m, ClassName retType) {\n \t        if (isEmpty(m) || !isValidToken(m)) {\n \t            throw new IllegalArgumentException(_loc.get(\n \t                \"src-invalid-method\",m).toString());\n \t        }\n-\t        Method method = new Method(this, m, retType);\n+\t        Method method = new Method(m, retType);\n \t        if (!methods.add(method)) \n \t            throw new IllegalArgumentException(_loc.get(\n \t                \"src-duplicate-method\", method, this).toString());\n@@ -409,16 +439,16 @@ public void write(PrintWriter out, int tab) {\n \t\t\t    out.append(\"abstract \");\n \t\t\tout.print(\"class \");\n \t\t\tout.print(type.simpleName);\n-\t\t\twriteList(out, BLANK, params, BRACKET_PARAMS, false);\n+\t\t\twriteList(out, BLANK, params, PARAMS_DELIMITER, false);\n \t\t\tif (superCls != null)\n \t\t\t\tout.print(\" extends \" + superCls + SPACE);\n \t\t\twriteList(out, \"implements \", interfaces);\n-\t\t\tout.println(SPACE + BRACKET_BLOCK[0]);\n+\t\t\tout.println(SPACE + BLOCK_DELIMITER.start);\n \t        for (Field field:fields) \n \t            field.write(out, 1);\n \t        for (Method method:methods) \n \t            method.write(out, 1);\n-\t        out.println(BRACKET_BLOCK[1]);\n+\t        out.println(BLOCK_DELIMITER.end);\n \t\t}\n \t    \n \t    public String toString() {\n@@ -482,7 +512,7 @@ public void write(PrintWriter out, int tab) {\n \t\t\tif (isVolatile) out.print(\"volatile \");\n \t\t\tif (isTransient) out.print(\"transient \");\n \t\t\tout.print(type);\n-\t\t\twriteList(out, BLANK, params, BRACKET_PARAMS, false);\n+\t\t\twriteList(out, BLANK, params, PARAMS_DELIMITER, false);\n \t\t\tout.println(SPACE + name + SEMICOLON);\n \t\t}\n \t\t\n@@ -501,19 +531,16 @@ public boolean equals(Object other) {\n \t *\n \t */\n \tclass Method  extends Element<Method> {\n-\t    private final Class owner;\n \t\tprivate boolean isAbstract;\n-\t\tprivate List<Argument<ClassName,String>> args = \n-\t\t    new ArrayList<Argument<ClassName,String>>();\n+\t\tprivate List<Argument<ClassName,String>> args = new ArrayList<Argument<ClassName,String>>();\n \t\tprivate List<String> codeLines = new ArrayList<String>();\n \t\t\n-        Method(Class owner, String n, String t) {\n-            this(owner, n, new ClassName(t));\n+        Method(String n, String t) {\n+            this(n, getOrCreateImport(t));\n         }\n         \n-        public Method(Class owner, String name, ClassName returnType) {\n+        public Method(String name, ClassName returnType) {\n             super(name, returnType);\n-            this.owner = owner;\n             makePublic();\n         }\n \t\t\n@@ -551,18 +578,18 @@ public void write(PrintWriter out, int tab) {\n \t\t\tsuper.write(out, tab);\n \t\t\tif (isAbstract) out.append(\"abstract \");\n \t\t\tout.print(type + SPACE + name);\n-\t\t\twriteList(out, BLANK, args, BRACKET_ARGS, true);\n+\t\t\twriteList(out, BLANK, args, ARGS_DELIMITER, true);\n \t\t\tif (isAbstract) {\n \t\t\t\tout.println(SEMICOLON);\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\tout.println(SPACE + BRACKET_BLOCK[0]);\n+\t\t\tout.println(SPACE + BLOCK_DELIMITER.start);\n \t\t\tfor (String line : codeLines) {\n \t\t\t\ttab(out, tab+1);\n \t\t\t\tout.println(line);\n \t\t\t}\n \t\t\ttab(out, tab);\n-\t\t\tout.println(BRACKET_BLOCK[1]);\n+\t\t\tout.println(BLOCK_DELIMITER.end);\n \t\t}\n \t\t\n \t\tpublic boolean equals(Object other) {\n@@ -595,7 +622,7 @@ public void write(PrintWriter out, int tab) {\n \t\t    String pkg = name.getPackageName();\n \t\t    if (pkg.length() == 0 || pkg.equals(getPackage().name))\n \t\t        return;\n-\t\t    out.println(\"import \"+ name.getName() + SEMICOLON);\n+\t\t    out.println(\"import \"+ name.getFullName() + SEMICOLON);\n \t\t}\n \t\t\n \t\tpublic boolean equals(Object other) {\n@@ -653,12 +680,12 @@ public Annotation addArgument(String key, String v) {\n         }\n         \n         public Annotation addArgument(String key, String[] vs) {\n-            StringBuffer tmp = new StringBuffer(BRACKET_BLOCK[0]);\n+            StringBuffer tmp = new StringBuffer(BLOCK_DELIMITER.start);\n             for (int i=0; i < vs.length; i++) {\n                 tmp.append(quote(vs[i]));\n                 tmp.append(i != vs.length-1 ? COMMA : BLANK);\n             }\n-            tmp.append(BRACKET_BLOCK[1]);\n+            tmp.append(BLOCK_DELIMITER.end);\n             return addArgument(key, tmp.toString(), false);\n         }\n         \n@@ -670,7 +697,7 @@ public Annotation addArgument(String key, String[] vs) {\n \t\tpublic void write(PrintWriter out, int tab) {\n \t\t\ttab(out, tab);\n \t\t\tout.println(\"@\"+name);\n-\t\t\twriteList(out, BLANK, args, BRACKET_ARGS, false);\n+\t\t\twriteList(out, BLANK, args, ARGS_DELIMITER, false);\n \t\t\tout.println();\n \t\t}\n \t\t\n@@ -732,11 +759,10 @@ public void write(PrintWriter out, int tab) {\n \t/**\n \t * Represents fully-qualified name of a Java type.\n \t * \n-\t * Constructing a name adds it to the list of imports for the enclosing\n-\t * SourceCode.\n-\t *\n+\t * NOTE: Do not construct directly unless necessary.\n+\t * @see SourceCode#getOrCreateImport(String)\n \t */\n-\tclass ClassName implements Comparable<ClassName> {\n+\tprivate class ClassName implements Comparable<ClassName> {\n         public final String fullName;\n         public final String simpleName;\n         public final String pkgName;\n@@ -756,13 +782,12 @@ public void write(PrintWriter out, int tab) {\n                 throw new IllegalArgumentException(_loc.get(\"src-invalid-type\", \n                     name).toString());\n             }\n-            addImport(this);\n \t    }\n \t    \n \t    /**\n \t     * Gets fully qualified name of this receiver.\n \t     */\n-\t    public String getName() {\n+\t    public String getFullName() {\n \t        return fullName + arrayMarker;\n \t    }\n \t    \n@@ -834,6 +859,25 @@ boolean usingFullName() {\n \t    \n \t}\n \t\n+\tstatic class Delimiter {\n+\t    final char start;\n+\t    final char end;\n+\t    \n+        public Delimiter() {\n+            this((char)0, (char)0);\n+        }\n+\n+\t    public Delimiter(String pair) {\n+\t        this(pair.charAt(0), pair.charAt(1));\n+\t    }\n+\t    \n+        public Delimiter(char start, char end) {\n+            super();\n+            this.start = start;\n+            this.end = end;\n+        }\n+\t}\n+\t\n \tstatic {\n \t\treserved.add(\"abstract\");\n \t\treserved.add(\"continue\");"}]}

