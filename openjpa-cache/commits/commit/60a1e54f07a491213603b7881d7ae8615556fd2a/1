{"sha":"60a1e54f07a491213603b7881d7ae8615556fd2a","node_id":"MDY6Q29tbWl0MjA2MzY0OjYwYTFlNTRmMDdhNDkxMjEzNjAzYjc4ODFkN2FlODYxNTU1NmZkMmE=","commit":{"author":{"name":"A. Abram White","email":"awhite@apache.org","date":"2007-04-06T19:17:44Z"},"committer":{"name":"A. Abram White","email":"awhite@apache.org","date":"2007-04-06T19:17:44Z"},"message":"OPENJPA-202 : Don't detach LRS fields.  \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@526253 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"8390000749c6fcfaa1dfa2f4b2c7f59715ed2815","url":"https://api.github.com/repos/apache/openjpa/git/trees/8390000749c6fcfaa1dfa2f4b2c7f59715ed2815"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/60a1e54f07a491213603b7881d7ae8615556fd2a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/60a1e54f07a491213603b7881d7ae8615556fd2a","html_url":"https://github.com/apache/openjpa/commit/60a1e54f07a491213603b7881d7ae8615556fd2a","comments_url":"https://api.github.com/repos/apache/openjpa/commits/60a1e54f07a491213603b7881d7ae8615556fd2a/comments","author":null,"committer":null,"parents":[{"sha":"8ece757233957518b2cf30b67f7a9103acf4bced","url":"https://api.github.com/repos/apache/openjpa/commits/8ece757233957518b2cf30b67f7a9103acf4bced","html_url":"https://github.com/apache/openjpa/commit/8ece757233957518b2cf30b67f7a9103acf4bced"}],"stats":{"total":357,"additions":267,"deletions":90},"files":[{"sha":"7c32253c721a890fef9c2d29788f6701676976db","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","status":"modified","additions":93,"deletions":87,"changes":180,"blob_url":"https://github.com/apache/openjpa/blob/60a1e54f07a491213603b7881d7ae8615556fd2a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","raw_url":"https://github.com/apache/openjpa/raw/60a1e54f07a491213603b7881d7ae8615556fd2a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java?ref=60a1e54f07a491213603b7881d7ae8615556fd2a","patch":"@@ -40,6 +40,7 @@\n import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.util.CallbackException;\n+import org.apache.openjpa.util.LRSProxy;\n import org.apache.openjpa.util.ObjectNotFoundException;\n import org.apache.openjpa.util.Proxy;\n import org.apache.openjpa.util.ProxyManager;\n@@ -163,6 +164,12 @@ else if (detachMode == DETACH_ALL)\n                 setFetchGroupFields(broker, sm, idxs);\n             else\n                 idxs.or(sm.getLoaded());\n+\n+            // clear lrs fields\n+            FieldMetaData[] fmds = sm.getMetaData().getFields();\n+            for (int i = 0; i < fmds.length; i++)\n+                if (fmds[i].isLRS())\n+                    idxs.clear(i);\n         }\n     }\n \n@@ -482,46 +489,49 @@ public void detachVersion() {\n                 fmd.getTypeCode());\n             val = fmd.getFieldValue(val, sm.getBroker());\n             switch (fmd.getDeclaredTypeCode()) {\n-                case JavaTypes.LONG:\n-                case JavaTypes.SHORT:\n-                case JavaTypes.INT:\n-                case JavaTypes.BYTE:\n-                    longval = (val == null) ? 0L : ((Number) val).longValue();\n-                    break;\n-                case JavaTypes.DOUBLE:\n-                case JavaTypes.FLOAT:\n-                    dblval = (val == null) ? 0D : ((Number) val).doubleValue();\n-                    break;\n-                default:\n-                    objval = val;\n+            case JavaTypes.LONG:\n+            case JavaTypes.SHORT:\n+            case JavaTypes.INT:\n+            case JavaTypes.BYTE:\n+                longval = (val == null) ? 0L : ((Number) val).longValue();\n+                break;\n+            case JavaTypes.DOUBLE:\n+            case JavaTypes.FLOAT:\n+                dblval = (val == null) ? 0D : ((Number) val).doubleValue();\n+                break;\n+            default:\n+                objval = val;\n             }\n             sm.replaceField(getDetachedPersistenceCapable(), this,\n                 fmd.getIndex());\n         }\n \n         /**\n-         * Unproxies second class object fields; in the future we should\n-         * instead set these fields up for change tracking.\n+         * Unproxies second class object fields.\n          */\n         public void reproxy(DetachedStateManager dsm) {\n             FieldMetaData[] fmds = sm.getMetaData().getFields();\n             for (int i = 0; i < fmds.length; i++) {\n                 switch (fmds[i].getDeclaredTypeCode()) {\n-                    case JavaTypes.COLLECTION:\n-                    case JavaTypes.MAP:\n-                    case JavaTypes.DATE:\n-                    case JavaTypes.OBJECT:\n-                        sm.provideField(getDetachedPersistenceCapable(), this,\n-                            i);\n-                        if (objval instanceof Proxy) {\n-                            Proxy proxy = (Proxy) objval;\n-                            if (proxy.getChangeTracker() != null)\n-                                proxy.getChangeTracker().stopTracking();\n-                            if (dsm == null)\n-                                proxy.setOwner(null, -1);\n-                            else\n-                                proxy.setOwner(dsm, i);\n-                        }\n+                case JavaTypes.COLLECTION:\n+                case JavaTypes.MAP:\n+                    // lrs proxies not detached\n+                    if (fmds[i].isLRS()) {\n+                        objval = null;\n+                        sm.replaceField(getDetachedPersistenceCapable(), \n+                            this, i);\n+                        break;\n+                    }\n+                    // no break\n+                case JavaTypes.DATE:\n+                case JavaTypes.OBJECT:\n+                    sm.provideField(getDetachedPersistenceCapable(), this, i);\n+                    if (objval instanceof Proxy) {\n+                        Proxy proxy = (Proxy) objval;\n+                        if (proxy.getChangeTracker() != null)\n+                            proxy.getChangeTracker().stopTracking();\n+                        proxy.setOwner(dsm, (dsm == null) ? -1 : i);\n+                    }\n                 }\n             }\n             clear();\n@@ -583,7 +593,7 @@ public void detachFields(BitSet fgfields) {\n                     detachField(from, pks[i].getIndex(), true);\n                 detachVersion();\n                 for (int i = 0; i < fmds.length; i++)\n-                    if (!fmds[i].isPrimaryKey() && !fmds[i].isVersion())\n+                    if (!fmds[i].isPrimaryKey() && !fmds[i].isVersion()) \n                         detachField(from, i, fgfields.get(i));\n             } finally {\n                 // clear the StateManager from the target object\n@@ -677,61 +687,58 @@ private Object detachField(Object curVal, int field) {\n             FieldMetaData fmd = sm.getMetaData().getField(field);\n             Object newVal = null;\n             switch (fmd.getDeclaredTypeCode()) {\n-                case JavaTypes.ARRAY:\n-                    if (_copy)\n-                        newVal = _proxy.copyArray(curVal);\n-                    else\n-                        newVal = curVal;\n-                    detachArray(newVal, fmd);\n-                    return newVal;\n-                case JavaTypes.COLLECTION:\n-                    if (_copy) {\n-                        if (_detSM != null) {\n-                            newVal =\n-                                _proxy.newCollectionProxy(fmd.getProxyType(),\n-                                    fmd.getElement().getDeclaredType(),\n-                                    fmd.getInitializer() instanceof Comparator ?\n-                                        (Comparator) fmd.getInitializer() :\n-                                        null);\n-                            ((Collection) newVal).addAll((Collection) curVal);\n-                        } else\n-                            newVal = _proxy.copyCollection((Collection) curVal);\n+            case JavaTypes.ARRAY:\n+                if (_copy)\n+                    newVal = _proxy.copyArray(curVal);\n+                else\n+                    newVal = curVal;\n+                detachArray(newVal, fmd);\n+                return newVal;\n+            case JavaTypes.COLLECTION:\n+                if (_copy) {\n+                    if (_detSM != null) {\n+                        newVal = _proxy.newCollectionProxy(fmd.getProxyType(),\n+                            fmd.getElement().getDeclaredType(),\n+                            fmd.getInitializer() instanceof Comparator ?\n+                            (Comparator) fmd.getInitializer() : null);\n+                        ((Collection) newVal).addAll((Collection) curVal);\n                     } else\n-                        newVal = curVal;\n-                    detachCollection((Collection) newVal, (Collection) curVal,\n-                        fmd);\n-                    return reproxy(newVal, field);\n-                case JavaTypes.MAP:\n-                    if (_copy) {\n-                        if (_detSM != null) {\n-                            newVal = _proxy.newMapProxy(fmd.getProxyType(),\n-                                fmd.getKey().getDeclaredType(),\n-                                fmd.getElement().getDeclaredType(),\n-                                fmd.getInitializer() instanceof Comparator ?\n-                                    (Comparator) fmd.getInitializer() : null);\n-                            ((Map) newVal).putAll((Map) curVal);\n-                        } else\n-                            newVal = _proxy.copyMap((Map) curVal);\n+                        newVal = _proxy.copyCollection((Collection) curVal);\n+                } else\n+                    newVal = curVal;\n+                detachCollection((Collection) newVal, (Collection) curVal, fmd);\n+                return reproxy(newVal, field);\n+            case JavaTypes.MAP:\n+                if (_copy) {\n+                    if (_detSM != null) {\n+                        newVal = _proxy.newMapProxy(fmd.getProxyType(),\n+                            fmd.getKey().getDeclaredType(),\n+                            fmd.getElement().getDeclaredType(),\n+                            fmd.getInitializer() instanceof Comparator ?\n+                                (Comparator) fmd.getInitializer() : null);\n+                        ((Map) newVal).putAll((Map) curVal);\n                     } else\n-                        newVal = curVal;\n-                    detachMap((Map) newVal, (Map) curVal, fmd);\n-                    return reproxy(newVal, field);\n-                case JavaTypes.CALENDAR:\n-                    newVal = (_copy) ? _proxy.copyCalendar((Calendar) curVal) :\n-                        curVal;\n-                    return reproxy(newVal, field);\n-                case JavaTypes.DATE:\n-                    newVal = (_copy) ? _proxy.copyDate((Date) curVal) : curVal;\n-                    return reproxy(newVal, field);\n-                case JavaTypes.OBJECT:\n-                    if (_copy)\n-                        newVal = _proxy.copyCustom(curVal);\n-                    return reproxy((newVal == null) ? curVal : newVal, field);\n-                case JavaTypes.PC:\n-                case JavaTypes.PC_UNTYPED:\n-                    return detachInternal(curVal);\n-                default:\n-                    return curVal;\n+                        newVal = _proxy.copyMap((Map) curVal);\n+                } else\n+                    newVal = curVal;\n+                detachMap((Map) newVal, (Map) curVal, fmd);\n+                return reproxy(newVal, field);\n+            case JavaTypes.CALENDAR:\n+                newVal = (_copy) ? _proxy.copyCalendar((Calendar) curVal) :\n+                    curVal;\n+                return reproxy(newVal, field);\n+            case JavaTypes.DATE:\n+                newVal = (_copy) ? _proxy.copyDate((Date) curVal) : curVal;\n+                return reproxy(newVal, field);\n+            case JavaTypes.OBJECT:\n+                if (_copy)\n+                    newVal = _proxy.copyCustom(curVal);\n+                return reproxy((newVal == null) ? curVal : newVal, field);\n+            case JavaTypes.PC:\n+            case JavaTypes.PC_UNTYPED:\n+                return detachInternal(curVal);\n+            default:\n+                return curVal;\n             }\n         }\n \n@@ -752,7 +759,7 @@ private void detachArray(Object array, FieldMetaData fmd) {\n          */\n         private void detachCollection(Collection coll, Collection orig,\n             FieldMetaData fmd) {\n-            // coll can be null if not copyable (lrs, for instance)\n+            // coll can be null if not copyable\n             if (_copy && coll == null)\n                 throw new UserException(_loc.get(\"not-copyable\", fmd));\n             if (!fmd.getElement().isDeclaredTypePC())\n@@ -773,7 +780,7 @@ private void detachCollection(Collection coll, Collection orig,\n          * Make sure all the values in the given map are detached.\n          */\n         private void detachMap(Map map, Map orig, FieldMetaData fmd) {\n-            // map can be null if not copyable (lrs, for instance)\n+            // map can be null if not copyable\n             if (_copy && map == null)\n                 throw new UserException(_loc.get(\"not-copyable\", fmd));\n             boolean keyPC = fmd.getKey().isDeclaredTypePC();\n@@ -788,8 +795,7 @@ private void detachMap(Map map, Map orig, FieldMetaData fmd) {\n                 if (_copy)\n                     map.clear();\n                 Object key, val;\n-                for (Iterator itr = orig.entrySet().iterator(); itr.hasNext();)\n-                {\n+                for (Iterator itr = orig.entrySet().iterator(); itr.hasNext();){\n                     entry = (Map.Entry) itr.next();\n                     key = entry.getKey();\n                     if (keyPC)"},{"sha":"93c6540f491448e8f8b28e3ad8867727e9ca8e57","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/60a1e54f07a491213603b7881d7ae8615556fd2a/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/60a1e54f07a491213603b7881d7ae8615556fd2a/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties?ref=60a1e54f07a491213603b7881d7ae8615556fd2a","patch":"@@ -138,9 +138,8 @@ attach-deleted: The object \"{0}\" with id \"{1}\" has been deleted and \\\n not-detachable: The class \"{0}\" does not declare the \"detachable\" metadata \\\n \textension, so cannot be detached.\n not-copyable: Attempt to copy field \"{0}\" failed.  The field is \\\n-\tnot copyable.  This can occur with custom SCO types or with large result \\\n-\tset fields.  Only standard or immutable SCO types can be attached and \\\n-\tdetached.\n+\tnot copyable.  This can occur with custom SCO types. Only standard or \\\n+    immutable SCO types can be attached and detached.\n no-detach-object-id: Cannot access the detached object id of class \"{0}\". \\\n \tEnsure that the class has the \"detachable\" metadata extension, and \\\n \tthe the class has been re-enhanced."},{"sha":"5bbacec37ea0a894a53bb8f60eb424023ec01ebf","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/LRSEntity.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/60a1e54f07a491213603b7881d7ae8615556fd2a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/LRSEntity.java","raw_url":"https://github.com/apache/openjpa/raw/60a1e54f07a491213603b7881d7ae8615556fd2a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/LRSEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/LRSEntity.java?ref=60a1e54f07a491213603b7881d7ae8615556fd2a","patch":"@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.relations;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.ManyToMany;\n+import javax.persistence.OrderBy;\n+\n+import org.apache.openjpa.persistence.LRS;\n+\n+@Entity\n+public class LRSEntity {\n+\n+    @Id\n+    @GeneratedValue\n+    private long id;\n+\n+    private String name;\n+\n+    @ManyToMany\n+    @OrderBy(\"name ASC\")\n+    @LRS\n+    private Collection<BasicEntity> lrsList = new ArrayList<BasicEntity>();\n+\n+    public long getId() { \n+        return id; \n+    }\n+\n+    public String getName() { \n+        return name; \n+    }\n+\n+    public void setName(String name) { \n+        this.name = name; \n+    }\n+\n+    public Collection<BasicEntity> getLRSList() { \n+        return lrsList; \n+    }\n+}"},{"sha":"64e53e284de286140c6c1083484799accfe40556","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TestLRS.java","status":"added","additions":115,"deletions":0,"changes":115,"blob_url":"https://github.com/apache/openjpa/blob/60a1e54f07a491213603b7881d7ae8615556fd2a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TestLRS.java","raw_url":"https://github.com/apache/openjpa/raw/60a1e54f07a491213603b7881d7ae8615556fd2a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TestLRS.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TestLRS.java?ref=60a1e54f07a491213603b7881d7ae8615556fd2a","patch":"@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.relations;\n+\n+import java.util.Iterator;\n+import javax.persistence.EntityManager;\n+\n+import junit.textui.TestRunner;\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\n+import org.apache.openjpa.persistence.OpenJPAPersistence;\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+/**\n+ * Test LRS relations.\n+ *\n+ * @author Abe White\n+ */\n+public class TestLRS\n+    extends SingleEMFTestCase {\n+\n+    private long id;\n+\n+    public void setUp() {\n+        setUp(LRSEntity.class, BasicEntity.class);\n+        \n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+\n+        LRSEntity lrs = new LRSEntity();\n+        lrs.setName(\"lrs\"); \n+        for (int i = 1; i <= 3; i++) {\n+            BasicEntity basic = new BasicEntity();\n+            basic.setName(\"basic\" + i);\n+            em.persist(basic);\n+            lrs.getLRSList().add(basic);\n+        }\n+        em.persist(lrs);\n+        em.getTransaction().commit();\n+        id = lrs.getId();\n+        em.close();\n+    }\n+\n+    public void testEMClear() {\n+        EntityManager em = emf.createEntityManager();\n+        LRSEntity lrs = em.find(LRSEntity.class, id);\n+        assertLRS(lrs, \"lrs\");\n+        em.clear();\n+        assertNull(lrs.getLRSList());\n+        assertMerge(lrs);\n+        em.close();\n+    }\n+\n+    public void testEMClose() {\n+        EntityManager em = emf.createEntityManager();\n+        LRSEntity lrs = em.find(LRSEntity.class, id);\n+        assertLRS(lrs, \"lrs\");\n+        em.close();\n+        assertNull(lrs.getLRSList());\n+        assertMerge(lrs);\n+    }\n+\n+    public void testDetachCopy() {\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        LRSEntity lrs = em.find(LRSEntity.class, id);\n+        assertLRS(lrs, \"lrs\");\n+        lrs = em.detach(lrs); \n+        assertEquals(\"lrs\", lrs.getName());\n+        assertNull(lrs.getLRSList());\n+        em.close();\n+        assertMerge(lrs);\n+    }\n+\n+    private void assertLRS(LRSEntity lrs, String name) {\n+        assertNotNull(lrs);\n+        assertEquals(name, lrs.getName());\n+        assertEquals(3, lrs.getLRSList().size());\n+        Iterator itr = lrs.getLRSList().iterator();\n+        for (int i = 1; itr.hasNext(); i++) {\n+            BasicEntity basic = (BasicEntity) itr.next();\n+            assertEquals(\"basic\" + i, basic.getName());\n+        }\n+        OpenJPAPersistence.close(itr);\n+    }\n+\n+    private void assertMerge(LRSEntity lrs) {\n+        lrs.setName(\"changed\");\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        assertLRS(em.merge(lrs), \"changed\");\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        em = emf.createEntityManager();\n+        assertLRS(em.find(LRSEntity.class, id), \"changed\");\n+        em.close();\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(TestLRS.class);\n+    }\n+}\n+"}]}

