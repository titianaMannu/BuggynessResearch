{"sha":"679989fd16a96bd9f94c0a68face0374dfaa2b44","node_id":"MDY6Q29tbWl0MjA2MzY0OjY3OTk4OWZkMTZhOTZiZDlmOTRjMGE2OGZhY2UwMzc0ZGZhYTJiNDQ=","commit":{"author":{"name":"Albert Lee","email":"allee8285@apache.org","date":"2009-02-19T05:34:30Z"},"committer":{"name":"Albert Lee","email":"allee8285@apache.org","date":"2009-02-19T05:34:30Z"},"message":"OPENJPA-466 - Commit patch contributed by Tim McConnell.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@745737 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"e38eaba7933f445b998e83b92acf5e0a624529ab","url":"https://api.github.com/repos/apache/openjpa/git/trees/e38eaba7933f445b998e83b92acf5e0a624529ab"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/679989fd16a96bd9f94c0a68face0374dfaa2b44","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/679989fd16a96bd9f94c0a68face0374dfaa2b44","html_url":"https://github.com/apache/openjpa/commit/679989fd16a96bd9f94c0a68face0374dfaa2b44","comments_url":"https://api.github.com/repos/apache/openjpa/commits/679989fd16a96bd9f94c0a68face0374dfaa2b44/comments","author":null,"committer":null,"parents":[{"sha":"1a407b6d6802202e9d7aa0f0882fbdb94213af55","url":"https://api.github.com/repos/apache/openjpa/commits/1a407b6d6802202e9d7aa0f0882fbdb94213af55","html_url":"https://github.com/apache/openjpa/commit/1a407b6d6802202e9d7aa0f0882fbdb94213af55"}],"stats":{"total":817,"additions":816,"deletions":1},"files":[{"sha":"348e2d6212456abb82046e99d40d0750d275d36f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/679989fd16a96bd9f94c0a68face0374dfaa2b44/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/679989fd16a96bd9f94c0a68face0374dfaa2b44/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java?ref=679989fd16a96bd9f94c0a68face0374dfaa2b44","patch":"@@ -294,7 +294,9 @@ private long getSequence(Connection conn)\n         ResultSet rs = null;\n         try {\n             stmnt = conn.prepareStatement(_select);\n-            rs = stmnt.executeQuery();\n+            synchronized(this) {\n+                rs = stmnt.executeQuery();\n+            }\n             if (rs.next())\n                 return rs.getLong(1);\n "},{"sha":"8980e6611d5af5ab01362040ce7d7e15c4b6e42e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/sequence/EntityEmployee.java","status":"added","additions":138,"deletions":0,"changes":138,"blob_url":"https://github.com/apache/openjpa/blob/679989fd16a96bd9f94c0a68face0374dfaa2b44/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/sequence/EntityEmployee.java","raw_url":"https://github.com/apache/openjpa/raw/679989fd16a96bd9f94c0a68face0374dfaa2b44/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/sequence/EntityEmployee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/sequence/EntityEmployee.java?ref=679989fd16a96bd9f94c0a68face0374dfaa2b44","patch":"@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.sequence;\n+\n+import java.io.Serializable;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+\n+/**\n+ * @author Tim McConnell\n+ * @since 2.0.0\n+ */\n+@Entity\n+@Table(name=\"ENTITY_EMPLOYEE\")\n+public class EntityEmployee implements Serializable {\n+\n+    private static final long serialVersionUID = 2961572787273807912L;\n+    \n+    @Id\n+    @SequenceGenerator(name=\"SeqEmployee\", sequenceName=\"test_native_sequence\")\n+    @GeneratedValue(strategy=GenerationType.SEQUENCE, generator=\"SeqEmployee\")\n+    private int id; \n+    private String firstName;\n+    private String lastName;\n+    private float salary;\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+\n+    public void setFirstName(String firstName) {\n+        this.firstName = firstName;\n+    }\n+\n+    public String getLastName() {\n+        return lastName;\n+    }\n+\n+    public void setLastName(String lastName) {\n+        this.lastName = lastName;\n+    }\n+\n+    public float getSalary() {\n+        return salary;\n+    }\n+\n+    public void setSalary(float salary) {\n+        this.salary = salary;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"EntityEmployee: Employee id: \" + getId() + \n+               \" firstName: \" + getFirstName() +\n+               \" lastName: \" + getLastName() +\n+               \" salary: \" + getSalary();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result\n+            + ((getFirstName() == null) ? 0 : getFirstName().hashCode());\n+        result = prime * result + getId();\n+        result = prime * result\n+            + ((getLastName() == null) ? 0 : getLastName().hashCode());\n+        result = prime * result + Float.floatToIntBits(getSalary());\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        final EntityEmployee other = (EntityEmployee) obj;\n+        if (getId() != other.getId()) {\n+            return false;\n+        }\n+        if (getFirstName() == null) {\n+            if (other.getFirstName() != null) {\n+                return false;\n+            }\n+        }\n+        else if (!getFirstName().equals(other.getFirstName())) {\n+            return false;\n+        }\n+        if (getLastName() == null) {\n+            if (other.getLastName() != null) {\n+                return false;\n+            }\n+        }\n+        else if (!getLastName().equals(other.getLastName())) {\n+            return false;\n+        }\n+        if (Float.floatToIntBits(getSalary()) != Float.floatToIntBits(other\n+            .getSalary())) {\n+            return false;\n+        }\n+        return true;\n+    }\n+}"},{"sha":"e8c925c4a5ab3aa813cf48705cb36f1944268365","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/sequence/EntityPerson.java","status":"added","additions":132,"deletions":0,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/679989fd16a96bd9f94c0a68face0374dfaa2b44/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/sequence/EntityPerson.java","raw_url":"https://github.com/apache/openjpa/raw/679989fd16a96bd9f94c0a68face0374dfaa2b44/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/sequence/EntityPerson.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/sequence/EntityPerson.java?ref=679989fd16a96bd9f94c0a68face0374dfaa2b44","patch":"@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.sequence;\n+\n+import java.io.Serializable;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+\n+/**\n+ * @author Tim McConnell\n+ * @since 2.0.0\n+ */\n+@Entity\n+@Table(name=\"ENTITY_PERSON\")\n+public class EntityPerson implements Serializable {\n+\n+    private static final long serialVersionUID = 3772049669261731520L;\n+    \n+    @Id\n+    @SequenceGenerator(name=\"SeqPerson\", sequenceName=\"test_native_sequence\")\n+    @GeneratedValue(strategy=GenerationType.SEQUENCE, generator=\"SeqPerson\")\n+    private int id; \n+    private String firstName;\n+    private String lastName;\n+\n+\n+    public EntityPerson() {\n+    }\n+\n+    public EntityPerson(String firstName, String lastName) {\n+        this.firstName = firstName;\n+        this.lastName = lastName;\n+    }\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+\n+    public void setFirstName(String firstName) {\n+        this.firstName = firstName;\n+    }\n+\n+    public String getLastName() {\n+        return lastName;\n+    }\n+\n+    public void setLastName(String lastName) {\n+        this.lastName = lastName;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"EntityPerson: Person id: \" + getId() + \n+               \" firstName: \" + getFirstName() +\n+               \" lastName: \" + getLastName();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result\n+            + ((getFirstName() == null) ? 0 : getFirstName().hashCode());\n+        result = prime * result + getId();\n+        result = prime * result\n+            + ((getLastName() == null) ? 0 : getLastName().hashCode());\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        final EntityPerson other = (EntityPerson) obj;\n+        if (getId() != other.getId()) {\n+            return false;\n+        }\n+        if (getFirstName() == null) {\n+            if (other.getFirstName() != null) {\n+                return false;\n+            }\n+        }\n+        else if (!getFirstName().equals(other.getFirstName())) {\n+            return false;\n+        }\n+        if (getLastName() == null) {\n+            if (other.getLastName() != null) {\n+                return false;\n+            }\n+        }\n+        else if (!getLastName().equals(other.getLastName())) {\n+            return false;\n+        }\n+        return true;\n+    } \n+}"},{"sha":"ee9075ad36dffaad785e8469053c80f0e78d2a14","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/sequence/TestSequence.java","status":"added","additions":543,"deletions":0,"changes":543,"blob_url":"https://github.com/apache/openjpa/blob/679989fd16a96bd9f94c0a68face0374dfaa2b44/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/sequence/TestSequence.java","raw_url":"https://github.com/apache/openjpa/raw/679989fd16a96bd9f94c0a68face0374dfaa2b44/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/sequence/TestSequence.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/sequence/TestSequence.java?ref=679989fd16a96bd9f94c0a68face0374dfaa2b44","patch":"@@ -0,0 +1,543 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agEmployee_Last_Name to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.sequence;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+import javax.persistence.EntityManager;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+/**\n+ * @author Tim McConnell\n+ * @since 2.0.0\n+ */\n+public class TestSequence extends SingleEMFTestCase {\n+\n+    private String multiThreadExecuting = null;\n+    private static final int NUMBER_ENTITIES = 5000;\n+\n+    public void setUp() {\n+        setUp(EntityPerson.class, EntityEmployee.class, CLEAR_TABLES,\n+            \"openjpa.Multithreaded\", \"true\");\n+    }\n+\n+    // Override teardown to preserve database contents\n+    @Override\n+    public void tearDown() throws Exception {\n+    }\n+\n+    public void testMultiThreadedNativeSequences() throws Exception {\n+        boolean supportsNativeSequence = false;\n+\n+        try {\n+            supportsNativeSequence = ((JDBCConfiguration) emf\n+                .getConfiguration()).getDBDictionaryInstance()\n+                .nextSequenceQuery != null;\n+        } catch (Throwable t) {\n+            supportsNativeSequence = false;\n+        }\n+\n+        if (supportsNativeSequence) {\n+            mttest(6, 8);\n+            switch ((int) (Math.random() * 7)) {\n+            case 0:\n+                createAndRemove();\n+                break;\n+            case 1:\n+                createManyPersonsInSeparateTransactions();\n+                break;\n+            case 2:\n+                createManyEmployeesInSeparateTransactions();\n+                break;\n+            case 3:\n+                createManyPersonsAndEmployeesInSeparateTransactions();\n+                break;\n+            case 4:\n+                createManyPersonsInSingleTransaction();\n+                break;\n+            case 5:\n+                createManyEmployeesInSingleTransaction();\n+                break;\n+            case 6:\n+                createManyPersonsAndEmployeesInSingleTransaction();\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void createAndRemove() {\n+        int person_id;\n+        int employee_id;\n+\n+        EntityManager em = emf.createEntityManager();\n+\n+        EntityPerson person = new EntityPerson();\n+        person.setFirstName(\"Person_First_Name\");\n+        person.setLastName(\"Person_Last_Name\");\n+\n+        EntityEmployee employee = new EntityEmployee();\n+        employee.setFirstName(\"Employee_First_Name\");\n+        employee.setLastName(\"Employee_Last_Name\");\n+        employee.setSalary(NUMBER_ENTITIES);\n+\n+        em.getTransaction().begin();\n+        em.persist(person);\n+        em.persist(employee);\n+        em.getTransaction().commit();\n+\n+        em.refresh(person);\n+        em.refresh(employee);\n+        person_id = person.getId();\n+        employee_id = employee.getId();\n+\n+        person = em.find(EntityPerson.class, person_id);\n+        assertTrue(person != null);\n+        assertTrue(person.getId() == person_id);\n+        assertTrue(person.getFirstName().equals(\"Person_First_Name\"));\n+        assertTrue(person.getLastName().equals(\"Person_Last_Name\"));\n+\n+        employee = em.find(EntityEmployee.class, employee_id);\n+        assertTrue(employee != null);\n+        assertTrue(employee.getId() == employee_id);\n+        assertTrue(employee.getFirstName().equals(\"Employee_First_Name\"));\n+        assertTrue(employee.getLastName().equals(\"Employee_Last_Name\"));\n+        assertTrue(employee.getSalary() == NUMBER_ENTITIES);\n+\n+        em.getTransaction().begin();\n+        em.remove(person);\n+        em.remove(employee);\n+        em.getTransaction().commit();\n+\n+        em.clear();\n+        em.close();\n+    }\n+\n+    private void createManyPersonsInSeparateTransactions() {\n+        EntityManager em = emf.createEntityManager();\n+\n+        for (int ii = 0; ii < NUMBER_ENTITIES; ii++) {\n+            EntityPerson person = new EntityPerson();\n+            person.setFirstName(\"1_First_name_\" + ii);\n+            person.setLastName(\"1_Last_name_\" + ii);\n+\n+            em.getTransaction().begin();\n+            em.persist(person);\n+            em.getTransaction().commit();\n+        }\n+\n+        em.clear();\n+        em.close();\n+    }\n+\n+    private void createManyEmployeesInSeparateTransactions() {\n+        EntityManager em = emf.createEntityManager();\n+\n+        for (int ii = 0; ii < NUMBER_ENTITIES; ii++) {\n+            EntityEmployee employee = new EntityEmployee();\n+            employee.setFirstName(\"2_First_name_\" + ii);\n+            employee.setLastName(\"2_Last_name_\" + ii);\n+            employee.setSalary(ii);\n+\n+            em.getTransaction().begin();\n+            em.persist(employee);\n+            em.getTransaction().commit();\n+        }\n+\n+        em.clear();\n+        em.close();\n+    }\n+\n+    private void createManyPersonsAndEmployeesInSeparateTransactions() {\n+        EntityManager em = emf.createEntityManager();\n+\n+        for (int ii = 0; ii < NUMBER_ENTITIES; ii++) {\n+            EntityPerson person = new EntityPerson();\n+            person.setFirstName(\"3_First_name_\" + ii);\n+            person.setLastName(\"3_Last_name_\" + ii);\n+\n+            EntityEmployee employee = new EntityEmployee();\n+            employee.setFirstName(\"4_First_name_\" + ii);\n+            employee.setLastName(\"4_Last_name_\" + ii);\n+            employee.setSalary(ii);\n+\n+            em.getTransaction().begin();\n+            em.persist(person);\n+            em.persist(employee);\n+            em.getTransaction().commit();\n+        }\n+\n+        em.clear();\n+        em.close();\n+    }\n+\n+    private void createManyPersonsInSingleTransaction() {\n+        EntityManager em = emf.createEntityManager();\n+\n+        em.getTransaction().begin();\n+        for (int ii = 0; ii < NUMBER_ENTITIES; ii++) {\n+            EntityPerson person = new EntityPerson();\n+            person.setFirstName(\"5_First_name_\" + ii);\n+            person.setLastName(\"5_Last_name_\" + ii);\n+\n+            em.persist(person);\n+        }\n+        em.getTransaction().commit();\n+\n+        em.clear();\n+        em.close();\n+    }\n+\n+    private void createManyEmployeesInSingleTransaction() {\n+        EntityManager em = emf.createEntityManager();\n+\n+        em.getTransaction().begin();\n+        for (int ii = 0; ii < NUMBER_ENTITIES; ii++) {\n+            EntityEmployee employee = new EntityEmployee();\n+            employee.setFirstName(\"6_First_name_\" + ii);\n+            employee.setLastName(\"6_Last_name_\" + ii);\n+            employee.setSalary(ii);\n+\n+            em.persist(employee);\n+        }\n+        em.getTransaction().commit();\n+\n+        em.clear();\n+        em.close();\n+    }\n+\n+    private void createManyPersonsAndEmployeesInSingleTransaction() {\n+        EntityManager em = emf.createEntityManager();\n+\n+        em.getTransaction().begin();\n+        for (int ii = 0; ii < NUMBER_ENTITIES; ii++) {\n+            EntityPerson person = new EntityPerson();\n+            person.setFirstName(\"7_First_name_\" + ii);\n+            person.setLastName(\"7_Last_name_\" + ii);\n+\n+            EntityEmployee employee = new EntityEmployee();\n+            employee.setFirstName(\"8_First_name_\" + ii);\n+            employee.setLastName(\"8_Last_name_\" + ii);\n+            employee.setSalary(ii);\n+\n+            em.persist(person);\n+            em.persist(employee);\n+        }\n+        em.getTransaction().commit();\n+\n+        em.clear();\n+        em.close();\n+    }\n+\n+    /**\n+     * Re-execute the invoking method a random number of times in a random\n+     * number of Threads.\n+     */\n+    public void mttest() throws ThreadingException {\n+        // 6 iterations in 8 threads is a good trade-off between\n+        // tests taking way too long and having a decent chance of\n+        // identifying MT problems.\n+        int iterations = 6;\n+        int threads = 8;\n+\n+        mttest(threads, iterations);\n+    }\n+\n+    /**\n+     * Execute the calling method <code>iterations</code> times in\n+     * <code>threads</code> Threads.\n+     */\n+    public void mttest(int threads, int iterations) {\n+        mttest(0, threads, iterations);\n+    }\n+\n+    public void mttest(int serialCount, int threads, int iterations)\n+        throws ThreadingException {\n+        String methodName = callingMethod(\"mttest\");\n+        mttest(serialCount, threads, iterations, methodName, new Object[0]);\n+    }\n+\n+    /**\n+     * Execute a test method in multiple threads.\n+     * \n+     * @param threads\n+     *            the number of Threads to run in\n+     * @param iterations\n+     *            the number of times the method should be execute in a single\n+     *            Thread\n+     * @param method\n+     *            the name of the method to execute\n+     * @param args\n+     *            the arguments to pass to the method\n+     * @throws ThreadingException\n+     *             if an errors occur in any of the Threads. The actual\n+     *             exceptions will be embedded in the exception. Note that this\n+     *             means that assert() failures will be treated as errors rather\n+     *             than warnings.\n+     * @author Marc Prud'hommeaux\n+     */\n+    public void mttest(int threads, int iterations, final String method,\n+        final Object[] args) throws ThreadingException {\n+        mttest(0, threads, iterations, method, args);\n+    }\n+\n+    public void mttest(int serialCount, int threads, int iterations,\n+        final String method, final Object[] args) throws ThreadingException {\n+        if (multiThreadExecuting != null \n+            && multiThreadExecuting.equals(method)) {\n+            // we are currently executing in multi-threaded mode:\n+            // don't deadlock!\n+            return;\n+        }\n+\n+        multiThreadExecuting = method;\n+\n+        try {\n+            Class<?>[] paramClasses = new Class[args.length];\n+            for (int i = 0; i < paramClasses.length; i++)\n+                paramClasses[i] = args[i].getClass();\n+\n+            final Method meth;\n+\n+            try {\n+                meth = getClass().getMethod(method, paramClasses);\n+            } catch (NoSuchMethodException nsme) {\n+                throw new ThreadingException(nsme.toString(), nsme);\n+            }\n+\n+            final Object thiz = this;\n+\n+            mttest(\"reflection invocation: (\" + method + \")\", serialCount,\n+                threads, iterations, new VolatileRunnable() {\n+                    public void run() throws Exception {\n+                        meth.invoke(thiz, args);\n+                    }\n+                });\n+        } finally {\n+            multiThreadExecuting = null;\n+        }\n+    }\n+\n+    public void mttest(String title, final int threads, final int iterations,\n+        final VolatileRunnable runner) throws ThreadingException {\n+        mttest(title, 0, threads, iterations, runner);\n+    }\n+\n+    /**\n+     * Execute a test method in multiple threads.\n+     * \n+     * @param title\n+     *            a description of the test, for inclusion in the error message\n+     * @param serialCount\n+     *            the number of times to run the method serially before spawning\n+     *            threads.\n+     * @param threads\n+     *            the number of Threads to run in\n+     * @param iterations\n+     *            the number of times the method should\n+     * @param runner\n+     *            the VolatileRunnable that will execute the actual test from\n+     *            within the Thread.\n+     * @throws ThreadingException\n+     *             if an errors occur in any of the Threads. The actual\n+     *             exceptions will be embedded in the exception. Note that this\n+     *             means that assert() failures will be treated as errors rather\n+     *             than warnings.\n+     * @author Marc Prud'hommeaux\n+     */\n+    public void mttest(String title, final int serialCount, final int threads,\n+        final int iterations, final VolatileRunnable runner)\n+        throws ThreadingException {\n+        final List exceptions = Collections.synchronizedList(new LinkedList());\n+\n+        Thread[] runners = new Thread[threads];\n+\n+        final long startMillis = System.currentTimeMillis() + 1000;\n+\n+        for (int i = 1; i <= threads; i++) {\n+            final int thisThread = i;\n+\n+            runners[i - 1] = new Thread(title + \" [\" + i + \" of \" + threads\n+                + \"]\") {\n+                public void run() {\n+                    // do our best to have all threads start at the exact\n+                    // same time. This is imperfect, but the closer we\n+                    // get to everyone starting at the same time, the\n+                    // better chance we have for identifying MT problems.\n+                    while (System.currentTimeMillis() < startMillis)\n+                        yield();\n+\n+                    int thisIteration = 1;\n+                    try {\n+                        for (; thisIteration <= iterations; thisIteration++) {\n+                            // go go go!\n+                            runner.run();\n+                        }\n+                    } catch (Throwable error) {\n+                        synchronized (exceptions) {\n+                            // embed the exception into something that gives\n+                            // us some more information about the threading\n+                            // environment\n+                            exceptions.add(new ThreadingException(\"thread=\"\n+                                + this.toString() + \";threadNum=\" + thisThread\n+                                + \";maxThreads=\" + threads + \";iteration=\"\n+                                + thisIteration + \";maxIterations=\"\n+                                + iterations, error));\n+                        }\n+                    }\n+                }\n+            };\n+        }\n+\n+        // start the serial tests(does not spawn the threads)\n+        for (int i = 0; i < serialCount; i++) {\n+            runners[0].run();\n+        }\n+\n+        // start the multithreaded\n+        for (int i = 0; i < threads; i++) {\n+            runners[i].start();\n+        }\n+\n+        // wait for them all to complete\n+        for (int i = 0; i < threads; i++) {\n+            try {\n+                runners[i].join();\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+\n+        if (exceptions.size() == 0)\n+            return; // sweeeeeeeet: no errors\n+\n+        // embed all the exceptions that were throws into a\n+        // ThreadingException\n+        Throwable[] errors = (Throwable[]) exceptions.toArray(new Throwable[0]);\n+        throw new ThreadingException(\"The \" + errors.length\n+            + \" embedded errors \" + \"occured in the execution of \" + iterations\n+            + \" iterations \" + \"of \" + threads + \" threads: [\" + title + \"]\",\n+            errors);\n+    }\n+\n+    /**\n+     * Check to see if we are in the top-level execution stack.\n+     */\n+    public boolean isRootThread() {\n+        return multiThreadExecuting == null;\n+    }\n+\n+    /**\n+     * A Runnable that can throw an Exception: used to test cases.\n+     */\n+    public static interface VolatileRunnable {\n+\n+        public void run() throws Exception;\n+    }\n+\n+    /**\n+     * Exception for errors caught during threading tests.\n+     */\n+    public class ThreadingException extends RuntimeException {\n+\n+        private static final long serialVersionUID = -1911769845552507956L;\n+        private final Throwable[] _nested;\n+\n+        public ThreadingException(String msg, Throwable nested) {\n+            super(msg);\n+            if (nested == null)\n+                _nested = new Throwable[0];\n+            else\n+                _nested = new Throwable[] { nested };\n+        }\n+\n+        public ThreadingException(String msg, Throwable[] nested) {\n+            super(msg);\n+            if (nested == null)\n+                _nested = new Throwable[0];\n+            else\n+                _nested = nested;\n+        }\n+\n+        public void printStackTrace() {\n+            printStackTrace(System.out);\n+        }\n+\n+        public void printStackTrace(PrintStream out) {\n+            printStackTrace(new PrintWriter(out));\n+        }\n+\n+        public void printStackTrace(PrintWriter out) {\n+            super.printStackTrace(out);\n+            for (int i = 0; i < _nested.length; i++) {\n+                out.print(\"Nested Throwable #\" + (i + 1) + \": \");\n+                _nested[i].printStackTrace(out);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return the last method name that called this one by parsing the current\n+     * stack trace.\n+     * \n+     * @param exclude\n+     *            a method name to skip\n+     * @throws IllegalStateException\n+     *             If the calling method could not be identified.\n+     * @author Marc Prud'hommeaux\n+     */\n+    public String callingMethod(String exclude) {\n+        // determine the currently executing method by\n+        // looking at the stack track. Hackish, but convenient.\n+        StringWriter sw = new StringWriter();\n+        new Exception().printStackTrace(new PrintWriter(sw));\n+        for (StringTokenizer stackTrace = new StringTokenizer(sw.toString(),\n+            System.getProperty(\"line.separator\"))\n+            ; stackTrace.hasMoreTokens() ; ) {\n+            String line = stackTrace.nextToken().trim();\n+\n+            // not a stack trace element\n+            if (!(line.startsWith(\"at \")))\n+                continue;\n+\n+            String fullMethodName = line.substring(0, line.indexOf(\"(\"));\n+\n+            String shortMethodName = fullMethodName.substring(fullMethodName\n+                .lastIndexOf(\".\") + 1);\n+\n+            // skip our own methods!\n+            if (shortMethodName.equals(\"callingMethod\"))\n+                continue;\n+            if (exclude != null && shortMethodName.equals(exclude))\n+                continue;\n+\n+            return shortMethodName;\n+        }\n+\n+        throw new IllegalStateException(\"Could not identify calling \"\n+            + \"method in stack trace\");\n+    }\n+}"}]}

