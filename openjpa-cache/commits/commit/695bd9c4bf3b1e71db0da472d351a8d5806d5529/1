{"sha":"695bd9c4bf3b1e71db0da472d351a8d5806d5529","node_id":"MDY6Q29tbWl0MjA2MzY0OjY5NWJkOWM0YmYzYjFlNzFkYjBkYTQ3MmQzNTFhOGQ1ODA2ZDU1Mjk=","commit":{"author":{"name":"Donald Woods","email":"dwoods@apache.org","date":"2010-03-09T22:29:18Z"},"committer":{"name":"Donald Woods","email":"dwoods@apache.org","date":"2010-03-09T22:29:18Z"},"message":"OPENJPA-1550 When batchLimit=-1 or >1 and an exception is caused, the params and failedObject are missing from the resultant exception.  Original patch contributed by Heath Thomann.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@921174 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"d02b3939f0589a42333f255deae9462c8d50ad07","url":"https://api.github.com/repos/apache/openjpa/git/trees/d02b3939f0589a42333f255deae9462c8d50ad07"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/695bd9c4bf3b1e71db0da472d351a8d5806d5529","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/695bd9c4bf3b1e71db0da472d351a8d5806d5529","html_url":"https://github.com/apache/openjpa/commit/695bd9c4bf3b1e71db0da472d351a8d5806d5529","comments_url":"https://api.github.com/repos/apache/openjpa/commits/695bd9c4bf3b1e71db0da472d351a8d5806d5529/comments","author":null,"committer":null,"parents":[{"sha":"8c8cd98a655144d072b6849eb42108435a3ebed8","url":"https://api.github.com/repos/apache/openjpa/commits/8c8cd98a655144d072b6849eb42108435a3ebed8","html_url":"https://github.com/apache/openjpa/commit/8c8cd98a655144d072b6849eb42108435a3ebed8"}],"stats":{"total":161,"additions":127,"deletions":34},"files":[{"sha":"576bebf3bdcb143911925da9a0e1b7963e0134d8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java","status":"modified","additions":36,"deletions":4,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/695bd9c4bf3b1e71db0da472d351a8d5806d5529/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/695bd9c4bf3b1e71db0da472d351a8d5806d5529/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java?ref=695bd9c4bf3b1e71db0da472d351a8d5806d5529","patch":"@@ -33,6 +33,7 @@\n import org.apache.openjpa.jdbc.sql.RowImpl;\n import org.apache.openjpa.jdbc.sql.SQLExceptions;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.lib.jdbc.ReportingSQLException;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.util.OptimisticException;\n@@ -187,13 +188,44 @@ protected void flushBatch() throws SQLException {\n                     checkUpdateCount(rtn, batchedRowsBaseIndex, ps);\n                 }\n             } catch (SQLException se) {\n-                SQLException sqex = se.getNextException();\n-                if (sqex == null)\n-                    sqex = se;\n-                throw SQLExceptions.getStore(sqex, ps, _dict);\n+                //If we look at PreparedStatementManagerImpl.flushAndUpdate (which is the 'non-batch' code path\n+                //similar to this path, or I should say, the path which is taken instead of this path when\n+                //we aren't using batching), we see that the catch block doesn't do a 'se.getNextException'.\n+                //When we do a 'getNextException', the 'next exception' doesn't contain the same message as se.\n+                //That is, 'next exception' contains a subset msg which is contained in se.  For legacy, should\n+                //we continute to use 'sqex' in the 'old path' and use 'se' in the next path/code?????\n+//                SQLException sqex = se.getNextException();\n+  //              if (sqex == null)\n+    //                sqex = se;\n+                SQLException sqex = se;\n+                \n+                if (se instanceof ReportingSQLException){\n+                  int index = ((ReportingSQLException) se).getIndexOfFirstFailedObject();\n+\n+                  //if we have only batched one statement, the index should be 0.  As can be seen above,\n+                  //if 'batchSize == 1' a different path is taken (the 'single row' path), and if that row\n+                  //fails, we know that the index is 0 since there is only one row.\n+                  if (batchSize == 1){\n+                      index = 0;\n+                  }\n+                  \n+                  //index should not be less than 0 this path, but if for some reason it is, lets\n+                  //resort to the 'old way' and simply pass the 'ps' as the failed object.\n+                  if (index < 0){ \n+                      throw SQLExceptions.getStore(sqex, ps, _dict);\n+                  }\n+                  else{\n+                      throw SQLExceptions.getStore(sqex, ((RowImpl)(_batchedRows.get(index))).getFailedObject(), _dict);\n+                  }                    \n+                }\n+                else{\n+                    throw SQLExceptions.getStore(sqex, ps, _dict);\n+                }\n             } finally {\n                 _batchedSql = null;\n                 batchedRows.clear();\n+                //Clear the Params now....should this be done above?\n+                ps.clearParameters();\n                 if (ps != null) {\n                     try {\n                         ps.close();"},{"sha":"a6985e6e7bf8733888033fd3491647dc3d4c10e5","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","status":"modified","additions":79,"deletions":29,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/695bd9c4bf3b1e71db0da472d351a8d5806d5529/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/695bd9c4bf3b1e71db0da472d351a8d5806d5529/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java?ref=695bd9c4bf3b1e71db0da472d351a8d5806d5529","patch":"@@ -85,7 +85,7 @@\n     private static final int WARN_THROW = 5;\n     private static final int WARN_HANDLE = 6;\n     private static final String[] WARNING_ACTIONS = new String[7];\n-\n+    \n     static {\n         WARNING_ACTIONS[WARN_IGNORE] = \"ignore\";\n         WARNING_ACTIONS[WARN_LOG_TRACE] = \"trace\";\n@@ -229,29 +229,36 @@ private LoggingConnection newLoggingConnection(Connection conn)\n         return ConcreteClassGenerator.newInstance(loggingConnectionImpl, LoggingConnectionDecorator.this, conn);\n     }\n \n-\n-    /**\n-     * Include SQL in exception.\n-     */\n     private SQLException wrap(SQLException sqle, Statement stmnt) {\n-        if (sqle instanceof ReportingSQLException)\n-            return (ReportingSQLException) sqle;\n-        return new ReportingSQLException(sqle, stmnt, null);\n+        return wrap(sqle, stmnt, null, -1);\n     }\n \n-    /**\n-     * Include SQL in exception.\n-     */\n     private SQLException wrap(SQLException sqle, String sql) {\n-        if (sqle instanceof ReportingSQLException)\n-            return (ReportingSQLException) sqle;\n-        return new ReportingSQLException(sqle, null, sql);\n+        return wrap(sqle, null, sql, -1);\n     }\n     \n     private SQLException wrap(SQLException sqle, Statement stmnt, String sql) {\n-        if (sqle instanceof ReportingSQLException)\n-            return (ReportingSQLException) sqle;\n-        return new ReportingSQLException(sqle, stmnt, sql);\n+        return wrap(sqle, stmnt, sql, -1);\n+    }\n+\n+    private SQLException wrap(SQLException sqle, Statement stmnt, int indexOfFailedBatchObject) {\n+        return wrap(sqle, stmnt, null, -1);\n+    }\n+\n+    /**\n+     * Include SQL in exception.\n+     */\n+    private SQLException wrap(SQLException sqle, Statement stmnt, String sql, int indexOfFailedBatchObject) {\n+        ReportingSQLException toReturn = null;\n+\n+        if (sqle instanceof ReportingSQLException) {\n+            toReturn = (ReportingSQLException) sqle;\n+        } else {\n+            toReturn = new ReportingSQLException(sqle, stmnt, sql);\n+        }\n+\n+        toReturn.setIndexOfFirstFailedObject(indexOfFailedBatchObject);\n+        return toReturn;\n     }\n \n     /**\n@@ -972,6 +979,9 @@ public boolean execute(String sql) throws SQLException {\n             private final String _sql;\n             private List<String> _params = null;\n             private List<List<String>> _paramBatch = null;\n+            // When batching is used, this variable contains the index into the\n+            // last successfully executed batched statement.\n+            int batchedRowsBaseIndex = 0;\n \n             public LoggingPreparedStatement(PreparedStatement stmnt, String sql)\n                 throws SQLException {\n@@ -1076,11 +1086,29 @@ public int executeUpdate() throws SQLException {\n             }\n \n             public int[] executeBatch() throws SQLException {\n+                int indexOfFirstFailedObject = -1;\n+\n                 logBatchSQL(this);\n                 long start = System.currentTimeMillis();\n                 SQLException err = null;\n                 try {\n-                    return super.executeBatch();\n+                    int[] toReturn = super.executeBatch();\n+                    //executeBatch is called any time the number of batched statements\n+                    //is equal to, or less than, batchLimit.  In the 'catch' block below,\n+                    //the logic seeks to find an index based on the current executeBatch\n+                    //results.  This is fine when executeBatch is only called once, but\n+                    //if executeBatch is called many times, the _paramsBatch will continue\n+                    //to grow, as such, to index into _paramsBatch, we need to take into\n+                    //account the number of times executeBatch is called in or der to\n+                    //correctly index into _paramsBatch.  To that end, each time executeBatch\n+                    //is called, lets get the size of _paramBatch.  This will effectively\n+                    //tell us the index of the last successfully executed batch statement.\n+                    //If an exception is caused, then we know that _paramBatch.size was\n+                    //the index of the LAST row to successfully execute.\n+                    if (_paramBatch != null){\n+                        batchedRowsBaseIndex = _paramBatch.size();            \n+                    }\n+                    return toReturn;\n                 } catch (SQLException se) {\n                     // if the exception is a BatchUpdateException, and\n                     // we are tracking parameters, then set the current\n@@ -1093,28 +1121,43 @@ public int executeUpdate() throws SQLException {\n                             getUpdateCounts();\n                         if (count != null && count.length <= _paramBatch.size())\n                         {\n-                            int index = -1;\n                             for (int i = 0; i < count.length; i++) {\n                                 // -3 is Statement.STATEMENT_FAILED, but is\n                                 // only available in JDK 1.4+\n                                 if (count[i] == Statement.EXECUTE_FAILED) {\n-                                    index = i;\n+                                    indexOfFirstFailedObject = i;\n                                     break;\n                                 }\n                             }\n \n                             // no -3 element: it may be that the server stopped\n                             // processing, so the size of the count will be\n                             // the index\n-                            if (index == -1)\n-                                index = count.length + 1;\n+                            //See the Javadoc for 'getUpdateCounts'; a provider\n+                            //may stop processing when the first failure occurs,\n+                            //as such, it may only return 'UpdateCounts' for the\n+                            //first few which pass.  As such, the failed\n+                            //index is 'count.length', NOT count.length+1.  That\n+                            //is, if the provider ONLY returns the first few that\n+                            //passes (i.e. say an array of [1,1] is returned) then\n+                            //length is 2, and since _paramBatch starts at 0, we\n+                            //don't want to use length+1 as that will give us the\n+                            //wrong index.\n+                            if (indexOfFirstFailedObject == -1){\n+                                indexOfFirstFailedObject = count.length;\n+                            }\n+\n+                            //Finally, whatever the index is at this point, add batchedRowsBaseIndex\n+                            //to it to get the final index.  Recall, we need to start our index from the\n+                            //last batch which successfully executed.\n+                            indexOfFirstFailedObject += batchedRowsBaseIndex;\n \n                             // set the current params to the saved values\n-                            if (index < _paramBatch.size())\n-                                _params = (List<String>) _paramBatch.get(index);\n+                            if (indexOfFirstFailedObject < _paramBatch.size())\n+                                _params = (List) _paramBatch.get(indexOfFirstFailedObject);\n                         }\n                     }\n-                    err = wrap(se, LoggingPreparedStatement.this);\n+                    err = wrap(se, LoggingPreparedStatement.this, indexOfFirstFailedObject);\n                     throw err;\n                 } finally {\n                     logTime(start);\n@@ -1366,10 +1409,17 @@ protected void appendInfo(StringBuffer buf) {\n             }\n \n             private void clearLogParameters(boolean batch) {\n-                if (_params != null)\n-                    _params.clear();\n-                if (batch && _paramBatch != null)\n-                    _paramBatch.clear();\n+                //Made !batch...we only want to clear if\n+                //we are NOT using batching.  If we clear now,\n+                //the _params will not be displayed in the resultant\n+                //exception message.  But when should we 'clear' them???\n+                if (!batch){                    \n+                    if (_params != null)\n+                        _params.clear();\n+                    \n+                    if (_paramBatch != null)\n+                        _paramBatch.clear();                \n+                }\n             }\n \n             private boolean shouldTrackParameters() {"},{"sha":"e63ad76648ccac1560cfeb049beb7257e6c0a32c","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java","status":"modified","additions":12,"deletions":1,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/695bd9c4bf3b1e71db0da472d351a8d5806d5529/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java","raw_url":"https://github.com/apache/openjpa/raw/695bd9c4bf3b1e71db0da472d351a8d5806d5529/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java?ref=695bd9c4bf3b1e71db0da472d351a8d5806d5529","patch":"@@ -34,7 +34,10 @@\n     private final transient Statement _stmnt;\n     private final SQLException _sqle;\n     private final String       _sql;\n-    \n+    // When batching is used, and an object/row in the batch causes an\n+    // exception, this variable will hold the index of the first failing object.\n+    private int indexOfFirstFailedObject=-1;\n+\n     /**\n      * Supply original exception and non-null Statement and/or SQL string.\n      */\n@@ -74,7 +77,15 @@ public int getErrorCode() {\n     public Statement getStatement() {\n         return _stmnt;\n     }\n+    \n+    public int getIndexOfFirstFailedObject(){\n+        return indexOfFirstFailedObject;\n+    }\n \n+    public void setIndexOfFirstFailedObject(int index){    \n+        indexOfFirstFailedObject=index;\n+    }\n+    \n     private static String getExceptionMessage(SQLException sqle,\n         Statement stmnt, String sql) {\n         try {"}]}

