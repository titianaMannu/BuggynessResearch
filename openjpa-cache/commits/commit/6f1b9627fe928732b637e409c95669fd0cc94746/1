{"sha":"6f1b9627fe928732b637e409c95669fd0cc94746","node_id":"MDY6Q29tbWl0MjA2MzY0OjZmMWI5NjI3ZmU5Mjg3MzJiNjM3ZTQwOWM5NTY2OWZkMGNjOTQ3NDY=","commit":{"author":{"name":"Fay Wang","email":"faywang@apache.org","date":"2009-09-22T20:38:36Z"},"committer":{"name":"Fay Wang","email":"faywang@apache.org","date":"2009-09-22T20:38:36Z"},"message":"OPENJPA-1253: support non-default bi-directional one-to-many using foreign key strategy to find/query from the ower's side\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@817831 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"01ce84344d29a3b6d826776a2d7db54d4ab0c376","url":"https://api.github.com/repos/apache/openjpa/git/trees/01ce84344d29a3b6d826776a2d7db54d4ab0c376"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/6f1b9627fe928732b637e409c95669fd0cc94746","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/6f1b9627fe928732b637e409c95669fd0cc94746","html_url":"https://github.com/apache/openjpa/commit/6f1b9627fe928732b637e409c95669fd0cc94746","comments_url":"https://api.github.com/repos/apache/openjpa/commits/6f1b9627fe928732b637e409c95669fd0cc94746/comments","author":null,"committer":null,"parents":[{"sha":"01c26a9e21a80fd6339d0c2a406f11397f4e3d20","url":"https://api.github.com/repos/apache/openjpa/commits/01c26a9e21a80fd6339d0c2a406f11397f4e3d20","html_url":"https://github.com/apache/openjpa/commit/01c26a9e21a80fd6339d0c2a406f11397f4e3d20"}],"stats":{"total":119,"additions":88,"deletions":31},"files":[{"sha":"b3802a48e88517585b09170ecb05af16d7bace90","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","status":"modified","additions":81,"deletions":30,"changes":111,"blob_url":"https://github.com/apache/openjpa/blob/6f1b9627fe928732b637e409c95669fd0cc94746/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/6f1b9627fe928732b637e409c95669fd0cc94746/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java?ref=6f1b9627fe928732b637e409c95669fd0cc94746","patch":"@@ -83,8 +83,10 @@\n         (RelationFieldStrategy.class);\n \n     private Boolean _fkOid = null;\n-    boolean _isBiOneToManyJoinTable = false;\n-\n+    private int _biOneToManyJoinTable = -1;\n+    private ForeignKey _biOneToManyJoinFK = null;\n+    private ForeignKey _biOneToManyElemFK = null;\n+    \n     public void map(boolean adapt) {\n         if (field.getTypeCode() != JavaTypes.PC || field.isEmbeddedPC())\n             throw new MetaDataException(_loc.get(\"not-relation\", field));\n@@ -140,25 +142,8 @@ public void map(boolean adapt) {\n             OpenJPAConfiguration conf = field.getRepository().getConfiguration();\n             boolean isNonDefaultMappingAllowed = field.getRepository().\n                 getMetaDataFactory().getDefaults().isNonDefaultMappingAllowed(conf);\n-            if (isNonDefaultMappingAllowed) { \n-                ClassMapping inverse = field.getValueMapping().getTypeMapping();\n-                FieldMapping[] fmds = inverse.getFieldMappings();\n-                for (int i = 0; i < fmds.length; i++) {\n-                    if (field == fmds[i].getMappedByMapping()) {\n-                        int typeCode = fmds[i].getDeclaredTypeCode(); \n-                        if (typeCode == JavaTypes.ARRAY ||\n-                            typeCode == JavaTypes.COLLECTION ||\n-                            typeCode == JavaTypes.MAP) {\n-                            // this is a bi-directional oneToMany relation with\n-                            // @JoinTable annotation ==> join table strategy\n-                            // ==> should not mapped in the owner's table\n-                            FieldMappingInfo info = fmds[i].getMappingInfo();\n-                            _isBiOneToManyJoinTable = (info.getTableName() != null ? true : false);\n-                        }\n-                        break;\n-                    }\n-                }\n-            }\n+            if (isNonDefaultMappingAllowed)  \n+                getBiOneToManyInfo();\n         }\n \n         // this is necessary to support openjpa 3 mappings, which didn't\n@@ -183,7 +168,7 @@ public void map(boolean adapt) {\n             if (field.getMappedByIdValue() != null) \n                 setMappedByIdColumns();            \n              \n-            if (!_isBiOneToManyJoinTable) {\n+            if (_biOneToManyJoinTable == -1) {\n                 ForeignKey fk = vinfo.getTypeJoin(field, field.getName(), true,\n                     adapt);\n                 field.setForeignKey(fk);\n@@ -295,7 +280,7 @@ public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n         else {\n             Row row = field.getRow(sm, store, rm, Row.ACTION_INSERT);\n             if (row != null) {\n-                if (!_isBiOneToManyJoinTable)\n+                if (_biOneToManyJoinTable == -1)\n                     field.setForeignKey(row, rel);\n                 // this is for bi-directional maps, the key and value of the \n                 // map are stored in the table of the mapped-by entity  \n@@ -382,12 +367,29 @@ public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n                     Row.ACTION_DELETE : Row.ACTION_UPDATE;\n             Row row = field.getRow(sm, store, rm, action);\n             if (row != null) {\n-                if (!_isBiOneToManyJoinTable)\n+                if (_biOneToManyJoinTable == -1)\n                     field.setForeignKey(row, rel);\n                 // this is for bi-directional maps, the key and value of the \n                 // map are stored in the table of the mapped-by entity  \n                 setMapKey(sm, rel, store, row);\n             }\n+            \n+            if (_biOneToManyJoinTable != -1) { // also need to update the join table\n+                PersistenceCapable inversePC = (PersistenceCapable)sm.fetchObject(_biOneToManyJoinTable);\n+                Row secondaryRow = null;\n+                if (inversePC != null) {\n+                    secondaryRow = rm.getSecondaryRow(_biOneToManyJoinFK.getTable(),\n+                        Row.ACTION_INSERT);\n+                    secondaryRow.setForeignKey(_biOneToManyElemFK, null, sm);\n+                    secondaryRow.setForeignKey(_biOneToManyJoinFK, null, \n+                        (OpenJPAStateManager)inversePC.pcGetStateManager());\n+                } else { \n+                    secondaryRow = rm.getSecondaryRow(_biOneToManyJoinFK.getTable(),\n+                            Row.ACTION_DELETE);\n+                    secondaryRow.setForeignKey(_biOneToManyElemFK, null, sm);\n+                }\n+                rm.flushSecondaryRow(secondaryRow);\n+            }\n         }\n     }\n \n@@ -560,6 +562,8 @@ public void select(Select sel, int idx) {\n      */\n     private void selectEagerParallel(Select sel, ClassMapping cls,\n         JDBCStore store, JDBCFetchConfiguration fetch, int eagerMode) {\n+        if (_biOneToManyJoinTable != -1)\n+            return;\n         sel.selectPrimaryKey(field.getDefiningMapping());\n         // set a variable name that does not conflict with any in the query;\n         // using a variable guarantees that the selected data will use different\n@@ -573,7 +577,7 @@ private void selectEagerParallel(Select sel, ClassMapping cls,\n \n     public void selectEagerJoin(Select sel, OpenJPAStateManager sm,\n         JDBCStore store, JDBCFetchConfiguration fetch, int eagerMode) {\n-        if (_isBiOneToManyJoinTable) \n+        if (_biOneToManyJoinTable != -1) \n             return;\n \n         // limit the eager mode to single on recursive eager fetching b/c\n@@ -678,6 +682,8 @@ private Map processEagerParallelResult(OpenJPAStateManager sm,\n     public void loadEagerJoin(OpenJPAStateManager sm, JDBCStore store,\n         JDBCFetchConfiguration fetch, Result res)\n         throws SQLException {\n+        if (_biOneToManyJoinTable != -1)\n+            return;\n         ClassMapping cls = field.getIndependentTypeMappings()[0];\n \n         // for inverseEager field\n@@ -725,7 +731,7 @@ public void load(OpenJPAStateManager sm, JDBCStore store,\n         // get the related object's oid\n         ClassMapping relMapping = field.getTypeMapping();\n         Object oid = null;\n-        if (relMapping.isMapped() && !_isBiOneToManyJoinTable) { \n+        if (relMapping.isMapped() && _biOneToManyJoinTable == -1) { \n             oid = relMapping.getObjectId(store, res, field.getForeignKey(),\n                     field.getPolymorphic() != ValueMapping.POLY_FALSE, null);\n         } else {\n@@ -791,10 +797,18 @@ public void select(Select sel, int idx) {\n                     sel.whereForeignKey(field.getForeignKey(rels[idx]),\n                         sm.getObjectId(), field.getDefiningMapping(), store);\n                 else {\n-                    resJoins[idx] = sel.newJoins().joinRelation(field.getName(),\n-                        field.getForeignKey(rels[idx]), rels[idx],\n-                        field.getSelectSubclasses(), false, false);\n-                    field.wherePrimaryKey(sel, sm, store);\n+                    if (_biOneToManyJoinTable == -1) {\n+                        resJoins[idx] = sel.newJoins().joinRelation(field.getName(),\n+                            field.getForeignKey(rels[idx]), rels[idx],\n+                            field.getSelectSubclasses(), false, false);\n+                        field.wherePrimaryKey(sel, sm, store);\n+                    } else {\n+                        resJoins[idx] = sel.newJoins().joinRelation(null,\n+                            getBiOneToManyJoinFK(), rels[idx],\n+                            field.getSelectSubclasses(), false, false);\n+                        sel.whereForeignKey(getBiOneToManyElemFK(), sm.getObjectId(), \n+                            field.getDefiningMapping(), store);\n+                    }\n                 }\n                 sel.select(rels[idx], subs, store, fetch, fetch.EAGER_JOIN, \n                     resJoins[idx]);\n@@ -813,6 +827,43 @@ public void select(Select sel, int idx) {\n         }\n     }\n \n+    private ForeignKey getBiOneToManyJoinFK() {\n+        if (_biOneToManyJoinFK == null) {\n+            getBiOneToManyInfo();\n+        }\n+        return _biOneToManyJoinFK;\n+    }\n+    \n+    private ForeignKey getBiOneToManyElemFK() {\n+        if (_biOneToManyElemFK == null) {\n+            getBiOneToManyInfo();\n+        }\n+        return _biOneToManyElemFK;\n+    }\n+\n+    private void getBiOneToManyInfo() {\n+        ClassMapping inverse = field.getValueMapping().getTypeMapping();\n+        FieldMapping[] fmds = inverse.getFieldMappings();\n+        for (int i = 0; i < fmds.length; i++) {\n+            if (field == fmds[i].getMappedByMapping()) {\n+                int typeCode = fmds[i].getDeclaredTypeCode(); \n+                if (typeCode == JavaTypes.ARRAY ||\n+                        typeCode == JavaTypes.COLLECTION ||\n+                        typeCode == JavaTypes.MAP) {\n+                    // this is a bi-directional oneToMany relation with\n+                    // @JoinTable annotation ==> join table strategy\n+                    // ==> should not mapped in the owner's table\n+                    FieldMappingInfo info = fmds[i].getMappingInfo();\n+                    if (info.getTableName() != null)\n+                        _biOneToManyJoinTable = i;\n+                    _biOneToManyElemFK = fmds[i].getElementMapping().getForeignKey();\n+                    _biOneToManyJoinFK = fmds[i].getJoinForeignKey();\n+                }\n+                break;\n+            }\n+        }\n+    }\n+    \n     public Object toDataStoreValue(Object val, JDBCStore store) {\n         return RelationStrategies.toDataStoreValue(field, val, store);\n     }"},{"sha":"18ecb15abefd09001bbd067e45b8279c4711d0da","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestSpecCompatibilityOptions.java","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/6f1b9627fe928732b637e409c95669fd0cc94746/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestSpecCompatibilityOptions.java","raw_url":"https://github.com/apache/openjpa/raw/6f1b9627fe928732b637e409c95669fd0cc94746/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestSpecCompatibilityOptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestSpecCompatibilityOptions.java?ref=6f1b9627fe928732b637e409c95669fd0cc94746","patch":"@@ -369,11 +369,17 @@ public void crudBi1MJT(EntityManager em) {\n         em.clear();\n         \n         //query\n-        Query q = em.createQuery(\"SELECT u FROM Bi_1ToM_JT u\");\n+        Query q = em.createQuery(\"SELECT b FROM Bi_1ToM_JT b where b.name = 'newName'\");\n         Bi_1ToM_JT b1 = (Bi_1ToM_JT)q.getSingleResult();\n         assertEquals(b, b1);\n         em.clear();\n \n+        //query\n+        q = em.createQuery(\"SELECT c FROM EntityC_B1MJT c\");\n+        List<EntityC_B1MJT> cs1 = q.getResultList();\n+        assertEquals(2, cs1.size());\n+        em.clear();\n+                \n         //find\n         long id = b1.getId();\n         Bi_1ToM_JT b2 = em.find(Bi_1ToM_JT.class, id);"}]}

