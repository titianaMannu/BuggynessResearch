{"sha":"72db5680fa7a9954cd1ba5e6d8d90ca265c0e20d","node_id":"MDY6Q29tbWl0MjA2MzY0OjcyZGI1NjgwZmE3YTk5NTRjZDFiYTVlNmQ4ZDkwY2EyNjVjMGUyMGQ=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2008-01-25T19:30:47Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2008-01-25T19:30:47Z"},"message":"OPENJPA-437. Removed synchronization.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.0.x@615311 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"638d4ae6f10bc934a343578104af9fb010bb5c97","url":"https://api.github.com/repos/apache/openjpa/git/trees/638d4ae6f10bc934a343578104af9fb010bb5c97"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/72db5680fa7a9954cd1ba5e6d8d90ca265c0e20d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/72db5680fa7a9954cd1ba5e6d8d90ca265c0e20d","html_url":"https://github.com/apache/openjpa/commit/72db5680fa7a9954cd1ba5e6d8d90ca265c0e20d","comments_url":"https://api.github.com/repos/apache/openjpa/commits/72db5680fa7a9954cd1ba5e6d8d90ca265c0e20d/comments","author":null,"committer":null,"parents":[{"sha":"bebd829b4512143e33a1edb6f4291d28b7fa4127","url":"https://api.github.com/repos/apache/openjpa/commits/bebd829b4512143e33a1edb6f4291d28b7fa4127","html_url":"https://github.com/apache/openjpa/commit/bebd829b4512143e33a1edb6f4291d28b7fa4127"}],"stats":{"total":27,"additions":16,"deletions":11},"files":[{"sha":"2c398a795febd61a68daeb69f4f3fc202d701afc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"modified","additions":16,"deletions":11,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/72db5680fa7a9954cd1ba5e6d8d90ca265c0e20d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/72db5680fa7a9954cd1ba5e6d8d90ca265c0e20d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=72db5680fa7a9954cd1ba5e6d8d90ca265c0e20d","patch":"@@ -95,6 +95,7 @@\n     // that we can re-load them for each new broker\n     private transient Collection _pcClassNames = null;\n     private transient Collection _pcClassLoaders = null;\n+    private transient boolean _persistentTypesLoaded = false;\n \n     // lifecycle listeners to pass to each broker\n     private transient Map _lifecycleListeners = null;\n@@ -232,28 +233,31 @@ protected void addListeners(BrokerImpl broker) {\n     /**\n      * Load the configured persistent classes list. Performed automatically\n      * whenever a broker is created.\n-     * \n-     * This method is synchronized due to the possible creation of new brokers\n-     * (entity managers) by multiple threads (clients).  The two data structures\n-     * used by this method (_pcClassNames and _pcClassLoaders) are not thread\n-     * safe and this was an easy, efficient solution (OPENJPA-437).\n      */\n-    private synchronized void loadPersistentTypes(ClassLoader envLoader) {\n-        // no listed persistent types?\n-        if (_pcClassNames != null && _pcClassNames.isEmpty())\n+    private void loadPersistentTypes(ClassLoader envLoader) {\n+        // if we've loaded the persistent types and the class name list\n+        // is empty, then we can simply return. Note that there is a\n+        // potential threading scenario in which _persistentTypesLoaded is\n+        // false when read, but the work to populate _pcClassNames has\n+        // already been done. This is ok; _pcClassNames can tolerate\n+        // concurrent access, so the worst case is that the list is\n+        // persistent type data is processed multiple times, which this\n+        // algorithm takes into account.\n+        if (_persistentTypesLoaded && _pcClassNames.isEmpty())\n             return;\n \n         // cache persistent type names if not already\n         ClassLoader loader = _conf.getClassResolverInstance().\n             getClassLoader(getClass(), envLoader);\n         Collection toRedefine = new ArrayList();\n-        if (_pcClassNames == null) {\n+        if (!_persistentTypesLoaded) {\n             Collection clss = _conf.getMetaDataRepositoryInstance().\n                 loadPersistentTypes(false, loader);\n             if (clss.isEmpty())\n-                _pcClassNames = Collections.EMPTY_LIST;\n+                _pcClassNames = Collections.EMPTY_SET;\n             else {\n-                _pcClassNames = new ArrayList(clss.size());\n+                _pcClassNames = new ConcurrentReferenceHashSet(\n+                    ConcurrentReferenceHashSet.HARD);\n                 for (Iterator itr = clss.iterator(); itr.hasNext();) {\n                     Class cls = (Class) itr.next();\n                     _pcClassNames.add(cls.getName());\n@@ -262,6 +266,7 @@ private synchronized void loadPersistentTypes(ClassLoader envLoader) {\n                 }\n                 _pcClassLoaders.add(loader);\n             }\n+            _persistentTypesLoaded = true;\n         } else {\n             // reload with this loader\n             if (_pcClassLoaders.add(loader)) {"}]}

