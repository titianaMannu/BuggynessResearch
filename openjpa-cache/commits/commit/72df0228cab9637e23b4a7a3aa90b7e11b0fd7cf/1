{"sha":"72df0228cab9637e23b4a7a3aa90b7e11b0fd7cf","node_id":"MDY6Q29tbWl0MjA2MzY0OjcyZGYwMjI4Y2FiOTYzN2UyM2I0YTdhM2FhOTBiN2UxMWIwZmQ3Y2Y=","commit":{"author":{"name":"Mark Struberg","email":"struberg@apache.org","date":"2021-03-28T17:36:32Z"},"committer":{"name":"Mark Struberg","email":"struberg@apache.org","date":"2021-03-28T17:36:32Z"},"message":"OPENJPA-2849 coerc native java.sql types to java.time\n\nMany JDBC driver support old java.sql types for select max, min, etc.\nThose need to get converted to java.time.* on demand.","tree":{"sha":"a0478af9c7e2022b92b1335b76a819278f7202f7","url":"https://api.github.com/repos/apache/openjpa/git/trees/a0478af9c7e2022b92b1335b76a819278f7202f7"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/72df0228cab9637e23b4a7a3aa90b7e11b0fd7cf","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/72df0228cab9637e23b4a7a3aa90b7e11b0fd7cf","html_url":"https://github.com/apache/openjpa/commit/72df0228cab9637e23b4a7a3aa90b7e11b0fd7cf","comments_url":"https://api.github.com/repos/apache/openjpa/commits/72df0228cab9637e23b4a7a3aa90b7e11b0fd7cf/comments","author":{"login":"struberg","id":79310,"node_id":"MDQ6VXNlcjc5MzEw","avatar_url":"https://avatars.githubusercontent.com/u/79310?v=4","gravatar_id":"","url":"https://api.github.com/users/struberg","html_url":"https://github.com/struberg","followers_url":"https://api.github.com/users/struberg/followers","following_url":"https://api.github.com/users/struberg/following{/other_user}","gists_url":"https://api.github.com/users/struberg/gists{/gist_id}","starred_url":"https://api.github.com/users/struberg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/struberg/subscriptions","organizations_url":"https://api.github.com/users/struberg/orgs","repos_url":"https://api.github.com/users/struberg/repos","events_url":"https://api.github.com/users/struberg/events{/privacy}","received_events_url":"https://api.github.com/users/struberg/received_events","type":"User","site_admin":false},"committer":{"login":"struberg","id":79310,"node_id":"MDQ6VXNlcjc5MzEw","avatar_url":"https://avatars.githubusercontent.com/u/79310?v=4","gravatar_id":"","url":"https://api.github.com/users/struberg","html_url":"https://github.com/struberg","followers_url":"https://api.github.com/users/struberg/followers","following_url":"https://api.github.com/users/struberg/following{/other_user}","gists_url":"https://api.github.com/users/struberg/gists{/gist_id}","starred_url":"https://api.github.com/users/struberg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/struberg/subscriptions","organizations_url":"https://api.github.com/users/struberg/orgs","repos_url":"https://api.github.com/users/struberg/repos","events_url":"https://api.github.com/users/struberg/events{/privacy}","received_events_url":"https://api.github.com/users/struberg/received_events","type":"User","site_admin":false},"parents":[{"sha":"aeb333fb3a6b7eb611c3ed79ba39c6286445f5b3","url":"https://api.github.com/repos/apache/openjpa/commits/aeb333fb3a6b7eb611c3ed79ba39c6286445f5b3","html_url":"https://github.com/apache/openjpa/commit/aeb333fb3a6b7eb611c3ed79ba39c6286445f5b3"}],"stats":{"total":172,"additions":149,"deletions":23},"files":[{"sha":"a63ae1a82bb7acfa3158b48bd1f00a551d247531","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","status":"modified","additions":84,"deletions":23,"changes":107,"blob_url":"https://github.com/apache/openjpa/blob/72df0228cab9637e23b4a7a3aa90b7e11b0fd7cf/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","raw_url":"https://github.com/apache/openjpa/raw/72df0228cab9637e23b4a7a3aa90b7e11b0fd7cf/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java?ref=72df0228cab9637e23b4a7a3aa90b7e11b0fd7cf","patch":"@@ -25,6 +25,13 @@\n import java.security.PrivilegedActionException;\n import java.sql.Time;\n import java.sql.Timestamp;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.OffsetTime;\n+import java.time.ZoneId;\n+import java.time.temporal.Temporal;\n import java.util.ArrayList;\n import java.util.Calendar;\n import java.util.Collection;\n@@ -266,6 +273,8 @@ public static Object convert(Object o, Class<?> type) {\n \n     /**\n      * Convert the given value to the given type.\n+     * @param o the given value\n+     * @param type the target type\n      */\n     public static Object convert(Object o, Class<?> type, boolean strictNumericConversion) {\n         if (o == null)\n@@ -283,42 +292,93 @@ public static Object convert(Object o, Class<?> type, boolean strictNumericConve\n         // String to Integer\n         boolean num = o instanceof Number;\n         if (!num) {\n-            if (type == String.class)\n+            if (type == String.class) {\n                 return o.toString();\n-            else if (type == Boolean.class && o instanceof String)\n+            }\n+            else if (type == Boolean.class && o instanceof String) {\n                 return Boolean.valueOf(o.toString());\n-            else if (type == Integer.class && o instanceof String)\n+            }\n+            else if (type == Integer.class && o instanceof String) {\n                 try {\n                     return new Integer(o.toString());\n-                } catch (NumberFormatException e) {\n-                    throw new ClassCastException(_loc.get(\"cant-convert\", o,\n-                        o.getClass(), type).getMessage());\n                 }\n+                catch (NumberFormatException e) {\n+                    throw new ClassCastException(_loc.get(\"cant-convert\", o, o.getClass(), type).getMessage());\n+                }\n+            }\n             else if (type == Character.class) {\n                 String str = o.toString();\n-                if (str != null && str.length() == 1)\n+                if (str != null && str.length() == 1) {\n                     return Character.valueOf(str.charAt(0));\n-            } else if (Calendar.class.isAssignableFrom(type) &&\n-                o instanceof Date) {\n+                }\n+            }\n+            else if (Calendar.class.isAssignableFrom(type) && o instanceof Date) {\n                 Calendar cal = Calendar.getInstance();\n                 cal.setTime((Date) o);\n                 return cal;\n-            } else if (Date.class.isAssignableFrom(type) &&\n-                o instanceof Calendar) {\n+            }\n+            else if (Date.class.isAssignableFrom(type) && o instanceof Calendar) {\n                 return ((Calendar) o).getTime();\n-            } else if (Number.class.isAssignableFrom(type)) {\n+            }\n+            else if (Number.class.isAssignableFrom(type)) {\n                 Integer i = null;\n                 if (o instanceof Character) {\n-                    i = Integer.valueOf((Character)o);\n+                    i = Integer.valueOf((Character) o);\n+                }\n+                else if (o instanceof String && ((String) o).length() == 1) {\n+                    i = Integer.valueOf(((String) o));\n                 }\n-                else if (o instanceof String && ((String) o).length() == 1)\n-                    i = Integer.valueOf(((String)o));\n \n                 if (i != null) {\n-                    if (type == Integer.class)\n+                    if (type == Integer.class) {\n                         return i;\n+                    }\n                     num = true;\n                 }\n+            } else if (Temporal.class.isAssignableFrom(type)) {\n+                // handling of Java8 time API.\n+                if (LocalDate.class.equals(type)) {\n+                    if (o instanceof java.sql.Date) {\n+                        return ((java.sql.Date) o).toLocalDate();\n+                    } else if (o instanceof java.util.Date) {\n+                        return new java.sql.Date(((java.util.Date)o).getTime()).toLocalDate();\n+                    } else if (o instanceof CharSequence) {\n+                        return LocalDate.parse((CharSequence) o);\n+                    }\n+                } else if (LocalDateTime.class.equals(type)) {\n+                    if (o instanceof java.sql.Timestamp) {\n+                        return ((java.sql.Timestamp) o).toLocalDateTime();\n+                    } else if (o instanceof java.util.Date) {\n+                        return ((java.util.Date)o).toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();\n+                    } else if (o instanceof CharSequence) {\n+                        return LocalDateTime.parse((CharSequence) o);\n+                    }\n+                } else if (LocalTime.class.equals(type)) {\n+                    if (o instanceof java.sql.Time) {\n+                        return ((java.sql.Time) o).toLocalTime();\n+                    } else if (o instanceof java.util.Date) {\n+                        return ((java.util.Date)o).toInstant().atZone(ZoneId.systemDefault()).toLocalTime();\n+                    } else if (o instanceof CharSequence) {\n+                        return LocalTime.parse((CharSequence) o);\n+                    }\n+                } else if (OffsetTime.class.equals(type)) {\n+                    if (o instanceof java.sql.Time) {\n+                        return ((java.sql.Time) o).toLocalTime().atOffset(OffsetDateTime.now().getOffset());\n+                    } else if (o instanceof java.util.Date) {\n+                        return ((java.util.Date)o).toInstant().atZone(ZoneId.systemDefault()).toOffsetDateTime().toOffsetTime();\n+                    } else if (o instanceof CharSequence) {\n+                        return OffsetTime.parse((CharSequence) o);\n+                    }\n+                } else if (OffsetDateTime.class.equals(type)) {\n+                    if (o instanceof java.sql.Timestamp) {\n+                        return ((java.sql.Timestamp) o).toInstant().atZone(ZoneId.systemDefault()).toOffsetDateTime();\n+                    } else if (o instanceof java.util.Date) {\n+                        return ((java.util.Date)o).toInstant().atZone(ZoneId.systemDefault()).toOffsetDateTime();\n+                    } else if (o instanceof CharSequence) {\n+                        return LocalTime.parse((CharSequence) o);\n+                    }\n+                }\n+\n             } else if (o instanceof String && isJDBCTemporalSyntax(o.toString())) {\n                 try {\n                     Object temporal = parseJDBCTemporalSyntax(o.toString());\n@@ -331,9 +391,9 @@ else if (o instanceof String && ((String) o).length() == 1)\n                 return Enum.valueOf((Class<Enum>)type, o.toString());\n             }\n         }\n-        if (!num)\n-            throw new ClassCastException(_loc.get(\"cant-convert\", o,\n-                o.getClass(), type).getMessage());\n+        if (!num) {\n+            throw new ClassCastException(_loc.get(\"cant-convert\", o, o.getClass(), type).getMessage());\n+        }\n \n         if (type == Integer.class && allowNumericConversion(o.getClass(), type, strictNumericConversion)) {\n             return ((Number) o).intValue();\n@@ -349,12 +409,13 @@ else if (o instanceof String && ((String) o).length() == 1)\n             // does it handle infinity; we need to instead use the Double\n             // and Float versions, despite wanting to cast it to BigDecimal\n             double dval = ((Number) o).doubleValue();\n-            if (Double.isNaN(dval) || Double.isInfinite(dval))\n+            if (Double.isNaN(dval) || Double.isInfinite(dval)) {\n                 return Double.valueOf(dval);\n-\n+            }\n             float fval = ((Number) o).floatValue();\n-            if (Float.isNaN(fval) || Float.isInfinite(fval))\n+            if (Float.isNaN(fval) || Float.isInfinite(fval)) {\n                 return Float.valueOf(fval);\n+            }\n \n             return new BigDecimal(o.toString());\n         } else if (type == BigInteger.class) {\n@@ -364,7 +425,7 @@ else if (o instanceof String && ((String) o).length() == 1)\n         } else if (type == Byte.class && allowNumericConversion(o.getClass(), type, strictNumericConversion)) {\n             return Byte.valueOf(((Number) o).byteValue());\n         } else if (type == Character.class) {\n-        \treturn (char) ((Number) o).intValue();\n+            return (char) ((Number) o).intValue();\n         } else if (!strictNumericConversion) {\n             return ((Number) o).intValue();\n         } else {"},{"sha":"17b76cac7434ced56a961e77ad07419ee241efc8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestJava8TimeTypes.java","status":"modified","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/72df0228cab9637e23b4a7a3aa90b7e11b0fd7cf/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestJava8TimeTypes.java","raw_url":"https://github.com/apache/openjpa/raw/72df0228cab9637e23b4a7a3aa90b7e11b0fd7cf/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestJava8TimeTypes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestJava8TimeTypes.java?ref=72df0228cab9637e23b4a7a3aa90b7e11b0fd7cf","patch":"@@ -21,11 +21,15 @@\n import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n \n import javax.persistence.EntityManager;\n+import javax.persistence.TypedQuery;\n \n import java.time.Instant;\n import java.time.LocalDate;\n import java.time.LocalDateTime;\n import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.OffsetTime;\n+import java.time.ZoneId;\n import java.time.ZoneOffset;\n import java.util.Date;\n \n@@ -75,6 +79,67 @@ public void testJava8Types() {\n \n         assertEquals(e.getOffsetTimeField().withOffsetSameInstant(eRead.getOffsetTimeField().getOffset()),\n                 eRead.getOffsetTimeField());\n+\n+        // we've got reports from various functions not properly working with Java8 Dates.\n+\n+        // max function\n+        {\n+            final TypedQuery<LocalDate> qry = em.createQuery(\"select max(t.localDateField) from Java8TimeTypes AS t\", LocalDate.class);\n+            final LocalDate max = qry.getSingleResult();\n+            assertEquals(LocalDate.parse(VAL_LOCAL_DATE), max);\n+        }\n+        {\n+            final TypedQuery<LocalDateTime> qry = em.createQuery(\"select max(t.localDateTimeField) from Java8TimeTypes AS t\", LocalDateTime.class);\n+            final LocalDateTime max = qry.getSingleResult();\n+            assertEquals(LocalDateTime.parse(VAL_LOCAL_DATETIME), max);\n+        }\n+        {\n+            final TypedQuery<LocalTime> qry = em.createQuery(\"select max(t.localTimeField) from Java8TimeTypes AS t\", LocalTime.class);\n+            final LocalTime max = qry.getSingleResult();\n+            assertEquals(LocalTime.parse(VAL_LOCAL_TIME), max);\n+        }\n+        {\n+            final TypedQuery<OffsetTime> qry = em.createQuery(\"select max(t.offsetTimeField) from Java8TimeTypes AS t\", OffsetTime.class);\n+            final OffsetTime max = qry.getSingleResult();\n+            assertEquals(e.getOffsetTimeField().withOffsetSameInstant(eRead.getOffsetTimeField().getOffset()),\n+                    max.withOffsetSameInstant(eRead.getOffsetTimeField().getOffset()));\n+        }\n+        {\n+            final TypedQuery<OffsetDateTime> qry = em.createQuery(\"select max(t.offsetDateTimeField) from Java8TimeTypes AS t\", OffsetDateTime.class);\n+            final OffsetDateTime max = qry.getSingleResult();\n+            assertEquals(Instant.from(e.getOffsetDateTimeField()),\n+                    Instant.from(max));\n+        }\n+\n+        // min function\n+        {\n+            final TypedQuery<LocalDate> qry = em.createQuery(\"select min(t.localDateField) from Java8TimeTypes AS t\", LocalDate.class);\n+            final LocalDate min = qry.getSingleResult();\n+            assertEquals(LocalDate.parse(VAL_LOCAL_DATE), min);\n+        }\n+        {\n+            final TypedQuery<LocalDateTime> qry = em.createQuery(\"select min(t.localDateTimeField) from Java8TimeTypes AS t\", LocalDateTime.class);\n+            final LocalDateTime min = qry.getSingleResult();\n+            assertEquals(LocalDateTime.parse(VAL_LOCAL_DATETIME), min);\n+        }\n+        {\n+            final TypedQuery<LocalTime> qry = em.createQuery(\"select min(t.localTimeField) from Java8TimeTypes AS t\", LocalTime.class);\n+            final LocalTime min = qry.getSingleResult();\n+            assertEquals(LocalTime.parse(VAL_LOCAL_TIME), min);\n+        }\n+        {\n+            final TypedQuery<OffsetTime> qry = em.createQuery(\"select min(t.offsetTimeField) from Java8TimeTypes AS t\", OffsetTime.class);\n+            final OffsetTime min = qry.getSingleResult();\n+            assertEquals(e.getOffsetTimeField().withOffsetSameInstant(eRead.getOffsetTimeField().getOffset()),\n+                    min.withOffsetSameInstant(eRead.getOffsetTimeField().getOffset()));\n+        }\n+        {\n+            final TypedQuery<OffsetDateTime> qry = em.createQuery(\"select min(t.offsetDateTimeField) from Java8TimeTypes AS t\", OffsetDateTime.class);\n+            final OffsetDateTime min = qry.getSingleResult();\n+            assertEquals(Instant.from(e.getOffsetDateTimeField()),\n+                    Instant.from(min));\n+        }\n+\n     }\n \n "}]}

