{"sha":"747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","node_id":"MDY6Q29tbWl0MjA2MzY0Ojc0NzIyNmIxZDZkYzZkNTdmZDI4MzMyYjRjMmE0YjBjNGFkN2E1OWM=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-07-26T22:08:37Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-07-26T22:08:37Z"},"message":"OPENJPA-293. All tests pass, but only because we don't currently test Java 5 + redefinition (only Java 5 + no redef). We need a new version of serp (1.13.1) to support that configuration; the new version has not yet made it into ibiblio.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@560016 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b55eb4b18ccb2b0767ebce7456dd901add10e5d2","url":"https://api.github.com/repos/apache/openjpa/git/trees/b55eb4b18ccb2b0767ebce7456dd901add10e5d2"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","html_url":"https://github.com/apache/openjpa/commit/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","comments_url":"https://api.github.com/repos/apache/openjpa/commits/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/comments","author":null,"committer":null,"parents":[{"sha":"6b45d6ed968f0e4d8aa1d71ae587ee8720cfc110","url":"https://api.github.com/repos/apache/openjpa/commits/6b45d6ed968f0e4d8aa1d71ae587ee8720cfc110","html_url":"https://github.com/apache/openjpa/commit/6b45d6ed968f0e4d8aa1d71ae587ee8720cfc110"}],"stats":{"total":4599,"additions":4172,"deletions":427},"files":[{"sha":"30a4c5d11fdbaade35c2138ddc356a936f6e3395","filename":"openjpa-all/pom.xml","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-all/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-all/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-all/pom.xml?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -102,7 +102,9 @@\n                     <archive>\n                         <manifestEntries>\n                             <Premain-Class>\n-                                org.apache.openjpa.enhance.PCEnhancerAgent</Premain-Class>\n+                                org.apache.openjpa.enhance.PCEnhancerAgent\n+                            </Premain-Class>\n+                            <Can-Redefine-Classes>true</Can-Redefine-Classes>\n                         </manifestEntries>\n                     </archive>\n                 </configuration>"},{"sha":"28b8d2152d27dab1b4b93399a045a462daefe79e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstGetObjectId.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstGetObjectId.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstGetObjectId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstGetObjectId.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -18,9 +18,9 @@\n  */\n package org.apache.openjpa.jdbc.kernel.exps;\n \n-import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.util.ImplHelper;\n \n /**\n  * Obtaining the object id of a constant.\n@@ -48,9 +48,11 @@ public void setImplicitType(Class type) {\n \n     public Object getValue(Object[] params) {\n         Object o = _constant.getValue(params);\n-        if (!(o instanceof PersistenceCapable))\n+        if (!(ImplHelper.isManageable(o)))\n             return null;\n-        return ((PersistenceCapable) o).pcFetchObjectId();\n+        return (ImplHelper.toPersistenceCapable(o,\n+            this.getMetaData().getRepository().getConfiguration()))\n+            .pcFetchObjectId();\n     }\n \n     public Object getValue(ExpContext ctx, ExpState state) {"},{"sha":"96049edd0b2facfe808002c52544c519196fb771","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -22,7 +22,6 @@\n import java.util.LinkedList;\n import java.util.ListIterator;\n \n-import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.Broker;\n@@ -33,6 +32,7 @@\n import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.XMLMetaData;\n import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.ImplHelper;\n \n /**\n  * A field traversal starting with a constant filter parameter.\n@@ -141,8 +141,10 @@ public void calculateValue(Select sel, ExpContext ctx, ExpState state,\n             // be proxyable\n             sm = null;\n             tmpBroker = null;\n-            if (cstate.value instanceof PersistenceCapable)\n-                sm = (OpenJPAStateManager) ((PersistenceCapable) cstate.value).\n+            if (ImplHelper.isManageable(cstate.value))\n+                sm = (OpenJPAStateManager) (ImplHelper.toPersistenceCapable(\n+                    cstate.value,\n+                    this.getMetaData().getRepository().getConfiguration())).\n                     pcGetStateManager();\n             if (sm == null) {\n                 tmpBroker = ctx.store.getContext().getBroker();"},{"sha":"017460cc9612e8ab33fb51c0caaf5fc1e96525b1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java","status":"modified","additions":3,"deletions":4,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -21,7 +21,6 @@\n import java.util.Collection;\n import java.util.Map;\n \n-import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n@@ -108,11 +107,11 @@ public void calculateValue(Select sel, ExpContext ctx, ExpState state,\n         if (other != null && !_container) {\n             pstate.sqlValue = other.toDataStoreValue(sel, ctx, otherState, val);\n             pstate.otherLength = other.length(sel, ctx, otherState);\n-        } else if (val instanceof PersistenceCapable) {\n+        } else if (ImplHelper.isManageable(val)) {\n             ClassMapping mapping = ctx.store.getConfiguration().\n-                getMappingRepositoryInstance().getMapping(val.getClass(), \n+                getMappingRepositoryInstance().getMapping(val.getClass(),\n                 ctx.store.getContext().getClassLoader(), true);\n-            pstate.sqlValue = mapping.toDataStoreValue(val, \n+            pstate.sqlValue = mapping.toDataStoreValue(val,\n                 mapping.getPrimaryKeyColumns(), ctx.store);\n             pstate.otherLength = mapping.getPrimaryKeyColumns().length;\n         } else"},{"sha":"cc6ddc8888bfcb5e08d7bba7284f65a0771fdd24","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -30,7 +30,6 @@\n import java.util.Map;\n import java.util.Set;\n \n-import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.strats.NoneClassStrategy;\n@@ -55,6 +54,7 @@\n import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.MetaDataException;\n import org.apache.openjpa.util.OpenJPAId;\n+import org.apache.openjpa.util.ImplHelper;\n \n /**\n  * Specialization of metadata for relational databases.\n@@ -208,9 +208,10 @@ public Object toDataStoreValue(Object obj, Column[] cols, JDBCStore store) {\n         // from other persistence contexts, so try to get sm directly from\n         // instance before asking our context\n         OpenJPAStateManager sm;\n-        if (obj instanceof PersistenceCapable)\n-            sm = (OpenJPAStateManager) ((PersistenceCapable) obj).\n-                pcGetStateManager();\n+        if (ImplHelper.isManageable(obj))\n+            sm = (OpenJPAStateManager) (ImplHelper.toPersistenceCapable(obj,\n+                getRepository().getConfiguration()))\n+                .pcGetStateManager();\n         else\n             sm = store.getContext().getStateManager(obj);\n         if (sm == null)"},{"sha":"4ae7cdaa5740e2359c64f007204d845b0d8bec7a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java","status":"modified","additions":4,"deletions":2,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -32,6 +32,7 @@\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.util.StoreException;\n+import org.apache.openjpa.util.ImplHelper;\n \n /**\n  * Handler for unknown persistence-capable object fields that stores\n@@ -77,8 +78,9 @@ public Object toDataStoreValue(ValueMapping vm, Object val,\n         // in the past we've been lenient about being able to translate objects\n         // from other persistence contexts, so try to get sm directly from\n         // instance before asking our context\n-        if (val instanceof PersistenceCapable) {\n-            PersistenceCapable pc = (PersistenceCapable) val;\n+        if (ImplHelper.isManageable(val)) {\n+            PersistenceCapable pc = ImplHelper.toPersistenceCapable(val,\n+                store.getConfiguration());\n             if (pc.pcGetStateManager() != null)\n                 return pc.pcGetStateManager();\n         }"},{"sha":"127db00d01784b8738a0aec8e6be8623594e5c69","filename":"openjpa-kernel-5/pom.xml","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel-5/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel-5/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/pom.xml?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -58,7 +58,9 @@\n                     <archive>\n                         <manifestEntries>\n                             <Premain-Class>\n-                                org.apache.openjpa.enhance.PCEnhancerAgent</Premain-Class>\n+                                org.apache.openjpa.enhance.InstrumentationFactory\n+                            </Premain-Class>\n+                            <Can-Redefine-Classes>true</Can-Redefine-Classes>\n                         </manifestEntries>\n                     </archive>\n                 </configuration>"},{"sha":"ac6d782dc52a6a212e455ebe613a47424c406adc","filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","status":"added","additions":151,"deletions":0,"changes":151,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,151 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.lang.instrument.Instrumentation;\r\n+import java.lang.instrument.ClassFileTransformer;\r\n+import java.lang.instrument.ClassDefinition;\r\n+import java.lang.instrument.UnmodifiableClassException;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.lang.reflect.Method;\r\n+import java.security.ProtectionDomain;\r\n+import java.util.Map;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.ArrayList;\r\n+import java.io.IOException;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.lib.util.JavaVersions;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Redefines the method bodies of existing classes. Supports Java 5 VMs that\r\n+ * have a javaagent installed on the command line as well as newer VMs without\r\n+ * any javaagent flag.\r\n+ *\r\n+ * @since 1.0.0\r\n+ */\r\n+public class ClassRedefiner {\r\n+\r\n+    private static final Localizer _loc = \r\n+        Localizer.forPackage(ClassRedefiner.class);\r\n+\r\n+    private static Boolean _canRedefine = null;\r\n+\r\n+    /**\r\n+     * For each element in <code>classes</code>, this method will redefine\r\n+     * all the element's methods such that field accesses are intercepted\r\n+     * in-line.\r\n+     */\r\n+    public static void redefineClasses(OpenJPAConfiguration conf,\r\n+        final Map<Class,byte[]> classes) {\r\n+        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n+        if (classes == null || classes.size() == 0)\r\n+            return;\r\n+\r\n+        Instrumentation inst = null;\r\n+        ClassFileTransformer t = null;\r\n+        try {\r\n+            inst = InstrumentationFactory.getInstrumentation();\r\n+\r\n+            Class[] array = classes.keySet().toArray(new Class[classes.size()]);\r\n+            if (JavaVersions.VERSION >= 6) {\r\n+                log.trace(_loc.get(\"retransform-types\", classes.keySet()));\r\n+\r\n+                t = new ClassFileTransformer() {\r\n+                    public byte[] transform(ClassLoader loader, String clsName,\r\n+                        Class<?> classBeingRedefined, ProtectionDomain pd,\r\n+                        byte[] classfileBuffer) {\r\n+                        return classes.get(classBeingRedefined);\r\n+                    }\r\n+                };\r\n+                \r\n+                // these are Java 6 methods, and we don't have a Java 6 build\r\n+                // module yet. The cost of reflection here is negligible\r\n+                // compared to the redefinition / enhancement costs in total,\r\n+                // so this should not be a big problem.\r\n+                Method meth = inst.getClass().getMethod(\"addTransformer\",\r\n+                    new Class[] { ClassFileTransformer.class, boolean.class });\r\n+                meth.invoke(inst, new Object[] { t, true });\r\n+                meth = inst.getClass().getMethod(\"retransformClasses\",\r\n+                    new Class[] { array.getClass() });\r\n+                meth.invoke(inst, new Object[] { array });\r\n+            } else {\r\n+                log.trace(_loc.get(\"redefine-types\", classes.keySet()));\r\n+                // in a Java 5 context, we can use class redefinition instead\r\n+                ClassDefinition[] defs = new ClassDefinition[array.length];\r\n+                for (int i = 0; i < defs.length; i++)\r\n+                    defs[i] = new ClassDefinition(array[i],\r\n+                        classes.get(array[i]));\r\n+                inst.redefineClasses(defs);\r\n+            }\r\n+        } catch (NoSuchMethodException e) {\r\n+            throw new InternalException(e);\r\n+        } catch (IllegalAccessException e) {\r\n+            throw new InternalException(e);\r\n+        } catch (InvocationTargetException e) {\r\n+            throw new UserException(e.getCause());\r\n+        } catch (IOException e) {\r\n+            throw new InternalException(e);\r\n+        } catch (ClassNotFoundException e) {\r\n+            throw new InternalException(e);\r\n+        } catch (UnmodifiableClassException e) {\r\n+            throw new InternalException(e);\r\n+        } finally {\r\n+            if (inst != null && t != null)\r\n+                inst.removeTransformer(t);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * @return whether or not this VM has an instrumentation installed that\r\n+     * permits redefinition of classes. This assumes that all the arguments\r\n+     * will be modifiable classes according to\r\n+     * {@link java.lang.instrument.Instrumentation#isModifiableClass}, and\r\n+     * only checks whether or not an instrumentation is available and\r\n+     * if retransformation is possible.\r\n+     */\r\n+    public static boolean canRedefineClasses() {\r\n+        if (_canRedefine == null) {\r\n+            try {\r\n+                Instrumentation inst = InstrumentationFactory\r\n+                    .getInstrumentation();\r\n+                if (inst == null) {\r\n+                    _canRedefine = Boolean.FALSE;\r\n+                } else if (JavaVersions.VERSION == 5) {\r\n+                    // if inst is non-null and we're using Java 5,\r\n+                    // isRetransformClassesSupported isn't available,\r\n+                    // so we use the more basic class redefinition\r\n+                    // instead.\r\n+                    _canRedefine = Boolean.TRUE;\r\n+                } else {\r\n+                    _canRedefine = (Boolean) Instrumentation.class.getMethod(\r\n+                        \"isRetransformClassesSupported\").invoke(inst);\r\n+                }\r\n+            } catch (Exception e) {\r\n+                _canRedefine = Boolean.FALSE;\r\n+            }\r\n+        }\r\n+        return _canRedefine.booleanValue();\r\n+    }\r\n+}\n\\ No newline at end of file"},{"sha":"505b5ff25e5777465e8ebc1530798393c94295d2","filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/InstrumentationFactory.java","status":"added","additions":123,"deletions":0,"changes":123,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/InstrumentationFactory.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/InstrumentationFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/InstrumentationFactory.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.io.*;\n+import java.lang.instrument.*;\n+import java.lang.management.*;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.zip.*;\n+import org.apache.openjpa.lib.util.*;\n+\n+\n+/**\n+ * Factory for obtaining an {@link Instrumentation} instance.\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @since 1.0.0\n+ */\n+public class InstrumentationFactory {\n+    private static Instrumentation _inst;\n+    private static boolean _dynamicallyInstall = true;\n+\n+    public static void setInstrumentation(Instrumentation inst) {\n+        _inst = inst;\n+    }\n+\n+    /**\n+     * Configures whether or not this instance should attempt to dynamically\n+     * install an agent in the VM. Defaults to <code>true</code>.\n+     */\n+    public static synchronized void setDynamicallyInstallAgent(boolean val) {\n+        _dynamicallyInstall = val;\n+    }\n+\n+    public static synchronized Instrumentation getInstrumentation()\n+        throws IOException, NoSuchMethodException, IllegalAccessException,\n+        InvocationTargetException, ClassNotFoundException {\n+        if (_inst != null || !_dynamicallyInstall)\n+            return _inst;\n+\n+        // dynamic loading of the agent is only available in JDK 1.6+\n+        if (JavaVersions.VERSION < 6)\n+            return null;\n+\n+        String agentPath = getAgentJar();\n+\n+        // first obtain the PID of the currently-running process\n+        // ### this relies on the undocumented convention of the RuntimeMXBean's\n+        // ### name starting with the PID, but there appears to be no other\n+        // ### way to obtain the current process' id, which we need for\n+        // ### the attach process\n+        RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();\n+        String pid = runtime.getName();\n+        if (pid.indexOf(\"@\") != -1)\n+            pid = pid.substring(0, pid.indexOf(\"@\"));\n+\n+        // JDK1.6: now attach to the current VM so we can deploy a new agent\n+        // ### this is a Sun JVM specific feature; other JVMs may offer\n+        // ### this feature, but in an implementation-dependent way\n+        Class vmClass = Class.forName(\"com.sun.tools.attach.VirtualMachine\");\n+        Object vm = vmClass.getMethod(\"attach\", new Class[] { String.class }).\n+            invoke(null, new String[] { pid });\n+\n+        // now deploy the actual agent, which will wind up calling agentmain()\n+        vm.getClass().getMethod(\"loadAgent\", new Class[] { String.class }).\n+            invoke(vm, new Object[] { agentPath });\n+\n+        if (_inst != null)\n+            return _inst;\n+\n+        return null;\n+    }\n+\n+    /** \n+     *  Create a new jar file for the sole purpose of specifying an\n+     *  Agent-Class to load into the JVM.\n+     */\n+    private static String getAgentJar() throws IOException {\n+        File file = File.createTempFile(\n+            InstrumentationFactory.class.getName(), \".jar\");\n+        file.deleteOnExit();\n+\n+        ZipOutputStream zout = new ZipOutputStream(new FileOutputStream(file));\n+        zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n+\n+        PrintWriter writer = new PrintWriter\n+            (new OutputStreamWriter(zout));\n+\n+        writer.println(\"Agent-Class: \"\n+            + InstrumentationFactory.class.getName());\n+        writer.println(\"Can-Redefine-Classes: true\");\n+        writer.println(\"Can-Retransform-Classes: true\");\n+\n+        writer.close();\n+\n+        return file.getAbsolutePath();\n+    }\n+\n+    /**\n+     *  The method that is called when a jar is added as an agent at runtime.\n+     *  All this method does is store the {@link Instrumentation} for\n+     *  later use.\n+     */\n+    public static void agentmain(String agentArgs, Instrumentation inst) {\n+        InstrumentationFactory.setInstrumentation(inst);\n+    }\n+}\n\\ No newline at end of file"},{"sha":"41489937b164f078f1a5c53faf5f4ca33ec68362","filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","status":"added","additions":177,"deletions":0,"changes":177,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,177 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.Map;\r\n+import java.util.HashMap;\r\n+import java.util.Collection;\r\n+import java.util.List;\r\n+import java.util.Collections;\r\n+import java.util.ArrayList;\r\n+import java.util.Iterator;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.lib.util.JavaVersions;\r\n+import org.apache.openjpa.lib.util.BytecodeWriter;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.util.GeneratedClasses;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import serp.bytecode.BCClass;\r\n+\r\n+/**\r\n+ * Redefines the method bodies of existing unenhanced classes to make them\r\n+ * notify state managers of mutations.\r\n+ *\r\n+ * @since 1.0.0\r\n+ */\r\n+public class ManagedClassSubclasser {\r\n+    private static final Localizer _loc = Localizer.forPackage(\r\n+        ManagedClassSubclasser.class);\r\n+\r\n+    /**\r\n+     * For each element in <code>classes</code>, creates and registers a\r\n+     * new subclass that implements {@link PersistenceCapable}, and prepares\r\n+     * OpenJPA to handle new instances of the unenhanced type. If this is\r\n+     * invoked in a Java 6 environment, this method will redefine the methods\r\n+     * for each class in the argument list such that field accesses are\r\n+     * intercepted in-line. If invoked in a Java 5 environment, this\r\n+     * redefinition is not possible; in these contexts, when using field\r\n+     * access, OpenJPA will need to do state comparisons to detect any change\r\n+     * to any instance at any time, and when using property access, OpenJPA\r\n+     * will need to do state comparisons to detect changes to newly inserted\r\n+     * instances after a flush has been called.\r\n+     *\r\n+     * @return the new subclasses\r\n+     *\r\n+     * @since 1.0.0\r\n+     */\r\n+    public static List<Class> prepareUnenhancedClasses(\r\n+        final OpenJPAConfiguration conf,\r\n+        final Collection<? extends Class> classes,\r\n+        final ClassLoader envLoader) {\r\n+        if (classes == null)\r\n+            return null;\r\n+        if (classes.size() == 0)\r\n+            return Collections.EMPTY_LIST;\r\n+\r\n+        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n+        if (ClassRedefiner.canRedefineClasses())\r\n+            log.info(_loc.get(\"enhance-and-subclass-no-redef-start\",\r\n+                classes));\r\n+        else\r\n+            log.info(_loc.get(\"enhance-and-subclass-and-redef-start\",\r\n+                classes));\r\n+\r\n+        final Map<Class, byte[]> map = new HashMap<Class, byte[]>();\r\n+        final List subs = new ArrayList(classes.size());\r\n+        final List ints = new ArrayList(classes.size());\r\n+        for (Iterator iter = classes.iterator(); iter.hasNext(); ) {\r\n+            final Class cls = (Class) iter.next();\r\n+            final PCEnhancer enhancer = new PCEnhancer(conf, cls);\r\n+\r\n+            // set this before enhancement as well as after since enhancement\r\n+            // uses a different metadata repository, and the value of this\r\n+            // setting matters in the enhancement contract.\r\n+            setDetachedState(enhancer.getMetaData());\r\n+\r\n+            enhancer.setBytecodeWriter(new BytecodeWriter() {\r\n+                public void write(BCClass bc) throws IOException {\r\n+                    ManagedClassSubclasser.write(bc, enhancer, map,\r\n+                        cls, subs, ints);\r\n+                }\r\n+            });\r\n+            if (ClassRedefiner.canRedefineClasses())\r\n+                enhancer.setRedefine(true);\r\n+            enhancer.setCreateSubclass(true);\r\n+            enhancer.setAddDefaultConstructor(true);\r\n+            enhancer.run();\r\n+            try {\r\n+                enhancer.record();\r\n+            } catch (IOException e) {\r\n+                // our impl of BytecodeWriter doesn't throw IOException\r\n+                throw new InternalException(e);\r\n+            }\r\n+        }\r\n+\r\n+        ClassRedefiner.redefineClasses(conf, map);\r\n+        for (Class cls : map.keySet()) {\r\n+            setIntercepting(conf, envLoader, cls);\r\n+            configureMetaData(conf, envLoader, cls);\r\n+        }\r\n+        for (Class cls : (Collection<Class>) subs)\r\n+            configureMetaData(conf, envLoader, cls);\r\n+        for (Class cls : (Collection<Class>) ints)\r\n+            setIntercepting(conf, envLoader, cls);\r\n+\r\n+        return subs;\r\n+    }\r\n+\r\n+    private static void write(BCClass bc, PCEnhancer enhancer,\r\n+        Map<Class, byte[]> map, Class cls, List subs, List ints)\r\n+        throws IOException {\r\n+\r\n+        // #####\r\n+        java.io.File dir = org.apache.openjpa.lib.util.Files.getPackageFile(\r\n+            new java.io.File(\"subs\"), bc.getPackageName(), true);\r\n+        bc.write(new java.io.File(dir, bc.getClassName() + \".class\"));\r\n+\r\n+        if (bc == enhancer.getManagedTypeBytecode()) {\r\n+            // if it was already defined, don't put it in the map,\r\n+            // but do set the metadata accordingly.\r\n+            if (enhancer.isAlreadyRedefined())\r\n+                ints.add(bc.getType());\r\n+            else if (JavaVersions.VERSION >= 5)\r\n+                map.put(bc.getType(), bc.toByteArray());\r\n+        } else {\r\n+            if (!enhancer.isAlreadySubclassed()) {\r\n+                // this is the new subclass\r\n+                ClassLoader loader = GeneratedClasses.getMostDerivedLoader(\r\n+                    cls, PersistenceCapable.class);\r\n+                subs.add(GeneratedClasses.loadBCClass(bc, loader));\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private static void setIntercepting(OpenJPAConfiguration conf,\r\n+        ClassLoader envLoader, Class cls) {\r\n+        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\r\n+            .getMetaData(cls, envLoader, true);\r\n+        meta.setIntercepting(true);\r\n+    }\r\n+\r\n+    private static void configureMetaData(OpenJPAConfiguration conf,\r\n+        ClassLoader envLoader, Class cls) {\r\n+        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\r\n+            .getMetaData(cls, envLoader, true);\r\n+        setDetachedState(meta);\r\n+    }\r\n+\r\n+    /**\r\n+     * If the metadata is configured to use a synthetic\r\n+     * detached state, reset it to not use a detached\r\n+     * state field, since we can't add fields when redefining.\r\n+     */\r\n+    private static void setDetachedState(ClassMetaData meta) {\r\n+        if (ClassMetaData.SYNTHETIC.equals(meta.getDetachedState()))\r\n+            meta.setDetachedState(null);\r\n+    }\r\n+}\r"},{"sha":"b3a06960dab257da7a872ae8ef0ec35ad9e2451e","filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -133,7 +133,7 @@ public PCClassFileTransformer(MetaDataRepository repos,\n \n             if (enhancer.run() == PCEnhancer.ENHANCE_NONE)\n                 return null;\n-            return enhancer.getBytecode().toByteArray();\n+            return enhancer.getPCBytecode().toByteArray();\n         } catch (Throwable t) {\n             _log.warn(_loc.get(\"cft-exception-thrown\", className), t);\n             if (t instanceof RuntimeException)"},{"sha":"7aeb12d128e736a29ca86f1a905092fd6780a161","filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java","status":"modified","additions":37,"deletions":9,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -30,24 +30,52 @@\n import org.apache.openjpa.util.ClassResolver;\n \n /**\n- * Java agent that makes persistent classes implement the\n- * {@link PersistenceCapable} interface at runtime. The agent is launched\n- * at JVM startup from the command line:\n- * \n- * <code>java -javaagent:openjpa.jar[=&lt;options&gt;]</code>\n+ * <p>Java agent that makes persistent classes work with OpenJPA at runtime.\n+ * This is achieved by either running the enhancer on the classes as they\n+ * are loaded, or by redefining the classes on the fly.\n+ * The agent is launched at JVM startup from the command line:</p>\n+ *\n+ * <p><code>java -javaagent:openjpa.jar[=&lt;options&gt;]</code>\n  *  The options string should be formatted as a OpenJPA plugin, and may\n  * contain any properties understood by the OpenJPA enhancer or any\n- * configuration properties. For example:\n- * \n- * <code>java -javaagent:openjpa.jar</code>\n+ * configuration properties. For example:</p>\n+ *\n+ * <p><code>java -javaagent:openjpa.jar</code></p>\n+ *\n+ * <p>By default, if specified, the agent runs the OpenJPA enhancer on\n+ * all classes listed in the first persistence unit as they are loaded,\n+ * and redefines all other persistent classes when they are encountered.\n+ * To disable enhancement and rely solely on the redefinition logic, set\n+ * the RuntimeEnhancement flag to false. To disable redefinition and rely\n+ * solely on pre-deployment or runtime enhancement, set the\n+ * RuntimeRedefinition flag to false.\n+ * </p>\n+ *\n+ * <p><code>java -javaagent:openjpa.jar=RuntimeEnhancement=false</code></p>\n  *\n  * @author Abe White\n+ * @author Patrick Linskey\n  */\n public class PCEnhancerAgent {\n \n     public static void premain(String args, Instrumentation inst) {\n-        OpenJPAConfiguration conf = new OpenJPAConfigurationImpl();\n         Options opts = Configurations.parseProperties(args);\n+\n+        if (opts.getBooleanProperty(\n+            \"RuntimeEnhancement\", \"runtimeEnhancement\", true))\n+            registerRuntimeEnhancer(inst, opts);\n+\n+        if (opts.getBooleanProperty(\"RuntimeRedefinition\",\n+            \"runtimeRedefinition\", true)) {\n+            InstrumentationFactory.setInstrumentation(inst);\n+        } else {\n+            InstrumentationFactory.setDynamicallyInstallAgent(false);\n+        }\n+    }\n+\n+    private static void registerRuntimeEnhancer(Instrumentation inst,\n+        Options opts) {\n+        OpenJPAConfiguration conf = new OpenJPAConfigurationImpl();\n         Configurations.populateConfiguration(conf, opts);\n         // don't allow connections\n         conf.setConnectionUserName(null);"},{"sha":"f3be4a540ad4c9739e7306f99cd18ee6afe215e7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,31 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+/**\r\n+ * Instances of this interface can convert a positional index for a\r\n+ * {@link FieldMetaData} that uses property access into the underlying\r\n+ * field name. Instances of {@link DynamicPersistenceCapable} for types\r\n+ * that use property access will implement this interface.\r\n+ *\r\n+ * @since 1.0.0\r\n+ */\r\n+public interface AttributeTranslator {\r\n+    public String pcAttributeIndexToFieldName(int i);\r\n+}\r"},{"sha":"ed413dcd29460a6923992b6cc315b9be15270f14","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPCHelper.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPCHelper.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPCHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPCHelper.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,30 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+/**\r\n+ * Helper methods for dynamically-redefined managed types.\r\n+ *\r\n+ * @since 1.0.0\r\n+ */\r\n+public class DynamicPCHelper {\r\n+    public static boolean isDetached(Object o) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+}\r"},{"sha":"04516f04797c67347c12a9b0644c4d412f566cf1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,28 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+/**\r\n+ * Instances that implement this marker interface are dynamically-generated\r\n+ * subtypes of managed types that were loaded before being enhanced.\r\n+ *\r\n+ * @since 1.0.0\r\n+ */\r\n+public interface DynamicPersistenceCapable {\r\n+}\r"},{"sha":"1934f15390de20ac7b0d8f4ece8a99f3465dee02","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,28 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+/**\r\n+ * Instances of this interface can provide an underlying instance.\r\n+ *\r\n+ * @since 1.0.0\r\n+ */\r\n+public interface ManagedInstanceProvider {\r\n+    public Object getManagedInstance();\r\n+}\r"},{"sha":"45df3ee3c58ee739693a602a5ef12565c07c9c97","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","status":"modified","additions":788,"deletions":176,"changes":964,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -27,6 +27,7 @@\n import java.io.ObjectOutputStream;\n import java.io.ObjectStreamClass;\n import java.io.Serializable;\n+import java.io.ObjectStreamException;\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n@@ -78,6 +79,7 @@\n import org.apache.openjpa.util.StringId;\n import org.apache.openjpa.util.OpenJPAException;\n import org.apache.openjpa.util.UserException;\n+import org.apache.openjpa.util.ImplHelper;\n import serp.bytecode.BCClass;\n import serp.bytecode.BCField;\n import serp.bytecode.BCMethod;\n@@ -93,7 +95,9 @@\n import serp.bytecode.MethodInstruction;\n import serp.bytecode.Project;\n import serp.bytecode.TableSwitchInstruction;\n+import serp.bytecode.ClassInstruction;\n import serp.util.Numbers;\n+import serp.util.Strings;\n \n /**\n  * Bytecode enhancer used to enhance persistent classes from metadata. The\n@@ -129,10 +133,13 @@\n \n     private static final Localizer _loc = Localizer.forPackage\n         (PCEnhancer.class);\n+    private static final String REDEFINED_ATTRIBUTE\n+        = PCEnhancer.class.getName() + \"#redefined-type\";\n+    \n     private static final AuxiliaryEnhancer[] _auxEnhancers;\n     static {\n         Class[] classes = Services.getImplementorClasses(\n-            AuxiliaryEnhancer.class, \n+            AuxiliaryEnhancer.class,\n             (ClassLoader) AccessController.doPrivileged(\n                 J2DoPrivHelper.getClassLoaderAction(AuxiliaryEnhancer.class)));\n         List auxEnhancers = new ArrayList(classes.length);\n@@ -148,17 +155,25 @@\n             (new AuxiliaryEnhancer[auxEnhancers.size()]);\n     }\n \n-    private final BCClass _pc;\n+    private BCClass _pc;\n+    private final BCClass _managedType;\n     private final MetaDataRepository _repos;\n     private final ClassMetaData _meta;\n     private final Log _log;\n     private Collection _oids = null;\n     private boolean _defCons = true;\n+    private boolean _redefine = false;\n+    private boolean _subclass = false;\n     private boolean _fail = false;\n+    private Set _violations = null;\n     private File _dir = null;\n     private BytecodeWriter _writer = null;\n-    private Map _backingFields = null;\n-    private Set _violations = null;\n+    private Map _backingFields = null; // map of set / get names => field names\n+    private Map _attrsToFields = null; // map of attr names => field names\n+    private Map _fieldsToAttrs = null; // map of field names => attr names\n+    private boolean _isAlreadyRedefined = false;\n+    private boolean _isAlreadySubclassed = false;\n+    private boolean _bcsConfigured = false;\n \n     /**\n      * Constructor. Supply configuration and type to enhance.\n@@ -191,7 +206,7 @@ public PCEnhancer(OpenJPAConfiguration conf, ClassMetaData type) {\n      */\n     public PCEnhancer(OpenJPAConfiguration conf, BCClass type,\n         MetaDataRepository repos) {\n-        this(conf, type, repos, (ClassLoader) null);\n+        this(conf, type, repos, null);\n     }\n \n     /**\n@@ -210,7 +225,9 @@ public PCEnhancer(OpenJPAConfiguration conf, BCClass type,\n      */\n     public PCEnhancer(OpenJPAConfiguration conf, BCClass type,\n         MetaDataRepository repos, ClassLoader loader) {\n+        _managedType = type;\n         _pc = type;\n+\n         _log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\n \n         if (repos == null) {\n@@ -221,24 +238,37 @@ public PCEnhancer(OpenJPAConfiguration conf, BCClass type,\n         _meta = _repos.getMetaData(type.getType(), loader, false);\n     }\n \n+    static String toPCSubclassName(Class cls) {\n+        return Strings.getPackageName(PCEnhancer.class) + \".\"\n+            + cls.getName().replace('.', '$') + \"$pcsubclass\";\n+    }\n+\n     /**\n      * Constructor. Supply configuration, type, and metadata.\n      */\n     public PCEnhancer(OpenJPAConfiguration conf, BCClass type,\n         ClassMetaData meta) {\n-        _pc = type;\n-        _log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\n-        _repos = meta.getRepository();\n-        _meta = meta;\n+        this(conf, type, meta.getRepository());\n     }\n \n     /**\n-     * Return the bytecode representation of the class being manipulated.\n+     * Return the bytecode representation of the persistence-capable class\n+     * being manipulated.\n      */\n-    public BCClass getBytecode() {\n+    public BCClass getPCBytecode() {\n         return _pc;\n     }\n \n+    /**\n+     * Return the bytecode representation of the managed class being\n+     * manipulated. This is usually the same as {@link #getPCBytecode},\n+     * except when running the enhancer to redefine and subclass\n+     * existing persistent types.\n+     */\n+    public BCClass getManagedTypeBytecode() {\n+        return _managedType;\n+    }\n+\n     /**\n      * Return the metadata for the class being manipulated, or null if not\n      * a persistent type.\n@@ -267,6 +297,68 @@ public void setAddDefaultConstructor(boolean addDefaultConstructor) {\n         _defCons = addDefaultConstructor;\n     }\n \n+    /**\n+     * Whether the enhancer should mutate its arguments, or just run validation\n+     * and optional subclassing logic on them. Usually used in conjunction with\n+     * <code>setCreateSubclass(true)</code>.\n+     *\n+     * @since 1.0.0\n+     */\n+    public boolean getRedefine() {\n+        return _redefine;\n+    }\n+\n+    /**\n+     * Whether the enhancer should mutate its arguments, or just run validation\n+     * and optional subclassing logic on them. Usually used in conjunction with\n+     * <code>setCreateSubclass(true)</code>.\n+     *\n+     * @since 1.0.0\n+     */\n+    public void setRedefine(boolean redefine) {\n+        _redefine = redefine;\n+    }\n+\n+    /**\n+     * Whether the type that this instance is enhancing has already been\n+     * redefined.\n+     *\n+     * @since 1.0.0\n+     */\n+    public boolean isAlreadyRedefined() {\n+        return _isAlreadyRedefined;\n+    }\n+\n+    /**\n+     * Whether the type that this instance is enhancing has already been\n+     * subclassed in this instance's environment classloader.\n+     *\n+     * @since 1.0.0\n+     */\n+    public boolean isAlreadySubclassed() {\n+        return _isAlreadySubclassed;\n+    }\n+\n+    /**\n+     * Whether the enhancer should make its arguments persistence-capable,\n+     * or generate a persistence-capable subclass.\n+     *\n+     * @since 1.0.0\n+     */\n+    public boolean getCreateSubclass() {\n+        return _subclass;\n+    }\n+\n+    /**\n+     * Whether the enhancer should make its arguments persistence-capable,\n+     * or generate a persistence-capable subclass.\n+     *\n+     * @since 1.0.0\n+     */\n+    public void setCreateSubclass(boolean subclass) {\n+        _subclass = subclass;\n+    }\n+\n     /**\n      * Whether to fail if the persistent type uses property access and\n      * bytecode analysis shows that it may be violating OpenJPA's property\n@@ -324,33 +416,37 @@ public void setBytecodeWriter(BytecodeWriter writer) {\n      */\n     public int run() {\n         if (_log.isTraceEnabled())\n-            _log.trace(_loc.get(\"enhance-start\", _pc.getType()));\n+            _log.trace(_loc.get(\"enhance-start\", _managedType.getType()));\n \n         try {\n             // if managed interface, skip\n-            if (_pc.isInterface())\n+            if (_managedType.isInterface())\n                 return ENHANCE_INTERFACE;\n \n             // check if already enhanced\n-            Class[] interfaces = _pc.getDeclaredInterfaceTypes();\n+            Class[] interfaces = _managedType.getDeclaredInterfaceTypes();\n             for (int i = 0; i < interfaces.length; i++) {\n                 if (interfaces[i].getName().equals(PCTYPE.getName())) {\n                     if (_log.isTraceEnabled())\n-                        _log.trace(_loc.get(\"pc-type\", _pc.getType()));\n+                        _log.trace(_loc.get(\"pc-type\", _managedType.getType()));\n                     return ENHANCE_NONE;\n                 }\n             }\n \n+            configureBCs();\n+\n             // validate properties before replacing field access so that\n             // we build up a record of backing fields, etc\n             if (_meta != null\n-                && _meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY)\n+                && _meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\n                 validateProperties();\n+                if (getCreateSubclass())\n+                    addAttributeTranslation();\n+            }\n             replaceAndValidateFieldAccess();\n             processViolations();\n \n             if (_meta != null) {\n-                int ret = ENHANCE_PC;\n                 enhanceClass();\n                 addFields();\n                 addStaticInitializer();\n@@ -360,11 +456,11 @@ public int run() {\n                 addSerializationCode();\n                 addCloningCode();\n                 runAuxiliaryEnhancers();\n-                return ret;\n+                return ENHANCE_PC;\n             }\n \n             if (_log.isWarnEnabled())\n-                _log.warn(_loc.get(\"pers-aware\", _pc.getType()));\n+                _log.warn(_loc.get(\"pers-aware\", _managedType.getType()));\n             return ENHANCE_AWARE;\n         } catch (OpenJPAException ke) {\n             throw ke;\n@@ -373,11 +469,44 @@ public int run() {\n         }\n     }\n \n+    private void configureBCs() {\n+        if (!_bcsConfigured) {\n+            if (getRedefine()) {\n+                if (_managedType.getAttribute(REDEFINED_ATTRIBUTE) == null)\n+                    _managedType.addAttribute(REDEFINED_ATTRIBUTE);\n+                else\n+                    _isAlreadyRedefined = true;\n+            }\n+\n+            if (getCreateSubclass()) {\n+                PCSubclassValidator val = new PCSubclassValidator(\n+                    _meta, _managedType, _log, _fail);\n+                val.assertCanSubclass();\n+\n+                _pc = _managedType.getProject().loadClass(\n+                    toPCSubclassName(_managedType.getType()));\n+                if (_pc.getSuperclassBC() != _managedType) {\n+                    _pc.setSuperclass(_managedType);\n+                    _pc.setAbstract(_managedType.isAbstract());\n+                    _pc.declareInterface(DynamicPersistenceCapable.class);\n+                } else {\n+                    _isAlreadySubclassed = true;\n+                }\n+            } else {\n+                _pc = _managedType;\n+            }\n+\n+            _bcsConfigured = true;\n+        }\n+    }\n+\n     /**\n      * Write the generated bytecode.\n      */\n     public void record()\n         throws IOException {\n+        if (_managedType != _pc && getRedefine())\n+            record(_managedType);\n         record(_pc);\n         if (_oids != null)\n             for (Iterator itr = _oids.iterator(); itr.hasNext();)\n@@ -405,9 +534,13 @@ else if (_dir == null)\n      * property's backing field.\n      */\n     private void validateProperties() {\n-        FieldMetaData[] fmds = _meta.getDeclaredFields();\n+        FieldMetaData[] fmds;\n+        if (getCreateSubclass())\n+            fmds = _meta.getFields();\n+        else\n+            fmds = _meta.getDeclaredFields();\n         Method meth;\n-        BCMethod getter, setter = null;\n+        BCMethod getter, setter;\n         BCField returned, assigned = null;\n         for (int i = 0; i < fmds.length; i++) {\n             if (!(fmds[i].getBackingMember() instanceof Method)) {\n@@ -418,30 +551,30 @@ private void validateProperties() {\n             }\n \n             meth = (Method) fmds[i].getBackingMember();\n-            getter = _pc.getDeclaredMethod(meth.getName(),\n+            // ##### this will fail if we override and don't call super.\n+            BCClass declaringType = _managedType.getProject()\n+                .loadClass(fmds[i].getDeclaringType());\n+            getter = declaringType.getDeclaredMethod(meth.getName(),\n                 meth.getParameterTypes());\n             if (getter == null) {\n                 addViolation(\"property-no-getter\", new Object[]{ fmds[i] },\n                     true);\n                 continue;\n             }\n             returned = getReturnedField(getter);\n-            if (returned != null) {\n-                if (_backingFields == null)\n-                    _backingFields = new HashMap();\n-                _backingFields.put(getter.getName(), returned.getName());\n-            }\n+            if (returned != null)\n+                registerBackingFieldInfo(fmds[i], getter, returned);\n \n-            setter = _pc.getDeclaredMethod(getSetterName(fmds[i]),\n+            setter = declaringType.getDeclaredMethod(getSetterName(fmds[i]),\n                 new Class[]{ fmds[i].getDeclaredType() });\n             if (setter == null) {\n                 if (returned == null) {\n                     addViolation(\"property-no-setter\",\n                         new Object[]{ fmds[i] }, true);\n                     continue;\n-                } else {\n+                } else if (!getRedefine()) {\n                     // create synthetic setter\n-                    setter = _pc.declareMethod(getSetterName(fmds[i]),\n+                    setter = _managedType.declareMethod(getSetterName(fmds[i]),\n                         void.class, new Class[]{ fmds[i].getDeclaredType() });\n                     setter.makePrivate();\n                     Code code = setter.getCode(true);\n@@ -458,11 +591,8 @@ private void validateProperties() {\n                 assigned = getAssignedField(setter);\n \n             if (assigned != null) {\n-                if (_backingFields == null)\n-                    _backingFields = new HashMap();\n-\n                 if (setter != null)\n-                    _backingFields.put(setter.getName(), assigned.getName());\n+                    registerBackingFieldInfo(fmds[i], setter, assigned);\n \n                 if (assigned != returned)\n                     addViolation(\"property-setter-getter-mismatch\", new Object[]\n@@ -472,13 +602,66 @@ private void validateProperties() {\n         }\n     }\n \n+    private void registerBackingFieldInfo(FieldMetaData fmd, BCMethod method,\n+        BCField field) {\n+        if (_backingFields == null)\n+            _backingFields = new HashMap();\n+        _backingFields.put(method.getName(), field.getName());\n+\n+        if (_attrsToFields == null)\n+            _attrsToFields = new HashMap();\n+        _attrsToFields.put(fmd.getName(), field.getName());\n+\n+        if (_fieldsToAttrs == null)\n+            _fieldsToAttrs = new HashMap();\n+        _fieldsToAttrs.put(field.getName(), fmd.getName());\n+    }\n+\n+    private void addAttributeTranslation() {\n+        _pc.declareInterface(AttributeTranslator.class);\n+        BCMethod method = _pc.declareMethod(PRE + \"AttributeIndexToFieldName\",\n+            String.class, new Class[] { int.class });\n+        method.makePublic();\n+        Code code = method.getCode(true);\n+\n+        FieldMetaData[] fmds = _meta.getFields();\n+\n+        // switch (val)\n+        code.iload().setParam(0);\n+        TableSwitchInstruction tabins = code.tableswitch();\n+        tabins.setLow(0);\n+        tabins.setHigh(fmds.length - 1);\n+\n+        // case i:\n+        //     return <_attrsToFields.get(fmds[i].getName())>\n+        for (int i = 0; i < fmds.length; i++) {\n+            tabins.addTarget(code.constant().setValue(\n+                _attrsToFields.get(fmds[i].getName())));\n+            code.areturn();\n+        }\n+\n+        // default: throw new IllegalArgumentException ()\n+        tabins.setDefaultTarget(throwException\n+            (code, IllegalArgumentException.class));\n+\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n+    }\n+\n     /**\n      * Return the name of the setter method for the given field.\n      */\n     private static String getSetterName(FieldMetaData fmd) {\n         return \"set\" + StringUtils.capitalize(fmd.getName());\n     }\n \n+    /**\n+     * Return the name of the getter method for the given field.\n+     */\n+    private static String getGetterName(FieldMetaData fmd) {\n+        return \"get\" + StringUtils.capitalize(fmd.getName());\n+    }\n+\n     /**\n      * Return the field returned by the given method, or null if none.\n      * Package-protected and static for testing.\n@@ -505,8 +688,8 @@ static BCField getAssignedField(BCMethod meth) {\n      */\n     private static BCField findField(BCMethod meth, Instruction template,\n         boolean findAccessed) {\n-        // ignore any static methods. OpenJPA only currently supports non-static\n-        // setters and getters\n+        // ignore any static methods. OpenJPA only currently supports\n+        // non-static setters and getters\n         if (meth.isStatic())\n             return null;\n \n@@ -516,21 +699,29 @@ private static BCField findField(BCMethod meth, Instruction template,\n         code.beforeFirst();\n \n         BCField field = null, cur;\n-        Instruction templateIns, prevIns, twoPrevIns;\n+        Instruction templateIns, prevIns, earlierIns;\n+        int backupCount = 3;\n         while (code.searchForward(template)) {\n             templateIns = code.previous();\n             if (!code.hasPrevious())\n                 return null;\n             prevIns = code.previous();\n+\n+            if (prevIns instanceof ClassInstruction\n+                && code.hasPrevious()) {\n+                prevIns = code.previous();\n+                backupCount++;\n+            }\n+\n             if (!code.hasPrevious())\n                 return null;\n-            twoPrevIns = code.previous();\n+            earlierIns = code.previous();\n \n             // if the opcode two before the template was an aload_0, check\n             // against the middle instruction based on what type of find\n             // we're doing\n-            if (!(twoPrevIns instanceof LoadInstruction)\n-                || !((LoadInstruction) twoPrevIns).isThis())\n+            if (!(earlierIns instanceof LoadInstruction)\n+                || !((LoadInstruction) earlierIns).isThis())\n                 return null;\n \n             // if the middle instruction was a getfield, then it's the\n@@ -550,9 +741,10 @@ else if (findAccessed && prevIns instanceof LoadInstruction\n             field = cur;\n \n             // ready for next search iteration\n-            code.next();\n-            code.next();\n-            code.next();\n+            while (backupCount > 0) {\n+                code.next();\n+                backupCount--;\n+            }\n         }\n         return field;\n     }\n@@ -594,7 +786,7 @@ private void processViolations() {\n      * pcGet/pcSet method. Note that this includes access to fields\n      * owned by PersistenceCapable classes other than this one.\n      */\n-    private void replaceAndValidateFieldAccess() {\n+    private void replaceAndValidateFieldAccess() throws NoSuchMethodException {\n         // create template putfield/getfield instructions to search for\n         Code template = (Code) AccessController.doPrivileged(\n             J2DoPrivHelper.newCodeAction());\n@@ -604,7 +796,7 @@ private void replaceAndValidateFieldAccess() {\n \n         // look through all methods; this is done before any methods are added\n         // so we don't need to worry about excluding synthetic methods.\n-        BCMethod[] methods = _pc.getDeclaredMethods();\n+        BCMethod[] methods = _managedType.getDeclaredMethods();\n         Code code;\n         for (int i = 0; i < methods.length; i++) {\n             code = methods[i].getCode(false);\n@@ -630,7 +822,7 @@ private void replaceAndValidateFieldAccess() {\n      * @param stat template invokestatic instruction to replace with\n      */\n     private void replaceAndValidateFieldAccess(Code code, Instruction ins,\n-        boolean get, Instruction stat) {\n+        boolean get, Instruction stat) throws NoSuchMethodException {\n         code.beforeFirst();\n \n         FieldInstruction fi;\n@@ -642,16 +834,15 @@ private void replaceAndValidateFieldAccess(Code code, Instruction ins,\n             fi = (FieldInstruction) code.previous();\n             name = fi.getFieldName();\n             typeName = fi.getFieldTypeName();\n-            owner = getPersistenceCapableOwner(name,\n-                fi.getFieldDeclarerType());\n+            owner = getPersistenceCapableOwner(name, fi.getFieldDeclarerType());\n \n             if (owner != null\n                 && owner.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\n                 // if we're directly accessing a field in another class\n                 // hierarchy that uses property access, something is wrong\n                 if (owner != _meta && owner.getDeclaredField(name) != null &&\n-                    _meta != null && !owner.getDescribedType().\n-                    isAssignableFrom(_meta.getDescribedType()))\n+                    _meta != null && !owner.getDescribedType()\n+                        .isAssignableFrom(_meta.getDescribedType()))\n                     throw new UserException(_loc.get(\"property-field-access\",\n                         new Object[]{ _meta, owner, name,\n                             code.getMethod().getName() }));\n@@ -661,34 +852,99 @@ private void replaceAndValidateFieldAccess(Code code, Instruction ins,\n                 if (isBackingFieldOfAnotherProperty(name, code))\n                     addViolation(\"property-field-access\", new Object[]{ _meta,\n                         owner, name, code.getMethod().getName() }, false);\n-\n-                code.next();\n-                continue;\n             }\n \n-            // not persistent field?\n-            if (owner == null || owner.getDeclaredField(name) == null) {\n+            if (owner == null ||\n+                owner.getDeclaredField(fromBackingFieldName(name)) == null) {\n+                // not persistent field?\n                 code.next();\n                 continue;\n-            }\n+            } else if (!getRedefine() && !getCreateSubclass()\n+                && owner.getAccessType() == ClassMetaData.ACCESS_FIELD) {\n+                // replace the instruction with a call to the generated access\n+                // method\n+                mi = (MethodInstruction) code.set(stat);\n+\n+                // invoke the proper access method, whether getter or setter\n+                String prefix = (get) ? PRE + \"Get\" : PRE + \"Set\";\n+                methodName = prefix + name;\n+                if (get) {\n+                    mi.setMethod(getType(owner).getName(),\n+                        methodName, typeName, new String[]\n+                        { getType(owner).getName() });\n+                } else {\n+                    mi.setMethod(getType(owner).getName(),\n+                        methodName, \"void\", new String[]\n+                        { getType(owner).getName(), typeName });\n+                }\n+                code.next();\n+            } else if (getRedefine()) {\n+                name = fromBackingFieldName(name);\n+                if (get) {\n+                    addNotifyAccess(code, owner.getField(name));\n+                    code.next();\n+                } else {\n+                    // insert the set operations after the field mutation, but\n+                    // first load the old value for use in the\n+                    // StateManager.settingXXX method.\n+                    loadManagedInstance(code, false);\n+                    code.getfield().setField(fi.getField());\n+                    int val = code.getNextLocalsIndex();\n+                    code.xstore().setLocal(val).setType(fi.getFieldType());\n \n-            // replace the instruction with a call to the generated access\n-            // method\n-            mi = (MethodInstruction) code.set(stat);\n-\n-            // invoke the proper access method, whether getter or setter\n-            String prefix = (get) ? PRE + \"Get\" : PRE + \"Set\";\n-            methodName = prefix + name;\n-            if (get) {\n-                mi.setMethod(getType(owner).getName(),\n-                    methodName, typeName, new String[]\n-                    { getType(owner).getName() });\n+                    // move past the putfield\n+                    code.next();\n+                    addNotifyMutation(code, owner.getField(name), val, -1);\n+                }\n             } else {\n-                mi.setMethod(getType(owner).getName(),\n-                    methodName, \"void\", new String[]\n-                    { getType(owner).getName(), typeName });\n+                code.next();\n             }\n+            code.calculateMaxLocals();\n+            code.calculateMaxStack();\n+        }\n+    }\n+\n+    private void addNotifyAccess(Code code, FieldMetaData fmd) {\n+        // PCHelper.accessingField(this, <absolute-index>);\n+        code.aload().setThis();\n+        code.constant().setValue(fmd.getIndex());\n+        code.invokestatic().setMethod(RedefinitionHelper.class,\n+            \"accessingField\", void.class,\n+            new Class[] { Object.class, int.class });\n+    }\n+\n+    /**\n+     * This must be called after setting the value in the object.\n+     * \n+     * @param code\n+     * @param val the position in the local variable table where the\n+     * old value is stored\n+     * @param param the parameter position containing the new value, or\n+     * -1 if the new value is unavailable and should therefore be looked\n+     * up.\n+     * @throws NoSuchMethodException\n+     */\n+    private void addNotifyMutation(Code code, FieldMetaData fmd, int val,\n+        int param)\n+        throws NoSuchMethodException {\n+        // PCHelper.settingField(this, <absolute-index>, old, new);\n+        code.aload().setThis();\n+        code.constant().setValue(fmd.getIndex());\n+        Class type = fmd.getDeclaredType();\n+        // we only have special signatures for primitives and Strings\n+        if (!type.isPrimitive() && type != String.class)\n+            type = Object.class;\n+        code.xload().setLocal(val).setType(type);\n+        if (param == -1) {\n+            loadManagedInstance(code, false);\n+            addGetManagedValueCode(code, fmd);\n+        } else {\n+            code.xload().setParam(param).setType(type);\n         }\n+        code.invokestatic().setMethod(RedefinitionHelper.class, \"settingField\",\n+            void.class, new Class[] {\n+                Object.class, int.class, type, type\n+        });\n     }\n \n     /**\n@@ -745,7 +1001,7 @@ private void addPCMethods()\n         addProvideFieldsMethods();\n         addCopyFieldsMethod();\n \n-        if (_meta.getPCSuperclass() == null) {\n+        if (_meta.getPCSuperclass() == null || getCreateSubclass()) {\n             addStockMethods();\n             addGetVersionMethod();\n             addReplaceStateManagerMethod();\n@@ -759,8 +1015,9 @@ private void addPCMethods()\n         // a subclass with an app id hierarchy that matches the\n         // persistent class inheritance hierarchy\n         if (_meta.getIdentityType() == ClassMetaData.ID_APPLICATION\n-            && (_meta.getPCSuperclass() == null || _meta.getObjectIdType()\n-            != _meta.getPCSuperclassMetaData().getObjectIdType())) {\n+            && (_meta.getPCSuperclass() == null || getCreateSubclass() ||\n+                _meta.getObjectIdType() !=\n+                    _meta.getPCSuperclassMetaData().getObjectIdType())) {\n             addCopyKeyFieldsToObjectIdMethod(true);\n             addCopyKeyFieldsToObjectIdMethod(false);\n             addCopyKeyFieldsFromObjectIdMethod(true);\n@@ -784,10 +1041,10 @@ private void addClearFieldsMethod()\n         Code code = method.getCode(true);\n \n         // super.pcClearFields ()\n-        if (_meta.getPCSuperclass() != null) {\n+        if (_meta.getPCSuperclass() != null && !getCreateSubclass()) {\n             code.aload().setThis();\n             code.invokespecial().setMethod(getType(_meta.\n-                getPCSuperclassMetaData()), PRE + \"ClearFields\", void.class, \n+                getPCSuperclassMetaData()), PRE + \"ClearFields\", void.class,\n                 null);\n         }\n \n@@ -909,8 +1166,11 @@ private void addManagedFieldCountMethod() {\n         // return <fields> + <superclass>.pcGetManagedFieldCount ()\n         code.constant().setValue(_meta.getDeclaredFields().length);\n         if (_meta.getPCSuperclass() != null) {\n-            code.invokestatic().setMethod(getType(_meta.\n-                getPCSuperclassMetaData()).getName(),\n+            Class superClass = getType(_meta.getPCSuperclassMetaData());\n+            String superName = getCreateSubclass() ?\n+                PCEnhancer.toPCSubclassName(superClass) :\n+                superClass.getName();\n+            code.invokestatic().setMethod(superName,\n                 PRE + \"GetManagedFieldCount\", int.class.getName(), null);\n             code.iadd();\n         }\n@@ -933,7 +1193,8 @@ private void addProvideFieldsMethods()\n         int relLocal = beginSwitchMethod(PRE + \"ProvideField\", code);\n \n         // if no fields in this inst, just throw exception\n-        FieldMetaData[] fmds = _meta.getDeclaredFields();\n+        FieldMetaData[] fmds = getCreateSubclass() ? _meta.getFields()\n+            : _meta.getDeclaredFields();\n         if (fmds.length == 0)\n             throwException(code, IllegalArgumentException.class);\n         else {\n@@ -983,7 +1244,8 @@ private void addReplaceFieldsMethods()\n         int relLocal = beginSwitchMethod(PRE + \"ReplaceField\", code);\n \n         // if no fields in this inst, just throw exception\n-        FieldMetaData[] fmds = _meta.getDeclaredFields();\n+        FieldMetaData[] fmds = getCreateSubclass() ? _meta.getFields()\n+            : _meta.getDeclaredFields();\n         if (fmds.length == 0)\n             throwException(code, IllegalArgumentException.class);\n         else {\n@@ -1031,15 +1293,16 @@ private void addCopyFieldsMethod()\n         // public void pcCopyField (Object pc, int field)\n         BCMethod method = _pc.declareMethod(PRE + \"CopyField\",\n             void.class.getName(),\n-            new String[]{ _pc.getName(), int.class.getName() });\n+            new String[]{ _managedType.getName(), int.class.getName() });\n         method.makeProtected();\n         Code code = method.getCode(true);\n \n         // adds everything through the switch ()\n         int relLocal = beginSwitchMethod(PRE + \"CopyField\", code);\n \n         // if no fields in this inst, just throw exception\n-        FieldMetaData[] fmds = _meta.getDeclaredFields();\n+        FieldMetaData[] fmds = getCreateSubclass() ? _meta.getFields()\n+            : _meta.getDeclaredFields();\n         if (fmds.length == 0)\n             throwException(code, IllegalArgumentException.class);\n         else {\n@@ -1054,7 +1317,7 @@ private void addCopyFieldsMethod()\n                 // or set<field> (other.get<field>);\n                 tabins.addTarget(loadManagedInstance(code, false));\n                 code.aload().setParam(0);\n-                addGetManagedValueCode(code, fmds[i]);\n+                addGetManagedValueCode(code, fmds[i], false);\n                 addSetManagedValueCode(code, fmds[i]);\n \n                 // break;\n@@ -1085,8 +1348,14 @@ private int beginSwitchMethod(String name, Code code) {\n         boolean copy = (PRE + \"CopyField\").equals(name);\n         int fieldNumber = (copy) ? 1 : 0;\n \n-        // int rel = fieldNumber - pcInheritedFieldCount\n         int relLocal = code.getNextLocalsIndex();\n+        if (getCreateSubclass()) {\n+            code.iload().setParam(fieldNumber);\n+            code.istore().setLocal(relLocal);\n+            return relLocal;\n+        }\n+\n+        // int rel = fieldNumber - pcInheritedFieldCount\n         code.iload().setParam(fieldNumber);\n         code.getstatic().setField(INHERIT, int.class);\n         code.isub();\n@@ -1140,16 +1409,41 @@ private void addMultipleFieldsMethodVersion(BCMethod single) {\n         if (copy) {\n             fieldNumbers = 1;\n \n-            // XXX other = (XXX) pc;\n-            code.aload().setParam(0);\n-            code.checkcast().setType(_pc);\n-            inst = code.getNextLocalsIndex();\n-            code.astore().setLocal(inst);\n+            if (getCreateSubclass()) {\n+                // get the managed instance into the local variable table\n+                code.aload().setParam(0);\n+                code.invokestatic().setMethod(ImplHelper.class,\n+                    \"getManagedInstance\", Object.class,\n+                    new Class[] { Object.class });\n+                code.checkcast().setType(_managedType);\n+                inst = code.getNextLocalsIndex();\n+                code.astore().setLocal(inst);\n+\n+                // there might be a difference between the classes of 'this'\n+                // vs 'other' in this context; use the PC methods to get the SM\n+                code.aload().setParam(0);\n+                code.aload().setThis();\n+                code.getfield().setField(SM, SMTYPE);\n+                code.invokestatic().setMethod(ImplHelper.class,\n+                    \"toPersistenceCapable\", PersistenceCapable.class,\n+                    new Class[] { Object.class, Object.class });\n+                code.invokeinterface().setMethod(PersistenceCapable.class,\n+                    \"pcGetStateManager\", StateManager.class, null);\n+            } else {\n+                // XXX other = (XXX) pc;\n+                code.aload().setParam(0);\n+                code.checkcast().setType(_pc);\n+                inst = code.getNextLocalsIndex();\n+                code.astore().setLocal(inst);\n+\n+                // access the other's sm field directly\n+                code.aload().setLocal(inst);\n+                code.getfield().setField(SM, SMTYPE);\n+            }\n \n             // if (other.pcStateManager != pcStateManager)\n             //\tthrow new IllegalArgumentException\n-            code.aload().setLocal(inst);\n-            code.getfield().setField(SM, SMTYPE);\n+\n             loadManagedInstance(code, false);\n             code.getfield().setField(SM, SMTYPE);\n             JumpInstruction ifins = code.ifacmpeq();\n@@ -1206,55 +1500,55 @@ private void addStockMethods()\n             translateFromStateManagerMethod(\n                 (Method) AccessController.doPrivileged(\n                     J2DoPrivHelper.getDeclaredMethodAction(\n-                        SMTYPE, \"get\" + CONTEXTNAME, (Class[]) null)));\n+                        SMTYPE, \"get\" + CONTEXTNAME, (Class[]) null)), false);\n     \n             // pcFetchObjectId\n             translateFromStateManagerMethod(\n                 (Method) AccessController.doPrivileged(\n                     J2DoPrivHelper.getDeclaredMethodAction(\n-                        SMTYPE, \"fetchObjectId\", (Class[]) null)));\n+                        SMTYPE, \"fetchObjectId\", (Class[]) null)), false);\n     \n             // pcIsDeleted\n             translateFromStateManagerMethod(\n                 (Method) AccessController.doPrivileged(\n                     J2DoPrivHelper.getDeclaredMethodAction(\n-                        SMTYPE, \"isDeleted\", (Class[]) null)));\n+                        SMTYPE, \"isDeleted\", (Class[]) null)), false);\n     \n             // pcIsDirty\n             translateFromStateManagerMethod(\n                 (Method) AccessController.doPrivileged(\n                     J2DoPrivHelper.getDeclaredMethodAction(\n-                        SMTYPE, \"isDirty\", (Class[]) null)));\n+                        SMTYPE, \"isDirty\", (Class[]) null)), true);\n     \n             // pcIsNew\n             translateFromStateManagerMethod(\n                 (Method) AccessController.doPrivileged(\n                     J2DoPrivHelper.getDeclaredMethodAction(\n-                        SMTYPE, \"isNew\", (Class[]) null)));\n+                        SMTYPE, \"isNew\", (Class[]) null)), false);\n     \n             // pcIsPersistent\n             translateFromStateManagerMethod(\n                 (Method) AccessController.doPrivileged(\n                     J2DoPrivHelper.getDeclaredMethodAction(\n-                        SMTYPE, \"isPersistent\", (Class[]) null)));\n+                        SMTYPE, \"isPersistent\", (Class[]) null)), false);\n     \n             // pcIsTransactional\n             translateFromStateManagerMethod(\n                 (Method) AccessController.doPrivileged(\n                     J2DoPrivHelper.getDeclaredMethodAction(\n-                        SMTYPE, \"isTransactional\", (Class[]) null)));\n+                        SMTYPE, \"isTransactional\", (Class[]) null)), false);\n     \n             // pcSerializing\n             translateFromStateManagerMethod(\n                 (Method) AccessController.doPrivileged(\n                     J2DoPrivHelper.getDeclaredMethodAction(\n-                        SMTYPE, \"serializing\", (Class[]) null)));\n+                        SMTYPE, \"serializing\", (Class[]) null)), false);\n     \n             // pcDirty\n             translateFromStateManagerMethod(\n                 (Method) AccessController.doPrivileged(\n                     J2DoPrivHelper.getDeclaredMethodAction(\n-                        SMTYPE, \"dirty\", new Class[]{ String.class })));\n+                        SMTYPE, \"dirty\", new Class[]{ String.class })), false);\n     \n             // pcGetStateManager\n             BCMethod meth = _pc.declareMethod(PRE + \"GetStateManager\",\n@@ -1276,7 +1570,8 @@ private void addStockMethods()\n      * Given the StateManager method, then, this function translates it into\n      * the wrapper method that should be added to the bytecode.\n      */\n-    private void translateFromStateManagerMethod(Method m) {\n+    private void translateFromStateManagerMethod(Method m,\n+        boolean isDirtyCheckMethod) {\n         // form the name of the method by prepending 'pc' to the sm method\n         String name = PRE + StringUtils.capitalize(m.getName());\n         Class[] params = m.getParameterTypes();\n@@ -1296,9 +1591,22 @@ else if (!returnType.equals(void.class))\n             code.constant().setNull();\n         code.xreturn().setType(returnType);\n \n+        // if this is the dirty-check method and we're subclassing but not\n+        // redefining, hook into PCHelper to do the dirty check\n+        if (isDirtyCheckMethod && !getRedefine()) {\n+            // RedefinitionHelper.dirtyCheck(sm);\n+            ifins.setTarget(loadManagedInstance(code, false));\n+            code.getfield().setField(SM, SMTYPE);\n+            code.dup(); // for the return statement below\n+            code.invokestatic().setMethod(RedefinitionHelper.class, \n+                \"dirtyCheck\", void.class, new Class[] { SMTYPE });\n+        } else {\n+            ifins.setTarget(loadManagedInstance(code, false));\n+            code.getfield().setField(SM, SMTYPE);\n+        }\n+        \n         // return pcStateManager.<method> (<args>);\n-        ifins.setTarget(loadManagedInstance(code, false));\n-        code.getfield().setField(SM, SMTYPE);\n+        // managed instance loaded above in if-else block\n         for (int i = 0; i < params.length; i++)\n             code.xload().setParam(i);\n         code.invokeinterface().setMethod(m);\n@@ -1499,7 +1807,7 @@ private void addCopyKeyFieldsToObjectIdMethod(boolean fieldManager)\n         }\n \n         // call superclass method\n-        if (_meta.getPCSuperclass() != null) {\n+        if (_meta.getPCSuperclass() != null && !getCreateSubclass()) {\n             loadManagedInstance(code, false);\n             for (int i = 0; i < args.length; i++)\n                 code.aload().setParam(i);\n@@ -1537,7 +1845,8 @@ private void addCopyKeyFieldsToObjectIdMethod(boolean fieldManager)\n \n         // id.<field> = fs.fetch<type>Field (<index>); or...\n         // id.<field> = pc.<field>;\n-        FieldMetaData[] fmds = _meta.getDeclaredFields();\n+        FieldMetaData[] fmds = getCreateSubclass() ? _meta.getFields()\n+            : _meta.getDeclaredFields();\n         Class type;\n         String name;\n         Field field;\n@@ -1823,7 +2132,7 @@ private void addCopyKeyFieldsFromObjectIdMethod(boolean fieldManager)\n         Code code = method.getCode(true);\n \n         // call superclass method\n-        if (_meta.getPCSuperclass() != null) {\n+        if (_meta.getPCSuperclass() != null && !getCreateSubclass()) {\n             loadManagedInstance(code, false);\n             for (int i = 0; i < args.length; i++)\n                 code.aload().setParam(i);\n@@ -1853,7 +2162,8 @@ private void addCopyKeyFieldsFromObjectIdMethod(boolean fieldManager)\n         // fs.store<type>Field (<index>, id.<field>); or...\n         // this.<field> = id.<field>\n         // or for single field identity: id.getId ()\n-        FieldMetaData[] fmds = _meta.getDeclaredFields();\n+        FieldMetaData[] fmds = getCreateSubclass() ? _meta.getFields()\n+            : _meta.getDeclaredFields();\n         String name;\n         Class type;\n         Class unwrapped;\n@@ -1940,7 +2250,7 @@ private void addCopyKeyFieldsFromObjectIdMethod(boolean fieldManager)\n                         code.constant().setValue(name);\n                         code.constant().setValue(true);\n                         code.invokestatic().setMethod(Reflection.class,\n-                            \"findGetter\", Method.class, new Class[] { \n+                            \"findGetter\", Method.class, new Class[] {\n                             Class.class, String.class, boolean.class });\n                         code.invokestatic().setMethod\n                             (getReflectionGetterMethod(type, Method.class));\n@@ -2191,14 +2501,12 @@ else if (type.equals(String.class))\n         String name = prefix + typeName + \"Field\";\n         Class[] params = (Class[]) plist.toArray(new Class[plist.size()]);\n         \n-        Method method = null;\n         try {\n-            method = (Method) AccessController.doPrivileged(\n+            return (Method) AccessController.doPrivileged(\n                 J2DoPrivHelper.getDeclaredMethodAction(owner, name, params));\n         } catch (PrivilegedActionException pae) {\n              throw (NoSuchMethodException) pae.getException();\n         }\n-        return method;\n     }\n \n     /**\n@@ -2214,8 +2522,9 @@ private Instruction throwException(Code code, Class type) {\n     }\n \n     /**\n-     * Adds the PersistenceCapable interface to the class being enhanced, and\n-     * adds a default constructor for use by OpenJPA if it is not already present.\n+     * Adds the PersistenceCapable interface to the class being\n+     * enhanced, and adds a default constructor for use by OpenJPA\n+     * if it is not already present.\n      */\n     private void enhanceClass() {\n         // make the class implement PersistenceCapable\n@@ -2229,10 +2538,9 @@ private void enhanceClass() {\n \n         // a default constructor is required\n         if (method == null) {\n-            Class type = _pc.getType();\n+            String name = _pc.getName();\n             if (!_defCons)\n-                throw new UserException(_loc.get(\"enhance-defaultconst\",\n-                    type));\n+                throw new UserException(_loc.get(\"enhance-defaultconst\", name));\n \n             method = _pc.addDefaultConstructor();\n             String access;\n@@ -2248,8 +2556,9 @@ private void enhanceClass() {\n                 method.makeProtected();\n                 access = \"protected\";\n             }\n-            if (!_meta.getDescribedType().isInterface() && _log.isWarnEnabled())\n-                _log.warn(_loc.get(\"enhance-adddefaultconst\", type, access));\n+            if (!(_meta.getDescribedType().isInterface() || getCreateSubclass())\n+                && _log.isWarnEnabled())\n+                _log.warn(_loc.get(\"enhance-adddefaultconst\", name, access));\n         }\n     }\n \n@@ -2273,7 +2582,7 @@ private void addFields() {\n         _pc.declareField(PRE + \"FieldFlags\", byte[].class).setStatic(true);\n         _pc.declareField(SUPER, Class.class).setStatic(true);\n \n-        if (_meta.getPCSuperclass() == null) {\n+        if (_meta.getPCSuperclass() == null || getCreateSubclass()) {\n             BCField field = _pc.declareField(SM, SMTYPE);\n             field.makeProtected();\n             field.setTransient(true);\n@@ -2288,11 +2597,16 @@ private void addFields() {\n     private void addStaticInitializer() {\n         Code code = getOrCreateClassInitCode(true);\n         if (_meta.getPCSuperclass() != null) {\n-            // pcInheritedFieldCount = <superClass>.pcGetManagedFieldCount()\n-            code.invokestatic().setMethod(getType(_meta.\n-                getPCSuperclassMetaData()).getName(), \n-                PRE + \"GetManagedFieldCount\", int.class.getName(), null);\n-            code.putstatic().setField(INHERIT, int.class);\n+            if (getCreateSubclass()) {\n+                code.constant().setValue(_meta.getFields().length);\n+                code.putstatic().setField(INHERIT, int.class);\n+            } else {\n+                // pcInheritedFieldCount = <superClass>.pcGetManagedFieldCount()\n+                code.invokestatic().setMethod(getType(_meta.\n+                    getPCSuperclassMetaData()).getName(),\n+                    PRE + \"GetManagedFieldCount\", int.class.getName(), null);\n+                code.putstatic().setField(INHERIT, int.class);\n+            }\n \n             // pcPCSuperclass = <superClass>;\n             code.classconstant().setClass(getType(_meta.\n@@ -2337,7 +2651,7 @@ private void addStaticInitializer() {\n         // PCRegistry.register (cls,\n         //\tpcFieldNames, pcFieldTypes, pcFieldFlags,\n         //  pcPCSuperclass, alias, new XXX ());\n-        code.classconstant().setClass(_pc);\n+        code.classconstant().setClass(_managedType);\n         code.getstatic().setField(PRE + \"FieldNames\", String[].class);\n         code.getstatic().setField(PRE + \"FieldTypes\", Class[].class);\n         code.getstatic().setField(PRE + \"FieldFlags\", byte[].class);\n@@ -2399,6 +2713,13 @@ private void addSerializationCode() {\n             || !Serializable.class.isAssignableFrom(_meta.getDescribedType()))\n             return;\n \n+        if (getCreateSubclass()) {\n+            if (!Externalizable.class.isAssignableFrom(\n+                _meta.getDescribedType()))\n+                addSubclassSerializationCode();\n+            return;\n+        }\n+\n         // if not already present, add a serialVersionUID field; if the instance\n         // is detachable and uses detached state without a declared field,\n         // can't add a serial version UID because we'll be adding extra fields\n@@ -2462,6 +2783,43 @@ private void addSerializationCode() {\n         modifyReadObjectMethod(read, full);\n     }\n \n+    private void addSubclassSerializationCode() {\n+        // for generated subclasses, serialization must write an instance of\n+        // the superclass instead of the subclass, so that the client VM can\n+        // deserialize successfully.\n+\n+        // private Object writeReplace() throws ObjectStreamException\n+        BCMethod method = _pc.declareMethod(\"writeReplace\", Object.class, null);\n+        method.getExceptions(true).addException(ObjectStreamException.class);\n+        Code code = method.getCode(true);\n+\n+        // Object o = new <managed-type>()\n+        code.anew().setType(_managedType); // for return\n+        code.dup(); // for post-<init> work\n+        code.dup(); // for <init>\n+        code.invokespecial().setMethod(_managedType.getType(), \"<init>\",\n+            void.class, null);\n+\n+        // copy all the fields.\n+        // ##### limiting to JPA @Transient limitations\n+        FieldMetaData[] fmds = _meta.getFields();\n+        for (int i = 0; i < fmds.length; i++) {\n+            if (fmds[i].isTransient())\n+                continue;\n+            // o.<field> = this.<field> (or reflective analog)\n+            code.dup(); // for putfield\n+            code.aload().setThis(); // for getfield\n+            getfield(code, _managedType, fmds[i].getName());\n+            putfield(code, _managedType, fmds[i].getName(),\n+                fmds[i].getDeclaredType());\n+        }\n+\n+        code.areturn().setType(Object.class);\n+\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n+    }\n+\n     /**\n      * Whether the class being enhanced should externalize to a detached\n      * instance rather than serialize.\n@@ -2795,40 +3153,47 @@ private Code getOrCreateClassInitCode(boolean replaceLast) {\n      * enhanced to correctly replace the <code>pcStateManager</code> \n      * instance fields of any clone created with their default values. \n      * Also, if this class is the base PC type and does not declared \n-     * a clone method, one will be added.\n+     * a clone method, one will be added. Also, if _pc is a synthetic\n+     * subclass, create the clone() method that clears the state manager\n+     * that may have been initialized in a super's clone() method.\n      */\n     private void addCloningCode() {\n-        if (_meta.getPCSuperclass() != null)\n+        if (_meta.getPCSuperclass() != null && !getCreateSubclass())\n             return;\n \n         // add the clone method if necessary\n-        BCMethod clone = _pc.getDeclaredMethod(\"clone\", (String[]) null);\n-        String superName = _pc.getSuperclassName();\n+        BCMethod clone = _pc.getDeclaredMethod(\"clone\", \n+            (String[]) null);\n+        String superName = _managedType.getSuperclassName();\n         Code code = null;\n         if (clone == null) {\n             // add clone support for base classes\n             // which also implement cloneable\n-            if (!((Boolean) AccessController.doPrivileged(\n-                    J2DoPrivHelper.isInstanceOfAction(_pc, Cloneable.class)))\n-                    .booleanValue()\n-                || !superName.equals(Object.class.getName()))\n+            boolean isCloneable = Cloneable.class.isAssignableFrom(\n+                _managedType.getType());\n+            boolean extendsObject =\n+                superName.equals(Object.class.getName());\n+            if (!isCloneable || (!extendsObject && !getCreateSubclass()))\n                 return;\n \n-            if (_log.isTraceEnabled())\n-                _log.trace(_loc.get(\"enhance-cloneable\", _pc.getType()));\n+            if (!getCreateSubclass())\n+                if (_log.isTraceEnabled())\n+                    _log.trace(\n+                        _loc.get(\"enhance-cloneable\", _managedType.getName()));\n \n             // add clone method\n             // protected Object clone () throws CloneNotSupportedException\n             clone = _pc.declareMethod(\"clone\", Object.class, null);\n-            clone.makeProtected();\n+            if (!setVisibilityToSuperMethod(clone))\n+                clone.makeProtected();\n             clone.getExceptions(true).addException\n                 (CloneNotSupportedException.class);\n             code = clone.getCode(true);\n \n             // return super.clone ();\n             loadManagedInstance(code, false);\n-            code.invokespecial().setMethod(_pc.getSuperclassName(),\n-                \"clone\", Object.class.getName(), null);\n+            code.invokespecial().setMethod(superName, \"clone\",\n+                Object.class.getName(), null);\n             code.areturn();\n         } else {\n             // get the clone method code\n@@ -2877,13 +3242,18 @@ private void runAuxiliaryEnhancers() {\n      * Affirms if the given method be skipped.\n      * \n      * @param method method to be skipped or not\n-     * @return true if any of the auxiliary enhancers skips the given method\n+     * @return true if any of the auxiliary enhancers skips the given method,\n+     * or if the method is a constructor\n      */\n     private boolean skipEnhance(BCMethod method) {\n-    \tfor (int i = 0; i < _auxEnhancers.length; i++)\n+        if (\"<init>\".equals(method.getName()))\n+            return true;\n+        \n+        for (int i = 0; i < _auxEnhancers.length; i++)\n     \t\tif (_auxEnhancers[i].skipEnhance(method))\n     \t\t\treturn true;\n-    \treturn false;\n+        \n+        return false;\n     }\n \n     /**\n@@ -2892,11 +3262,100 @@ private boolean skipEnhance(BCMethod method) {\n      */\n     private void addAccessors()\n         throws NoSuchMethodException {\n-        FieldMetaData[] fmds = _meta.getDeclaredFields();\n+        FieldMetaData[] fmds = getCreateSubclass() ? _meta.getFields()\n+            : _meta.getDeclaredFields();\n         for (int i = 0; i < fmds.length; i++) {\n-            addGetMethod(i, fmds[i]);\n-            addSetMethod(i, fmds[i]);\n+            if (getCreateSubclass()) {\n+                if (!getRedefine()\n+                    && _meta.getAccessType() != ClassMetaData.ACCESS_FIELD) {\n+                    addSubclassSetMethod(fmds[i]);\n+                    addSubclassGetMethod(fmds[i]);\n+                }\n+            } else {\n+                addGetMethod(i, fmds[i]);\n+                addSetMethod(i, fmds[i]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds a non-static setter that delegates to the super methods, and\n+     * performs any necessary field tracking.\n+     */\n+    private void addSubclassSetMethod(FieldMetaData fmd)\n+        throws NoSuchMethodException {\n+        Class propType = fmd.getDeclaredType();\n+        String setterName = getSetterName(fmd);\n+        BCMethod setter = _pc.declareMethod(setterName, void.class,\n+            new Class[] { propType });\n+        setVisibilityToSuperMethod(setter);\n+        Code code = setter.getCode(true);\n+\n+        // not necessary if we're already tracking access via redefinition\n+        if (!getRedefine()) {\n+            // get the orig value onto stack\n+            code.aload().setThis();\n+            addGetManagedValueCode(code, fmd);\n+            int val = code.getNextLocalsIndex();\n+            code.xstore().setLocal(val).setType(fmd.getDeclaredType());\n+            addNotifyMutation(code, fmd, val, 0);\n         }\n+\n+        // ##### test case: B extends A. Methods defined in A. What\n+        // ##### happens?\n+        // super.setXXX(...)\n+        code.aload().setThis();\n+        code.xload().setParam(0).setType(propType);\n+        code.invokespecial().setMethod(_managedType.getType(),\n+            setterName, void.class, new Class[] { propType });\n+\n+        code.vreturn();\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n+    }\n+\n+    private boolean setVisibilityToSuperMethod(BCMethod method) {\n+        BCMethod superMeth = _managedType.getMethods(method.getName(),\n+            method.getParamTypes())[0];\n+        if (superMeth.isPrivate()) {\n+            method.makePrivate();\n+            return true;\n+        } else if (superMeth.isPackage()) {\n+            method.makePackage();\n+            return true;\n+        } else if (superMeth.isProtected()) {\n+            method.makeProtected();\n+            return true;\n+        } else if (superMeth.isPublic()) {\n+            method.makePublic();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Adds a non-static getter that delegates to the super methods, and\n+     * performs any necessary field tracking.\n+     */\n+    private void addSubclassGetMethod(FieldMetaData fmd) {\n+        String methName = getGetterName(fmd);\n+        BCMethod getter = _pc.declareMethod(methName, fmd.getType(), null);\n+        setVisibilityToSuperMethod(getter);\n+        getter.makePublic();\n+        Code code = getter.getCode(true);\n+\n+        // if we're not already tracking field access via reflection, then we\n+        // must make the getter hook in lazy loading before accessing the super\n+        // method.\n+        if (!getRedefine())\n+            addNotifyAccess(code, fmd);\n+\n+        code.aload().setThis();\n+        code.invokespecial().setMethod(_managedType.getType(), methName,\n+            fmd.getType(), null);\n+        code.xreturn().setType(fmd.getType());\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n     }\n \n     /**\n@@ -3017,7 +3476,7 @@ private void addAttachDetachCode()\n \n         // if parent not detachable, we need to add the detach state fields and\n         // accessor methods\n-        if (_meta.getPCSuperclass() == null\n+        if (_meta.getPCSuperclass() == null || getCreateSubclass()\n             || parentDetachable != _meta.isDetachable()) {\n             addIsDetachedMethod();\n             addDetachedStateMethods(_meta.usesDetachedState()\n@@ -3068,7 +3527,8 @@ private void addDetachedStateMethods(boolean impl) {\n         if (impl) {\n             // return pcDetachedState;\n             loadManagedInstance(code, false);\n-            code.getfield().setField(declarer, name, Object.class.getName());\n+            getfield(code, _managedType.getProject().loadClass(declarer),\n+                name);\n         } else\n             code.constant().setNull();\n         code.areturn();\n@@ -3084,14 +3544,128 @@ private void addDetachedStateMethods(boolean impl) {\n             // pcDetachedState = state;\n             loadManagedInstance(code, false);\n             code.aload().setParam(0);\n-            code.putfield().setField(declarer, name,\n-                Object.class.getName());\n+            putfield(code, _managedType.getProject().loadClass(declarer),\n+                name, Object.class);\n         }\n         code.vreturn();\n         code.calculateMaxStack();\n         code.calculateMaxLocals();\n     }\n \n+    /**\n+     * Adds to <code>code</code> the instructions to get field\n+     * <code>attrName</code> declared in type <code>declarer</code>\n+     * onto the top of the stack.\n+     *\n+     * The instance to access must already be on the top of the\n+     * stack when this is invoked.\n+     */\n+    private void getfield(Code code, BCClass declarer, String attrName) {\n+        if (declarer == null)\n+            declarer = _managedType;\n+\n+        // first, see if we can convert the attribute name to a field name\n+        String fieldName = toBackingFieldName(attrName);\n+\n+        // next, find the field in the managed type.\n+        BCField[] fields = _managedType.getFields(fieldName);\n+        BCField field = null;\n+        for (int i = 0; i < fields.length; i++) {\n+            field = fields[i];\n+            // if we reach a field declared in this type, then this is the\n+            // most-masking field, and is the one that we want.\n+            // ##### probably should walk up the hierarchy, or check that\n+            // ##### serp does that.\n+            if (fields[i].getDeclarer() == declarer) {\n+                break;\n+            }\n+        }\n+\n+        if (getCreateSubclass() && code.getMethod().getDeclarer() == _pc\n+            && (field == null || !field.isPublic())) {\n+            // we're creating the subclass, not redefining the user type.\n+\n+            // Reflection.getXXX(this, Reflection.findField(...));\n+            code.classconstant().setClass(declarer);\n+            code.constant().setValue(fieldName);\n+            code.constant().setValue(true);\n+            code.invokestatic().setMethod(Reflection.class,\n+                \"findField\", Field.class, new Class[] {\n+                Class.class, String.class, boolean.class });\n+            Class type = _meta.getField(attrName).getDeclaredType();\n+            try {\n+                code.invokestatic().setMethod(\n+                    getReflectionGetterMethod(type, Field.class));\n+            } catch (NoSuchMethodException e) {\n+                // should never happen\n+                throw new InternalException(e);\n+            }\n+            if (!type.isPrimitive() && type != Object.class)\n+                code.checkcast().setType(type);\n+        } else {\n+            code.getfield().setField(declarer.getName(), fieldName,\n+                field.getType().getName());\n+        }\n+    }\n+\n+    /**\n+     * Adds to <code>code</code> the instructions to set field\n+     * <code>attrName</code> declared in type <code>declarer</code>\n+     * to the value of type <code>fieldType</code> on the top of the stack.\n+     *\n+     * When this method is invoked, the value to load must\n+     * already be on the top of the stack in <code>code</code>,\n+     * and the instance to load into must be second.\n+     */\n+    private void putfield(Code code, BCClass declarer, String attrName,\n+        Class fieldType) {\n+        if (declarer == null)\n+            declarer = _managedType;\n+\n+        String fieldName = toBackingFieldName(attrName);\n+\n+        if (getRedefine() || getCreateSubclass()) {\n+            // Reflection.set(this, Reflection.findField(...), value);\n+            code.classconstant().setClass(declarer);\n+            code.constant().setValue(fieldName);\n+            code.constant().setValue(true);\n+            code.invokestatic().setMethod(Reflection.class,\n+                \"findField\", Field.class, new Class[] {\n+                Class.class, String.class, boolean.class });\n+            code.invokestatic().setMethod(Reflection.class, \"set\",\n+                void.class,\n+                new Class[] {\n+                    Object.class,\n+                    fieldType.isPrimitive() ? fieldType : Object.class, \n+                    Field.class });\n+        } else {\n+            code.putfield()\n+                .setField(declarer.getName(), fieldName, fieldType.getName());\n+        }\n+    }\n+\n+    /**\n+     * If using property access, see if there is a different backing field\n+     * name for the persistent attribute <code>name</code>.\n+     */\n+    private String toBackingFieldName(String name) {\n+        if (_meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY\n+            && _attrsToFields.containsKey(name))\n+            name = (String) _attrsToFields.get(name);\n+        return name;\n+    }\n+\n+    /**\n+     * If using property access, see if there is a different persistent\n+     * attribute name for the backing field <code>name</code>.\n+     */\n+    private String fromBackingFieldName(String name) {\n+        if (_meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY\n+            && _fieldsToAttrs.containsKey(name))\n+            name = (String) _fieldsToAttrs.get(name);\n+        return name;\n+    }\n+\n     /**\n      * Implement the externalizable interface to detach on serialize.\n      */\n@@ -3115,17 +3689,17 @@ private void addDetachExternalize(boolean parentDetachable,\n         // serialization methods\n         Class[] input = new Class[]{ ObjectInputStream.class };\n         Class[] output = new Class[]{ ObjectOutputStream.class };\n-        if (_pc.getDeclaredMethod(\"readObject\", input) != null\n-            || _pc.getDeclaredMethod(\"writeObject\", output) != null)\n+        if (_managedType.getDeclaredMethod(\"readObject\", input) != null\n+            || _managedType.getDeclaredMethod(\"writeObject\", output) != null)\n             throw new UserException(_loc.get(\"detach-custom-ser\", _meta));\n         input[0] = ObjectInput.class;\n         output[0] = ObjectOutput.class;\n-        if (_pc.getDeclaredMethod(\"readExternal\", input) != null\n-            || _pc.getDeclaredMethod(\"writeExternal\", output) != null)\n+        if (_managedType.getDeclaredMethod(\"readExternal\", input) != null\n+            || _managedType.getDeclaredMethod(\"writeExternal\", output) != null)\n             throw new UserException(_loc.get(\"detach-custom-extern\", _meta));\n \n         // create list of all unmanaged serializable fields\n-        BCField[] fields = _pc.getDeclaredFields();\n+        BCField[] fields = _managedType.getDeclaredFields();\n         Collection unmgd = new ArrayList(fields.length);\n         for (int i = 0; i < fields.length; i++) {\n             if (!fields[i].isTransient() && !fields[i].isStatic()\n@@ -3258,7 +3832,7 @@ private void readExternal(Code code, String fieldName, Class type,\n         if (!type.isPrimitive() && type != Object.class)\n             code.checkcast().setType(type);\n         if (fmd == null)\n-            code.putfield().setField(fieldName, type);\n+            putfield(code, null, fieldName, type);\n         else {\n             addSetManagedValueCode(code, fmd);\n             switch (fmd.getDeclaredTypeCode()) {\n@@ -3410,7 +3984,7 @@ private void writeExternal(Code code, String fieldName, Class type,\n         code.aload().setParam(0);\n         loadManagedInstance(code, false);\n         if (fmd == null)\n-            code.getfield().setField(fieldName, type);\n+            getfield(code, null, fieldName);\n         else\n             addGetManagedValueCode(code, fmd);\n         Class[] args = new Class[]{ type };\n@@ -3422,17 +3996,47 @@ else if (!type.isPrimitive())\n             void.class, args);\n     }\n \n+    private void addGetManagedValueCode(Code code, FieldMetaData fmd)\n+        throws NoSuchMethodException {\n+        addGetManagedValueCode(code, fmd, true);\n+    }\n+\n     /**\n      * Load the field value specified by <code>fmd</code> onto the stack.\n      * Before this method is called, the object that the data should be loaded\n      * from will be on the top of the stack.\n+     *\n+     * @param fromSameClass if <code>true</code>, then <code>fmd</code> is\n+     * being loaded from an instance of the same class as the current execution\n+     * context. If <code>false</code>, then the instance on the top of the stack\n+     * might be a superclass of the current execution context's 'this' instance.\n      */\n-    private void addGetManagedValueCode(Code code, FieldMetaData fmd)\n+    private void addGetManagedValueCode(Code code, FieldMetaData fmd,\n+        boolean fromSameClass)\n         throws NoSuchMethodException {\n-        if (_meta.getAccessType() == ClassMetaData.ACCESS_FIELD)\n-            code.getfield().setField(fmd.getName(), fmd.getDeclaredType());\n-        else // property\n-        {\n+        // if redefining, then we must always reflect (or access the field\n+        // directly if accessible), since the redefined methods will always\n+        // trigger method calls to StateManager, even from internal direct-\n+        // access usage. We could work around this by not redefining, and\n+        // just do a subclass approach instead. But this is not a good option,\n+        // since it would sacrifice lazy loading and efficient dirty tracking.\n+\n+        if (getRedefine()\n+            || _meta.getAccessType() == ClassMetaData.ACCESS_FIELD) {\n+            getfield(code, null, fmd.getName());\n+        } else if (getCreateSubclass()) {\n+            // property access, and we're not redefining. If we're operating\n+            // on an instance that is definitely the same type as 'this', then\n+            // call superclass method to bypass tracking. Otherwise, reflect\n+            // to both bypass tracking and avoid class verification errors.\n+            if (fromSameClass) {\n+                Method meth = (Method) fmd.getBackingMember();\n+                code.invokespecial().setMethod(meth);\n+            } else {\n+                getfield(code, null, fmd.getName());\n+            }\n+        } else {\n+            // regular enhancement + property access\n             Method meth = (Method) fmd.getBackingMember();\n             code.invokevirtual().setMethod(PRE + meth.getName(),\n                 meth.getReturnType(), meth.getParameterTypes());\n@@ -3447,11 +4051,27 @@ private void addGetManagedValueCode(Code code, FieldMetaData fmd)\n      */\n     private void addSetManagedValueCode(Code code, FieldMetaData fmd)\n         throws NoSuchMethodException {\n-        if (_meta.getAccessType() == ClassMetaData.ACCESS_FIELD)\n-            code.putfield().setField(fmd.getName(), fmd.getDeclaredType());\n-        else // property\n+        // if redefining, then we must always reflect (or access the field\n+        // directly if accessible), since the redefined methods will always\n+        // trigger method calls to StateManager, even from internal direct-\n+        // access usage. We could work around this by not redefining, and\n+        // just do a subclass approach instead. But this is not a good option,\n+        // since it would sacrifice lazy loading and efficient dirty tracking.\n+\n+        if (getRedefine()\n+            || _meta.getAccessType() == ClassMetaData.ACCESS_FIELD) {\n+            putfield(code, null, fmd.getName(), fmd.getDeclaredType());\n+        } else if (getCreateSubclass()) {\n+            // property access, and we're not redefining. invoke the\n+            // superclass method to bypass tracking.\n+            code.invokespecial().setMethod(_managedType.getType(),\n+                getSetterName(fmd), void.class,\n+                new Class[] { fmd.getDeclaredType() });\n+        } else {\n+            // regular enhancement + property access\n             code.invokevirtual().setMethod(PRE + getSetterName(fmd),\n-                void.class, new Class[]{ fmd.getDeclaredType() });\n+                void.class, new Class[] { fmd.getDeclaredType() });\n+        }\n     }\n \n     /**\n@@ -3463,20 +4083,14 @@ private int getAccessorParameterOffset() {\n \n     /**\n      * Add the {@link Instruction}s to load the instance to modify onto the\n-     * stack, and return it. If <code>userObject</code> is set,\n-     * then <code>code</code> will be accessing data in the user-visible\n-     * object (which might not be 'this' in proxying contexts),\n-     * and the load code should behave accordingly. Otherwise,\n-     * <code>code</code> will be accessing PC-contract data, which must always\n-     * be in 'this'. If <code>forAccesor</code> is set, then <code>code</code>\n-     * is in an accessor method; otherwise, it is in one of the PC-specified\n-     * methods.\n+     * stack, and return it. If <code>forStatic</code> is set, then\n+     * <code>code</code> is in an accessor method or another static method;\n+     * otherwise, it is in one of the PC-specified methods.\n      *\n      * @return the first instruction added to <code>code</code>.\n      */\n-    private Instruction loadManagedInstance(Code code,\n-        boolean forAccessor) {\n-        if (_meta.getAccessType() == ClassMetaData.ACCESS_FIELD && forAccessor)\n+    private Instruction loadManagedInstance(Code code, boolean forStatic) {\n+        if (_meta.getAccessType() == ClassMetaData.ACCESS_FIELD && forStatic)\n             return code.aload().setParam(0);\n         return code.aload().setThis();\n     }\n@@ -3554,7 +4168,6 @@ private void addGetEnhancementContractVersionMethod() {\n         code.ireturn();\n         code.calculateMaxStack();\n         code.calculateMaxLocals();\n-        return;\n     }\n \n     /**\n@@ -3699,7 +4312,6 @@ public static boolean run(OpenJPAConfiguration conf, String[] args,\n         BCClass bc;\n         PCEnhancer enhancer;\n         int status;\n-        Class cls;\n         for (Iterator itr = classes.iterator(); itr.hasNext();) {\n             Object o = itr.next();\n             if (log.isTraceEnabled())"},{"sha":"fa825746fd4de9ca83cdea430105cccf24e4c8ab","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","status":"added","additions":272,"deletions":0,"changes":272,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,272 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.lang.reflect.Modifier;\r\n+import java.lang.reflect.Constructor;\r\n+import java.lang.reflect.Method;\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.util.UserException;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.Localizer.Message;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import serp.bytecode.BCField;\r\n+import serp.bytecode.BCClass;\r\n+import serp.bytecode.BCMethod;\r\n+\r\n+/**\r\n+ *\t<p>Validates that a given type meets the JPA contract, plus a few\r\n+ *  OpenJPA-specific additions for subclassing / redefinition:\r\n+ *\r\n+ *\t<ul>\r\n+ * \t\t<li>must have an accessible no-args constructor</li>\r\n+ * \t\t<li>must be a public or protected class</li>\r\n+ * \t\t<li>must not be final</li>\r\n+ * \t\t<li>must not extend an enhanced class</li>\r\n+ *\t\t<li>all persistent data represented by accessible setter/getter\r\n+ * \t\t\tmethods (persistent properties)</li>\r\n+ * \t\t<li>if versioning is to be used, exactly one persistent property for\r\n+ * \t\t\tthe numeric version data</li> <!-- ##### is this true? -->\r\n+ *\r\n+ * \t\t<li>When using property access, the backing field for a persistent\r\n+ *          property must be:\r\n+ * \t\t\t<ul>\r\n+ * \t\t\t\t<!-- ##### JPA validation of these needs to be tested -->\r\n+ * \t\t\t\t<li>private</li>\r\n+ * \t\t\t\t<li>set only in the designated setter,\r\n+ * \t\t\t\t\tin the constructor, or in {@link Object#clone()},\r\n+ * \t\t\t\t\t<code>readObject(ObjectInputStream)</code>, or\r\n+ * \t\t\t\t\t{@link Externalizable#readExternal(ObjectInput)}.</li>\r\n+ * \t\t\t\t<li>read only in the designated getter and the\r\n+ * \t\t\t\t\tconstructor.</li>\r\n+ *\t\t\t</ul>\r\n+ * \t\t</li>\r\n+ * \t</ul>\r\n+ *\r\n+ * \t<p>If you use this technique and use the <code>new</code> keyword instead of\r\n+ * \ta OpenJPA-supplied construction routine, OpenJPA will need to do extra work\r\n+ *  with persistent-new-flushed instances, since OpenJPA cannot in this case\r\n+ *  track what happens to such an instance.</p>\r\n+ *\r\n+ * \t@since 1.0.0\r\n+ */\r\n+public class PCSubclassValidator {\r\n+\r\n+    private static final Localizer loc =\r\n+        Localizer.forPackage(PCSubclassValidator.class);\r\n+\r\n+    private final ClassMetaData meta;\r\n+    private final BCClass pc;\r\n+    private final Log log;\r\n+    private final boolean failOnContractViolations;\r\n+\r\n+    private Collection errors;\r\n+    private Collection contractViolations;\r\n+\r\n+    public PCSubclassValidator(ClassMetaData meta, BCClass bc, Log log,\r\n+        boolean enforceContractViolations) {\r\n+        this.meta = meta;\r\n+        this.pc = bc;\r\n+        this.log = log;\r\n+        this.failOnContractViolations = enforceContractViolations;\r\n+    }\r\n+\r\n+    public void assertCanSubclass() {\r\n+        Class superclass = meta.getDescribedType();\r\n+        String name = superclass.getName();\r\n+        if (superclass.isInterface())\r\n+            addError(loc.get(\"subclasser-no-ifaces\", name), meta);\r\n+        if (Modifier.isFinal(superclass.getModifiers()))\r\n+            addError(loc.get(\"subclasser-no-final-classes\", name), meta);\r\n+        if (Modifier.isPrivate(superclass.getModifiers()))\r\n+            addError(loc.get(\"subclasser-no-private-classes\", name), meta);\r\n+        if (PersistenceCapable.class.isAssignableFrom(superclass))\r\n+            addError(loc.get(\"subclasser-super-already-pc\", name), meta);\r\n+\r\n+        try {\r\n+            Constructor c = superclass.getDeclaredConstructor(new Class[0]);\r\n+            if (!(Modifier.isProtected(c.getModifiers())\r\n+                || Modifier.isPublic(c.getModifiers())))\r\n+                addError(loc.get(\"subclasser-private-ctor\", name), meta);\r\n+        }\r\n+        catch (NoSuchMethodException e) {\r\n+            addError(loc.get(\"subclasser-no-void-ctor\", name),\r\n+                meta);\r\n+        }\r\n+\r\n+        // if the BCClass we loaded is already pc and the superclass is not,\r\n+        // then we should never get here, so let's make sure that the\r\n+        // calling context is caching correctly by throwing an exception.\r\n+        if (pc.isInstanceOf(PersistenceCapable.class) &&\r\n+            !PersistenceCapable.class.isAssignableFrom(superclass))\r\n+            throw new InternalException(\r\n+                loc.get(\"subclasser-class-already-pc\", name));\r\n+\r\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY)\r\n+            checkPropertiesAreInterceptable();\r\n+\r\n+        if (errors != null && !errors.isEmpty())\r\n+            throw new UserException(errors.toString());\r\n+        else if (contractViolations != null &&\r\n+            !contractViolations.isEmpty() && log.isWarnEnabled())\r\n+            log.warn(contractViolations.toString());\r\n+    }\r\n+\r\n+    private void checkPropertiesAreInterceptable() {\r\n+        // just considers accessor methods for now.\r\n+        FieldMetaData[] fmds = meta.getFields();\r\n+        for (int i = 0; i < fmds.length; i++) {\r\n+            Method getter = (Method) fmds[i].getBackingMember();\r\n+            if (getter == null) {\r\n+                addError(loc.get(\"subclasser-no-getter\",\r\n+                    fmds[i].getName()), fmds[i]);\r\n+                continue;\r\n+            }\r\n+            BCField returnedField = checkGetterIsSubclassable(getter, fmds[i]);\r\n+\r\n+            Method setter = setterForField(fmds[i]);\r\n+            if (setter == null) {\r\n+                addError(loc.get(\"subclasser-no-setter\", fmds[i].getName()),\r\n+                    fmds[i]);\r\n+                continue;\r\n+            }\r\n+            BCField assignedField = checkSetterIsSubclassable(setter, fmds[i]);\r\n+            if (assignedField == null)\r\n+                continue;\r\n+\r\n+            if (assignedField != returnedField)\r\n+                addContractViolation(loc.get\r\n+                    (\"subclasser-setter-getter-field-mismatch\",\r\n+                        fmds[i].getName(), returnedField,assignedField),\r\n+                    fmds[i]);\r\n+\r\n+            // ### scan through all the rest of the class to make sure it\r\n+            // ### doesn't use the field.\r\n+        }\r\n+    }\r\n+\r\n+    private Method setterForField(FieldMetaData fmd) {\r\n+        try {\r\n+            return fmd.getDeclaringType().getDeclaredMethod(\r\n+                \"set\" + StringUtils.capitalize(fmd.getName()),\r\n+                new Class[]{ fmd.getDeclaredType() });\r\n+        }\r\n+        catch (NoSuchMethodException e) {\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * @return the name of the field that is returned by <code>meth</code>, or\r\n+     *         <code>null</code> if something other than a single field is\r\n+     *         returned, or if it cannot be determined what is returned.\r\n+     */\r\n+    private BCField checkGetterIsSubclassable(Method meth, FieldMetaData fmd) {\r\n+        checkMethodIsSubclassable(meth, fmd);\r\n+        BCField field = PCEnhancer.getReturnedField(getBCMethod(meth));\r\n+        if (field == null) {\r\n+            addContractViolation(loc.get(\"subclasser-invalid-getter\",\r\n+                fmd.getName()), fmd);\r\n+            return null;\r\n+        } else {\r\n+            return field;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * @return the field that is set in <code>meth</code>, or\r\n+     *         <code>null</code> if something other than a single field is\r\n+     *         set, or if it cannot be determined what is set.\r\n+     */\r\n+    private BCField checkSetterIsSubclassable(Method meth, FieldMetaData fmd) {\r\n+        checkMethodIsSubclassable(meth, fmd);\r\n+        BCField field = PCEnhancer.getAssignedField(getBCMethod(meth));\r\n+        if (field == null) {\r\n+            addContractViolation(loc.get(\"subclasser-invalid-setter\",\r\n+                fmd.getName()), fmd);\r\n+            return null;\r\n+        } else {\r\n+            return field;\r\n+        }\r\n+    }\r\n+\r\n+    private BCMethod getBCMethod(Method meth) {\r\n+        BCClass bc = pc.getProject().loadClass(meth.getDeclaringClass());\r\n+        return bc.getDeclaredMethod(meth.getName(), meth.getParameterTypes());\r\n+    }\r\n+\r\n+    private void checkMethodIsSubclassable(Method meth, FieldMetaData fmd) {\r\n+        String className = fmd.getDefiningMetaData().\r\n+            getDescribedType().getName();\r\n+        if (!(Modifier.isProtected(meth.getModifiers())\r\n+            || Modifier.isPublic(meth.getModifiers())))\r\n+            addError(loc.get(\"subclasser-private-accessors-unsupported\",\r\n+                className, meth.getName()), fmd);\r\n+        if (Modifier.isFinal(meth.getModifiers()))\r\n+            addError(loc.get(\"subclasser-final-methods-not-allowed\",\r\n+                className, meth.getName()), fmd);\r\n+        if (Modifier.isNative(meth.getModifiers()))\r\n+            addContractViolation(loc.get\r\n+                (\"subclasser-native-methods-not-allowed\", className,\r\n+                    meth.getName()),\r\n+                fmd);\r\n+        if (Modifier.isStatic(meth.getModifiers()))\r\n+            addError(loc.get(\"subclasser-static-methods-not-supported\",\r\n+                className, meth.getName()), fmd);\r\n+    }\r\n+\r\n+    private void addError(Message s, ClassMetaData cls) {\r\n+        if (errors == null)\r\n+            errors = new ArrayList();\r\n+\r\n+        errors.add(loc.get(\"subclasser-error-meta\", s,\r\n+            cls.getDescribedType().getName(),\r\n+            cls.getSourceFile()));\r\n+    }\r\n+\r\n+    private void addError(Message s, FieldMetaData fmd) {\r\n+        if (errors == null)\r\n+            errors = new ArrayList();\r\n+\r\n+        errors.add(loc.get(\"subclasser-error-field\", s,\r\n+            fmd.getFullName(),\r\n+            fmd.getDeclaringMetaData().getSourceFile()));\r\n+    }\r\n+\r\n+    private void addContractViolation(Message m, FieldMetaData fmd) {\r\n+        // add the violation as an error in case we're processing violations\r\n+        // as errors; this keeps them in the order that they were found rather\r\n+        // than just adding the violations to the end of the list.\r\n+        if (failOnContractViolations)\r\n+            addError(m, fmd);\r\n+\r\n+        if (contractViolations == null)\r\n+            contractViolations = new ArrayList();\r\n+\r\n+        contractViolations.add(loc.get\r\n+            (\"subclasser-contract-violation-field\", m.getMessage(),\r\n+                fmd.getFullName(), fmd.getDeclaringMetaData().getSourceFile()));\r\n+    }\r\n+}\r"},{"sha":"ecf91ea3c37b5cc2231b92253488e7cc5726d757","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","status":"added","additions":188,"deletions":0,"changes":188,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,188 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.kernel.StateManagerImpl;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n+\r\n+/**\r\n+ * Helper methods for managed types that use method redefinition for field\r\n+ * tracking.\r\n+ *\r\n+ * @since 1.0.0\r\n+ */\r\n+public class RedefinitionHelper {\r\n+\r\n+    /**\r\n+     * Call {@link StateManagerImpl#dirtyCheck} if the argument is a\r\n+     * {@link StateManagerImpl}.\r\n+     */\r\n+    public static void dirtyCheck(StateManager sm) {\r\n+        if (sm instanceof StateManagerImpl)\r\n+            ((StateManagerImpl) sm).dirtyCheck();\r\n+    }\r\n+\r\n+    /**\r\n+     * Notify the state manager for <code>o</code> (if any) that a field\r\n+     * is about to be accessed.\r\n+     */\r\n+    public static void accessingField(Object o, int absoluteIndex) {\r\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n+        if (pc == null)\r\n+            return;\r\n+        StateManager sm = pc.pcGetStateManager();\r\n+        if (sm != null)\r\n+            sm.accessingField(absoluteIndex);\r\n+    }\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public static void settingField(Object o, int idx, boolean cur,\r\n+        boolean next) {\r\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n+        if (pc == null)\r\n+            return;\r\n+        StateManager sm = pc.pcGetStateManager();\r\n+        if (sm != null)\r\n+            sm.settingBooleanField(pc, idx, cur, next,\r\n+                OpenJPAStateManager.SET_USER);\r\n+    }\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public static void settingField(Object o, int idx, char cur, char next) {\r\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n+        if (pc == null)\r\n+            return;\r\n+        StateManager sm = pc.pcGetStateManager();\r\n+        if (sm != null)\r\n+            sm.settingCharField(pc, idx, cur, next,\r\n+                OpenJPAStateManager.SET_USER);\r\n+    }\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public static void settingField(Object o, int idx, byte cur, byte next) {\r\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n+        if (pc == null)\r\n+            return;\r\n+        StateManager sm = pc.pcGetStateManager();\r\n+        if (sm != null)\r\n+            sm.settingByteField(pc, idx, cur, next,\r\n+                OpenJPAStateManager.SET_USER);\r\n+    }\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public static void settingField(Object o, int idx, short cur, short next) {\r\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n+        if (pc == null)\r\n+            return;\r\n+        StateManager sm = pc.pcGetStateManager();\r\n+        if (sm != null)\r\n+            sm.settingShortField(pc, idx, cur, next,\r\n+                OpenJPAStateManager.SET_USER);\r\n+    }\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public static void settingField(Object o, int idx, int cur, int next) {\r\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n+        if (pc == null)\r\n+            return;\r\n+        StateManager sm = pc.pcGetStateManager();\r\n+        if (sm != null)\r\n+            sm.settingIntField(pc, idx, cur, next,\r\n+                OpenJPAStateManager.SET_USER);\r\n+    }\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public static void settingField(Object o, int idx, long cur, long next) {\r\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n+        if (pc == null)\r\n+            return;\r\n+        StateManager sm = pc.pcGetStateManager();\r\n+        if (sm != null)\r\n+            sm.settingLongField(pc, idx, cur, next,\r\n+                OpenJPAStateManager.SET_USER);\r\n+    }\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public static void settingField(Object o, int idx, float cur, float next) {\r\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n+        if (pc == null)\r\n+            return;\r\n+        StateManager sm = pc.pcGetStateManager();\r\n+        if (sm != null)\r\n+            sm.settingFloatField(pc, idx, cur, next,\r\n+                OpenJPAStateManager.SET_USER);\r\n+    }\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public static void settingField(Object o, int idx, double cur,\r\n+        double next) {\r\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n+        if (pc == null)\r\n+            return;\r\n+        StateManager sm = pc.pcGetStateManager();\r\n+        if (sm != null)\r\n+            sm.settingDoubleField(pc, idx, cur, next,\r\n+                OpenJPAStateManager.SET_USER);\r\n+    }\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public static void settingField(Object o, int idx, String cur,\r\n+        String next) {\r\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n+        if (pc == null)\r\n+            return;\r\n+        StateManager sm = pc.pcGetStateManager();\r\n+        if (sm != null)\r\n+            sm.settingStringField(pc, idx, cur, next,\r\n+                OpenJPAStateManager.SET_USER);\r\n+    }\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public static void settingField(Object o, int idx, Object cur,\r\n+        Object next) {\r\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n+        if (pc == null)\r\n+            return;\r\n+        StateManager sm = pc.pcGetStateManager();\r\n+        if (sm != null)\r\n+            sm.settingObjectField(pc, idx, cur, next,\r\n+                OpenJPAStateManager.SET_USER);\r\n+    }\r\n+}\r"},{"sha":"6e69aaa3113562dec928fe4a1ee66687ecddd197","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","status":"added","additions":353,"deletions":0,"changes":353,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,353 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.lang.reflect.Field;\r\n+import java.lang.reflect.Method;\r\n+\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.util.ApplicationIds;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import org.apache.openjpa.util.ObjectId;\r\n+import org.apache.openjpa.kernel.StateManagerImpl;\r\n+\r\n+/**\r\n+ * Implementation of the {@link PersistenceCapable} interface that can handle\r\n+ * the persistence-capable contract for instances that were not enhanced\r\n+ * before class load time.\r\n+ *\r\n+ * @since 1.0.0\r\n+ */\r\n+public class ReflectingPersistenceCapable\r\n+    implements PersistenceCapable, ManagedInstanceProvider {\r\n+\r\n+    private Object o;\r\n+    private StateManager sm;\r\n+    private PersistenceCapable pcSubclassInstance;\r\n+    private ClassMetaData meta;\r\n+\r\n+    public ReflectingPersistenceCapable(Object o, OpenJPAConfiguration conf) {\r\n+        this.o = o;\r\n+        Class type = o.getClass();\r\n+        pcSubclassInstance = PCRegistry.newInstance(type, null, false);\r\n+        meta = conf.getMetaDataRepositoryInstance()\r\n+            .getMetaData(type, null, true);\r\n+    }\r\n+\r\n+    public int pcGetEnhancementContractVersion() {\r\n+        return PCEnhancer.ENHANCER_VERSION;\r\n+    }\r\n+\r\n+    public Object pcGetGenericContext() {\r\n+        if (sm == null)\r\n+            return null;\r\n+        else\r\n+            return sm.getGenericContext();\r\n+    }\r\n+\r\n+    public StateManager pcGetStateManager() {\r\n+        return sm;\r\n+    }\r\n+\r\n+    public void pcReplaceStateManager(StateManager sm) {\r\n+        this.sm = sm;\r\n+    }\r\n+\r\n+    public void pcProvideField(int i) {\r\n+        switch (meta.getField(i).getTypeCode()) {\r\n+            case JavaTypes.BOOLEAN:\r\n+                sm.providedBooleanField(this, i,\r\n+                    ((Boolean) getValue(i, o)).booleanValue());\r\n+                break;\r\n+            case JavaTypes.BYTE:\r\n+                sm.providedByteField(this, i,\r\n+                    ((Byte) getValue(i, o)).byteValue());\r\n+                break;\r\n+            case JavaTypes.CHAR:\r\n+                sm.providedCharField(this, i,\r\n+                    ((Character) getValue(i, o)).charValue());\r\n+                break;\r\n+            case JavaTypes.DOUBLE:\r\n+                sm.providedDoubleField(this, i,\r\n+                    ((Double) getValue(i, o)).doubleValue());\r\n+                break;\r\n+            case JavaTypes.FLOAT:\r\n+                sm.providedFloatField(this, i,\r\n+                    ((Float) getValue(i, o)).floatValue());\r\n+                break;\r\n+            case JavaTypes.INT:\r\n+                sm.providedIntField(this, i,\r\n+                    ((Integer) getValue(i, o)).intValue());\r\n+                break;\r\n+            case JavaTypes.LONG:\r\n+                sm.providedLongField(this, i,\r\n+                    ((Long) getValue(i, o)).longValue());\r\n+                break;\r\n+            case JavaTypes.SHORT:\r\n+                sm.providedShortField(this, i,\r\n+                    ((Short) getValue(i, o)).shortValue());\r\n+                break;\r\n+            case JavaTypes.STRING:\r\n+                sm.providedStringField(this, i,\r\n+                    (String) getValue(i, o));\r\n+                break;\r\n+            default:\r\n+                sm.providedObjectField(this, i, getValue(i, o));\r\n+                break;\r\n+        }\r\n+    }\r\n+\r\n+    public void pcProvideFields(int[] fieldIndices) {\r\n+        for(int i = 0; i < fieldIndices.length; i++)\r\n+            pcProvideField(fieldIndices[i]);\r\n+    }\r\n+\r\n+    public void pcReplaceField(int i) {\r\n+        switch(meta.getField(i).getTypeCode()) {\r\n+            case JavaTypes.BOOLEAN:\r\n+                setValue(i, o, Boolean.valueOf(\r\n+                    sm.replaceBooleanField(this, i)));\r\n+                break;\r\n+            case JavaTypes.BYTE:\r\n+                setValue(i, o, Byte.valueOf(sm.replaceByteField(this, i)));\r\n+                break;\r\n+            case JavaTypes.CHAR:\r\n+                setValue(i, o, Character.valueOf(sm.replaceCharField(this, i)));\r\n+                break;\r\n+            case JavaTypes.DOUBLE:\r\n+                setValue(i, o, Double.valueOf(sm.replaceDoubleField(this, i)));\r\n+                break;\r\n+            case JavaTypes.FLOAT:\r\n+                setValue(i, o, Float.valueOf(sm.replaceFloatField(this, i)));\r\n+                break;\r\n+            case JavaTypes.INT:\r\n+                setValue(i, o, Integer.valueOf(sm.replaceIntField(this, i)));\r\n+                break;\r\n+            case JavaTypes.LONG:\r\n+                setValue(i, o, Long.valueOf(sm.replaceLongField(this, i)));\r\n+                break;\r\n+            case JavaTypes.SHORT:\r\n+                setValue(i, o, Short.valueOf(sm.replaceShortField(this, i)));\r\n+                break;\r\n+            case JavaTypes.STRING:\r\n+                setValue(i, o, sm.replaceStringField(this, i));\r\n+                break;\r\n+            default:\r\n+                setValue(i, o, sm.replaceObjectField(this, i));\r\n+                break;\r\n+        }\r\n+    }\r\n+\r\n+    public void pcReplaceFields(int[] fieldIndices) {\r\n+        for(int i = 0; i < fieldIndices.length; i++)\r\n+            pcReplaceField(fieldIndices[i]);\r\n+    }\r\n+\r\n+    public void pcCopyField(Object fromObject, int i) {\r\n+        // this doesn't need switch treatment because we're just\r\n+        // reflecting on both sides, bypassing field managers.\r\n+        setValue(i, o, getValue(i, fromObject));\r\n+    }\r\n+\r\n+    public void pcCopyFields(Object fromObject, int[] fieldIndices) {\r\n+        for(int i = 0; i < fieldIndices.length; i++)\r\n+            pcCopyField(fromObject, fieldIndices[i]);\r\n+    }\r\n+\r\n+    public void pcDirty(String fieldName) {\r\n+        if (sm != null)\r\n+            sm.dirty(fieldName);\r\n+    }\r\n+\r\n+    public Object pcFetchObjectId() {\r\n+        if (sm != null)\r\n+            return sm.fetchObjectId();\r\n+        else\r\n+            return null;\r\n+    }\r\n+\r\n+    public Object pcGetVersion() {\r\n+        if (sm == null)\r\n+            return null;\r\n+        else\r\n+            return sm.getVersion();\r\n+    }\r\n+\r\n+    public boolean pcIsDirty() {\r\n+        if (sm == null)\r\n+            return false;\r\n+        else {\r\n+            if (sm instanceof StateManagerImpl)\r\n+                ((StateManagerImpl) sm).dirtyCheck();\r\n+            return sm.isDirty();\r\n+        }\r\n+    }\r\n+\r\n+    public boolean pcIsTransactional() {\r\n+        if (sm == null)\r\n+            return false;\r\n+        else\r\n+            return sm.isTransactional();\r\n+    }\r\n+\r\n+    public boolean pcIsPersistent() {\r\n+        if (sm == null)\r\n+            return false;\r\n+        else\r\n+            return sm.isPersistent();\r\n+    }\r\n+\r\n+    public boolean pcIsNew() {\r\n+        if (sm == null)\r\n+            return false;\r\n+        else\r\n+            return sm.isNew();\r\n+    }\r\n+\r\n+    public boolean pcIsDeleted() {\r\n+        if (sm == null)\r\n+            return false;\r\n+        else\r\n+            return sm.isDeleted();\r\n+    }\r\n+\r\n+    // null == unknown\r\n+    public Boolean pcIsDetached() {\r\n+        if (sm != null)\r\n+            return Boolean.valueOf(sm.isDetached());\r\n+\r\n+        // ##### we could do a lot more here if a detached state field\r\n+        // ##### was specified.\r\n+        return null;\r\n+    }\r\n+\r\n+    public PersistenceCapable pcNewInstance(StateManager sm, boolean clear) {\r\n+        return pcSubclassInstance.pcNewInstance(sm, clear);\r\n+    }\r\n+\r\n+    public PersistenceCapable pcNewInstance(StateManager sm, Object oid,\r\n+        boolean clear) {\r\n+        return pcSubclassInstance.pcNewInstance(sm, oid, clear);\r\n+    }\r\n+\r\n+    public Object pcNewObjectIdInstance() {\r\n+        FieldMetaData[] pkFields = meta.getPrimaryKeyFields();\r\n+        Object[] pks = new Object[pkFields.length];\r\n+        for (int i = 0; i < pkFields.length; i++)\r\n+            pks[i] = getValue(pkFields[i].getIndex(), o);\r\n+        return ApplicationIds.fromPKValues(pks, meta);\r\n+    }\r\n+    \r\n+    public Object pcNewObjectIdInstance(Object oid) {\r\n+        return pcSubclassInstance.pcNewObjectIdInstance(oid);\r\n+    }\r\n+\r\n+    public void pcCopyKeyFieldsToObjectId(Object oid) {\r\n+        Object target;\r\n+        if (oid instanceof ObjectId)\r\n+            target = ((ObjectId) oid).getId();\r\n+        else\r\n+            target = oid;\r\n+\r\n+        FieldMetaData[] pks = meta.getPrimaryKeyFields();\r\n+        for (int i = 0; i < pks.length; i++) {\r\n+            Object val = getValue(pks[i].getIndex(), o);\r\n+            Field f = Reflection.findField(target.getClass(), pks[i].getName(),\r\n+                true);\r\n+            Reflection.set(target, f, val);\r\n+        }\r\n+    }\r\n+\r\n+    public void pcCopyKeyFieldsToObjectId(FieldSupplier supplier, Object obj) {\r\n+        // This is only ever invoked against PCs in the PCRegistry. Such PCs\r\n+        // will always be enhanced types or subtypes of user types, and will\r\n+        // never be a ReflectingPersistenceCapable.\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public void pcCopyKeyFieldsFromObjectId(FieldConsumer consumer,\r\n+        Object obj) {\r\n+        // This is only ever invoked against PCs in the PCRegistry. Such PCs\r\n+        // will always be enhanced types or subtypes of user types, and will\r\n+        // never be a ReflectingPersistenceCapable.\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public Object pcGetDetachedState() {\r\n+        // ##### we can implement this if a state field has been set\r\n+        return null;\r\n+    }\r\n+\r\n+    public void pcSetDetachedState(Object state) {\r\n+        // StateManagerImpl will invoke this with null during instance\r\n+        // initialization\r\n+        if (state != null)\r\n+            throw new UnsupportedOperationException();\r\n+        // ##### we can implement this if a state field has been set\r\n+    }\r\n+\r\n+    public Object getManagedInstance() {\r\n+        return o;\r\n+    }\r\n+\r\n+    private Object getValue(int i, Object o) {\r\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\r\n+            if (!meta.isIntercepting()) {\r\n+                Method meth = Reflection.findGetter(meta.getDescribedType(),\r\n+                    meta.getField(i).getName(), true);\r\n+                return Reflection.get(o, meth);\r\n+            } else {\r\n+                Field field = Reflection.findField(meta.getDescribedType(),\r\n+                    toFieldName(i), true);\r\n+                return Reflection.get(o, field);\r\n+            }\r\n+        } else {\r\n+            Field field = (Field) meta.getField(i).getBackingMember();\r\n+            return Reflection.get(o, field);\r\n+        }\r\n+    }\r\n+\r\n+    private String toFieldName(int i) {\r\n+        if (pcSubclassInstance instanceof AttributeTranslator)\r\n+            return ((AttributeTranslator) pcSubclassInstance)\r\n+                .pcAttributeIndexToFieldName(i);\r\n+        else\r\n+            return meta.getField(i).getName();\r\n+    }\r\n+\r\n+    private void setValue(int i, Object o, Object val) {\r\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\r\n+            if (!meta.isIntercepting()) {\r\n+                Method meth = Reflection.findSetter(meta.getDescribedType(),\r\n+                    meta.getField(i).getName(), true);\r\n+                Reflection.set(o, meth, val);\r\n+            } else {\r\n+                Field field = Reflection.findField(meta.getDescribedType(),\r\n+                    toFieldName(i), true);\r\n+                Reflection.set(o, field, val);\r\n+            }\r\n+        } else {\r\n+            Field field = (Field) meta.getField(i).getBackingMember();\r\n+            Reflection.set(o, field, val);\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"c7bc9fa4453f94f7f51c68a8ef849c1f0f41c864","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java","status":"modified","additions":99,"deletions":0,"changes":99,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -526,6 +526,105 @@ public static void set(Object target, Field field, short value) {\n         }\n     }\n \n+    /**\n+     * Set the value of the given field in the given object.\n+     * Same behavior as above methods, but parameter ordering is rearranged\n+     * to simplify usage from generated bytecodes.\n+     *\n+     * @since 1.0.0\n+     */\n+    public static void set(Object target, Object value, Field field) {\n+        set(target, field, value);\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     * Same behavior as above methods, but parameter ordering is rearranged\n+     * to simplify usage from generated bytecodes.\n+     *\n+     * @since 1.0.0\n+     */\n+    public static void set(Object target, boolean value, Field field) {\n+        set(target, field, value);\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     * Same behavior as above methods, but parameter ordering is rearranged\n+     * to simplify usage from generated bytecodes.\n+     *\n+     * @since 1.0.0\n+     */\n+    public static void set(Object target, byte value, Field field) {\n+        set(target, field, value);\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     * Same behavior as above methods, but parameter ordering is rearranged\n+     * to simplify usage from generated bytecodes.\n+     *\n+     * @since 1.0.0\n+     */\n+    public static void set(Object target, char value, Field field) {\n+        set(target, field, value);\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     * Same behavior as above methods, but parameter ordering is rearranged\n+     * to simplify usage from generated bytecodes.\n+     *\n+     * @since 1.0.0\n+     */\n+    public static void set(Object target, double value, Field field) {\n+        set(target, field, value);\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     * Same behavior as above methods, but parameter ordering is rearranged\n+     * to simplify usage from generated bytecodes.\n+     *\n+     * @since 1.0.0\n+     */\n+    public static void set(Object target, float value, Field field) {\n+        set(target, field, value);\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     * Same behavior as above methods, but parameter ordering is rearranged\n+     * to simplify usage from generated bytecodes.\n+     *\n+     * @since 1.0.0\n+     */\n+    public static void set(Object target, int value, Field field) {\n+        set(target, field, value);\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     * Same behavior as above methods, but parameter ordering is rearranged\n+     * to simplify usage from generated bytecodes.\n+     *\n+     * @since 1.0.0\n+     */\n+    public static void set(Object target, long value, Field field) {\n+        set(target, field, value);\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     * Same behavior as above methods, but parameter ordering is rearranged\n+     * to simplify usage from generated bytecodes.\n+     *\n+     * @since 1.0.0\n+     */\n+    public static void set(Object target, short value, Field field) {\n+        set(target, field, value);\n+    }\n+\n     /**\n      * Invoke the given setter on the given object.\n      */"},{"sha":"18d3a815c461a6df2d63c3852d6eb99fea91daa8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"modified","additions":64,"deletions":16,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -28,6 +28,7 @@\n import java.util.Properties;\n import java.util.LinkedList;\n import java.util.List;\n+import java.lang.reflect.InvocationTargetException;\n import javax.transaction.Status;\n import javax.transaction.Synchronization;\n import javax.transaction.Transaction;\n@@ -38,12 +39,14 @@\n import org.apache.openjpa.conf.OpenJPAVersion;\n import org.apache.openjpa.datacache.DataCacheStoreManager;\n import org.apache.openjpa.enhance.PCRegistry;\n+import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.event.RemoteCommitEventManager;\n import org.apache.openjpa.event.BrokerFactoryEvent;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.J2DoPrivHelper;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.lib.util.ReferenceHashSet;\n+import org.apache.openjpa.lib.util.JavaVersions;\n import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;\n import org.apache.openjpa.lib.util.concurrent.ReentrantLock;\n@@ -52,6 +55,7 @@\n import org.apache.openjpa.util.InvalidStateException;\n import org.apache.openjpa.util.OpenJPAException;\n import org.apache.openjpa.util.UserException;\n+import org.apache.openjpa.util.InternalException;\n \n /**\n  * Abstract implementation of the {@link BrokerFactory}\n@@ -216,7 +220,6 @@ protected void addListeners(BrokerImpl broker) {\n         }\n \n         if (_transactionListeners != null && !_transactionListeners.isEmpty()) {\n-            Map.Entry entry;\n             for (Iterator itr = _transactionListeners.iterator();\n                 itr.hasNext(); ) {\n                 broker.addTransactionListener(itr.next());\n@@ -236,34 +239,79 @@ private void loadPersistentTypes(ClassLoader envLoader) {\n         // cache persistent type names if not already\n         ClassLoader loader = _conf.getClassResolverInstance().\n             getClassLoader(getClass(), envLoader);\n+        Collection toRedefine = new ArrayList();\n         if (_pcClassNames == null) {\n             Collection clss = _conf.getMetaDataRepositoryInstance().\n                 loadPersistentTypes(false, loader);\n             if (clss.isEmpty())\n                 _pcClassNames = Collections.EMPTY_SET;\n             else {\n                 _pcClassNames = new ArrayList(clss.size());\n-                for (Iterator itr = clss.iterator(); itr.hasNext();)\n-                    _pcClassNames.add(((Class) itr.next()).getName());\n+                for (Iterator itr = clss.iterator(); itr.hasNext();) {\n+                    Class cls = (Class) itr.next();\n+                    _pcClassNames.add(cls.getName());\n+                    if (needsSub(cls))\n+                        toRedefine.add(cls);\n+                }\n                 _pcClassLoaders = new ReferenceHashSet(ReferenceHashSet.WEAK);\n                 _pcClassLoaders.add(loader);\n             }\n-            return;\n+        } else {\n+            // reload with this loader\n+            if (_pcClassLoaders.add(loader)) {\n+                for (Iterator itr = _pcClassNames.iterator(); itr.hasNext();) {\n+                    try {\n+                        Class cls =\n+                            Class.forName((String) itr.next(), true, loader);\n+                        if (needsSub(cls))\n+                            toRedefine.add(cls);\n+                    } catch (Throwable t) {\n+                        _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME)\n+                            .warn(null, t);\n+                    }\n+                }\n+            }\n         }\n \n-        // reload with this loader\n-        if (_pcClassLoaders.add(loader)) {\n-            for (Iterator itr = _pcClassNames.iterator(); itr.hasNext();) {\n-                try {\n-                    Class.forName((String) itr.next(), true, loader);\n-                } catch (Throwable t) {\n-                    _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME)\n-                        .warn(null, t);\n-                }\n+        if (JavaVersions.VERSION >= 5) {\n+            try {\n+                // This is Java 5 / 6 code. There might be a more elegant\n+                // way to bootstrap this into the system, but reflection\n+                // will get things working for now. We could potentially\n+                // do this by creating a new BrokerFactoryEvent type for\n+                // Broker creation, at which point we have an appropriate\n+                // classloader to use.\n+                Class cls = Class.forName(\n+                    \"org.apache.openjpa.enhance.ManagedClassSubclasser\");\n+                cls.getMethod(\"prepareUnenhancedClasses\", new Class[] {\n+                        OpenJPAConfiguration.class, Collection.class,\n+                        ClassLoader.class\n+                    })\n+                    .invoke(null, new Object[]{ _conf, toRedefine, envLoader });\n+            } catch (NoSuchMethodException e) {\n+                // should never happen in a properly-built installation\n+                throw new InternalException(e);\n+            } catch (IllegalAccessException e) {\n+                // should never happen in a properly-built installation\n+                throw new InternalException(e);\n+            } catch (InvocationTargetException e) {\n+                Throwable cause = e.getCause();\n+                if (cause instanceof OpenJPAException)\n+                    throw (OpenJPAException) cause;\n+                else\n+                    throw new InternalException(cause);\n+            } catch (ClassNotFoundException e) {\n+                // should never happen in a properly-built installation\n+                throw new InternalException(e);\n             }\n         }\n     }\n \n+    private boolean needsSub(Class cls) {\n+        return !cls.isInterface()\n+            && !PersistenceCapable.class.isAssignableFrom(cls);\n+    }\n+\n     public void addLifecycleListener(Object listener, Class[] classes) {\n         lock();\n         try {\n@@ -477,7 +525,7 @@ protected void setup() {\n      * current transaction, or returns null if none.\n      */\n     protected BrokerImpl findTransactionalBroker(String user, String pass) {\n-        Transaction trans = null;\n+        Transaction trans;\n         try {\n             trans = _conf.getManagedRuntimeInstance().getTransactionManager().\n                 getTransaction();\n@@ -626,7 +674,7 @@ private void assertOpen() {\n      * failed objects in the nested exceptions.\n      */\n     private void assertNoActiveTransaction() {\n-        Collection excs = null;\n+        Collection excs;\n         if (_transactional.isEmpty())\n             return;\n \n@@ -653,7 +701,7 @@ private void assertNoActiveTransaction() {\n      * @return true if synched with transaction, false otherwise\n      */\n     boolean syncWithManagedTransaction(BrokerImpl broker, boolean begin) {\n-        Transaction trans = null;\n+        Transaction trans;\n         try {\n             TransactionManager tm = broker.getManagedRuntime().\n                 getTransactionManager();"},{"sha":"a1e7b873c17cedb6d1352fc219e4ee43f9f81cbd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","status":"modified","additions":8,"deletions":4,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -39,6 +39,7 @@\n import org.apache.openjpa.util.OptimisticException;\n import org.apache.openjpa.util.ProxyManager;\n import org.apache.openjpa.util.UserException;\n+import org.apache.openjpa.util.ImplHelper;\n \n /**\n  * Handles attaching instances.\n@@ -234,8 +235,9 @@ Object attach(Object toAttach, PersistenceCapable into,\n \n         //### need to handle ACT_RUN without also ACT_CASCADE\n         ClassMetaData meta = _broker.getConfiguration().\n-            getMetaDataRepositoryInstance().getMetaData(toAttach.getClass(),\n-            _broker.getClassLoader(), true);\n+            getMetaDataRepositoryInstance().getMetaData(\n+                ImplHelper.getManagedInstance(toAttach).getClass(),\n+                _broker.getClassLoader(), true);\n         return getStrategy(toAttach).attach(this, toAttach, meta, into,\n             owner, ownerMeta, explicit);\n     }\n@@ -254,7 +256,8 @@ private int processArgument(Object obj) {\n      * Calculate proper attach strategy for instance.\n      */\n     private AttachStrategy getStrategy(Object toAttach) {\n-        PersistenceCapable pc = (PersistenceCapable) toAttach;\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(toAttach,\n+            getBroker().getConfiguration());\n         if (pc.pcGetStateManager() instanceof AttachStrategy)\n             return (AttachStrategy) pc.pcGetStateManager();\n \n@@ -293,7 +296,8 @@ ProxyManager getProxyManager() {\n      * the (cached) attached copy.\n      */\n     PersistenceCapable getAttachedCopy(Object pc) {\n-        return (PersistenceCapable) _attached.get(pc);\n+        return ImplHelper.toPersistenceCapable(_attached.get(pc),\n+            getBroker().getConfiguration());\n     }\n \n     /**"},{"sha":"1e7ba74abd8b1dcffebabef23f7e767cb838d680","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":42,"deletions":27,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -735,8 +735,6 @@ public void setTransactionListenerCallbackMode(int mode) {\n \n     /**\n      * Fire given transaction event, handling any exceptions appropriately.\n-     *\n-     * @return whether events are being processed at this time\n      */\n     private void fireTransactionEvent(TransactionEvent trans) {\n         if (_transEventManager != null)\n@@ -792,7 +790,7 @@ protected Object find(Object oid, FetchConfiguration fetch, BitSet exclude,\n                     // after making instance transactional for locking\n                     if (!sm.isTransactional() && useTransactionalState(fetch))\n                         sm.transactional();\n-                    boolean loaded = false;\n+                    boolean loaded;\n                     try {\n                         loaded = sm.load(fetch, StateManagerImpl.LOAD_FGS, \n                             exclude, edata, false);\n@@ -4152,8 +4150,9 @@ public Object newInstance(Class cls) {\n \n     public Object getObjectId(Object obj) {\n         assertOpen();\n-        if (obj instanceof PersistenceCapable)\n-            return ((PersistenceCapable) obj).pcFetchObjectId();\n+        if (ImplHelper.isManageable(obj))\n+            return (ImplHelper.toPersistenceCapable(obj, _conf))\n+                .pcFetchObjectId();\n         return null;\n     }\n \n@@ -4170,58 +4169,62 @@ public int getLockLevel(Object o) {\n \n     public Object getVersion(Object obj) {\n         assertOpen();\n-        if (obj instanceof PersistenceCapable)\n-            return ((PersistenceCapable) obj).pcGetVersion();\n+        if (ImplHelper.isManageable(obj))\n+            return (ImplHelper.toPersistenceCapable(obj, _conf)).pcGetVersion();\n         return null;\n     }\n \n     public boolean isDirty(Object obj) {\n         assertOpen();\n-        if (obj instanceof PersistenceCapable)\n-            return ((PersistenceCapable) obj).pcIsDirty();\n+        if (ImplHelper.isManageable(obj)) {\n+            PersistenceCapable pc = ImplHelper.toPersistenceCapable(obj, _conf);\n+            return pc.pcIsDirty();\n+        }\n         return false;\n     }\n \n     public boolean isTransactional(Object obj) {\n         assertOpen();\n-        if (obj instanceof PersistenceCapable)\n-            return ((PersistenceCapable) obj).pcIsTransactional();\n+        if (ImplHelper.isManageable(obj))\n+            return (ImplHelper.toPersistenceCapable(obj, _conf))\n+                .pcIsTransactional();\n         return false;\n     }\n \n     public boolean isPersistent(Object obj) {\n         assertOpen();\n-        if (obj instanceof PersistenceCapable)\n-            return ((PersistenceCapable) obj).pcIsPersistent();\n+        if (ImplHelper.isManageable(obj))\n+            return (ImplHelper.toPersistenceCapable(obj, _conf)).pcIsPersistent();\n         return false;\n     }\n \n     public boolean isNew(Object obj) {\n         assertOpen();\n-        if (obj instanceof PersistenceCapable)\n-            return ((PersistenceCapable) obj).pcIsNew();\n+        if (ImplHelper.isManageable(obj))\n+            return (ImplHelper.toPersistenceCapable(obj, _conf)).pcIsNew();\n         return false;\n     }\n \n     public boolean isDeleted(Object obj) {\n         assertOpen();\n-        if (obj instanceof PersistenceCapable)\n-            return ((PersistenceCapable) obj).pcIsDeleted();\n+        if (ImplHelper.isManageable(obj))\n+            return (ImplHelper.toPersistenceCapable(obj, _conf)).pcIsDeleted();\n         return false;\n     }\n \n     public boolean isDetached(Object obj) {\n-        if (!(obj instanceof PersistenceCapable))\n+        if (!(ImplHelper.isManageable(obj)))\n             return false;\n \n-        PersistenceCapable pc = (PersistenceCapable) obj;\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(obj, _conf);\n         Boolean detached = pc.pcIsDetached();\n         if (detached != null)\n             return detached.booleanValue();\n \n         // last resort: instance is detached if it has a store record\n         ClassMetaData meta = _conf.getMetaDataRepositoryInstance().\n-            getMetaData(pc.getClass(), _loader, true);\n+            getMetaData(ImplHelper.getManagedInstance(pc).getClass(),\n+                _loader, true);\n         Object oid = ApplicationIds.create(pc, meta);\n         if (oid == null)\n             return false;\n@@ -4241,8 +4244,8 @@ public OpenJPAStateManager getStateManager(Object obj) {\n      */\n     protected StateManagerImpl getStateManagerImpl(Object obj,\n         boolean assertThisContext) {\n-        if (obj instanceof PersistenceCapable) {\n-            PersistenceCapable pc = (PersistenceCapable) obj;\n+        if (ImplHelper.isManageable(obj)) {\n+            PersistenceCapable pc = ImplHelper.toPersistenceCapable(obj, _conf);\n             if (pc.pcGetGenericContext() == this)\n                 return (StateManagerImpl) pc.pcGetStateManager();\n             if (assertThisContext && pc.pcGetGenericContext() != null)\n@@ -4272,10 +4275,10 @@ protected StateManagerImpl getStateManagerImplById(Object oid,\n     protected PersistenceCapable assertPersistenceCapable(Object obj) {\n         if (obj == null)\n             return null;\n-        if (obj instanceof PersistenceCapable)\n-            return (PersistenceCapable) obj;\n+        if (ImplHelper.isManageable(obj))\n+            return ImplHelper.toPersistenceCapable(obj, _conf);\n \n-        // check for difference instances of the PersistenceCapable interface\n+        // check for different instances of the PersistenceCapable interface\n         // and throw a better error that mentions the class loaders\n         Class[] intfs = obj.getClass().getInterfaces();\n         for (int i = 0; intfs != null && i < intfs.length; i++) {\n@@ -4373,6 +4376,7 @@ public Object processReturn(Object oid, OpenJPAStateManager sm) {\n         private Map _conflicts = null; // conflict oid -> new sm\n         private Map _news = null; // tmp id -> new sm\n         private Collection _embeds = null; // embedded/non-persistent sms\n+        private Collection _untracked = null; // hard refs to untracked sms\n \n         /**\n          * Constructor; supply primary cache map.\n@@ -4449,6 +4453,12 @@ public void add(StateManagerImpl sm) {\n                     (orig.getManagedInstance()))).\n                     setFailedObject(sm.getManagedInstance());\n             }\n+\n+            if (!sm.isIntercepting()) {\n+                if (_untracked == null)\n+                    _untracked = new HashSet();\n+                _untracked.add(sm);\n+            }\n         }\n \n         /**\n@@ -4471,12 +4481,15 @@ public void remove(Object id, StateManagerImpl sm) {\n                             _conflicts.put(id, orig); // put back\n                     }\n                 }\n-            } else\n-            if ((_embeds == null || !_embeds.remove(sm)) && _news != null) {\n+            } else if ((_embeds == null || !_embeds.remove(sm))\n+                && _news != null) {\n                 orig = _news.remove(id);\n                 if (orig != null && orig != sm)\n                     _news.put(id, orig); // put back\n             }\n+\n+            if (_untracked != null)\n+                _untracked.remove(sm);\n         }\n \n         /**\n@@ -4600,6 +4613,8 @@ public void clear() {\n                 _news.clear();\n             if (_embeds != null)\n                 _embeds.clear();\n+            if (_untracked != null)\n+                _untracked.clear();\n         }\n \n         /**"},{"sha":"ce3f238451a0561aa9932695ad59d2dd70cc80c9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","status":"modified","additions":17,"deletions":9,"changes":26,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -28,6 +28,7 @@\n import org.apache.openjpa.util.ApplicationIds;\n import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.OptimisticException;\n+import org.apache.openjpa.util.ImplHelper;\n \n /**\n  * Handles attaching instances with detached state.\n@@ -46,19 +47,21 @@ protected Object getDetachedObjectId(AttachManager manager,\n         if (toAttach == null)\n             return null;\n \n-        PersistenceCapable pc = (PersistenceCapable) toAttach;\n         Broker broker = manager.getBroker();\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(toAttach,\n+            broker.getConfiguration());\n         ClassMetaData meta = broker.getConfiguration().\n-            getMetaDataRepositoryInstance().getMetaData(toAttach.getClass(),\n-            broker.getClassLoader(), true);\n+            getMetaDataRepositoryInstance().getMetaData(\n+                ImplHelper.getManagedInstance(toAttach).getClass(),\n+                broker.getClassLoader(), true);\n \n         switch (meta.getIdentityType()) {\n             case ClassMetaData.ID_DATASTORE:\n                 Object[] state = (Object[]) pc.pcGetDetachedState();\n                 if (state == null)\n                     return null;\n                 return broker\n-                    .newObjectId(toAttach.getClass(), (String) state[0]);\n+                    .newObjectId(toAttach.getClass(), state[0]);\n             case ClassMetaData.ID_APPLICATION:\n                 return ApplicationIds.create(pc, meta);\n             default:\n@@ -68,14 +71,16 @@ protected Object getDetachedObjectId(AttachManager manager,\n \n     protected void provideField(Object toAttach, StateManagerImpl sm,\n         int field) {\n-        sm.provideField((PersistenceCapable) toAttach, this, field);\n+        sm.provideField(ImplHelper.toPersistenceCapable(toAttach,\n+            sm.getContext().getConfiguration()), this, field);\n     }\n \n     public Object attach(AttachManager manager, Object toAttach,\n         ClassMetaData meta, PersistenceCapable into, OpenJPAStateManager owner,\n         ValueMetaData ownerMeta, boolean explicit) {\n         BrokerImpl broker = manager.getBroker();\n-        PersistenceCapable pc = (PersistenceCapable) toAttach;\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(toAttach,\n+            manager.getBroker().getConfiguration());\n \n         Object[] state = (Object[]) pc.pcGetDetachedState();\n         boolean embedded = ownerMeta != null && ownerMeta.isEmbeddedPC();\n@@ -103,7 +108,9 @@ public Object attach(AttachManager manager, Object toAttach,\n         } else if (!embedded && into == null) {\n             Object id = getDetachedObjectId(manager, pc);\n             if (id != null)\n-                into = (PersistenceCapable) broker.find(id, true, null);\n+                into =\n+                    ImplHelper.toPersistenceCapable(broker.find(id, true, null),\n+                        manager.getBroker().getConfiguration());\n             if (into == null) {\n                 // we mark objects that were new on detach by putting an empty\n                 // extra element in their detached state array\n@@ -114,7 +121,8 @@ public Object attach(AttachManager manager, Object toAttach,\n                 // will throw an OVE if it was not PNEW when it was detached\n                 if (!isNew)\n                     throw new OptimisticException(_loc.get(\"attach-deleted\",\n-                        pc.getClass(), id)).setFailedObject(id);\n+                        ImplHelper.getManagedInstance(pc).getClass(), id))\n+                        .setFailedObject(id);\n \n                 // if the instance does not exist, we assume that it was\n                 // made persistent in a new transaction, detached, and then\n@@ -185,6 +193,6 @@ public Object attach(AttachManager manager, Object toAttach,\n                     break;\n             }\n         }\n-        return into;\n+        return ImplHelper.getManagedInstance(into);\n     }\n }"},{"sha":"d91b30ef56824ce285f7e887f3bd909caf25eda1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","status":"modified","additions":9,"deletions":5,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -36,6 +36,7 @@\n import org.apache.openjpa.util.Exceptions;\n import org.apache.openjpa.util.Proxy;\n import org.apache.openjpa.util.UnsupportedException;\n+import org.apache.openjpa.util.ImplHelper;\n \n /**\n  * Internal state manager for detached instances. Does not fully\n@@ -93,12 +94,13 @@ public Object attach(AttachManager manager, Object toAttach,\n         ClassMetaData meta, PersistenceCapable into, OpenJPAStateManager owner,\n         ValueMetaData ownerMeta, boolean explicit) {\n         BrokerImpl broker = manager.getBroker();\n-        StateManagerImpl sm = null;\n+        StateManagerImpl sm;\n         if (_embedded) {\n             if (_dirty.length () > 0)\n                 owner.dirty(ownerMeta.getFieldMetaData().getIndex());\n             sm = (StateManagerImpl) broker.embed(_pc, _oid, owner, ownerMeta);\n-            ((PersistenceCapable) toAttach).pcReplaceStateManager(this);\n+            ImplHelper.toPersistenceCapable(toAttach, broker.getConfiguration())\n+                .pcReplaceStateManager(this);\n         } else {\n             PCState state = (_dirty.length() > 0) ? PCState.PDIRTY\n                 : PCState.PCLEAN;\n@@ -161,8 +163,9 @@ public Object attach(AttachManager manager, Object toAttach,\n             switch (fields[i].getDeclaredTypeCode()) {\n                 case JavaTypes.BOOLEAN:\n                     if (_dirty.get(i))\n-                        sm.settingBooleanField(pc, i, (!loaded.get(i)) ? false\n-                            : sm.fetchBooleanField(i), longval == 1, set);\n+                        sm.settingBooleanField(pc, i,\n+                            (loaded.get(i)) && sm.fetchBooleanField(i),\n+                            longval == 1, set);\n                     else\n                         sm.storeBooleanField(i, longval == 1);\n                     break;\n@@ -231,7 +234,8 @@ public Object attach(AttachManager manager, Object toAttach,\n                     else {\n                         PersistenceCapable toPC = null;\n                         if (objval != null && fields[i].isEmbeddedPC())\n-                            toPC = (PersistenceCapable) objval;\n+                            toPC = ImplHelper.toPersistenceCapable(objval,\n+                                broker.getConfiguration());\n                         objval = manager.attach(objval, toPC, sm, fields[i],\n                             false);\n                     }"},{"sha":"28b4097752f92f110f192dea8f31ca5b3763d764","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -31,6 +31,7 @@\n import org.apache.openjpa.meta.ValueMetaData;\n import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.UnsupportedException;\n+import org.apache.openjpa.util.ImplHelper;\n import serp.util.Numbers;\n \n /**\n@@ -50,14 +51,15 @@\n     private ClassMetaData _meta;\n \n     public DetachedValueStateManager(Object pc, StoreContext ctx) {\n-        this((PersistenceCapable) pc, ctx.getConfiguration().\n-            getMetaDataRepositoryInstance().getMetaData(pc.getClass(),\n+        this(ImplHelper.toPersistenceCapable(pc, ctx.getConfiguration()),\n+            ctx.getConfiguration().getMetaDataRepositoryInstance()\n+                .getMetaData(ImplHelper.getManagedInstance(pc).getClass(),\n             ctx.getClassLoader(), true), ctx);\n     }\n \n     public DetachedValueStateManager(PersistenceCapable pc, ClassMetaData meta,\n         StoreContext ctx) {\n-        _pc = (PersistenceCapable) pc;\n+        _pc = ImplHelper.toPersistenceCapable(pc, ctx.getConfiguration());\n         _meta = meta;\n         _ctx = ctx;\n     }"},{"sha":"88f713aca5719c511f2e721edb3120648c2cbba2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -35,6 +35,7 @@\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.meta.ValueMetaData;\n import org.apache.openjpa.util.GeneralException;\n+import org.apache.openjpa.util.ImplHelper;\n import serp.util.Numbers;\n \n /**\n@@ -296,7 +297,8 @@ public Object getManagedInstance() {\n     }\n \n     public PersistenceCapable getPersistenceCapable() {\n-        return (PersistenceCapable) _oid;\n+        return ImplHelper.toPersistenceCapable(_oid,\n+            _vmd.getRepository().getConfiguration());\n     }\n \n     public ClassMetaData getMetaData() {"},{"sha":"2b38f661cf4b1a1352d78064dd076f9305691244","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -61,6 +61,7 @@\n import org.apache.openjpa.util.OpenJPAException;\n import org.apache.openjpa.util.UnsupportedException;\n import org.apache.openjpa.util.UserException;\n+import org.apache.openjpa.util.ImplHelper;\n import serp.util.Numbers;\n import serp.util.Strings;\n \n@@ -1083,7 +1084,8 @@ private void updateInMemory(Object ob, Object[] params) {\n \n             OpenJPAStateManager sm = _broker.getStateManager(ob);\n             int i = fmd.getIndex();\n-            PersistenceCapable into = (PersistenceCapable) ob;\n+            PersistenceCapable into = ImplHelper.toPersistenceCapable(ob,\n+                _broker.getConfiguration());\n \n             // set the actual field in the instance\n             int set = OpenJPAStateManager.SET_USER;"},{"sha":"7ac13dd55e45f01c8e8b596f0f99a06578792553","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","status":"modified","additions":21,"deletions":2,"changes":23,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -24,6 +24,7 @@\n import java.util.Map;\n \n import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.enhance.Reflection;\n import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.util.ProxyManager;\n@@ -33,7 +34,7 @@\n  *\n  * @author Abe White\n  */\n-class SaveFieldManager\n+public class SaveFieldManager\n     extends ClearFieldManager {\n \n     private final StateManagerImpl _sm;\n@@ -88,7 +89,7 @@ public BitSet getUnloaded() {\n      */\n     public boolean saveField(int field) {\n         // if not loaded we can't save orig value; mark as unloaded on rollback\n-        if (!_sm.getLoaded().get(field)) {\n+        if (_sm.getLoaded() != null && !_sm.getLoaded().get(field)) {\n             _unloaded.set(field);\n             return false;\n         }\n@@ -167,6 +168,24 @@ public boolean restoreField(int field) {\n         return false;\n     }\n \n+    /**\n+     * Compare the given field.\n+     * @return <code>true</code> if the field is the same in the current\n+     * state and in the saved state; otherwise, <code>false</code>.\n+     */\n+    public boolean isFieldEqual(int field, Object current) {\n+        // if the field is not available, assume that it has changed.\n+        if (_saved == null || !_saved.get(field))\n+            return false;\n+        if (!(_state.pcGetStateManager() instanceof OpenJPAStateManager))\n+            return false;\n+\n+        OpenJPAStateManager sm = (OpenJPAStateManager)\n+            _state.pcGetStateManager();\n+        Object old = sm.fetch(field);\n+        return current == old || current != null && current.equals(old);\n+    }\n+\n     public Object fetchObjectField(int field) {\n         // return the copied field during save, or a null value during restore\n         Object val = _field;"},{"sha":"643a309d659a33ccb8dae2b653dc953041aee8e9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":102,"deletions":7,"changes":109,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -29,6 +29,8 @@\n import org.apache.openjpa.enhance.PCRegistry;\n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.enhance.StateManager;\n+import org.apache.openjpa.enhance.ManagedInstanceProvider;\n+import org.apache.openjpa.enhance.DynamicPersistenceCapable;\n import org.apache.openjpa.event.LifecycleEvent;\n import org.apache.openjpa.event.LifecycleEventManager;\n import org.apache.openjpa.lib.util.Localizer;\n@@ -48,6 +50,7 @@\n import org.apache.openjpa.util.ProxyManager;\n import org.apache.openjpa.util.RuntimeExceptionTranslator;\n import org.apache.openjpa.util.UserException;\n+import org.apache.openjpa.util.ImplHelper;\n import serp.util.Numbers;\n \n /**\n@@ -89,7 +92,7 @@\n     private static final int FLAG_VERSION_UPDATE = 2 << 15;\n     private static final int FLAG_DETACHING = 2 << 16;\n \n-    private static Localizer _loc = Localizer.forPackage\n+    private static final Localizer _loc = Localizer.forPackage\n         (StateManagerImpl.class);\n \n     // information about the instance\n@@ -300,6 +303,27 @@ protected void initialize(PersistenceCapable pc, PCState state) {\n         _broker.setStateManager(_id, this, BrokerImpl.STATUS_INIT);\n         if (state == PCState.PNEW)\n             fireLifecycleEvent(LifecycleEvent.AFTER_PERSIST);\n+\n+        // if this is a non-tracking PC, add a hard ref to the appropriate data\n+        // sets and give it an opportunity to make a state snapshot.\n+        if (!isIntercepting())\n+            saveFields(true);\n+    }\n+\n+    /**\n+     * Whether or not data access in this instance is intercepted. This differs\n+     * from {@link ClassMetaData#isIntercepting()} in that it checks for\n+     * property access + subclassing in addition to the redefinition /\n+     * enhancement checks.\n+     */\n+    public boolean isIntercepting() {\n+        if (getMetaData().isIntercepting())\n+            return true;\n+        if (getMetaData().getAccessType() != ClassMetaData.ACCESS_FIELD\n+            && _pc instanceof DynamicPersistenceCapable)\n+            return true;\n+\n+        return false;\n     }\n \n     /**\n@@ -339,7 +363,10 @@ protected boolean load(FetchConfiguration fetch, int loadMode,\n     }\n \n     public Object getManagedInstance() {\n-        return _pc;\n+        if (_pc instanceof ManagedInstanceProvider)\n+            return ((ManagedInstanceProvider) _pc).getManagedInstance();\n+        else\n+            return _pc;\n     }\n \n     public PersistenceCapable getPersistenceCapable() {\n@@ -735,6 +762,61 @@ public void storeField(int field, Object val) {\n         storeField(field, val, this);\n     }\n \n+    /**\n+     * <p>Checks whether or not <code>_pc</code> is dirty. In the cases where\n+     * field tracking is not happening (see below), this method will do a\n+     * state comparison to find whether <code>_pc</code> is dirty, and will\n+     * update this instance with this information. In the cases where field\n+     * tracking is happening, this method is a no-op.</p>\n+     *\n+     * <p>Fields are tracked for all classes that are run through the OpenJPA\n+     * enhancer prior to or during deployment, and all classes (enhanced or\n+     * unenhanced) in a Java 6 environment or newer.</p>\n+     *\n+     * <p>In a Java 5 VM or older:\n+     * <br>- instances of unenhanced classes that use\n+     * property access and obey the property access limitations are tracked\n+     * when the instances are loaded from the database by OpenJPA, and are\n+     * not tracked when the instances are created by application code.\n+     * <br>- instances of unenhanced classes that use field access are\n+     * never tracked.</p>\n+     *\n+     * @since 1.0.0\n+     */\n+    public void dirtyCheck() {\n+        if (!needsDirtyCheck())\n+            return;\n+\n+        SaveFieldManager saved = getSaveFieldManager();\n+        if (saved == null)\n+            throw new InternalException(_loc.get(\"no-saved-fields\"));\n+\n+        FieldMetaData[] fmds = getMetaData().getFields();\n+        for (int i = 0; i < fmds.length; i++) {\n+            // pk and version fields cannot be mutated; don't mark them\n+            // as such. ##### validate?\n+            if (!fmds[i].isPrimaryKey()\n+                && !fmds[i].isVersion()) {\n+                if (!saved.isFieldEqual(i, fetch(i))) {\n+                    dirty(i);\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean needsDirtyCheck() {\n+        if (isIntercepting())\n+            return false;\n+        if (isDeleted())\n+            return false;\n+        if (isNew() && !isFlushed())\n+            return false;\n+        if (getMetaData().getAccessType() != ClassMetaData.ACCESS_FIELD\n+            && !(isNew() && isFlushed()))\n+            return false;\n+        return true;\n+    }\n+\n     public Object fetchInitialField(int field) {\n         FieldMetaData fmd = _meta.getField(field);\n         if (_broker.getRestoreState() == RestoreState.RESTORE_NONE\n@@ -1375,7 +1457,8 @@ public void dirty(String field) {\n         FieldMetaData fmd = _meta.getField(field);\n         if (fmd == null)\n             throw translate(new UserException(_loc.get(\"no-field\", field,\n-                _pc.getClass())).setFailedObject(getManagedInstance()));\n+                ImplHelper.getManagedInstance(_pc).getClass()))\n+                .setFailedObject(getManagedInstance()));\n \n         dirty(fmd.getIndex(), null, true);\n     }\n@@ -1505,7 +1588,7 @@ private Boolean dirty(int field, Boolean mutate, boolean loadFetchGroup) {\n     /**\n      * Fire post-dirty events after field value changes.\n      *\n-     * @param status return value from {@link #dirty(int,boolean,boolean)}\n+     * @param status return value from {@link #dirty(int, Boolean, boolean)}\n      */\n     private void postDirty(Boolean status) {\n         if (Boolean.TRUE.equals(status))\n@@ -1836,7 +1919,8 @@ private void assertNoPrimaryKeyChange(int field) {\n      */\n     void assertNotManagedObjectId(Object val) {\n         if (val != null\n-            && ((PersistenceCapable) val).pcGetGenericContext() != null)\n+            && (ImplHelper.toPersistenceCapable(val,\n+                 getContext().getConfiguration())).pcGetGenericContext()!= null)\n             throw translate(new InvalidStateException(_loc.get\n                 (\"managed-oid\", Exceptions.toString(val),\n                     Exceptions.toString(getManagedInstance()))).\n@@ -2486,6 +2570,9 @@ else if (!val) {\n      * are not cleared.\n      */\n     void clearFields() {\n+        if (!isIntercepting())\n+            return;\n+\n         fireLifecycleEvent(LifecycleEvent.BEFORE_CLEAR);\n \n         // unproxy all fields\n@@ -2569,8 +2656,14 @@ private void saveField(int field) {\n      * to that of the last call to {@link #saveFields}.\n      */\n     void clearSavedFields() {\n-        _flags &= ~FLAG_SAVE;\n-        _saved = null;\n+        if (isIntercepting()) {\n+            _flags &= ~FLAG_SAVE;\n+            _saved = null;\n+        }\n+    }\n+\n+    public SaveFieldManager getSaveFieldManager() {\n+        return _saved;\n     }\n \n     /**\n@@ -2681,6 +2774,8 @@ void preFlush(boolean logical, OpCallbacks call) {\n                         _single.clear();\n                 }\n             }\n+\n+            dirtyCheck();\n         } finally {\n             unlock();\n         }"},{"sha":"16374e1a0bce7aad621ee395a379b04f4ea688cb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -177,7 +177,7 @@ public boolean load(OpenJPAStateManager sm, BitSet fields,\n      * several objects. Each of the given state managers will be in one of\n      * three states, each requiring a different action:\n      * <ul>\n-     * <li><code>stateManager.getManagedInstance () == null</code>: An\n+     * <li><code>stateManager.getO () == null</code>: An\n      * uninitialized state manager. Perform the same actions as in\n      * {@link #initialize}.\n      * <li><code>load != FORCE_LOAD_NONE || stateManager.getPCState ()"},{"sha":"5813f78d0a17c16883f54c161890ca5b435d31c9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","status":"modified","additions":18,"deletions":9,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -32,6 +32,7 @@\n import org.apache.openjpa.util.ApplicationIds;\n import org.apache.openjpa.util.ObjectNotFoundException;\n import org.apache.openjpa.util.OptimisticException;\n+import org.apache.openjpa.util.ImplHelper;\n \n /**\n  * Handles attaching instances using version and primary key fields.\n@@ -50,26 +51,31 @@ protected Object getDetachedObjectId(AttachManager manager,\n         Object toAttach) {\n         Broker broker = manager.getBroker();\n         ClassMetaData meta = broker.getConfiguration().\n-            getMetaDataRepositoryInstance().getMetaData(toAttach.getClass(),\n-            broker.getClassLoader(), true);\n-        return ApplicationIds.create((PersistenceCapable) toAttach, meta);\n+            getMetaDataRepositoryInstance().getMetaData(\n+                ImplHelper.getManagedInstance(toAttach).getClass(),\n+                broker.getClassLoader(), true);\n+        return ApplicationIds.create(ImplHelper.toPersistenceCapable(toAttach,\n+            broker.getConfiguration()),\n+            meta);\n     }\n \n     protected void provideField(Object toAttach, StateManagerImpl sm,\n         int field) {\n-        sm.provideField((PersistenceCapable) toAttach, this, field);\n+        sm.provideField(ImplHelper.toPersistenceCapable(toAttach,\n+            sm.getContext().getConfiguration()), this, field);\n     }\n \n     public Object attach(AttachManager manager, Object toAttach,\n         ClassMetaData meta, PersistenceCapable into, OpenJPAStateManager owner,\n         ValueMetaData ownerMeta, boolean explicit) {\n         BrokerImpl broker = manager.getBroker();\n-        PersistenceCapable pc = (PersistenceCapable) toAttach;\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(toAttach,\n+            meta.getRepository().getConfiguration());\n \n         boolean embedded = ownerMeta != null && ownerMeta.isEmbeddedPC();\n         boolean isNew = !broker.isDetached(pc);\n         Object version = null;\n-        StateManagerImpl sm = null;\n+        StateManagerImpl sm;\n \n         // if the state manager for the embedded instance is null, then\n         // it should be treated as a new instance (since the\n@@ -91,10 +97,13 @@ public Object attach(AttachManager manager, Object toAttach,\n         } else if (!embedded && into == null) {\n             Object id = getDetachedObjectId(manager, toAttach);\n             if (id != null)\n-                into = (PersistenceCapable) broker.find(id, true, null);\n+                into =\n+                    ImplHelper.toPersistenceCapable(broker.find(id, true, null),\n+                        broker.getConfiguration());\n             if (into == null)\n                 throw new OptimisticException(_loc.get(\"attach-version-del\",\n-                    pc.getClass(), id, version)).setFailedObject(toAttach);\n+                    ImplHelper.getManagedInstance(pc).getClass(), id, version))\n+                    .setFailedObject(toAttach);\n \n             sm = manager.assertManaged(into);\n             if (meta.getDescribedType()\n@@ -148,7 +157,7 @@ public Object attach(AttachManager manager, Object toAttach,\n         }\n         if (!embedded && !isNew)\n             compareVersion(sm, pc);\n-        return into;\n+        return ImplHelper.getManagedInstance(into);\n     }\n \n     /**"},{"sha":"8d89e01e52f9fc0dd374f75b38b3031de96d0ff0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -23,14 +23,14 @@\n import java.util.ListIterator;\n \n import org.apache.commons.lang.ObjectUtils;\n-import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.kernel.Broker;\n import org.apache.openjpa.kernel.Filters;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.StoreContext;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.XMLMetaData;\n+import org.apache.openjpa.util.ImplHelper;\n \n /**\n  * A path represents a traversal into fields of a candidate object.\n@@ -126,8 +126,9 @@ protected Object eval(Object candidate, Object orig,\n             // be proxyable\n             sm = null;\n             tmpBroker = null;\n-            if (candidate instanceof PersistenceCapable)\n-                sm = (OpenJPAStateManager) ((PersistenceCapable) candidate).\n+            if (ImplHelper.isManageable(candidate))\n+                sm = (OpenJPAStateManager) (ImplHelper.toPersistenceCapable(\n+                    candidate, ctx.getConfiguration())).\n                     pcGetStateManager();\n             if (sm == null) {\n                 tmpBroker = ctx.getBroker();"},{"sha":"1eac4740f2c29f2e85cbbcf93a7e8d7e61fd1df6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","status":"modified","additions":33,"deletions":8,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -39,8 +39,8 @@\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.datacache.DataCache;\n import org.apache.openjpa.enhance.PCRegistry;\n-import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.enhance.Reflection;\n+import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.meta.SourceTracker;\n import org.apache.openjpa.lib.util.J2DoPrivHelper;\n@@ -61,6 +61,7 @@\n import org.apache.openjpa.util.ShortId;\n import org.apache.openjpa.util.StringId;\n import org.apache.openjpa.util.UnsupportedException;\n+import org.apache.openjpa.util.ImplHelper;\n import serp.util.Strings;\n \n /**\n@@ -184,6 +185,7 @@\n     private FieldMetaData[] _allListingFields = null;\n     private FetchGroup[] _fgs = null;\n     private FetchGroup[] _customFGs = null;\n+    private boolean _intercepting = false;\n \n     /**\n      * Constructor. Supply described type and repository.\n@@ -234,6 +236,8 @@ protected void setDescribedType(Class type) {\n             (type.getSuperclass().getName()))\n             throw new MetaDataException(_loc.get(\"enum\", type));\n         _type = type;\n+        if (PersistenceCapable.class.isAssignableFrom(type))\n+            setIntercepting(true);\n     }\n \n     /**\n@@ -688,6 +692,22 @@ public void setEmbeddedOnly(boolean embed) {\n         _embedded = (embed) ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n+    /**\n+     * Whether the type's fields are actively intercepted, either by\n+     * redefinition or enhancement.\n+     */\n+    public boolean isIntercepting() {\n+        return _intercepting;\n+    }\n+\n+    /**\n+     * Whether the type's fields are actively intercepted, either by\n+     * redefinition or enhancement.\n+     */\n+    public void setIntercepting(boolean intercepting) {\n+        _intercepting = intercepting;\n+    }\n+\n     /**\n      * Whether the type is a managed interface.\n      */\n@@ -1576,7 +1596,10 @@ public boolean resolve(int mode) {\n \n         int val = _repos.getValidate();\n         boolean runtime = (val & _repos.VALIDATE_RUNTIME) != 0;\n-        boolean validate = !PersistenceCapable.class.isAssignableFrom(_type)\n+        // ##### what to do here? This should essentially never fail anymore.\n+        // ##### Maybe remove altogether?\n+        boolean validate =\n+            !ImplHelper.isManagedType(_type)\n             || (val & MetaDataRepository.VALIDATE_UNENHANCED) == 0;\n \n         // we only do any actions for metadata mode\n@@ -1605,8 +1628,10 @@ protected void resolveMeta(boolean runtime) {\n             log.trace(_loc.get((embed) ? \"resolve-embed-meta\" : \"resolve-meta\",\n                 this + \"@\" + System.identityHashCode(this)));\n \n-        if (runtime && !_type.isInterface() && \n-            !PersistenceCapable.class.isAssignableFrom(_type))\n+        // ##### what to do here? This should essentially never fail anymore.\n+        // ##### either remove, or convert to warning.\n+        if (runtime && !_type.isInterface() &&\n+            !ImplHelper.isManagedType(_type))\n             throw new MetaDataException(_loc.get(\"not-enhanced\", _type));\n \n         // are we the target of an embedded value?\n@@ -1710,7 +1735,7 @@ protected void validateMeta(boolean runtime) {\n         validateDataCache();\n         validateDetachable();\n         validateExtensionKeys();\n-        validateIdentity(runtime);\n+        validateIdentity();\n         validateAccessType();\n     }\n \n@@ -1769,7 +1794,7 @@ private void validateDataCache() {\n     /**\n      * Assert that the identity handling for this class is valid.\n      */\n-    private void validateIdentity(boolean runtime) {\n+    private void validateIdentity() {\n         // make sure identity types are consistent\n         ClassMetaData sup = getPCSuperclassMetaData();\n         int id = getIdentityType();\n@@ -1793,7 +1818,7 @@ private void validateIdentity(boolean runtime) {\n         if (id == ID_APPLICATION) {\n             if (_idStrategy != ValueStrategies.NONE)\n                 throw new MetaDataException(_loc.get(\"appid-strategy\", _type));\n-            validateAppIdClass(runtime);\n+            validateAppIdClass();\n         } else if (id != ID_UNKNOWN)\n             validateNoPKFields();\n \n@@ -1809,7 +1834,7 @@ private void validateIdentity(boolean runtime) {\n     /**\n      * Make sure the application identity class is valid.\n      */\n-    private void validateAppIdClass(boolean runtime) {\n+    private void validateAppIdClass() {\n         // base types must declare an oid class if not single-field identity\n         FieldMetaData[] pks = getPrimaryKeyFields();\n         if (getObjectIdType() == null) {"},{"sha":"675ce4e1f44a29894e9f0f1ed314edf8b8518e4a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","status":"modified","additions":7,"deletions":4,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -47,7 +47,6 @@\n import org.apache.commons.collections.comparators.ComparatorChain;\n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n-import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.StoreContext;\n import org.apache.openjpa.lib.conf.Configurations;\n@@ -62,6 +61,7 @@\n import org.apache.openjpa.util.MetaDataException;\n import org.apache.openjpa.util.OpenJPAException;\n import org.apache.openjpa.util.UnsupportedException;\n+import org.apache.openjpa.util.ImplHelper;\n import serp.util.Strings;\n \n /**\n@@ -174,8 +174,9 @@\n     // Members aren't serializable. Use a proxy that can provide a Member\n     // to avoid writing the full Externalizable implementation.\n     private transient MemberProvider _backingMember = null;\n+    private String _backingFieldName = null;\n     \n-    // Members aren't serializable. Initializing _extMethod and _factMethod to \n+    // Members aren't serializable. Initializing _extMethod and _factMethod to\n     // DEFAULT_METHOD is sufficient to trigger lazy population of these fields.\n     private transient Method _extMethod = DEFAULT_METHOD;\n     private transient Member _factMethod = DEFAULT_METHOD;\n@@ -1586,9 +1587,11 @@ public boolean resolve(int mode) {\n \n         MetaDataRepository repos = getRepository();\n         int validate = repos.getValidate();\n+        // ##### what to do here? This should essentially never fail anymore.\n+        // ##### Maybe remove the isManagedType check.\n         if ((validate & MetaDataRepository.VALIDATE_META) != 0\n-            && (!PersistenceCapable.class.isAssignableFrom\n-            (_owner.getDescribedType())\n+            && (!ImplHelper\n+            .isManagedType(_owner.getDescribedType())\n             || (validate & MetaDataRepository.VALIDATE_UNENHANCED) == 0)) {\n             validateLRS();\n             if ((validate & repos.VALIDATE_RUNTIME) == 0)"},{"sha":"532dcb10b2e69e42d5cbeadf1a86725a8d12bf7a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryRelatedFieldOrder.java","status":"modified","additions":10,"deletions":5,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryRelatedFieldOrder.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryRelatedFieldOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryRelatedFieldOrder.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -22,6 +22,8 @@\n \n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.util.ImplHelper;\n \n /**\n  * Order by a field in the related type in memory.\n@@ -33,10 +35,13 @@\n \n     private final FieldMetaData _rel;\n     private final boolean _asc;\n+    private final OpenJPAConfiguration _conf;\n \n-    public InMemoryRelatedFieldOrder(FieldMetaData rel, boolean asc) {\n+    public InMemoryRelatedFieldOrder(FieldMetaData rel, boolean asc,\n+        OpenJPAConfiguration conf) {\n         _rel = rel;\n         _asc = asc;\n+        _conf = conf;\n     }\n \n     public String getName() {\n@@ -54,12 +59,12 @@ public Comparator getComparator() {\n     public int compare(Object o1, Object o2) {\n         if (o1 == o2)\n             return 0;\n-        if (!(o1 instanceof PersistenceCapable)\n-            || !(o2 instanceof PersistenceCapable))\n+        if (!(ImplHelper.isManageable(o1))\n+            || !(ImplHelper.isManageable(o2)))\n             return 0;\n \n-        PersistenceCapable pc1 = (PersistenceCapable) o1;\n-        PersistenceCapable pc2 = (PersistenceCapable) o2;\n+        PersistenceCapable pc1 = ImplHelper.toPersistenceCapable(o1, _conf);\n+        PersistenceCapable pc2 = ImplHelper.toPersistenceCapable(o2, _conf);\n         OpenJPAStateManager sm1 = (OpenJPAStateManager) pc1.pcGetStateManager();\n         OpenJPAStateManager sm2 = (OpenJPAStateManager) pc2.pcGetStateManager();\n         if (sm1 == null || sm2 == null)"},{"sha":"a06e5a9acc3387401e722419ed1dc0c3a1201945","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryValueOrder.java","status":"modified","additions":9,"deletions":5,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryValueOrder.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryValueOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryValueOrder.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -23,6 +23,8 @@\n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.util.ApplicationIds;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n \n /**\n  * Order by the field value in memory. If the field contains\n@@ -36,9 +38,11 @@\n     implements Order, Comparator {\n \n     private final boolean _asc;\n+    private final OpenJPAConfiguration _conf;\n \n-    public InMemoryValueOrder(boolean asc) {\n+    public InMemoryValueOrder(boolean asc, OpenJPAConfiguration conf) {\n         _asc = asc;\n+        _conf = conf;\n     }\n \n     public String getName() {\n@@ -63,15 +67,15 @@ public int compare(Object o1, Object o2) {\n \n         // non-pc values must be comparable\n         int cmp;\n-        if (!(o1 instanceof PersistenceCapable)\n-            || !(o2 instanceof PersistenceCapable)) {\n+        if (!(ImplHelper.isManageable(o1))\n+            || !(ImplHelper.isManageable(o2))) {\n             cmp = ((Comparable) o1).compareTo(o2);\n             return (_asc) ? cmp : -cmp;\n         }\n \n         // order on primary key values\n-        PersistenceCapable pc1 = (PersistenceCapable) o1;\n-        PersistenceCapable pc2 = (PersistenceCapable) o2;\n+        PersistenceCapable pc1 = ImplHelper.toPersistenceCapable(o1, _conf);\n+        PersistenceCapable pc2 = ImplHelper.toPersistenceCapable(o2, _conf);\n         OpenJPAStateManager sm1 = (OpenJPAStateManager) pc1.pcGetStateManager();\n         OpenJPAStateManager sm2 = (OpenJPAStateManager) pc2.pcGetStateManager();\n         if (sm1 == null || sm2 == null)"},{"sha":"d113a0579c74d41717bdb3fd29592ac77e8bd40d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","status":"modified","additions":10,"deletions":3,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -38,6 +38,7 @@\n import org.apache.openjpa.enhance.PCRegistry;\n import org.apache.openjpa.enhance.PCRegistry.RegisterClassListener;\n import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.enhance.DynamicPersistenceCapable;\n import org.apache.openjpa.event.LifecycleEventManager;\n import org.apache.openjpa.lib.conf.Configurable;\n import org.apache.openjpa.lib.conf.Configuration;\n@@ -48,6 +49,7 @@\n import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.MetaDataException;\n import org.apache.openjpa.util.OpenJPAId;\n+import org.apache.openjpa.util.ImplHelper;\n import serp.util.Strings;\n \n /**\n@@ -274,9 +276,14 @@ else if (on)\n      */\n     public synchronized ClassMetaData getMetaData(Class cls,\n         ClassLoader envLoader, boolean mustExist) {\n+        if (cls != null &&\n+            DynamicPersistenceCapable.class.isAssignableFrom(cls))\n+            cls = cls.getSuperclass();\n+\n         ClassMetaData meta = getMetaDataInternal(cls, envLoader);\n         if (meta == null && mustExist) {\n-            if (cls != null && !PersistenceCapable.class.isAssignableFrom(cls))\n+            if (cls != null &&\n+                !ImplHelper.isManagedType(cls))\n                 throw new MetaDataException(_loc.get(\"no-meta-notpc\", cls)).\n                     setFatal(false);\n \n@@ -824,15 +831,15 @@ protected Order newOrder(FieldMetaData owner, String name, boolean asc) {\n      * Order by the field value.\n      */\n     protected Order newValueOrder(FieldMetaData owner, boolean asc) {\n-        return new InMemoryValueOrder(asc);\n+        return new InMemoryValueOrder(asc, getConfiguration());\n     }\n \n     /**\n      * Order by a field of the related type.\n      */\n     protected Order newRelatedFieldOrder(FieldMetaData owner,\n         FieldMetaData rel, boolean asc) {\n-        return new InMemoryRelatedFieldOrder(rel, asc);\n+        return new InMemoryRelatedFieldOrder(rel, asc, getConfiguration());\n     }\n \n     /**"},{"sha":"b64e8cda6eee4f4060cd1af60674b02e5f72799d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java","status":"modified","additions":7,"deletions":4,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -249,10 +249,13 @@ public static Object replaceFailedObject(Object ob) {\n      * <code>null</code> otherwise.\n      */\n     private static Object getObjectId(Object ob) {\n-        if (ob instanceof PersistenceCapable\n-            && !((PersistenceCapable) ob).pcIsNew())\n-            return ((PersistenceCapable) ob).pcFetchObjectId();\n+        if (!ImplHelper.isManageable(ob))\n+            return null;\n+\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(ob, null);\n+        if (pc == null || pc.pcIsNew())\n+            return null;\n         else\n-\t\t\treturn null;\n+            return pc.pcFetchObjectId();\n \t}\n }"},{"sha":"b057e9f9db575c818d14509e559526cfff8ad4cd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,75 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.util;\r\n+\r\n+import java.security.AccessController;\r\n+import java.security.PrivilegedActionException;\r\n+import java.lang.reflect.Constructor;\r\n+\r\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import serp.bytecode.BCClass;\r\n+import serp.bytecode.BCClassLoader;\r\n+\r\n+/**\r\n+ * Utility methods when generating classes, including at runtime.\r\n+ *\r\n+ * @since 1.0.0\r\n+ */\r\n+public class GeneratedClasses {\r\n+\r\n+    /**\r\n+     * Return the more derived loader of the class laoders for the given \r\n+     * classes.\r\n+     */\r\n+    public static ClassLoader getMostDerivedLoader(Class c1, Class c2) {\r\n+        ClassLoader l1 = (ClassLoader) AccessController.doPrivileged(\r\n+            J2DoPrivHelper.getClassLoaderAction(c1));\r\n+        ClassLoader l2 = (ClassLoader) AccessController.doPrivileged(\r\n+            J2DoPrivHelper.getClassLoaderAction(c2));\r\n+        if (l1 == l2)\r\n+            return l1;\r\n+        if (l1 == null)\r\n+            return l2;\r\n+        if (l2 == null)\r\n+            return l1;\r\n+\r\n+        for (ClassLoader p = (ClassLoader) AccessController.doPrivileged(\r\n+                J2DoPrivHelper.getParentAction(l1)); p != null;\r\n+                p = (ClassLoader) AccessController.doPrivileged(\r\n+                    J2DoPrivHelper.getParentAction(p)))\r\n+            if (p == l2)\r\n+                return l1;\r\n+        return l2;\r\n+    }\r\n+\r\n+    /**\r\n+     * Load the class represented by the given bytecode.\r\n+     */\r\n+    public static Class loadBCClass(BCClass bc, ClassLoader loader) {\r\n+        BCClassLoader bcloader = new BCClassLoader(bc.getProject(), loader);\r\n+        try {\r\n+            Class c = Class.forName(bc.getName(), true, bcloader);\r\n+            bc.getProject().clear();\r\n+            return c;\r\n+        } catch (Throwable t) {\r\n+            throw new GeneralException(bc.getName()).setCause(t);\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"bf502e30ad5da940e31331ec4833d613ff11b9f9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","status":"modified","additions":84,"deletions":3,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -26,6 +26,10 @@\n import java.util.Map;\n \n import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.enhance.PCRegistry;\n+import org.apache.openjpa.enhance.StateManager;\n+import org.apache.openjpa.enhance.ManagedInstanceProvider;\n+import org.apache.openjpa.enhance.ReflectingPersistenceCapable;\n import org.apache.openjpa.kernel.FetchConfiguration;\n import org.apache.openjpa.kernel.LockManager;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n@@ -42,6 +46,7 @@\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.meta.SequenceMetaData;\n import org.apache.openjpa.meta.ValueStrategies;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n \n /**\n  * Helper for OpenJPA back-ends.\n@@ -53,9 +58,32 @@\n public class ImplHelper {\n \n     // Cache for from/to type assignments\n-    private static ConcurrentReferenceHashMap _assignableTypes =\n+    private static final Map _assignableTypes =\n         new ConcurrentReferenceHashMap(ReferenceMap.WEAK, ReferenceMap.HARD);\n \n+    // map of all new unenhanced instances active in this classloader\n+    public static final Map _unenhancedInstanceMap =\n+        new ConcurrentReferenceHashMap(ReferenceMap.WEAK, ReferenceMap.HARD) {\n+\n+            protected boolean eq(Object x, Object y) {\n+                // the Entries in ConcurrentReferenceHashMap delegate back to\n+                // eq() in their equals() impls\n+                if (x instanceof Map.Entry)\n+                    return super.eq(x, y);\n+                else\n+                    return x == y;\n+            }\n+\n+            protected int hc(Object o) {\n+                // the Entries in ConcurrentReferenceHashMap delegate back to\n+                // hc() in their hashCode() impls\n+                if (o instanceof Map.Entry)\n+                    return super.hc(o);\n+                else\n+                    return System.identityHashCode(o);\n+            }\n+        };\n+\n     /**\n      * Helper for store manager implementations. This method simply delegates\n      * to the proper singular method for each state manager.\n@@ -185,7 +213,8 @@ public static void close(Object o) {\n      * @return true if the class is manageable.\n      */\n     public static boolean isManagedType(Class type) {\n-        return PersistenceCapable.class.isAssignableFrom(type);\n+        return PersistenceCapable.class.isAssignableFrom(type)\n+            || type != null && PCRegistry.isRegistered(type);\n     }\n \n     /**\n@@ -195,7 +224,8 @@ public static boolean isManagedType(Class type) {\n      * @return true if the instance is a persistent type, false otherwise\n      */\n     public static boolean isManageable(Object instance) {\n-        return instance instanceof PersistenceCapable;\n+        return instance instanceof PersistenceCapable\n+            || instance != null && PCRegistry.isRegistered(instance.getClass());\n     }\n \n     /**\n@@ -227,4 +257,55 @@ public static boolean isAssignable(Class from, Class to) {\n \n         return isAssignable.booleanValue();\n     }\n+\n+    /**\n+     * @return the persistence-capable instance responsible for managing\n+     * <code>o</code>, or <code>null</code> if <code>o</code> is not manageable.\n+     * @since 1.0.0\n+     */\n+    public static PersistenceCapable toPersistenceCapable(Object o, Object ctx){\n+        if (o instanceof PersistenceCapable)\n+            return (PersistenceCapable) o;\n+\n+        OpenJPAConfiguration conf = null;\n+        if (ctx instanceof OpenJPAConfiguration)\n+            conf = (OpenJPAConfiguration) ctx;\n+        else if (ctx instanceof StateManager\n+            && ((StateManager) ctx).getGenericContext() instanceof StoreContext)\n+            conf = ((StoreContext) ((StateManager) ctx).getGenericContext())\n+                .getConfiguration();\n+\n+        if (!isManageable(o))\n+            return null;\n+\n+        // if we had a putIfAbsent() method, we wouldn't need to sync here\n+        synchronized (o) {\n+            PersistenceCapable pc = (PersistenceCapable)\n+                _unenhancedInstanceMap.get(o);\n+\n+            if (pc != null)\n+                return pc;\n+\n+            // if we don't have a conf passed in, then we can't create a new\n+            // ReflectingPC; this will only be the case when invoked from a\n+            // context outside of OpenJPA.\n+            if (conf == null)\n+                return null;\n+\n+            pc = new ReflectingPersistenceCapable(o, conf);\n+            _unenhancedInstanceMap.put(o, pc);\n+            return pc;\n+        }\n+    }\n+\n+    /**\n+     * @return the user-visible representation of <code>o</code>.\n+     * @since 1.0.0\n+     */\n+    public static Object getManagedInstance(Object o) {\n+        if (o instanceof ManagedInstanceProvider)\n+            return ((ManagedInstanceProvider) o).getManagedInstance();\n+        else\n+            return o;\n+    }\n }"},{"sha":"db8991bdf2086d2d2702a9e146f579733f1e5a39","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","status":"modified","additions":37,"deletions":63,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -56,12 +56,12 @@\n import org.apache.openjpa.lib.util.Options;\n import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n import serp.bytecode.BCClass;\n-import serp.bytecode.BCClassLoader;\n import serp.bytecode.BCField;\n import serp.bytecode.BCMethod;\n import serp.bytecode.Code;\n import serp.bytecode.JumpInstruction;\n import serp.bytecode.Project;\n+import serp.bytecode.BCClassLoader;\n import serp.util.Strings;\n \n /**\n@@ -364,10 +364,12 @@ private ProxyCollection getFactoryProxyCollection(Class type) {\n         // we don't lock here; ok if two proxies get generated for same type\n         ProxyCollection proxy = (ProxyCollection) _proxies.get(type);\n         if (proxy == null) {\n-            ClassLoader l = getMostDerivedLoader(type, ProxyCollection.class);\n+            ClassLoader l = GeneratedClasses.getMostDerivedLoader(type,\n+                ProxyCollection.class);\n             Class pcls = loadBuildTimeProxy(type, l);\n             if (pcls == null)\n-                pcls = loadProxy(generateProxyCollectionBytecode(type, true),l);\n+                pcls = GeneratedClasses.loadBCClass(\n+                    generateProxyCollectionBytecode(type, true), l);\n             proxy = (ProxyCollection) instantiateProxy(pcls, null, null);\n             _proxies.put(type, proxy);\n         }\n@@ -381,10 +383,12 @@ private ProxyMap getFactoryProxyMap(Class type) {\n         // we don't lock here; ok if two proxies get generated for same type\n         ProxyMap proxy = (ProxyMap) _proxies.get(type);\n         if (proxy == null) {\n-            ClassLoader l = getMostDerivedLoader(type, ProxyMap.class);\n+            ClassLoader l = GeneratedClasses.getMostDerivedLoader(type,\n+                ProxyMap.class);\n             Class pcls = loadBuildTimeProxy(type, l);\n             if (pcls == null)\n-                pcls = loadProxy(generateProxyMapBytecode(type, true), l);\n+                pcls = GeneratedClasses.loadBCClass(\n+                    generateProxyMapBytecode(type, true), l);\n             proxy = (ProxyMap) instantiateProxy(pcls, null, null);\n             _proxies.put(type, proxy);\n         }\n@@ -398,10 +402,12 @@ private ProxyDate getFactoryProxyDate(Class type) {\n         // we don't lock here; ok if two proxies get generated for same type\n         ProxyDate proxy = (ProxyDate) _proxies.get(type);\n         if (proxy == null) {\n-            ClassLoader l = getMostDerivedLoader(type, ProxyDate.class);\n+            ClassLoader l = GeneratedClasses.getMostDerivedLoader(type,\n+                ProxyDate.class);\n             Class pcls = loadBuildTimeProxy(type, l);\n             if (pcls == null)\n-                pcls = loadProxy(generateProxyDateBytecode(type, true), l);\n+                pcls = GeneratedClasses.loadBCClass(\n+                    generateProxyDateBytecode(type, true), l);\n             proxy = (ProxyDate) instantiateProxy(pcls, null, null);\n             _proxies.put(type, proxy);\n         }\n@@ -415,10 +421,12 @@ private ProxyCalendar getFactoryProxyCalendar(Class type) {\n         // we don't lock here; ok if two proxies get generated for same type\n         ProxyCalendar proxy = (ProxyCalendar) _proxies.get(type);\n         if (proxy == null) {\n-            ClassLoader l = getMostDerivedLoader(type, ProxyCalendar.class);\n+            ClassLoader l = GeneratedClasses.getMostDerivedLoader(type,\n+                ProxyCalendar.class);\n             Class pcls = loadBuildTimeProxy(type, l);\n             if (pcls == null)\n-                pcls = loadProxy(generateProxyCalendarBytecode(type, true), l);\n+                pcls = GeneratedClasses.loadBCClass(\n+                    generateProxyCalendarBytecode(type, true), l);\n             proxy = (ProxyCalendar) instantiateProxy(pcls, null, null);\n             _proxies.put(type, proxy);\n         }\n@@ -436,15 +444,16 @@ private ProxyBean getFactoryProxyBean(Object orig) {\n         // we don't lock here; ok if two proxies get generated for same type\n         ProxyBean proxy = (ProxyBean) _proxies.get(type);\n         if (proxy == null && !_proxies.containsKey(type)) {\n-            ClassLoader l = getMostDerivedLoader(type, ProxyBean.class);\n+            ClassLoader l = GeneratedClasses.getMostDerivedLoader(type,\n+                ProxyBean.class);\n             Class pcls = loadBuildTimeProxy(type, l);\n             if (pcls == null) {\n                 BCClass bc = generateProxyBeanBytecode(type, true);\n                 if (bc != null)\n-                    pcls = loadProxy(bc, l);\n+                    pcls = GeneratedClasses.loadBCClass(bc, l);\n             }\n             if (pcls != null)\n-                proxy = (ProxyBean) instantiateProxy(pcls, \n+                proxy = (ProxyBean) instantiateProxy(pcls,\n                     findCopyConstructor(type), new Object[] {orig});\n             _proxies.put(type, proxy);\n         }\n@@ -475,20 +484,6 @@ protected Class loadBuildTimeProxy(Class type, ClassLoader loader) {\n         }\n     }\n \n-    /**\n-     * Load the proxy class represented by the given bytecode.\n-     */\n-    private Class loadProxy(BCClass bc, ClassLoader loader) {\n-        BCClassLoader bcloader = new BCClassLoader(bc.getProject(), loader);\n-        try {\n-            Class c = Class.forName(bc.getName(), true, bcloader);\n-            bc.getProject().clear();\n-            return c;\n-        } catch (Throwable t) {\n-            throw new GeneralException(bc.getName()).setCause(t);\n-        }\n-    }\n-\n     /**\n      * Instantiate the given proxy class.\n      */\n@@ -500,12 +495,12 @@ private Proxy instantiateProxy(Class cls, Constructor cons, Object[] args) {\n             return (Proxy) AccessController.doPrivileged(\n                 J2DoPrivHelper.newInstanceAction(cls));\n         } catch (InstantiationException ie) {\n-            throw new UnsupportedException(_loc.get(\"cant-newinstance\", \n+            throw new UnsupportedException(_loc.get(\"cant-newinstance\",\n                 cls.getSuperclass().getName()));\n         } catch (PrivilegedActionException pae) {\n             Exception e = pae.getException();\n             if (e instanceof InstantiationException)\n-                throw new UnsupportedException(_loc.get(\"cant-newinstance\", \n+                throw new UnsupportedException(_loc.get(\"cant-newinstance\",\n                     cls.getSuperclass().getName()));\n             else\n                 throw new GeneralException(cls.getName()).setCause(e);\n@@ -514,31 +509,6 @@ private Proxy instantiateProxy(Class cls, Constructor cons, Object[] args) {\n         }\n     }\n \n-    /**\n-     * Return the more derived loader of the class laoders for the given \n-     * classes.\n-     */\n-    private static ClassLoader getMostDerivedLoader(Class c1, Class c2) {\n-        ClassLoader l1 = (ClassLoader) AccessController.doPrivileged(\n-            J2DoPrivHelper.getClassLoaderAction(c1)); \n-        ClassLoader l2 = (ClassLoader) AccessController.doPrivileged(\n-            J2DoPrivHelper.getClassLoaderAction(c2)); \n-        if (l1 == l2)\n-            return l1;\n-        if (l1 == null)\n-            return l2;\n-        if (l2 == null)\n-            return l1;\n-        \n-        for (ClassLoader p = (ClassLoader) AccessController.doPrivileged(\n-                J2DoPrivHelper.getParentAction(l1)); p != null;\n-                p = (ClassLoader) AccessController.doPrivileged(\n-                    J2DoPrivHelper.getParentAction(p)))\n-            if (p == l2)\n-                return l1;\n-        return l2;\n-    }\n-\n     /**\n      * Generate the bytecode for a collection proxy for the given type.\n      */\n@@ -551,7 +521,7 @@ protected BCClass generateProxyCollectionBytecode(Class type,\n         bc.declareInterface(ProxyCollection.class);\n  \n         delegateConstructors(bc, type);\n-        addProxyMethods(bc, type, false);\n+        addProxyMethods(bc, false);\n         addProxyCollectionMethods(bc, type);\n         proxyRecognizedMethods(bc, type, ProxyCollections.class, \n             ProxyCollection.class);\n@@ -588,7 +558,7 @@ protected BCClass generateProxyMapBytecode(Class type, boolean runtime) {\n         bc.declareInterface(ProxyMap.class);\n  \n         delegateConstructors(bc, type);\n-        addProxyMethods(bc, type, false);\n+        addProxyMethods(bc, false);\n         addProxyMapMethods(bc, type);\n         proxyRecognizedMethods(bc, type, ProxyMaps.class, ProxyMap.class);\n         proxySetters(bc, type);\n@@ -607,7 +577,7 @@ protected BCClass generateProxyDateBytecode(Class type, boolean runtime) {\n         bc.declareInterface(ProxyDate.class);\n  \n         delegateConstructors(bc, type);\n-        addProxyMethods(bc, type, true);\n+        addProxyMethods(bc, true);\n         addProxyDateMethods(bc, type);\n         proxySetters(bc, type);\n         addWriteReplaceMethod(bc, runtime);\n@@ -626,7 +596,7 @@ protected BCClass generateProxyCalendarBytecode(Class type,\n         bc.declareInterface(ProxyCalendar.class);\n  \n         delegateConstructors(bc, type);\n-        addProxyMethods(bc, type, true);\n+        addProxyMethods(bc, true);\n         addProxyCalendarMethods(bc, type);\n         proxySetters(bc, type);\n         addWriteReplaceMethod(bc, runtime);\n@@ -660,7 +630,7 @@ protected BCClass generateProxyBeanBytecode(Class type, boolean runtime) {\n         bc.declareInterface(ProxyBean.class);\n  \n         delegateConstructors(bc, type);\n-        addProxyMethods(bc, type, true);\n+        addProxyMethods(bc, true);\n         addProxyBeanMethods(bc, type, cons);\n         if (!proxySetters(bc, type))\n             return null;\n@@ -699,8 +669,7 @@ private void delegateConstructors(BCClass bc, Class type) {\n      * @param changeTracker whether to implement a null change tracker; if false\n      * the change tracker method is left unimplemented\n      */\n-    private void addProxyMethods(BCClass bc, Class type, \n-        boolean changeTracker) {\n+    private void addProxyMethods(BCClass bc, boolean changeTracker) {\n         BCField sm = bc.declareField(\"sm\", OpenJPAStateManager.class);\n         sm.setTransient(true);\n         BCField field = bc.declareField(\"field\", int.class);\n@@ -1631,9 +1600,14 @@ public static void main(String[] args)\n         BCClass bc;\n         for (int i = 0; i < types.size(); i++) {\n             cls = Class.forName((String) types.get(i));\n-            if (mgr.loadBuildTimeProxy(cls, getMostDerivedLoader(cls, \n-                Proxy.class)) != null)\n-                continue;\n+            try {\n+                if (Class.forName(getProxyClassName(cls, false), true,\n+                    GeneratedClasses.getMostDerivedLoader(cls, Proxy.class))\n+                    != null)\n+                    continue;\n+            } catch (Throwable t) {\n+                // expected if the class hasn't been generated\n+            }\n \n             if (Collection.class.isAssignableFrom(cls))\n                 bc = mgr.generateProxyCollectionBytecode(cls, false);         "},{"sha":"5bfc6f8056561358b8b87f2cd40e898e96edf735","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties","status":"modified","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -38,6 +38,17 @@ detach-custom-extern: Type \"{0}\" is set to detach on serialize, but implements \\\n \ta custom readExternal and/or writeExternal method.  You cannot use custom \\\n \tserialization with detachment. \n enhance-start: Enhancing type \"{0}\".\n+enhance-and-subclass-and-redef-start: Creating subclass and redefining methods \\\n+    for \"{0}\". This means that your application will be less efficient \\\n+    than it would if you ran the OpenJPA enhancer.\n+enhance-and-subclass-no-redef-start: Creating subclass for \"{0}\". \\\n+    This means that your application will be less efficient and will consume \\\n+    more memory than it would if you ran the OpenJPA enhancer. Additionally, \\\n+    lazy loading will not be available for one-to-one and many-to-one \\\n+    persistent attributes in types using field access; they will be loaded \\\n+    eagerly instead.\n+redefine-types: Redefining {0} using Java 5 type redefinition.\n+retransform-types: Redefining {0} using Java 6 type retransformation.\n pc-type: Type \"{0}\" is already persistence capable; skipping.\n pers-aware: Type \"{0}\" has no metadata; enhancing as persistence aware. \\\n \tIf you intended for \"{0}\" to be persistence-capable, then this means that \\\n@@ -121,3 +132,58 @@ property-setter-getter-mismatch: Bytecode analysis of the setter and getter \\\n \tfield \"{1}\", while the getter method returns field \"{2}\".\n cft-exception-thrown: An exception was thrown while attempting to perform \\\n \tclass file transformation on \"{0}\":\n+subclasser-error-field: Error while processing persistent field {1}, declared \\\n+\tin {2}. Error details: {0}\n+subclasser-error-meta: Error while processing persistent type {1}, declared \\\n+\tin {2}. Error details: {0}\n+subclasser-contract-violation-field: Possible violation of subclassing contract\\\n+\tdetected while processing persistent field {1}, declared in {2}. Are you \\\n+\tsure you are obeying the OpenJPA requirements? Details: {0}\n+subclasser-setter-getter-field-mismatch: Mismatch between getter and setter.\n+subclasser-no-ifaces: OpenJPA does not currently support automatic handling of \\\n+    interface types. Failed type: {0}\n+subclasser-no-final-classes: OpenJPA cannot dynamically subclass final types. \\\n+    To use final types, you must run the OpenJPA enhancer after compilation, \\\n+    or deploy to an environment that supports deploy-time enhancement, such as \\\n+    a Java EE 5 application server. Failed type: {0}\n+subclasser-no-private-classes: OpenJPA cannot dynamically subclass final types.\\\n+    To use final types, you must run the OpenJPA enhancer after compilation, \\\n+    or deploy to an environment that supports deploy-time enhancement, such as \\\n+    a Java EE 5 application server. Failed type: {0}\n+subclasser-super-already-pc: The superclass for type {0} implements \\\n+    org.apache.openjpa.enhance.PersistenceCapable, which means that it was \\\n+    processed by the OpenJPA enhancer. If you are enhancing some of your \\\n+    persistent types, you must enhance all of them.\n+subclasser-private-ctor: Unenhanced classes must have a public or protected \\\n+    no-args constructor. Type {0}'s no-args constructor is private or \\\n+    package-visible. If you do not want to add such a constructor, you must\\\n+    run the OpenJPA enhancer after compilation, \\\n+    or deploy to an environment that supports deploy-time enhancement, such as \\\n+    a Java EE 5 application server.\n+subclasser-no-void-ctor: Unenhanced classes must have a public or protected \\\n+    no-args constructor. Type {0} does not have any no-args constructors. \\\n+    If you do not want to add such a constructor, you must \\\n+    run the OpenJPA enhancer after compilation, \\\n+    or deploy to an environment that supports deploy-time enhancement, such as \\\n+    a Java EE 5 application server.\n+subclasser-class-already-pc: Type {0} is already persistence-capable. Please \\\n+    report this problem to the OpenJPA team at dev@openjpa.apache.org.\n+subclasser-no-getter: No getter exists for field {0}.\n+subclasser-no-setter: No setter exists for field {0}.\n+subclasser-invalid-getter: The getter for field {0} does not obey OpenJPA's \\\n+    subclassing restrictions. Getters must return a single non-computed field.\n+subclasser-invalid-setter: The setter for field {0} does not obey OpenJPA's \\\n+    subclassing restrictions. Setters must assign the passed-in parameter to a \\\n+    single field in the object.\n+subclasser-private-accessors-unsupported: The accessor for field {1} in type \\\n+    {0} is private or package-visible. OpenJPA requires accessors in \\\n+    unenhanced instances to be public or protected. \\\n+    If you do not want to add such an accessor, you must run the OpenJPA \\\n+    enhancer after compilation, or deploy to an environment that supports \\\n+    deploy-time enhancement, such as a Java EE 5 application server.\n+subclasser-final-methods-not-allowed: The method {1} in type {0} is final. \\\n+    OpenJPA requires methods in unenhanced instances to be non-final.\n+subclasser-native-methods-not-allowed: The method {1} in type {0} is native. \\\n+    OpenJPA requires methods in unenhanced instances to be non-native.\n+subclasser-static-methods-not-supported: The method {1} in type {0} is static. \\\n+    OpenJPA requires methods in unenhanced instances to be non-static."},{"sha":"ddfcd7ec0621b4d035c5de09a290b2694f27ca98","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/jpql/localizer.properties","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/jpql/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/jpql/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/jpql/localizer.properties?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -55,3 +55,5 @@ unknown-identifier: Undeclared identifier \"{0}\".\n update-constant-value: Update expression \"{0}\" may only use literals \\\n \tor parameters as update values.\n bad-parse: Encountered \"{0}\" at character {1}, but expected: {2}.\n+no-saved-fields: No state snapshot is available for \"{0}\", but this instance \\\n+    uses state-comparison for dirty detection."},{"sha":"cc473f0d52b6df04a581d92174c0abd60abaf039","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -169,7 +169,8 @@ no-pk: Concrete type \"{0}\" with application identity does not declare any \\\n \tprimary key fields.\n invalid-id: The id class specified by type \"{0}\" does not match the \\\n \tprimary key fields of the class.  Make sure your identity class has the \\\n-\tsame primary keys as your persistent type.  Mismatched property: \"{1}\"\n+\tsame primary keys as your persistent type, including pk field types. \\\n+    Mismatched property: \"{1}\"\n null-cons: The id class specified by type \"{0}\" does not have public a \\\n \tno-args constructor.\n hc-method: The identity class specified by type \"{0}\" is not valid, as the \\"},{"sha":"4cd90e616ff2c22bf2db31f6807d855ae280ade3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java","status":"modified","additions":0,"deletions":18,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -601,22 +601,4 @@ public Object run() {\n             }\n         };\n     }\n-\n-    /**\n-     * Return a PrivilegeAction object for bcClass.isInstanceOf().\n-     * \n-     * Requires security policy:\n-     *   'permission java.lang.RuntimePermission \"getClassLoader\";'\n-     *   \n-     * @return Boolean\n-     */\n-    public static final PrivilegedAction isInstanceOfAction(\n-        final BCClass bcClass, final Class clazz) {\n-        return new PrivilegedAction() {\n-            public Object run() {\n-                return bcClass.isInstanceOf(clazz) ? Boolean.TRUE\n-                    : Boolean.FALSE;\n-            }\n-        };\n-    }\n }"},{"sha":"0c6a8ddac5d1e560ba5762cbc23d75281f94d8c2","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap.java","status":"modified","additions":27,"deletions":10,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -105,10 +105,27 @@\n      */\n     private int maxSize = Integer.MAX_VALUE;\n \n-    private static boolean eq(Object x, Object y) {\n+    /**\n+     * Compare two objects. These might be keys, values, or Entry instances.\n+     * This implementation uses a normal null-safe object equality algorithm.\n+     *\n+     * @since 1.0.0\n+     */\n+    protected boolean eq(Object x, Object y) {\n         return x == y || (x != null && x.equals(y));\n     }\n \n+    /**\n+     * Obtain the hashcode of an object. The object might be a key, a value,\n+     * or an Entry. This implementation just delegates to\n+     * {@link Object#hashCode}\n+     *\n+     * @since 1.0.0\n+     */\n+    protected int hc(Object o) {\n+        return o == null ? 0 : o.hashCode();\n+    }\n+\n     /**\n      * Constructs a new, empty HashMap with the specified initial\n      * capacity and the specified load factor.\n@@ -251,7 +268,7 @@ public boolean containsKey(Object key) {\n             return false;\n \n         Entry[] tab = table;\n-        int hash = (key == null) ? 0 : key.hashCode();\n+        int hash = hc(key);\n         int index = (hash & 0x7FFFFFFF) % tab.length;\n         for (Entry e = tab[index]; e != null; e = e.getNext())\n             if (e.getHash() == hash && eq(key, e.getKey()))\n@@ -270,7 +287,7 @@ public Object get(Object key) {\n             return null;\n \n         Entry[] tab = table;\n-        int hash = (key == null) ? 0 : key.hashCode();\n+        int hash = hc(key);\n         int index = (hash & 0x7FFFFFFF) % tab.length;\n         for (Entry e = tab[index]; e != null; e = e.getNext())\n             if ((e.getHash() == hash) && eq(key, e.getKey()))\n@@ -331,7 +348,7 @@ public Object put(Object key, Object value) {\n             || (value == null && valueType != HARD))\n             throw new IllegalArgumentException(\"Null references not supported\");\n \n-        int hash = (key == null) ? 0 : key.hashCode();\n+        int hash = hc(key);\n         synchronized (this) {\n             expungeStaleEntries();\n \n@@ -413,7 +430,7 @@ public Object remove(Object key) {\n         if (key == null && keyType != HARD)\n             return null;\n \n-        int hash = (key == null) ? 0 : key.hashCode();\n+        int hash = hc(key);\n         synchronized (this) {\n             expungeStaleEntries();\n \n@@ -662,7 +679,7 @@ public boolean contains(Object o) {\n                     Map.Entry entry = (Map.Entry) o;\n                     Object key = entry.getKey();\n                     Entry[] tab = table;\n-                    int hash = (key == null ? 0 : key.hashCode());\n+                    int hash = hc(key);\n                     int index = (hash & 0x7FFFFFFF) % tab.length;\n \n                     for (Entry e = tab[index]; e != null; e = e.getNext())\n@@ -678,7 +695,7 @@ public boolean remove(Object o) {\n                     Object key = entry.getKey();\n                     synchronized (ConcurrentReferenceHashMap.this) {\n                         Entry[] tab = table;\n-                        int hash = (key == null ? 0 : key.hashCode());\n+                        int hash = hc(key);\n                         int index = (hash & 0x7FFFFFFF) % tab.length;\n \n                         for (Entry e = tab[index], prev = null; e != null;\n@@ -757,7 +774,7 @@ private void expungeStaleEntries() {\n     /**\n      * Hard entry.\n      */\n-    private static class HardEntry implements Entry {\n+    private class HardEntry implements Entry {\n \n         private int hash;\n         private Object key;\n@@ -829,7 +846,7 @@ public String toString() {\n     /**\n      * Weak entry.\n      */\n-    private static class WeakEntry extends WeakReference implements Entry {\n+    private class WeakEntry extends WeakReference implements Entry {\n \n         private int hash;\n         private Object hard;\n@@ -902,7 +919,7 @@ public String toString() {\n     /**\n      * Soft entry.\n      */\n-    private static class SoftEntry extends SoftReference implements Entry {\n+    private class SoftEntry extends SoftReference implements Entry {\n \n         private int hash;\n         private Object hard;"},{"sha":"3e5b8424e9f157e07c38774a69a096e55fa00a86","filename":"openjpa-persistence-jdbc/pom.xml","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/pom.xml?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -399,6 +399,8 @@\n                                     dir=\"${project.build.testOutputDirectory}\">\n                                     <include name=\"**/*.class\"/>\n                                     <exclude name=\"**/inheritance/serializable/*.class\"/>\n+                                    <exclude name=\"**/xml/*.class\"/>\n+                                    <exclude name=\"**/Unenhanced*.class\"/>\n                                 </fileset>\n                                 <openjpac>\n                                     <classpath refid=\"cp\"/>"},{"sha":"b499917769e68dc16584b5016c26f59a2d4421b3","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","status":"added","additions":458,"deletions":0,"changes":458,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,458 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.ByteArrayOutputStream;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ByteArrayInputStream;\r\n+import java.util.List;\r\n+import java.util.Collections;\r\n+import java.lang.reflect.Field;\r\n+\r\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\r\n+import org.apache.openjpa.persistence.OpenJPAPersistence;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n+\r\n+public abstract class AbstractUnenhancedClassTest\r\n+    extends SingleEMFTestCase {\r\n+\r\n+    // ##### To do:\r\n+    // - clearing in pnew property-access without redefinition\r\n+    // - lazy loading override for -to-one field types\r\n+    // - figure out how to auto-test the redefinition code, either in Java 5\r\n+    //   or in Java 6\r\n+    // - run CTS in the following combinations:\r\n+    //   * Java 6\r\n+    //   * Java 5 with javaagent\r\n+    //   * Java 5 without javaagent\r\n+\r\n+    public void setUp() {\r\n+        setUp(getUnenhancedClass(), getUnenhancedSubclass(), CLEAR_TABLES,\r\n+            \"openjpa.Log\", \"Enhance=TRACE\");\r\n+        // trigger class redefinition\r\n+        emf.createEntityManager().close();\r\n+    }\r\n+\r\n+    protected abstract Class<? extends UnenhancedType> getUnenhancedClass();\r\n+\r\n+    protected abstract UnenhancedType newUnenhancedInstance();\r\n+\r\n+    protected abstract Class<? extends UnenhancedSubtype> getUnenhancedSubclass();\r\n+\r\n+    protected abstract UnenhancedSubtype newUnenhancedSubclassInstance();\r\n+\r\n+    public void testMetaData() {\r\n+        ClassMetaData meta = OpenJPAPersistence.getMetaData(emf,\r\n+            getUnenhancedClass());\r\n+        assertEquals(ClassRedefiner.canRedefineClasses(),\r\n+            meta.isIntercepting());\r\n+    }\r\n+\r\n+    public void testImplHelperCalls() {\r\n+        assertTrue(ImplHelper.isManagedType(getUnenhancedClass()));\r\n+\r\n+        UnenhancedType un = newUnenhancedInstance();\r\n+        assertFalse(un instanceof PersistenceCapable);\r\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(un,\r\n+            emf.getConfiguration());\r\n+        assertNotNull(pc);\r\n+        assertTrue(ImplHelper.isManageable(un));\r\n+    }\r\n+\r\n+    public void testBasicPersistenceCapableBehavior() {\r\n+        UnenhancedType un = newUnenhancedInstance();\r\n+        un.setStringField(\"bar\");\r\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(un,\r\n+            emf.getConfiguration());\r\n+        assertFalse(pc.pcIsDeleted());\r\n+        assertFalse(pc.pcIsDirty());\r\n+        assertFalse(pc.pcIsNew());\r\n+        assertFalse(pc.pcIsPersistent());\r\n+        assertFalse(pc.pcIsTransactional());\r\n+    }\r\n+\r\n+    public void testPCRegistry() {\r\n+        assertTrue(PCRegistry.isRegistered(getUnenhancedClass()));\r\n+        PersistenceCapable pc = PCRegistry.newInstance(\r\n+            getUnenhancedClass(), null, false);\r\n+        assertNotNull(pc);\r\n+    }\r\n+\r\n+    public void testClearingOnSubtypeInstance() {\r\n+        // the boolean at the end of newInstance will cause clear to be invoked\r\n+        UnenhancedType un = (UnenhancedType)\r\n+            PCRegistry.newInstance(getUnenhancedClass(), null, true);\r\n+        assertEquals(null, un.getStringField());\r\n+    }\r\n+\r\n+    public void testGetObjectIdOnOpenJPAType() {\r\n+        getObjectIdHelper(true, false);\r\n+    }\r\n+\r\n+    public void testGetObjectIdOnOpenJPATypeSubclass() {\r\n+        getObjectIdHelper(false, false);\r\n+    }\r\n+\r\n+    public void testGetObjectIdOnUserDefined() {\r\n+        getObjectIdHelper(true, true);\r\n+    }\r\n+\r\n+    public void testGetObjectIdOnUserDefinedSubclass() {\r\n+        getObjectIdHelper(false, true);\r\n+    }\r\n+\r\n+    private void getObjectIdHelper(boolean sub, boolean userDefined) {\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        em.getTransaction().begin();\r\n+        UnenhancedType un = newInstance(sub);\r\n+        em.persist(un);\r\n+        em.getTransaction().commit();\r\n+\r\n+        if (!userDefined) {\r\n+            em.close();\r\n+            em = emf.createEntityManager();\r\n+            un = em.find(getUnenhancedClass(), un.getId());\r\n+        }\r\n+\r\n+        assertNotNull(em.getObjectId(un));\r\n+    }\r\n+\r\n+    public void testOperations() {\r\n+        opsHelper(false);\r\n+    }\r\n+\r\n+    public void testSubclassOperations() {\r\n+        opsHelper(true);\r\n+    }\r\n+\r\n+    private void opsHelper(boolean sub) {\r\n+        OpenJPAEntityManager em = null;\r\n+        try {\r\n+            UnenhancedType un = newInstance(sub);\r\n+            em = emf.createEntityManager();\r\n+\r\n+            em.getTransaction().begin();\r\n+            em.persist(un);\r\n+            un.setStringField(\"bar\");\r\n+            assertEquals(\"bar\", un.getStringField());\r\n+            em.flush();\r\n+            assertTrue(un.getId() != 0);\r\n+            UnenhancedType un2 = em.find(getUnenhancedClass(), un.getId());\r\n+            assertSame(un, un2);\r\n+            em.getTransaction().commit();\r\n+            un2 = em.find(getUnenhancedClass(), un.getId());\r\n+            assertSame(un, un2);\r\n+            em.close();\r\n+\r\n+            em = emf.createEntityManager();\r\n+            un = em.find(getUnenhancedClass(), un.getId());\r\n+            assertNotNull(un);\r\n+            assertTrue(un instanceof PersistenceCapable);\r\n+            assertEquals(\"bar\", un.getStringField());\r\n+            em.getTransaction().begin();\r\n+            un.setStringField(\"baz\");\r\n+            assertEquals(\"baz\", un.getStringField());\r\n+\r\n+            if (sub)\r\n+                ((UnenhancedSubtype) un).setIntField(17);\r\n+\r\n+            assertTrue(em.isDirty(un));\r\n+            \r\n+            em.getTransaction().commit();\r\n+            em.close();\r\n+\r\n+            em = emf.createEntityManager();\r\n+            un = em.find(getUnenhancedClass(), un.getId());\r\n+            assertNotNull(un);\r\n+            assertTrue(un instanceof PersistenceCapable);\r\n+            assertEquals(\"baz\", un.getStringField());\r\n+            if (sub)\r\n+                assertEquals(17, ((UnenhancedSubtype) un).getIntField());\r\n+            em.close();\r\n+        } finally {\r\n+            if (em != null && em.getTransaction().isActive())\r\n+                em.getTransaction().rollback();\r\n+            if (em != null && em.isOpen())\r\n+                em.close();\r\n+        }\r\n+    }\r\n+\r\n+    public void testRelations() {\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        em.getTransaction().begin();\r\n+        UnenhancedSubtype un = newUnenhancedSubclassInstance();\r\n+        em.persist(un);\r\n+        un.setStringField(\"aoeu\");\r\n+        UnenhancedSubtype related = newUnenhancedSubclassInstance();\r\n+        un.setRelated(related);\r\n+        related.setStringField(\"snth\");\r\n+        em.getTransaction().commit();\r\n+        em.close();\r\n+\r\n+        em = emf.createEntityManager();\r\n+        un = (UnenhancedSubtype) em.find(getUnenhancedClass(), un.getId());\r\n+        assertEquals(\"aoeu\", un.getStringField());\r\n+        assertNotNull(un.getRelated());\r\n+        assertEquals(\"snth\", un.getRelated().getStringField());\r\n+        em.close();\r\n+    }\r\n+\r\n+    public void testEnhancer() throws IOException {\r\n+        List<Class> subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\r\n+            emf.getConfiguration(),\r\n+            Collections.singleton(getUnenhancedClass()), null);\r\n+        Class sub = subs.get(0);\r\n+        assertNotNull(sub);\r\n+        assertEquals(\"org.apache.openjpa.enhance.\"\r\n+            + getUnenhancedClass().getName().replace('.', '$') + \"$pcsubclass\",\r\n+            sub.getName());\r\n+        assertTrue(PersistenceCapable.class.isAssignableFrom(sub));\r\n+        assertTrue(getUnenhancedClass().isAssignableFrom(sub));\r\n+    }\r\n+\r\n+    public void testPCSubclassName() {\r\n+        assertEquals(\"org.apache.openjpa.enhance.\"\r\n+            + getUnenhancedClass().getName().replace('.', '$') + \"$pcsubclass\",\r\n+            PCEnhancer.toPCSubclassName(getUnenhancedClass()));\r\n+    }\r\n+\r\n+    public void testLazyLoadingInUserCreatedInstance()\r\n+        throws NoSuchFieldException, IllegalAccessException {\r\n+        lazyLoading(true);\r\n+    }\r\n+\r\n+    public void testLazyLoadingInOpenJPACreatedInstance()\r\n+        throws NoSuchFieldException, IllegalAccessException {\r\n+        lazyLoading(false);\r\n+    }\r\n+\r\n+    private void lazyLoading(boolean userDefined)\r\n+        throws NoSuchFieldException, IllegalAccessException {\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        UnenhancedType un = newUnenhancedInstance();\r\n+        em.getTransaction().begin();\r\n+        em.persist(un);\r\n+        em.getTransaction().commit();\r\n+\r\n+        if (!userDefined) {\r\n+            em.close();\r\n+            em = emf.createEntityManager();\r\n+            un = em.find(getUnenhancedClass(), un.getId());\r\n+            assertTrue(getUnenhancedClass() != un.getClass());\r\n+        }\r\n+\r\n+        em.evict(un);\r\n+        OpenJPAStateManager sm = (OpenJPAStateManager)\r\n+            ImplHelper.toPersistenceCapable(un, null).pcGetStateManager();\r\n+\r\n+        // we only expect lazy loading to work when we can redefine classes\r\n+        // or when accessing a property-access record that OpenJPA created.\r\n+        if (ClassRedefiner.canRedefineClasses()\r\n+            || (!userDefined && sm.getMetaData().getAccessType()\r\n+                != ClassMetaData.ACCESS_FIELD)) {\r\n+\r\n+            assertFalse(sm.getLoaded()\r\n+                .get(sm.getMetaData().getField(\"stringField\").getIndex()));\r\n+\r\n+            // make sure that the value was cleared...\r\n+            Field field = getUnenhancedClass().getDeclaredField(\r\n+                this instanceof TestUnenhancedFieldAccess\r\n+                    ? \"stringField\" : \"sf\");\r\n+            field.setAccessible(true);\r\n+            assertEquals(null, field.get(un));\r\n+\r\n+            // ... and that it gets reloaded properly\r\n+            assertEquals(\"foo\", un.getStringField());\r\n+            assertTrue(sm.getLoaded()\r\n+                .get(sm.getMetaData().getField(\"stringField\").getIndex()));\r\n+        } else {\r\n+            // unredefined properties with user-defined instance, or any\r\n+            // unredefined field access\r\n+            assertTrue(sm.getLoaded()\r\n+                .get(sm.getMetaData().getField(\"stringField\").getIndex()));\r\n+\r\n+            // make sure that the value was not cleared\r\n+            Field field = getUnenhancedClass().getDeclaredField(\r\n+                this instanceof TestUnenhancedFieldAccess\r\n+                    ? \"stringField\" : \"sf\");\r\n+            field.setAccessible(true);\r\n+            assertEquals(\"foo\", field.get(un));\r\n+        }\r\n+\r\n+        em.close();\r\n+    }\r\n+\r\n+    public void testSerializationOfUserDefinedInstance()\r\n+        throws IOException, ClassNotFoundException {\r\n+        serializationHelper(true, false);\r\n+    }\r\n+\r\n+    public void testSerializationOfUserDefinedSubclassInstance()\r\n+        throws IOException, ClassNotFoundException {\r\n+        serializationHelper(true, true);\r\n+    }\r\n+\r\n+    public void testSerializationOfOpenJPADefinedInstance()\r\n+        throws IOException, ClassNotFoundException {\r\n+        serializationHelper(false, false);\r\n+    }\r\n+\r\n+    public void testSerializationOfOpenJPADefinedSubclassInstance()\r\n+        throws IOException, ClassNotFoundException {\r\n+        serializationHelper(false, true);\r\n+    }\r\n+\r\n+    private void serializationHelper(boolean userDefined, boolean sub)\r\n+        throws IOException, ClassNotFoundException {\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        UnenhancedType un = newInstance(sub);\r\n+        em.getTransaction().begin();\r\n+        em.persist(un);\r\n+\r\n+        if (sub) {\r\n+            UnenhancedType related = newInstance(false);\r\n+            related.setStringField(\"related\");\r\n+            ((UnenhancedSubtype) un).setRelated(related);\r\n+        }\r\n+\r\n+        em.getTransaction().commit();\r\n+\r\n+        if (!userDefined) {\r\n+            em.close();\r\n+            em = emf.createEntityManager();\r\n+        }\r\n+\r\n+        un = em.find(getUnenhancedClass(), un.getId());\r\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n+        ObjectOutputStream oout = new ObjectOutputStream(out);\r\n+        oout.writeObject(un);\r\n+        oout.flush();\r\n+        byte[] bytes = out.toByteArray();\r\n+\r\n+        ObjectInputStream oin = new ObjectInputStream(\r\n+            new ByteArrayInputStream(bytes));\r\n+        UnenhancedType deserialized = (UnenhancedType) oin.readObject();\r\n+\r\n+        copiedInstanceHelper(sub, em, un, deserialized, false);\r\n+        em.close();\r\n+    }\r\n+\r\n+    public void testCloningOfUserDefinedInstance()\r\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n+        cloneHelper(true, false);\r\n+    }\r\n+\r\n+    public void testCloningOfUserDefinedSubclassInstance()\r\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n+        cloneHelper(true, true);\r\n+    }\r\n+\r\n+    public void testCloningOfOpenJPADefinedInstance()\r\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n+        cloneHelper(false, false);\r\n+    }\r\n+\r\n+    public void testCloningOfOpenJPADefinedSubclassInstance()\r\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n+        cloneHelper(false, true);\r\n+    }\r\n+\r\n+    private void cloneHelper(boolean userDefined, boolean sub)\r\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        UnenhancedType un = newInstance(sub);\r\n+        em.getTransaction().begin();\r\n+        em.persist(un);\r\n+\r\n+        if (sub) {\r\n+            UnenhancedType related = newInstance(false);\r\n+            related.setStringField(\"related\");\r\n+            ((UnenhancedSubtype) un).setRelated(related);\r\n+        }\r\n+\r\n+        em.getTransaction().commit();\r\n+\r\n+        if (!userDefined) {\r\n+            em.close();\r\n+            em = emf.createEntityManager();\r\n+        }\r\n+\r\n+        un = em.find(getUnenhancedClass(), un.getId());\r\n+        UnenhancedType cloned = (UnenhancedType) un.clone();\r\n+\r\n+        copiedInstanceHelper(sub, em, un, cloned, true);\r\n+        em.close();\r\n+    }\r\n+\r\n+    private void copiedInstanceHelper(boolean sub, OpenJPAEntityManager em,\r\n+        UnenhancedType un, UnenhancedType copy, boolean viaClone) {\r\n+        assertNotSame(un, copy);\r\n+        if (!viaClone)\r\n+            assertEquals(sub ? getUnenhancedSubclass() : getUnenhancedClass(),\r\n+                copy.getClass());\r\n+        assertEquals(un.getId(), copy.getId());\r\n+        assertEquals(un.getStringField(), copy.getStringField());\r\n+        if (sub) {\r\n+            assertEquals(\r\n+                ((UnenhancedSubtype) un).getIntField(),\r\n+                ((UnenhancedSubtype) copy).getIntField());\r\n+            assertNotSame(\r\n+                ((UnenhancedSubtype) un).getRelated(),\r\n+                ((UnenhancedSubtype) copy).getRelated());\r\n+            assertEquals(\r\n+                ((UnenhancedSubtype) un).getRelated().getId(),\r\n+                ((UnenhancedSubtype) copy).getRelated().getId());\r\n+        }\r\n+\r\n+        assertFalse(em.isDetached(un));\r\n+        assertTrue(em.isDetached(copy));\r\n+        copy.setStringField(\"offline update\");\r\n+\r\n+        em.getTransaction().begin();\r\n+        assertSame(un, em.merge(copy));\r\n+        assertTrue(em.isDirty(un));\r\n+        assertEquals(\"offline update\", un.getStringField());\r\n+        em.getTransaction().commit();\r\n+    }\r\n+\r\n+    private UnenhancedType newInstance(boolean sub) {\r\n+        return sub ? newUnenhancedSubclassInstance()\r\n+            : newUnenhancedInstance();\r\n+    }\r\n+\r\n+    public void testGetMetaDataOfSubtype() {\r\n+        ClassMetaData meta = OpenJPAPersistence.getMetaData(emf,\r\n+            getUnenhancedClass());\r\n+        List<Class> subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\r\n+            emf.getConfiguration(),\r\n+            Collections.singleton(getUnenhancedClass()), null);\r\n+        assertSame(meta, OpenJPAPersistence.getMetaData(emf, subs.get(0)));\r\n+\r\n+        meta = OpenJPAPersistence.getMetaData(emf, getUnenhancedSubclass());\r\n+        subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\r\n+            emf.getConfiguration(),\r\n+            Collections.singleton(getUnenhancedSubclass()), null);\r\n+        assertSame(meta, OpenJPAPersistence.getMetaData(emf, subs.get(0)));\r\n+    }\r\n+}\n\\ No newline at end of file"},{"sha":"797db3557a9166cf9b7b6a0329a168d02c3f0956","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,75 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import org.apache.openjpa.persistence.test.SingleEMTestCase;\r\n+\r\n+public class TestUnenhancedCompoundPK\r\n+    extends SingleEMTestCase {\r\n+\r\n+    public void setUp() {\r\n+        setUp(UnenhancedCompoundPKFieldAccess.class,\r\n+            UnenhancedCompoundPKPropertyAccess.class, CLEAR_TABLES);\r\n+    }\r\n+\r\n+    public void testCompoundPKFieldAccessUserDefined() {\r\n+        UnenhancedCompoundPKFieldAccess un\r\n+            = new UnenhancedCompoundPKFieldAccess(17, 31);\r\n+        UnenhancedCompoundPKFieldAccess.PK oid\r\n+            = new UnenhancedCompoundPKFieldAccess.PK(17, 31);\r\n+        compoundPKHelper(un, oid, true);\r\n+    }\r\n+\r\n+    public void testCompoundPKFieldAccessOpenJPADefined() {\r\n+        UnenhancedCompoundPKFieldAccess un\r\n+            = new UnenhancedCompoundPKFieldAccess(17, 31);\r\n+        UnenhancedCompoundPKFieldAccess.PK oid\r\n+            = new UnenhancedCompoundPKFieldAccess.PK(17, 31);\r\n+        compoundPKHelper(un, oid, false);\r\n+    }\r\n+\r\n+    public void testCompoundPKPropertyAccessUserDefined() {\r\n+        UnenhancedCompoundPKPropertyAccess un\r\n+            = new UnenhancedCompoundPKPropertyAccess(17, 31);\r\n+        UnenhancedCompoundPKPropertyAccess.PK oid\r\n+            = new UnenhancedCompoundPKPropertyAccess.PK(17, 31);\r\n+        compoundPKHelper(un, oid, true);\r\n+    }\r\n+\r\n+    public void testCompoundPKPropertyAccessOpenJPADefined() {\r\n+        UnenhancedCompoundPKPropertyAccess un\r\n+            = new UnenhancedCompoundPKPropertyAccess(17, 31);\r\n+        UnenhancedCompoundPKPropertyAccess.PK oid\r\n+            = new UnenhancedCompoundPKPropertyAccess.PK(17, 31);\r\n+        compoundPKHelper(un, oid, false);\r\n+    }\r\n+\r\n+    private void compoundPKHelper(Object o, Object oid, boolean userDefined) {\r\n+        em.getTransaction().begin();\r\n+        em.persist(o);\r\n+        em.getTransaction().commit();\r\n+\r\n+        if (!userDefined) {\r\n+            em.close();\r\n+            em = emf.createEntityManager();\r\n+        }\r\n+\r\n+        em.find(o.getClass(), oid);\r\n+    }\r\n+}\n\\ No newline at end of file"},{"sha":"dc4877e799fb5b6a8f39c980cee00eb53ea80aad","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,39 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+public class TestUnenhancedFieldAccess\r\n+    extends AbstractUnenhancedClassTest {\r\n+\r\n+    protected Class<? extends UnenhancedType> getUnenhancedClass() {\r\n+        return UnenhancedFieldAccess.class;\r\n+    }\r\n+\r\n+    protected UnenhancedType newUnenhancedInstance() {\r\n+        return new UnenhancedFieldAccess();\r\n+    }\r\n+\r\n+    protected Class<? extends UnenhancedSubtype> getUnenhancedSubclass() {\r\n+        return UnenhancedFieldAccessSubclass.class;\r\n+    }\r\n+\r\n+    protected UnenhancedSubtype newUnenhancedSubclassInstance() {\r\n+        return new UnenhancedFieldAccessSubclass();\r\n+    }\r\n+}\r"},{"sha":"b743cf9cb5757e025524bb3e7c20cd93bc05d121","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,39 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+public class TestUnenhancedPropertyAccess\r\n+    extends AbstractUnenhancedClassTest {\r\n+\r\n+    protected Class<? extends UnenhancedType> getUnenhancedClass() {\r\n+        return UnenhancedPropertyAccess.class;\r\n+    }\r\n+\r\n+    protected UnenhancedType newUnenhancedInstance() {\r\n+        return new UnenhancedPropertyAccess();\r\n+    }\r\n+\r\n+    protected Class<? extends UnenhancedSubtype> getUnenhancedSubclass() {\r\n+        return UnenhancedPropertyAccessSubclass.class;\r\n+    }\r\n+\r\n+    protected UnenhancedSubtype newUnenhancedSubclassInstance() {\r\n+        return new UnenhancedPropertyAccessSubclass();\r\n+    }\r\n+}\n\\ No newline at end of file"},{"sha":"35d23c2ba242ad312eb8232b9191b2df2b4e3743","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,87 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import javax.persistence.Entity;\r\n+import javax.persistence.IdClass;\r\n+import javax.persistence.Id;\r\n+\r\n+import org.apache.openjpa.enhance.UnenhancedCompoundPKFieldAccess.PK;\r\n+\r\n+@Entity\r\n+@IdClass(PK.class)\r\n+public class UnenhancedCompoundPKFieldAccess {\r\n+\r\n+    @Id private int id0;\r\n+    @Id private int id1;\r\n+\r\n+    protected UnenhancedCompoundPKFieldAccess() {\r\n+    }\r\n+\r\n+    public UnenhancedCompoundPKFieldAccess(\r\n+        int i0, int i1) {\r\n+        id0 = i0;\r\n+        id1 = i1;\r\n+    }\r\n+\r\n+    public static class PK {\r\n+        static {\r\n+            // register persistent class in JVM\r\n+            try {\r\n+                Class.forName(UnenhancedCompoundPKFieldAccess.class.getName());\r\n+            } catch (Exception e) {\r\n+                // ignore\r\n+            }\r\n+        }\r\n+\r\n+        public int id0;\r\n+        public int id1;\r\n+\r\n+        public PK() {\r\n+        }\r\n+\r\n+        public PK(int i0, int i1) {\r\n+            id0 = i0;\r\n+            id1 = i1;\r\n+        }\r\n+\r\n+        public String toString() {\r\n+            return String.valueOf(id0)\r\n+                + \"::\" + String.valueOf(id1);\r\n+        }\r\n+\r\n+        public int hashCode() {\r\n+            int rs = 17;\r\n+            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\r\n+            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\r\n+            return rs;\r\n+        }\r\n+\r\n+        public boolean equals(Object obj) {\r\n+            if(this == obj)\r\n+                return true;\r\n+            if(obj == null || obj.getClass() != getClass())\r\n+                return false;\r\n+\r\n+            PK other = (PK) obj;\r\n+            return (id0 == other.id0)\r\n+                && (id1 == other.id1);\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"e69da157aadd2b652de6b25d2606f7c3f899eae6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","status":"added","additions":122,"deletions":0,"changes":122,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,122 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import javax.persistence.Entity;\r\n+import javax.persistence.IdClass;\r\n+import javax.persistence.Id;\r\n+\r\n+import org.apache.openjpa.enhance.UnenhancedCompoundPKPropertyAccess.PK;\r\n+\r\n+@Entity\r\n+@IdClass(PK.class)\r\n+public class UnenhancedCompoundPKPropertyAccess {\r\n+\r\n+    private int id0;\r\n+    private int id1;\r\n+\r\n+    protected UnenhancedCompoundPKPropertyAccess() {\r\n+    }\r\n+\r\n+    public UnenhancedCompoundPKPropertyAccess(\r\n+        int i0, int i1) {\r\n+        id0 = i0;\r\n+        id1 = i1;\r\n+    }\r\n+\r\n+    @Id\r\n+    public int getId0() {\r\n+        return id0;\r\n+    }\r\n+\r\n+    public void setId0(int id0) {\r\n+        this.id0 = id0;\r\n+    }\r\n+\r\n+    @Id\r\n+    public int getId1() {\r\n+        return id1;\r\n+    }\r\n+\r\n+    public void setId1(int id1) {\r\n+        this.id1 = id1;\r\n+    }\r\n+\r\n+    public static class PK {\r\n+        static {\r\n+            // register persistent class in JVM\r\n+            try {\r\n+                Class.forName(\r\n+                    UnenhancedCompoundPKPropertyAccess.class.getName());\r\n+            } catch (Exception e) {\r\n+                // ignore\r\n+            }\r\n+        }\r\n+\r\n+        public int id0;\r\n+        public int id1;\r\n+\r\n+        public PK() {\r\n+        }\r\n+\r\n+        public PK(int i0, int i1) {\r\n+            id0 = i0;\r\n+            id1 = i1;\r\n+        }\r\n+\r\n+        public int getId0() {\r\n+            return id0;\r\n+        }\r\n+\r\n+        public void setId0(int id0) {\r\n+            this.id0 = id0;\r\n+        }\r\n+\r\n+        public int getId1() {\r\n+            return id1;\r\n+        }\r\n+\r\n+        public void setId1(int id1) {\r\n+            this.id1 = id1;\r\n+        }\r\n+\r\n+        public String toString() {\r\n+            return String.valueOf(id0)\r\n+                + \"::\" + String.valueOf(id1);\r\n+        }\r\n+\r\n+        public int hashCode() {\r\n+            int rs = 17;\r\n+            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\r\n+            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\r\n+            return rs;\r\n+        }\r\n+\r\n+        public boolean equals(Object obj) {\r\n+            if(this == obj)\r\n+                return true;\r\n+            if(obj == null || obj.getClass() != getClass())\r\n+                return false;\r\n+\r\n+            PK other = (PK) obj;\r\n+            return (id0 == other.id0)\r\n+                && (id1 == other.id1);\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"d2a372a44d87a0e4b1632799074a67fd338840eb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,72 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.io.Serializable;\r\n+import javax.persistence.Entity;\r\n+import javax.persistence.Version;\r\n+import javax.persistence.Id;\r\n+import javax.persistence.GeneratedValue;\r\n+import javax.persistence.Inheritance;\r\n+import javax.persistence.InheritanceType;\r\n+import javax.persistence.Table;\r\n+\r\n+import org.apache.openjpa.persistence.DetachedState;\r\n+\r\n+@Entity\r\n+@Table(name=\"UN_FIELD\")\r\n+@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r\n+public class UnenhancedFieldAccess\r\n+    implements UnenhancedType, Serializable, Cloneable {\r\n+    \r\n+    @Id @GeneratedValue private int id;\r\n+    @Version public int version;\r\n+    protected String stringField = \"foo\";\r\n+\r\n+    public int getId() {\r\n+        return id;\r\n+    }\r\n+\r\n+    public void setStringField(String s) {\r\n+        stringField = s;\r\n+    }\r\n+\r\n+    public String getStringField() {\r\n+        return stringField;\r\n+    }\r\n+\r\n+    public boolean equals(Object o) {\r\n+        if (o == this)\r\n+            return true;\r\n+        if (o == null)\r\n+            return false;\r\n+        if (!getClass().isAssignableFrom(o.getClass()))\r\n+            return false;\r\n+\r\n+        return id == ((UnenhancedFieldAccess) o).id;\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return id;\r\n+    }\r\n+\r\n+    public Object clone() throws CloneNotSupportedException {\r\n+        return super.clone();\r\n+    }\r\n+}\r"},{"sha":"26e8ee34d1f5b9a5673bb918d552194703821448","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,56 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import javax.persistence.OneToOne;\r\n+import javax.persistence.Entity;\r\n+import javax.persistence.CascadeType;\r\n+\r\n+@Entity\r\n+public class UnenhancedFieldAccessSubclass\r\n+    extends UnenhancedFieldAccess \r\n+    implements UnenhancedSubtype {\r\n+\r\n+    @OneToOne(cascade = CascadeType.ALL)\r\n+    private UnenhancedFieldAccess related;\r\n+    private int intField;\r\n+\r\n+    public UnenhancedType getRelated() {\r\n+        return related;\r\n+    }\r\n+\r\n+    public void setRelated(UnenhancedType related) {\r\n+        this.related = (UnenhancedFieldAccess) related;\r\n+    }\r\n+\r\n+    public void setIntField(int i) {\r\n+        intField = i;\r\n+    }\r\n+\r\n+    public int getIntField() {\r\n+        return intField;\r\n+    }\r\n+\r\n+    public Object clone() throws CloneNotSupportedException {\r\n+        UnenhancedFieldAccessSubclass un =\r\n+            (UnenhancedFieldAccessSubclass) super.clone();\r\n+        un.setRelated((UnenhancedType) getRelated().clone());\r\n+        return un;\r\n+    }\r\n+}\r"},{"sha":"6eca1f82fce642ea19adfcf47b89d3a226cfa393","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","status":"added","additions":88,"deletions":0,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,88 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.io.Serializable;\r\n+import javax.persistence.Entity;\r\n+import javax.persistence.Version;\r\n+import javax.persistence.Id;\r\n+import javax.persistence.GeneratedValue;\r\n+import javax.persistence.Basic;\r\n+import javax.persistence.Inheritance;\r\n+import javax.persistence.InheritanceType;\r\n+import javax.persistence.Table;\r\n+\r\n+import org.apache.openjpa.persistence.DetachedState;\r\n+\r\n+@Entity\r\n+@Table(name=\"UN_PROP\")\r\n+@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r\n+public class UnenhancedPropertyAccess\r\n+    implements UnenhancedType, Serializable, Cloneable {\r\n+\r\n+    private int id;\r\n+    private int version;\r\n+    private String sf = \"foo\";\r\n+\r\n+    @Id @GeneratedValue\r\n+    public int getId() {\r\n+        return id;\r\n+    }\r\n+\r\n+    public void setId(int id) {\r\n+        this.id = id;\r\n+    }\r\n+\r\n+    @Version\r\n+    protected int getVersion() {\r\n+        return version;\r\n+    }\r\n+\r\n+    protected void setVersion(int v) {\r\n+        version = v;\r\n+    }\r\n+\r\n+    public void setStringField(String s) {\r\n+        sf = s;\r\n+    }\r\n+\r\n+    @Basic\r\n+    public String getStringField() {\r\n+        return sf;\r\n+    }\r\n+\r\n+    public boolean equals(Object o) {\r\n+        if (o == this)\r\n+            return true;\r\n+        if (o == null)\r\n+            return false;\r\n+        if (!getClass().isAssignableFrom(o.getClass()))\r\n+            return false;\r\n+\r\n+        return getId() == ((UnenhancedPropertyAccess) o).getId();\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return getId();\r\n+    }\r\n+\r\n+    public Object clone() throws CloneNotSupportedException {\r\n+        return super.clone();\r\n+    }\r\n+}\n\\ No newline at end of file"},{"sha":"72b464b43ae741bbd3d1db7504da9256a4b0f541","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,60 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import javax.persistence.OneToOne;\r\n+import javax.persistence.Transient;\r\n+import javax.persistence.Entity;\r\n+import javax.persistence.CascadeType;\r\n+\r\n+import org.apache.openjpa.persistence.Type;\r\n+\r\n+@Entity\r\n+public class UnenhancedPropertyAccessSubclass\r\n+    extends UnenhancedPropertyAccess\r\n+    implements UnenhancedSubtype {\r\n+\r\n+    private UnenhancedPropertyAccess related;\r\n+    private int intField;\r\n+\r\n+    @OneToOne(cascade = CascadeType.ALL)\r\n+    @Type(UnenhancedPropertyAccess.class)\r\n+    public UnenhancedType getRelated() {\r\n+        return related;\r\n+    }\r\n+\r\n+    public void setRelated(UnenhancedType related) {\r\n+        this.related = (UnenhancedPropertyAccess) related;\r\n+    }\r\n+\r\n+    public void setIntField(int i) {\r\n+        intField = i;\r\n+    }\r\n+\r\n+    public int getIntField() {\r\n+        return intField;\r\n+    }\r\n+\r\n+    public Object clone() throws CloneNotSupportedException {\r\n+        UnenhancedPropertyAccessSubclass un =\r\n+            (UnenhancedPropertyAccessSubclass) super.clone();\r\n+        un.setRelated((UnenhancedType) getRelated().clone());\r\n+        return un;\r\n+    }\r\n+}\r"},{"sha":"4530db7c5d60cc6764105e84f0976abb5ca622a9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,31 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+public interface UnenhancedSubtype\r\n+    extends UnenhancedType {\r\n+\r\n+    UnenhancedType getRelated();\r\n+\r\n+    void setRelated(UnenhancedType related);\r\n+\r\n+    void setIntField(int i);\r\n+\r\n+    int getIntField();\r\n+}\r"},{"sha":"b7c75169ab9b9b8b9ad69cecb1253e98d1b26734","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -0,0 +1,31 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+/**\r\n+ * Used in {@link AbstractUnenhancedClassTest}\r\n+ */\r\n+public interface UnenhancedType {\r\n+\r\n+    void setStringField(String s);\r\n+    String getStringField();\r\n+    int getId();\r\n+\r\n+    Object clone() throws CloneNotSupportedException;\r\n+}\r"},{"sha":"a4e07c6dc56d24cd64e925ed2053e054e3759c4f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -751,7 +751,7 @@ private void parseDetachedState(ClassMetaData meta,\n         if (detached != null) {\n             if (!detached.enabled())\n                 meta.setDetachedState(null);\n-            else if (!StringUtils.isEmpty(detached.fieldName()))\n+            else if (StringUtils.isEmpty(detached.fieldName()))\n                 meta.setDetachedState(ClassMetaData.SYNTHETIC);\n             else\n                 meta.setDetachedState(detached.fieldName());"},{"sha":"7a0153bbe0cf62f389004f5a79c09e2c8f71c20b","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManager.java","status":"modified","additions":4,"deletions":6,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManager.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManager.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -887,12 +887,10 @@\n      * JavaBeans convention, this method will create a concrete implementation\n      * according to the metadata that defines the class. If <code>cls</code>\n      * is a non-final concrete type that has metadata but does not implement\n-     * {@link org.apache.openjpa.enhance.PersistenceCapable}, this method will create a\n-     * subclass of the type that does implement\n-     * {@link org.apache.openjpa.enhance.PersistenceCapable},\n-     * following the property-based persistent attribute access rules, or\n-     * will raise an exception if the class does not meet the requirements\n-     * for subclassing. Otherwise, this will return an instance of the\n+     * {@link PersistenceCapable}, this method will create a subclass of the\n+     * type that does implement {@link PersistenceCapable}, and will attempt\n+     * to redefine the methods in <code>cls</code> to enable persistent\n+     * attribute tracking. Otherwise, this will return an instance of the\n      * specified class.\n      */\n     public <T> T createInstance(Class<T> cls);"},{"sha":"0a3bd39ef3f604ba6fe6d2a00e3cd92249184d54","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java","status":"modified","additions":7,"deletions":4,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java","raw_url":"https://github.com/apache/openjpa/raw/747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java?ref=747226b1d6dc6d57fd28332b4c2a4b0c4ad7a59c","patch":"@@ -273,9 +273,11 @@ public static OpenJPAEntityManagerFactory getEntityManagerFactory(Map map) {\n      */\n     public static OpenJPAEntityManager getEntityManager(Object o) {\n         try {\n-            if (o instanceof PersistenceCapable)\n-                return toEntityManager((Broker) ((PersistenceCapable) o).\n-                    pcGetGenericContext());\n+            if (ImplHelper.isManageable(o)) {\n+                PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+                if (pc != null)\n+                    return toEntityManager((Broker) pc.pcGetGenericContext());\n+            }\n             return null;\n         } catch (Exception e) {\n             throw PersistenceExceptions.toPersistenceException(e);\n@@ -290,7 +292,8 @@ public static ClassMetaData getMetaData(Object o) {\n         if (o == null)\n             return null;\n         EntityManager em = getEntityManager(o);\n-        return (em == null) ? null : getMetaData(em, o.getClass());\n+        return (em == null) ? null : getMetaData(em,\n+            ImplHelper.getManagedInstance(o).getClass());\n     }\n \n     /**"}]}

