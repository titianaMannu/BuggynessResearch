{"sha":"75cf4c522f41e6dfcbac89a2905498085d7f728e","node_id":"MDY6Q29tbWl0MjA2MzY0Ojc1Y2Y0YzUyMmY0MWU2ZGZjYmFjODlhMjkwNTQ5ODA4NWQ3ZjcyOGU=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-02-26T20:20:44Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-02-26T20:20:44Z"},"message":"OPENJPA-825: A new threading policy for Slice via extension\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@748292 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"524629b58c4441ff16630c26f11a45d316975c97","url":"https://api.github.com/repos/apache/openjpa/git/trees/524629b58c4441ff16630c26f11a45d316975c97"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/75cf4c522f41e6dfcbac89a2905498085d7f728e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/75cf4c522f41e6dfcbac89a2905498085d7f728e","html_url":"https://github.com/apache/openjpa/commit/75cf4c522f41e6dfcbac89a2905498085d7f728e","comments_url":"https://api.github.com/repos/apache/openjpa/commits/75cf4c522f41e6dfcbac89a2905498085d7f728e/comments","author":null,"committer":null,"parents":[{"sha":"bcfb4e9c8379ec26d2c86876cdf34edc37e1979c","url":"https://api.github.com/repos/apache/openjpa/commits/bcfb4e9c8379ec26d2c86876cdf34edc37e1979c","html_url":"https://github.com/apache/openjpa/commit/bcfb4e9c8379ec26d2c86876cdf34edc37e1979c"}],"stats":{"total":403,"additions":265,"deletions":138},"files":[{"sha":"6c2cdcf06cdefe42b9350610d42a6895ff3adf47","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java","status":"modified","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java?ref=75cf4c522f41e6dfcbac89a2905498085d7f728e","patch":"@@ -21,6 +21,8 @@\n import org.apache.openjpa.kernel.FinalizingBrokerImpl;\r\n import org.apache.openjpa.kernel.OpCallbacks;\r\n import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.kernel.QueryImpl;\r\n+import org.apache.openjpa.kernel.StoreQuery;\r\n import org.apache.openjpa.lib.util.Localizer;\r\n \r\n /**\r\n@@ -37,9 +39,16 @@\n public class DistributedBrokerImpl extends FinalizingBrokerImpl {\r\n \tprivate transient String _rootSlice;\r\n \tprivate transient DistributedConfiguration _conf;\r\n+\tprivate final ReentrantSliceLock _lock;\r\n+\t\r\n \tprivate static final Localizer _loc =\r\n \t\t\tLocalizer.forPackage(DistributedBrokerImpl.class);\r\n \r\n+\tpublic DistributedBrokerImpl() {\r\n+\t    super();\r\n+\t    _lock = new ReentrantSliceLock();\r\n+\t}\r\n+\t\r\n     public DistributedConfiguration getConfiguration() {\r\n     \tif (_conf == null) {\r\n     \t\t_conf = (DistributedConfiguration)super.getConfiguration();\r\n@@ -89,6 +98,26 @@ public boolean endOperation() {\n \t    return true;\r\n \t}\r\n \t\r\n+    /**\r\n+     * Create a new query.\r\n+     */\r\n+    protected QueryImpl newQueryImpl(String lang, StoreQuery sq) {\r\n+        return new DistributedQueryImpl(this, lang, sq);\r\n+    }\r\n+    \r\n+\t/**\r\n+\t * Always uses lock irrespective of super's multi-threaded settings.\r\n+\t */\r\n+    @Override\r\n+    public void lock() {\r\n+        _lock.lock();\r\n+    }\r\n+    \r\n+    @Override\r\n+    public void unlock() {\r\n+        _lock.unlock();\r\n+    }\r\n+\t\r\n \t/**\r\n \t * A virtual datastore need not be opened.\r\n \t */\r"},{"sha":"02d45c445afd5e785792c371a5de9e3b4d2cc9cd","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedQueryImpl.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedQueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedQueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedQueryImpl.java?ref=75cf4c522f41e6dfcbac89a2905498085d7f728e","patch":"@@ -0,0 +1,50 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice;\r\n+\r\n+import org.apache.openjpa.kernel.Broker;\r\n+import org.apache.openjpa.kernel.QueryImpl;\r\n+import org.apache.openjpa.kernel.StoreQuery;\r\n+\r\n+/**\r\n+ * Extension with slice locking policy.\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ *\r\n+ */\r\n+public class DistributedQueryImpl extends QueryImpl {\r\n+    private final ReentrantSliceLock _lock;\r\n+    public DistributedQueryImpl(Broker broker, String language, StoreQuery storeQuery) {\r\n+        super(broker, language, storeQuery);\r\n+        _lock = new ReentrantSliceLock();\r\n+    }\r\n+    \r\n+    /**\r\n+     * Always uses lock irrespective of super's multi-threaded settings.\r\n+     */\r\n+    @Override\r\n+    public void lock() {\r\n+        _lock.lock();\r\n+    }\r\n+    \r\n+    @Override\r\n+    public void unlock() {\r\n+        _lock.unlock();\r\n+    }\r\n+}\r"},{"sha":"a32a9cffe6ec8c769e380e0e4fa4966bbee7ea79","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/ExecutorServiceValue.java","status":"modified","additions":9,"deletions":15,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/ExecutorServiceValue.java","raw_url":"https://github.com/apache/openjpa/raw/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/ExecutorServiceValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/ExecutorServiceValue.java?ref=75cf4c522f41e6dfcbac89a2905498085d7f728e","patch":"@@ -62,6 +62,8 @@ public void setProperties(String props) {\n \r\n     /**\r\n      * Configures a cached or fixed thread pool.\r\n+     * The factory always produces SliceThread which uses special locking.\r\n+     * \r\n      */\r\n     @Override\r\n     public Object instantiate(Class type, Configuration conf, boolean fatal) {\r\n@@ -73,21 +75,7 @@ public Object instantiate(Class type, Configuration conf, boolean fatal) {\n \r\n         Options opts = Configurations.parseProperties(getProperties());\r\n \r\n-        ThreadFactory factory = null;\r\n-        if (opts.containsKey(\"ThreadFactory\")) {\r\n-            String fName = opts.getProperty(\"ThreadFactory\");\r\n-            try {\r\n-                factory = (ThreadFactory) Class.forName(fName).newInstance();\r\n-                Configurations.configureInstance(factory, conf, opts,\r\n-                        getProperty());\r\n-            } catch (Throwable t) {\r\n-                throw new UserException(_loc.get(\"bad-thread-factory\", fName), t);\r\n-            } finally {\r\n-                opts.removeProperty(\"ThreadFactory\");\r\n-            }\r\n-        } else {\r\n-            factory = Executors.defaultThreadFactory();\r\n-        }\r\n+        ThreadFactory factory = new SliceThreadFactory();\r\n         if (\"cached\".equals(cls)) {\r\n             obj = Executors.newCachedThreadPool(factory);\r\n         } else if (\"fixed\".equals(cls)) {\r\n@@ -105,4 +93,10 @@ public Object instantiate(Class type, Configuration conf, boolean fatal) {\n         set(obj, true);\r\n         return obj;\r\n     }\r\n+    \r\n+    private static class SliceThreadFactory implements ThreadFactory {\r\n+        public Thread newThread(Runnable r) {\r\n+            return new SliceThread(Thread.currentThread(), r);\r\n+        }\r\n+    }\r\n }\r"},{"sha":"cb6ee5d3eef82e51b414138ee0e2f648a2a4f7e4","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/ReentrantSliceLock.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/ReentrantSliceLock.java","raw_url":"https://github.com/apache/openjpa/raw/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/ReentrantSliceLock.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/ReentrantSliceLock.java?ref=75cf4c522f41e6dfcbac89a2905498085d7f728e","patch":"@@ -0,0 +1,57 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice;\r\n+\r\n+import java.util.concurrent.locks.ReentrantLock;\r\n+\r\n+/**\r\n+ * A reentrant lock that lets a child to work with the parent's lock.\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ *\r\n+ */\r\n+public class ReentrantSliceLock extends ReentrantLock {\r\n+\r\n+    public ReentrantSliceLock() {\r\n+    }\r\n+\r\n+    public ReentrantSliceLock(boolean fair) {\r\n+        super(fair);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Locks only for parent thread and let the child use parent's lock. \r\n+     */\r\n+    @Override\r\n+    public void lock() {\r\n+        if (Thread.currentThread() instanceof SliceThread) \r\n+            return;\r\n+        super.lock();\r\n+    }\r\n+\r\n+    /**\r\n+     * Unlocks only if parent thread. \r\n+     */\r\n+    @Override\r\n+    public void unlock() {\r\n+        if (Thread.currentThread() instanceof SliceThread) \r\n+            return;\r\n+        super.unlock();\r\n+    }\r\n+}\r"},{"sha":"3d1311c4aa9baa636c9c14b626717040f338d6c3","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceThread.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceThread.java","raw_url":"https://github.com/apache/openjpa/raw/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceThread.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceThread.java?ref=75cf4c522f41e6dfcbac89a2905498085d7f728e","patch":"@@ -0,0 +1,74 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice;\r\n+\r\n+import java.util.concurrent.ExecutorService;\r\n+import java.util.concurrent.SynchronousQueue;\r\n+import java.util.concurrent.ThreadFactory;\r\n+import java.util.concurrent.ThreadPoolExecutor;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+/**\r\n+ * A thread to execute operation against each database slice.\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ *\r\n+ */\r\n+public class SliceThread extends Thread {\r\n+    private final Thread _parent;\r\n+\r\n+    public SliceThread(String name, Thread parent, Runnable r) {\r\n+        super(r, name);\r\n+        _parent = parent;\r\n+    }\r\n+    \r\n+    public SliceThread(Thread parent, Runnable r) {\r\n+        super(r);\r\n+        _parent = parent;\r\n+    }\r\n+    \r\n+    /**\r\n+     * Gets the parent thread of this receiver.\r\n+     * \r\n+     */\r\n+    public Thread getParent() {\r\n+        return _parent;\r\n+    }\r\n+    \r\n+    /** \r\n+     * Create a pool of given size.\r\n+     * The thread factory is specialized to create SliceThread which gets\r\n+     * preferential treatment for locking.\r\n+     * \r\n+     */\r\n+\r\n+    public static ExecutorService newPool(int size) {\r\n+        return new ThreadPoolExecutor(size, size, 60L, TimeUnit.SECONDS, \r\n+            new SynchronousQueue<Runnable>(), new SliceThreadFactory());\r\n+    }\r\n+    \r\n+    static class SliceThreadFactory implements ThreadFactory {\r\n+        int n = 0;\r\n+        public Thread newThread(Runnable r) {\r\n+            Thread parent = Thread.currentThread();\r\n+            return new SliceThread(parent.getName()+\"-slice-\"+n++, parent, r);\r\n+        }\r\n+    }\r\n+\r\n+}\r"},{"sha":"eb28d8cf3ef817e192fcb9d72d7f3d5bb75f6417","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfiguration.java","status":"modified","additions":6,"deletions":18,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfiguration.java?ref=75cf4c522f41e6dfcbac89a2905498085d7f728e","patch":"@@ -18,34 +18,22 @@\n  */\r\n package org.apache.openjpa.slice.jdbc;\r\n \r\n-import java.util.concurrent.ExecutorService;\r\n-\r\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n import org.apache.openjpa.slice.DistributedConfiguration;\r\n import org.apache.openjpa.slice.Slice;\r\n \r\n /**\r\n- * A distributed configuration that is a ordered collection of \r\n+ * A distributed configuration that is a ordered collection of\r\n  * JDBCConfigurations.\r\n  * \r\n- * @author Pinaki Poddar \r\n- *\r\n+ * @author Pinaki Poddar\r\n+ * \r\n  */\r\n-public interface DistributedJDBCConfiguration extends JDBCConfiguration, \r\n-\tDistributedConfiguration {\r\n+public interface DistributedJDBCConfiguration extends JDBCConfiguration,\r\n+    DistributedConfiguration {\r\n     /**\r\n      * Gets the master slice.\r\n      */\r\n     Slice getMaster();\r\n-    \r\n-    /**\r\n-     * Gets the alias for ExecutorService being used.\r\n-     */\r\n-    \r\n-    String getExecutorService();\r\n-    \r\n-    /**\r\n-     * Gets the ExecutorService being used.\r\n-     */\r\n-    ExecutorService getExecutorServiceInstance();\r\n+\r\n }\r"},{"sha":"c5c6947c2cbe88b9d861fd967c923bfab8c6bd5e","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfigurationImpl.java","status":"modified","additions":0,"deletions":15,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfigurationImpl.java?ref=75cf4c522f41e6dfcbac89a2905498085d7f728e","patch":"@@ -477,19 +477,4 @@ private void setMaster(Map original) {\n             _master = activeSlices.get(0);\r\n         }\r\n     }\r\n-    \r\n-    public String getExecutorService() {\r\n-        return executorServicePlugin.getString();\r\n-    }\r\n-\r\n-    public void setExecutorService(ExecutorService txnManager) {\r\n-        executorServicePlugin.set(txnManager);\r\n-    }\r\n-\r\n-    public ExecutorService getExecutorServiceInstance() {\r\n-        if (executorServicePlugin.get() == null) {\r\n-            executorServicePlugin.instantiate(ExecutorService.class, this);\r\n-        }\r\n-        return (ExecutorService) executorServicePlugin.get();\r\n-    }    \r\n }\r"},{"sha":"7ea25fd176bcf46bdeaddbf44837d401dbf0fc67","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java","status":"modified","additions":13,"deletions":23,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java?ref=75cf4c522f41e6dfcbac89a2905498085d7f728e","patch":"@@ -59,6 +59,7 @@\n import org.apache.openjpa.slice.ProductDerivation;\r\n import org.apache.openjpa.slice.SliceImplHelper;\r\n import org.apache.openjpa.slice.SliceInfo;\r\n+import org.apache.openjpa.slice.SliceThread;\r\n import org.apache.openjpa.util.InternalException;\r\n import org.apache.openjpa.util.StoreException;\r\n \r\n@@ -78,7 +79,6 @@\n     private final DistributedJDBCConfiguration _conf;\r\n     private static final Localizer _loc =\r\n             Localizer.forPackage(DistributedStoreManager.class);\r\n-    private static ExecutorService threadPool = Executors.newCachedThreadPool();\r\n \r\n     /**\r\n      * Constructs a set of child StoreManagers each connected to a physical\r\n@@ -249,7 +249,7 @@ public Collection flush(Collection sms) {\n         Map<String, StateManagerSet> subsets = bin(sms, null);\r\n         Collection<StateManagerSet> remaining = \r\n             new ArrayList<StateManagerSet>(subsets.values());\r\n-        boolean parallel = !getConfiguration().getMultithreaded();\r\n+        ExecutorService threadPool = SliceThread.newPool(_slices.size());\r\n         for (int i = 0; i < _slices.size(); i++) {\r\n             SliceStoreManager slice = _slices.get(i);\r\n             StateManagerSet subset = subsets.get(slice.getName());\r\n@@ -262,24 +262,19 @@ public Collection flush(Collection sms) {\n                 remaining.remove(subset);\r\n             \trollbackVersion(subset.getReplicated(), oldVersions, remaining);\r\n             } else {\r\n-            \tif (parallel) {\r\n-            \t\tfutures.add(threadPool.submit(new Flusher(slice, subset)));\r\n-            \t} else {\r\n-                \tcollectException(slice.flush(subset), exceptions);\r\n-            \t}\r\n+            \tfutures.add(threadPool.submit(new Flusher(slice, subset)));\r\n             }\r\n         }\r\n-        if (parallel) {\r\n-\t        for (Future<Collection> future : futures) {\r\n-\t            try {\r\n-\t            \tcollectException(future.get(), exceptions);\r\n-\t            } catch (InterruptedException e) {\r\n-\t                throw new StoreException(e);\r\n-\t            } catch (ExecutionException e) {\r\n-\t                throw new StoreException(e.getCause());\r\n-\t            }\r\n-\t        }\r\n+        for (Future<Collection> future : futures) {\r\n+            try {\r\n+            \tcollectException(future.get(), exceptions);\r\n+            } catch (InterruptedException e) {\r\n+                throw new StoreException(e);\r\n+            } catch (ExecutionException e) {\r\n+                throw new StoreException(e.getCause());\r\n+            }\r\n         }\r\n+        \r\n \t    return exceptions;\r\n     }\r\n     \r\n@@ -498,12 +493,7 @@ protected RefCountConnection connectInternal() throws SQLException {\n         }\r\n \r\n         public Collection call() throws Exception {\r\n-        \t((BrokerImpl)store.getContext()).startLocking();\r\n-        \ttry {\r\n-        \t\treturn store.flush(toFlush);\r\n-        \t} finally {\r\n-            \t((BrokerImpl)store.getContext()).stopLocking();\r\n-        \t}\r\n+        \treturn store.flush(toFlush);\r\n         }\r\n     }\r\n     \r"},{"sha":"5b05ecc6504f92cc3bb0ce4ab3354ab9216844b6","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java","status":"modified","additions":20,"deletions":59,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java?ref=75cf4c522f41e6dfcbac89a2905498085d7f728e","patch":"@@ -25,6 +25,10 @@\n import java.util.concurrent.ExecutionException;\r\n import java.util.concurrent.ExecutorService;\r\n import java.util.concurrent.Future;\r\n+import java.util.concurrent.SynchronousQueue;\r\n+import java.util.concurrent.ThreadFactory;\r\n+import java.util.concurrent.ThreadPoolExecutor;\r\n+import java.util.concurrent.TimeUnit;\r\n \r\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\r\n import org.apache.openjpa.jdbc.kernel.JDBCStoreQuery;\r\n@@ -41,6 +45,7 @@\n import org.apache.openjpa.lib.rop.RangeResultObjectProvider;\r\n import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.slice.SliceThread;\r\n import org.apache.openjpa.util.StoreException;\r\n \r\n /**\r\n@@ -84,12 +89,6 @@ public void setContext(QueryContext ctx) {\n \t\t\tq.setContext(ctx);\r\n \t}\r\n \r\n-\tpublic ExecutorService getExecutorServiceInstance() {\r\n-\t\tDistributedJDBCConfiguration conf = ((DistributedJDBCConfiguration) \r\n-\t\t\tgetStore().getConfiguration());\r\n-\t\treturn conf.getExecutorServiceInstance();\r\n-\t}\r\n-\r\n \t/**\r\n \t * Executes queries on multiple databases.\r\n \t * \r\n@@ -100,16 +99,12 @@ public ExecutorService getExecutorServiceInstance() {\n \t\t\tExpressionStoreQuery.DataStoreExecutor {\r\n \t\tprivate List<Executor> executors = new ArrayList<Executor>();\r\n \t\tprivate DistributedStoreQuery owner = null;\r\n-\t\tprivate ExecutorService threadPool = null;\r\n-\t\tprivate final boolean parallel;\r\n \r\n \t\tpublic ParallelExecutor(DistributedStoreQuery dsq, ClassMetaData meta,\r\n \t\t\t\tboolean subclasses, ExpressionParser parser, Object parsed, \r\n \t\t\t\tboolean parallel) {\r\n \t\t\tsuper(dsq, meta, subclasses, parser, parsed);\r\n \t\t\towner = dsq;\r\n-\t\t\tthreadPool = dsq.getExecutorServiceInstance();\r\n-\t\t\tthis.parallel = parallel;\r\n \t\t}\r\n \r\n \t\tpublic void addExecutor(Executor ex) {\r\n@@ -130,6 +125,7 @@ public ResultObjectProvider executeQuery(StoreQuery q,\n \t\t\tList<SliceStoreManager> targets = findTargets();\r\n \t\t\tQueryContext ctx = q.getContext();\r\n \t\t\tboolean isReplicated = containsReplicated(ctx);\r\n+\t\t\tExecutorService threadPool = SliceThread.newPool(owner._queries.size());\r\n \t\t\tfor (int i = 0; i < owner._queries.size(); i++) {\r\n \t\t\t\t// if replicated, then execute only on single slice\r\n \t\t\t\tif (isReplicated && !usedExecutors.isEmpty()) {\r\n@@ -143,28 +139,23 @@ public ResultObjectProvider executeQuery(StoreQuery q,\n \t\t\t\tif (!targets.contains(sm))\r\n \t\t\t\t\tcontinue;\r\n \t\t\t\tusedExecutors.add(executor);\r\n-\t\t\t\tif (!parallel) {\r\n-\t\t\t\t\trops.add(executor.executeQuery(query, params, range));\r\n-\t\t\t\t} else {\r\n \t\t\t\t\tQueryExecutor call = new QueryExecutor();\r\n \t\t\t\t\tcall.executor = executor;\r\n \t\t\t\t\tcall.query = query;\r\n \t\t\t\t\tcall.params = params;\r\n \t\t\t\t\tcall.range = range;\r\n \t\t\t\t\tfutures.add(threadPool.submit(call));\r\n-\t\t\t\t}\r\n \t\t\t}\r\n-\t\t\tif (parallel) {\r\n-\t\t\t\tfor (Future<ResultObjectProvider> future : futures) {\r\n-\t\t\t\t\ttry {\r\n-\t\t\t\t\t\trops.add(future.get());\r\n-\t\t\t\t\t} catch (InterruptedException e) {\r\n-\t\t\t\t\t\tthrow new RuntimeException(e);\r\n-\t\t\t\t\t} catch (ExecutionException e) {\r\n-\t\t\t\t\t\tthrow new StoreException(e.getCause());\r\n-\t\t\t\t\t}\r\n+\t\t\tfor (Future<ResultObjectProvider> future : futures) {\r\n+\t\t\t\ttry {\r\n+\t\t\t\t\trops.add(future.get());\r\n+\t\t\t\t} catch (InterruptedException e) {\r\n+\t\t\t\t\tthrow new RuntimeException(e);\r\n+\t\t\t\t} catch (ExecutionException e) {\r\n+\t\t\t\t\tthrow new StoreException(e.getCause());\r\n \t\t\t\t}\r\n \t\t\t}\r\n+\t\t\t\r\n \t\t\tResultObjectProvider[] tmp = rops\r\n \t\t\t\t\t.toArray(new ResultObjectProvider[rops.size()]);\r\n \t\t\tResultObjectProvider result = null;\r\n@@ -214,6 +205,7 @@ public Number executeDelete(StoreQuery q, Object[] params) {\n \t\t\tIterator<StoreQuery> qs = owner._queries.iterator();\r\n \t\t\tList<Future<Number>> futures = null;\r\n \t\t\tint result = 0;\r\n+\t\t\tExecutorService threadPool = SliceThread.newPool(executors.size());\r\n \t\t\tfor (Executor ex : executors) {\r\n \t\t\t\tif (futures == null)\r\n \t\t\t\t\tfutures = new ArrayList<Future<Number>>();\r\n@@ -241,6 +233,7 @@ public Number executeUpdate(StoreQuery q, Object[] params) {\n \t\t\tIterator<StoreQuery> qs = owner._queries.iterator();\r\n \t\t\tList<Future<Number>> futures = null;\r\n \t\t\tint result = 0;\r\n+            ExecutorService threadPool = SliceThread.newPool(executors.size());\r\n \t\t\tfor (Executor ex : executors) {\r\n \t\t\t\tif (futures == null)\r\n \t\t\t\t\tfutures = new ArrayList<Future<Number>>();\r\n@@ -268,6 +261,7 @@ public Number executeUpdate(StoreQuery q, Object[] params) {\n \t\t\t\t\t.getFetchConfiguration();\r\n \t\t\treturn owner.getDistributedStore().getTargets(fetch);\r\n \t\t}\r\n+\t\t\r\n \t}\r\n \r\n \tstatic class QueryExecutor implements Callable<ResultObjectProvider> {\r\n@@ -277,18 +271,7 @@ public Number executeUpdate(StoreQuery q, Object[] params) {\n \t\tRange range;\r\n \r\n \t\tpublic ResultObjectProvider call() throws Exception {\r\n-\t\t\t((QueryImpl)query.getContext()).startLocking();\r\n-\t\t\t((BrokerImpl)query.getContext().getStoreContext()).startLocking();\r\n-\t\t\t((QueryImpl)query.getContext()).lock();\r\n-\t\t\t((BrokerImpl)query.getContext().getStoreContext()).lock();\r\n-\t\t\ttry { \r\n-\t\t\t\treturn executor.executeQuery(query, params, range);\r\n-\t\t\t} finally {\r\n-\t\t\t\t((QueryImpl)query.getContext()).unlock();\r\n-\t\t\t\t((BrokerImpl)query.getContext().getStoreContext()).unlock();\r\n-\t\t\t\t((QueryImpl)query.getContext()).stopLocking();\r\n-\t\t\t\t((BrokerImpl)query.getContext().getStoreContext()).stopLocking();\r\n-\t\t\t}\r\n+\t\t\treturn executor.executeQuery(query, params, range);\r\n \t\t}\r\n \t}\r\n \r\n@@ -298,18 +281,7 @@ public ResultObjectProvider call() throws Exception {\n \t\tObject[] params;\r\n \r\n \t\tpublic Number call() throws Exception {\r\n-\t\t\t((QueryImpl)query.getContext()).startLocking();\r\n-\t\t\t((BrokerImpl)query.getContext().getStoreContext()).startLocking();\r\n-\t\t\t((QueryImpl)query.getContext()).lock();\r\n-\t\t\t((BrokerImpl)query.getContext().getStoreContext()).lock();\r\n-\t\t\ttry { \r\n-\t\t\t\treturn executor.executeDelete(query, params);\r\n-\t\t\t} finally {\r\n-\t\t\t\t((QueryImpl)query.getContext()).unlock();\r\n-\t\t\t\t((BrokerImpl)query.getContext().getStoreContext()).unlock();\r\n-\t\t\t\t((QueryImpl)query.getContext()).stopLocking();\r\n-\t\t\t\t((BrokerImpl)query.getContext().getStoreContext()).stopLocking();\r\n-\t\t\t}\r\n+\t\t\treturn executor.executeDelete(query, params);\r\n \t\t}\r\n \t}\r\n \r\n@@ -319,18 +291,7 @@ public Number call() throws Exception {\n \t\tObject[] params;\r\n \r\n \t\tpublic Number call() throws Exception {\r\n-\t\t\t((QueryImpl)query.getContext()).startLocking();\r\n-\t\t\t((BrokerImpl)query.getContext().getStoreContext()).startLocking();\r\n-\t\t\t((QueryImpl)query.getContext()).lock();\r\n-\t\t\t((BrokerImpl)query.getContext().getStoreContext()).lock();\r\n-\t\t\ttry { \r\n-\t\t\t\treturn executor.executeUpdate(query, params);\r\n-\t\t\t} finally {\r\n-\t\t\t\t((QueryImpl)query.getContext()).unlock();\r\n-\t\t\t\t((BrokerImpl)query.getContext().getStoreContext()).unlock();\r\n-\t\t\t\t((QueryImpl)query.getContext()).stopLocking();\r\n-\t\t\t\t((BrokerImpl)query.getContext().getStoreContext()).stopLocking();\r\n-\t\t\t}\r\n+\t\t    return executor.executeUpdate(query, params);\r\n \t\t}\r\n \t}\r\n }\r"},{"sha":"c9b1cf725edb4503d2875b5e1122cb82d1dd2d39","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/TestBasic.java","status":"modified","additions":7,"deletions":8,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestBasic.java","raw_url":"https://github.com/apache/openjpa/raw/75cf4c522f41e6dfcbac89a2905498085d7f728e/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestBasic.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestBasic.java?ref=75cf4c522f41e6dfcbac89a2905498085d7f728e","patch":"@@ -128,18 +128,17 @@ public void testReference() {\n \r\n         EntityManager em = emf.createEntityManager();\r\n         em.getTransaction().begin();\r\n-        PObject pc2 = em.getReference(PObject.class, pc.getId());\r\n-        assertNotNull(pc2);\r\n-        assertNotEquals(pc, pc2);\r\n-        assertEquals(pc.getId(), pc2.getId());\r\n-        assertEquals(value, pc2.getValue());\r\n-        pc2.setValue(value+1);\r\n-        em.merge(pc2);\r\n+        PObject ref = em.getReference(PObject.class, pc.getId());\r\n+        assertNotNull(ref);\r\n+        assertNotEquals(pc, ref);\r\n+        assertEquals(ref.getId(), pc.getId());\r\n+        pc.setValue(value+1);\r\n+        em.merge(pc);\r\n         em.getTransaction().commit();\r\n         em.clear();\r\n         \r\n         em.getTransaction().begin();\r\n-        PObject pc3 = em.getReference(PObject.class, pc.getId());\r\n+        PObject pc3 = em.find(PObject.class, pc.getId());\r\n         assertEquals(value+1, pc3.getValue());\r\n         em.getTransaction().commit();\r\n         \r"}]}

