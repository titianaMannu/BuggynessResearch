{"sha":"7846adbf3f732c3258e88c326445044387385fb3","node_id":"MDY6Q29tbWl0MjA2MzY0Ojc4NDZhZGJmM2Y3MzJjMzI1OGU4OGMzMjY0NDUwNDQzODczODVmYjM=","commit":{"author":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-09-14T22:10:45Z"},"committer":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-09-14T22:10:45Z"},"message":"Unused.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@443496 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a5a1cbe89e82747a6c77275cc17f7599eb624a30","url":"https://api.github.com/repos/apache/openjpa/git/trees/a5a1cbe89e82747a6c77275cc17f7599eb624a30"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/7846adbf3f732c3258e88c326445044387385fb3","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/7846adbf3f732c3258e88c326445044387385fb3","html_url":"https://github.com/apache/openjpa/commit/7846adbf3f732c3258e88c326445044387385fb3","comments_url":"https://api.github.com/repos/apache/openjpa/commits/7846adbf3f732c3258e88c326445044387385fb3/comments","author":null,"committer":null,"parents":[{"sha":"a5d552f940b7830cc252d10aaccf630249626b13","url":"https://api.github.com/repos/apache/openjpa/commits/a5d552f940b7830cc252d10aaccf630249626b13","html_url":"https://github.com/apache/openjpa/commit/a5d552f940b7830cc252d10aaccf630249626b13"}],"stats":{"total":254,"additions":0,"deletions":254},"files":[{"sha":"645a138384ffe132733bdc78c2042ecd4c56f92a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","status":"removed","additions":0,"deletions":254,"changes":254,"blob_url":"https://github.com/apache/openjpa/blob/a5d552f940b7830cc252d10aaccf630249626b13/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/a5d552f940b7830cc252d10aaccf630249626b13/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java?ref=a5d552f940b7830cc252d10aaccf630249626b13","patch":"@@ -1,254 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.openjpa.jdbc.meta.strats;\n-\n-import java.sql.SQLException;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.meta.ValueHandler;\n-import org.apache.openjpa.jdbc.meta.ValueMapping;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ColumnIO;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.Row;\n-import org.apache.openjpa.jdbc.sql.RowManager;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.util.ChangeTracker;\n-import org.apache.openjpa.util.MetaDataException;\n-import org.apache.openjpa.util.Proxies;\n-import org.apache.openjpa.util.Proxy;\n-\n-/**\n- * Mapping for a map of keys and values both controlled by\n- * {@link ValueHandler}s.\n- *\n- * @author Abe White\n- * @since 0.4.0\n- */\n-public class HandlerHandlerMapTableFieldStrategy\n-    extends MapTableFieldStrategy {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (HandlerHandlerMapTableFieldStrategy.class);\n-\n-    private Column[] _kcols = null;\n-    private ColumnIO _kio = null;\n-    private boolean _kload = false;\n-    private Column[] _vcols = null;\n-    private ColumnIO _vio = null;\n-    private boolean _vload = false;\n-\n-    public Column[] getKeyColumns(ClassMapping cls) {\n-        return _kcols;\n-    }\n-\n-    public Column[] getValueColumns(ClassMapping cls) {\n-        return _vcols;\n-    }\n-\n-    public void selectKey(Select sel, ClassMapping cls, OpenJPAStateManager sm,\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n-        sel.select(_kcols, joins);\n-    }\n-\n-    public void selectValue(Select sel, ClassMapping cls,\n-        OpenJPAStateManager sm,\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n-        sel.select(_vcols, joins);\n-    }\n-\n-    public Result[] getResults(OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch, int eagerMode, Joins[] joins, boolean lrs)\n-        throws SQLException {\n-        Select sel = store.getSQLFactory().newSelect();\n-        sel.setLRS(lrs);\n-        sel.select(_kcols);\n-        sel.select(_vcols);\n-        sel.whereForeignKey(field.getJoinForeignKey(), sm.getObjectId(),\n-            field.getDefiningMapping(), store);\n-        Result res = sel.execute(store, fetch);\n-        return new Result[]{ res, res };\n-    }\n-\n-    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\n-        throws SQLException {\n-        return HandlerStrategies.loadObject(field.getKeyMapping(),\n-            sm, store, fetch, res, joins, _kcols, _kload);\n-    }\n-\n-    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\n-        throws SQLException {\n-        return HandlerStrategies.loadObject(field.getElementMapping(),\n-            sm, store, fetch, res, joins, _vcols, _vload);\n-    }\n-\n-    public void map(boolean adapt) {\n-        super.map(adapt);\n-\n-        ValueMapping key = field.getKeyMapping();\n-        if (key.getHandler() == null)\n-            throw new MetaDataException(_loc.get(\"no-handler\", key));\n-        ValueMapping val = field.getElementMapping();\n-        if (val.getHandler() == null)\n-            throw new MetaDataException(_loc.get(\"no-handler\", val));\n-        assertNotMappedBy();\n-\n-        field.mapJoin(adapt, true);\n-        _kio = new ColumnIO();\n-        _kcols = HandlerStrategies.map(key, \"key\", _kio, adapt);\n-        _vio = new ColumnIO();\n-        _vcols = HandlerStrategies.map(val, \"value\", _vio, adapt);\n-        field.mapPrimaryKey(adapt);\n-    }\n-\n-    public void initialize() {\n-        _kload = field.getKeyMapping().getHandler().\n-            objectValueRequiresLoad(field.getKeyMapping());\n-        _vload = field.getElementMapping().getHandler().\n-            objectValueRequiresLoad(field.getElementMapping());\n-    }\n-\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n-        throws SQLException {\n-        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\n-    }\n-\n-    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n-        Map map)\n-        throws SQLException {\n-        if (map == null || map.isEmpty())\n-            return;\n-\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n-            sm);\n-\n-        ValueMapping key = field.getKeyMapping();\n-        ValueMapping val = field.getElementMapping();\n-        Map.Entry entry;\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n-            entry = (Map.Entry) itr.next();\n-            HandlerStrategies.set(key, entry.getKey(), store, row, _kcols,\n-                _kio, true);\n-            HandlerStrategies.set(val, entry.getValue(), store, row, _vcols,\n-                _vio, true);\n-            rm.flushSecondaryRow(row);\n-        }\n-    }\n-\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n-        throws SQLException {\n-        Map map = (Map) sm.fetchObject(field.getIndex());\n-        ChangeTracker ct = null;\n-        if (map instanceof Proxy) {\n-            Proxy proxy = (Proxy) map;\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n-                ct = proxy.getChangeTracker();\n-        }\n-\n-        // if no fine-grained change tracking then just delete and reinsert\n-        if (ct == null || !ct.isTracking()) {\n-            delete(sm, store, rm);\n-            insert(sm, store, rm, map);\n-            return;\n-        }\n-\n-        // delete the removes\n-        ValueMapping key = field.getKeyMapping();\n-        Collection rem = ct.getRemoved();\n-        if (!rem.isEmpty()) {\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\n-                Row.ACTION_DELETE);\n-            delRow.setForeignKey(field.getJoinForeignKey(),\n-                field.getJoinColumnIO(), sm);\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n-                HandlerStrategies.where(key, itr.next(), store, delRow,\n-                    _kcols);\n-                rm.flushSecondaryRow(delRow);\n-            }\n-        }\n-\n-        // insert the adds\n-        ValueMapping val = field.getElementMapping();\n-        Collection add = ct.getAdded();\n-        Object mkey;\n-        if (!add.isEmpty()) {\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\n-                Row.ACTION_INSERT);\n-            addRow.setForeignKey(field.getJoinForeignKey(),\n-                field.getJoinColumnIO(), sm);\n-\n-            for (Iterator itr = add.iterator(); itr.hasNext();) {\n-                mkey = itr.next();\n-                HandlerStrategies.set(key, mkey, store, addRow, _kcols,\n-                    _kio, true);\n-                HandlerStrategies.set(val, map.get(mkey), store, addRow,\n-                    _vcols, _vio, true);\n-                rm.flushSecondaryRow(addRow);\n-            }\n-        }\n-\n-        // update the changes\n-        Collection change = ct.getChanged();\n-        if (!change.isEmpty()) {\n-            Row changeRow = rm.getSecondaryRow(field.getTable(),\n-                Row.ACTION_UPDATE);\n-            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n-\n-            for (Iterator itr = change.iterator(); itr.hasNext();) {\n-                mkey = itr.next();\n-                HandlerStrategies.where(key, mkey, store, changeRow, _kcols);\n-                HandlerStrategies.set(val, map.get(mkey), store, changeRow,\n-                    _vcols, _vio, true);\n-                rm.flushSecondaryRow(changeRow);\n-            }\n-        }\n-    }\n-\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\n-            val, _vcols, store);\n-    }\n-\n-    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n-        return HandlerStrategies.toDataStoreValue(field.getKeyMapping(), val,\n-            _kcols, store);\n-    }\n-\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\n-        boolean traverse) {\n-        if (traverse)\n-            HandlerStrategies.assertJoinable(field.getElementMapping());\n-        return joins;\n-    }\n-\n-    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\n-        boolean traverse) {\n-        if (traverse)\n-            HandlerStrategies.assertJoinable(field.getKeyMapping());\n-        return joins;\n-    }\n-}"}]}

