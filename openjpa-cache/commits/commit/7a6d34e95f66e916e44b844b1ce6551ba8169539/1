{"sha":"7a6d34e95f66e916e44b844b1ce6551ba8169539","node_id":"MDY6Q29tbWl0MjA2MzY0OjdhNmQzNGU5NWY2NmU5MTZlNDRiODQ0YjFjZTY1NTFiYTgxNjk1Mzk=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-12T01:06:30Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-12T01:06:30Z"},"message":"re-applied conversion from SolarMetric code formatting.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@421062 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5ec8e1f7fce68f4452491ebdc47aa9bd6b5cebcd","url":"https://api.github.com/repos/apache/openjpa/git/trees/5ec8e1f7fce68f4452491ebdc47aa9bd6b5cebcd"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/7a6d34e95f66e916e44b844b1ce6551ba8169539","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/7a6d34e95f66e916e44b844b1ce6551ba8169539","html_url":"https://github.com/apache/openjpa/commit/7a6d34e95f66e916e44b844b1ce6551ba8169539","comments_url":"https://api.github.com/repos/apache/openjpa/commits/7a6d34e95f66e916e44b844b1ce6551ba8169539/comments","author":null,"committer":null,"parents":[{"sha":"b9636bb8786de3ffbc3c897f4fe5f38e979c9df7","url":"https://api.github.com/repos/apache/openjpa/commits/b9636bb8786de3ffbc3c897f4fe5f38e979c9df7","html_url":"https://github.com/apache/openjpa/commit/b9636bb8786de3ffbc3c897f4fe5f38e979c9df7"}],"stats":{"total":190652,"additions":98492,"deletions":92160},"files":[{"sha":"317588461ed258f8b586f6e1975116ae11199b69","filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","status":"modified","additions":237,"deletions":219,"changes":456,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,219 +1,237 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation. Licensed under the Apache\r\n- * License, Version 2.0 (the \"License\"); you may not use this file except in\r\n- * compliance with the License. You may obtain a copy of the License at\r\n- * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\r\n- * or agreed to in writing, software distributed under the License is\r\n- * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied. See the License for the specific language\r\n- * governing permissions and limitations under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.io.ByteArrayInputStream;\r\n-import java.io.UnsupportedEncodingException;\r\n-import java.lang.instrument.ClassFileTransformer;\r\n-import java.lang.instrument.IllegalClassFormatException;\r\n-import java.security.ProtectionDomain;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.Options;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.util.GeneralException;\r\n-import serp.bytecode.Project;\r\n-\r\n-/**\r\n- * Transformer that makes persistent classes implement the\r\n- * {@link PersistenceCapable} interface at runtime.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class PCClassFileTransformer implements ClassFileTransformer {\r\n-\r\n-    private static final Localizer _loc = Localizer\r\n-        .forPackage(PCClassFileTransformer.class);\r\n-\r\n-    private final MetaDataRepository _repos;\r\n-    private final PCEnhancer.Flags _flags;\r\n-    private final ClassLoader _loader;\r\n-    private final Log _log;\r\n-    private final Set _names;\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param repos  metadata repository to use internally\r\n-     * @param opts   enhancer configuration options\r\n-     * @param loader temporary class loader for loading intermediate\r\n-     *               classes\r\n-     */\r\n-    public PCClassFileTransformer(MetaDataRepository repos, Options opts,\r\n-        ClassLoader loader) {\r\n-        this(repos, toFlags(opts), loader, opts.removeBooleanProperty(\r\n-            \"scanDevPath\", \"ScanDevPath\", false));\r\n-    }\r\n-\r\n-    /**\r\n-     * Create enhancer flags from the given options.\r\n-     */\r\n-    private static PCEnhancer.Flags toFlags(Options opts) {\r\n-        PCEnhancer.Flags flags = new PCEnhancer.Flags();\r\n-        flags.addDefaultConstructor = opts.removeBooleanProperty(\r\n-            \"addDefaultConstructor\", \"AddDefaultConstructor\",\r\n-            flags.addDefaultConstructor);\r\n-        flags.enforcePropertyRestrictions = opts.removeBooleanProperty(\r\n-            \"enforcePropertyRestrictions\", \"EnforcePropertyRestrictions\",\r\n-            flags.enforcePropertyRestrictions);\r\n-        return flags;\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param repos   metadata repository to use internally\r\n-     * @param flags   enhancer configuration\r\n-     * @param loader  temporary class loader for loading intermediate\r\n-     *                classes\r\n-     * @param devscan whether to scan the dev classpath for persistent types\r\n-     *                if none are configured\r\n-     */\r\n-    public PCClassFileTransformer(MetaDataRepository repos,\r\n-        PCEnhancer.Flags flags, ClassLoader loader, boolean devscan) {\r\n-        _repos = repos;\r\n-        _log = repos.getConfiguration()\r\n-            .getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n-        _flags = flags;\r\n-        _loader = loader;\r\n-        _names = repos.getPersistentTypeNames(devscan, loader);\r\n-        if (_names == null && _log.isInfoEnabled())\r\n-            _log.info(_loc.get(\"runtime-enhance-pcclasses\"));\r\n-    }\r\n-\r\n-    public byte[] transform(ClassLoader loader, String className, Class redef,\r\n-        ProtectionDomain domain, byte[] bytes)\r\n-        throws IllegalClassFormatException {\r\n-        if (loader == _loader)\r\n-            return null;\r\n-        try {\r\n-            Boolean enhance = needsEnhance(className, redef, bytes);\r\n-            if (enhance != null && _log.isTraceEnabled())\r\n-                _log.trace(_loc\r\n-                    .get(\"needs-runtime-enhance\", className, enhance));\r\n-            if (enhance != Boolean.TRUE)\r\n-                return null;\r\n-            PCEnhancer enhancer = new PCEnhancer(_repos.getConfiguration(),\r\n-                new Project().loadClass(new ByteArrayInputStream(bytes),\r\n-                    _loader), _repos);\r\n-            enhancer.setAddDefaultConstructor(_flags.addDefaultConstructor);\r\n-            enhancer\r\n-                .setEnforcePropertyRestrictions(\r\n-                    _flags.enforcePropertyRestrictions);\r\n-            if (enhancer.run() == PCEnhancer.ENHANCE_NONE)\r\n-                return null;\r\n-            return enhancer.getBytecode().toByteArray();\r\n-        } catch (Throwable t) {\r\n-            _log.warn(_loc.get(\"cft-exception-thrown\", className), t);\r\n-            if (t instanceof RuntimeException)\r\n-                throw (RuntimeException) t;\r\n-            if (t instanceof IllegalClassFormatException)\r\n-                throw (IllegalClassFormatException) t;\r\n-            throw new GeneralException(t);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Return whether the given class needs enhancement.\r\n-     */\r\n-    private Boolean needsEnhance(String clsName, Class redef, byte[] bytes) {\r\n-        if (redef != null) {\r\n-            Class[] intfs = redef.getInterfaces();\r\n-            for (int i = 0; i < intfs.length; i++)\r\n-                if (PersistenceCapable.class.getName().equals(\r\n-                    intfs[i].getName()))\r\n-                    return Boolean.valueOf(!isEnhanced(bytes));\r\n-            return null;\r\n-        }\r\n-        if (_names != null) {\r\n-            if (_names.contains(clsName.replace('/', '.')))\r\n-                return Boolean.valueOf(!isEnhanced(bytes));\r\n-            return null;\r\n-        }\r\n-        if (clsName.startsWith(\"java/\") || clsName.startsWith(\"javax/\"))\r\n-            return null;\r\n-        if (isEnhanced(bytes))\r\n-            return Boolean.FALSE;\r\n-        try {\r\n-            Class c = Class.forName(clsName.replace('/', '.'), false, _loader);\r\n-            if (_repos.getMetaData(c, null, false) != null)\r\n-                return Boolean.TRUE;\r\n-            return null;\r\n-        } catch (RuntimeException re) {\r\n-            throw re;\r\n-        } catch (Throwable t) {\r\n-            throw new GeneralException(t);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Analyze the bytecode to see if the given class definition implements\r\n-     * {@link PersistenceCapable}.\r\n-     */\r\n-    private static boolean isEnhanced(byte[] b) {\r\n-        // each entry is the index in the byte array of the data for a const\r\n-        // pool entry\r\n-        int[] entries = new int[readUnsignedShort(b, 8)];\r\n-        int idx = 10;\r\n-        for (int i = 1; i < entries.length; i++) {\r\n-            entries[i] = idx + 1; // skip entry type\r\n-            switch (b[idx]) {\r\n-                case 1: // utf8\r\n-                    idx += 3 + readUnsignedShort(b, idx + 1);\r\n-                    break;\r\n-                case 3: // integer\r\n-                case 4: // float\r\n-                case 9: // field\r\n-                case 10: // method\r\n-                case 11: // interface method\r\n-                case 12: // name\r\n-                    idx += 5;\r\n-                    break;\r\n-                case 5: // long\r\n-                case 6: // double\r\n-                    idx += 9;\r\n-                    i++; // wide entry\r\n-                    break;\r\n-                default:\r\n-                    idx += 3;\r\n-            }\r\n-        }\r\n-        idx += 6;\r\n-        int ifaces = readUnsignedShort(b, idx);\r\n-        int clsEntry, utfEntry, len;\r\n-        String name;\r\n-        for (int i = 0; i < ifaces; i++) {\r\n-            idx += 2;\r\n-            clsEntry = readUnsignedShort(b, idx);\r\n-            utfEntry = readUnsignedShort(b, entries[clsEntry]);\r\n-            len = readUnsignedShort(b, entries[utfEntry]);\r\n-            try {\r\n-                name = new String(b, entries[utfEntry] + 2, len, \"UTF-8\");\r\n-                if (\"openjpa/enhance/PersistenceCapable\".equals(name))\r\n-                    return true;\r\n-            } catch (UnsupportedEncodingException uee) {\r\n-                throw new ClassFormatError(uee.toString());\r\n-            }\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Read an unsigned short from the given array at the given offset.\r\n-     */\r\n-    private static int readUnsignedShort(byte[] b, int idx) {\r\n-        return ((b[idx] & 0xFF) << 8) | (b[idx + 1] & 0xFF);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.security.ProtectionDomain;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Options;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.util.GeneralException;\n+import serp.bytecode.Project;\n+\n+/**\n+ * <p>Transformer that makes persistent classes implement the\n+ * {@link PersistenceCapable} interface at runtime.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class PCClassFileTransformer\n+    implements ClassFileTransformer {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (PCClassFileTransformer.class);\n+\n+    private final MetaDataRepository _repos;\n+    private final PCEnhancer.Flags _flags;\n+    private final ClassLoader _loader;\n+    private final Log _log;\n+    private final Set _names;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param    repos    metadata repository to use internally\n+     * @param    opts    enhancer configuration options\n+     * @param    loader    temporary class loader for loading intermediate classes\n+     */\n+    public PCClassFileTransformer(MetaDataRepository repos, Options opts,\n+        ClassLoader loader) {\n+        this(repos, toFlags(opts), loader, opts.removeBooleanProperty\n+            (\"scanDevPath\", \"ScanDevPath\", false));\n+    }\n+\n+    /**\n+     * Create enhancer flags from the given options.\n+     */\n+    private static PCEnhancer.Flags toFlags(Options opts) {\n+        PCEnhancer.Flags flags = new PCEnhancer.Flags();\n+        flags.addDefaultConstructor = opts.removeBooleanProperty\n+            (\"addDefaultConstructor\", \"AddDefaultConstructor\",\n+                flags.addDefaultConstructor);\n+        flags.jdoEnhance = opts.removeBooleanProperty\n+            (\"jdoEnhance\", \"JdoEnhance\", flags.jdoEnhance);\n+        flags.enforcePropertyRestrictions = opts.removeBooleanProperty\n+            (\"enforcePropertyRestrictions\", \"EnforcePropertyRestrictions\",\n+                flags.enforcePropertyRestrictions);\n+        return flags;\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param    repos    metadata repository to use internally\n+     * @param    flags    enhancer configuration\n+     * @param    loader    temporary class loader for loading intermediate classes\n+     * @param    devscan    whether to scan the dev classpath for persistent types\n+     * if none are configured\n+     */\n+    public PCClassFileTransformer(MetaDataRepository repos,\n+        PCEnhancer.Flags flags, ClassLoader loader, boolean devscan) {\n+        _repos = repos;\n+        _log =\n+            repos.getConfiguration().getLog(OpenJPAConfiguration.LOG_ENHANCE);\n+        _flags = flags;\n+        _loader = loader;\n+\n+        _names = repos.getPersistentTypeNames(devscan, loader);\n+        if (_names == null && _log.isInfoEnabled())\n+            _log.info(_loc.get(\"runtime-enhance-pcclasses\"));\n+    }\n+\n+    public byte[] transform(ClassLoader loader, String className,\n+        Class redef, ProtectionDomain domain, byte[] bytes)\n+        throws IllegalClassFormatException {\n+        if (loader == _loader)\n+            return null;\n+\n+        try {\n+            Boolean enhance = needsEnhance(className, redef, bytes);\n+            if (enhance != null && _log.isTraceEnabled())\n+                _log.trace(_loc.get(\"needs-runtime-enhance\", className,\n+                    enhance));\n+            if (enhance != Boolean.TRUE)\n+                return null;\n+\n+            PCEnhancer enhancer = new PCEnhancer(_repos.getConfiguration(),\n+                new Project().loadClass(new ByteArrayInputStream(bytes),\n+                    _loader), _repos);\n+            enhancer.setAddDefaultConstructor(_flags.addDefaultConstructor);\n+            enhancer.setJDOEnhance(_flags.jdoEnhance);\n+            enhancer.setEnforcePropertyRestrictions\n+                (_flags.enforcePropertyRestrictions);\n+\n+            if (enhancer.run() == PCEnhancer.ENHANCE_NONE)\n+                return null;\n+            return enhancer.getBytecode().toByteArray();\n+        }\n+        catch (Throwable t) {\n+            _log.warn(_loc.get(\"cft-exception-thrown\", className), t);\n+            if (t instanceof RuntimeException)\n+                throw (RuntimeException) t;\n+            if (t instanceof IllegalClassFormatException)\n+                throw (IllegalClassFormatException) t;\n+            throw new GeneralException(t);\n+        }\n+    }\n+\n+    /**\n+     * Return whether the given class needs enhancement.\n+     */\n+    private Boolean needsEnhance(String clsName, Class redef, byte[] bytes) {\n+        if (redef != null) {\n+            Class[] intfs = redef.getInterfaces();\n+            for (int i = 0; i < intfs.length; i++)\n+                if (PersistenceCapable.class.getName().\n+                    equals(intfs[i].getName()))\n+                    return Boolean.valueOf(!isEnhanced(bytes));\n+            return null;\n+        }\n+\n+        if (_names != null) {\n+            if (_names.contains(clsName.replace('/', '.')))\n+                return Boolean.valueOf(!isEnhanced(bytes));\n+            return null;\n+        }\n+\n+        if (clsName.startsWith(\"java/\") || clsName.startsWith(\"javax/\"))\n+            return null;\n+        if (isEnhanced(bytes))\n+            return Boolean.FALSE;\n+\n+        try {\n+            Class c = Class.forName(clsName.replace('/', '.'), false, _loader);\n+            if (_repos.getMetaData(c, null, false) != null)\n+                return Boolean.TRUE;\n+            return null;\n+        }\n+        catch (RuntimeException re) {\n+            throw re;\n+        }\n+        catch (Throwable t) {\n+            throw new GeneralException(t);\n+        }\n+    }\n+\n+    /**\n+     * Analyze the bytecode to see if the given class definition implements\n+     * {@link PersistenceCapable}.\n+     */\n+    private static boolean isEnhanced(byte[] b) {\n+        // each entry is the index in the byte array of the data for a const\n+        // pool entry\n+        int[] entries = new int[readUnsignedShort(b, 8)];\n+        int idx = 10;\n+        for (int i = 1; i < entries.length; i++) {\n+            entries[i] = idx + 1; // skip entry type\n+            switch (b[idx]) {\n+                case 1:        // utf8\n+                    idx += 3 + readUnsignedShort(b, idx + 1);\n+                    break;\n+                case 3:        // integer\n+                case 4:        // float\n+                case 9:        // field\n+                case 10:    // method\n+                case 11:    // interface method\n+                case 12:    // name\n+                    idx += 5;\n+                    break;\n+                case 5:        // long\n+                case 6:        // double\n+                    idx += 9;\n+                    i++;    // wide entry\n+                    break;\n+                default:\n+                    idx += 3;\n+            }\n+        }\n+\n+        idx += 6;\n+        int ifaces = readUnsignedShort(b, idx);\n+        int clsEntry, utfEntry, len;\n+        String name;\n+        for (int i = 0; i < ifaces; i++) {\n+            idx += 2;\n+            clsEntry = readUnsignedShort(b, idx);\n+            utfEntry = readUnsignedShort(b, entries[clsEntry]);\n+            len = readUnsignedShort(b, entries[utfEntry]);\n+            try {\n+                name = new String(b, entries[utfEntry] + 2, len, \"UTF-8\");\n+                if (\"openjpa/enhance/PersistenceCapable\".equals(name))\n+                    return true;\n+            }\n+            catch (UnsupportedEncodingException uee) {\n+                throw new ClassFormatError(uee.toString());\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     *\tRead an unsigned short from the given array at the given offset.\n+     */\n+    private static int readUnsignedShort(byte[] b, int idx) {\n+        return ((b[idx] & 0xFF) << 8) | (b[idx + 1] & 0xFF);\n+\t}\n+}"},{"sha":"f12a65923078daf7c4e9ee7f1e9b7888cd78cf20","filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java","status":"modified","additions":70,"deletions":65,"changes":135,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,65 +1,70 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation. Licensed under the Apache\r\n- * License, Version 2.0 (the \"License\"); you may not use this file except in\r\n- * compliance with the License. You may obtain a copy of the License at\r\n- * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\r\n- * or agreed to in writing, software distributed under the License is\r\n- * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied. See the License for the specific language\r\n- * governing permissions and limitations under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.lang.instrument.Instrumentation;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\r\n-import org.apache.openjpa.lib.conf.Configurations;\r\n-import org.apache.openjpa.lib.util.Options;\r\n-import org.apache.openjpa.lib.util.TemporaryClassLoader;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.util.ClassResolver;\r\n-\r\n-/**\r\n- * Java agent that makes persistent classes implement the\r\n- * {@link PersistenceCapable} interface at runtime. The agent is launched at JVM\r\n- * startup from the command line:\r\n- * <p/>\r\n- * <code>java -javaagent:org.apache.openjpa.jar[=&lt;options&gt;]</code> The\r\n- * options string should be formatted as a OpenJPA plugin, and may contain any\r\n- * properties understood by the OpenJPA enhancer or any configuration\r\n- * properties. For example:\r\n- * <p/>\r\n- * <code>java -javaagent:org.apache.openjpa.jar=JdoEnhance=true,LicenseKey=xxx</code>\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public class PCEnhancerAgent {\r\n-\r\n-    public static void premain(String args, Instrumentation inst) {\r\n-        OpenJPAConfiguration conf = new OpenJPAConfigurationImpl();\r\n-        Options opts = Configurations.parseProperties(args);\r\n-        Configurations.populateConfiguration(conf, opts);\r\n-\r\n-        // don't allow connections\r\n-        conf.setConnectionUserName(null);\r\n-        conf.setConnectionPassword(null);\r\n-        conf.setConnectionURL(null);\r\n-        conf.setConnectionDriverName(null);\r\n-        conf.setConnectionFactoryName(null);\r\n-        // set single class resolver\r\n-        final ClassLoader tmpLoader = new TemporaryClassLoader(Thread\r\n-            .currentThread().getContextClassLoader());\r\n-        conf.setClassResolver(new ClassResolver() {\r\n-\r\n-            public ClassLoader getClassLoader(Class context, ClassLoader env) {\r\n-                return tmpLoader;\r\n-            }\r\n-        });\r\n-        conf.setReadOnly(true);\r\n-        conf.instantiateAll(); // avoid threading issues\r\n-        PCClassFileTransformer transformer = new PCClassFileTransformer(\r\n-            new MetaDataRepository(conf), opts, tmpLoader);\r\n-        inst.addTransformer(transformer);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.lang.instrument.Instrumentation;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.util.Options;\n+import org.apache.openjpa.lib.util.TemporaryClassLoader;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.util.ClassResolver;\n+\n+/**\n+ * <p>Java agent that makes persistent classes implement the\n+ * {@link PersistenceCapable} interface at runtime.  The agent is launched\n+ * at JVM startup from the command line:</p>\n+ * <p/>\n+ * <code>java -javaagent:org.apache.openjpa.jar[=&lt;options&gt;]</code>\n+ * <p/>\n+ * <p>The options string should be formatted as a OpenJPA plugin, and may contain\n+ * any properties understood by the OpenJPA enhancer or any configuration\n+ * properties.  For example:</p>\n+ * <p/>\n+ * <code>java -javaagent:org.apache.openjpa.jar=JdoEnhance=true,LicenseKey=xxx</code>\n+ *\n+ * @author Abe White\n+ */\n+public class PCEnhancerAgent {\n+\n+    public static void premain(String args, Instrumentation inst) {\n+        OpenJPAConfiguration conf = new OpenJPAConfigurationImpl();\n+        Options opts = Configurations.parseProperties(args);\n+        Configurations.populateConfiguration(conf, opts);\n+        // don't allow connections\n+        conf.setConnectionUserName(null);\n+        conf.setConnectionPassword(null);\n+        conf.setConnectionURL(null);\n+        conf.setConnectionDriverName(null);\n+        conf.setConnectionFactoryName(null);\n+        // set single class resolver\n+        final ClassLoader tmpLoader = new TemporaryClassLoader(Thread.\n+            currentThread().getContextClassLoader());\n+        conf.setClassResolver(new ClassResolver() {\n+            public ClassLoader getClassLoader(Class context, ClassLoader env) {\n+                return tmpLoader;\n+            }\n+        });\n+        conf.setReadOnly(true);\n+        conf.instantiateAll(); // avoid threading issues\n+\n+        PCClassFileTransformer transformer = new PCClassFileTransformer\n+            (new MetaDataRepository(conf), opts, tmpLoader);\n+        inst.addTransformer(transformer);\n+    }\n+}"},{"sha":"ce3e7d5ed304840fc8f83e4f69dae113afb7523f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java","status":"modified","additions":139,"deletions":127,"changes":266,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,127 +1,139 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.abstractstore;\r\n-\r\n-import java.util.Map;\r\n-import java.util.Properties;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.AbstractBrokerFactory;\r\n-import org.apache.openjpa.kernel.Bootstrap;\r\n-import org.apache.openjpa.kernel.BrokerFactory;\r\n-import org.apache.openjpa.kernel.StoreManager;\r\n-import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n-import org.apache.openjpa.lib.conf.Configurations;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * {@link BrokerFactory} implementation for use with the\r\n- * {@link AbstractStoreManager}. This provides integration into the\r\n- * {@link Bootstrap#getBrokerFactory} bootstrapping mechanism, to facilitate\r\n- * the process of creating a subclass of {@link AbstractStoreManager}. New\r\n- * store manager implementations need not extend this class. Instead, set the\r\n- * <code>org.apache.openjpa.BrokerFactory</code> configuration property to\r\n- * <code>abstractstore</code>,\r\n- * and set the <code>org.apache.openjpa.abstractstore.AbstractStoreManager</code>\r\n- * configuration property to the full class name of your implementation.\r\n- * Additionally, you can optionally create your own\r\n- * <code>BrokerFactory</code> implementation. However, we recommend that you\r\n- * use the <code>AbstractStoreBrokerFactory</code>, as it deals with pooling\r\n- * and bootstrapping from a {@link Map} object(the strategy used by\r\n- * {@link Bootstrap} to create a factory in a vendor-neutral manner).\r\n- */\r\n-public class AbstractStoreBrokerFactory extends AbstractBrokerFactory {\r\n-\r\n-    /**\r\n-     * The property name under which to name the concrete store manager\r\n-     * class for this runtime.\r\n-     */\r\n-    public static final String PROP_ABSTRACT_STORE =\r\n-        \"org.apache.openjpa.abstractstore.AbstractStoreManager\";\r\n-    private static final Localizer s_loc = Localizer.forPackage\r\n-        (AbstractStoreBrokerFactory.class);\r\n-    private String _storeCls = null;\r\n-    private String _storeProps = null;\r\n-    private String _platform = null;\r\n-\r\n-    /**\r\n-     * Factory method for obtaining a possibly-pooled {@link BrokerFactory}\r\n-     * from properties. Invoked from {@link Bootstrap#getBrokerFactory}.\r\n-     */\r\n-    public static AbstractStoreBrokerFactory getInstance\r\n-        (ConfigurationProvider cp) {\r\n-        AbstractStoreBrokerFactory factory = (AbstractStoreBrokerFactory)\r\n-            getPooledFactory(cp.getProperties());\r\n-        if (factory != null)\r\n-            return factory;\r\n-        factory = newInstance(cp);\r\n-        factory.pool();\r\n-        return factory;\r\n-    }\r\n-\r\n-    /**\r\n-     * Factory method for constructing a {@link BrokerFactory}\r\n-     * from properties. Invoked from {@link Bootstrap#newBrokerFactory}.\r\n-     */\r\n-    public static AbstractStoreBrokerFactory newInstance\r\n-        (ConfigurationProvider cp) {\r\n-        // use a tmp store manager to get metadata about the capabilities of\r\n-        // this runtime\r\n-        Map map = cp.getProperties();\r\n-        String storePlugin = (String) map.get(PROP_ABSTRACT_STORE);\r\n-        String storeCls = Configurations.getClassName(storePlugin);\r\n-        String storeProps = Configurations.getProperties(storePlugin);\r\n-        AbstractStoreManager store = createStoreManager(storeCls, storeProps);\r\n-        // populate configuration\r\n-        OpenJPAConfiguration conf = store.newConfiguration();\r\n-        cp.setInto(conf);\r\n-        conf.supportedOptions().removeAll(store.getUnsupportedOptions());\r\n-        // create and pool a new factory\r\n-        return new AbstractStoreBrokerFactory(conf, storeCls, storeProps,\r\n-            store.getPlatform());\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct the factory with the given settings.\r\n-     */\r\n-    protected AbstractStoreBrokerFactory(OpenJPAConfiguration conf,\r\n-        String storeCls, String storeProps, String platform) {\r\n-        super(conf);\r\n-        _storeCls = storeCls;\r\n-        _storeProps = storeProps;\r\n-        _platform = platform;\r\n-    }\r\n-\r\n-    public Properties getProperties() {\r\n-        Properties props = super.getProperties();\r\n-        props.setProperty(\"Platform\", _platform);\r\n-        return props;\r\n-    }\r\n-\r\n-    protected StoreManager newStoreManager() {\r\n-        return createStoreManager(_storeCls, _storeProps);\r\n-    }\r\n-\r\n-    private static AbstractStoreManager createStoreManager(String cls,\r\n-        String props) {\r\n-        AbstractStoreManager store = (AbstractStoreManager) Configurations.\r\n-            newInstance(cls, AbstractStoreManager.class.getClassLoader());\r\n-        Configurations.configureInstance(store, null, props,\r\n-            PROP_ABSTRACT_STORE);\r\n-        if (store == null)\r\n-            throw new UserException(s_loc.get(\"no-store-manager\",\r\n-                PROP_ABSTRACT_STORE)).setFatal(true);\r\n-        return store;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.abstractstore;\n+\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.AbstractBrokerFactory;\n+import org.apache.openjpa.kernel.Bootstrap;\n+import org.apache.openjpa.kernel.BrokerFactory;\n+import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * <p>{@link BrokerFactory} implementation for use with the\n+ * {@link AbstractStoreManager}. This provides integration into the\n+ * {@link Bootstrap#getBrokerFactory} bootstrapping mechanism, to facilitate\n+ * the process of creating a subclass of {@link AbstractStoreManager}. New\n+ * store manager implementations need not extend this class. Instead, set the\n+ * <code>org.apache.openjpa.BrokerFactory</code> configuration property to\n+ * <code>abstractstore</code>,\n+ * and set the <code>org.apache.openjpa.abstractstore.AbstractStoreManager</code>\n+ * configuration property to the full class name of your implementation.</p>\n+ * <p/>\n+ * <p>Additionally, you can optionally create your own\n+ * <code>BrokerFactory</code> implementation. However, we recommend that you\n+ * use the <code>AbstractStoreBrokerFactory</code>, as it deals with pooling\n+ * and bootstrapping from a {@link Map} object (the strategy used by\n+ * {@link Bootstrap} to create a factory in a vendor-neutral manner).</p>\n+ */\n+public class AbstractStoreBrokerFactory\n+    extends AbstractBrokerFactory {\n+\n+    /**\n+     * The property name under which to name the concrete store manager\n+     * class for this runtime.\n+     */\n+    public static final String PROP_ABSTRACT_STORE =\n+        \"org.apache.openjpa.abstractstore.AbstractStoreManager\";\n+\n+    private static final Localizer s_loc = Localizer.forPackage\n+        (AbstractStoreBrokerFactory.class);\n+\n+    private String _storeCls = null;\n+    private String _storeProps = null;\n+    private String _platform = null;\n+\n+    /**\n+     * Factory method for obtaining a possibly-pooled {@link BrokerFactory}\n+     * from properties. Invoked from {@link Bootstrap#getBrokerFactory}.\n+     */\n+    public static AbstractStoreBrokerFactory getInstance\n+        (ConfigurationProvider cp) {\n+        AbstractStoreBrokerFactory factory = (AbstractStoreBrokerFactory)\n+            getPooledFactory(cp.getProperties());\n+        if (factory != null)\n+            return factory;\n+\n+        factory = newInstance(cp);\n+        factory.pool();\n+        return factory;\n+    }\n+\n+    /**\n+     * Factory method for constructing a {@link BrokerFactory}\n+     * from properties. Invoked from {@link Bootstrap#newBrokerFactory}.\n+     */\n+    public static AbstractStoreBrokerFactory newInstance\n+        (ConfigurationProvider cp) {\n+        // use a tmp store manager to get metadata about the capabilities of\n+        // this runtime\n+        Map map = cp.getProperties();\n+        String storePlugin = (String) map.get(PROP_ABSTRACT_STORE);\n+        String storeCls = Configurations.getClassName(storePlugin);\n+        String storeProps = Configurations.getProperties(storePlugin);\n+        AbstractStoreManager store = createStoreManager(storeCls,\n+            storeProps);\n+\n+        // populate configuration\n+        OpenJPAConfiguration conf = store.newConfiguration();\n+        cp.setInto(conf);\n+        conf.supportedOptions().removeAll(store.getUnsupportedOptions());\n+\n+        // create and pool a new factory\n+        return new AbstractStoreBrokerFactory(conf, storeCls, storeProps,\n+            store.getPlatform());\n+    }\n+\n+    /**\n+     * Construct the factory with the given settings.\n+     */\n+    protected AbstractStoreBrokerFactory(OpenJPAConfiguration conf,\n+        String storeCls, String storeProps, String platform) {\n+        super(conf);\n+        _storeCls = storeCls;\n+        _storeProps = storeProps;\n+        _platform = platform;\n+    }\n+\n+    public Properties getProperties() {\n+        Properties props = super.getProperties();\n+        props.setProperty(\"Platform\", _platform);\n+        return props;\n+    }\n+\n+    protected StoreManager newStoreManager() {\n+        return createStoreManager(_storeCls, _storeProps);\n+    }\n+\n+    private static AbstractStoreManager createStoreManager(String cls,\n+        String props) {\n+        AbstractStoreManager store = (AbstractStoreManager) Configurations.\n+            newInstance(cls, AbstractStoreManager.class.getClassLoader());\n+        Configurations.configureInstance(store, null, props,\n+            PROP_ABSTRACT_STORE);\n+        if (store == null)\n+            throw new UserException(s_loc.get(\"no-store-manager\",\n+                PROP_ABSTRACT_STORE)).setFatal(true);\n+\n+        return store;\n+\t}\n+}"},{"sha":"da315bf7fc1eef9f4afcae4c9024cfe8b85feb1c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java","status":"modified","additions":535,"deletions":507,"changes":1042,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,507 +1,535 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.abstractstore;\r\n-\r\n-import java.util.BitSet;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.FetchConfigurationImpl;\r\n-import org.apache.openjpa.kernel.FetchState;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.PCState;\r\n-import org.apache.openjpa.kernel.Seq;\r\n-import org.apache.openjpa.kernel.StoreContext;\r\n-import org.apache.openjpa.kernel.StoreManager;\r\n-import org.apache.openjpa.kernel.StoreQuery;\r\n-import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.meta.ValueStrategies;\r\n-import org.apache.openjpa.util.ApplicationIds;\r\n-import org.apache.openjpa.util.Id;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-\r\n-/**\r\n- * Abstract store manager implementation to ease development of custom\r\n- * OpenJPA back-ends. A concrete subclass must define implementations for the\r\n- * following methods:\r\n- * <ul>\r\n- * <li>{@link StoreManager#exists}</li>\r\n- * <li>{@link #initialize}</li>\r\n- * <li>{@link #load}</li>\r\n- * <li>{@link\r\n- * #flush(Collection,Collection,Collection,Collection,Collection)}</li>\r\n- * <li>{@link #executeExtent}</li>\r\n- * </ul> Additionally, subclasses should not attempt to acquire resources\r\n- * until {@link #open} has been called. Store manager instances might be\r\n- * created to call metadata methods such as {@link #newConfiguration} or\r\n- * {@link #getUnsupportedOptions} and never opened. These instances should\r\n- * not consume any data store resources.\r\n- * Notes:\r\n- * <ul>\r\n- * <li>The {@link StoreManager#initialize} method is responsible\r\n- * for creating new instances of objects freshly loaded from the\r\n- * database. The method will be invoked with a {@link OpenJPAStateManager}\r\n- * that the newly-loaded object should be associated with. To create the\r\n- * new object and set up this association correctly, the implementation\r\n- * should use the {@link OpenJPAStateManager#initialize} method.</li>\r\n- * <li>If your data store supports some sort of transaction or\r\n- * unit of work, you should override the {@link #begin}, {@link #commit},\r\n- * and {@link #rollback} methods.</li>\r\n- * <li>This class provides no infrastructure support for optimistic\r\n- * transactions. To provide optimistic transaction support:\r\n- * <ul>\r\n- * <li>Override {@link #beginOptimistic}, {@link #rollbackOptimistic},\r\n- * and {@link #syncVersion}.</li>\r\n- * <li>Override {@link #getUnsupportedOptions} to not include {@link\r\n- * OpenJPAConfiguration#OPTION_OPTIMISTIC} in the list of unsupported\r\n- * options.</li>\r\n- * <li>Ensure that your flush implementation sets the next\r\n- * version for each modified object via the {@link\r\n- * OpenJPAStateManager#setNextVersion} method.</li>\r\n- * <li>If your version object does not implement {@link Comparable},\r\n- * override {@link #compareVersion}, which relies on the\r\n- * {@link Comparable#compareTo} method.</li>\r\n- * </ul></li>\r\n- * <li>If your data store supports a mechanism for automatically\r\n- * generating and managing identity values(or if you want to\r\n- * provide that facility on top of your data store), implement\r\n- * the {@link #getDataStoreIdSequence} method if you want to use a\r\n- * <code>long</code> as your datastore identity type and are\r\n- * happy with OpenJPA's {@link Id} class. To use another datastore identity\r\n- * type, override {@link #getManagedType},\r\n- * {@link #getDataStoreIdType}, {@link #copyDataStoreId}, and\r\n- * {@link #newDataStoreId} instead. In either case, override\r\n- * {@link #getUnsupportedOptions} to not include\r\n- * {@link OpenJPAConfiguration#OPTION_ID_DATASTORE} in the list of\r\n- * unsupported options.</li>\r\n- * <li>If your data store does not support queries(or if you do\r\n- * not want to convert OpenJPA's query parse tree into a\r\n- * datastore-specific query), you still have two options in terms\r\n- * of query execution:\r\n- * <ul>\r\n- * <li><em>In-memory execution</em>: If you\r\n- * execute a query against an extent or a class, OpenJPA will\r\n- * automatically load the full extent of objects into memory and\r\n- * execute the query in memory.</li>\r\n- * <li><em>org.apache.openjpa.MethodQL</em>: MethodQL allows\r\n- * you to use the query APIs to execute a method that finds\r\n- * data in your back-end and returns that data as a\r\n- * {@link org.apache.openjpa.lib.rop.ResultList}. For more details on\r\n- * MethodQL, see the OpenJPA Reference Guide.</li>\r\n- * </ul></li>\r\n- * </ul>\r\n- *\r\n- * @since 3.1\r\n- */\r\n-public abstract class AbstractStoreManager implements StoreManager {\r\n-\r\n-    protected StoreContext ctx;\r\n-\r\n-    public final void setContext(StoreContext ctx) {\r\n-        this.ctx = ctx;\r\n-        open();\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the {@link StoreContext} that this store manager is\r\n-     * associated with.\r\n-     */\r\n-    public StoreContext getContext() {\r\n-        return ctx;\r\n-    }\r\n-\r\n-    /**\r\n-     * No-op implementation. Ready this store manager for persistent operations.\r\n-     */\r\n-    protected void open() {\r\n-    }\r\n-\r\n-    /**\r\n-     * No-op implementation. Override this method to provide optimistic\r\n-     * locking semantics for your data store if you need notification of\r\n-     * the beginning of an optimistic transaction.\r\n-     */\r\n-    public void beginOptimistic() {\r\n-    }\r\n-\r\n-    /**\r\n-     * No-op implementation. Override this method to provide optimistic\r\n-     * locking semantics for your data store if you need notification of\r\n-     * a rollback of an optimistic transaction before {@link #begin} is invoked.\r\n-     */\r\n-    public void rollbackOptimistic() {\r\n-    }\r\n-\r\n-    /**\r\n-     * OpenJPA assumes that after this method is invoked, all data\r\n-     * accesses through this store manager will be part of a single\r\n-     * unit of work that can be rolled back.\r\n-     * This is a no-op implementation. If your data store does not\r\n-     * support any concept of locking or transactions, you need not\r\n-     * override this method.\r\n-     */\r\n-    public void begin() {\r\n-    }\r\n-\r\n-    /**\r\n-     * This is a no-op implementation. If your data store does not\r\n-     * have a concept of transactions or a unit of work, you need not\r\n-     * override this method. If it does, then override this method to\r\n-     * notify the data store that the current transaction should be committed.\r\n-     */\r\n-    public void commit() {\r\n-    }\r\n-\r\n-    /**\r\n-     * This is a no-op implementation. If your data store does not\r\n-     * have a concept of transactions or a unit of work, you need not\r\n-     * override this method. If it does, then override this method to\r\n-     * notify the data store that the current transaction should be rolled back.\r\n-     */\r\n-    public void rollback() {\r\n-    }\r\n-\r\n-    /**\r\n-     * Since this store manager does not provide optimistic locking\r\n-     * support, this method always returns <code>true</code>.\r\n-     */\r\n-    public boolean syncVersion(OpenJPAStateManager sm, Object context) {\r\n-        return true;\r\n-    }\r\n-\r\n-    /**\r\n-     * This method is invoked when OpenJPA needs to load an object whose\r\n-     * identity is known but which has not yet been loaded from the data\r\n-     * store. <code>sm</code> is a partially-set-up state manager for this\r\n-     * object. The ID and least-derived type information for the instance\r\n-     * to load can be obtained by invoking\r\n-     * <code>sm.getObjectId()</code> and <code>sm.getMetaData()</code>.\r\n-     * <p/>\r\n-     * When implementing this method, load the data for this object from\r\n-     * the data store, determine the most-derived subclass of the newly-loaded\r\n-     * data, and then use the {@link OpenJPAStateManager#initialize} method to\r\n-     * populate <code>sm</code> with a new instance of the appropriate type.\r\n-     * Once {@link OpenJPAStateManager#initialize} has been invoked, proceed to\r\n-     * load field data into <code>sm</code> as in the {@link #load} method, by\r\n-     * using {@link OpenJPAStateManager#store} (or the appropriate\r\n-     * <code>OpenJPAStateManager.store<em>type</em></code> method) to put the\r\n-     * data into the object.\r\n-     */\r\n-    public abstract boolean initialize(OpenJPAStateManager sm, PCState state,\r\n-        FetchState fetchState, Object context);\r\n-\r\n-    /**\r\n-     * This method is invoked when OpenJPA needs to load additional data\r\n-     * into an object that has already been at least partially loaded by\r\n-     * a previous {@link #initialize} invocation.\r\n-     * Load data into <code>sm</code> by using {@link\r\n-     * OpenJPAStateManager#store} (or the appropriate\r\n-     * <code>OpenJPAStateManager.store<em>type</em></code> method) to put the\r\n-     * data into the object.\r\n-     */\r\n-    public abstract boolean load(OpenJPAStateManager sm, BitSet fields,\r\n-        FetchState fetchState, int lockLevel, Object context);\r\n-\r\n-    /**\r\n-     * This implementation just delegates to the proper singular\r\n-     * method({@link StoreManager#initialize} or {@link StoreManager#load})\r\n-     * depending on each state manager's state. If your data store provides\r\n-     * bulk loading APIs, overriding this method to be more clever may be\r\n-     * advantageous.\r\n-     */\r\n-    public Collection loadAll(Collection sms, PCState state, int load,\r\n-        FetchState fetchState, Object context) {\r\n-        return ImplHelper.loadAll(sms, this, state, load, fetchState, context);\r\n-    }\r\n-\r\n-    /**\r\n-     * Breaks down <code>states</code> based on the objects' current\r\n-     * states, and delegates to\r\n-     * {@link #flush(Collection,Collection,Collection,Collection,Collection)}.\r\n-     */\r\n-    public Collection flush(Collection sms) {\r\n-        // break down state managers by state; initialize as empty lists;\r\n-        // use constants for efficiency\r\n-        Collection pNew = new LinkedList();\r\n-        Collection pNewUpdated = new LinkedList();\r\n-        Collection pNewFlushedDeleted = new LinkedList();\r\n-        Collection pDirty = new LinkedList();\r\n-        Collection pDeleted = new LinkedList();\r\n-        OpenJPAStateManager sm;\r\n-        for (Iterator itr = sms.iterator(); itr.hasNext();) {\r\n-            sm = (OpenJPAStateManager) itr.next();\r\n-            if (sm.getPCState() == PCState.PNEW && !sm.isFlushed())\r\n-                pNew.add(sm);\r\n-            else if (sm.getPCState() == PCState.PNEW && sm.isFlushed())\r\n-                pNewUpdated.add(sm);\r\n-            else if (sm.getPCState() == PCState.PNEWFLUSHEDDELETED)\r\n-                pNewFlushedDeleted.add(sm);\r\n-            else if (sm.getPCState() == PCState.PDIRTY)\r\n-                pDirty.add(sm);\r\n-            else if (sm.getPCState() == PCState.PDELETED)\r\n-                pDeleted.add(sm);\r\n-        }\r\n-        // no dirty instances to flush?\r\n-        if (pNew.isEmpty() && pNewUpdated.isEmpty()\r\n-            && pNewFlushedDeleted.isEmpty() && pDirty.isEmpty()\r\n-            && pDeleted.isEmpty())\r\n-            return Collections.EMPTY_LIST;\r\n-        return flush(pNew, pNewUpdated, pNewFlushedDeleted, pDirty, pDeleted);\r\n-    }\r\n-\r\n-    public void beforeStateChange(OpenJPAStateManager sm, PCState fromState,\r\n-        PCState toState) {\r\n-    }\r\n-\r\n-    public boolean assignObjectId(OpenJPAStateManager sm, boolean preFlush) {\r\n-        ClassMetaData meta = sm.getMetaData();\r\n-        if (meta.getIdentityType() == ClassMetaData.ID_APPLICATION)\r\n-            return ApplicationIds.assign(sm, this, preFlush);\r\n-        // datastore identity\r\n-        Object val = ImplHelper.generateIdentityValue(ctx, meta,\r\n-            JavaTypes.LONG);\r\n-        return assignDataStoreId(sm, val);\r\n-    }\r\n-\r\n-    /**\r\n-     * Assign a new datastore identity to the given instance. This given\r\n-     * value may be null.\r\n-     */\r\n-    protected boolean assignDataStoreId(OpenJPAStateManager sm, Object val) {\r\n-        ClassMetaData meta = sm.getMetaData();\r\n-        if (val == null && meta.getIdentityStrategy() != ValueStrategies.NATIVE)\r\n-            return false;\r\n-        if (val == null)\r\n-            val = getDataStoreIdSequence(meta).next(ctx, meta);\r\n-        sm.setObjectId(newDataStoreId(val, meta));\r\n-        return true;\r\n-    }\r\n-\r\n-    public boolean assignField(OpenJPAStateManager sm, int field,\r\n-        boolean preFlush) {\r\n-        FieldMetaData fmd = sm.getMetaData().getField(field);\r\n-        Object val = ImplHelper.generateFieldValue(ctx, fmd);\r\n-        if (val == null)\r\n-            return false;\r\n-        sm.store(field, val);\r\n-        return true;\r\n-    }\r\n-\r\n-    public Class getManagedType(Object oid) {\r\n-        if (oid instanceof Id)\r\n-            return ((Id) oid).getType();\r\n-        return null;\r\n-    }\r\n-\r\n-    public Class getDataStoreIdType(ClassMetaData meta) {\r\n-        return Id.class;\r\n-    }\r\n-\r\n-    public Object copyDataStoreId(Object oid, ClassMetaData meta) {\r\n-        Id id = (Id) oid;\r\n-        return new Id(meta.getDescribedType(), id.getId(), id.hasSubclasses());\r\n-    }\r\n-\r\n-    public Object newDataStoreId(Object val, ClassMetaData meta) {\r\n-        // we use base types for all oids\r\n-        while (meta.getPCSuperclass() != null)\r\n-            meta = meta.getPCSuperclassMetaData();\r\n-        return Id.newInstance(meta.getDescribedType(), val);\r\n-    }\r\n-\r\n-    /**\r\n-     * Override to retain a dedicated connection.\r\n-     */\r\n-    public void retainConnection() {\r\n-    }\r\n-\r\n-    /**\r\n-     * Override to release previously-retained connection.\r\n-     */\r\n-    public void releaseConnection() {\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns <code>null</code>. If your data store can provide a\r\n-     * distinct connection object, return it here.\r\n-     */\r\n-    public Object getClientConnection() {\r\n-        return null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a {@link ResultObjectProvider} that can return all instances\r\n-     * of <code>type</code>, optionally including subclasses as defined\r\n-     * by <code>subclasses</code>.\r\n-     * The implementation of the result provider will typically execute\r\n-     * some sort of data store query to find all the applicable objects, loop\r\n-     * through the returned data, extracting object IDs from the data, and\r\n-     * invoking {@link StoreContext#find(Object,FetchState,BitSet,Object,int)}\r\n-     * on each OID. When invoking this method, the first argument is the OID.\r\n-     * The second is the given fetch configuration. The\r\n-     * third argument is a mask of fields to exclude from loading; it will\r\n-     * typically be null. The last argument is an object that will be passed\r\n-     * through to {@link #initialize} or {@link #load}, and typically will\r\n-     * contain the actual data to load. For example, for a JDBC-based store\r\n-     * manager, this might be the result set that is being iterated over. If\r\n-     * this argument is <code>null</code>, then the {@link #initialize} or\r\n-     * {@link #load} method will have to issue another command to the data\r\n-     * store in order to fetch the data to be loaded.\r\n-     */\r\n-    public abstract ResultObjectProvider executeExtent(ClassMetaData meta,\r\n-        boolean subs, FetchConfiguration fetch);\r\n-\r\n-    public StoreQuery newQuery(String language) {\r\n-        return null;\r\n-    }\r\n-\r\n-    public FetchConfiguration newFetchConfiguration() {\r\n-        return new FetchConfigurationImpl();\r\n-    }\r\n-\r\n-    /**\r\n-     * Casts <code>v1</code> and <code>v2</code> to {@link Comparable}, and\r\n-     * invokes <code>v1.compareTo(v2)</code>. If <code>v1</code> is less\r\n-     * than <code>v2</code>, returns {@link #VERSION_EARLIER}. If the same,\r\n-     * returns {@link #VERSION_SAME}. Otherwise, returns {@link\r\n-     * #VERSION_LATER}. If either <code>v1</code> or <code>v2</code> are\r\n-     * <code>null</code>, returns {@link #VERSION_DIFFERENT}.\r\n-     */\r\n-    public int compareVersion(OpenJPAStateManager state, Object v1, Object v2) {\r\n-        if (v1 == null || v2 == null)\r\n-            return VERSION_DIFFERENT;\r\n-        int compare = ((Comparable) v1).compareTo((Comparable) v2);\r\n-        if (compare < 0)\r\n-            return VERSION_EARLIER;\r\n-        if (compare == 0)\r\n-            return VERSION_SAME;\r\n-        return VERSION_LATER;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the system-configured sequence. To use some other sort\r\n-     * of datastore identifier(a GUID, string, or someting of that nature),\r\n-     * override {@link #getManagedType},\r\n-     * {@link #getDataStoreIdType}, {@link #copyDataStoreId},\r\n-     * {@link #newDataStoreId}.\r\n-     */\r\n-    public Seq getDataStoreIdSequence(ClassMetaData forClass) {\r\n-        return ctx.getConfiguration().getSequenceInstance();\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns null.\r\n-     */\r\n-    public Seq getValueSequence(FieldMetaData forField) {\r\n-        return null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns <code>false</code>. If your data store supports\r\n-     * cancelling queries, this method should cancel any\r\n-     * currently-running queries and return <code>true</code> if any\r\n-     * were cancelled.\r\n-     */\r\n-    public boolean cancelAll() {\r\n-        return false;\r\n-    }\r\n-\r\n-    public void close() {\r\n-    }\r\n-\r\n-    /**\r\n-     * Responsible for writing modifications happened back to the data\r\n-     * store. If you do not remove the\r\n-     * {@link OpenJPAConfiguration#OPTION_INC_FLUSH} option in\r\n-     * {@link #getUnsupportedOptions}, this will be called only once at the\r\n-     * end of a transaction. Otherwise, it may be called periodically\r\n-     * throughout the course of a transaction.\r\n-     * If this store manager supports optimistic transactions, datastore\r\n-     * version information should be updated during flush, and the state\r\n-     * manager's version indicator should be updated through the\r\n-     * {@link OpenJPAStateManager#setNextVersion} method.\r\n-     * This method will only be invoked if there are meaningful changes\r\n-     * to store. This differs from the behavior of {@link StoreManager#flush},\r\n-     * which may be invoked with a collection of objects in states that\r\n-     * do not require any datastore action(for example, objects in the\r\n-     * transient-transactional state).\r\n-     *\r\n-     * @param pNew               Objects that should be added to the store,\r\n-     *                           and that have not previously been flushed.\r\n-     * @param pNewUpdated        New objects that have been modified since\r\n-     *                           they were initially flushed. These were\r\n-     *                           in <code>persistentNew</code> in an earlier flush invocation.\r\n-     * @param pNewFlushedDeleted New objects that have been deleted since\r\n-     *                           they were initially flushed. These were\r\n-     *                           in <code>persistentNew</code> in an earlier flush invocation.\r\n-     * @param pDirty             Objects that were loaded from the data\r\n-     *                           store and have since been modified.\r\n-     * @param pDeleted           Objects that were loaded from the data\r\n-     *                           store and have since been deleted. These\r\n-     *                           may have been in a previous flush invocation's persistentDirty list.\r\n-     * @return a collection of exceptions encountered during flushing.\r\n-     */\r\n-    protected abstract Collection flush(Collection pNew,\r\n-        Collection pNewUpdated, Collection pNewFlushedDeleted,\r\n-        Collection pDirty, Collection pDeleted);\r\n-\r\n-    /**\r\n-     * Return a new configuration instance for this runtime. Configuration\r\n-     * data is maintained at the factory level and is available to all OpenJPA\r\n-     * components; therefore it is a good place to maintain shared resources\r\n-     * such as connection pools, etc.\r\n-     */\r\n-    protected OpenJPAConfiguration newConfiguration() {\r\n-        return new OpenJPAConfigurationImpl();\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns a set of option names that this store manager does\r\n-     * not support. By default, returns the following:\r\n-     * <ul>\r\n-     * <li>{@link OpenJPAConfiguration#OPTION_OPTIMISTIC}</li>\r\n-     * <li>{@link OpenJPAConfiguration#OPTION_ID_DATASTORE}</li>\r\n-     * <li>{@link OpenJPAConfiguration#OPTION_INC_FLUSH}</li>\r\n-     * <li>{@link OpenJPAConfiguration#OPTION_VALUE_AUTOASSIGN}</li>\r\n-     * <li>{@link OpenJPAConfiguration#OPTION_VALUE_INCREMENT}</li>\r\n-     * <li>{@link OpenJPAConfiguration#OPTION_DATASTORE_CONNECTION}</li>\r\n-     * </ul>\r\n-     */\r\n-    protected Collection getUnsupportedOptions() {\r\n-        Collection c = new HashSet();\r\n-        c.add(OpenJPAConfiguration.OPTION_OPTIMISTIC);\r\n-        c.add(OpenJPAConfiguration.OPTION_ID_DATASTORE);\r\n-        c.add(OpenJPAConfiguration.OPTION_INC_FLUSH);\r\n-        c.add(OpenJPAConfiguration.OPTION_VALUE_AUTOASSIGN);\r\n-        c.add(OpenJPAConfiguration.OPTION_VALUE_INCREMENT);\r\n-        c.add(OpenJPAConfiguration.OPTION_DATASTORE_CONNECTION);\r\n-        return c;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns a string name to identify the platform of this\r\n-     * store manager. Returns the class name of this store manager by default.\r\n-     */\r\n-    protected String getPlatform() {\r\n-        return getClass().getName();\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.abstractstore;\n+\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.FetchConfigurationImpl;\n+import org.apache.openjpa.kernel.FetchState;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.PCState;\n+import org.apache.openjpa.kernel.Seq;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.ValueStrategies;\n+import org.apache.openjpa.util.ApplicationIds;\n+import org.apache.openjpa.util.Id;\n+import org.apache.openjpa.util.ImplHelper;\n+\n+/**\n+ * <p>Abstract store manager implementation to ease development of custom\n+ * OpenJPA back-ends.  A concrete subclass must define implementations for the\n+ * following methods:\n+ * <ul>\n+ * <li>{@link StoreManager#exists}</li>\n+ * <li>{@link #initialize}</li>\n+ * <li>{@link #load}</li>\n+ * <li>{@link\n+ * #flush(Collection,Collection,Collection,Collection,Collection)}</li>\n+ * <li>{@link #executeExtent}</li>\n+ * </ul>\n+ * Additionally, subclasses should not attempt to acquire resources\n+ * until {@link #open} has been called.  Store manager instances might be\n+ * created to call metadata methods such as {@link #newConfiguration} or\n+ * {@link #getUnsupportedOptions} and never opened.  These instances should\n+ * not consume any data store resources.</p>\n+ * <p/>\n+ * <p>Notes:\n+ * <ul>\n+ * <li>The {@link StoreManager#initialize} method is responsible\n+ * for creating new instances of objects freshly loaded from the\n+ * database. The method will be invoked with a {@link OpenJPAStateManager}\n+ * that the newly-loaded object should be associated with. To create the\n+ * new object and set up this association correctly, the implementation\n+ * should use the {@link OpenJPAStateManager#initialize} method.</li>\n+ * <li>If your data store supports some sort of transaction or\n+ * unit of work, you should override the {@link #begin}, {@link #commit},\n+ * and {@link #rollback} methods.</li>\n+ * <li>This class provides no infrastructure support for optimistic\n+ * transactions. To provide optimistic transaction support:\n+ * <ul>\n+ * <li>Override {@link #beginOptimistic}, {@link #rollbackOptimistic},\n+ * and {@link #syncVersion}.</li>\n+ * <li>Override {@link #getUnsupportedOptions} to not include {@link\n+ * OpenJPAConfiguration#OPTION_OPTIMISTIC} in the list of unsupported\n+ * options.</li>\n+ * <li>Ensure that your flush implementation sets the next\n+ * version for each modified object via the {@link\n+ * OpenJPAStateManager#setNextVersion} method.</li>\n+ * <li>If your version object does not implement {@link Comparable},\n+ * override {@link #compareVersion}, which relies on the\n+ * {@link Comparable#compareTo} method.</li>\n+ * </ul></li>\n+ * <li>If your data store supports a mechanism for automatically\n+ * generating and managing identity values (or if you want to\n+ * provide that facility on top of your data store), implement\n+ * the {@link #getDataStoreIdSequence} method if you want to use a\n+ * <code>long</code> as your datastore identity type and are\n+ * happy with OpenJPA's {@link Id} class.  To use another datastore identity\n+ * type, override {@link #getManagedType},\n+ * {@link #getDataStoreIdType}, {@link #copyDataStoreId}, and\n+ * {@link #newDataStoreId} instead. In either case, override\n+ * {@link #getUnsupportedOptions} to not include\n+ * {@link OpenJPAConfiguration#OPTION_ID_DATASTORE} in the list of\n+ * unsupported options.</li>\n+ * <li>If your data store does not support queries (or if you do\n+ * not want to convert OpenJPA's query parse tree into a\n+ * datastore-specific query), you still have two options in terms\n+ * of query execution:\n+ * <ul>\n+ * <li><em>In-memory execution</em>: If you\n+ * execute a query against an extent or a class, OpenJPA will\n+ * automatically load the full extent of objects into memory and\n+ * execute the query in memory.</li>\n+ * <li><em>org.apache.openjpa.MethodQL</em>: MethodQL allows\n+ * you to use the query APIs to execute a method that finds\n+ * data in your back-end and returns that data as a\n+ * {@link org.apache.openjpa.lib.rop.ResultList}. For more details on\n+ * MethodQL, see the OpenJPA Reference Guide.</li>\n+ * </ul></li>\n+ * </ul></p>\n+ *\n+ * @since 3.1\n+ */\n+public abstract class AbstractStoreManager\n+    implements StoreManager {\n+\n+    protected StoreContext ctx;\n+\n+    public final void setContext(StoreContext ctx) {\n+        this.ctx = ctx;\n+        open();\n+    }\n+\n+    /**\n+     * Returns the {@link StoreContext} that this store manager is\n+     * associated with.\n+     */\n+    public StoreContext getContext() {\n+        return ctx;\n+    }\n+\n+    /**\n+     * No-op implementation. Ready this store manager for persistent\n+     * operations.\n+     */\n+    protected void open() {\n+    }\n+\n+    /**\n+     * No-op implementation. Override this method to provide optimistic\n+     * locking semantics for your data store if you need notification of\n+     * the beginning of an optimistic transaction.\n+     */\n+    public void beginOptimistic() {\n+    }\n+\n+    /**\n+     * No-op implementation. Override this method to provide optimistic\n+     * locking semantics for your data store if you need notification of\n+     * a rollback of an optimistic transaction before {@link #begin} is\n+     * invoked.\n+     */\n+    public void rollbackOptimistic() {\n+    }\n+\n+    /**\n+     * <p>OpenJPA assumes that after this method is invoked, all data\n+     * accesses through this store manager will be part of a single\n+     * unit of work that can be rolled back.</p>\n+     * <p/>\n+     * <p>This is a no-op implementation. If your data store does not\n+     * support any concept of locking or transactions, you need not\n+     * override this method.</p>\n+     */\n+    public void begin() {\n+    }\n+\n+    /**\n+     * This is a no-op implementation. If your data store does not\n+     * have a concept of transactions or a unit of work, you need not\n+     * override this method. If it does, then override this method to\n+     * notify the data store that the current transaction should be\n+     * committed.\n+     */\n+    public void commit() {\n+    }\n+\n+    /**\n+     * This is a no-op implementation. If your data store does not\n+     * have a concept of transactions or a unit of work, you need not\n+     * override this method. If it does, then override this method to\n+     * notify the data store that the current transaction should be\n+     * rolled back.\n+     */\n+    public void rollback() {\n+    }\n+\n+    /**\n+     * Since this store manager does not provide optimistic locking\n+     * support, this method always returns <code>true</code>.\n+     */\n+    public boolean syncVersion(OpenJPAStateManager sm, Object context) {\n+        return true;\n+    }\n+\n+    /**\n+     * <p>This method is invoked when OpenJPA needs to load an object whose\n+     * identity is known but which has not yet been loaded from the data\n+     * store. <code>sm</code> is a partially-set-up state manager for this\n+     * object. The ID and least-derived type information for the instance\n+     * to load can be obtained by invoking\n+     * <code>sm.getObjectId()</code> and <code>sm.getMetaData()</code>.\n+     * </p>\n+     * <p/>\n+     * <p>When implementing this method, load the data for this object from\n+     * the data store, determine the most-derived subclass of the newly-loaded\n+     * data, and then use the {@link OpenJPAStateManager#initialize} method to\n+     * populate <code>sm</code> with a new instance of the appropriate type.\n+     * Once {@link OpenJPAStateManager#initialize} has been invoked, proceed to\n+     * load field data into <code>sm</code> as in the {@link #load} method, by\n+     * using {@link OpenJPAStateManager#store} (or the appropriate\n+     * <code>OpenJPAStateManager.store<em>type</em></code> method) to put the\n+     * data into the object.</p>\n+     */\n+    public abstract boolean initialize(OpenJPAStateManager sm, PCState state,\n+        FetchState fetchState, Object context);\n+\n+    /**\n+     * <p>This method is invoked when OpenJPA needs to load additional data\n+     * into an object that has already been at least partially loaded by\n+     * a previous {@link #initialize} invocation.</p>\n+     * <p/>\n+     * <p>Load data into <code>sm</code> by using {@link\n+     * OpenJPAStateManager#store} (or the appropriate\n+     * <code>OpenJPAStateManager.store<em>type</em></code> method) to put the\n+     * data into the object.</p>\n+     */\n+    public abstract boolean load(OpenJPAStateManager sm, BitSet fields,\n+        FetchState fetchState, int lockLevel, Object context);\n+\n+    /**\n+     * This implementation just delegates to the proper singular\n+     * method ({@link StoreManager#initialize} or {@link StoreManager#load})\n+     * depending on each state manager's state. If your data store provides\n+     * bulk loading APIs, overriding this method to be more clever may be\n+     * advantageous.\n+     */\n+    public Collection loadAll(Collection sms, PCState state, int load,\n+        FetchState fetchState, Object context) {\n+        return ImplHelper.loadAll(sms, this, state, load, fetchState, context);\n+    }\n+\n+    /**\n+     * Breaks down <code>states</code> based on the objects' current\n+     * states, and delegates to\n+     * {@link #flush(Collection,Collection,Collection,Collection,Collection)}.\n+     */\n+    public Collection flush(Collection sms) {\n+        // break down state managers by state; initialize as empty lists;\n+        // use constants for efficiency\n+        Collection pNew = new LinkedList();\n+        Collection pNewUpdated = new LinkedList();\n+        Collection pNewFlushedDeleted = new LinkedList();\n+        Collection pDirty = new LinkedList();\n+        Collection pDeleted = new LinkedList();\n+\n+        OpenJPAStateManager sm;\n+        for (Iterator itr = sms.iterator(); itr.hasNext();) {\n+            sm = (OpenJPAStateManager) itr.next();\n+            if (sm.getPCState() == PCState.PNEW && !sm.isFlushed())\n+                pNew.add(sm);\n+            else if (sm.getPCState() == PCState.PNEW && sm.isFlushed())\n+                pNewUpdated.add(sm);\n+            else if (sm.getPCState() == PCState.PNEWFLUSHEDDELETED)\n+                pNewFlushedDeleted.add(sm);\n+            else if (sm.getPCState() == PCState.PDIRTY)\n+                pDirty.add(sm);\n+            else if (sm.getPCState() == PCState.PDELETED)\n+                pDeleted.add(sm);\n+        }\n+\n+        // no dirty instances to flush?\n+        if (pNew.isEmpty() && pNewUpdated.isEmpty()\n+            && pNewFlushedDeleted.isEmpty() && pDirty.isEmpty()\n+            && pDeleted.isEmpty())\n+            return Collections.EMPTY_LIST;\n+\n+        return flush(pNew, pNewUpdated, pNewFlushedDeleted, pDirty, pDeleted);\n+    }\n+\n+    public void beforeStateChange(OpenJPAStateManager sm, PCState fromState,\n+        PCState toState) {\n+    }\n+\n+    public boolean assignObjectId(OpenJPAStateManager sm, boolean preFlush) {\n+        ClassMetaData meta = sm.getMetaData();\n+        if (meta.getIdentityType() == ClassMetaData.ID_APPLICATION)\n+            return ApplicationIds.assign(sm, this, preFlush);\n+\n+        // datastore identity\n+        Object val = ImplHelper.generateIdentityValue(ctx, meta,\n+            JavaTypes.LONG);\n+        return assignDataStoreId(sm, val);\n+    }\n+\n+    /**\n+     * Assign a new datastore identity to the given instance.  This given\n+     * value may be null.\n+     */\n+    protected boolean assignDataStoreId(OpenJPAStateManager sm, Object val) {\n+        ClassMetaData meta = sm.getMetaData();\n+        if (val == null && meta.getIdentityStrategy() != ValueStrategies.NATIVE)\n+            return false;\n+        if (val == null)\n+            val = getDataStoreIdSequence(meta).next(ctx, meta);\n+        sm.setObjectId(newDataStoreId(val, meta));\n+        return true;\n+    }\n+\n+    public boolean assignField(OpenJPAStateManager sm, int field,\n+        boolean preFlush) {\n+        FieldMetaData fmd = sm.getMetaData().getField(field);\n+        Object val = ImplHelper.generateFieldValue(ctx, fmd);\n+        if (val == null)\n+            return false;\n+        sm.store(field, val);\n+        return true;\n+    }\n+\n+    public Class getManagedType(Object oid) {\n+        if (oid instanceof Id)\n+            return ((Id) oid).getType();\n+        return null;\n+    }\n+\n+    public Class getDataStoreIdType(ClassMetaData meta) {\n+        return Id.class;\n+    }\n+\n+    public Object copyDataStoreId(Object oid, ClassMetaData meta) {\n+        Id id = (Id) oid;\n+        return new Id(meta.getDescribedType(), id.getId(),\n+            id.hasSubclasses());\n+    }\n+\n+    public Object newDataStoreId(Object val, ClassMetaData meta) {\n+        // we use base types for all oids\n+        while (meta.getPCSuperclass() != null)\n+            meta = meta.getPCSuperclassMetaData();\n+        return Id.newInstance(meta.getDescribedType(), val);\n+    }\n+\n+    /**\n+     * Override to retain a dedicated connection.\n+     */\n+    public void retainConnection() {\n+    }\n+\n+    /**\n+     * Override to release previously-retained connection.\n+     */\n+    public void releaseConnection() {\n+    }\n+\n+    /**\n+     * Returns <code>null</code>. If your data store can provide a\n+     * distinct connection object, return it here.\n+     */\n+    public Object getClientConnection() {\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Create a {@link ResultObjectProvider} that can return all instances\n+     * of <code>type</code>, optionally including subclasses as defined\n+     * by <code>subclasses</code>.</p>\n+     * <p/>\n+     * <p>The implementation of the result provider will typically execute\n+     * some sort of data store query to find all the applicable objects, loop\n+     * through the returned data, extracting object IDs from the data, and\n+     * invoking {@link\n+     * StoreContext#find(Object,FetchState,BitSet,Object,int)}\n+     * on each OID. When invoking this method, the first argument is the OID.\n+     * The second is the given fetch configuration. The\n+     * third argument is a mask of fields to exclude from loading; it will\n+     * typically be null. The last argument is an object that will be passed\n+     * through to {@link #initialize} or {@link #load}, and typically will\n+     * contain the actual data to load. For example, for a JDBC-based store\n+     * manager, this might be the result set that is being iterated over. If\n+     * this argument is <code>null</code>, then the {@link #initialize} or\n+     * {@link #load} method will have to issue another command to the data\n+     * store in order to fetch the data to be loaded.</p>\n+     */\n+    public abstract ResultObjectProvider executeExtent(ClassMetaData meta,\n+        boolean subs, FetchConfiguration fetch);\n+\n+    public StoreQuery newQuery(String language) {\n+        return null;\n+    }\n+\n+    public FetchConfiguration newFetchConfiguration() {\n+        return new FetchConfigurationImpl();\n+    }\n+\n+    /**\n+     * <p>Casts <code>v1</code> and <code>v2</code> to {@link Comparable}, and\n+     * invokes <code>v1.compareTo (v2)</code>. If <code>v1</code> is less\n+     * than <code>v2</code>, returns {@link #VERSION_EARLIER}. If the same,\n+     * returns {@link #VERSION_SAME}. Otherwise, returns {@link\n+     * #VERSION_LATER}. If either <code>v1</code> or <code>v2</code> are\n+     * <code>null</code>, returns {@link #VERSION_DIFFERENT}.</p>\n+     */\n+    public int compareVersion(OpenJPAStateManager state, Object v1, Object v2) {\n+        if (v1 == null || v2 == null)\n+            return VERSION_DIFFERENT;\n+\n+        int compare = ((Comparable) v1).compareTo((Comparable) v2);\n+        if (compare < 0)\n+            return VERSION_EARLIER;\n+        if (compare == 0)\n+            return VERSION_SAME;\n+        return VERSION_LATER;\n+    }\n+\n+    /**\n+     * Returns the system-configured sequence. To use some other sort\n+     * of datastore identifier (a GUID, string, or someting of that nature),\n+     * override {@link #getManagedType},\n+     * {@link #getDataStoreIdType}, {@link #copyDataStoreId},\n+     * {@link #newDataStoreId}.\n+     */\n+    public Seq getDataStoreIdSequence(ClassMetaData forClass) {\n+        return ctx.getConfiguration().getSequenceInstance();\n+    }\n+\n+    /**\n+     * Returns null.\n+     */\n+    public Seq getValueSequence(FieldMetaData forField) {\n+        return null;\n+    }\n+\n+    /**\n+     * Returns <code>false</code>. If your data store supports\n+     * cancelling queries, this method should cancel any\n+     * currently-running queries and return <code>true</code> if any\n+     * were cancelled.\n+     */\n+    public boolean cancelAll() {\n+        return false;\n+    }\n+\n+    public void close() {\n+    }\n+\n+    /**\n+     * <p>Responsible for writing modifications happened back to the data\n+     * store. If you do not remove the\n+     * {@link OpenJPAConfiguration#OPTION_INC_FLUSH} option in\n+     * {@link #getUnsupportedOptions}, this will be called only once at the\n+     * end\tof a transaction. Otherwise, it may be called periodically\n+     * throughout the course of a transaction.</p>\n+     * <p/>\n+     * <p>If this store manager supports optimistic transactions, datastore\n+     * version information should be updated during flush, and the state\n+     * manager's version indicator should be updated through the\n+     * {@link OpenJPAStateManager#setNextVersion} method.</p>\n+     * <p/>\n+     * <p>This method will only be invoked if there are meaningful changes\n+     * to store. This differs from the behavior of {@link StoreManager#flush},\n+     * which may be invoked with a collection of objects in states that\n+     * do not require any datastore action (for example, objects in the\n+     * transient-transactional state).</p>\n+     *\n+     * @param pNew Objects that should be added to the store,\n+     * and that have not previously been flushed.\n+     * @param pNewUpdated New objects that have been modified since\n+     * they were initially flushed. These were\n+     * in <code>persistentNew</code> in an earlier\n+     * flush invocation.\n+     * @param pNewFlushedDeleted New objects that have been deleted since\n+     * they were initially flushed. These were\n+     * in <code>persistentNew</code> in an earlier\n+     * flush invocation.\n+     * @param pDirty Objects that were loaded from the data\n+     * store and have since been modified.\n+     * @param pDeleted Objects that were loaded from the data\n+     * store and have since been deleted. These\n+     * may have been in a previous flush\n+     * invocation's persistentDirty list.\n+     * @return a collection of exceptions encountered during flushing.\n+     */\n+    protected abstract Collection flush(Collection pNew,\n+        Collection pNewUpdated, Collection pNewFlushedDeleted,\n+        Collection pDirty, Collection pDeleted);\n+\n+    /**\n+     * Return a new configuration instance for this runtime.  Configuration\n+     * data is maintained at the factory level and is available to all OpenJPA\n+     * components; therefore it is a good place to maintain shared resources\n+     * such as connection pools, etc.</p>\n+     */\n+    protected OpenJPAConfiguration newConfiguration() {\n+        return new OpenJPAConfigurationImpl();\n+    }\n+\n+    /**\n+     * <p>Returns a set of option names that this store manager does\n+     * not support.  By default, returns the following:\n+     * <ul>\n+     * <li>{@link OpenJPAConfiguration#OPTION_OPTIMISTIC}</li>\n+     * <li>{@link OpenJPAConfiguration#OPTION_ID_DATASTORE}</li>\n+     * <li>{@link OpenJPAConfiguration#OPTION_INC_FLUSH}</li>\n+     * <li>{@link OpenJPAConfiguration#OPTION_VALUE_AUTOASSIGN}</li>\n+     * <li>{@link OpenJPAConfiguration#OPTION_VALUE_INCREMENT}</li>\n+     * <li>{@link OpenJPAConfiguration#OPTION_DATASTORE_CONNECTION}</li>\n+     * </ul></p>\n+     */\n+    protected Collection getUnsupportedOptions() {\n+        Collection c = new HashSet();\n+        c.add(OpenJPAConfiguration.OPTION_OPTIMISTIC);\n+        c.add(OpenJPAConfiguration.OPTION_ID_DATASTORE);\n+        c.add(OpenJPAConfiguration.OPTION_INC_FLUSH);\n+        c.add(OpenJPAConfiguration.OPTION_VALUE_AUTOASSIGN);\n+        c.add(OpenJPAConfiguration.OPTION_VALUE_INCREMENT);\n+        c.add(OpenJPAConfiguration.OPTION_DATASTORE_CONNECTION);\n+        return c;\n+    }\n+\n+    /**\n+     *\t<p>Returns a string name to identify the platform of this\n+     *\tstore manager.  Returns the class name of this store manager by\n+     *\tdefault.</p>\n+     */\n+    protected String getPlatform ()\n+\t{\n+\t\treturn getClass ().getName ();\n+\t}\n+}"},{"sha":"746ff6570513c9cf00389773c32b11f28dfa5ddf","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java","status":"modified","additions":89,"deletions":82,"changes":171,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,82 +1,89 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-/*********************************************************************\r\n-\r\n- **********************************************************************/\r\n-package org.apache.openjpa.ant;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.PrintWriter;\r\n-\r\n-import org.apache.tools.ant.BuildException;\r\n-import org.apache.tools.ant.types.EnumeratedAttribute;\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\r\n-import org.apache.openjpa.lib.ant.AbstractTask;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.util.Files;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.meta.MetaDataTool;\r\n-\r\n-/**\r\n- * Executes the metadata tool on the specified files. This task can\r\n- * take the following arguments:\r\n- * <ul>\r\n- * <li><code>file</code></li>\r\n- * </ul>\r\n- */\r\n-public class MetaDataToolTask extends AbstractTask {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (MetaDataToolTask.class);\r\n-    protected MetaDataTool.Flags flags = new MetaDataTool.Flags();\r\n-    protected String fileName = null;\r\n-\r\n-    /**\r\n-     * Set the tool action.\r\n-     */\r\n-    public void setAction(Action act) {\r\n-        flags.action = act.getValue();\r\n-    }\r\n-\r\n-    /**\r\n-     * Set the file to write the metadata to.\r\n-     */\r\n-    public void setFile(String fileName) {\r\n-        this.fileName = fileName;\r\n-    }\r\n-\r\n-    protected Configuration newConfiguration() {\r\n-        return new OpenJPAConfigurationImpl();\r\n-    }\r\n-\r\n-    protected void executeOn(String[] files) throws IOException {\r\n-        ClassLoader loader = getClassLoader();\r\n-        if (\"stdout\".equals(fileName))\r\n-            flags.writer = new PrintWriter(System.out);\r\n-        else if (\"stderr\".equals(fileName))\r\n-            flags.writer = new PrintWriter(System.err);\r\n-        else if (fileName != null)\r\n-            flags.file = Files.getFile(fileName, loader);\r\n-        if (!MetaDataTool.run((OpenJPAConfiguration) getConfiguration(), files,\r\n-            flags, null, loader))\r\n-            throw new BuildException(_loc.get(\"bad-conf\", \"MetaDataToolTask\"));\r\n-    }\r\n-\r\n-    public static class Action extends EnumeratedAttribute {\r\n-\r\n-        public String[] getValues() {\r\n-            return MetaDataTool.ACTIONS;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*********************************************************************\n+\n+ **********************************************************************/\n+package org.apache.openjpa.ant;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+\n+import org.apache.tools.ant.BuildException;\n+import org.apache.tools.ant.types.EnumeratedAttribute;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\n+import org.apache.openjpa.lib.ant.AbstractTask;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.util.Files;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.MetaDataTool;\n+\n+/**\n+ * <p>Executes the metadata tool on the specified files.  This task can\n+ * take the following arguments:\n+ * <ul>\n+ * <li><code>file</code></li>\n+ * </ul></p>\n+ */\n+public class MetaDataToolTask\n+    extends AbstractTask {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (MetaDataToolTask.class);\n+\n+    protected MetaDataTool.Flags flags = new MetaDataTool.Flags();\n+    protected String fileName = null;\n+\n+    /**\n+     * Set the tool action.\n+     */\n+    public void setAction(Action act) {\n+        flags.action = act.getValue();\n+    }\n+\n+    /**\n+     * Set the file to write the metadata to.\n+     */\n+    public void setFile(String fileName) {\n+        this.fileName = fileName;\n+    }\n+\n+    protected Configuration newConfiguration() {\n+        return new OpenJPAConfigurationImpl();\n+    }\n+\n+    protected void executeOn(String[] files)\n+        throws IOException {\n+        ClassLoader loader = getClassLoader();\n+        if (\"stdout\".equals(fileName))\n+            flags.writer = new PrintWriter(System.out);\n+        else if (\"stderr\".equals(fileName))\n+            flags.writer = new PrintWriter(System.err);\n+        else if (fileName != null)\n+            flags.file = Files.getFile(fileName, loader);\n+        if (!MetaDataTool.run((OpenJPAConfiguration) getConfiguration(), files,\n+            flags, null, loader))\n+            throw new BuildException(_loc.get(\"bad-conf\", \"MetaDataToolTask\"));\n+    }\n+\n+    public static class Action\n+        extends EnumeratedAttribute {\n+\n+        public String[] getValues() {\n+            return MetaDataTool.ACTIONS;\n+        }\n+\t}\n+}"},{"sha":"cdbdea3698aa39b0bb51cc07d6a925a9852edf61","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java","status":"modified","additions":99,"deletions":86,"changes":185,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,86 +1,99 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-/*********************************************************************\r\n-\r\n- **********************************************************************/\r\n-package org.apache.openjpa.ant;\r\n-\r\n-import java.io.IOException;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\r\n-import org.apache.openjpa.enhance.PCEnhancer;\r\n-import org.apache.openjpa.lib.ant.AbstractTask;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.util.Files;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-\r\n-/**\r\n- * Executes the enhancer on the specified files. This task can take\r\n- * the following arguments:\r\n- * <ul>\r\n- * <li><code>directory</code></li>\r\n- * <li><code>addDefaultConstructor</code></li>\r\n- * <li><code>tmpClassLoader</code></li>\r\n- * <li><code>enforcePropertyRestrictions</code></li>\r\n- * </ul>\r\n- */\r\n-public class PCEnhancerTask extends AbstractTask {\r\n-\r\n-    protected PCEnhancer.Flags flags = new PCEnhancer.Flags();\r\n-    protected String dirName = null;\r\n-\r\n-    /**\r\n-     * Set the output directory we want the enhancer to write to.\r\n-     */\r\n-    public void setDirectory(String dirName) {\r\n-        this.dirName = dirName;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set whether or not the enhancer should add a no-args constructor\r\n-     * to any PC that does not have a no-args constructor.\r\n-     */\r\n-    public void setAddDefaultConstructor(boolean addDefCons) {\r\n-        flags.addDefaultConstructor = addDefCons;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set whether to fail if the persistent type uses property access and\r\n-     * bytecode analysis shows that it may be violating OpenJPA's property\r\n-     * access restrictions.\r\n-     */\r\n-    public void setEnforcePropertyRestrictions(boolean fail) {\r\n-        flags.enforcePropertyRestrictions = fail;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set whether or not to use a default class loader for loading\r\n-     * the unenhanced classes.\r\n-     */\r\n-    public void setTmpClassLoader(boolean tmpClassLoader) {\r\n-        flags.tmpClassLoader = tmpClassLoader;\r\n-    }\r\n-\r\n-    protected Configuration newConfiguration() {\r\n-        return new OpenJPAConfigurationImpl();\r\n-    }\r\n-\r\n-    protected void executeOn(String[] files) throws IOException {\r\n-        flags.directory = (dirName == null) ? null\r\n-            : Files.getFile(dirName, getClassLoader());\r\n-        OpenJPAConfiguration conf = (OpenJPAConfiguration) getConfiguration();\r\n-        MetaDataRepository repos = new MetaDataRepository(conf);\r\n-        PCEnhancer.run(conf, files, flags, repos, null, getClassLoader());\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*********************************************************************\n+\n+ **********************************************************************/\n+package org.apache.openjpa.ant;\n+\n+import java.io.IOException;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\n+import org.apache.openjpa.enhance.PCEnhancer;\n+import org.apache.openjpa.lib.ant.AbstractTask;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.util.Files;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+\n+/**\n+ * <p>Executes the enhancer on the specified files.  This task can take\n+ * the following arguments:\n+ * <ul>\n+ * <li><code>directory</code></li>\n+ * <li><code>addDefaultConstructor</code></li>\n+ * <li><code>tmpClassLoader</code></li>\n+ * <li><code>jdoEnhance</code></li>\n+ * <li><code>enforcePropertyRestrictions</code></li>\n+ * </ul></p>\n+ */\n+public class PCEnhancerTask\n+    extends AbstractTask {\n+\n+    protected PCEnhancer.Flags flags = new PCEnhancer.Flags();\n+    protected String dirName = null;\n+\n+    /**\n+     * Set the output directory we want the enhancer to write to.\n+     */\n+    public void setDirectory(String dirName) {\n+        this.dirName = dirName;\n+    }\n+\n+    /**\n+     * Set whether or not the enhancer should add a no-args constructor\n+     * to any PC that does not have a no-args constructor.\n+     */\n+    public void setAddDefaultConstructor(boolean addDefCons) {\n+        flags.addDefaultConstructor = addDefCons;\n+    }\n+\n+    /**\n+     * Whether to perform JDO enhancement in addition to OpenJPA enhancement.\n+     */\n+    public void setJdoEnhance(boolean jdoEnhance) {\n+        flags.jdoEnhance = jdoEnhance;\n+    }\n+\n+    /**\n+     * Set whether to fail if the persistent type uses property access and\n+     * bytecode analysis shows that it may be violating OpenJPA's property\n+     * access restrictions.\n+     */\n+    public void setEnforcePropertyRestrictions(boolean fail) {\n+        flags.enforcePropertyRestrictions = fail;\n+    }\n+\n+    /**\n+     * Set whether or not to use a default class loader for loading\n+     * the unenhanced classes.\n+     */\n+    public void setTmpClassLoader(boolean tmpClassLoader) {\n+        flags.tmpClassLoader = tmpClassLoader;\n+    }\n+\n+    protected Configuration newConfiguration() {\n+        return new OpenJPAConfigurationImpl();\n+    }\n+\n+    protected void executeOn(String[] files)\n+        throws IOException {\n+        flags.directory = (dirName == null) ? null\n+            : Files.getFile(dirName, getClassLoader());\n+        OpenJPAConfiguration conf = (OpenJPAConfiguration) getConfiguration();\n+        MetaDataRepository repos = new MetaDataRepository(conf);\n+        PCEnhancer.run(conf, files, flags, repos, null, getClassLoader ());\n+\t}\n+}"},{"sha":"8f3685f0c63f68959e027f2f91e7faefbc850683","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java","status":"modified","additions":91,"deletions":82,"changes":173,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,82 +1,91 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.kernel.AutoDetach;\r\n-import org.apache.openjpa.lib.conf.Value;\r\n-import serp.util.Strings;\r\n-\r\n-/**\r\n- * Value type used to represent auto detach flags. Separate to\r\n- * optimize translation of Strings to bit flags.\r\n- *\r\n- * @author Steve Kim\r\n- * @nojavadoc\r\n- */\r\n-class AutoDetachValue extends Value {\r\n-\r\n-    public static final String DETACH_CLOSE = \"close\";\r\n-    public static final String DETACH_COMMIT = \"commit\";\r\n-    public static final String DETACH_NONTXREAD = \"nontx-read\";\r\n-    private static String[] ALIASES = new String[]{\r\n-        DETACH_CLOSE, String.valueOf(AutoDetach.DETACH_CLOSE),\r\n-        DETACH_COMMIT, String.valueOf(AutoDetach.DETACH_COMMIT),\r\n-        DETACH_NONTXREAD, String.valueOf(AutoDetach.DETACH_NONTXREAD),\r\n-        // for compatibility with JDO DetachAllOnCommit\r\n-        \"true\", String.valueOf(AutoDetach.DETACH_COMMIT), \"false\", \"0\", };\r\n-    private int _flags;\r\n-\r\n-    public AutoDetachValue(String prop) {\r\n-        super(prop);\r\n-        setAliases(ALIASES);\r\n-    }\r\n-\r\n-    public Class getValueType() {\r\n-        return String[].class;\r\n-    }\r\n-\r\n-    public void set(int flags) {\r\n-        _flags = flags;\r\n-    }\r\n-\r\n-    public int get() {\r\n-        return _flags;\r\n-    }\r\n-\r\n-    protected String getInternalString() {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        String[] aliases = getAliases();\r\n-        boolean start = false;\r\n-        for (int i = 0; i < aliases.length; i += 2) {\r\n-            if ((_flags & Integer.parseInt(aliases[i + 1])) != 0) {\r\n-                buf.append(aliases[i]);\r\n-                if (start)\r\n-                    buf.append(\", \");\r\n-                else start = true;\r\n-            }\r\n-        }\r\n-        return buf.toString();\r\n-    }\r\n-\r\n-    public void setInternalString(String val) {\r\n-        String[] vals = Strings.split(val, \",\", 0);\r\n-        for (int i = 0; i < vals.length; i++)\r\n-            _flags |= Integer.parseInt(unalias(vals[i]));\r\n-    }\r\n-\r\n-    public void setInternalObject(Object val) {\r\n-        String[] vals = (String[]) val;\r\n-        for (int i = 0; i < vals.length; i++)\r\n-            _flags |= Integer.parseInt(unalias(vals[i]));\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.kernel.AutoDetach;\n+import org.apache.openjpa.lib.conf.Value;\n+import serp.util.Strings;\n+\n+/**\n+ * <p>Value type used to represent auto detach flags. Separate to\n+ * optimize translation of Strings to bit flags.</p>\n+ *\n+ * @author Steve Kim\n+ * @nojavadoc\n+ */\n+class AutoDetachValue\n+    extends Value {\n+\n+    public static final String DETACH_CLOSE = \"close\";\n+    public static final String DETACH_COMMIT = \"commit\";\n+    public static final String DETACH_NONTXREAD = \"nontx-read\";\n+\n+    private static String[] ALIASES = new String[]{\n+        DETACH_CLOSE, String.valueOf(AutoDetach.DETACH_CLOSE),\n+        DETACH_COMMIT, String.valueOf(AutoDetach.DETACH_COMMIT),\n+        DETACH_NONTXREAD, String.valueOf(AutoDetach.DETACH_NONTXREAD),\n+        // for compatibility with JDO DetachAllOnCommit\n+        \"true\", String.valueOf(AutoDetach.DETACH_COMMIT),\n+        \"false\", \"0\",\n+    };\n+\n+    private int _flags;\n+\n+    public AutoDetachValue(String prop) {\n+        super(prop);\n+        setAliases(ALIASES);\n+    }\n+\n+    public Class getValueType() {\n+        return String[].class;\n+    }\n+\n+    public void set(int flags) {\n+        _flags = flags;\n+    }\n+\n+    public int get() {\n+        return _flags;\n+    }\n+\n+    protected String getInternalString() {\n+        StringBuffer buf = new StringBuffer();\n+        String[] aliases = getAliases();\n+        boolean start = false;\n+        for (int i = 0; i < aliases.length; i += 2) {\n+            if ((_flags & Integer.parseInt(aliases[i + 1])) != 0) {\n+                buf.append(aliases[i]);\n+                if (start)\n+                    buf.append(\", \");\n+                else\n+                    start = true;\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    public void setInternalString(String val) {\n+        String[] vals = Strings.split(val, \",\", 0);\n+        for (int i = 0; i < vals.length; i++)\n+            _flags |= Integer.parseInt(unalias(vals[i]));\n+    }\n+\n+    public void setInternalObject(Object val) {\n+        String[] vals = (String[]) val;\n+        for (int i = 0; i < vals.length; i++)\n+            _flags |= Integer.parseInt(unalias(vals[i]));\n+    }\n+}"},{"sha":"18e0831bb8b31b75e0d6cbf689f871059efec779","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java","status":"modified","additions":47,"deletions":42,"changes":89,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,42 +1,47 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.kernel.BrokerFactory;\r\n-import org.apache.openjpa.lib.conf.PluginValue;\r\n-\r\n-/**\r\n- * Value type used to represent the {@link BrokerFactory}. This type is\r\n- * defined separately so that it can be used both in the global configuration\r\n- * and in {@link OpenJPAHelper} with the same encapsulated configuration.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class BrokerFactoryValue extends PluginValue {\r\n-\r\n-    public static final String KEY = \"org.apache.openjpa.BrokerFactory\";\r\n-    private static final String[] ALIASES = new String[]{\r\n-        \"abstractstore\",\r\n-        \"org.apache.openjpa.abstractstore.AbstractStoreBrokerFactory\",\r\n-    };\r\n-\r\n-    public BrokerFactoryValue() {\r\n-        this(KEY);\r\n-    }\r\n-\r\n-    public BrokerFactoryValue(String prop) {\r\n-        super(prop, false);\r\n-        setAliases(ALIASES);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.kernel.BrokerFactory;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+\n+/**\n+ * <p>Value type used to represent the {@link BrokerFactory}.  This type is\n+ * defined separately so that it can be used both in the global configuration\n+ * and in {@link OpenJPAHelper} with the same encapsulated configuration.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class BrokerFactoryValue\n+    extends PluginValue {\n+\n+    public static final String KEY = \"org.apache.openjpa.BrokerFactory\";\n+\n+    private static final String[] ALIASES = new String[]{\n+        \"abstractstore\",\n+        \"org.apache.openjpa.abstractstore.AbstractStoreBrokerFactory\",\n+    };\n+\n+    public BrokerFactoryValue() {\n+        this(KEY);\n+    }\n+\n+    public BrokerFactoryValue(String prop) {\n+        super(prop, false);\n+        setAliases(ALIASES);\n+    }\n+}"},{"sha":"5a27dd070feb421f2313052f91a86465b14a41b1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","status":"modified","additions":139,"deletions":136,"changes":275,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,136 +1,139 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-/**\r\n- * Struct encompassing backwards-compatibility options.\r\n- */\r\n-public class Compatibility {\r\n-\r\n-    private boolean _strictIdValues = false;\r\n-    private boolean _hollowLookups = true;\r\n-    private boolean _checkStore = false;\r\n-    private boolean _copyIds = false;\r\n-    private boolean _closeOnCommit = true;\r\n-    private boolean _quotedNumbers = false;\r\n-\r\n-    /**\r\n-     * Whether to require exact identity value types when creating object\r\n-     * ids from a class and value. Defaults to false.\r\n-     */\r\n-    public boolean getStrictIdentityValues() {\r\n-        return _strictIdValues;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to require exact identity value types when creating object\r\n-     * ids from a class and value. Defaults to false.\r\n-     */\r\n-    public void setStrictIdentityValues(boolean strictVals) {\r\n-        _strictIdValues = strictVals;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to interpret quoted numbers in query strings as numbers.\r\n-     * OpenJPA versions 3.1 and prior treated them as numbers; more recent\r\n-     * versions treat them as strings.\r\n-     */\r\n-    public boolean getQuotedNumbersInQueries() {\r\n-        return _quotedNumbers;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to interpret quoted numbers in query strings as numbers.\r\n-     * OpenJPA versions 3.1 and prior treated them as numbers; more recent\r\n-     * versions treat them as strings.\r\n-     */\r\n-    public void setQuotedNumbersInQueries(boolean quotedNumbers) {\r\n-        _quotedNumbers = quotedNumbers;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to return hollow instances to broker lookups with a\r\n-     * <code>validate</code> parameter of false. OpenJPA versions prior to\r\n-     * 4.0 did not return hollow instances without special configuration\r\n-     * (the <code>ObjectLookupMode</code>). Beginning with 4.0, hollow\r\n-     * objects are the default.\r\n-     */\r\n-    public boolean getValidateFalseReturnsHollow() {\r\n-        return _hollowLookups;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to return hollow instances to broker lookups with a\r\n-     * <code>validate</code> parameter of false. OpenJPA versions prior to\r\n-     * 4.0 did not return hollow instances without special configuration\r\n-     * (the <code>ObjectLookupMode</code>). Beginning with 4.0, hollow\r\n-     * objects are the default.\r\n-     */\r\n-    public void setValidateFalseReturnsHollow(boolean hollow) {\r\n-        _hollowLookups = hollow;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to check the datastore for the existence of a nontransactional\r\n-     * cached object in broker lookups with a <code>validate</code> parameter\r\n-     * of true. OpenJPA versions prior to 4.0 checked the datastore.\r\n-     */\r\n-    public boolean getValidateTrueChecksStore() {\r\n-        return _checkStore;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to check the datastore for the existence of a nontransactional\r\n-     * cached object in broker lookups with a <code>validate</code> parameter\r\n-     * of true. OpenJPA versions prior to 4.0 checked the datastore.\r\n-     */\r\n-    public void setValidateTrueChecksStore(boolean check) {\r\n-        _checkStore = check;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to copy identity objects before returning them to client code.\r\n-     * Versions of OpenJPA prior to 3.0 always copied identity objects. Also,\r\n-     * you should configure OpenJPA to copy identity objects if you mutate them\r\n-     * after use.\r\n-     */\r\n-    public boolean getCopyObjectIds() {\r\n-        return _copyIds;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to copy identity objects before returning them to client code.\r\n-     * Versions of OpenJPA prior to 3.0 always copied identity objects. Also,\r\n-     * you should configure OpenJPA to copy identity objects if you mutate them\r\n-     * after use.\r\n-     */\r\n-    public void setCopyObjectIds(boolean copy) {\r\n-        _copyIds = copy;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to close the broker when the managed transaction commits.\r\n-     * Versions of OpenJPA prior to 3.0 did not close the broker.\r\n-     */\r\n-    public boolean getCloseOnManagedCommit() {\r\n-        return _closeOnCommit;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to close the broker when the managed transaction commits.\r\n-     * Versions of OpenJPA prior to 3.0 did not close the broker.\r\n-     */\r\n-    public void setCloseOnManagedCommit(boolean close) {\r\n-        _closeOnCommit = close;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+/**\n+ * <p>Struct encompassing backwards-compatibility options.</p>\n+ */\n+public class Compatibility {\n+\n+    private boolean _strictIdValues = false;\n+    private boolean _hollowLookups = true;\n+    private boolean _checkStore = false;\n+    private boolean _copyIds = false;\n+    private boolean _closeOnCommit = true;\n+    private boolean _quotedNumbers = false;\n+\n+    /**\n+     * Whether to require exact identity value types when creating object\n+     * ids from a class and value.  Defaults to false.\n+     */\n+    public boolean getStrictIdentityValues() {\n+        return _strictIdValues;\n+    }\n+\n+    /**\n+     * Whether to require exact identity value types when creating object\n+     * ids from a class and value.  Defaults to false.\n+     */\n+    public void setStrictIdentityValues(boolean strictVals) {\n+        _strictIdValues = strictVals;\n+    }\n+\n+    /**\n+     * Whether to interpret quoted numbers in query strings as numbers.\n+     * OpenJPA versions 3.1 and prior treated them as numbers; more recent\n+     * versions treat them as strings.\n+     */\n+    public boolean getQuotedNumbersInQueries() {\n+        return _quotedNumbers;\n+    }\n+\n+    /**\n+     * Whether to interpret quoted numbers in query strings as numbers.\n+     * OpenJPA versions 3.1 and prior treated them as numbers; more recent\n+     * versions treat them as strings.\n+     */\n+    public void setQuotedNumbersInQueries(boolean quotedNumbers) {\n+        _quotedNumbers = quotedNumbers;\n+    }\n+\n+    /**\n+     * Whether to return hollow instances to broker lookups with a\n+     * <code>validate</code> parameter of false.  OpenJPA versions prior to\n+     * 4.0 did not return hollow instances without special configuration\n+     * (the <code>ObjectLookupMode</code>).  Beginning with 4.0, hollow\n+     * objects are the default.\n+     */\n+    public boolean getValidateFalseReturnsHollow() {\n+        return _hollowLookups;\n+    }\n+\n+    /**\n+     * Whether to return hollow instances to broker lookups with a\n+     * <code>validate</code> parameter of false.  OpenJPA versions prior to\n+     * 4.0 did not return hollow instances without special configuration\n+     * (the <code>ObjectLookupMode</code>).  Beginning with 4.0, hollow\n+     * objects are the default.\n+     */\n+    public void setValidateFalseReturnsHollow(boolean hollow) {\n+        _hollowLookups = hollow;\n+    }\n+\n+    /**\n+     * Whether to check the datastore for the existence of a nontransactional\n+     * cached object in broker lookups with a <code>validate</code> parameter\n+     * of true.  OpenJPA versions prior to 4.0 checked the datastore.\n+     */\n+    public boolean getValidateTrueChecksStore() {\n+        return _checkStore;\n+    }\n+\n+    /**\n+     * Whether to check the datastore for the existence of a nontransactional\n+     * cached object in broker lookups with a <code>validate</code> parameter\n+     * of true.  OpenJPA versions prior to 4.0 checked the datastore.\n+     */\n+    public void setValidateTrueChecksStore(boolean check) {\n+        _checkStore = check;\n+    }\n+\n+    /**\n+     * Whether to copy identity objects before returning them to client code.\n+     * Versions of OpenJPA prior to 3.0 always copied identity objects.  Also,\n+     * you should configure OpenJPA to copy identity objects if you mutate them\n+     * after use.\n+     */\n+    public boolean getCopyObjectIds() {\n+        return _copyIds;\n+    }\n+\n+    /**\n+     * Whether to copy identity objects before returning them to client code.\n+     * Versions of OpenJPA prior to 3.0 always copied identity objects.  Also,\n+     * you should configure OpenJPA to copy identity objects if you mutate them\n+     * after use.\n+     */\n+    public void setCopyObjectIds(boolean copy) {\n+        _copyIds = copy;\n+    }\n+\n+    /**\n+     * Whether to close the broker when the managed transaction commits.\n+     * Versions of OpenJPA prior to 3.0 did not close the broker.\n+     */\n+    public boolean getCloseOnManagedCommit() {\n+        return _closeOnCommit;\n+    }\n+\n+    /**\n+     *\tWhether to close the broker when the managed transaction commits.\n+     *\tVersions of OpenJPA prior to 3.0 did not close the broker.\n+     */\n+    public void setCloseOnManagedCommit(boolean close) {\n+        _closeOnCommit = close;\n+\t}\t\n+}"},{"sha":"6a6af8670153a21707e479e8c89cd2d4fceed0a9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java","status":"modified","additions":157,"deletions":149,"changes":306,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,149 +1,157 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.kernel.DetachState;\r\n-\r\n-/**\r\n- * Detach options.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public abstract class DetachOptions implements DetachState {\r\n-\r\n-    private boolean _field = true;\r\n-    private boolean _transient = true;\r\n-    private boolean _manager = true;\r\n-    private boolean _access = true;\r\n-\r\n-    /**\r\n-     * The {@link DetachState} constant.\r\n-     */\r\n-    public abstract int getDetachState();\r\n-\r\n-    /**\r\n-     * Whether to add a detached state field to enhanced classes.\r\n-     */\r\n-    public boolean getDetachedStateField() {\r\n-        return _field;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to add a detached state field to enhanced classes.\r\n-     */\r\n-    public void setDetachedStateField(boolean val) {\r\n-        _field = val;\r\n-        if (!val)\r\n-            _manager = false;\r\n-    }\r\n-\r\n-    /**\r\n-     * For auto-configuration of the detached state field. Accepts values\r\n-     * \"true\", \"false\", or \"transient\".\r\n-     */\r\n-    public void setDetachedStateField(String val) {\r\n-        if (val == null)\r\n-            return;\r\n-        if (\"transient\".equals(val)) {\r\n-            setDetachedStateField(true);\r\n-            _transient = true;\r\n-        } else if (\"true\".equals(val)) {\r\n-            setDetachedStateField(true);\r\n-            _transient = false;\r\n-        } else if (\"false\".equals(val)) {\r\n-            setDetachedStateField(false);\r\n-            _transient = false;\r\n-        } else throw new IllegalArgumentException(\"DetachedStateField=\" + val);\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to use transient detached state.\r\n-     */\r\n-    public boolean isDetachedStateTransient() {\r\n-        return _transient;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to use transient detached state.\r\n-     */\r\n-    public void setDetachedStateTransient(boolean val) {\r\n-        _transient = val;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to use a detached state manager on types that allow it.\r\n-     * Types that do not use detached state or that declare a custom detached\r\n-     * state field to maintain serialization compatibility will never use\r\n-     * a detached state manager. Defaults to true.\r\n-     */\r\n-    public boolean getDetachedStateManager() {\r\n-        return _manager;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to use a detached state manager on types that allow it.\r\n-     * Types that do not use detached state or that declare a custom detached\r\n-     * state field to maintain serialization compatibility will never use\r\n-     * a detached state manager. Defaults to true.\r\n-     */\r\n-    public void setDetachedStateManager(boolean val) {\r\n-        _manager = val;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to allow access to unloaded detached fields. This setting only\r\n-     * applies to instances with detached state managers.\r\n-     */\r\n-    public boolean getAccessUnloaded() {\r\n-        return _access;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to allow access to unloaded detached fields. This setting only\r\n-     * applies to instances with detached state managers.\r\n-     */\r\n-    public void setAccessUnloaded(boolean val) {\r\n-        _access = val;\r\n-    }\r\n-\r\n-    /**\r\n-     * Detach loaded state.\r\n-     */\r\n-    public static class Loaded extends DetachOptions {\r\n-\r\n-        public int getDetachState() {\r\n-            return DETACH_LOADED;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Public to allow reflection.\r\n-     */\r\n-    public static class FetchGroups extends DetachOptions {\r\n-\r\n-        public int getDetachState() {\r\n-            return DETACH_FGS;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Public to allow reflection.\r\n-     */\r\n-    public static class All extends DetachOptions {\r\n-\r\n-        public int getDetachState() {\r\n-            return DETACH_ALL;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.kernel.DetachState;\n+\n+/**\n+ * <p>Detach options.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public abstract class DetachOptions\n+    implements DetachState {\n+\n+    private boolean _field = true;\n+    private boolean _transient = true;\n+    private boolean _manager = true;\n+    private boolean _access = true;\n+\n+    /**\n+     * The {@link DetachState} constant.\n+     */\n+    public abstract int getDetachState();\n+\n+    /**\n+     * Whether to add a detached state field to enhanced classes.\n+     */\n+    public boolean getDetachedStateField() {\n+        return _field;\n+    }\n+\n+    /**\n+     * Whether to add a detached state field to enhanced classes.\n+     */\n+    public void setDetachedStateField(boolean val) {\n+        _field = val;\n+        if (!val)\n+            _manager = false;\n+    }\n+\n+    /**\n+     * For auto-configuration of the detached state field.  Accepts values\n+     * \"true\", \"false\", or \"transient\".\n+     */\n+    public void setDetachedStateField(String val) {\n+        if (val == null)\n+            return;\n+        if (\"transient\".equals(val)) {\n+            setDetachedStateField(true);\n+            _transient = true;\n+        } else if (\"true\".equals(val)) {\n+            setDetachedStateField(true);\n+            _transient = false;\n+        } else if (\"false\".equals(val)) {\n+            setDetachedStateField(false);\n+            _transient = false;\n+        } else\n+            throw new IllegalArgumentException(\"DetachedStateField=\" + val);\n+    }\n+\n+    /**\n+     * Whether to use transient detached state.\n+     */\n+    public boolean isDetachedStateTransient() {\n+        return _transient;\n+    }\n+\n+    /**\n+     * Whether to use transient detached state.\n+     */\n+    public void setDetachedStateTransient(boolean val) {\n+        _transient = val;\n+    }\n+\n+    /**\n+     * Whether to use a detached state manager on types that allow it.\n+     * Types that do not use detached state or that declare a custom detached\n+     * state field to maintain serialization compatibility will never use\n+     * a detached state manager.  Defaults to true.\n+     */\n+    public boolean getDetachedStateManager() {\n+        return _manager;\n+    }\n+\n+    /**\n+     * Whether to use a detached state manager on types that allow it.\n+     * Types that do not use detached state or that declare a custom detached\n+     * state field to maintain serialization compatibility will never use\n+     * a detached state manager.  Defaults to true.\n+     */\n+    public void setDetachedStateManager(boolean val) {\n+        _manager = val;\n+    }\n+\n+    /**\n+     * Whether to allow access to unloaded detached fields.  This setting only\n+     * applies to instances with detached state managers.\n+     */\n+    public boolean getAccessUnloaded() {\n+        return _access;\n+    }\n+\n+    /**\n+     * Whether to allow access to unloaded detached fields.  This setting only\n+     * applies to instances with detached state managers.\n+     */\n+    public void setAccessUnloaded(boolean val) {\n+        _access = val;\n+    }\n+\n+    /**\n+     * Detach loaded state.\n+     */\n+    public static class Loaded\n+        extends DetachOptions {\n+\n+        public int getDetachState() {\n+            return DETACH_LOADED;\n+        }\n+    }\n+\n+    /**\n+     * Public to allow reflection.\n+     */\n+    public static class FetchGroups\n+        extends DetachOptions {\n+\n+        public int getDetachState() {\n+            return DETACH_FGS;\n+        }\n+    }\n+\n+    /**\n+     *\tPublic to allow reflection.\n+     */\n+    public static class All\n+        extends DetachOptions {\n+\n+        public int getDetachState() {\n+            return DETACH_ALL;\n+\t\t}\t\t\n+\t}\n+}"},{"sha":"928a497f18036af27595e3f6082531dd5c392cea","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java","status":"modified","additions":1336,"deletions":1324,"changes":2660,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,1324 +1,1336 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.Collection;\r\n-\r\n-import org.apache.openjpa.datacache.DataCache;\r\n-import org.apache.openjpa.datacache.DataCacheManager;\r\n-import org.apache.openjpa.ee.ManagedRuntime;\r\n-import org.apache.openjpa.event.OrphanedKeyAction;\r\n-import org.apache.openjpa.event.RemoteCommitEventManager;\r\n-import org.apache.openjpa.event.RemoteCommitProvider;\r\n-import org.apache.openjpa.kernel.AutoClear;\r\n-import org.apache.openjpa.kernel.AutoDetach;\r\n-import org.apache.openjpa.kernel.BrokerFactory;\r\n-import org.apache.openjpa.kernel.BrokerImpl;\r\n-import org.apache.openjpa.kernel.ConnectionRetainModes;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.InverseManager;\r\n-import org.apache.openjpa.kernel.LockManager;\r\n-import org.apache.openjpa.kernel.QueryFlushModes;\r\n-import org.apache.openjpa.kernel.RestoreState;\r\n-import org.apache.openjpa.kernel.SavepointManager;\r\n-import org.apache.openjpa.kernel.Seq;\r\n-import org.apache.openjpa.kernel.exps.AggregateListener;\r\n-import org.apache.openjpa.kernel.exps.FilterListener;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.meta.MetaDataFactory;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.util.ClassResolver;\r\n-import org.apache.openjpa.util.ProxyManager;\r\n-\r\n-/**\r\n- * Defines the properties necessary to configure runtime properties and\r\n- * connect to a data source. There is a 1-1 relation between a configuration\r\n- * and a {@link BrokerFactory}.\r\n- * All setter methods that take primitive parameters also have wrapper\r\n- * setter with the appropriate primitive wrapper. This is so the interface\r\n- * can be in accordance with the J2EE Connector Architecture.\r\n- *\r\n- * @author Marc Prud'hommeaux\r\n- * @author Abe White\r\n- * @see Configuration\r\n- */\r\n-public interface OpenJPAConfiguration extends Configuration {\r\n-\r\n-    /**\r\n-     * Name of logger for metadata-related messages:\r\n-     * <code>org.apache.openjpa.MetaData</code>.\r\n-     */\r\n-    public static final String LOG_METADATA = \"org.apache.openjpa.MetaData\";\r\n-\r\n-    /**\r\n-     * Name of logger for enhancement-related messages:\r\n-     * <code>org.apache.openjpa.Enhance</code>.\r\n-     */\r\n-    public static final String LOG_ENHANCE = \"org.apache.openjpa.Enhance\";\r\n-\r\n-    /**\r\n-     * Name of logger for messages from the runtime system:\r\n-     * <code>org.apache.openjpa.Runtime</code>.\r\n-     */\r\n-    public static final String LOG_RUNTIME = \"org.apache.openjpa.Runtime\";\r\n-\r\n-    /**\r\n-     * Name of logger for query logging:\r\n-     * <code>org.apache.openjpa.Query</code>.\r\n-     */\r\n-    public static final String LOG_QUERY = \"org.apache.openjpa.Query\";\r\n-\r\n-    /**\r\n-     * Name of logger for messages from the data cache:\r\n-     * <code>org.apache.openjpa.DataCache</code>.\r\n-     */\r\n-    public static final String LOG_DATACACHE = \"org.apache.openjpa.DataCache\";\r\n-\r\n-    /**\r\n-     * Name of logger for messages from the development tools:\r\n-     * <code>org.apache.openjpa.Tool</code>.\r\n-     */\r\n-    public static final String LOG_TOOL = \"org.apache.openjpa.Tool\";\r\n-\r\n-    /**\r\n-     * Option for runtimes that support nontransactional reads.\r\n-     */\r\n-    public static final String OPTION_NONTRANS_READ =\r\n-        \"org.apache.openjpa.option.NontransactionalRead\";\r\n-\r\n-    /**\r\n-     * Option for runtimes that support optimistic transactions.\r\n-     */\r\n-    public static final String OPTION_OPTIMISTIC =\r\n-        \"org.apache.openjpa.option.Optimistic\";\r\n-\r\n-    /**\r\n-     * Option for runtimes that support application identity.\r\n-     */\r\n-    public static final String OPTION_ID_APPLICATION =\r\n-        \"org.apache.openjpa.option.ApplicationIdentity\";\r\n-\r\n-    /**\r\n-     * Option for runtimes that support application identity.\r\n-     */\r\n-    public static final String OPTION_ID_DATASTORE =\r\n-        \"org.apache.openjpa.option.DatastoreIdentity\";\r\n-\r\n-    /**\r\n-     * Option for SQL support.\r\n-     */\r\n-    public static final String OPTION_QUERY_SQL =\r\n-        \"org.apache.openjpa.option.SQL\";\r\n-\r\n-    /**\r\n-     * Option for runtimes that support persistent collection fields.\r\n-     */\r\n-    public static final String OPTION_TYPE_COLLECTION =\r\n-        \"org.apache.openjpa.option.Collection\";\r\n-\r\n-    /**\r\n-     * Option for runtimes that support persistent map fields.\r\n-     */\r\n-    public static final String OPTION_TYPE_MAP =\r\n-        \"org.apache.openjpa.option.Map\";\r\n-\r\n-    /**\r\n-     * Option for runtimes that support persistent array fields.\r\n-     */\r\n-    public static final String OPTION_TYPE_ARRAY =\r\n-        \"org.apache.openjpa.option.Array\";\r\n-\r\n-    /**\r\n-     * Option for runtime that can differentiate between null and empty\r\n-     * container fields.\r\n-     */\r\n-    public static final String OPTION_NULL_CONTAINER =\r\n-        \"org.apache.openjpa.option.NullContainer\";\r\n-\r\n-    /**\r\n-     * Option for runtimes that support embedded relations to other\r\n-     * persistence capable objects.\r\n-     */\r\n-    public static final String OPTION_EMBEDDED_RELATION =\r\n-        \"org.apache.openjpa.option.EmbeddedRelation\";\r\n-\r\n-    /**\r\n-     * Option for runtimes that support collections of embedded\r\n-     * relations to other persistence capable objects.\r\n-     */\r\n-    public static final String OPTION_EMBEDDED_COLLECTION_RELATION =\r\n-        \"org.apache.openjpa.option.EmbeddedCollectionRelation\";\r\n-\r\n-    /**\r\n-     * Option for runtimes that support maps of embedded\r\n-     * relations to other persistence capable objects.\r\n-     */\r\n-    public static final String OPTION_EMBEDDED_MAP_RELATION =\r\n-        \"org.apache.openjpa.option.EmbeddedMapRelation\";\r\n-\r\n-    /**\r\n-     * Option for runtimes that support incremental flushing.\r\n-     */\r\n-    public static final String OPTION_INC_FLUSH =\r\n-        \"org.apache.openjpa.option.IncrementalFlush\";\r\n-\r\n-    /**\r\n-     * Option for runtimes that the autoassign value strategy.\r\n-     */\r\n-    public static final String OPTION_VALUE_AUTOASSIGN =\r\n-        \"org.apache.openjpa.option.AutoassignValue\";\r\n-\r\n-    /**\r\n-     * Option for runtimes that the increment value strategy.\r\n-     */\r\n-    public static final String OPTION_VALUE_INCREMENT =\r\n-        \"org.apache.openjpa.option.IncrementValue\";\r\n-\r\n-    /**\r\n-     * Option for runtimes that support returning the datastore connection.\r\n-     */\r\n-    public static final String OPTION_DATASTORE_CONNECTION =\r\n-        \"org.apache.openjpa.option.DataStoreConnection\";\r\n-\r\n-    /**\r\n-     * Option for runtimes that support returning the datastore connection\r\n-     * that is a JDBC Connection.\r\n-     */\r\n-    public static final String OPTION_JDBC_CONNECTION =\r\n-        \"org.apache.openjpa.option.JDBCConnection\";\r\n-\r\n-    /**\r\n-     * Return the set of option strings supported by this runtime. This set\r\n-     * is mutable.\r\n-     */\r\n-    public Collection supportedOptions();\r\n-\r\n-    /**\r\n-     * A configuration can be set with defaults for a specific specification.\r\n-     */\r\n-    public String getSpecification();\r\n-\r\n-    /**\r\n-     * Set the specification that this configuration should use for the\r\n-     * various properties that need to have different defaults for different\r\n-     * spec environments. This should be invoked before any configuration\r\n-     * options are set, as it will mutate various values.\r\n-     * You can only assign the specification once, though it is not fatal\r\n-     * to attempt to do so multiple times. Attempts to set to null will\r\n-     * be ignored.\r\n-     */\r\n-    public boolean setSpecification(String spec);\r\n-\r\n-    /**\r\n-     * The plugin string for the {@link ClassResolver} to use for custom\r\n-     * class loading.\r\n-     */\r\n-    public String getClassResolver();\r\n-\r\n-    /**\r\n-     * The plugin string for the {@link ClassResolver} to use for custom\r\n-     * class loading.\r\n-     */\r\n-    public void setClassResolver(String classResolver);\r\n-\r\n-    /**\r\n-     * The {@link ClassResolver} to use.\r\n-     */\r\n-    public ClassResolver getClassResolverInstance();\r\n-\r\n-    /**\r\n-     * The {@link ClassResolver} to use.\r\n-     */\r\n-    public void setClassResolver(ClassResolver classResolver);\r\n-\r\n-    /**\r\n-     * The {@link BrokerFactory} class to use.\r\n-     */\r\n-    public String getBrokerFactory();\r\n-\r\n-    /**\r\n-     * The {@link BrokerFactory} class to use.\r\n-     */\r\n-    public void setBrokerFactory(String factory);\r\n-\r\n-    /**\r\n-     * The plugin string of the {@link BrokerImpl} extension to create.\r\n-     */\r\n-    public String getBrokerImpl();\r\n-\r\n-    /**\r\n-     * The plugin string of the {@link BrokerImpl} extension to create.\r\n-     */\r\n-    public void setBrokerImpl(String broker);\r\n-\r\n-    /**\r\n-     * Create a new broker instance with the configured plugin data.\r\n-     */\r\n-    public BrokerImpl newBrokerInstance(String user, String pass);\r\n-\r\n-    /**\r\n-     * The {@link DataCache} to use for level-2 data store caching.\r\n-     */\r\n-    public String getDataCache();\r\n-\r\n-    /**\r\n-     * The {@link DataCache} to use for level-2 data store caching.\r\n-     */\r\n-    public void setDataCache(String dataCache);\r\n-\r\n-    /**\r\n-     * The data cache manager manages this configuration's cache instances.\r\n-     */\r\n-    public String getDataCacheManager();\r\n-\r\n-    /**\r\n-     * The data cache manager manages this configuration's cache instances.\r\n-     */\r\n-    public void setDataCacheManager(String mgr);\r\n-\r\n-    /**\r\n-     * The data cache manager manages this configuration's cache instances.\r\n-     * The cache manager is created if it has not been set. Once the cache\r\n-     * manager has been set/created, all changes to caching configuration\r\n-     * must proceed through the cache manager.\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public DataCacheManager getDataCacheManagerInstance();\r\n-\r\n-    /**\r\n-     * The data cache manager manages this configuration's cache instances.\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public void setDataCacheManager(DataCacheManager manager);\r\n-\r\n-    /**\r\n-     * Default data cache timeout.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public int getDataCacheTimeout();\r\n-\r\n-    /**\r\n-     * Default data cache timeout.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public void setDataCacheTimeout(int timeout);\r\n-\r\n-    /**\r\n-     * Wrapper for JCA usage of {@link #setDataCacheTimeout(int)}.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public void setDataCacheTimeout(Integer timeout);\r\n-\r\n-    /**\r\n-     * The plugin to use for level-2 data store query caching.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public String getQueryCache();\r\n-\r\n-    /**\r\n-     * The plugin to use for level-2 data store query caching.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public void setQueryCache(String queryCache);\r\n-\r\n-    /**\r\n-     * Return whether to generate dynamic data structures\r\n-     * where possible for cache and runtime usage.\r\n-     *\r\n-     * @since 3.3\r\n-     */\r\n-    public boolean getDynamicDataStructs();\r\n-\r\n-    /**\r\n-     * Set whether to generate dynamic data structures\r\n-     * where possible for cache and runtime usage.\r\n-     *\r\n-     * @since 3.3\r\n-     */\r\n-    public void setDynamicDataStructs(boolean dynamic);\r\n-\r\n-    /**\r\n-     * Wrapper for JCA usage of {@link #setDynamicDataStructs(boolean)}.\r\n-     */\r\n-    public void setDynamicDataStructs(Boolean dynamic);\r\n-\r\n-    /**\r\n-     * The plugin to use for datastore lock management.\r\n-     *\r\n-     * @since 3.1\r\n-     */\r\n-    public String getLockManager();\r\n-\r\n-    /**\r\n-     * The plugin to use for datastore lock management.\r\n-     *\r\n-     * @since 3.1\r\n-     */\r\n-    public void setLockManager(String lockManager);\r\n-\r\n-    /**\r\n-     * Return a new lock manager instance using the configured plugin settings.\r\n-     */\r\n-    public LockManager newLockManagerInstance();\r\n-\r\n-    /**\r\n-     * The plugin to use for managing inverse relations.\r\n-     *\r\n-     * @since 3.2\r\n-     */\r\n-    public String getInverseManager();\r\n-\r\n-    /**\r\n-     * The plugin to use for managing inverse relations.\r\n-     *\r\n-     * @since 3.2\r\n-     */\r\n-    public void setInverseManager(String inverse);\r\n-\r\n-    /**\r\n-     * Return a new inverse manager instance using the configured plugin\r\n-     * settings.\r\n-     *\r\n-     * @since 3.2\r\n-     */\r\n-    public InverseManager newInverseManagerInstance();\r\n-\r\n-    /**\r\n-     * The plugin to use for savepoint management.\r\n-     *\r\n-     * @since 3.4\r\n-     */\r\n-    public String getSavepointManager();\r\n-\r\n-    /**\r\n-     * The plugin to use for savepoint management.\r\n-     *\r\n-     * @since 3.4\r\n-     */\r\n-    public void setSavepointManager(String savepointManager);\r\n-\r\n-    /**\r\n-     * Return the configured savepoint manager instance.\r\n-     */\r\n-    public SavepointManager getSavepointManagerInstance();\r\n-\r\n-    /**\r\n-     * The action to take when an orphaned key is detected.\r\n-     *\r\n-     * @since 3.2.2\r\n-     */\r\n-    public String getOrphanedKeyAction();\r\n-\r\n-    /**\r\n-     * The action to take when an orphaned key is detected.\r\n-     *\r\n-     * @since 3.2.2\r\n-     */\r\n-    public void setOrphanedKeyAction(String action);\r\n-\r\n-    /**\r\n-     * The action to take when an orphaned key is detected.\r\n-     *\r\n-     * @since 3.2.2\r\n-     */\r\n-    public OrphanedKeyAction getOrphanedKeyActionInstance();\r\n-\r\n-    /**\r\n-     * The action to take when an orphaned key is detected.\r\n-     *\r\n-     * @since 3.2.2\r\n-     */\r\n-    public void setOrphanedKeyAction(OrphanedKeyAction action);\r\n-\r\n-    /**\r\n-     * The plugin to use for remote commit notification.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public String getRemoteCommitProvider();\r\n-\r\n-    /**\r\n-     * The plugin to use for remote commit notification.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public void setRemoteCommitProvider(String remoteCommitProvider);\r\n-\r\n-    /**\r\n-     * Create a remote commit provider from the configured plugin.\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public RemoteCommitProvider newRemoteCommitProviderInstance();\r\n-\r\n-    /**\r\n-     * The remote event manager that manages this configuration's remote\r\n-     * event listeners.\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public RemoteCommitEventManager getRemoteCommitEventManager();\r\n-\r\n-    /**\r\n-     * The remote event manager that manages this configuration's remote\r\n-     * event listeners.\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public void setRemoteCommitEventManager(RemoteCommitEventManager manager);\r\n-\r\n-    /**\r\n-     * Specifies the behavior of the transaction featureSelection. Possible values are:\r\n-     * <ul>\r\n-     * <li><code>local</code>: Perform transaction operations locally.</li>\r\n-     * <li><code>managed</code>: Use managed environment's global\r\n-     * transactions.</li>\r\n-     * </ul>\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public String getTransactionMode();\r\n-\r\n-    /**\r\n-     * Specifies the behavior of the transaction featureSelection. Possible values are:\r\n-     * <ul>\r\n-     * <li><code>local</code>: Perform transaction operations locally.</li>\r\n-     * <li><code>managed</code>: Use managed environment's global\r\n-     * transactions.</li>\r\n-     * </ul>\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public void setTransactionMode(String mode);\r\n-\r\n-    /**\r\n-     * Return whether managed transactions are being used.\r\n-     */\r\n-    public boolean isTransactionModeManaged();\r\n-\r\n-    /**\r\n-     * Set whether managed transactions are being used.\r\n-     */\r\n-    public void setTransactionModeManaged(boolean managed);\r\n-\r\n-    /**\r\n-     * The plugin string for the {@link ManagedRuntime} to use for managed\r\n-     * environments.\r\n-     */\r\n-    public String getManagedRuntime();\r\n-\r\n-    /**\r\n-     * The plugin string for the {@link ManagedRuntime} to use for managed\r\n-     * environments.\r\n-     */\r\n-    public void setManagedRuntime(String managedRuntime);\r\n-\r\n-    /**\r\n-     * The plugin to use for integrating with a managed runtime.\r\n-     */\r\n-    public ManagedRuntime getManagedRuntimeInstance();\r\n-\r\n-    /**\r\n-     * The plugin to use for integrating with a managed runtime.\r\n-     */\r\n-    public void setManagedRuntime(ManagedRuntime runtime);\r\n-\r\n-    /**\r\n-     * The plugin string for the {@link ProxyManager} to use for second\r\n-     * class object proxies.\r\n-     */\r\n-    public String getProxyManager();\r\n-\r\n-    /**\r\n-     * The plugin string for the {@link ProxyManager} to use for second\r\n-     * class object proxies.\r\n-     */\r\n-    public void setProxyManager(String proxyManager);\r\n-\r\n-    /**\r\n-     * The {@link ProxyManager} to use.\r\n-     */\r\n-    public ProxyManager getProxyManagerInstance();\r\n-\r\n-    /**\r\n-     * The {@link ProxyManager} to use.\r\n-     */\r\n-    public void setProxyManager(ProxyManager manager);\r\n-\r\n-    /**\r\n-     * The name mapping to use for this data store.\r\n-     */\r\n-    public String getMapping();\r\n-\r\n-    /**\r\n-     * The name mapping to use for this data store.\r\n-     */\r\n-    public void setMapping(String mapping);\r\n-\r\n-    /**\r\n-     * A plugin string describing the {@link MetaDataFactory} to use.\r\n-     */\r\n-    public String getMetaDataFactory();\r\n-\r\n-    /**\r\n-     * A plugin string describing the {@link MetaDataFactory} to use.\r\n-     */\r\n-    public void setMetaDataFactory(String meta);\r\n-\r\n-    /**\r\n-     * Create a new {@link MetaDataFactory} to use with a repository.\r\n-     */\r\n-    public MetaDataFactory newMetaDataFactoryInstance();\r\n-\r\n-    /**\r\n-     * The metadata repository of managed class information. If no\r\n-     * repository has been set, creates one.\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public MetaDataRepository getMetaDataRepository();\r\n-\r\n-    /**\r\n-     * The metadata repository of managed class information.\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public void setMetaDataRepository(MetaDataRepository mdRepos);\r\n-\r\n-    /**\r\n-     * The user name for the data store connection.\r\n-     */\r\n-    public String getConnectionUserName();\r\n-\r\n-    /**\r\n-     * The user name for the data store connection.\r\n-     */\r\n-    public void setConnectionUserName(String connectionUserName);\r\n-\r\n-    /**\r\n-     * The password for the data store connection.\r\n-     */\r\n-    public String getConnectionPassword();\r\n-\r\n-    /**\r\n-     * The password for the data store connection.\r\n-     */\r\n-    public void setConnectionPassword(String connectionPassword);\r\n-\r\n-    /**\r\n-     * The URL for the data store connection.\r\n-     */\r\n-    public String getConnectionURL();\r\n-\r\n-    /**\r\n-     * The URL for the data store connection.\r\n-     */\r\n-    public void setConnectionURL(String connectionURL);\r\n-\r\n-    /**\r\n-     * Class name of the connection driver.\r\n-     */\r\n-    public String getConnectionDriverName();\r\n-\r\n-    /**\r\n-     * Class name of the connection driver.\r\n-     */\r\n-    public void setConnectionDriverName(String driverName);\r\n-\r\n-    /**\r\n-     * The name for the data store connection factory.\r\n-     */\r\n-    public String getConnectionFactoryName();\r\n-\r\n-    /**\r\n-     * The name for the data store connection factory.\r\n-     */\r\n-    public void setConnectionFactoryName(String cfName);\r\n-\r\n-    /**\r\n-     * The connection factory, possibly from JNDI.\r\n-     */\r\n-    public Object getConnectionFactory();\r\n-\r\n-    /**\r\n-     * The connection factory.\r\n-     */\r\n-    public void setConnectionFactory(Object factory);\r\n-\r\n-    /**\r\n-     * These properties provide any additional information needed to\r\n-     * establish connections.\r\n-     */\r\n-    public String getConnectionProperties();\r\n-\r\n-    /**\r\n-     * These properties provide any additional information needed to\r\n-     * establish connections.\r\n-     */\r\n-    public void setConnectionProperties(String props);\r\n-\r\n-    /**\r\n-     * Configuration properties for the connection factory.\r\n-     */\r\n-    public String getConnectionFactoryProperties();\r\n-\r\n-    /**\r\n-     * Configuration properties for the connection factory.\r\n-     */\r\n-    public void setConnectionFactoryProperties(String props);\r\n-\r\n-    /**\r\n-     * The mode of the connection factory in use. Available options are:\r\n-     * <ul>\r\n-     * <li>local: OpenJPA controls the connections.</li>\r\n-     * <li>managed: Connections are automatically enlisted in\r\n-     * the current global transaction by an application server.</li>\r\n-     * </ul> Defaults to local.\r\n-     */\r\n-    public String getConnectionFactoryMode();\r\n-\r\n-    /**\r\n-     * The mode of the connection factory in use. Available options are:\r\n-     * <ul>\r\n-     * <li>local: OpenJPA controls the connections.</li>\r\n-     * <li>managed: Connections are automatically enlisted in\r\n-     * the current global transaction by an application server.</li>\r\n-     * </ul> Defaults to local.\r\n-     */\r\n-    public void setConnectionFactoryMode(String mode);\r\n-\r\n-    /**\r\n-     * Whether connections are automatically enlisted in global transactions.\r\n-     */\r\n-    public boolean isConnectionFactoryModeManaged();\r\n-\r\n-    /**\r\n-     * Whether connections are automatically enlisted in global transactions.\r\n-     */\r\n-    public void setConnectionFactoryModeManaged(boolean managed);\r\n-\r\n-    /**\r\n-     * The user name for the non-XA data store connection.\r\n-     */\r\n-    public String getConnection2UserName();\r\n-\r\n-    /**\r\n-     * The user name for the non-XA data store connection.\r\n-     */\r\n-    public void setConnection2UserName(String connectionUserName);\r\n-\r\n-    /**\r\n-     * The password for the non-XA data store connection.\r\n-     */\r\n-    public String getConnection2Password();\r\n-\r\n-    /**\r\n-     * The password for the non-XA data store connection.\r\n-     */\r\n-    public void setConnection2Password(String connectionPassword);\r\n-\r\n-    /**\r\n-     * The URL for the non-XA data store connection.\r\n-     */\r\n-    public String getConnection2URL();\r\n-\r\n-    /**\r\n-     * The URL for the non-XA data store connection.\r\n-     */\r\n-    public void setConnection2URL(String connectionURL);\r\n-\r\n-    /**\r\n-     * Class name of the non-XA connection driver.\r\n-     */\r\n-    public String getConnection2DriverName();\r\n-\r\n-    /**\r\n-     * Class name of the non-XA connection driver.\r\n-     */\r\n-    public void setConnection2DriverName(String driverName);\r\n-\r\n-    /**\r\n-     * The name for the second data store connection factory.\r\n-     */\r\n-    public String getConnectionFactory2Name();\r\n-\r\n-    /**\r\n-     * The name for the second data store connection factory.\r\n-     */\r\n-    public void setConnectionFactory2Name(String cf2Name);\r\n-\r\n-    /**\r\n-     * The non-XA connection factory.\r\n-     */\r\n-    public Object getConnectionFactory2();\r\n-\r\n-    /**\r\n-     * The non-XA connection factory.\r\n-     */\r\n-    public void setConnectionFactory2(Object factory);\r\n-\r\n-    /**\r\n-     * These properties provide any additional information needed to\r\n-     * establish non-XA connections.\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public String getConnection2Properties();\r\n-\r\n-    /**\r\n-     * These properties provide any additional information needed to\r\n-     * establish non-XA connections.\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public void setConnection2Properties(String props);\r\n-\r\n-    /**\r\n-     * Configuration properties for the non-XA connection factory.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public String getConnectionFactory2Properties();\r\n-\r\n-    /**\r\n-     * Configuration properties for the non-XA connection factory.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public void setConnectionFactory2Properties(String props);\r\n-\r\n-    /**\r\n-     * Whether to use optimistic transactions by default.\r\n-     */\r\n-    public boolean getOptimistic();\r\n-\r\n-    /**\r\n-     * Whether to use optimistic transactions by default.\r\n-     */\r\n-    public void setOptimistic(boolean optimistic);\r\n-\r\n-    /**\r\n-     * Wrapper for JCA usage of {@link #setOptimistic(boolean)}.\r\n-     */\r\n-    public void setOptimistic(Boolean optimistic);\r\n-\r\n-    /**\r\n-     * Whether to retain state after a transaction by default.\r\n-     */\r\n-    public boolean getRetainState();\r\n-\r\n-    /**\r\n-     * Whether to retain state after a transaction by default.\r\n-     */\r\n-    public void setRetainState(boolean retainState);\r\n-\r\n-    /**\r\n-     * Wrapper for JCA usage of {@link #setRetainState(boolean)}.\r\n-     */\r\n-    public void setRetainState(Boolean retainState);\r\n-\r\n-    /**\r\n-     * Whether instances clear their state when entering a transaction.\r\n-     */\r\n-    public String getAutoClear();\r\n-\r\n-    /**\r\n-     * Whether instances clear their state when entering a transaction.\r\n-     */\r\n-    public void setAutoClear(String clear);\r\n-\r\n-    /**\r\n-     * Return the {@link AutoClear} constant.\r\n-     */\r\n-    public int getAutoClearConstant();\r\n-\r\n-    /**\r\n-     * Whether instances clear their state when entering a transaction.\r\n-     */\r\n-    public void setAutoClear(int clear);\r\n-\r\n-    /**\r\n-     * Whether to restore initial state on rollback by default.\r\n-     */\r\n-    public String getRestoreState();\r\n-\r\n-    /**\r\n-     * Whether to restore initial state on rollback by default.\r\n-     */\r\n-    public void setRestoreState(String restoreState);\r\n-\r\n-    /**\r\n-     * Return the {@link RestoreState} constant.\r\n-     */\r\n-    public int getRestoreStateConstant();\r\n-\r\n-    /**\r\n-     * Whether to restore initial state on rollback by default.\r\n-     */\r\n-    public void setRestoreState(int restoreState);\r\n-\r\n-    /**\r\n-     * Whether changes in the current transaction are taken into account when\r\n-     * executing queries and iterating extents.\r\n-     */\r\n-    public boolean getIgnoreChanges();\r\n-\r\n-    /**\r\n-     * Whether changes in the current transaction are taken into account when\r\n-     * executing queries and iterating extents.\r\n-     */\r\n-    public void setIgnoreChanges(boolean ignoreChanges);\r\n-\r\n-    /**\r\n-     * Wrapper for JCA usage of {@link #setIgnoreChanges(boolean)}.\r\n-     */\r\n-    public void setIgnoreChanges(Boolean ignoreChanges);\r\n-\r\n-    /**\r\n-     * A comma-separated list of events which trigger auto-detachment\r\n-     * in place of managed states. Possible values are:\r\n-     * <ul>\r\n-     * <li><code>commit</code>: When the current transaction commits.</li>\r\n-     * <li><code>close</code>: When the broker closes.</li>\r\n-     * <li><code>nontx-read</code>: When instances are read\r\n-     * non-transactionally.</li>\r\n-     * </ul>\r\n-     */\r\n-    public String getAutoDetach();\r\n-\r\n-    /**\r\n-     * A comma-separated list of events which trigger auto-detachment\r\n-     * in place of managed states. Possible values are:\r\n-     * <ul>\r\n-     * <li><code>commit</code>: When the current transaction commits.</li>\r\n-     * <li><code>close</code>: When the broker closes.</li>\r\n-     * <li><code>nontx-read</code>: When instances are read\r\n-     * non-transactionally.</li>\r\n-     * </ul>\r\n-     */\r\n-    public void setAutoDetach(String detach);\r\n-\r\n-    /**\r\n-     * The {@link AutoDetach} flags.\r\n-     */\r\n-    public int getAutoDetachConstant();\r\n-\r\n-    /**\r\n-     * The {@link AutoDetach} flags.\r\n-     */\r\n-    public void setAutoDetach(int flags);\r\n-\r\n-    /**\r\n-     * Which field values to include when detaching.\r\n-     */\r\n-    public void setDetachState(String detachState);\r\n-\r\n-    /**\r\n-     * Return the instance specified by the detach state plugin.\r\n-     */\r\n-    public DetachOptions getDetachStateInstance();\r\n-\r\n-    /**\r\n-     * Return the instance specified by the detach state plugin.\r\n-     */\r\n-    public void setDetachState(DetachOptions detachState);\r\n-\r\n-    /**\r\n-     * Whether persistent state is accessible outside a transaction by default.\r\n-     */\r\n-    public boolean getNontransactionalRead();\r\n-\r\n-    /**\r\n-     * Whether persistent state is accessible outside a transaction by default.\r\n-     */\r\n-    public void setNontransactionalRead(boolean ntRead);\r\n-\r\n-    /**\r\n-     * Wrapper for JCA usage of {@link #setNontransactionalRead(boolean)}.\r\n-     */\r\n-    public void setNontransactionalRead(Boolean ntRead);\r\n-\r\n-    /**\r\n-     * Whether persistent state can be modified outside a transaction by\r\n-     * default.\r\n-     */\r\n-    public boolean getNontransactionalWrite();\r\n-\r\n-    /**\r\n-     * Whether persistent state can be modified outside a transaction by\r\n-     * default.\r\n-     */\r\n-    public void setNontransactionalWrite(boolean ntWrite);\r\n-\r\n-    /**\r\n-     * Wrapper for JCA usage of {@link #setNontransactionalWrite(boolean)}.\r\n-     */\r\n-    public void setNontransactionalWrite(Boolean ntWrite);\r\n-\r\n-    /**\r\n-     * Whether brokers or their managed objects will be used by multiple\r\n-     * concurrent threads.\r\n-     */\r\n-    public boolean getMultithreaded();\r\n-\r\n-    /**\r\n-     * Whether brokers or their managed objects will be used by multiple\r\n-     * concurrent threads.\r\n-     */\r\n-    public void setMultithreaded(boolean multithreaded);\r\n-\r\n-    /**\r\n-     * Wrapper for JCA usage of {@link #setMultithreaded(boolean)}.\r\n-     */\r\n-    public void setMultithreaded(Boolean multithreaded);\r\n-\r\n-    /**\r\n-     * Get the size of the batch that will be pre-selected when accessing\r\n-     * elements in a query or relationship. Use -1 to prefetch all results.\r\n-     */\r\n-    public int getFetchBatchSize();\r\n-\r\n-    /**\r\n-     * Set the size of the batch that will be pre-selected when accessing\r\n-     * elements in a query or relationship. Use -1 to prefetch all results.\r\n-     */\r\n-    public void setFetchBatchSize(int size);\r\n-\r\n-    /**\r\n-     * Wrapper for JCA usage of {@link #setFetchBatchSize(int)}.\r\n-     */\r\n-    public void setFetchBatchSize(Integer size);\r\n-\r\n-    /**\r\n-     * Comma-separated list of fetch group names that will be pre-set for\r\n-     * all new {@link FetchConfiguration}s.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public String getFetchGroups();\r\n-\r\n-    /**\r\n-     * Comma-separated list of fetch group names that will be pre-set for\r\n-     * all new {@link FetchConfiguration}s.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public void setFetchGroups(String groups);\r\n-\r\n-    /**\r\n-     * List of fetch group names that will be pre-set for all new\r\n-     * {@link FetchConfiguration}s.\r\n-     */\r\n-    public String[] getFetchGroupsList();\r\n-\r\n-    /**\r\n-     * List of fetch group names that will be pre-set for all new\r\n-     * {@link FetchConfiguration}s.\r\n-     */\r\n-    public void setFetchGroups(String[] names);\r\n-\r\n-    /**\r\n-     * Returns whether or not OpenJPA should automatically flush\r\n-     * modifications to the data store before executing queries.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public String getFlushBeforeQueries();\r\n-\r\n-    /**\r\n-     * Sets whether or not OpenJPA should automatically flush\r\n-     * modifications to the data store before executing queries.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public void setFlushBeforeQueries(String flush);\r\n-\r\n-    /**\r\n-     * Returns one of {@link QueryFlushModes#FLUSH_TRUE},\r\n-     * {@link QueryFlushModes#FLUSH_FALSE}, or\r\n-     * {@link QueryFlushModes#FLUSH_WITH_CONNECTION}, as determined\r\n-     * by parsing the string returned by {@link #getFlushBeforeQueries}.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public int getFlushBeforeQueriesConstant();\r\n-\r\n-    /**\r\n-     * Set to one of {@link QueryFlushModes#FLUSH_TRUE},\r\n-     * {@link QueryFlushModes#FLUSH_FALSE}, or\r\n-     * {@link QueryFlushModes#FLUSH_WITH_CONNECTION}.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public void setFlushBeforeQueries(int flushBeforeQueries);\r\n-\r\n-    /**\r\n-     * The time to wait for an object lock in milliseconds, or -1 for no\r\n-     * timeout.\r\n-     *\r\n-     * @since 3.1\r\n-     */\r\n-    public int getLockTimeout();\r\n-\r\n-    /**\r\n-     * The time to wait for an object lock in milliseconds, or -1 for no\r\n-     * timeout.\r\n-     *\r\n-     * @since 3.1\r\n-     */\r\n-    public void setLockTimeout(int timeout);\r\n-\r\n-    /**\r\n-     * Wrapper for JCA usage of {@link #setLockTimeout(int)}.\r\n-     *\r\n-     * @since 3.1\r\n-     */\r\n-    public void setLockTimeout(Integer timeout);\r\n-\r\n-    /**\r\n-     * The default read lock level to use during non-optimistic transactions.\r\n-     * Defaults to <code>read</code>.\r\n-     *\r\n-     * @since 3.1\r\n-     */\r\n-    public String getReadLockLevel();\r\n-\r\n-    /**\r\n-     * The default read lock level to use during non-optimistic transactions.\r\n-     * Defaults to <code>read</code>.\r\n-     *\r\n-     * @since 3.1\r\n-     */\r\n-    public void setReadLockLevel(String level);\r\n-\r\n-    /**\r\n-     * The numeric read lock level.\r\n-     *\r\n-     * @since 3.1\r\n-     */\r\n-    public int getReadLockLevelConstant();\r\n-\r\n-    /**\r\n-     * The numeric read lock level.\r\n-     *\r\n-     * @since 3.1\r\n-     */\r\n-    public void setReadLockLevel(int level);\r\n-\r\n-    /**\r\n-     * The default write lock level to use during non-optimistic transactions.\r\n-     * Defaults to <code>write</code>.\r\n-     *\r\n-     * @since 3.1\r\n-     */\r\n-    public String getWriteLockLevel();\r\n-\r\n-    /**\r\n-     * The default write lock level to use during non-optimistic transactions.\r\n-     * Defaults to <code>write</code>.\r\n-     *\r\n-     * @since 3.1\r\n-     */\r\n-    public void setWriteLockLevel(String level);\r\n-\r\n-    /**\r\n-     * The numeric write lock level.\r\n-     *\r\n-     * @since 3.1\r\n-     */\r\n-    public int getWriteLockLevelConstant();\r\n-\r\n-    /**\r\n-     * The numeric write lock level.\r\n-     *\r\n-     * @since 3.1\r\n-     */\r\n-    public void setWriteLockLevel(int level);\r\n-\r\n-    /**\r\n-     * Plugin string for the default system {@link Seq}.\r\n-     */\r\n-    public String getSequence();\r\n-\r\n-    /**\r\n-     * Plugin string for the default system {@link Seq}.\r\n-     */\r\n-    public void setSequence(String sequence);\r\n-\r\n-    /**\r\n-     * The default system sequence.\r\n-     */\r\n-    public Seq getSequenceInstance();\r\n-\r\n-    /**\r\n-     * The default system sequence.\r\n-     */\r\n-    public void setSequence(Seq sequence);\r\n-\r\n-    /**\r\n-     * Specifies the behavior of the broker with respect to data store\r\n-     * connections. Possible values are:\r\n-     * <ul>\r\n-     * <li><code>always</code>: Each broker obtains a single connection and\r\n-     * uses it until the broker is closed.</li>\r\n-     * <li><code>transaction</code>: A connection is obtained when each\r\n-     * transaction begins(optimistic or datastore), and is released\r\n-     * when the transaction completes.</li>\r\n-     * <li><code>on-demand</code>: Connections are obtained only when needed.\r\n-     * This is the default mode. It is equivalent to the previous option\r\n-     * when datastore transactions are used. For optimistic transactions,\r\n-     * though, it means that a connection will be retained only for\r\n-     * the duration of the data store commit process.</li>\r\n-     * </ul>\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public String getConnectionRetainMode();\r\n-\r\n-    /**\r\n-     * Specifies the behavior of the broker with respect to data store\r\n-     * connections. Possible values are:\r\n-     * <ul>\r\n-     * <li><code>always</code>: Each broker obtains a single connection and\r\n-     * uses it until the broker is closed.</li>\r\n-     * <li><code>transaction</code>: A connection is obtained when each\r\n-     * transaction begins(optimistic or datastore), and is released\r\n-     * when the transaction completes.</li>\r\n-     * <li><code>on-demand</code>: Connections are obtained only when needed.\r\n-     * This is the default mode. It is equivalent to the previous option\r\n-     * when datastore transactions are used. For optimistic transactions,\r\n-     * though, it means that a connection will be retained only for\r\n-     * the duration of the data store commit process.</li>\r\n-     * </ul>\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public void setConnectionRetainMode(String mode);\r\n-\r\n-    /**\r\n-     * Return the connection retain mode as one of the following symbolic\r\n-     * constants:\r\n-     * <ul>\r\n-     * <li>{@link ConnectionRetainModes#CONN_RETAIN_ALWAYS}</li>\r\n-     * <li>{@link ConnectionRetainModes#CONN_RETAIN_TRANS}</li>\r\n-     * <li>{@link ConnectionRetainModes#CONN_RETAIN_DEMAND}</li>\r\n-     * </ul>\r\n-     */\r\n-    public int getConnectionRetainModeConstant();\r\n-\r\n-    /**\r\n-     * Set the connection retain mode as one of the following symbolic\r\n-     * constants:\r\n-     * <ul>\r\n-     * <li>{@link ConnectionRetainModes#CONN_RETAIN_ALWAYS}</li>\r\n-     * <li>{@link ConnectionRetainModes#CONN_RETAIN_TRANS}</li>\r\n-     * <li>{@link ConnectionRetainModes#CONN_RETAIN_DEMAND}</li>\r\n-     * </ul>\r\n-     */\r\n-    public void setConnectionRetainMode(int mode);\r\n-\r\n-    /**\r\n-     * A comma-separted list of the plugin strings of the query\r\n-     * {@link FilterListener}s to use.\r\n-     */\r\n-    public String getFilterListeners();\r\n-\r\n-    /**\r\n-     * A comma-separted list of the plugin strings of the query\r\n-     * {@link FilterListener}s to use.\r\n-     */\r\n-    public void setFilterListeners(String listeners);\r\n-\r\n-    /**\r\n-     * Return the query filter listeners. If none have been set explicitly,\r\n-     * this method instantiates the listeners from the set plugin list.\r\n-     */\r\n-    public FilterListener[] getFilterListenerInstances();\r\n-\r\n-    /**\r\n-     * Set the query filter listeners. Overrides the list of listener classes.\r\n-     */\r\n-    public void setFilterListeners(FilterListener[] listeners);\r\n-\r\n-    /**\r\n-     * A comma-separted list of the plugin strings of the query\r\n-     * {@link AggregateListener}s to use.\r\n-     */\r\n-    public String getAggregateListeners();\r\n-\r\n-    /**\r\n-     * A comma-separted list of the plugin strings of the query\r\n-     * {@link AggregateListener}s to use.\r\n-     */\r\n-    public void setAggregateListeners(String listeners);\r\n-\r\n-    /**\r\n-     * Return the query function listeners. If none have been set explicitly,\r\n-     * this method instantiates the listeners from the set plugin list.\r\n-     */\r\n-    public AggregateListener[] getAggregateListenerInstances();\r\n-\r\n-    /**\r\n-     * Set the query function listeners. Overrides the list of listener classes.\r\n-     */\r\n-    public void setAggregateListeners(AggregateListener[] listeners);\r\n-\r\n-    /**\r\n-     * Whether to warn and defer registration instead of throwing an\r\n-     * exception when a registered persistent class cannot be processed.\r\n-     * Should only be set to true in complex classloader topologies.\r\n-     * Defaults to <code>false</code>.\r\n-     *\r\n-     * @since 3.2.3\r\n-     */\r\n-    public boolean getRetryClassRegistration();\r\n-\r\n-    /**\r\n-     * Whether to warn and defer registration instead of throwing an\r\n-     * exception when a registered persistent class cannot be processed.\r\n-     * Should only be set to true in complex classloader topologies.\r\n-     * Defaults to <code>false</code>.\r\n-     *\r\n-     * @since 3.2.3\r\n-     */\r\n-    public void setRetryClassRegistration(boolean warn);\r\n-\r\n-    /**\r\n-     * Wrapper for JCA usage of {@link #setRetryClassRegistration(boolean)}.\r\n-     *\r\n-     * @since 3.2.3\r\n-     */\r\n-    public void setRetryClassRegistration(Boolean warn);\r\n-\r\n-    /**\r\n-     * Backwards compatibility options.\r\n-     */\r\n-    public String getCompatibility();\r\n-\r\n-    /**\r\n-     * Backwards compatibility options.\r\n-     */\r\n-    public void setCompatibility(String compatibility);\r\n-\r\n-    /**\r\n-     * Backwards compatibility options.\r\n-     */\r\n-    public Compatibility getCompatibilityInstance();\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.Collection;\n+\n+import org.apache.openjpa.datacache.DataCache;\n+import org.apache.openjpa.datacache.DataCacheManager;\n+import org.apache.openjpa.ee.ManagedRuntime;\n+import org.apache.openjpa.event.OrphanedKeyAction;\n+import org.apache.openjpa.event.RemoteCommitEventManager;\n+import org.apache.openjpa.event.RemoteCommitProvider;\n+import org.apache.openjpa.kernel.AutoClear;\n+import org.apache.openjpa.kernel.AutoDetach;\n+import org.apache.openjpa.kernel.BrokerFactory;\n+import org.apache.openjpa.kernel.BrokerImpl;\n+import org.apache.openjpa.kernel.ConnectionRetainModes;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.InverseManager;\n+import org.apache.openjpa.kernel.LockManager;\n+import org.apache.openjpa.kernel.QueryFlushModes;\n+import org.apache.openjpa.kernel.RestoreState;\n+import org.apache.openjpa.kernel.SavepointManager;\n+import org.apache.openjpa.kernel.Seq;\n+import org.apache.openjpa.kernel.exps.AggregateListener;\n+import org.apache.openjpa.kernel.exps.FilterListener;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.meta.MetaDataFactory;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.util.ClassResolver;\n+import org.apache.openjpa.util.ProxyManager;\n+\n+/**\n+ * <p>Defines the properties necessary to configure runtime properties and\n+ * connect to a data source.  There is a 1-1 relation between a configuration\n+ * and a {@link BrokerFactory}.</p>\n+ * <p/>\n+ * <p>All setter methods that take primitive parameters also have wrapper\n+ * setter with the appropriate primitive wrapper.  This is so the interface\n+ * can be in accordance with the J2EE Connector Architecture.</p>\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @author Abe White\n+ * @see    Configuration\n+ */\n+public interface OpenJPAConfiguration\n+    extends Configuration {\n+\n+    /**\n+     * Name of logger for metadata-related messages:\n+     * <code>org.apache.openjpa.MetaData</code>.\n+     */\n+    public static final String LOG_METADATA = \"org.apache.openjpa.MetaData\";\n+\n+    /**\n+     * Name of logger for enhancement-related messages:\n+     * <code>org.apache.openjpa.Enhance</code>.\n+     */\n+    public static final String LOG_ENHANCE = \"org.apache.openjpa.Enhance\";\n+\n+    /**\n+     * Name of logger for messages from the runtime system:\n+     * <code>org.apache.openjpa.Runtime</code>.\n+     */\n+    public static final String LOG_RUNTIME = \"org.apache.openjpa.Runtime\";\n+\n+    /**\n+     * Name of logger for query logging:\n+     * <code>org.apache.openjpa.Query</code>.\n+     */\n+    public static final String LOG_QUERY = \"org.apache.openjpa.Query\";\n+\n+    /**\n+     * Name of logger for messages from the data cache:\n+     * <code>org.apache.openjpa.DataCache</code>.\n+     */\n+    public static final String LOG_DATACACHE = \"org.apache.openjpa.DataCache\";\n+\n+    /**\n+     * Name of logger for messages from the development tools:\n+     * <code>org.apache.openjpa.Tool</code>.\n+     */\n+    public static final String LOG_TOOL = \"org.apache.openjpa.Tool\";\n+\n+    /**\n+     * Option for runtimes that support nontransactional reads.\n+     */\n+    public static final String OPTION_NONTRANS_READ =\n+        \"org.apache.openjpa.option.NontransactionalRead\";\n+\n+    /**\n+     * Option for runtimes that support optimistic transactions.\n+     */\n+    public static final String OPTION_OPTIMISTIC =\n+        \"org.apache.openjpa.option.Optimistic\";\n+\n+    /**\n+     * Option for runtimes that support application identity.\n+     */\n+    public static final String OPTION_ID_APPLICATION =\n+        \"org.apache.openjpa.option.ApplicationIdentity\";\n+\n+    /**\n+     * Option for runtimes that support application identity.\n+     */\n+    public static final String OPTION_ID_DATASTORE =\n+        \"org.apache.openjpa.option.DatastoreIdentity\";\n+\n+    /**\n+     * Option for SQL support.\n+     */\n+    public static final String OPTION_QUERY_SQL =\n+        \"org.apache.openjpa.option.SQL\";\n+\n+    /**\n+     * Option for runtimes that support persistent collection fields.\n+     */\n+    public static final String OPTION_TYPE_COLLECTION =\n+        \"org.apache.openjpa.option.Collection\";\n+\n+    /**\n+     * Option for runtimes that support persistent map fields.\n+     */\n+    public static final String OPTION_TYPE_MAP =\n+        \"org.apache.openjpa.option.Map\";\n+\n+    /**\n+     * Option for runtimes that support persistent array fields.\n+     */\n+    public static final String OPTION_TYPE_ARRAY =\n+        \"org.apache.openjpa.option.Array\";\n+\n+    /**\n+     * Option for runtime that can differentiate between null and empty\n+     * container fields.\n+     */\n+    public static final String OPTION_NULL_CONTAINER =\n+        \"org.apache.openjpa.option.NullContainer\";\n+\n+    /**\n+     * Option for runtimes that support embedded relations to other\n+     * persistence capable objects.\n+     */\n+    public static final String OPTION_EMBEDDED_RELATION =\n+        \"org.apache.openjpa.option.EmbeddedRelation\";\n+\n+    /**\n+     * Option for runtimes that support collections of embedded\n+     * relations to other persistence capable objects.\n+     */\n+    public static final String OPTION_EMBEDDED_COLLECTION_RELATION =\n+        \"org.apache.openjpa.option.EmbeddedCollectionRelation\";\n+\n+    /**\n+     * Option for runtimes that support maps of embedded\n+     * relations to other persistence capable objects.\n+     */\n+    public static final String OPTION_EMBEDDED_MAP_RELATION =\n+        \"org.apache.openjpa.option.EmbeddedMapRelation\";\n+\n+    /**\n+     * Option for runtimes that support incremental flushing.\n+     */\n+    public static final String OPTION_INC_FLUSH =\n+        \"org.apache.openjpa.option.IncrementalFlush\";\n+\n+    /**\n+     * Option for runtimes that the autoassign value strategy.\n+     */\n+    public static final String OPTION_VALUE_AUTOASSIGN =\n+        \"org.apache.openjpa.option.AutoassignValue\";\n+\n+    /**\n+     * Option for runtimes that the increment value strategy.\n+     */\n+    public static final String OPTION_VALUE_INCREMENT =\n+        \"org.apache.openjpa.option.IncrementValue\";\n+\n+    /**\n+     * Option for runtimes that support returning the datastore connection.\n+     */\n+    public static final String OPTION_DATASTORE_CONNECTION =\n+        \"org.apache.openjpa.option.DataStoreConnection\";\n+\n+    /**\n+     * Option for runtimes that support returning the datastore connection\n+     * that is a JDBC Connection.\n+     */\n+    public static final String OPTION_JDBC_CONNECTION =\n+        \"org.apache.openjpa.option.JDBCConnection\";\n+\n+    /**\n+     * Return the set of option strings supported by this runtime.  This set\n+     * is mutable.\n+     */\n+    public Collection supportedOptions();\n+\n+    /**\n+     * A configuration can be set with defaults for a specific specification.\n+     */\n+    public String getSpecification();\n+\n+    /**\n+     * Set the specification that this configuration should use for the\n+     * various properties that need to have different defaults for different\n+     * spec environments. This should be invoked before any configuration\n+     * options are set, as it will mutate various values.\n+     * You can only assign the specification once, though it is not fatal\n+     * to attempt to do so multiple times.  Attempts to set to null will\n+     * be ignored.\n+     */\n+    public boolean setSpecification(String spec);\n+\n+    /**\n+     * The plugin string for the {@link ClassResolver} to use for custom\n+     * class loading.\n+     */\n+    public String getClassResolver();\n+\n+    /**\n+     * The plugin string for the {@link ClassResolver} to use for custom\n+     * class loading.\n+     */\n+    public void setClassResolver(String classResolver);\n+\n+    /**\n+     * The {@link ClassResolver} to use.\n+     */\n+    public ClassResolver getClassResolverInstance();\n+\n+    /**\n+     * The {@link ClassResolver} to use.\n+     */\n+    public void setClassResolver(ClassResolver classResolver);\n+\n+    /**\n+     * The {@link BrokerFactory} class to use.\n+     */\n+    public String getBrokerFactory();\n+\n+    /**\n+     * The {@link BrokerFactory} class to use.\n+     */\n+    public void setBrokerFactory(String factory);\n+\n+    /**\n+     * The plugin string of the {@link BrokerImpl} extension to create.\n+     */\n+    public String getBrokerImpl();\n+\n+    /**\n+     * The plugin string of the {@link BrokerImpl} extension to create.\n+     */\n+    public void setBrokerImpl(String broker);\n+\n+    /**\n+     * Create a new broker instance with the configured plugin data.\n+     */\n+    public BrokerImpl newBrokerInstance(String user, String pass);\n+\n+    /**\n+     * The {@link DataCache} to use for level-2 data store caching.\n+     */\n+    public String getDataCache();\n+\n+    /**\n+     * The {@link DataCache} to use for level-2 data store caching.\n+     */\n+    public void setDataCache(String dataCache);\n+\n+    /**\n+     * The data cache manager manages this configuration's cache instances.\n+     */\n+    public String getDataCacheManager();\n+\n+    /**\n+     * The data cache manager manages this configuration's cache instances.\n+     */\n+    public void setDataCacheManager(String mgr);\n+\n+    /**\n+     * The data cache manager manages this configuration's cache instances.\n+     * The cache manager is created if it has not been set.  Once the cache\n+     * manager has been set/created, all changes to caching configuration\n+     * must proceed through the cache manager.\n+     *\n+     * @since 3.0\n+     */\n+    public DataCacheManager getDataCacheManagerInstance();\n+\n+    /**\n+     * The data cache manager manages this configuration's cache instances.\n+     *\n+     * @since 3.0\n+     */\n+    public void setDataCacheManager(DataCacheManager manager);\n+\n+    /**\n+     * Default data cache timeout.\n+     *\n+     * @since 2.5\n+     */\n+    public int getDataCacheTimeout();\n+\n+    /**\n+     * Default data cache timeout.\n+     *\n+     * @since 2.5\n+     */\n+    public void setDataCacheTimeout(int timeout);\n+\n+    /**\n+     * Wrapper for JCA usage of {@link #setDataCacheTimeout(int)}.\n+     *\n+     * @since 2.5\n+     */\n+    public void setDataCacheTimeout(Integer timeout);\n+\n+    /**\n+     * The plugin to use for level-2 data store query caching.\n+     *\n+     * @since 2.5\n+     */\n+    public String getQueryCache();\n+\n+    /**\n+     * The plugin to use for level-2 data store query caching.\n+     *\n+     * @since 2.5\n+     */\n+    public void setQueryCache(String queryCache);\n+\n+    /**\n+     * Return whether to generate dynamic data structures\n+     * where possible for cache and runtime usage.\n+     *\n+     * @since 3.3\n+     */\n+    public boolean getDynamicDataStructs();\n+\n+    /**\n+     * Set whether to generate dynamic data structures\n+     * where possible for cache and runtime usage.\n+     *\n+     * @since 3.3\n+     */\n+    public void setDynamicDataStructs(boolean dynamic);\n+\n+    /**\n+     * Wrapper for JCA usage of {@link #setDynamicDataStructs(boolean)}.\n+     */\n+    public void setDynamicDataStructs(Boolean dynamic);\n+\n+    /**\n+     * The plugin to use for datastore lock management.\n+     *\n+     * @since 3.1\n+     */\n+    public String getLockManager();\n+\n+    /**\n+     * The plugin to use for datastore lock management.\n+     *\n+     * @since 3.1\n+     */\n+    public void setLockManager(String lockManager);\n+\n+    /**\n+     * Return a new lock manager instance using the configured plugin settings.\n+     */\n+    public LockManager newLockManagerInstance();\n+\n+    /**\n+     * The plugin to use for managing inverse relations.\n+     *\n+     * @since 3.2\n+     */\n+    public String getInverseManager();\n+\n+    /**\n+     * The plugin to use for managing inverse relations.\n+     *\n+     * @since 3.2\n+     */\n+    public void setInverseManager(String inverse);\n+\n+    /**\n+     * Return a new inverse manager instance using the configured plugin\n+     * settings.\n+     *\n+     * @since 3.2\n+     */\n+    public InverseManager newInverseManagerInstance();\n+\n+    /**\n+     * The plugin to use for savepoint management.\n+     *\n+     * @since 3.4\n+     */\n+    public String getSavepointManager();\n+\n+    /**\n+     * The plugin to use for savepoint management.\n+     *\n+     * @since 3.4\n+     */\n+    public void setSavepointManager(String savepointManager);\n+\n+    /**\n+     * Return the configured savepoint manager instance.\n+     */\n+    public SavepointManager getSavepointManagerInstance();\n+\n+    /**\n+     * The action to take when an orphaned key is detected.\n+     *\n+     * @since 3.2.2\n+     */\n+    public String getOrphanedKeyAction();\n+\n+    /**\n+     * The action to take when an orphaned key is detected.\n+     *\n+     * @since 3.2.2\n+     */\n+    public void setOrphanedKeyAction(String action);\n+\n+    /**\n+     * The action to take when an orphaned key is detected.\n+     *\n+     * @since 3.2.2\n+     */\n+    public OrphanedKeyAction getOrphanedKeyActionInstance();\n+\n+    /**\n+     * The action to take when an orphaned key is detected.\n+     *\n+     * @since 3.2.2\n+     */\n+    public void setOrphanedKeyAction(OrphanedKeyAction action);\n+\n+    /**\n+     * The plugin to use for remote commit notification.\n+     *\n+     * @since 2.5\n+     */\n+    public String getRemoteCommitProvider();\n+\n+    /**\n+     * The plugin to use for remote commit notification.\n+     *\n+     * @since 2.5\n+     */\n+    public void setRemoteCommitProvider(String remoteCommitProvider);\n+\n+    /**\n+     * Create a remote commit provider from the configured plugin.\n+     *\n+     * @since 3.0\n+     */\n+    public RemoteCommitProvider newRemoteCommitProviderInstance();\n+\n+    /**\n+     * The remote event manager that manages this configuration's remote\n+     * event listeners.\n+     *\n+     * @since 3.0\n+     */\n+    public RemoteCommitEventManager getRemoteCommitEventManager();\n+\n+    /**\n+     * The remote event manager that manages this configuration's remote\n+     * event listeners.\n+     *\n+     * @since 3.0\n+     */\n+    public void setRemoteCommitEventManager(RemoteCommitEventManager manager);\n+\n+    /**\n+     * Specifies the behavior of the transaction featureSelection. Possible values are:\n+     * <ul>\n+     * <li><code>local</code>: Perform transaction operations locally.</li>\n+     * <li><code>managed</code>: Use managed environment's global\n+     * transactions.</li>\n+     * </ul>\n+     *\n+     * @since 2.5\n+     */\n+    public String getTransactionMode();\n+\n+    /**\n+     * Specifies the behavior of the transaction featureSelection. Possible values are:\n+     * <ul>\n+     * <li><code>local</code>: Perform transaction operations locally.</li>\n+     * <li><code>managed</code>: Use managed environment's global\n+     * transactions.</li>\n+     * </ul>\n+     *\n+     * @since 2.5\n+     */\n+    public void setTransactionMode(String mode);\n+\n+    /**\n+     * Return whether managed transactions are being used.\n+     */\n+    public boolean isTransactionModeManaged();\n+\n+    /**\n+     * Set whether managed transactions are being used.\n+     */\n+    public void setTransactionModeManaged(boolean managed);\n+\n+    /**\n+     * The plugin string for the {@link ManagedRuntime} to use for managed\n+     * environments.\n+     */\n+    public String getManagedRuntime();\n+\n+    /**\n+     * The plugin string for the {@link ManagedRuntime} to use for managed\n+     * environments.\n+     */\n+    public void setManagedRuntime(String managedRuntime);\n+\n+    /**\n+     * The plugin to use for integrating with a managed runtime.\n+     */\n+    public ManagedRuntime getManagedRuntimeInstance();\n+\n+    /**\n+     * The plugin to use for integrating with a managed runtime.\n+     */\n+    public void setManagedRuntime(ManagedRuntime runtime);\n+\n+    /**\n+     * The plugin string for the {@link ProxyManager} to use for second\n+     * class object proxies.\n+     */\n+    public String getProxyManager();\n+\n+    /**\n+     * The plugin string for the {@link ProxyManager} to use for second\n+     * class object proxies.\n+     */\n+    public void setProxyManager(String proxyManager);\n+\n+    /**\n+     * The {@link ProxyManager} to use.\n+     */\n+    public ProxyManager getProxyManagerInstance();\n+\n+    /**\n+     * The {@link ProxyManager} to use.\n+     */\n+    public void setProxyManager(ProxyManager manager);\n+\n+    /**\n+     * The name mapping to use for this data store.\n+     */\n+    public String getMapping();\n+\n+    /**\n+     * The name mapping to use for this data store.\n+     */\n+    public void setMapping(String mapping);\n+\n+    /**\n+     * A plugin string describing the {@link MetaDataFactory} to use.\n+     */\n+    public String getMetaDataFactory();\n+\n+    /**\n+     * A plugin string describing the {@link MetaDataFactory} to use.\n+     */\n+    public void setMetaDataFactory(String meta);\n+\n+    /**\n+     * Create a new {@link MetaDataFactory} to use with a repository.\n+     */\n+    public MetaDataFactory newMetaDataFactoryInstance();\n+\n+    /**\n+     * The metadata repository of managed class information.  If no\n+     * repository has been set, creates one.\n+     *\n+     * @since 3.0\n+     */\n+    public MetaDataRepository getMetaDataRepository();\n+\n+    /**\n+     * The metadata repository of managed class information.\n+     *\n+     * @since 3.0\n+     */\n+    public void setMetaDataRepository(MetaDataRepository mdRepos);\n+\n+    /**\n+     * The user name for the data store connection.\n+     */\n+    public String getConnectionUserName();\n+\n+    /**\n+     * The user name for the data store connection.\n+     */\n+    public void setConnectionUserName(String connectionUserName);\n+\n+    /**\n+     * The password for the data store connection.\n+     */\n+    public String getConnectionPassword();\n+\n+    /**\n+     * The password for the data store connection.\n+     */\n+    public void setConnectionPassword(String connectionPassword);\n+\n+    /**\n+     * The URL for the data store connection.\n+     */\n+    public String getConnectionURL();\n+\n+    /**\n+     * The URL for the data store connection.\n+     */\n+    public void setConnectionURL(String connectionURL);\n+\n+    /**\n+     * Class name of the connection driver.\n+     */\n+    public String getConnectionDriverName();\n+\n+    /**\n+     * Class name of the connection driver.\n+     */\n+    public void setConnectionDriverName(String driverName);\n+\n+    /**\n+     * The name for the data store connection factory.\n+     */\n+    public String getConnectionFactoryName();\n+\n+    /**\n+     * The name for the data store connection factory.\n+     */\n+    public void setConnectionFactoryName(String cfName);\n+\n+    /**\n+     * The connection factory, possibly from JNDI.\n+     */\n+    public Object getConnectionFactory();\n+\n+    /**\n+     * The connection factory.\n+     */\n+    public void setConnectionFactory(Object factory);\n+\n+    /**\n+     * These properties provide any additional information needed to\n+     * establish connections.\n+     */\n+    public String getConnectionProperties();\n+\n+    /**\n+     * These properties provide any additional information needed to\n+     * establish connections.\n+     */\n+    public void setConnectionProperties(String props);\n+\n+    /**\n+     * Configuration properties for the connection factory.\n+     */\n+    public String getConnectionFactoryProperties();\n+\n+    /**\n+     * Configuration properties for the connection factory.\n+     */\n+    public void setConnectionFactoryProperties(String props);\n+\n+    /**\n+     * The mode of the connection factory in use.  Available options are:\n+     * <ul>\n+     * <li>local: OpenJPA controls the connections.</li>\n+     * <li>managed: Connections are automatically enlisted in\n+     * the current global transaction by an application server.</li>\n+     * </ul>\n+     * Defaults to local.\n+     */\n+    public String getConnectionFactoryMode();\n+\n+    /**\n+     * The mode of the connection factory in use.  Available options are:\n+     * <ul>\n+     * <li>local: OpenJPA controls the connections.</li>\n+     * <li>managed: Connections are automatically enlisted in\n+     * the current global transaction by an application server.</li>\n+     * </ul>\n+     * Defaults to local.\n+     */\n+    public void setConnectionFactoryMode(String mode);\n+\n+    /**\n+     * Whether connections are automatically enlisted in global transactions.\n+     */\n+    public boolean isConnectionFactoryModeManaged();\n+\n+    /**\n+     * Whether connections are automatically enlisted in global transactions.\n+     */\n+    public void setConnectionFactoryModeManaged(boolean managed);\n+\n+    /**\n+     * The user name for the non-XA data store connection.\n+     */\n+    public String getConnection2UserName();\n+\n+    /**\n+     * The user name for the non-XA data store connection.\n+     */\n+    public void setConnection2UserName(String connectionUserName);\n+\n+    /**\n+     * The password for the non-XA data store connection.\n+     */\n+    public String getConnection2Password();\n+\n+    /**\n+     * The password for the non-XA data store connection.\n+     */\n+    public void setConnection2Password(String connectionPassword);\n+\n+    /**\n+     * The URL for the non-XA data store connection.\n+     */\n+    public String getConnection2URL();\n+\n+    /**\n+     * The URL for the non-XA data store connection.\n+     */\n+    public void setConnection2URL(String connectionURL);\n+\n+    /**\n+     * Class name of the non-XA connection driver.\n+     */\n+    public String getConnection2DriverName();\n+\n+    /**\n+     * Class name of the non-XA connection driver.\n+     */\n+    public void setConnection2DriverName(String driverName);\n+\n+    /**\n+     * The name for the second data store connection factory.\n+     */\n+    public String getConnectionFactory2Name();\n+\n+    /**\n+     * The name for the second data store connection factory.\n+     */\n+    public void setConnectionFactory2Name(String cf2Name);\n+\n+    /**\n+     * The non-XA connection factory.\n+     */\n+    public Object getConnectionFactory2();\n+\n+    /**\n+     * The non-XA connection factory.\n+     */\n+    public void setConnectionFactory2(Object factory);\n+\n+    /**\n+     * These properties provide any additional information needed to\n+     * establish non-XA connections.\n+     *\n+     * @since 3.0\n+     */\n+    public String getConnection2Properties();\n+\n+    /**\n+     * These properties provide any additional information needed to\n+     * establish non-XA connections.\n+     *\n+     * @since 3.0\n+     */\n+    public void setConnection2Properties(String props);\n+\n+    /**\n+     * Configuration properties for the non-XA connection factory.\n+     *\n+     * @since 2.5\n+     */\n+    public String getConnectionFactory2Properties();\n+\n+    /**\n+     * Configuration properties for the non-XA connection factory.\n+     *\n+     * @since 2.5\n+     */\n+    public void setConnectionFactory2Properties(String props);\n+\n+    /**\n+     * Whether to use optimistic transactions by default.\n+     */\n+    public boolean getOptimistic();\n+\n+    /**\n+     * Whether to use optimistic transactions by default.\n+     */\n+    public void setOptimistic(boolean optimistic);\n+\n+    /**\n+     * Wrapper for JCA usage of {@link #setOptimistic(boolean)}.\n+     */\n+    public void setOptimistic(Boolean optimistic);\n+\n+    /**\n+     * Whether to retain state after a transaction by default.\n+     */\n+    public boolean getRetainState();\n+\n+    /**\n+     * Whether to retain state after a transaction by default.\n+     */\n+    public void setRetainState(boolean retainState);\n+\n+    /**\n+     * Wrapper for JCA usage of {@link #setRetainState(boolean)}.\n+     */\n+    public void setRetainState(Boolean retainState);\n+\n+    /**\n+     * Whether instances clear their state when entering a transaction.\n+     */\n+    public String getAutoClear();\n+\n+    /**\n+     * Whether instances clear their state when entering a transaction.\n+     */\n+    public void setAutoClear(String clear);\n+\n+    /**\n+     * Return the {@link AutoClear} constant.\n+     */\n+    public int getAutoClearConstant();\n+\n+    /**\n+     * Whether instances clear their state when entering a transaction.\n+     */\n+    public void setAutoClear(int clear);\n+\n+    /**\n+     * Whether to restore initial state on rollback by default.\n+     */\n+    public String getRestoreState();\n+\n+    /**\n+     * Whether to restore initial state on rollback by default.\n+     */\n+    public void setRestoreState(String restoreState);\n+\n+    /**\n+     * Return the {@link RestoreState} constant.\n+     */\n+    public int getRestoreStateConstant();\n+\n+    /**\n+     * Whether to restore initial state on rollback by default.\n+     */\n+    public void setRestoreState(int restoreState);\n+\n+    /**\n+     * Whether changes in the current transaction are taken into account when\n+     * executing queries and iterating extents.\n+     */\n+    public boolean getIgnoreChanges();\n+\n+    /**\n+     * Whether changes in the current transaction are taken into account when\n+     * executing queries and iterating extents.\n+     */\n+    public void setIgnoreChanges(boolean ignoreChanges);\n+\n+    /**\n+     * Wrapper for JCA usage of {@link #setIgnoreChanges(boolean)}.\n+     */\n+    public void setIgnoreChanges(Boolean ignoreChanges);\n+\n+    /**\n+     * A comma-separated list of events which trigger auto-detachment\n+     * in place of managed states.  Possible values are:\n+     * <ul>\n+     * <li><code>commit</code>: When the current transaction commits.</li>\n+     * <li><code>close</code>: When the broker closes.</li>\n+     * <li><code>nontx-read</code>: When instances are read\n+     * non-transactionally.</li>\n+     * </ul>\n+     */\n+    public String getAutoDetach();\n+\n+    /**\n+     * A comma-separated list of events which trigger auto-detachment\n+     * in place of managed states.  Possible values are:\n+     * <ul>\n+     * <li><code>commit</code>: When the current transaction commits.</li>\n+     * <li><code>close</code>: When the broker closes.</li>\n+     * <li><code>nontx-read</code>: When instances are read\n+     * non-transactionally.</li>\n+     * </ul>\n+     */\n+    public void setAutoDetach(String detach);\n+\n+    /**\n+     * The {@link AutoDetach} flags.\n+     */\n+    public int getAutoDetachConstant();\n+\n+    /**\n+     * The {@link AutoDetach} flags.\n+     */\n+    public void setAutoDetach(int flags);\n+\n+    /**\n+     * Which field values to include when detaching.\n+     */\n+    public void setDetachState(String detachState);\n+\n+    /**\n+     * Return the instance specified by the detach state plugin.\n+     */\n+    public DetachOptions getDetachStateInstance();\n+\n+    /**\n+     * Return the instance specified by the detach state plugin.\n+     */\n+    public void setDetachState(DetachOptions detachState);\n+\n+    /**\n+     * Whether persistent state is accessible outside a transaction by default.\n+     */\n+    public boolean getNontransactionalRead();\n+\n+    /**\n+     * Whether persistent state is accessible outside a transaction by default.\n+     */\n+    public void setNontransactionalRead(boolean ntRead);\n+\n+    /**\n+     * Wrapper for JCA usage of {@link #setNontransactionalRead(boolean)}.\n+     */\n+    public void setNontransactionalRead(Boolean ntRead);\n+\n+    /**\n+     * Whether persistent state can be modified outside a transaction by\n+     * default.\n+     */\n+    public boolean getNontransactionalWrite();\n+\n+    /**\n+     * Whether persistent state can be modified outside a transaction by\n+     * default.\n+     */\n+    public void setNontransactionalWrite(boolean ntWrite);\n+\n+    /**\n+     * Wrapper for JCA usage of {@link #setNontransactionalWrite(boolean)}.\n+     */\n+    public void setNontransactionalWrite(Boolean ntWrite);\n+\n+    /**\n+     * Whether brokers or their managed objects will be used by multiple\n+     * concurrent threads.\n+     */\n+    public boolean getMultithreaded();\n+\n+    /**\n+     * Whether brokers or their managed objects will be used by multiple\n+     * concurrent threads.\n+     */\n+    public void setMultithreaded(boolean multithreaded);\n+\n+    /**\n+     * Wrapper for JCA usage of {@link #setMultithreaded(boolean)}.\n+     */\n+    public void setMultithreaded(Boolean multithreaded);\n+\n+    /**\n+     * Get the size of the batch that will be pre-selected when accessing\n+     * elements in a query or relationship.  Use -1 to prefetch all results.\n+     */\n+    public int getFetchBatchSize();\n+\n+    /**\n+     * Set the size of the batch that will be pre-selected when accessing\n+     * elements in a query or relationship.  Use -1 to prefetch all results.\n+     */\n+    public void setFetchBatchSize(int size);\n+\n+    /**\n+     * Wrapper for JCA usage of {@link #setFetchBatchSize(int)}.\n+     */\n+    public void setFetchBatchSize(Integer size);\n+\n+    /**\n+     * Comma-separated list of fetch group names that will be pre-set for\n+     * all new {@link FetchConfiguration}s.\n+     *\n+     * @since 2.5\n+     */\n+    public String getFetchGroups();\n+\n+    /**\n+     * Comma-separated list of fetch group names that will be pre-set for\n+     * all new {@link FetchConfiguration}s.\n+     *\n+     * @since 2.5\n+     */\n+    public void setFetchGroups(String groups);\n+\n+    /**\n+     * List of fetch group names that will be pre-set for all new\n+     * {@link FetchConfiguration}s.\n+     */\n+    public String[] getFetchGroupsList();\n+\n+    /**\n+     * List of fetch group names that will be pre-set for all new\n+     * {@link FetchConfiguration}s.\n+     */\n+    public void setFetchGroups(String[] names);\n+\n+    /**\n+     * Returns whether or not OpenJPA should automatically flush\n+     * modifications to the data store before executing queries.\n+     *\n+     * @since 2.5\n+     */\n+    public String getFlushBeforeQueries();\n+\n+    /**\n+     * Sets whether or not OpenJPA should automatically flush\n+     * modifications to the data store before executing queries.\n+     *\n+     * @since 2.5\n+     */\n+    public void setFlushBeforeQueries(String flush);\n+\n+    /**\n+     * Returns one of {@link QueryFlushModes#FLUSH_TRUE},\n+     * {@link QueryFlushModes#FLUSH_FALSE}, or\n+     * {@link QueryFlushModes#FLUSH_WITH_CONNECTION}, as determined\n+     * by parsing the string returned by {@link #getFlushBeforeQueries}.\n+     *\n+     * @since 2.5\n+     */\n+    public int getFlushBeforeQueriesConstant();\n+\n+    /**\n+     * Set to one of {@link QueryFlushModes#FLUSH_TRUE},\n+     * {@link QueryFlushModes#FLUSH_FALSE}, or\n+     * {@link QueryFlushModes#FLUSH_WITH_CONNECTION}.\n+     *\n+     * @since 2.5\n+     */\n+    public void setFlushBeforeQueries(int flushBeforeQueries);\n+\n+    /**\n+     * The time to wait for an object lock in milliseconds, or -1 for no\n+     * timeout.\n+     *\n+     * @since 3.1\n+     */\n+    public int getLockTimeout();\n+\n+    /**\n+     * The time to wait for an object lock in milliseconds, or -1 for no\n+     * timeout.\n+     *\n+     * @since 3.1\n+     */\n+    public void setLockTimeout(int timeout);\n+\n+    /**\n+     * Wrapper for JCA usage of {@link #setLockTimeout(int)}.\n+     *\n+     * @since 3.1\n+     */\n+    public void setLockTimeout(Integer timeout);\n+\n+    /**\n+     * The default read lock level to use during non-optimistic transactions.\n+     * Defaults to <code>read</code>.\n+     *\n+     * @since 3.1\n+     */\n+    public String getReadLockLevel();\n+\n+    /**\n+     * The default read lock level to use during non-optimistic transactions.\n+     * Defaults to <code>read</code>.\n+     *\n+     * @since 3.1\n+     */\n+    public void setReadLockLevel(String level);\n+\n+    /**\n+     * The numeric read lock level.\n+     *\n+     * @since 3.1\n+     */\n+    public int getReadLockLevelConstant();\n+\n+    /**\n+     * The numeric read lock level.\n+     *\n+     * @since 3.1\n+     */\n+    public void setReadLockLevel(int level);\n+\n+    /**\n+     * The default write lock level to use during non-optimistic transactions.\n+     * Defaults to <code>write</code>.\n+     *\n+     * @since 3.1\n+     */\n+    public String getWriteLockLevel();\n+\n+    /**\n+     * The default write lock level to use during non-optimistic transactions.\n+     * Defaults to <code>write</code>.\n+     *\n+     * @since 3.1\n+     */\n+    public void setWriteLockLevel(String level);\n+\n+    /**\n+     * The numeric write lock level.\n+     *\n+     * @since 3.1\n+     */\n+    public int getWriteLockLevelConstant();\n+\n+    /**\n+     * The numeric write lock level.\n+     *\n+     * @since 3.1\n+     */\n+    public void setWriteLockLevel(int level);\n+\n+    /**\n+     * Plugin string for the default system {@link Seq}.\n+     */\n+    public String getSequence();\n+\n+    /**\n+     * Plugin string for the default system {@link Seq}.\n+     */\n+    public void setSequence(String sequence);\n+\n+    /**\n+     * The default system sequence.\n+     */\n+    public Seq getSequenceInstance();\n+\n+    /**\n+     * The default system sequence.\n+     */\n+    public void setSequence(Seq sequence);\n+\n+    /**\n+     * Specifies the behavior of the broker with respect to data store\n+     * connections.  Possible values are:\n+     * <ul>\n+     * <li><code>always</code>: Each broker obtains a single connection and\n+     * uses it until the broker is closed.</li>\n+     * <li><code>transaction</code>: A connection is obtained when each\n+     * transaction begins (optimistic or datastore), and is released\n+     * when the transaction completes.</li>\n+     * <li><code>on-demand</code>: Connections are obtained only when needed.\n+     * This is the default mode.  It is equivalent to the previous option\n+     * when datastore transactions are used.  For optimistic transactions,\n+     * though, it means that a connection will be retained only for\n+     * the duration of the data store commit process.</li>\n+     * </ul>\n+     *\n+     * @since 2.5\n+     */\n+    public String getConnectionRetainMode();\n+\n+    /**\n+     * Specifies the behavior of the broker with respect to data store\n+     * connections.  Possible values are:\n+     * <ul>\n+     * <li><code>always</code>: Each broker obtains a single connection and\n+     * uses it until the broker is closed.</li>\n+     * <li><code>transaction</code>: A connection is obtained when each\n+     * transaction begins (optimistic or datastore), and is released\n+     * when the transaction completes.</li>\n+     * <li><code>on-demand</code>: Connections are obtained only when needed.\n+     * This is the default mode.  It is equivalent to the previous option\n+     * when datastore transactions are used.  For optimistic transactions,\n+     * though, it means that a connection will be retained only for\n+     * the duration of the data store commit process.</li>\n+     * </ul>\n+     *\n+     * @since 2.5\n+     */\n+    public void setConnectionRetainMode(String mode);\n+\n+    /**\n+     * Return the connection retain mode as one of the following symbolic\n+     * constants:\n+     * <ul>\n+     * <li>{@link ConnectionRetainModes#CONN_RETAIN_ALWAYS}</li>\n+     * <li>{@link ConnectionRetainModes#CONN_RETAIN_TRANS}</li>\n+     * <li>{@link ConnectionRetainModes#CONN_RETAIN_DEMAND}</li>\n+     * </ul>\n+     */\n+    public int getConnectionRetainModeConstant();\n+\n+    /**\n+     * Set the connection retain mode as one of the following symbolic\n+     * constants:\n+     * <ul>\n+     * <li>{@link ConnectionRetainModes#CONN_RETAIN_ALWAYS}</li>\n+     * <li>{@link ConnectionRetainModes#CONN_RETAIN_TRANS}</li>\n+     * <li>{@link ConnectionRetainModes#CONN_RETAIN_DEMAND}</li>\n+     * </ul>\n+     */\n+    public void setConnectionRetainMode(int mode);\n+\n+    /**\n+     * A comma-separted list of the plugin strings of the query\n+     * {@link FilterListener}s to use.\n+     */\n+    public String getFilterListeners();\n+\n+    /**\n+     * A comma-separted list of the plugin strings of the query\n+     * {@link FilterListener}s to use.\n+     */\n+    public void setFilterListeners(String listeners);\n+\n+    /**\n+     * Return the query filter listeners.  If none have been set explicitly,\n+     * this method instantiates the listeners from the set plugin list.\n+     */\n+    public FilterListener[] getFilterListenerInstances();\n+\n+    /**\n+     * Set the query filter listeners.  Overrides the list of listener classes.\n+     */\n+    public void setFilterListeners(FilterListener[] listeners);\n+\n+    /**\n+     * A comma-separted list of the plugin strings of the query\n+     * {@link AggregateListener}s to use.\n+     */\n+    public String getAggregateListeners();\n+\n+    /**\n+     * A comma-separted list of the plugin strings of the query\n+     * {@link AggregateListener}s to use.\n+     */\n+    public void setAggregateListeners(String listeners);\n+\n+    /**\n+     * Return the query function listeners.  If none have been set explicitly,\n+     * this method instantiates the listeners from the set plugin list.\n+     */\n+    public AggregateListener[] getAggregateListenerInstances();\n+\n+    /**\n+     * Set the query function listeners.  Overrides the list of listener\n+     * classes.\n+     */\n+    public void setAggregateListeners(AggregateListener[] listeners);\n+\n+    /**\n+     * Whether to warn and defer registration instead of throwing an\n+     * exception when a registered persistent class cannot be processed.\n+     * Should only be set to true in complex classloader topologies.\n+     * Defaults to <code>false</code>.\n+     *\n+     * @since 3.2.3\n+     */\n+    public boolean getRetryClassRegistration();\n+\n+    /**\n+     *\tWhether to warn and defer registration instead of throwing an\n+     *\texception when a registered persistent class cannot be processed.\n+     *\tShould only be set to true in complex classloader topologies.\n+\t * \tDefaults to <code>false</code>.\n+\t *\n+\t *\t@since 3.2.3\n+\t */\n+\tpublic void setRetryClassRegistration (boolean warn);\n+\n+\n+\t/**\n+\t *\tWrapper for JCA usage of {@link #setRetryClassRegistration(boolean)}.\n+\t *\n+\t *\t@since 3.2.3\n+\t */\n+\tpublic void setRetryClassRegistration (Boolean warn);\n+\n+\n+\t/**\n+\t *\tBackwards compatibility options.\n+\t */\n+\tpublic String getCompatibility ();\n+\n+\n+\t/**\n+\t *\tBackwards compatibility options.\n+\t */\n+\tpublic void setCompatibility (String compatibility);\n+\n+\n+\t/**\n+\t *\tBackwards compatibility options.\n+\t */\n+\tpublic Compatibility getCompatibilityInstance ();\n+}"},{"sha":"8c852c7188c8998e2a0d93fc58ec7374d0e39c39","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","status":"modified","additions":1427,"deletions":1352,"changes":2779,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,1352 +1,1427 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.HashSet;\r\n-\r\n-import org.apache.openjpa.datacache.ConcurrentDataCache;\r\n-import org.apache.openjpa.datacache.ConcurrentQueryCache;\r\n-import org.apache.openjpa.datacache.DataCacheManager;\r\n-import org.apache.openjpa.datacache.DataCacheManagerImpl;\r\n-import org.apache.openjpa.ee.ManagedRuntime;\r\n-import org.apache.openjpa.event.OrphanedKeyAction;\r\n-import org.apache.openjpa.event.RemoteCommitEventManager;\r\n-import org.apache.openjpa.event.RemoteCommitProvider;\r\n-import org.apache.openjpa.kernel.AutoClear;\r\n-import org.apache.openjpa.kernel.BrokerImpl;\r\n-import org.apache.openjpa.kernel.ConnectionRetainModes;\r\n-import org.apache.openjpa.kernel.InverseManager;\r\n-import org.apache.openjpa.kernel.LockLevels;\r\n-import org.apache.openjpa.kernel.LockManager;\r\n-import org.apache.openjpa.kernel.QueryFlushModes;\r\n-import org.apache.openjpa.kernel.RestoreState;\r\n-import org.apache.openjpa.kernel.SavepointManager;\r\n-import org.apache.openjpa.kernel.Seq;\r\n-import org.apache.openjpa.kernel.exps.AggregateListener;\r\n-import org.apache.openjpa.kernel.exps.FilterListener;\r\n-import org.apache.openjpa.lib.conf.BooleanValue;\r\n-import org.apache.openjpa.lib.conf.ConfigurationImpl;\r\n-import org.apache.openjpa.lib.conf.Configurations;\r\n-import org.apache.openjpa.lib.conf.IntValue;\r\n-import org.apache.openjpa.lib.conf.ObjectValue;\r\n-import org.apache.openjpa.lib.conf.PluginListValue;\r\n-import org.apache.openjpa.lib.conf.PluginValue;\r\n-import org.apache.openjpa.lib.conf.StringListValue;\r\n-import org.apache.openjpa.lib.conf.StringValue;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.meta.MetaDataFactory;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.util.ClassResolver;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-import org.apache.openjpa.util.ProxyManager;\r\n-\r\n-/**\r\n- * Implementation of the {@link OpenJPAConfiguration} interface.\r\n- * On construction, the class will attempt to locate a default properties\r\n- * file called <code>org.apache.openjpa.properties</code> located at any top level token\r\n- * of the CLASSPATH. See the {@link ConfigurationImpl} class description\r\n- * for details.\r\n- *\r\n- * @author Marc Prud'hommeaux\r\n- * @author Abe White\r\n- * @see ConfigurationImpl\r\n- */\r\n-public class OpenJPAConfigurationImpl extends ConfigurationImpl\r\n-    implements OpenJPAConfiguration {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (OpenJPAConfigurationImpl.class);\r\n-    // cached state; some of this is created in getter methods, so make\r\n-    // protected in case subclasses want to access without creating\r\n-    protected MetaDataRepository metaRepos = null;\r\n-    protected RemoteCommitEventManager remoteEventManager = null;\r\n-    // openjpa properties\r\n-    public ObjectValue classResolverPlugin;\r\n-    public ObjectValue brokerPlugin;\r\n-    public ObjectValue dataCachePlugin;\r\n-    public ObjectValue dataCacheManagerPlugin;\r\n-    public IntValue dataCacheTimeout;\r\n-    public ObjectValue queryCachePlugin;\r\n-    public BooleanValue dynamicDataStructs;\r\n-    public ObjectValue managedRuntimePlugin;\r\n-    public BooleanValue transactionMode;\r\n-    public IntValue connectionRetainMode;\r\n-    public IntValue fetchBatchSize;\r\n-    public StringListValue fetchGroups;\r\n-    public IntValue flushBeforeQueries;\r\n-    public IntValue lockTimeout;\r\n-    public IntValue readLockLevel;\r\n-    public IntValue writeLockLevel;\r\n-    public ObjectValue seqPlugin;\r\n-    public PluginListValue filterListenerPlugins;\r\n-    public PluginListValue aggregateListenerPlugins;\r\n-    public BooleanValue retryClassRegistration;\r\n-    public ObjectValue proxyManagerPlugin;\r\n-    public StringValue connectionUserName;\r\n-    public StringValue connectionPassword;\r\n-    public StringValue connectionURL;\r\n-    public StringValue connectionDriverName;\r\n-    public ObjectValue connectionFactory;\r\n-    public StringValue connectionFactoryName;\r\n-    public StringValue connectionProperties;\r\n-    public StringValue connectionFactoryProperties;\r\n-    public BooleanValue connectionFactoryMode;\r\n-    public StringValue connection2UserName;\r\n-    public StringValue connection2Password;\r\n-    public StringValue connection2URL;\r\n-    public StringValue connection2DriverName;\r\n-    public StringValue connection2Properties;\r\n-    public ObjectValue connectionFactory2;\r\n-    public StringValue connectionFactory2Name;\r\n-    public StringValue connectionFactory2Properties;\r\n-    public BooleanValue optimistic;\r\n-    public IntValue autoClear;\r\n-    public BooleanValue retainState;\r\n-    public IntValue restoreState;\r\n-    public ObjectValue detachStatePlugin;\r\n-    public BooleanValue ignoreChanges;\r\n-    public BooleanValue nontransactionalRead;\r\n-    public BooleanValue nontransactionalWrite;\r\n-    public BooleanValue multithreaded;\r\n-    public StringValue mapping;\r\n-    public PluginValue metaFactoryPlugin;\r\n-    public ObjectValue lockManagerPlugin;\r\n-    public ObjectValue inverseManagerPlugin;\r\n-    public ObjectValue savepointManagerPlugin;\r\n-    public ObjectValue orphanedKeyPlugin;\r\n-    public ObjectValue compatibilityPlugin;\r\n-    // custom values\r\n-    public BrokerFactoryValue brokerFactoryPlugin;\r\n-    public RemoteCommitProviderValue remoteProviderPlugin;\r\n-    public AutoDetachValue autoDetach;\r\n-    private Collection supportedOptions = new HashSet(33);\r\n-    private String spec = null;\r\n-\r\n-    /**\r\n-     * Default constructor. Attempts to load default properties.\r\n-     */\r\n-    public OpenJPAConfigurationImpl() {\r\n-        this(true);\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param loadDefaults whether to attempt to load the default\r\n-     *                     <code>org.apache.openjpa.properties</code> resource\r\n-     */\r\n-    public OpenJPAConfigurationImpl(boolean loadDefaults) {\r\n-        this(true, loadDefaults);\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param derivations  whether to apply product derivations\r\n-     * @param loadDefaults whether to attempt to load the default\r\n-     *                     <code>org.apache.openjpa.properties</code> resource\r\n-     */\r\n-    public OpenJPAConfigurationImpl(boolean derivations, boolean loadDefaults) {\r\n-        super(false);\r\n-        String[] aliases;\r\n-        // setup super's log factory plugin\r\n-        logFactoryPlugin.setProperty(\"org.apache.openjpa.Log\");\r\n-        logFactoryPlugin\r\n-            .setAlias(\"openjpa\", \"org.apache.openjpa.lib.log.LogFactoryImpl\");\r\n-        aliases = logFactoryPlugin.getAliases();\r\n-        logFactoryPlugin.setDefault(aliases[0]);\r\n-        logFactoryPlugin.setString(aliases[0]);\r\n-        classResolverPlugin =\r\n-            addPlugin(\"org.apache.openjpa.ClassResolver\", true);\r\n-        aliases = new String[]{\r\n-            \"default\", \"org.apache.openjpa.util.ClassResolverImpl\",\r\n-            // deprecated alias\r\n-            \"spec\", \"org.apache.openjpa.util.ClassResolverImpl\", };\r\n-        classResolverPlugin.setAliases(aliases);\r\n-        classResolverPlugin.setDefault(aliases[0]);\r\n-        classResolverPlugin.setString(aliases[0]);\r\n-        classResolverPlugin.setInstantiatingGetter(\"getClassResolverInstance\");\r\n-        brokerFactoryPlugin = new BrokerFactoryValue();\r\n-        addValue(brokerFactoryPlugin);\r\n-        brokerPlugin = addPlugin(\"org.apache.openjpa.BrokerImpl\", false);\r\n-        aliases = new String[]{ \"default\", BrokerImpl.class.getName() };\r\n-        brokerPlugin.setAliases(aliases);\r\n-        brokerPlugin.setDefault(aliases[0]);\r\n-        brokerPlugin.setString(aliases[0]);\r\n-\r\n-        dataCacheManagerPlugin =\r\n-            addPlugin(\"org.apache.openjpa.DataCacheManager\", true);\r\n-        aliases = new String[]{\r\n-            \"default\", DataCacheManagerImpl.class.getName(), };\r\n-        dataCacheManagerPlugin.setAliases(aliases);\r\n-        dataCacheManagerPlugin.setDefault(aliases[0]);\r\n-        dataCacheManagerPlugin.setString(aliases[0]);\r\n-        dataCacheManagerPlugin.setInstantiatingGetter(\"getDataCacheManager\");\r\n-        dataCachePlugin = addPlugin(\"org.apache.openjpa.DataCache\", false);\r\n-        aliases = new String[]{\r\n-            \"false\", null, \"true\", ConcurrentDataCache.class.getName(),\r\n-            \"concurrent\", ConcurrentDataCache.class.getName(), };\r\n-        dataCachePlugin.setAliases(aliases);\r\n-        dataCachePlugin.setDefault(aliases[0]);\r\n-        dataCachePlugin.setString(aliases[0]);\r\n-        dataCacheTimeout = addInt(\"org.apache.openjpa.DataCacheTimeout\");\r\n-        dataCacheTimeout.setDefault(\"-1\");\r\n-        dataCacheTimeout.set(-1);\r\n-        queryCachePlugin = addPlugin(\"org.apache.openjpa.QueryCache\", true);\r\n-        aliases = new String[]{\r\n-            \"true\", ConcurrentQueryCache.class.getName(),\r\n-            \"concurrent\", ConcurrentQueryCache.class.getName(), \"false\", null,\r\n-        };\r\n-        queryCachePlugin.setAliases(aliases);\r\n-        queryCachePlugin.setDefault(aliases[0]);\r\n-        queryCachePlugin.setString(aliases[0]);\r\n-        dynamicDataStructs =\r\n-            addBoolean(\"org.apache.openjpa.DynamicDataStructs\");\r\n-        dynamicDataStructs.setDefault(\"false\");\r\n-        dynamicDataStructs.set(false);\r\n-        lockManagerPlugin = addPlugin(\"org.apache.openjpa.LockManager\", false);\r\n-        aliases = new String[]{\r\n-            \"none\", \"org.apache.openjpa.kernel.NoneLockManager\",\r\n-            \"version\", \"org.apache.openjpa.kernel.VersionLockManager\", };\r\n-        lockManagerPlugin.setAliases(aliases);\r\n-        lockManagerPlugin.setDefault(aliases[0]);\r\n-        lockManagerPlugin.setString(aliases[0]);\r\n-        inverseManagerPlugin =\r\n-            addPlugin(\"org.apache.openjpa.InverseManager\", false);\r\n-        aliases = new String[]{\r\n-            \"false\", null, \"true\", \"org.apache.openjpa.kernel.InverseManager\",\r\n-        };\r\n-        inverseManagerPlugin.setAliases(aliases);\r\n-        inverseManagerPlugin.setDefault(aliases[0]);\r\n-        inverseManagerPlugin.setString(aliases[0]);\r\n-\r\n-        savepointManagerPlugin =\r\n-            addPlugin(\"org.apache.openjpa.SavepointManager\", true);\r\n-        aliases = new String[]{\r\n-            \"in-mem\", \"org.apache.openjpa.kernel.InMemorySavepointManager\", };\r\n-        savepointManagerPlugin.setAliases(aliases);\r\n-        savepointManagerPlugin.setDefault(aliases[0]);\r\n-        savepointManagerPlugin.setString(aliases[0]);\r\n-        savepointManagerPlugin.setInstantiatingGetter\r\n-            (\"getSavepointManagerInstance\");\r\n-        orphanedKeyPlugin =\r\n-            addPlugin(\"org.apache.openjpa.OrphanedKeyAction\", true);\r\n-        aliases = new String[]{\r\n-            \"log\", \"org.apache.openjpa.event.LogOrphanedKeyAction\",\r\n-            \"exception\", \"org.apache.openjpa.event.ExceptionOrphanedKeyAction\",\r\n-            \"none\", \"org.apache.openjpa.event.NoneOrphanedKeyAction\", };\r\n-        orphanedKeyPlugin.setAliases(aliases);\r\n-        orphanedKeyPlugin.setDefault(aliases[0]);\r\n-        orphanedKeyPlugin.setString(aliases[0]);\r\n-        orphanedKeyPlugin.setInstantiatingGetter\r\n-            (\"getOrphanedKeyActionInstance\");\r\n-        remoteProviderPlugin = new RemoteCommitProviderValue\r\n-            (\"org.apache.openjpa.RemoteCommitProvider\");\r\n-        addValue(remoteProviderPlugin);\r\n-        transactionMode = addBoolean(\"org.apache.openjpa.TransactionMode\");\r\n-        aliases = new String[]{\r\n-            \"local\", \"false\", \"managed\", \"true\", };\r\n-        transactionMode.setAliases(aliases);\r\n-        transactionMode.setDefault(aliases[0]);\r\n-        managedRuntimePlugin =\r\n-            addPlugin(\"org.apache.openjpa.ManagedRuntime\", true);\r\n-        aliases = new String[]{\r\n-            \"auto\", \"org.apache.openjpa.ee.AutomaticManagedRuntime\",\r\n-            \"jndi\", \"org.apache.openjpa.ee.JNDIManagedRuntime\",\r\n-            \"invocation\", \"org.apache.openjpa.ee.InvocationManagedRuntime\", };\r\n-        managedRuntimePlugin.setAliases(aliases);\r\n-        managedRuntimePlugin.setDefault(aliases[0]);\r\n-        managedRuntimePlugin.setString(aliases[0]);\r\n-        managedRuntimePlugin.setInstantiatingGetter\r\n-            (\"getManagedRuntimeInstance\");\r\n-        proxyManagerPlugin = addPlugin(\"org.apache.openjpa.ProxyManager\", true);\r\n-        aliases = new String[]{ \"default\",\r\n-            \"org.apache.openjpa.util.ProxyManagerImpl\" };\r\n-        proxyManagerPlugin.setAliases(aliases);\r\n-        proxyManagerPlugin.setDefault(aliases[0]);\r\n-        proxyManagerPlugin.setString(aliases[0]);\r\n-        proxyManagerPlugin.setInstantiatingGetter(\"getProxyManagerInstance\");\r\n-        mapping = addString(\"org.apache.openjpa.Mapping\");\r\n-        metaFactoryPlugin =\r\n-            addPlugin(\"org.apache.openjpa.MetaDataFactory\", false);\r\n-        connectionFactory = addObject(\"org.apache.openjpa.ConnectionFactory\");\r\n-        connectionFactory.setInstantiatingGetter(\"getConnectionFactory\");\r\n-        connectionFactory2 = addObject(\"org.apache.openjpa.ConnectionFactory2\");\r\n-        connectionFactory2.setInstantiatingGetter(\"getConnectionFactory2\");\r\n-        connectionUserName = addString(\"org.apache.openjpa.ConnectionUserName\");\r\n-        connectionPassword = addString(\"org.apache.openjpa.ConnectionPassword\");\r\n-        connectionURL = addString(\"org.apache.openjpa.ConnectionURL\");\r\n-        connectionDriverName =\r\n-            addString(\"org.apache.openjpa.ConnectionDriverName\");\r\n-        connectionFactoryName =\r\n-            addString(\"org.apache.openjpa.ConnectionFactoryName\");\r\n-        connectionProperties =\r\n-            addString(\"org.apache.openjpa.ConnectionProperties\");\r\n-        connectionFactoryProperties = addString\r\n-            (\"org.apache.openjpa.ConnectionFactoryProperties\");\r\n-        connection2UserName =\r\n-            addString(\"org.apache.openjpa.Connection2UserName\");\r\n-        connection2Password =\r\n-            addString(\"org.apache.openjpa.Connection2Password\");\r\n-        connection2URL = addString(\"org.apache.openjpa.Connection2URL\");\r\n-        connection2DriverName =\r\n-            addString(\"org.apache.openjpa.Connection2DriverName\");\r\n-        connection2Properties =\r\n-            addString(\"org.apache.openjpa.Connection2Properties\");\r\n-        connectionFactory2Properties = addString\r\n-            (\"org.apache.openjpa.ConnectionFactory2Properties\");\r\n-        connectionFactory2Name =\r\n-            addString(\"org.apache.openjpa.ConnectionFactory2Name\");\r\n-\r\n-        connectionFactoryMode =\r\n-            addBoolean(\"org.apache.openjpa.ConnectionFactoryMode\");\r\n-        aliases = new String[]{\r\n-            \"local\", \"false\", \"managed\", \"true\", };\r\n-        connectionFactoryMode.setAliases(aliases);\r\n-        connectionFactoryMode.setDefault(aliases[0]);\r\n-        optimistic = addBoolean(\"org.apache.openjpa.Optimistic\");\r\n-        optimistic.setDefault(\"true\");\r\n-        optimistic.set(true);\r\n-        autoClear = addInt(\"org.apache.openjpa.AutoClear\");\r\n-        aliases = new String[]{\r\n-            \"datastore\", String.valueOf(AutoClear.CLEAR_DATASTORE),\r\n-            \"all\", String.valueOf(AutoClear.CLEAR_ALL), };\r\n-        autoClear.setAliases(aliases);\r\n-        autoClear.setDefault(aliases[0]);\r\n-        autoClear.set(AutoClear.CLEAR_DATASTORE);\r\n-        retainState = addBoolean(\"org.apache.openjpa.RetainState\");\r\n-        retainState.setDefault(\"true\");\r\n-        retainState.set(true);\r\n-        restoreState = addInt(\"org.apache.openjpa.RestoreState\");\r\n-        aliases = new String[]{\r\n-            \"none\", String.valueOf(RestoreState.RESTORE_NONE),\r\n-            \"false\", String.valueOf(RestoreState.RESTORE_NONE),\r\n-            \"immutable\", String.valueOf(RestoreState.RESTORE_IMMUTABLE),\r\n-            // \"true\" for compat with jdo RestoreValues\r\n-            \"true\", String.valueOf(RestoreState.RESTORE_IMMUTABLE),\r\n-            \"all\", String.valueOf(RestoreState.RESTORE_ALL), };\r\n-        restoreState.setAliases(aliases);\r\n-        restoreState.setDefault(aliases[0]);\r\n-        restoreState.set(RestoreState.RESTORE_IMMUTABLE);\r\n-        autoDetach = new AutoDetachValue(\"org.apache.openjpa.AutoDetach\");\r\n-        addValue(autoDetach);\r\n-        detachStatePlugin = addPlugin(\"org.apache.openjpa.DetachState\", true);\r\n-        aliases = new String[]{\r\n-            \"loaded\", DetachOptions.Loaded.class.getName(),\r\n-            \"fgs\", DetachOptions.FetchGroups.class.getName(),\r\n-            \"all\", DetachOptions.All.class.getName(), };\r\n-        detachStatePlugin.setAliases(aliases);\r\n-        detachStatePlugin.setDefault(aliases[0]);\r\n-        detachStatePlugin.setString(aliases[0]);\r\n-        detachStatePlugin.setInstantiatingGetter(\"getDetachStateInstance\");\r\n-        ignoreChanges = addBoolean(\"org.apache.openjpa.IgnoreChanges\");\r\n-        nontransactionalRead =\r\n-            addBoolean(\"org.apache.openjpa.NontransactionalRead\");\r\n-        nontransactionalRead.setDefault(\"true\");\r\n-        nontransactionalRead.set(true);\r\n-\r\n-        nontransactionalWrite =\r\n-            addBoolean(\"org.apache.openjpa.NontransactionalWrite\");\r\n-        multithreaded = addBoolean(\"org.apache.openjpa.Multithreaded\");\r\n-        fetchBatchSize = addInt(\"org.apache.openjpa.FetchBatchSize\");\r\n-        fetchBatchSize.setDefault(\"-1\");\r\n-        fetchBatchSize.set(-1);\r\n-        fetchGroups = addStringList(\"org.apache.openjpa.FetchGroups\");\r\n-        fetchGroups.setDefault(\"default\");\r\n-        fetchGroups.set(new String[]{ \"default\" });\r\n-        flushBeforeQueries = addInt(\"org.apache.openjpa.FlushBeforeQueries\");\r\n-        aliases = new String[]{\r\n-            \"true\", String.valueOf(QueryFlushModes.FLUSH_TRUE),\r\n-            \"false\", String.valueOf(QueryFlushModes.FLUSH_FALSE),\r\n-            \"with-connection\", String.valueOf\r\n-            (QueryFlushModes.FLUSH_WITH_CONNECTION), };\r\n-        flushBeforeQueries.setAliases(aliases);\r\n-        flushBeforeQueries.setDefault(aliases[0]);\r\n-        flushBeforeQueries.set(QueryFlushModes.FLUSH_TRUE);\r\n-        lockTimeout = addInt(\"org.apache.openjpa.LockTimeout\");\r\n-        lockTimeout.setDefault(\"-1\");\r\n-        lockTimeout.set(-1);\r\n-        readLockLevel = addInt(\"org.apache.openjpa.ReadLockLevel\");\r\n-        aliases = new String[]{\r\n-            \"read\", String.valueOf(LockLevels.LOCK_READ),\r\n-            \"write\", String.valueOf(LockLevels.LOCK_WRITE),\r\n-            \"none\", String.valueOf(LockLevels.LOCK_NONE), };\r\n-        readLockLevel.setAliases(aliases);\r\n-        readLockLevel.setDefault(aliases[0]);\r\n-        readLockLevel.set(LockLevels.LOCK_READ);\r\n-        writeLockLevel = addInt(\"org.apache.openjpa.WriteLockLevel\");\r\n-        aliases = new String[]{\r\n-            \"read\", String.valueOf(LockLevels.LOCK_READ),\r\n-            \"write\", String.valueOf(LockLevels.LOCK_WRITE),\r\n-            \"none\", String.valueOf(LockLevels.LOCK_NONE), };\r\n-        writeLockLevel.setAliases(aliases);\r\n-        writeLockLevel.setDefault(aliases[1]);\r\n-        writeLockLevel.set(LockLevels.LOCK_WRITE);\r\n-        seqPlugin = new SeqValue(\"org.apache.openjpa.Sequence\");\r\n-        seqPlugin.setInstantiatingGetter(\"getSequenceInstance\");\r\n-        addValue(seqPlugin);\r\n-        connectionRetainMode =\r\n-            addInt(\"org.apache.openjpa.ConnectionRetainMode\");\r\n-        aliases = new String[]{\r\n-            \"on-demand\",\r\n-            String.valueOf(ConnectionRetainModes.CONN_RETAIN_DEMAND),\r\n-            \"transaction\",\r\n-            String.valueOf(ConnectionRetainModes.CONN_RETAIN_TRANS),\r\n-            \"always\", String.valueOf(ConnectionRetainModes.CONN_RETAIN_ALWAYS),\r\n-            // deprecated\r\n-            \"persistence-manager\",\r\n-            String.valueOf(ConnectionRetainModes.CONN_RETAIN_ALWAYS), };\r\n-        connectionRetainMode.setAliases(aliases);\r\n-        connectionRetainMode.setDefault(aliases[0]);\r\n-        connectionRetainMode.setAliasListComprehensive(true);\r\n-        connectionRetainMode.set(ConnectionRetainModes.CONN_RETAIN_DEMAND);\r\n-        filterListenerPlugins =\r\n-            addPluginList(\"org.apache.openjpa.FilterListeners\");\r\n-        filterListenerPlugins.setInstantiatingGetter\r\n-            (\"getFilterListenerInstances\");\r\n-\r\n-        aggregateListenerPlugins =\r\n-            addPluginList(\"org.apache.openjpa.AggregateListeners\");\r\n-        aggregateListenerPlugins.setInstantiatingGetter\r\n-            (\"getAggregateListenerInstances\");\r\n-\r\n-        retryClassRegistration =\r\n-            addBoolean(\"org.apache.openjpa.RetryClassRegistration\");\r\n-        compatibilityPlugin =\r\n-            addPlugin(\"org.apache.openjpa.Compatibility\", true);\r\n-        aliases = new String[]{ \"default\", Compatibility.class.getName() };\r\n-        compatibilityPlugin.setAliases(aliases);\r\n-        compatibilityPlugin.setDefault(aliases[0]);\r\n-        compatibilityPlugin.setString(aliases[0]);\r\n-        compatibilityPlugin.setInstantiatingGetter(\"getCompatibilityInstance\");\r\n-        // initialize supported options that some runtimes may not support\r\n-        supportedOptions.add(OPTION_NONTRANS_READ);\r\n-        supportedOptions.add(OPTION_OPTIMISTIC);\r\n-        supportedOptions.add(OPTION_ID_APPLICATION);\r\n-        supportedOptions.add(OPTION_ID_DATASTORE);\r\n-        supportedOptions.add(OPTION_TYPE_COLLECTION);\r\n-        supportedOptions.add(OPTION_TYPE_MAP);\r\n-        supportedOptions.add(OPTION_TYPE_ARRAY);\r\n-        supportedOptions.add(OPTION_NULL_CONTAINER);\r\n-        supportedOptions.add(OPTION_EMBEDDED_RELATION);\r\n-        supportedOptions.add(OPTION_EMBEDDED_COLLECTION_RELATION);\r\n-        supportedOptions.add(OPTION_EMBEDDED_MAP_RELATION);\r\n-        supportedOptions.add(OPTION_INC_FLUSH);\r\n-        supportedOptions.add(OPTION_VALUE_AUTOASSIGN);\r\n-        supportedOptions.add(OPTION_VALUE_INCREMENT);\r\n-        supportedOptions.add(OPTION_DATASTORE_CONNECTION);\r\n-        if (derivations)\r\n-            ProductDerivations.beforeConfigurationLoad(this);\r\n-        if (loadDefaults)\r\n-            loadDefaults();\r\n-    }\r\n-\r\n-    public String getProductName() {\r\n-        return \"openjpa\";\r\n-    }\r\n-\r\n-    public Collection supportedOptions() {\r\n-        return supportedOptions;\r\n-    }\r\n-\r\n-    public String getSpecification() {\r\n-        return spec;\r\n-    }\r\n-\r\n-    public boolean setSpecification(String spec) {\r\n-        if (spec == null)\r\n-            return false;\r\n-        if (this.spec != null) {\r\n-            if (!this.spec.equals(spec)\r\n-                && getConfigurationLog().isWarnEnabled())\r\n-                getConfigurationLog().warn(_loc.get(\"diff-specs\", this.spec,\r\n-                    spec));\r\n-            return false;\r\n-        }\r\n-        this.spec = spec;\r\n-        ProductDerivations.afterSpecificationSet(this);\r\n-        return true;\r\n-    }\r\n-\r\n-    public void setClassResolver(String classResolver) {\r\n-        assertNotReadOnly();\r\n-        classResolverPlugin.setString(classResolver);\r\n-    }\r\n-\r\n-    public String getClassResolver() {\r\n-        return classResolverPlugin.getString();\r\n-    }\r\n-\r\n-    public void setClassResolver(ClassResolver classResolver) {\r\n-        assertNotReadOnly();\r\n-        classResolverPlugin.set(classResolver);\r\n-    }\r\n-\r\n-    public ClassResolver getClassResolverInstance() {\r\n-        if (classResolverPlugin.get() == null)\r\n-            classResolverPlugin.instantiate(ClassResolver.class, this);\r\n-        return (ClassResolver) classResolverPlugin.get();\r\n-    }\r\n-\r\n-    public void setBrokerFactory(String factory) {\r\n-        assertNotReadOnly();\r\n-        brokerFactoryPlugin.setString(factory);\r\n-    }\r\n-\r\n-    public String getBrokerFactory() {\r\n-        return brokerFactoryPlugin.getString();\r\n-    }\r\n-\r\n-    public void setBrokerImpl(String broker) {\r\n-        assertNotReadOnly();\r\n-        brokerPlugin.setString(broker);\r\n-    }\r\n-\r\n-    public String getBrokerImpl() {\r\n-        return brokerPlugin.getString();\r\n-    }\r\n-\r\n-    public BrokerImpl newBrokerInstance(String user, String pass) {\r\n-        BrokerImpl broker = (BrokerImpl) brokerPlugin.instantiate\r\n-            (BrokerImpl.class, this);\r\n-        if (broker != null)\r\n-            broker.setAuthentication(user, pass);\r\n-        return broker;\r\n-    }\r\n-\r\n-    public void setDataCacheManager(String mgr) {\r\n-        assertNotReadOnly();\r\n-        dataCacheManagerPlugin.setString(mgr);\r\n-    }\r\n-\r\n-    public String getDataCacheManager() {\r\n-        return dataCacheManagerPlugin.getString();\r\n-    }\r\n-\r\n-    public void setDataCacheManager(DataCacheManager dcm) {\r\n-        assertNotReadOnly();\r\n-        if (dcm != null)\r\n-            dcm.initialize(this, dataCachePlugin, queryCachePlugin);\r\n-        dataCacheManagerPlugin.set(dcm);\r\n-    }\r\n-\r\n-    public DataCacheManager getDataCacheManagerInstance() {\r\n-        DataCacheManager dcm = (DataCacheManager) dataCacheManagerPlugin.get();\r\n-        if (dcm == null) {\r\n-            dcm = (DataCacheManager) dataCacheManagerPlugin.instantiate\r\n-                (DataCacheManager.class, this);\r\n-            dcm.initialize(this, dataCachePlugin, queryCachePlugin);\r\n-        }\r\n-        return dcm;\r\n-    }\r\n-\r\n-    public void setDataCache(String dataCache) {\r\n-        assertNotReadOnly();\r\n-        dataCachePlugin.setString(dataCache);\r\n-    }\r\n-\r\n-    public String getDataCache() {\r\n-        return dataCachePlugin.getString();\r\n-    }\r\n-\r\n-    public void setDataCacheTimeout(int dataCacheTimeout) {\r\n-        assertNotReadOnly();\r\n-        this.dataCacheTimeout.set(dataCacheTimeout);\r\n-    }\r\n-\r\n-    public void setDataCacheTimeout(Integer dataCacheTimeout) {\r\n-        if (dataCacheTimeout != null)\r\n-            setDataCacheTimeout(dataCacheTimeout.intValue());\r\n-    }\r\n-\r\n-    public int getDataCacheTimeout() {\r\n-        return dataCacheTimeout.get();\r\n-    }\r\n-\r\n-    public void setQueryCache(String queryCache) {\r\n-        assertNotReadOnly();\r\n-        queryCachePlugin.setString(queryCache);\r\n-    }\r\n-\r\n-    public String getQueryCache() {\r\n-        return queryCachePlugin.getString();\r\n-    }\r\n-\r\n-    public boolean getDynamicDataStructs() {\r\n-        return dynamicDataStructs.get();\r\n-    }\r\n-\r\n-    public void setDynamicDataStructs(boolean dynamic) {\r\n-        dynamicDataStructs.set(dynamic);\r\n-    }\r\n-\r\n-    public void setDynamicDataStructs(Boolean dynamic) {\r\n-        setDynamicDataStructs(dynamic.booleanValue());\r\n-    }\r\n-\r\n-    public void setLockManager(String lockManager) {\r\n-        assertNotReadOnly();\r\n-        lockManagerPlugin.setString(lockManager);\r\n-    }\r\n-\r\n-    public String getLockManager() {\r\n-        return lockManagerPlugin.getString();\r\n-    }\r\n-\r\n-    public LockManager newLockManagerInstance() {\r\n-        // don't validate plugin properties on instantiation because it\r\n-        // is likely that back ends will override defaults with their\r\n-        // own subclasses with new properties\r\n-        return (LockManager) lockManagerPlugin.instantiate(LockManager.class,\r\n-            this, false);\r\n-    }\r\n-\r\n-    public void setInverseManager(String inverseManager) {\r\n-        assertNotReadOnly();\r\n-        inverseManagerPlugin.setString(inverseManager);\r\n-    }\r\n-\r\n-    public String getInverseManager() {\r\n-        return inverseManagerPlugin.getString();\r\n-    }\r\n-\r\n-    public InverseManager newInverseManagerInstance() {\r\n-        return (InverseManager) inverseManagerPlugin.instantiate\r\n-            (InverseManager.class, this);\r\n-    }\r\n-\r\n-    public void setSavepointManager(String savepointManager) {\r\n-        assertNotReadOnly();\r\n-        savepointManagerPlugin.setString(savepointManager);\r\n-    }\r\n-\r\n-    public String getSavepointManager() {\r\n-        return savepointManagerPlugin.getString();\r\n-    }\r\n-\r\n-    public SavepointManager getSavepointManagerInstance() {\r\n-        if (savepointManagerPlugin.get() == null)\r\n-            savepointManagerPlugin.instantiate(SavepointManager.class, this);\r\n-        return (SavepointManager) savepointManagerPlugin.get();\r\n-    }\r\n-\r\n-    public void setOrphanedKeyAction(String action) {\r\n-        assertNotReadOnly();\r\n-        orphanedKeyPlugin.setString(action);\r\n-    }\r\n-\r\n-    public String getOrphanedKeyAction() {\r\n-        return orphanedKeyPlugin.getString();\r\n-    }\r\n-\r\n-    public OrphanedKeyAction getOrphanedKeyActionInstance() {\r\n-        if (orphanedKeyPlugin.get() == null)\r\n-            orphanedKeyPlugin.instantiate(OrphanedKeyAction.class, this);\r\n-        return (OrphanedKeyAction) orphanedKeyPlugin.get();\r\n-    }\r\n-\r\n-    public void setOrphanedKeyAction(OrphanedKeyAction action) {\r\n-        assertNotReadOnly();\r\n-        orphanedKeyPlugin.set(action);\r\n-    }\r\n-\r\n-    public void setRemoteCommitProvider(String remoteCommitProvider) {\r\n-        assertNotReadOnly();\r\n-        remoteProviderPlugin.setString(remoteCommitProvider);\r\n-    }\r\n-\r\n-    public String getRemoteCommitProvider() {\r\n-        return remoteProviderPlugin.getString();\r\n-    }\r\n-\r\n-    public RemoteCommitProvider newRemoteCommitProviderInstance() {\r\n-        return remoteProviderPlugin.instantiateProvider(this);\r\n-    }\r\n-\r\n-    public void setRemoteCommitEventManager\r\n-        (RemoteCommitEventManager remoteEventManager) {\r\n-        assertNotReadOnly();\r\n-        this.remoteEventManager = remoteEventManager;\r\n-        remoteProviderPlugin.configureEventManager(remoteEventManager);\r\n-    }\r\n-\r\n-    public RemoteCommitEventManager getRemoteCommitEventManager() {\r\n-        if (remoteEventManager == null) {\r\n-            remoteEventManager = new RemoteCommitEventManager(this);\r\n-            remoteProviderPlugin.configureEventManager(remoteEventManager);\r\n-        }\r\n-        return remoteEventManager;\r\n-    }\r\n-\r\n-    public void setTransactionMode(String transactionMode) {\r\n-        assertNotReadOnly();\r\n-        this.transactionMode.setString(transactionMode);\r\n-    }\r\n-\r\n-    public String getTransactionMode() {\r\n-        return transactionMode.getString();\r\n-    }\r\n-\r\n-    public void setTransactionModeManaged(boolean managed) {\r\n-        assertNotReadOnly();\r\n-        transactionMode.set(managed);\r\n-    }\r\n-\r\n-    public boolean isTransactionModeManaged() {\r\n-        return transactionMode.get();\r\n-    }\r\n-\r\n-    public void setManagedRuntime(String managedRuntime) {\r\n-        assertNotReadOnly();\r\n-        managedRuntimePlugin.setString(managedRuntime);\r\n-    }\r\n-\r\n-    public String getManagedRuntime() {\r\n-        return managedRuntimePlugin.getString();\r\n-    }\r\n-\r\n-    public void setManagedRuntime(ManagedRuntime managedRuntime) {\r\n-        assertNotReadOnly();\r\n-        managedRuntimePlugin.set(managedRuntime);\r\n-    }\r\n-\r\n-    public ManagedRuntime getManagedRuntimeInstance() {\r\n-        if (managedRuntimePlugin.get() == null)\r\n-            managedRuntimePlugin.instantiate(ManagedRuntime.class, this);\r\n-        return (ManagedRuntime) managedRuntimePlugin.get();\r\n-    }\r\n-\r\n-    public void setProxyManager(String proxyManager) {\r\n-        assertNotReadOnly();\r\n-        proxyManagerPlugin.setString(proxyManager);\r\n-    }\r\n-\r\n-    public String getProxyManager() {\r\n-        return proxyManagerPlugin.getString();\r\n-    }\r\n-\r\n-    public void setProxyManager(ProxyManager proxyManager) {\r\n-        assertNotReadOnly();\r\n-        proxyManagerPlugin.set(proxyManager);\r\n-    }\r\n-\r\n-    public ProxyManager getProxyManagerInstance() {\r\n-        if (proxyManagerPlugin.get() == null)\r\n-            proxyManagerPlugin.instantiate(ProxyManager.class, this);\r\n-        return (ProxyManager) proxyManagerPlugin.get();\r\n-    }\r\n-\r\n-    public void setMapping(String mapping) {\r\n-        assertNotReadOnly();\r\n-        this.mapping.setString(mapping);\r\n-    }\r\n-\r\n-    public String getMapping() {\r\n-        return mapping.getString();\r\n-    }\r\n-\r\n-    public void setMetaDataFactory(String meta) {\r\n-        assertNotReadOnly();\r\n-        this.metaFactoryPlugin.setString(meta);\r\n-    }\r\n-\r\n-    public String getMetaDataFactory() {\r\n-        return metaFactoryPlugin.getString();\r\n-    }\r\n-\r\n-    public MetaDataFactory newMetaDataFactoryInstance() {\r\n-        return (MetaDataFactory) metaFactoryPlugin.instantiate\r\n-            (MetaDataFactory.class, this);\r\n-    }\r\n-\r\n-    public void setMetaDataRepository(MetaDataRepository meta) {\r\n-        assertNotReadOnly();\r\n-        metaRepos = meta;\r\n-    }\r\n-\r\n-    public MetaDataRepository getMetaDataRepository() {\r\n-        if (metaRepos == null)\r\n-            metaRepos = new MetaDataRepository(this);\r\n-        return metaRepos;\r\n-    }\r\n-\r\n-    public void setConnectionUserName(String connectionUserName) {\r\n-        assertNotReadOnly();\r\n-        this.connectionUserName.setString(connectionUserName);\r\n-    }\r\n-\r\n-    public String getConnectionUserName() {\r\n-        return connectionUserName.getString();\r\n-    }\r\n-\r\n-    public void setConnectionPassword(String connectionPassword) {\r\n-        assertNotReadOnly();\r\n-        this.connectionPassword.setString(connectionPassword);\r\n-    }\r\n-\r\n-    public String getConnectionPassword() {\r\n-        return connectionPassword.getString();\r\n-    }\r\n-\r\n-    public void setConnectionURL(String connectionURL) {\r\n-        assertNotReadOnly();\r\n-        this.connectionURL.setString(connectionURL);\r\n-    }\r\n-\r\n-    public String getConnectionURL() {\r\n-        return connectionURL.getString();\r\n-    }\r\n-\r\n-    public void setConnectionDriverName(String driverName) {\r\n-        assertNotReadOnly();\r\n-        this.connectionDriverName.setString(driverName);\r\n-    }\r\n-\r\n-    public String getConnectionDriverName() {\r\n-        return connectionDriverName.getString();\r\n-    }\r\n-\r\n-    public void setConnectionProperties(String connectionProperties) {\r\n-        assertNotReadOnly();\r\n-        this.connectionProperties.setString(connectionProperties);\r\n-    }\r\n-\r\n-    public String getConnectionProperties() {\r\n-        return connectionProperties.getString();\r\n-    }\r\n-\r\n-    public void setConnectionFactoryProperties\r\n-        (String connectionFactoryProperties) {\r\n-        assertNotReadOnly();\r\n-        this.connectionFactoryProperties.setString(connectionFactoryProperties);\r\n-    }\r\n-\r\n-    public String getConnectionFactoryProperties() {\r\n-        return connectionFactoryProperties.getString();\r\n-    }\r\n-\r\n-    public String getConnectionFactoryMode() {\r\n-        return connectionFactoryMode.getString();\r\n-    }\r\n-\r\n-    public void setConnectionFactoryMode(String mode) {\r\n-        assertNotReadOnly();\r\n-        connectionFactoryMode.setString(mode);\r\n-    }\r\n-\r\n-    public boolean isConnectionFactoryModeManaged() {\r\n-        return connectionFactoryMode.get();\r\n-    }\r\n-\r\n-    public void setConnectionFactoryModeManaged(boolean managed) {\r\n-        assertNotReadOnly();\r\n-        connectionFactoryMode.set(managed);\r\n-    }\r\n-\r\n-    public void setConnectionFactoryName(String connectionFactoryName) {\r\n-        assertNotReadOnly();\r\n-        this.connectionFactoryName.setString(connectionFactoryName);\r\n-    }\r\n-\r\n-    public String getConnectionFactoryName() {\r\n-        return connectionFactoryName.getString();\r\n-    }\r\n-\r\n-    public void setConnectionFactory(Object factory) {\r\n-        assertNotReadOnly();\r\n-        connectionFactory.set(factory);\r\n-    }\r\n-\r\n-    public Object getConnectionFactory() {\r\n-        if (connectionFactory.get() == null)\r\n-            connectionFactory.set(lookupConnectionFactory\r\n-                (getConnectionFactoryName()), true);\r\n-        return connectionFactory.get();\r\n-    }\r\n-\r\n-    /**\r\n-     * Lookup the connection factory at the given name.\r\n-     */\r\n-    private Object lookupConnectionFactory(String name) {\r\n-        if (name == null || name.trim().length() == 0)\r\n-            return null;\r\n-        return Configurations.lookup(name);\r\n-    }\r\n-\r\n-    public void setConnection2UserName(String connection2UserName) {\r\n-        assertNotReadOnly();\r\n-        this.connection2UserName.setString(connection2UserName);\r\n-    }\r\n-\r\n-    public String getConnection2UserName() {\r\n-        return connection2UserName.getString();\r\n-    }\r\n-\r\n-    public void setConnection2Password(String connection2Password) {\r\n-        assertNotReadOnly();\r\n-        this.connection2Password.setString(connection2Password);\r\n-    }\r\n-\r\n-    public String getConnection2Password() {\r\n-        return connection2Password.getString();\r\n-    }\r\n-\r\n-    public void setConnection2URL(String connection2URL) {\r\n-        assertNotReadOnly();\r\n-        this.connection2URL.setString(connection2URL);\r\n-    }\r\n-\r\n-    public String getConnection2URL() {\r\n-        return connection2URL.getString();\r\n-    }\r\n-\r\n-    public void setConnection2DriverName(String driverName) {\r\n-        assertNotReadOnly();\r\n-        this.connection2DriverName.setString(driverName);\r\n-    }\r\n-\r\n-    public String getConnection2DriverName() {\r\n-        return connection2DriverName.getString();\r\n-    }\r\n-\r\n-    public void setConnection2Properties(String connection2Properties) {\r\n-        assertNotReadOnly();\r\n-        this.connection2Properties.setString(connection2Properties);\r\n-    }\r\n-\r\n-    public String getConnection2Properties() {\r\n-        return connection2Properties.getString();\r\n-    }\r\n-\r\n-    public void setConnectionFactory2Properties\r\n-        (String connectionFactory2Properties) {\r\n-        assertNotReadOnly();\r\n-        this.connectionFactory2Properties.setString\r\n-            (connectionFactory2Properties);\r\n-    }\r\n-\r\n-    public String getConnectionFactory2Properties() {\r\n-        return connectionFactory2Properties.getString();\r\n-    }\r\n-\r\n-    public void setConnectionFactory2Name(String connectionFactory2Name) {\r\n-        assertNotReadOnly();\r\n-        this.connectionFactory2Name.setString(connectionFactory2Name);\r\n-    }\r\n-\r\n-    public String getConnectionFactory2Name() {\r\n-        return connectionFactory2Name.getString();\r\n-    }\r\n-\r\n-    public void setConnectionFactory2(Object factory) {\r\n-        assertNotReadOnly();\r\n-        connectionFactory2.set(factory);\r\n-    }\r\n-\r\n-    public Object getConnectionFactory2() {\r\n-        if (connectionFactory2.get() == null)\r\n-            connectionFactory2.set(lookupConnectionFactory\r\n-                (getConnectionFactory2Name()), false);\r\n-        return connectionFactory2.get();\r\n-    }\r\n-\r\n-    public void setOptimistic(boolean optimistic) {\r\n-        assertNotReadOnly();\r\n-        this.optimistic.set(optimistic);\r\n-    }\r\n-\r\n-    public void setOptimistic(Boolean optimistic) {\r\n-        if (optimistic != null)\r\n-            setOptimistic(optimistic.booleanValue());\r\n-    }\r\n-\r\n-    public boolean getOptimistic() {\r\n-        return optimistic.get();\r\n-    }\r\n-\r\n-    public void setAutoClear(String clear) {\r\n-        assertNotReadOnly();\r\n-        autoClear.setString(clear);\r\n-    }\r\n-\r\n-    public String getAutoClear() {\r\n-        return autoClear.getString();\r\n-    }\r\n-\r\n-    public void setAutoClear(int clear) {\r\n-        assertNotReadOnly();\r\n-        autoClear.set(clear);\r\n-    }\r\n-\r\n-    public int getAutoClearConstant() {\r\n-        return autoClear.get();\r\n-    }\r\n-\r\n-    public void setRetainState(boolean retainState) {\r\n-        assertNotReadOnly();\r\n-        this.retainState.set(retainState);\r\n-    }\r\n-\r\n-    public void setRetainState(Boolean retainState) {\r\n-        if (retainState != null)\r\n-            setRetainState(retainState.booleanValue());\r\n-    }\r\n-\r\n-    public boolean getRetainState() {\r\n-        return retainState.get();\r\n-    }\r\n-\r\n-    public void setRestoreState(String restoreState) {\r\n-        assertNotReadOnly();\r\n-        this.restoreState.setString(restoreState);\r\n-    }\r\n-\r\n-    public String getRestoreState() {\r\n-        return restoreState.getString();\r\n-    }\r\n-\r\n-    public void setRestoreState(int restoreState) {\r\n-        assertNotReadOnly();\r\n-        this.restoreState.set(restoreState);\r\n-    }\r\n-\r\n-    public int getRestoreStateConstant() {\r\n-        return restoreState.get();\r\n-    }\r\n-\r\n-    public void setAutoDetach(String autoDetach) {\r\n-        assertNotReadOnly();\r\n-        this.autoDetach.setString(autoDetach);\r\n-    }\r\n-\r\n-    public String getAutoDetach() {\r\n-        return autoDetach.getString();\r\n-    }\r\n-\r\n-    public void setAutoDetach(int autoDetachFlags) {\r\n-        autoDetach.set(autoDetachFlags);\r\n-    }\r\n-\r\n-    public int getAutoDetachConstant() {\r\n-        return autoDetach.get();\r\n-    }\r\n-\r\n-    public void setDetachState(String detachState) {\r\n-        assertNotReadOnly();\r\n-        detachStatePlugin.setString(detachState);\r\n-    }\r\n-\r\n-    public String getDetachState() {\r\n-        return detachStatePlugin.getString();\r\n-    }\r\n-\r\n-    public void setDetachState(DetachOptions detachState) {\r\n-        assertNotReadOnly();\r\n-        detachStatePlugin.set(detachState);\r\n-    }\r\n-\r\n-    public DetachOptions getDetachStateInstance() {\r\n-        if (detachStatePlugin.get() == null)\r\n-            detachStatePlugin.instantiate(DetachOptions.class, this);\r\n-        return (DetachOptions) detachStatePlugin.get();\r\n-    }\r\n-\r\n-    public void setIgnoreChanges(boolean ignoreChanges) {\r\n-        assertNotReadOnly();\r\n-        this.ignoreChanges.set(ignoreChanges);\r\n-    }\r\n-\r\n-    public void setIgnoreChanges(Boolean ignoreChanges) {\r\n-        if (ignoreChanges != null)\r\n-            setIgnoreChanges(ignoreChanges.booleanValue());\r\n-    }\r\n-\r\n-    public boolean getIgnoreChanges() {\r\n-        return ignoreChanges.get();\r\n-    }\r\n-\r\n-    public void setNontransactionalRead(boolean nontransactionalRead) {\r\n-        assertNotReadOnly();\r\n-        this.nontransactionalRead.set(nontransactionalRead);\r\n-    }\r\n-\r\n-    public void setNontransactionalRead(Boolean nontransactionalRead) {\r\n-        if (nontransactionalRead != null)\r\n-            setNontransactionalRead(nontransactionalRead.booleanValue());\r\n-    }\r\n-\r\n-    public boolean getNontransactionalRead() {\r\n-        return nontransactionalRead.get();\r\n-    }\r\n-\r\n-    public void setNontransactionalWrite(boolean nontransactionalWrite) {\r\n-        assertNotReadOnly();\r\n-        this.nontransactionalWrite.set(nontransactionalWrite);\r\n-    }\r\n-\r\n-    public void setNontransactionalWrite(Boolean nontransactionalWrite) {\r\n-        if (nontransactionalWrite != null)\r\n-            setNontransactionalWrite(nontransactionalWrite.booleanValue());\r\n-    }\r\n-\r\n-    public boolean getNontransactionalWrite() {\r\n-        return nontransactionalWrite.get();\r\n-    }\r\n-\r\n-    public void setMultithreaded(boolean multithreaded) {\r\n-        assertNotReadOnly();\r\n-        this.multithreaded.set(multithreaded);\r\n-    }\r\n-\r\n-    public void setMultithreaded(Boolean multithreaded) {\r\n-        if (multithreaded != null)\r\n-            setMultithreaded(multithreaded.booleanValue());\r\n-    }\r\n-\r\n-    public boolean getMultithreaded() {\r\n-        return multithreaded.get();\r\n-    }\r\n-\r\n-    public void setFetchBatchSize(int fetchBatchSize) {\r\n-        assertNotReadOnly();\r\n-        this.fetchBatchSize.set(fetchBatchSize);\r\n-    }\r\n-\r\n-    public void setFetchBatchSize(Integer fetchBatchSize) {\r\n-        if (fetchBatchSize != null)\r\n-            setFetchBatchSize(fetchBatchSize.intValue());\r\n-    }\r\n-\r\n-    public int getFetchBatchSize() {\r\n-        return fetchBatchSize.get();\r\n-    }\r\n-\r\n-    public void setFetchGroups(String fetchGroups) {\r\n-        assertNotReadOnly();\r\n-        this.fetchGroups.setString(fetchGroups);\r\n-    }\r\n-\r\n-    public String getFetchGroups() {\r\n-        return fetchGroups.getString();\r\n-    }\r\n-\r\n-    public String[] getFetchGroupsList() {\r\n-        return fetchGroups.get();\r\n-    }\r\n-\r\n-    public void setFetchGroups(String[] fetchGroups) {\r\n-        this.fetchGroups.set(fetchGroups);\r\n-    }\r\n-\r\n-    public void setFlushBeforeQueries(String flush) {\r\n-        assertNotReadOnly();\r\n-        flushBeforeQueries.setString(flush);\r\n-    }\r\n-\r\n-    public String getFlushBeforeQueries() {\r\n-        return flushBeforeQueries.getString();\r\n-    }\r\n-\r\n-    public void setFlushBeforeQueries(int flush) {\r\n-        assertNotReadOnly();\r\n-        flushBeforeQueries.set(flush);\r\n-    }\r\n-\r\n-    public int getFlushBeforeQueriesConstant() {\r\n-        return flushBeforeQueries.get();\r\n-    }\r\n-\r\n-    public void setLockTimeout(int timeout) {\r\n-        assertNotReadOnly();\r\n-        lockTimeout.set(timeout);\r\n-    }\r\n-\r\n-    public void setLockTimeout(Integer timeout) {\r\n-        if (timeout != null)\r\n-            setLockTimeout(timeout.intValue());\r\n-    }\r\n-\r\n-    public int getLockTimeout() {\r\n-        return lockTimeout.get();\r\n-    }\r\n-\r\n-    public void setReadLockLevel(String level) {\r\n-        assertNotReadOnly();\r\n-        readLockLevel.setString(level);\r\n-    }\r\n-\r\n-    public String getReadLockLevel() {\r\n-        return readLockLevel.getString();\r\n-    }\r\n-\r\n-    public void setReadLockLevel(int level) {\r\n-        assertNotReadOnly();\r\n-        readLockLevel.set(level);\r\n-    }\r\n-\r\n-    public int getReadLockLevelConstant() {\r\n-        return readLockLevel.get();\r\n-    }\r\n-\r\n-    public void setWriteLockLevel(String level) {\r\n-        assertNotReadOnly();\r\n-        writeLockLevel.setString(level);\r\n-    }\r\n-\r\n-    public String getWriteLockLevel() {\r\n-        return writeLockLevel.getString();\r\n-    }\r\n-\r\n-    public void setWriteLockLevel(int level) {\r\n-        assertNotReadOnly();\r\n-        writeLockLevel.set(level);\r\n-    }\r\n-\r\n-    public int getWriteLockLevelConstant() {\r\n-        return writeLockLevel.get();\r\n-    }\r\n-\r\n-    public void setSequence(String sequence) {\r\n-        assertNotReadOnly();\r\n-        seqPlugin.setString(sequence);\r\n-    }\r\n-\r\n-    public String getSequence() {\r\n-        return seqPlugin.getString();\r\n-    }\r\n-\r\n-    public void setSequence(Seq seq) {\r\n-        assertNotReadOnly();\r\n-        seqPlugin.set(seq);\r\n-    }\r\n-\r\n-    public Seq getSequenceInstance() {\r\n-        if (seqPlugin.get() == null)\r\n-            seqPlugin.instantiate(Seq.class, this);\r\n-        return (Seq) seqPlugin.get();\r\n-    }\r\n-\r\n-    public void setConnectionRetainMode(String connectionRetainMode) {\r\n-        assertNotReadOnly();\r\n-        this.connectionRetainMode.setString(connectionRetainMode);\r\n-    }\r\n-\r\n-    public String getConnectionRetainMode() {\r\n-        return connectionRetainMode.getString();\r\n-    }\r\n-\r\n-    public void setConnectionRetainMode(int connectionRetainMode) {\r\n-        assertNotReadOnly();\r\n-        this.connectionRetainMode.set(connectionRetainMode);\r\n-    }\r\n-\r\n-    public int getConnectionRetainModeConstant() {\r\n-        return connectionRetainMode.get();\r\n-    }\r\n-\r\n-    public void setFilterListeners(String filterListeners) {\r\n-        assertNotReadOnly();\r\n-        filterListenerPlugins.setString(filterListeners);\r\n-    }\r\n-\r\n-    public String getFilterListeners() {\r\n-        return filterListenerPlugins.getString();\r\n-    }\r\n-\r\n-    public void setFilterListeners(FilterListener[] listeners) {\r\n-        assertNotReadOnly();\r\n-        filterListenerPlugins.set(listeners);\r\n-    }\r\n-\r\n-    public FilterListener[] getFilterListenerInstances() {\r\n-        if (filterListenerPlugins.get() == null)\r\n-            filterListenerPlugins.instantiate(FilterListener.class, this);\r\n-        return (FilterListener[]) filterListenerPlugins.get();\r\n-    }\r\n-\r\n-    public void setAggregateListeners(String aggregateListeners) {\r\n-        assertNotReadOnly();\r\n-        aggregateListenerPlugins.setString(aggregateListeners);\r\n-    }\r\n-\r\n-    public String getAggregateListeners() {\r\n-        return aggregateListenerPlugins.getString();\r\n-    }\r\n-\r\n-    public void setAggregateListeners(AggregateListener[] listeners) {\r\n-        assertNotReadOnly();\r\n-        aggregateListenerPlugins.set(listeners);\r\n-    }\r\n-\r\n-    public AggregateListener[] getAggregateListenerInstances() {\r\n-        if (aggregateListenerPlugins.get() == null)\r\n-            aggregateListenerPlugins.instantiate(AggregateListener.class, this);\r\n-        return (AggregateListener[]) aggregateListenerPlugins.get();\r\n-    }\r\n-\r\n-    public void setRetryClassRegistration(boolean retry) {\r\n-        assertNotReadOnly();\r\n-        retryClassRegistration.set(retry);\r\n-    }\r\n-\r\n-    public void setRetryClassRegistration(Boolean retry) {\r\n-        if (retry != null)\r\n-            setRetryClassRegistration(retry.booleanValue());\r\n-    }\r\n-\r\n-    public boolean getRetryClassRegistration() {\r\n-        return retryClassRegistration.get();\r\n-    }\r\n-\r\n-    public String getCompatibility() {\r\n-        return compatibilityPlugin.getString();\r\n-    }\r\n-\r\n-    public void setCompatibility(String compatibility) {\r\n-        compatibilityPlugin.setString(compatibility);\r\n-    }\r\n-\r\n-    public Compatibility getCompatibilityInstance() {\r\n-        if (compatibilityPlugin.get() == null)\r\n-            compatibilityPlugin.instantiate(Compatibility.class, this);\r\n-        return (Compatibility) compatibilityPlugin.get();\r\n-    }\r\n-\r\n-    public void instantiateAll() {\r\n-        super.instantiateAll();\r\n-        // instantiate singletons without values\r\n-        getRemoteCommitEventManager();\r\n-        getMetaDataRepository();\r\n-    }\r\n-\r\n-    public void close() {\r\n-        ImplHelper.close(remoteEventManager);\r\n-        ImplHelper.close(metaRepos);\r\n-        super.close();\r\n-        ProductDerivations.afterClose(this);\r\n-    }\r\n-\r\n-    protected boolean isInvalidProperty(String propName) {\r\n-        // handle warnings for org.apache.openjpa.SomeString, but not for\r\n-        // org.apache.openjpa.some.subpackage.SomeString, since it might be valid for some\r\n-        // specific implementation of OpenJPA\r\n-        return propName.toLowerCase().startsWith(\"org.apache.openjpa.\")\r\n-            && propName.length() > 5 && propName.indexOf('.', 5) == -1;\r\n-    }\r\n-\r\n-    public Log getConfigurationLog() {\r\n-        return getLog(LOG_RUNTIME);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.apache.openjpa.datacache.ConcurrentDataCache;\n+import org.apache.openjpa.datacache.ConcurrentQueryCache;\n+import org.apache.openjpa.datacache.DataCacheManager;\n+import org.apache.openjpa.datacache.DataCacheManagerImpl;\n+import org.apache.openjpa.ee.ManagedRuntime;\n+import org.apache.openjpa.event.OrphanedKeyAction;\n+import org.apache.openjpa.event.RemoteCommitEventManager;\n+import org.apache.openjpa.event.RemoteCommitProvider;\n+import org.apache.openjpa.kernel.AutoClear;\n+import org.apache.openjpa.kernel.BrokerImpl;\n+import org.apache.openjpa.kernel.ConnectionRetainModes;\n+import org.apache.openjpa.kernel.InverseManager;\n+import org.apache.openjpa.kernel.LockLevels;\n+import org.apache.openjpa.kernel.LockManager;\n+import org.apache.openjpa.kernel.QueryFlushModes;\n+import org.apache.openjpa.kernel.RestoreState;\n+import org.apache.openjpa.kernel.SavepointManager;\n+import org.apache.openjpa.kernel.Seq;\n+import org.apache.openjpa.kernel.exps.AggregateListener;\n+import org.apache.openjpa.kernel.exps.FilterListener;\n+import org.apache.openjpa.lib.conf.BooleanValue;\n+import org.apache.openjpa.lib.conf.ConfigurationImpl;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.conf.IntValue;\n+import org.apache.openjpa.lib.conf.ObjectValue;\n+import org.apache.openjpa.lib.conf.PluginListValue;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.lib.conf.StringListValue;\n+import org.apache.openjpa.lib.conf.StringValue;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.MetaDataFactory;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.util.ClassResolver;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.util.ProxyManager;\n+\n+/**\n+ * <p>Implementation of the {@link OpenJPAConfiguration} interface.</p>\n+ * <p/>\n+ * <p>On construction, the class will attempt to locate a default properties\n+ * file called <code>org.apache.openjpa.properties</code> located at any top level token\n+ * of the CLASSPATH.  See the {@link ConfigurationImpl} class description\n+ * for details.</p>\n+ *\n+ * @see    ConfigurationImpl\n+ * @author Marc Prud'hommeaux\n+ * @author Abe White\n+ */\n+public class OpenJPAConfigurationImpl\n+    extends ConfigurationImpl\n+    implements OpenJPAConfiguration {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (OpenJPAConfigurationImpl.class);\n+\n+    // cached state; some of this is created in getter methods, so make\n+    // protected in case subclasses want to access without creating\n+    protected MetaDataRepository metaRepos = null;\n+    protected RemoteCommitEventManager remoteEventManager = null;\n+\n+    // openjpa properties\n+    public ObjectValue classResolverPlugin;\n+    public ObjectValue brokerPlugin;\n+    public ObjectValue dataCachePlugin;\n+    public ObjectValue dataCacheManagerPlugin;\n+    public IntValue dataCacheTimeout;\n+    public ObjectValue queryCachePlugin;\n+    public BooleanValue dynamicDataStructs;\n+    public ObjectValue managedRuntimePlugin;\n+    public BooleanValue transactionMode;\n+    public IntValue connectionRetainMode;\n+    public IntValue fetchBatchSize;\n+    public StringListValue fetchGroups;\n+    public IntValue flushBeforeQueries;\n+    public IntValue lockTimeout;\n+    public IntValue readLockLevel;\n+    public IntValue writeLockLevel;\n+    public ObjectValue seqPlugin;\n+    public PluginListValue filterListenerPlugins;\n+    public PluginListValue aggregateListenerPlugins;\n+    public BooleanValue retryClassRegistration;\n+    public ObjectValue proxyManagerPlugin;\n+    public StringValue connectionUserName;\n+    public StringValue connectionPassword;\n+    public StringValue connectionURL;\n+    public StringValue connectionDriverName;\n+    public ObjectValue connectionFactory;\n+    public StringValue connectionFactoryName;\n+    public StringValue connectionProperties;\n+    public StringValue connectionFactoryProperties;\n+    public BooleanValue connectionFactoryMode;\n+    public StringValue connection2UserName;\n+    public StringValue connection2Password;\n+    public StringValue connection2URL;\n+    public StringValue connection2DriverName;\n+    public StringValue connection2Properties;\n+    public ObjectValue connectionFactory2;\n+    public StringValue connectionFactory2Name;\n+    public StringValue connectionFactory2Properties;\n+    public BooleanValue optimistic;\n+    public IntValue autoClear;\n+    public BooleanValue retainState;\n+    public IntValue restoreState;\n+    public ObjectValue detachStatePlugin;\n+    public BooleanValue ignoreChanges;\n+    public BooleanValue nontransactionalRead;\n+    public BooleanValue nontransactionalWrite;\n+    public BooleanValue multithreaded;\n+    public StringValue mapping;\n+    public PluginValue metaFactoryPlugin;\n+    public ObjectValue lockManagerPlugin;\n+    public ObjectValue inverseManagerPlugin;\n+    public ObjectValue savepointManagerPlugin;\n+    public ObjectValue orphanedKeyPlugin;\n+    public ObjectValue compatibilityPlugin;\n+\n+    // custom values\n+    public BrokerFactoryValue brokerFactoryPlugin;\n+    public RemoteCommitProviderValue remoteProviderPlugin;\n+    public AutoDetachValue autoDetach;\n+\n+    private Collection supportedOptions = new HashSet(33);\n+    private String spec = null;\n+\n+    /**\n+     * Default constructor.  Attempts to load default properties.\n+     */\n+    public OpenJPAConfigurationImpl() {\n+        this(true);\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param    loadDefaults    whether to attempt to load the default\n+     * <code>org.apache.openjpa.properties</code> resource\n+     */\n+    public OpenJPAConfigurationImpl(boolean loadDefaults) {\n+        this(true, loadDefaults);\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param    derivations        whether to apply product derivations\n+     * @param    loadDefaults    whether to attempt to load the default\n+     * <code>org.apache.openjpa.properties</code> resource\n+     */\n+    public OpenJPAConfigurationImpl(boolean derivations, boolean loadDefaults) {\n+        super(false);\n+        String[] aliases;\n+\n+        // setup super's log factory plugin\n+        logFactoryPlugin.setProperty(\"org.apache.openjpa.Log\");\n+        logFactoryPlugin\n+            .setAlias(\"openjpa\", \"org.apache.openjpa.lib.log.LogFactoryImpl\");\n+        aliases = logFactoryPlugin.getAliases();\n+        logFactoryPlugin.setDefault(aliases[0]);\n+        logFactoryPlugin.setString(aliases[0]);\n+\n+        classResolverPlugin =\n+            addPlugin(\"org.apache.openjpa.ClassResolver\", true);\n+        aliases = new String[]{\n+            \"default\", \"org.apache.openjpa.util.ClassResolverImpl\",\n+            // deprecated alias\n+            \"spec\", \"org.apache.openjpa.util.ClassResolverImpl\",\n+        };\n+        classResolverPlugin.setAliases(aliases);\n+        classResolverPlugin.setDefault(aliases[0]);\n+        classResolverPlugin.setString(aliases[0]);\n+        classResolverPlugin.setInstantiatingGetter(\"getClassResolverInstance\");\n+\n+        brokerFactoryPlugin = new BrokerFactoryValue();\n+        addValue(brokerFactoryPlugin);\n+\n+        brokerPlugin = addPlugin(\"org.apache.openjpa.BrokerImpl\", false);\n+        aliases = new String[]{ \"default\", BrokerImpl.class.getName() };\n+        brokerPlugin.setAliases(aliases);\n+        brokerPlugin.setDefault(aliases[0]);\n+        brokerPlugin.setString(aliases[0]);\n+\n+        dataCacheManagerPlugin =\n+            addPlugin(\"org.apache.openjpa.DataCacheManager\", true);\n+        aliases = new String[]{\n+            \"default\", DataCacheManagerImpl.class.getName(),\n+        };\n+        dataCacheManagerPlugin.setAliases(aliases);\n+        dataCacheManagerPlugin.setDefault(aliases[0]);\n+        dataCacheManagerPlugin.setString(aliases[0]);\n+        dataCacheManagerPlugin.setInstantiatingGetter(\"getDataCacheManager\");\n+\n+        dataCachePlugin = addPlugin(\"org.apache.openjpa.DataCache\", false);\n+        aliases = new String[]{\n+            \"false\", null,\n+            \"true\", ConcurrentDataCache.class.getName(),\n+            \"concurrent\", ConcurrentDataCache.class.getName(),\n+        };\n+        dataCachePlugin.setAliases(aliases);\n+        dataCachePlugin.setDefault(aliases[0]);\n+        dataCachePlugin.setString(aliases[0]);\n+\n+        dataCacheTimeout = addInt(\"org.apache.openjpa.DataCacheTimeout\");\n+        dataCacheTimeout.setDefault(\"-1\");\n+        dataCacheTimeout.set(-1);\n+\n+        queryCachePlugin = addPlugin(\"org.apache.openjpa.QueryCache\", true);\n+        aliases = new String[]{\n+            \"true\", ConcurrentQueryCache.class.getName(),\n+            \"concurrent\", ConcurrentQueryCache.class.getName(),\n+            \"false\", null,\n+        };\n+        queryCachePlugin.setAliases(aliases);\n+        queryCachePlugin.setDefault(aliases[0]);\n+        queryCachePlugin.setString(aliases[0]);\n+\n+        dynamicDataStructs =\n+            addBoolean(\"org.apache.openjpa.DynamicDataStructs\");\n+        dynamicDataStructs.setDefault(\"false\");\n+        dynamicDataStructs.set(false);\n+\n+        lockManagerPlugin = addPlugin(\"org.apache.openjpa.LockManager\", false);\n+        aliases = new String[]{\n+            \"none\", \"org.apache.openjpa.kernel.NoneLockManager\",\n+            \"version\", \"org.apache.openjpa.kernel.VersionLockManager\",\n+        };\n+        lockManagerPlugin.setAliases(aliases);\n+        lockManagerPlugin.setDefault(aliases[0]);\n+        lockManagerPlugin.setString(aliases[0]);\n+\n+        inverseManagerPlugin =\n+            addPlugin(\"org.apache.openjpa.InverseManager\", false);\n+        aliases = new String[]{\n+            \"false\", null,\n+            \"true\", \"org.apache.openjpa.kernel.InverseManager\",\n+        };\n+        inverseManagerPlugin.setAliases(aliases);\n+        inverseManagerPlugin.setDefault(aliases[0]);\n+        inverseManagerPlugin.setString(aliases[0]);\n+\n+        savepointManagerPlugin =\n+            addPlugin(\"org.apache.openjpa.SavepointManager\", true);\n+        aliases = new String[]{\n+            \"in-mem\", \"org.apache.openjpa.kernel.InMemorySavepointManager\",\n+        };\n+        savepointManagerPlugin.setAliases(aliases);\n+        savepointManagerPlugin.setDefault(aliases[0]);\n+        savepointManagerPlugin.setString(aliases[0]);\n+        savepointManagerPlugin.setInstantiatingGetter\n+            (\"getSavepointManagerInstance\");\n+\n+        orphanedKeyPlugin =\n+            addPlugin(\"org.apache.openjpa.OrphanedKeyAction\", true);\n+        aliases = new String[]{\n+            \"log\", \"org.apache.openjpa.event.LogOrphanedKeyAction\",\n+            \"exception\", \"org.apache.openjpa.event.ExceptionOrphanedKeyAction\",\n+            \"none\", \"org.apache.openjpa.event.NoneOrphanedKeyAction\",\n+        };\n+        orphanedKeyPlugin.setAliases(aliases);\n+        orphanedKeyPlugin.setDefault(aliases[0]);\n+        orphanedKeyPlugin.setString(aliases[0]);\n+        orphanedKeyPlugin.setInstantiatingGetter\n+            (\"getOrphanedKeyActionInstance\");\n+\n+        remoteProviderPlugin = new RemoteCommitProviderValue\n+            (\"org.apache.openjpa.RemoteCommitProvider\");\n+        addValue(remoteProviderPlugin);\n+\n+        transactionMode = addBoolean(\"org.apache.openjpa.TransactionMode\");\n+        aliases = new String[]{\n+            \"local\", \"false\",\n+            \"managed\", \"true\",\n+        };\n+        transactionMode.setAliases(aliases);\n+        transactionMode.setDefault(aliases[0]);\n+\n+        managedRuntimePlugin =\n+            addPlugin(\"org.apache.openjpa.ManagedRuntime\", true);\n+        aliases = new String[]{\n+            \"auto\", \"org.apache.openjpa.ee.AutomaticManagedRuntime\",\n+            \"jndi\", \"org.apache.openjpa.ee.JNDIManagedRuntime\",\n+            \"invocation\", \"org.apache.openjpa.ee.InvocationManagedRuntime\",\n+        };\n+        managedRuntimePlugin.setAliases(aliases);\n+        managedRuntimePlugin.setDefault(aliases[0]);\n+        managedRuntimePlugin.setString(aliases[0]);\n+        managedRuntimePlugin.setInstantiatingGetter\n+            (\"getManagedRuntimeInstance\");\n+\n+        proxyManagerPlugin = addPlugin(\"org.apache.openjpa.ProxyManager\", true);\n+        aliases = new String[]{ \"default\",\n+            \"org.apache.openjpa.util.ProxyManagerImpl\" };\n+        proxyManagerPlugin.setAliases(aliases);\n+        proxyManagerPlugin.setDefault(aliases[0]);\n+        proxyManagerPlugin.setString(aliases[0]);\n+        proxyManagerPlugin.setInstantiatingGetter(\"getProxyManagerInstance\");\n+\n+        mapping = addString(\"org.apache.openjpa.Mapping\");\n+        metaFactoryPlugin =\n+            addPlugin(\"org.apache.openjpa.MetaDataFactory\", false);\n+\n+        connectionFactory = addObject(\"org.apache.openjpa.ConnectionFactory\");\n+        connectionFactory.setInstantiatingGetter(\"getConnectionFactory\");\n+\n+        connectionFactory2 = addObject(\"org.apache.openjpa.ConnectionFactory2\");\n+        connectionFactory2.setInstantiatingGetter(\"getConnectionFactory2\");\n+\n+        connectionUserName = addString(\"org.apache.openjpa.ConnectionUserName\");\n+        connectionPassword = addString(\"org.apache.openjpa.ConnectionPassword\");\n+        connectionURL = addString(\"org.apache.openjpa.ConnectionURL\");\n+        connectionDriverName =\n+            addString(\"org.apache.openjpa.ConnectionDriverName\");\n+        connectionFactoryName =\n+            addString(\"org.apache.openjpa.ConnectionFactoryName\");\n+        connectionProperties =\n+            addString(\"org.apache.openjpa.ConnectionProperties\");\n+        connectionFactoryProperties = addString\n+            (\"org.apache.openjpa.ConnectionFactoryProperties\");\n+        connection2UserName =\n+            addString(\"org.apache.openjpa.Connection2UserName\");\n+        connection2Password =\n+            addString(\"org.apache.openjpa.Connection2Password\");\n+        connection2URL = addString(\"org.apache.openjpa.Connection2URL\");\n+        connection2DriverName =\n+            addString(\"org.apache.openjpa.Connection2DriverName\");\n+        connection2Properties =\n+            addString(\"org.apache.openjpa.Connection2Properties\");\n+        connectionFactory2Properties = addString\n+            (\"org.apache.openjpa.ConnectionFactory2Properties\");\n+        connectionFactory2Name =\n+            addString(\"org.apache.openjpa.ConnectionFactory2Name\");\n+\n+        connectionFactoryMode =\n+            addBoolean(\"org.apache.openjpa.ConnectionFactoryMode\");\n+        aliases = new String[]{\n+            \"local\", \"false\",\n+            \"managed\", \"true\",\n+        };\n+        connectionFactoryMode.setAliases(aliases);\n+        connectionFactoryMode.setDefault(aliases[0]);\n+\n+        optimistic = addBoolean(\"org.apache.openjpa.Optimistic\");\n+        optimistic.setDefault(\"true\");\n+        optimistic.set(true);\n+\n+        autoClear = addInt(\"org.apache.openjpa.AutoClear\");\n+        aliases = new String[]{\n+            \"datastore\", String.valueOf(AutoClear.CLEAR_DATASTORE),\n+            \"all\", String.valueOf(AutoClear.CLEAR_ALL),\n+        };\n+        autoClear.setAliases(aliases);\n+        autoClear.setDefault(aliases[0]);\n+        autoClear.set(AutoClear.CLEAR_DATASTORE);\n+\n+        retainState = addBoolean(\"org.apache.openjpa.RetainState\");\n+        retainState.setDefault(\"true\");\n+        retainState.set(true);\n+\n+        restoreState = addInt(\"org.apache.openjpa.RestoreState\");\n+        aliases = new String[]{\n+            \"none\", String.valueOf(RestoreState.RESTORE_NONE),\n+            \"false\", String.valueOf(RestoreState.RESTORE_NONE),\n+            \"immutable\", String.valueOf(RestoreState.RESTORE_IMMUTABLE),\n+            // \"true\" for compat with jdo RestoreValues\n+            \"true\", String.valueOf(RestoreState.RESTORE_IMMUTABLE),\n+            \"all\", String.valueOf(RestoreState.RESTORE_ALL),\n+        };\n+        restoreState.setAliases(aliases);\n+        restoreState.setDefault(aliases[0]);\n+        restoreState.set(RestoreState.RESTORE_IMMUTABLE);\n+\n+        autoDetach = new AutoDetachValue(\"org.apache.openjpa.AutoDetach\");\n+        addValue(autoDetach);\n+\n+        detachStatePlugin = addPlugin(\"org.apache.openjpa.DetachState\", true);\n+        aliases = new String[]{\n+            \"loaded\", DetachOptions.Loaded.class.getName(),\n+            \"fgs\", DetachOptions.FetchGroups.class.getName(),\n+            \"all\", DetachOptions.All.class.getName(),\n+        };\n+        detachStatePlugin.setAliases(aliases);\n+        detachStatePlugin.setDefault(aliases[0]);\n+        detachStatePlugin.setString(aliases[0]);\n+        detachStatePlugin.setInstantiatingGetter(\"getDetachStateInstance\");\n+\n+        ignoreChanges = addBoolean(\"org.apache.openjpa.IgnoreChanges\");\n+\n+        nontransactionalRead =\n+            addBoolean(\"org.apache.openjpa.NontransactionalRead\");\n+        nontransactionalRead.setDefault(\"true\");\n+        nontransactionalRead.set(true);\n+\n+        nontransactionalWrite =\n+            addBoolean(\"org.apache.openjpa.NontransactionalWrite\");\n+        multithreaded = addBoolean(\"org.apache.openjpa.Multithreaded\");\n+\n+        fetchBatchSize = addInt(\"org.apache.openjpa.FetchBatchSize\");\n+        fetchBatchSize.setDefault(\"-1\");\n+        fetchBatchSize.set(-1);\n+\n+        fetchGroups = addStringList(\"org.apache.openjpa.FetchGroups\");\n+        fetchGroups.setDefault(\"default\");\n+        fetchGroups.set(new String[]{ \"default\" });\n+\n+        flushBeforeQueries = addInt(\"org.apache.openjpa.FlushBeforeQueries\");\n+        aliases = new String[]{\n+            \"true\", String.valueOf(QueryFlushModes.FLUSH_TRUE),\n+            \"false\", String.valueOf(QueryFlushModes.FLUSH_FALSE),\n+            \"with-connection\", String.valueOf\n+            (QueryFlushModes.FLUSH_WITH_CONNECTION),\n+        };\n+        flushBeforeQueries.setAliases(aliases);\n+        flushBeforeQueries.setDefault(aliases[0]);\n+        flushBeforeQueries.set(QueryFlushModes.FLUSH_TRUE);\n+\n+        lockTimeout = addInt(\"org.apache.openjpa.LockTimeout\");\n+        lockTimeout.setDefault(\"-1\");\n+        lockTimeout.set(-1);\n+\n+        readLockLevel = addInt(\"org.apache.openjpa.ReadLockLevel\");\n+        aliases = new String[]{\n+            \"read\", String.valueOf(LockLevels.LOCK_READ),\n+            \"write\", String.valueOf(LockLevels.LOCK_WRITE),\n+            \"none\", String.valueOf(LockLevels.LOCK_NONE),\n+        };\n+        readLockLevel.setAliases(aliases);\n+        readLockLevel.setDefault(aliases[0]);\n+        readLockLevel.set(LockLevels.LOCK_READ);\n+\n+        writeLockLevel = addInt(\"org.apache.openjpa.WriteLockLevel\");\n+        aliases = new String[]{\n+            \"read\", String.valueOf(LockLevels.LOCK_READ),\n+            \"write\", String.valueOf(LockLevels.LOCK_WRITE),\n+            \"none\", String.valueOf(LockLevels.LOCK_NONE),\n+        };\n+        writeLockLevel.setAliases(aliases);\n+        writeLockLevel.setDefault(aliases[1]);\n+        writeLockLevel.set(LockLevels.LOCK_WRITE);\n+\n+        seqPlugin = new SeqValue(\"org.apache.openjpa.Sequence\");\n+        seqPlugin.setInstantiatingGetter(\"getSequenceInstance\");\n+        addValue(seqPlugin);\n+\n+        connectionRetainMode =\n+            addInt(\"org.apache.openjpa.ConnectionRetainMode\");\n+        aliases = new String[]{\n+            \"on-demand\",\n+            String.valueOf(ConnectionRetainModes.CONN_RETAIN_DEMAND),\n+            \"transaction\",\n+            String.valueOf(ConnectionRetainModes.CONN_RETAIN_TRANS),\n+            \"always\",\n+            String.valueOf(ConnectionRetainModes.CONN_RETAIN_ALWAYS),\n+            // deprecated\n+            \"persistence-manager\",\n+            String.valueOf(ConnectionRetainModes.CONN_RETAIN_ALWAYS),\n+        };\n+        connectionRetainMode.setAliases(aliases);\n+        connectionRetainMode.setDefault(aliases[0]);\n+        connectionRetainMode.setAliasListComprehensive(true);\n+        connectionRetainMode.set(ConnectionRetainModes.CONN_RETAIN_DEMAND);\n+\n+        filterListenerPlugins =\n+            addPluginList(\"org.apache.openjpa.FilterListeners\");\n+        filterListenerPlugins.setInstantiatingGetter\n+            (\"getFilterListenerInstances\");\n+\n+        aggregateListenerPlugins =\n+            addPluginList(\"org.apache.openjpa.AggregateListeners\");\n+        aggregateListenerPlugins.setInstantiatingGetter\n+            (\"getAggregateListenerInstances\");\n+\n+        retryClassRegistration =\n+            addBoolean(\"org.apache.openjpa.RetryClassRegistration\");\n+\n+        compatibilityPlugin =\n+            addPlugin(\"org.apache.openjpa.Compatibility\", true);\n+        aliases = new String[]{ \"default\", Compatibility.class.getName() };\n+        compatibilityPlugin.setAliases(aliases);\n+        compatibilityPlugin.setDefault(aliases[0]);\n+        compatibilityPlugin.setString(aliases[0]);\n+        compatibilityPlugin.setInstantiatingGetter(\"getCompatibilityInstance\");\n+\n+        // initialize supported options that some runtimes may not support\n+        supportedOptions.add(OPTION_NONTRANS_READ);\n+        supportedOptions.add(OPTION_OPTIMISTIC);\n+        supportedOptions.add(OPTION_ID_APPLICATION);\n+        supportedOptions.add(OPTION_ID_DATASTORE);\n+        supportedOptions.add(OPTION_TYPE_COLLECTION);\n+        supportedOptions.add(OPTION_TYPE_MAP);\n+        supportedOptions.add(OPTION_TYPE_ARRAY);\n+        supportedOptions.add(OPTION_NULL_CONTAINER);\n+        supportedOptions.add(OPTION_EMBEDDED_RELATION);\n+        supportedOptions.add(OPTION_EMBEDDED_COLLECTION_RELATION);\n+        supportedOptions.add(OPTION_EMBEDDED_MAP_RELATION);\n+        supportedOptions.add(OPTION_INC_FLUSH);\n+        supportedOptions.add(OPTION_VALUE_AUTOASSIGN);\n+        supportedOptions.add(OPTION_VALUE_INCREMENT);\n+        supportedOptions.add(OPTION_DATASTORE_CONNECTION);\n+\n+        if (derivations)\n+            ProductDerivations.beforeConfigurationLoad(this);\n+        if (loadDefaults)\n+            loadDefaults();\n+    }\n+\n+    public String getProductName() {\n+        return \"openjpa\";\n+    }\n+\n+    public Collection supportedOptions() {\n+        return supportedOptions;\n+    }\n+\n+    public String getSpecification() {\n+        return spec;\n+    }\n+\n+    public boolean setSpecification(String spec) {\n+        if (spec == null)\n+            return false;\n+\n+        if (this.spec != null) {\n+            if (!this.spec.equals(spec)\n+                && getConfigurationLog().isWarnEnabled())\n+                getConfigurationLog().warn(_loc.get(\"diff-specs\", this.spec,\n+                    spec));\n+            return false;\n+        }\n+\n+        this.spec = spec;\n+        ProductDerivations.afterSpecificationSet(this);\n+        return true;\n+    }\n+\n+    public void setClassResolver(String classResolver) {\n+        assertNotReadOnly();\n+        classResolverPlugin.setString(classResolver);\n+    }\n+\n+    public String getClassResolver() {\n+        return classResolverPlugin.getString();\n+    }\n+\n+    public void setClassResolver(ClassResolver classResolver) {\n+        assertNotReadOnly();\n+        classResolverPlugin.set(classResolver);\n+    }\n+\n+    public ClassResolver getClassResolverInstance() {\n+        if (classResolverPlugin.get() == null)\n+            classResolverPlugin.instantiate(ClassResolver.class, this);\n+        return (ClassResolver) classResolverPlugin.get();\n+    }\n+\n+    public void setBrokerFactory(String factory) {\n+        assertNotReadOnly();\n+        brokerFactoryPlugin.setString(factory);\n+    }\n+\n+    public String getBrokerFactory() {\n+        return brokerFactoryPlugin.getString();\n+    }\n+\n+    public void setBrokerImpl(String broker) {\n+        assertNotReadOnly();\n+        brokerPlugin.setString(broker);\n+    }\n+\n+    public String getBrokerImpl() {\n+        return brokerPlugin.getString();\n+    }\n+\n+    public BrokerImpl newBrokerInstance(String user, String pass) {\n+        BrokerImpl broker = (BrokerImpl) brokerPlugin.instantiate\n+            (BrokerImpl.class, this);\n+        if (broker != null)\n+            broker.setAuthentication(user, pass);\n+        return broker;\n+    }\n+\n+    public void setDataCacheManager(String mgr) {\n+        assertNotReadOnly();\n+        dataCacheManagerPlugin.setString(mgr);\n+    }\n+\n+    public String getDataCacheManager() {\n+        return dataCacheManagerPlugin.getString();\n+    }\n+\n+    public void setDataCacheManager(DataCacheManager dcm) {\n+        assertNotReadOnly();\n+        if (dcm != null)\n+            dcm.initialize(this, dataCachePlugin, queryCachePlugin);\n+        dataCacheManagerPlugin.set(dcm);\n+    }\n+\n+    public DataCacheManager getDataCacheManagerInstance() {\n+        DataCacheManager dcm = (DataCacheManager) dataCacheManagerPlugin.get();\n+        if (dcm == null) {\n+            dcm = (DataCacheManager) dataCacheManagerPlugin.instantiate\n+                (DataCacheManager.class, this);\n+            dcm.initialize(this, dataCachePlugin, queryCachePlugin);\n+        }\n+        return dcm;\n+    }\n+\n+    public void setDataCache(String dataCache) {\n+        assertNotReadOnly();\n+        dataCachePlugin.setString(dataCache);\n+    }\n+\n+    public String getDataCache() {\n+        return dataCachePlugin.getString();\n+    }\n+\n+    public void setDataCacheTimeout(int dataCacheTimeout) {\n+        assertNotReadOnly();\n+        this.dataCacheTimeout.set(dataCacheTimeout);\n+    }\n+\n+    public void setDataCacheTimeout(Integer dataCacheTimeout) {\n+        if (dataCacheTimeout != null)\n+            setDataCacheTimeout(dataCacheTimeout.intValue());\n+    }\n+\n+    public int getDataCacheTimeout() {\n+        return dataCacheTimeout.get();\n+    }\n+\n+    public void setQueryCache(String queryCache) {\n+        assertNotReadOnly();\n+        queryCachePlugin.setString(queryCache);\n+    }\n+\n+    public String getQueryCache() {\n+        return queryCachePlugin.getString();\n+    }\n+\n+    public boolean getDynamicDataStructs() {\n+        return dynamicDataStructs.get();\n+    }\n+\n+    public void setDynamicDataStructs(boolean dynamic) {\n+        dynamicDataStructs.set(dynamic);\n+    }\n+\n+    public void setDynamicDataStructs(Boolean dynamic) {\n+        setDynamicDataStructs(dynamic.booleanValue());\n+    }\n+\n+    public void setLockManager(String lockManager) {\n+        assertNotReadOnly();\n+        lockManagerPlugin.setString(lockManager);\n+    }\n+\n+    public String getLockManager() {\n+        return lockManagerPlugin.getString();\n+    }\n+\n+    public LockManager newLockManagerInstance() {\n+        // don't validate plugin properties on instantiation because it\n+        // is likely that back ends will override defaults with their\n+        // own subclasses with new properties\n+        return (LockManager) lockManagerPlugin.instantiate(LockManager.class,\n+            this, false);\n+    }\n+\n+    public void setInverseManager(String inverseManager) {\n+        assertNotReadOnly();\n+        inverseManagerPlugin.setString(inverseManager);\n+    }\n+\n+    public String getInverseManager() {\n+        return inverseManagerPlugin.getString();\n+    }\n+\n+    public InverseManager newInverseManagerInstance() {\n+        return (InverseManager) inverseManagerPlugin.instantiate\n+            (InverseManager.class, this);\n+    }\n+\n+    public void setSavepointManager(String savepointManager) {\n+        assertNotReadOnly();\n+        savepointManagerPlugin.setString(savepointManager);\n+    }\n+\n+    public String getSavepointManager() {\n+        return savepointManagerPlugin.getString();\n+    }\n+\n+    public SavepointManager getSavepointManagerInstance() {\n+        if (savepointManagerPlugin.get() == null)\n+            savepointManagerPlugin.instantiate(SavepointManager.class, this);\n+        return (SavepointManager) savepointManagerPlugin.get();\n+    }\n+\n+    public void setOrphanedKeyAction(String action) {\n+        assertNotReadOnly();\n+        orphanedKeyPlugin.setString(action);\n+    }\n+\n+    public String getOrphanedKeyAction() {\n+        return orphanedKeyPlugin.getString();\n+    }\n+\n+    public OrphanedKeyAction getOrphanedKeyActionInstance() {\n+        if (orphanedKeyPlugin.get() == null)\n+            orphanedKeyPlugin.instantiate(OrphanedKeyAction.class, this);\n+        return (OrphanedKeyAction) orphanedKeyPlugin.get();\n+    }\n+\n+    public void setOrphanedKeyAction(OrphanedKeyAction action) {\n+        assertNotReadOnly();\n+        orphanedKeyPlugin.set(action);\n+    }\n+\n+    public void setRemoteCommitProvider(String remoteCommitProvider) {\n+        assertNotReadOnly();\n+        remoteProviderPlugin.setString(remoteCommitProvider);\n+    }\n+\n+    public String getRemoteCommitProvider() {\n+        return remoteProviderPlugin.getString();\n+    }\n+\n+    public RemoteCommitProvider newRemoteCommitProviderInstance() {\n+        return remoteProviderPlugin.instantiateProvider(this);\n+    }\n+\n+    public void setRemoteCommitEventManager\n+        (RemoteCommitEventManager remoteEventManager) {\n+        assertNotReadOnly();\n+        this.remoteEventManager = remoteEventManager;\n+        remoteProviderPlugin.configureEventManager(remoteEventManager);\n+    }\n+\n+    public RemoteCommitEventManager getRemoteCommitEventManager() {\n+        if (remoteEventManager == null) {\n+            remoteEventManager = new RemoteCommitEventManager(this);\n+            remoteProviderPlugin.configureEventManager(remoteEventManager);\n+        }\n+        return remoteEventManager;\n+    }\n+\n+    public void setTransactionMode(String transactionMode) {\n+        assertNotReadOnly();\n+        this.transactionMode.setString(transactionMode);\n+    }\n+\n+    public String getTransactionMode() {\n+        return transactionMode.getString();\n+    }\n+\n+    public void setTransactionModeManaged(boolean managed) {\n+        assertNotReadOnly();\n+        transactionMode.set(managed);\n+    }\n+\n+    public boolean isTransactionModeManaged() {\n+        return transactionMode.get();\n+    }\n+\n+    public void setManagedRuntime(String managedRuntime) {\n+        assertNotReadOnly();\n+        managedRuntimePlugin.setString(managedRuntime);\n+    }\n+\n+    public String getManagedRuntime() {\n+        return managedRuntimePlugin.getString();\n+    }\n+\n+    public void setManagedRuntime(ManagedRuntime managedRuntime) {\n+        assertNotReadOnly();\n+        managedRuntimePlugin.set(managedRuntime);\n+    }\n+\n+    public ManagedRuntime getManagedRuntimeInstance() {\n+        if (managedRuntimePlugin.get() == null)\n+            managedRuntimePlugin.instantiate(ManagedRuntime.class, this);\n+        return (ManagedRuntime) managedRuntimePlugin.get();\n+    }\n+\n+    public void setProxyManager(String proxyManager) {\n+        assertNotReadOnly();\n+        proxyManagerPlugin.setString(proxyManager);\n+    }\n+\n+    public String getProxyManager() {\n+        return proxyManagerPlugin.getString();\n+    }\n+\n+    public void setProxyManager(ProxyManager proxyManager) {\n+        assertNotReadOnly();\n+        proxyManagerPlugin.set(proxyManager);\n+    }\n+\n+    public ProxyManager getProxyManagerInstance() {\n+        if (proxyManagerPlugin.get() == null)\n+            proxyManagerPlugin.instantiate(ProxyManager.class, this);\n+        return (ProxyManager) proxyManagerPlugin.get();\n+    }\n+\n+    public void setMapping(String mapping) {\n+        assertNotReadOnly();\n+        this.mapping.setString(mapping);\n+    }\n+\n+    public String getMapping() {\n+        return mapping.getString();\n+    }\n+\n+    public void setMetaDataFactory(String meta) {\n+        assertNotReadOnly();\n+        this.metaFactoryPlugin.setString(meta);\n+    }\n+\n+    public String getMetaDataFactory() {\n+        return metaFactoryPlugin.getString();\n+    }\n+\n+    public MetaDataFactory newMetaDataFactoryInstance() {\n+        return (MetaDataFactory) metaFactoryPlugin.instantiate\n+            (MetaDataFactory.class, this);\n+    }\n+\n+    public void setMetaDataRepository(MetaDataRepository meta) {\n+        assertNotReadOnly();\n+        metaRepos = meta;\n+    }\n+\n+    public MetaDataRepository getMetaDataRepository() {\n+        if (metaRepos == null)\n+            metaRepos = new MetaDataRepository(this);\n+        return metaRepos;\n+    }\n+\n+    public void setConnectionUserName(String connectionUserName) {\n+        assertNotReadOnly();\n+        this.connectionUserName.setString(connectionUserName);\n+    }\n+\n+    public String getConnectionUserName() {\n+        return connectionUserName.getString();\n+    }\n+\n+    public void setConnectionPassword(String connectionPassword) {\n+        assertNotReadOnly();\n+        this.connectionPassword.setString(connectionPassword);\n+    }\n+\n+    public String getConnectionPassword() {\n+        return connectionPassword.getString();\n+    }\n+\n+    public void setConnectionURL(String connectionURL) {\n+        assertNotReadOnly();\n+        this.connectionURL.setString(connectionURL);\n+    }\n+\n+    public String getConnectionURL() {\n+        return connectionURL.getString();\n+    }\n+\n+    public void setConnectionDriverName(String driverName) {\n+        assertNotReadOnly();\n+        this.connectionDriverName.setString(driverName);\n+    }\n+\n+    public String getConnectionDriverName() {\n+        return connectionDriverName.getString();\n+    }\n+\n+    public void setConnectionProperties(String connectionProperties) {\n+        assertNotReadOnly();\n+        this.connectionProperties.setString(connectionProperties);\n+    }\n+\n+    public String getConnectionProperties() {\n+        return connectionProperties.getString();\n+    }\n+\n+    public void setConnectionFactoryProperties\n+        (String connectionFactoryProperties) {\n+        assertNotReadOnly();\n+        this.connectionFactoryProperties.setString(connectionFactoryProperties);\n+    }\n+\n+    public String getConnectionFactoryProperties() {\n+        return connectionFactoryProperties.getString();\n+    }\n+\n+    public String getConnectionFactoryMode() {\n+        return connectionFactoryMode.getString();\n+    }\n+\n+    public void setConnectionFactoryMode(String mode) {\n+        assertNotReadOnly();\n+        connectionFactoryMode.setString(mode);\n+    }\n+\n+    public boolean isConnectionFactoryModeManaged() {\n+        return connectionFactoryMode.get();\n+    }\n+\n+    public void setConnectionFactoryModeManaged(boolean managed) {\n+        assertNotReadOnly();\n+        connectionFactoryMode.set(managed);\n+    }\n+\n+    public void setConnectionFactoryName(String connectionFactoryName) {\n+        assertNotReadOnly();\n+        this.connectionFactoryName.setString(connectionFactoryName);\n+    }\n+\n+    public String getConnectionFactoryName() {\n+        return connectionFactoryName.getString();\n+    }\n+\n+    public void setConnectionFactory(Object factory) {\n+        assertNotReadOnly();\n+        connectionFactory.set(factory);\n+    }\n+\n+    public Object getConnectionFactory() {\n+        if (connectionFactory.get() == null)\n+            connectionFactory.set(lookupConnectionFactory\n+                (getConnectionFactoryName()), true);\n+        return connectionFactory.get();\n+    }\n+\n+    /**\n+     * Lookup the connection factory at the given name.\n+     */\n+    private Object lookupConnectionFactory(String name) {\n+        if (name == null || name.trim().length() == 0)\n+            return null;\n+\n+        return Configurations.lookup(name);\n+    }\n+\n+    public void setConnection2UserName(String connection2UserName) {\n+        assertNotReadOnly();\n+        this.connection2UserName.setString(connection2UserName);\n+    }\n+\n+    public String getConnection2UserName() {\n+        return connection2UserName.getString();\n+    }\n+\n+    public void setConnection2Password(String connection2Password) {\n+        assertNotReadOnly();\n+        this.connection2Password.setString(connection2Password);\n+    }\n+\n+    public String getConnection2Password() {\n+        return connection2Password.getString();\n+    }\n+\n+    public void setConnection2URL(String connection2URL) {\n+        assertNotReadOnly();\n+        this.connection2URL.setString(connection2URL);\n+    }\n+\n+    public String getConnection2URL() {\n+        return connection2URL.getString();\n+    }\n+\n+    public void setConnection2DriverName(String driverName) {\n+        assertNotReadOnly();\n+        this.connection2DriverName.setString(driverName);\n+    }\n+\n+    public String getConnection2DriverName() {\n+        return connection2DriverName.getString();\n+    }\n+\n+    public void setConnection2Properties(String connection2Properties) {\n+        assertNotReadOnly();\n+        this.connection2Properties.setString(connection2Properties);\n+    }\n+\n+    public String getConnection2Properties() {\n+        return connection2Properties.getString();\n+    }\n+\n+    public void setConnectionFactory2Properties\n+        (String connectionFactory2Properties) {\n+        assertNotReadOnly();\n+        this.connectionFactory2Properties.setString\n+            (connectionFactory2Properties);\n+    }\n+\n+    public String getConnectionFactory2Properties() {\n+        return connectionFactory2Properties.getString();\n+    }\n+\n+    public void setConnectionFactory2Name(String connectionFactory2Name) {\n+        assertNotReadOnly();\n+        this.connectionFactory2Name.setString(connectionFactory2Name);\n+    }\n+\n+    public String getConnectionFactory2Name() {\n+        return connectionFactory2Name.getString();\n+    }\n+\n+    public void setConnectionFactory2(Object factory) {\n+        assertNotReadOnly();\n+        connectionFactory2.set(factory);\n+    }\n+\n+    public Object getConnectionFactory2() {\n+        if (connectionFactory2.get() == null)\n+            connectionFactory2.set(lookupConnectionFactory\n+                (getConnectionFactory2Name()), false);\n+        return connectionFactory2.get();\n+    }\n+\n+    public void setOptimistic(boolean optimistic) {\n+        assertNotReadOnly();\n+        this.optimistic.set(optimistic);\n+    }\n+\n+    public void setOptimistic(Boolean optimistic) {\n+        if (optimistic != null)\n+            setOptimistic(optimistic.booleanValue());\n+    }\n+\n+    public boolean getOptimistic() {\n+        return optimistic.get();\n+    }\n+\n+    public void setAutoClear(String clear) {\n+        assertNotReadOnly();\n+        autoClear.setString(clear);\n+    }\n+\n+    public String getAutoClear() {\n+        return autoClear.getString();\n+    }\n+\n+    public void setAutoClear(int clear) {\n+        assertNotReadOnly();\n+        autoClear.set(clear);\n+    }\n+\n+    public int getAutoClearConstant() {\n+        return autoClear.get();\n+    }\n+\n+    public void setRetainState(boolean retainState) {\n+        assertNotReadOnly();\n+        this.retainState.set(retainState);\n+    }\n+\n+    public void setRetainState(Boolean retainState) {\n+        if (retainState != null)\n+            setRetainState(retainState.booleanValue());\n+    }\n+\n+    public boolean getRetainState() {\n+        return retainState.get();\n+    }\n+\n+    public void setRestoreState(String restoreState) {\n+        assertNotReadOnly();\n+        this.restoreState.setString(restoreState);\n+    }\n+\n+    public String getRestoreState() {\n+        return restoreState.getString();\n+    }\n+\n+    public void setRestoreState(int restoreState) {\n+        assertNotReadOnly();\n+        this.restoreState.set(restoreState);\n+    }\n+\n+    public int getRestoreStateConstant() {\n+        return restoreState.get();\n+    }\n+\n+    public void setAutoDetach(String autoDetach) {\n+        assertNotReadOnly();\n+        this.autoDetach.setString(autoDetach);\n+    }\n+\n+    public String getAutoDetach() {\n+        return autoDetach.getString();\n+    }\n+\n+    public void setAutoDetach(int autoDetachFlags) {\n+        autoDetach.set(autoDetachFlags);\n+    }\n+\n+    public int getAutoDetachConstant() {\n+        return autoDetach.get();\n+    }\n+\n+    public void setDetachState(String detachState) {\n+        assertNotReadOnly();\n+        detachStatePlugin.setString(detachState);\n+    }\n+\n+    public String getDetachState() {\n+        return detachStatePlugin.getString();\n+    }\n+\n+    public void setDetachState(DetachOptions detachState) {\n+        assertNotReadOnly();\n+        detachStatePlugin.set(detachState);\n+    }\n+\n+    public DetachOptions getDetachStateInstance() {\n+        if (detachStatePlugin.get() == null)\n+            detachStatePlugin.instantiate(DetachOptions.class, this);\n+        return (DetachOptions) detachStatePlugin.get();\n+    }\n+\n+    public void setIgnoreChanges(boolean ignoreChanges) {\n+        assertNotReadOnly();\n+        this.ignoreChanges.set(ignoreChanges);\n+    }\n+\n+    public void setIgnoreChanges(Boolean ignoreChanges) {\n+        if (ignoreChanges != null)\n+            setIgnoreChanges(ignoreChanges.booleanValue());\n+    }\n+\n+    public boolean getIgnoreChanges() {\n+        return ignoreChanges.get();\n+    }\n+\n+    public void setNontransactionalRead(boolean nontransactionalRead) {\n+        assertNotReadOnly();\n+        this.nontransactionalRead.set(nontransactionalRead);\n+    }\n+\n+    public void setNontransactionalRead(Boolean nontransactionalRead) {\n+        if (nontransactionalRead != null)\n+            setNontransactionalRead(nontransactionalRead.booleanValue());\n+    }\n+\n+    public boolean getNontransactionalRead() {\n+        return nontransactionalRead.get();\n+    }\n+\n+    public void setNontransactionalWrite(boolean nontransactionalWrite) {\n+        assertNotReadOnly();\n+        this.nontransactionalWrite.set(nontransactionalWrite);\n+    }\n+\n+    public void setNontransactionalWrite(Boolean nontransactionalWrite) {\n+        if (nontransactionalWrite != null)\n+            setNontransactionalWrite(nontransactionalWrite.booleanValue());\n+    }\n+\n+    public boolean getNontransactionalWrite() {\n+        return nontransactionalWrite.get();\n+    }\n+\n+    public void setMultithreaded(boolean multithreaded) {\n+        assertNotReadOnly();\n+        this.multithreaded.set(multithreaded);\n+    }\n+\n+    public void setMultithreaded(Boolean multithreaded) {\n+        if (multithreaded != null)\n+            setMultithreaded(multithreaded.booleanValue());\n+    }\n+\n+    public boolean getMultithreaded() {\n+        return multithreaded.get();\n+    }\n+\n+    public void setFetchBatchSize(int fetchBatchSize) {\n+        assertNotReadOnly();\n+        this.fetchBatchSize.set(fetchBatchSize);\n+    }\n+\n+    public void setFetchBatchSize(Integer fetchBatchSize) {\n+        if (fetchBatchSize != null)\n+            setFetchBatchSize(fetchBatchSize.intValue());\n+    }\n+\n+    public int getFetchBatchSize() {\n+        return fetchBatchSize.get();\n+    }\n+\n+    public void setFetchGroups(String fetchGroups) {\n+        assertNotReadOnly();\n+        this.fetchGroups.setString(fetchGroups);\n+    }\n+\n+    public String getFetchGroups() {\n+        return fetchGroups.getString();\n+    }\n+\n+    public String[] getFetchGroupsList() {\n+        return fetchGroups.get();\n+    }\n+\n+    public void setFetchGroups(String[] fetchGroups) {\n+        this.fetchGroups.set(fetchGroups);\n+    }\n+\n+    public void setFlushBeforeQueries(String flush) {\n+        assertNotReadOnly();\n+        flushBeforeQueries.setString(flush);\n+    }\n+\n+    public String getFlushBeforeQueries() {\n+        return flushBeforeQueries.getString();\n+    }\n+\n+    public void setFlushBeforeQueries(int flush) {\n+        assertNotReadOnly();\n+        flushBeforeQueries.set(flush);\n+    }\n+\n+    public int getFlushBeforeQueriesConstant() {\n+        return flushBeforeQueries.get();\n+    }\n+\n+    public void setLockTimeout(int timeout) {\n+        assertNotReadOnly();\n+        lockTimeout.set(timeout);\n+    }\n+\n+    public void setLockTimeout(Integer timeout) {\n+        if (timeout != null)\n+            setLockTimeout(timeout.intValue());\n+    }\n+\n+    public int getLockTimeout() {\n+        return lockTimeout.get();\n+    }\n+\n+    public void setReadLockLevel(String level) {\n+        assertNotReadOnly();\n+        readLockLevel.setString(level);\n+    }\n+\n+    public String getReadLockLevel() {\n+        return readLockLevel.getString();\n+    }\n+\n+    public void setReadLockLevel(int level) {\n+        assertNotReadOnly();\n+        readLockLevel.set(level);\n+    }\n+\n+    public int getReadLockLevelConstant() {\n+        return readLockLevel.get();\n+    }\n+\n+    public void setWriteLockLevel(String level) {\n+        assertNotReadOnly();\n+        writeLockLevel.setString(level);\n+    }\n+\n+    public String getWriteLockLevel() {\n+        return writeLockLevel.getString();\n+    }\n+\n+    public void setWriteLockLevel(int level) {\n+        assertNotReadOnly();\n+        writeLockLevel.set(level);\n+    }\n+\n+    public int getWriteLockLevelConstant() {\n+        return writeLockLevel.get();\n+    }\n+\n+    public void setSequence(String sequence) {\n+        assertNotReadOnly();\n+        seqPlugin.setString(sequence);\n+    }\n+\n+    public String getSequence() {\n+        return seqPlugin.getString();\n+    }\n+\n+    public void setSequence(Seq seq) {\n+        assertNotReadOnly();\n+        seqPlugin.set(seq);\n+    }\n+\n+    public Seq getSequenceInstance() {\n+        if (seqPlugin.get() == null)\n+            seqPlugin.instantiate(Seq.class, this);\n+        return (Seq) seqPlugin.get();\n+    }\n+\n+    public void setConnectionRetainMode(String connectionRetainMode) {\n+        assertNotReadOnly();\n+        this.connectionRetainMode.setString(connectionRetainMode);\n+    }\n+\n+    public String getConnectionRetainMode() {\n+        return connectionRetainMode.getString();\n+    }\n+\n+    public void setConnectionRetainMode(int connectionRetainMode) {\n+        assertNotReadOnly();\n+        this.connectionRetainMode.set(connectionRetainMode);\n+    }\n+\n+    public int getConnectionRetainModeConstant() {\n+        return connectionRetainMode.get();\n+    }\n+\n+    public void setFilterListeners(String filterListeners) {\n+        assertNotReadOnly();\n+        filterListenerPlugins.setString(filterListeners);\n+    }\n+\n+    public String getFilterListeners() {\n+        return filterListenerPlugins.getString();\n+    }\n+\n+    public void setFilterListeners(FilterListener[] listeners) {\n+        assertNotReadOnly();\n+        filterListenerPlugins.set(listeners);\n+    }\n+\n+    public FilterListener[] getFilterListenerInstances() {\n+        if (filterListenerPlugins.get() == null)\n+            filterListenerPlugins.instantiate(FilterListener.class, this);\n+        return (FilterListener[]) filterListenerPlugins.get();\n+    }\n+\n+    public void setAggregateListeners(String aggregateListeners) {\n+        assertNotReadOnly();\n+        aggregateListenerPlugins.setString(aggregateListeners);\n+    }\n+\n+    public String getAggregateListeners() {\n+        return aggregateListenerPlugins.getString();\n+    }\n+\n+    public void setAggregateListeners(AggregateListener[] listeners) {\n+        assertNotReadOnly();\n+        aggregateListenerPlugins.set(listeners);\n+    }\n+\n+    public AggregateListener[] getAggregateListenerInstances() {\n+        if (aggregateListenerPlugins.get() == null)\n+            aggregateListenerPlugins.instantiate(AggregateListener.class, this);\n+        return (AggregateListener[]) aggregateListenerPlugins.get();\n+    }\n+\n+    public void setRetryClassRegistration(boolean retry) {\n+        assertNotReadOnly();\n+        retryClassRegistration.set(retry);\n+    }\n+\n+    public void setRetryClassRegistration(Boolean retry) {\n+        if (retry != null)\n+            setRetryClassRegistration(retry.booleanValue());\n+    }\n+\n+    public boolean getRetryClassRegistration() {\n+        return retryClassRegistration.get();\n+    }\n+\n+    public String getCompatibility() {\n+        return compatibilityPlugin.getString();\n+    }\n+\n+    public void setCompatibility(String compatibility) {\n+        compatibilityPlugin.setString(compatibility);\n+    }\n+\n+    public Compatibility getCompatibilityInstance() {\n+        if (compatibilityPlugin.get() == null)\n+            compatibilityPlugin.instantiate(Compatibility.class, this);\n+        return (Compatibility) compatibilityPlugin.get();\n+    }\n+\n+    public void instantiateAll() {\n+        super.instantiateAll();\n+\n+        // instantiate singletons without values\n+        getRemoteCommitEventManager();\n+        getMetaDataRepository();\n+    }\n+\n+    public void close() {\n+        ImplHelper.close(remoteEventManager);\n+        ImplHelper.close(metaRepos);\n+        super.close();\n+        ProductDerivations.afterClose(this);\n+    }\n+\n+    protected boolean isInvalidProperty(String propName) {\n+        // handle warnings for org.apache.openjpa.SomeString, but not for\n+        // org.apache.openjpa.some.subpackage.SomeString, since it might be valid for some\n+        // specific implementation of OpenJPA\n+        return propName.toLowerCase().startsWith(\"org.apache.openjpa.\")\n+            && propName.length() > 5\n+            && propName.indexOf('.', 5) == -1;\n+    }\n+\n+    public Log getConfigurationLog() {\n+        return getLog(LOG_RUNTIME);\n+\t}\n+}"},{"sha":"6a72fa225b9cab910214eb5b54b8c5aca8fd986c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersion.java","status":"modified","additions":97,"deletions":58,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersion.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersion.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,58 +1,97 @@\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.io.File;\r\n-import java.util.Date;\r\n-import java.util.StringTokenizer;\r\n-\r\n-/**\r\n- * This class contains version information for Kodo. It uses\r\n- * Ant's filter tokens to convert the template into a java\r\n- * file with current information.\r\n- *\r\n- * @author Marc Prud'hommeaux, Patrick Linskey\r\n- */\r\n-public class OpenJPAVersion {\r\n-\r\n-    public static final String VERSION_NUMBER = \"4.1.0EA1\";\r\n-    private static final long RELEASE_SECONDS = 1147454303;\r\n-    public static final Date RELEASE_DATE = new Date(RELEASE_SECONDS * 1000);\r\n-    public static final String VERSION_ID = \"kodo-4.1.0EA1-20060710-0004\";\r\n-    public static final String VENDOR_NAME = \"BEA\";\r\n-    public static final int MAJOR_RELEASE = 4;\r\n-    public static final int MINOR_RELEASE = 1;\r\n-    public static final int PATCH_RELEASE = 0;\r\n-    public static final String RELEASE_STATUS = \"EA1\";\r\n-\r\n-    public static void main(String [] args) {\r\n-        System.out.println(new OpenJPAVersion().toString());\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        StringBuffer buf = new StringBuffer(80 * 30);\r\n-        buf.append(\"Kodo\");\r\n-        buf.append(VERSION_NUMBER);\r\n-        buf.append(\"\\n\");\r\n-        buf.append(\"version id: \").append(VERSION_ID);\r\n-        buf.append(\"\\n\\n\");\r\n-        getProperty(\"os.name\", buf).append(\"\\n\");\r\n-        getProperty(\"os.version\", buf).append(\"\\n\");\r\n-        getProperty(\"os.arch\", buf).append(\"\\n\\n\");\r\n-        getProperty(\"java.version\", buf).append(\"\\n\");\r\n-        getProperty(\"java.vendor\", buf).append(\"\\n\\n\");\r\n-        buf.append(\"java.class.path:\\n\");\r\n-        StringTokenizer tok = new StringTokenizer\r\n-            (System.getProperty(\"java.class.path\"), File.pathSeparator);\r\n-        while (tok.hasMoreTokens()) {\r\n-            buf.append(\"\\t\").append(tok.nextToken());\r\n-            buf.append(\"\\n\");\r\n-        }\r\n-        buf.append(\"\\n\");\r\n-        getProperty(\"user.dir\", buf);\r\n-        return buf.toString();\r\n-    }\r\n-\r\n-    private StringBuffer getProperty(String prop, StringBuffer buf) {\r\n-        buf.append(prop).append(\": \").append(System.getProperty(prop));\r\n-        return buf;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.io.File;\n+import java.util.Date;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * This class contains version information for OpenJPA. It uses\n+ * Ant's filter tokens to convert the template into a java\n+ * file with current information.\n+ *\n+ * @author Marc Prud'hommeaux, Patrick Linskey\n+ */\n+public class OpenJPAVersion {\n+\n+    public static final String VERSION_NUMBER = OpenJPAVersion.class\n+        .getPackage().getImplementationVersion() == null ? \"0.0.0\" :\n+        OpenJPAVersion.class.getPackage().getImplementationVersion();\n+    private static final long RELEASE_SECONDS = 1147454303;\n+\n+    public static final Date RELEASE_DATE = new Date(RELEASE_SECONDS * 1000);\n+\n+    public static final String VERSION_ID = VERSION_NUMBER;\n+    public static final String VENDOR_NAME =\n+        OpenJPAVersion.class.getPackage().getImplementationVendor();\n+    public static final int MAJOR_RELEASE;\n+    public static final int MINOR_RELEASE;\n+    public static final int PATCH_RELEASE;\n+    public static final String RELEASE_STATUS;\n+\n+    static {\n+\n+        java.util.StringTokenizer tok =\n+            new java.util.StringTokenizer(VERSION_NUMBER,\n+                \".ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\");\n+        MAJOR_RELEASE =\n+            tok.hasMoreTokens() ? Integer.parseInt(tok.nextToken()) : 0;\n+        MINOR_RELEASE =\n+            tok.hasMoreTokens() ? Integer.parseInt(tok.nextToken()) : 0;\n+        PATCH_RELEASE =\n+            tok.hasMoreTokens() ? Integer.parseInt(tok.nextToken()) : 0;\n+        RELEASE_STATUS = tok.hasMoreTokens() ? tok.nextToken(\".\") : \"\";\n+    }\n+\n+    public static void main(String [] args) {\n+        System.out.println(new OpenJPAVersion().toString());\n+    }\n+\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer(80 * 30);\n+        buf.append(\"OpenJPA\");\n+        buf.append(VERSION_NUMBER);\n+        buf.append(\"\\n\");\n+        buf.append(\"version id: \").append(VERSION_ID);\n+        buf.append(\"\\n\\n\");\n+\n+        getProperty(\"os.name\", buf).append(\"\\n\");\n+        getProperty(\"os.version\", buf).append(\"\\n\");\n+        getProperty(\"os.arch\", buf).append(\"\\n\\n\");\n+\n+        getProperty(\"java.version\", buf).append(\"\\n\");\n+        getProperty(\"java.vendor\", buf).append(\"\\n\\n\");\n+\n+        buf.append(\"java.class.path:\\n\");\n+        StringTokenizer tok = new StringTokenizer\n+            (System.getProperty(\"java.class.path\"), File.pathSeparator);\n+        while (tok.hasMoreTokens()) {\n+            buf.append(\"\\t\").append(tok.nextToken());\n+            buf.append(\"\\n\");\n+        }\n+        buf.append(\"\\n\");\n+\n+        getProperty(\"user.dir\", buf);\n+\n+        return buf.toString();\n+    }\n+\n+    private StringBuffer getProperty(String prop, StringBuffer buf) {\n+        buf.append(prop).append(\": \").append(System.getProperty(prop));\n+        return buf;\n+    }\n+}"},{"sha":"1638165a942e93c2486a77239091bde630028b35","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivation.java","status":"modified","additions":7,"deletions":4,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivation.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,10 +1,13 @@\n /*\r\n  * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  * you may not use this file except in compliance with the License.\r\n  * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  * See the License for the specific language governing permissions and\r\n@@ -41,7 +44,7 @@\n \r\n     /**\r\n      * Provides the instance with a callback to mutate the initial properties\r\n-     * of the {@link ConfigurationProvider}. This is primarily to alter or\r\n+     * of the {@link ConfigurationProvider}.  This is primarily to alter or\r\n      * add properties that determine what type of configuration is constructed,\r\n      * and therefore is typically used at runtime only.\r\n      */\r"},{"sha":"0a7f5bbdeb617cbb9470cf6fe78130f15a235fce","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivations.java","status":"modified","additions":134,"deletions":123,"changes":257,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivations.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivations.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,123 +1,134 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Collections;\r\n-import java.util.Comparator;\r\n-import java.util.List;\r\n-\r\n-import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n-import org.apache.openjpa.lib.util.Services;\r\n-\r\n-/**\r\n- * Utilities for running product derivations.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class ProductDerivations {\r\n-\r\n-    private static final ProductDerivation[] _derivations;\r\n-\r\n-    static {\r\n-        Class[] pdcls = Services.getImplementorClasses(ProductDerivation.class);\r\n-        List derivations = new ArrayList(pdcls.length);\r\n-        for (int i = 0; i < pdcls.length; i++) {\r\n-            try {\r\n-                derivations.add(pdcls[i].newInstance());\r\n-            } catch (Throwable t) {\r\n-                // invalid service\r\n-            }\r\n-        }\r\n-        Collections.sort(derivations, new ProductDerivationComparator());\r\n-        _derivations = (ProductDerivation[]) derivations.toArray\r\n-            (new ProductDerivation[derivations.size()]);\r\n-    }\r\n-\r\n-    /**\r\n-     * Apply {@link ProductDerivation#beforeConfigurationConstruct} callbacks\r\n-     * to the the given instance. Exceptions are swallowed.\r\n-     */\r\n-    public static void beforeConfigurationConstruct(ConfigurationProvider cp) {\r\n-        for (int i = 0; i < _derivations.length; i++) {\r\n-            try {\r\n-                _derivations[i].beforeConfigurationConstruct(cp);\r\n-            } catch (Exception e) {\r\n-                // can't log; no configuration yet\r\n-                e.printStackTrace();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Apply {@link ProductDerivation#beforeConfigurationLoad} callbacks\r\n-     * to the the given instance. Exceptions are swallowed.\r\n-     */\r\n-    public static void beforeConfigurationLoad(OpenJPAConfiguration conf) {\r\n-        for (int i = 0; i < _derivations.length; i++) {\r\n-            try {\r\n-                _derivations[i].beforeConfigurationLoad(conf);\r\n-            } catch (Exception e) {\r\n-                // logging not configured yet\r\n-                e.printStackTrace();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Apply {@link ProductDerivation#afterSpecificationSet} callbacks\r\n-     * to the the given instance. Exceptions are swallowed.\r\n-     */\r\n-    public static void afterSpecificationSet(OpenJPAConfiguration conf) {\r\n-        for (int i = 0; i < _derivations.length; i++) {\r\n-            try {\r\n-                _derivations[i].afterSpecificationSet(conf);\r\n-            } catch (Exception e) {\r\n-                // logging not configured yet\r\n-                e.printStackTrace();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Apply {@link ProductDerivation#afterClose} callbacks\r\n-     * to the the given instance. Exceptions are swallowed.\r\n-     */\r\n-    public static void afterClose(OpenJPAConfigurationImpl impl) {\r\n-        for (int i = 0; i < _derivations.length; i++) {\r\n-            try {\r\n-                _derivations[i].afterClose(impl);\r\n-            } catch (Exception e) {\r\n-                // logging not available\r\n-                e.printStackTrace();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Compare {@link ProductDerivation}s.\r\n-     */\r\n-    private static class ProductDerivationComparator implements Comparator {\r\n-\r\n-        public int compare(Object o1, Object o2) {\r\n-            int type1 = ((ProductDerivation) o1).getType();\r\n-            int type2 = ((ProductDerivation) o2).getType();\r\n-            if (type1 != type2)\r\n-                return type1 - type2;\r\n-            // arbitrary but consistent order\r\n-            return o1.getClass().getName().compareTo(o2.getClass(). getName());\r\n-        }\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\n+import org.apache.openjpa.lib.util.Services;\n+\n+/**\n+ * <p>Utilities for running product derivations.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ProductDerivations {\n+\n+    private static final ProductDerivation[] _derivations;\n+\n+    static {\n+        Class[] pdcls = Services.getImplementorClasses(ProductDerivation.class);\n+        List derivations = new ArrayList(pdcls.length);\n+        for (int i = 0; i < pdcls.length; i++) {\n+            try {\n+                derivations.add(pdcls[i].newInstance());\n+            }\n+            catch (Throwable t) {\n+                // invalid service\n+            }\n+        }\n+        Collections.sort(derivations, new ProductDerivationComparator());\n+        _derivations = (ProductDerivation[]) derivations.toArray\n+            (new ProductDerivation[derivations.size()]);\n+    }\n+\n+    /**\n+     * Apply {@link ProductDerivation#beforeConfigurationConstruct} callbacks\n+     * to the the given instance.  Exceptions are swallowed.\n+     */\n+    public static void beforeConfigurationConstruct(ConfigurationProvider cp) {\n+        for (int i = 0; i < _derivations.length; i++) {\n+            try {\n+                _derivations[i].beforeConfigurationConstruct(cp);\n+            }\n+            catch (Exception e) {\n+                // can't log; no configuration yet\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Apply {@link ProductDerivation#beforeConfigurationLoad} callbacks\n+     * to the the given instance.  Exceptions are swallowed.\n+     */\n+    public static void beforeConfigurationLoad(OpenJPAConfiguration conf) {\n+        for (int i = 0; i < _derivations.length; i++) {\n+            try {\n+                _derivations[i].beforeConfigurationLoad(conf);\n+            }\n+            catch (Exception e) {\n+                // logging not configured yet\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Apply {@link ProductDerivation#afterSpecificationSet} callbacks\n+     * to the the given instance.  Exceptions are swallowed.\n+     */\n+    public static void afterSpecificationSet(OpenJPAConfiguration conf) {\n+        for (int i = 0; i < _derivations.length; i++) {\n+            try {\n+                _derivations[i].afterSpecificationSet(conf);\n+            }\n+            catch (Exception e) {\n+                // logging not configured yet\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Apply {@link ProductDerivation#afterClose} callbacks\n+     * to the the given instance.  Exceptions are swallowed.\n+     */\n+    public static void afterClose(OpenJPAConfigurationImpl impl) {\n+        for (int i = 0; i < _derivations.length; i++) {\n+            try {\n+                _derivations[i].afterClose(impl);\n+            }\n+            catch (Exception e) {\n+                // logging not available\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\tCompare {@link ProductDerivation}s.\n+     */\n+    private static class ProductDerivationComparator\n+        implements Comparator {\n+\n+        public int compare(Object o1, Object o2) {\n+            int type1 = ((ProductDerivation) o1).getType();\n+            int type2 = ((ProductDerivation) o2).getType();\n+            if (type1 != type2)\n+                return type1 - type2;\n+\n+            // arbitrary but consistent order\n+            return o1.getClass().getName().compareTo(o2.getClass().\n+                getName());\n+\t\t}\n+\t}\n+}\n+"},{"sha":"8045519808c87f88fcbcb7dae53b02ab40951899","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/RemoteCommitProviderValue.java","status":"modified","additions":139,"deletions":132,"changes":271,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/RemoteCommitProviderValue.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/RemoteCommitProviderValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/RemoteCommitProviderValue.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,132 +1,139 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.event.RemoteCommitEventManager;\r\n-import org.apache.openjpa.event.RemoteCommitProvider;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.Configurations;\r\n-import org.apache.openjpa.lib.conf.PluginValue;\r\n-import org.apache.openjpa.lib.util.Options;\r\n-\r\n-/**\r\n- * Value type used to represent a {@link RemoteCommitProvider}. This\r\n- * plugin allows users to specify whether to transmit the ids of added objects\r\n- * in the remote commit events distributed.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class RemoteCommitProviderValue extends PluginValue {\r\n-\r\n-    private static final String[] ALIASES = new String[]{\r\n-        \"sjvm\", \"org.apache.openjpa.event.SingleJVMRemoteCommitProvider\",\r\n-        \"jms\", \"org.apache.openjpa.event.JMSRemoteCommitProvider\",\r\n-        \"tcp\", \"org.apache.openjpa.event.TCPRemoteCommitProvider\", };\r\n-    private Options _opts = null;\r\n-    private Boolean _transmitPersIds = null;\r\n-\r\n-    public RemoteCommitProviderValue(String prop) {\r\n-        super(prop, true);\r\n-        setAliases(ALIASES);\r\n-    }\r\n-\r\n-    public void setProperties(String props) {\r\n-        super.setProperties(props);\r\n-        _opts = null;\r\n-        _transmitPersIds = null;\r\n-    }\r\n-\r\n-    public void setString(String str) {\r\n-        super.setString(str);\r\n-        _opts = null;\r\n-        _transmitPersIds = null;\r\n-    }\r\n-\r\n-    /**\r\n-     * The cached provider.\r\n-     */\r\n-    public RemoteCommitProvider getProvider() {\r\n-        return (RemoteCommitProvider) get();\r\n-    }\r\n-\r\n-    /**\r\n-     * The cached provider.\r\n-     */\r\n-    public void setProvider(RemoteCommitProvider provider) {\r\n-        set(provider);\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to transmit persisted object ids in remote commit events.\r\n-     */\r\n-    public boolean getTransmitPersistedObjectIds() {\r\n-        return Boolean.TRUE.equals(_transmitPersIds);\r\n-    }\r\n-\r\n-    /**\r\n-     * The cached decorators.\r\n-     */\r\n-    public void setTransmitPersistedObjectIds(boolean transmit) {\r\n-        _transmitPersIds = (transmit) ? Boolean.TRUE : Boolean.FALSE;\r\n-    }\r\n-\r\n-    /**\r\n-     * Instantiate the provider.\r\n-     */\r\n-    public RemoteCommitProvider instantiateProvider(Configuration conf) {\r\n-        return instantiateProvider(conf, true);\r\n-    }\r\n-\r\n-    /**\r\n-     * Instantiate the provider.\r\n-     */\r\n-    public RemoteCommitProvider instantiateProvider(Configuration conf,\r\n-        boolean fatal) {\r\n-        return (RemoteCommitProvider) instantiate(RemoteCommitProvider.class,\r\n-            conf, fatal);\r\n-    }\r\n-\r\n-    /**\r\n-     * Configure the remote event manager.\r\n-     */\r\n-    public void configureEventManager(RemoteCommitEventManager mgr) {\r\n-        parseOptions();\r\n-        if (_transmitPersIds != null)\r\n-            mgr.setTransmitPersistedObjectIds(_transmitPersIds.booleanValue());\r\n-    }\r\n-\r\n-    /**\r\n-     * Override to keep decorators out of transport configuration.\r\n-     */\r\n-    public Object instantiate(Class type, Configuration conf, boolean fatal) {\r\n-        Object obj = newInstance(getClassName(), type, conf, fatal);\r\n-        parseOptions();\r\n-        Configurations.configureInstance(obj, conf, _opts, getProperty());\r\n-        set(obj, true);\r\n-        return obj;\r\n-    }\r\n-\r\n-    private void parseOptions() {\r\n-        if (_opts != null)\r\n-            return;\r\n-        _opts = Configurations.parseProperties(getProperties());\r\n-        String transmit = _opts.removeProperty(\"transmitPersistedObjectIds\",\r\n-            \"TransmitPersistedObjectIds\", null);\r\n-        if (transmit != null) {\r\n-            transmit = transmit.trim();\r\n-            if (transmit.length() > 0)\r\n-                _transmitPersIds = Boolean.valueOf(transmit);\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.event.RemoteCommitEventManager;\n+import org.apache.openjpa.event.RemoteCommitProvider;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.lib.util.Options;\n+\n+/**\n+ * <p>Value type used to represent a {@link RemoteCommitProvider}.  This\n+ * plugin allows users to specify whether to transmit the ids of added objects\n+ * in the remote commit events distributed.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class RemoteCommitProviderValue\n+    extends PluginValue {\n+\n+    private static final String[] ALIASES = new String[]{\n+        \"sjvm\", \"org.apache.openjpa.event.SingleJVMRemoteCommitProvider\",\n+        \"jms\", \"org.apache.openjpa.event.JMSRemoteCommitProvider\",\n+        \"tcp\", \"org.apache.openjpa.event.TCPRemoteCommitProvider\",\n+    };\n+\n+    private Options _opts = null;\n+    private Boolean _transmitPersIds = null;\n+\n+    public RemoteCommitProviderValue(String prop) {\n+        super(prop, true);\n+        setAliases(ALIASES);\n+    }\n+\n+    public void setProperties(String props) {\n+        super.setProperties(props);\n+        _opts = null;\n+        _transmitPersIds = null;\n+    }\n+\n+    public void setString(String str) {\n+        super.setString(str);\n+        _opts = null;\n+        _transmitPersIds = null;\n+    }\n+\n+    /**\n+     * The cached provider.\n+     */\n+    public RemoteCommitProvider getProvider() {\n+        return (RemoteCommitProvider) get();\n+    }\n+\n+    /**\n+     * The cached provider.\n+     */\n+    public void setProvider(RemoteCommitProvider provider) {\n+        set(provider);\n+    }\n+\n+    /**\n+     * Whether to transmit persisted object ids in remote commit events.\n+     */\n+    public boolean getTransmitPersistedObjectIds() {\n+        return Boolean.TRUE.equals(_transmitPersIds);\n+    }\n+\n+    /**\n+     * The cached decorators.\n+     */\n+    public void setTransmitPersistedObjectIds(boolean transmit) {\n+        _transmitPersIds = (transmit) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Instantiate the provider.\n+     */\n+    public RemoteCommitProvider instantiateProvider(Configuration conf) {\n+        return instantiateProvider(conf, true);\n+    }\n+\n+    /**\n+     * Instantiate the provider.\n+     */\n+    public RemoteCommitProvider instantiateProvider(Configuration conf,\n+        boolean fatal) {\n+        return (RemoteCommitProvider) instantiate(RemoteCommitProvider.class,\n+            conf, fatal);\n+    }\n+\n+    /**\n+     * Configure the remote event manager.\n+     */\n+    public void configureEventManager(RemoteCommitEventManager mgr) {\n+        parseOptions();\n+        if (_transmitPersIds != null)\n+            mgr.setTransmitPersistedObjectIds(_transmitPersIds.booleanValue());\n+    }\n+\n+    /**\n+     * Override to keep decorators out of transport configuration.\n+     */\n+    public Object instantiate(Class type, Configuration conf, boolean fatal) {\n+        Object obj = newInstance(getClassName(), type, conf, fatal);\n+        parseOptions();\n+        Configurations.configureInstance(obj, conf, _opts, getProperty());\n+        set(obj, true);\n+        return obj;\n+    }\n+\n+    private void parseOptions() {\n+        if (_opts != null)\n+            return;\n+\n+        _opts = Configurations.parseProperties(getProperties());\n+        String transmit = _opts.removeProperty(\"transmitPersistedObjectIds\",\n+            \"TransmitPersistedObjectIds\", null);\n+        if (transmit != null) {\n+            transmit = transmit.trim();\n+            if (transmit.length() > 0)\n+                _transmitPersIds = Boolean.valueOf (transmit);\n+\t\t}\n+\t}\n+}"},{"sha":"75eabf51c1eddc04437a710ecb629464402774f0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/SeqValue.java","status":"modified","additions":46,"deletions":41,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/SeqValue.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/conf/SeqValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/SeqValue.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,41 +1,46 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.kernel.TimeSeededSeq;\r\n-import org.apache.openjpa.lib.conf.PluginValue;\r\n-import org.apache.openjpa.meta.SequenceMetaData;\r\n-\r\n-/**\r\n- * Value type used to represent a sequence. This type is\r\n- * defined separately so that it can be used both in the global configuration\r\n- * and in class metadata with the same encapsulated configuration.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class SeqValue extends PluginValue {\r\n-\r\n-    private static final String[] ALIASES = new String[]{\r\n-        SequenceMetaData.IMPL_TIME, TimeSeededSeq.class.getName(),\r\n-        SequenceMetaData.IMPL_NATIVE, TimeSeededSeq.class.getName(),\r\n-        // deprecated aliases\r\n-        \"sjvm\", TimeSeededSeq.class.getName(), };\r\n-\r\n-    public SeqValue(String prop) {\r\n-        super(prop, true);\r\n-        setAliases(ALIASES);\r\n-        setDefault(ALIASES[0]);\r\n-        setClassName(ALIASES[1]);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.kernel.TimeSeededSeq;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.meta.SequenceMetaData;\n+\n+/**\n+ * <p>Value type used to represent a sequence.  This type is\n+ * defined separately so that it can be used both in the global configuration\n+ * and in class metadata with the same encapsulated configuration.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class SeqValue\n+    extends PluginValue {\n+\n+    private static final String[] ALIASES = new String[]{\n+        SequenceMetaData.IMPL_TIME, TimeSeededSeq.class.getName(),\n+        SequenceMetaData.IMPL_NATIVE, TimeSeededSeq.class.getName(),\n+        // deprecated aliases\n+        \"sjvm\", TimeSeededSeq.class.getName(),\n+    };\n+\n+    public SeqValue(String prop) {\n+        super(prop, true);\n+        setAliases(ALIASES);\n+        setDefault(ALIASES[0]);\n+        setClassName(ALIASES[1]);\n+    }\n+}"},{"sha":"5a67361a047212c84f7eebfafbf55a59383c10ab","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","status":"modified","additions":430,"deletions":403,"changes":833,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,403 +1,430 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.BitSet;\r\n-import java.util.Collection;\r\n-import java.util.Iterator;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.event.RemoteCommitEvent;\r\n-import org.apache.openjpa.event.RemoteCommitListener;\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n-\r\n-/**\r\n- * Abstract {@link DataCache} implementation that provides various\r\n- * statistics, logging, and timeout functionality common across cache\r\n- * implementations.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @author Abe White\r\n- */\r\n-public abstract class AbstractDataCache extends AbstractConcurrentEventManager\r\n-    implements DataCache, Configurable {\r\n-\r\n-    private static final BitSet EMPTY_BITSET = new BitSet(0);\r\n-    private static final Localizer s_loc =\r\n-        Localizer.forPackage(AbstractDataCache.class);\r\n-\r\n-    /**\r\n-     * The configuration set by the system.\r\n-     */\r\n-    protected OpenJPAConfiguration conf;\r\n-\r\n-    /**\r\n-     * The log to use.\r\n-     */\r\n-    protected Log log;\r\n-    private String _name = null;\r\n-    private boolean _closed = false;\r\n-    private String _schedule = null;\r\n-\r\n-    public String getName() {\r\n-        return _name;\r\n-    }\r\n-\r\n-    public void setName(String name) {\r\n-        _name = name;\r\n-    }\r\n-\r\n-    public String getEvictionSchedule() {\r\n-        return _schedule;\r\n-    }\r\n-\r\n-    public void setEvictionSchedule(String s) {\r\n-        _schedule = s;\r\n-    }\r\n-\r\n-    public void initialize(DataCacheManager manager) {\r\n-        if (_schedule != null && !\"\".equals(_schedule)) {\r\n-            DataCacheScheduler scheduler = manager.getDataCacheScheduler();\r\n-            if (scheduler != null)\r\n-                scheduler.scheduleEviction(this, _schedule);\r\n-        }\r\n-    }\r\n-\r\n-    public void commit(Collection additions, Collection newUpdates,\r\n-        Collection existingUpdates, Collection deletes) {\r\n-        // remove all objects in deletes list\r\n-        removeAllInternal(deletes);\r\n-        // next, add all the new additions\r\n-        putAllInternal(additions);\r\n-        putAllInternal(newUpdates);\r\n-        // possibly add the existing updates, depending on the\r\n-        // semantics of the cache, as dictated by recacheUpdates()\r\n-        if (recacheUpdates())\r\n-            putAllInternal(existingUpdates);\r\n-        if (log.isTraceEnabled()) {\r\n-            Collection addIds = new ArrayList(additions.size());\r\n-            Collection upIds = new ArrayList(newUpdates.size());\r\n-            Collection exIds = new ArrayList(existingUpdates.size());\r\n-            for (Iterator iter = additions.iterator(); iter.hasNext();)\r\n-                addIds.add(((DataCachePCData) iter.next()).getId());\r\n-            for (Iterator iter = newUpdates.iterator(); iter.hasNext();)\r\n-                upIds.add(((DataCachePCData) iter.next()).getId());\r\n-            for (Iterator iter = existingUpdates.iterator(); iter.hasNext();)\r\n-                exIds.add(((DataCachePCData) iter.next()).getId());\r\n-            log.trace(s_loc.get(\"cache-commit\",\r\n-                new Object[]{ addIds, upIds, exIds, deletes }));\r\n-        }\r\n-    }\r\n-\r\n-    public boolean contains(Object key) {\r\n-        DataCachePCData o = getInternal(key);\r\n-        if (o != null && o.isTimedOut()) {\r\n-            o = null;\r\n-            removeInternal(key);\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-timeout\", key));\r\n-        }\r\n-        return o != null;\r\n-    }\r\n-\r\n-    public BitSet containsAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (contains(iter.next()))\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    public DataCachePCData get(Object key) {\r\n-        DataCachePCData o = getInternal(key);\r\n-        if (o != null && o.isTimedOut()) {\r\n-            o = null;\r\n-            removeInternal(key);\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-timeout\", key));\r\n-        }\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-miss\", key));\r\n-            else log.trace(s_loc.get(\"cache-hit\", key));\r\n-        }\r\n-        return o;\r\n-    }\r\n-\r\n-    public DataCachePCData put(DataCachePCData data) {\r\n-        DataCachePCData o = putInternal(data.getId(), data);\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-put\", data.getId()));\r\n-        return (o == null || o.isTimedOut()) ? null : o;\r\n-    }\r\n-\r\n-    public void update(DataCachePCData data) {\r\n-        if (recacheUpdates())\r\n-            putInternal(data.getId(), data);\r\n-    }\r\n-\r\n-    public DataCachePCData remove(Object key) {\r\n-        DataCachePCData o = removeInternal(key);\r\n-        if (o != null && o.isTimedOut())\r\n-            o = null;\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-remove-miss\", key));\r\n-            else log.trace(s_loc.get(\"cache-remove-hit\", key));\r\n-        }\r\n-        return o;\r\n-    }\r\n-\r\n-    public BitSet removeAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (remove(iter.next()) != null)\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove the objects of the given class from the cache.\r\n-     */\r\n-    public void removeAll(Class cls, boolean subClasses) {\r\n-        removeAllInternal(cls, subClasses);\r\n-    }\r\n-\r\n-    public boolean pin(Object key) {\r\n-        boolean bool = pinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-pin-hit\", key));\r\n-            else log.trace(s_loc.get(\"cache-pin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public BitSet pinAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (pin(iter.next()))\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    public boolean unpin(Object key) {\r\n-        boolean bool = unpinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-unpin-hit\", key));\r\n-            else log.trace(s_loc.get(\"cache-unpin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public BitSet unpinAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (unpin(iter.next()))\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        clearInternal();\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-clear\", getName()));\r\n-    }\r\n-\r\n-    public void close() {\r\n-        close(true);\r\n-    }\r\n-\r\n-    protected void close(boolean clear) {\r\n-        if (!_closed) {\r\n-            if (clear)\r\n-                clearInternal();\r\n-            _closed = true;\r\n-        }\r\n-    }\r\n-\r\n-    public boolean isClosed() {\r\n-        return _closed;\r\n-    }\r\n-\r\n-    public void addExpirationListener(ExpirationListener listen) {\r\n-        addListener(listen);\r\n-    }\r\n-\r\n-    public boolean removeExpirationListener(ExpirationListener listen) {\r\n-        return removeListener(listen);\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return \"[\" + super.toString() + \":\" + _name + \"]\";\r\n-    }\r\n-\r\n-    /**\r\n-     * This method is part of the {@link RemoteCommitListener} interface. If\r\n-     * your cache subclass relies on OpenJPA for clustering support, make it\r\n-     * implement <code>RemoteCommitListener</code>. This method will take\r\n-     * care of invalidating entries from remote commits.\r\n-     */\r\n-    public void afterCommit(RemoteCommitEvent event) {\r\n-        if (_closed)\r\n-            return;\r\n-        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\r\n-            removeAllTypeNamesInternal(event.getUpdatedTypeNames());\r\n-            removeAllTypeNamesInternal(event.getDeletedTypeNames());\r\n-        } else {\r\n-            // drop all the committed OIDs, excepting brand\r\n-            // new OIDs. brand new OIDs either won't be in\r\n-            // the cache, or if they are, will be more up to date\r\n-            removeAllInternal(event.getUpdatedObjectIds());\r\n-            removeAllInternal(event.getDeletedObjectIds());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Invoke when a key is removed from this cache. Propagates the\r\n-     * expiration event on to all expiration listeners registered\r\n-     * with this class.\r\n-     */\r\n-    protected void keyRemoved(Object key, boolean expired) {\r\n-        // Notify any expiration listeners of the expiration.\r\n-        if (hasListeners())\r\n-            fireEvent(new ExpirationEvent(this, key, expired));\r\n-        if (expired && log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-expired\", key));\r\n-    }\r\n-\r\n-    /**\r\n-     * Return <code>true</code> if updates to data already in the\r\n-     * cache(either in {@link #commit} or the {@link #update})\r\n-     * should be put back into the cache. Returns false by default.\r\n-     */\r\n-    protected boolean recacheUpdates() {\r\n-        return false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the object for the given oid.\r\n-     */\r\n-    protected abstract DataCachePCData getInternal(Object oid);\r\n-\r\n-    /**\r\n-     * Add the given object to the cache, returning the old object under the\r\n-     * given oid.\r\n-     */\r\n-    protected abstract DataCachePCData putInternal(Object oid,\r\n-        DataCachePCData pc);\r\n-\r\n-    /**\r\n-     * All all of the given objects to the cache.\r\n-     */\r\n-    protected void putAllInternal(Collection pcs) {\r\n-        DataCachePCData pc;\r\n-        for (Iterator iter = pcs.iterator(); iter.hasNext();) {\r\n-            pc = (DataCachePCData) iter.next();\r\n-            putInternal(pc.getId(), pc);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove the object under the given oid from the cache.\r\n-     */\r\n-    protected abstract DataCachePCData removeInternal(Object oid);\r\n-\r\n-    /**\r\n-     * Evict objects in cache by class.\r\n-     */\r\n-    protected abstract void removeAllInternal(Class cls, boolean subclasses);\r\n-\r\n-    /**\r\n-     * Remove all objects under the given oids from the cache.\r\n-     */\r\n-    protected void removeAllInternal(Collection oids) {\r\n-        for (Iterator iter = oids.iterator(); iter.hasNext();)\r\n-            removeInternal(iter.next());\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove all objects of the given class names from the cache.\r\n-     */\r\n-    protected void removeAllTypeNamesInternal(Collection classNames) {\r\n-        Collection classes = Caches.addTypesByName(conf, classNames, null);\r\n-        if (classes == null)\r\n-            return;\r\n-        Class cls;\r\n-        for (Iterator iter = classes.iterator(); iter.hasNext();) {\r\n-            cls = (Class) iter.next();\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-removeclass\", cls.getName()));\r\n-            removeAllInternal(cls, false);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Clear the cache.\r\n-     */\r\n-    protected abstract void clearInternal();\r\n-\r\n-    /**\r\n-     * Pin an object to the cache.\r\n-     */\r\n-    protected abstract boolean pinInternal(Object oid);\r\n-\r\n-    /**\r\n-     * Unpin an object from the cache.\r\n-     */\r\n-    protected abstract boolean unpinInternal(Object oid);\r\n-\r\n-    // ---------- Configurable implementation ----------\r\n-    public void setConfiguration(Configuration conf) {\r\n-        this.conf = (OpenJPAConfiguration) conf;\r\n-        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-        if (_name == null)\r\n-            setName(NAME_DEFAULT);\r\n-    }\r\n-\r\n-    // ---------- AbstractEventManager implementation ----------\r\n-    protected void fireEvent(Object event, Object listener) {\r\n-        ExpirationListener listen = (ExpirationListener) listener;\r\n-        ExpirationEvent ev = (ExpirationEvent) event;\r\n-        try {\r\n-            listen.onExpire(ev);\r\n-        } catch (Exception e) {\r\n-            if (log.isWarnEnabled())\r\n-                log.warn(s_loc.get(\"exp-listener-ex\"), e);\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.event.RemoteCommitEvent;\n+import org.apache.openjpa.event.RemoteCommitListener;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\n+\n+/**\n+ * Abstract {@link DataCache} implementation that provides various\n+ * statistics, logging, and timeout functionality common across cache\n+ * implementations.\n+ *\n+ * @author Patrick Linskey\n+ * @author Abe White\n+ */\n+public abstract class AbstractDataCache\n+    extends AbstractConcurrentEventManager\n+    implements DataCache, Configurable {\n+\n+    private static final BitSet EMPTY_BITSET = new BitSet(0);\n+\n+    private static final Localizer s_loc =\n+        Localizer.forPackage(AbstractDataCache.class);\n+\n+    /**\n+     * The configuration set by the system.\n+     */\n+    protected OpenJPAConfiguration conf;\n+\n+    /**\n+     * The log to use.\n+     */\n+    protected Log log;\n+\n+    private String _name = null;\n+    private boolean _closed = false;\n+    private String _schedule = null;\n+\n+    public String getName() {\n+        return _name;\n+    }\n+\n+    public void setName(String name) {\n+        _name = name;\n+    }\n+\n+    public String getEvictionSchedule() {\n+        return _schedule;\n+    }\n+\n+    public void setEvictionSchedule(String s) {\n+        _schedule = s;\n+    }\n+\n+    public void initialize(DataCacheManager manager) {\n+        if (_schedule != null && !\"\".equals(_schedule)) {\n+            DataCacheScheduler scheduler = manager.getDataCacheScheduler();\n+            if (scheduler != null)\n+                scheduler.scheduleEviction(this, _schedule);\n+        }\n+    }\n+\n+    public void commit(Collection additions, Collection newUpdates,\n+        Collection existingUpdates, Collection deletes) {\n+        // remove all objects in deletes list\n+        removeAllInternal(deletes);\n+\n+        // next, add all the new additions\n+        putAllInternal(additions);\n+        putAllInternal(newUpdates);\n+\n+        // possibly add the existing updates, depending on the\n+        // semantics of the cache, as dictated by recacheUpdates()\n+        if (recacheUpdates())\n+            putAllInternal(existingUpdates);\n+\n+        if (log.isTraceEnabled()) {\n+            Collection addIds = new ArrayList(additions.size());\n+            Collection upIds = new ArrayList(newUpdates.size());\n+            Collection exIds = new ArrayList(existingUpdates.size());\n+\n+            for (Iterator iter = additions.iterator(); iter.hasNext();)\n+                addIds.add(((DataCachePCData) iter.next()).getId());\n+            for (Iterator iter = newUpdates.iterator(); iter.hasNext();)\n+                upIds.add(((DataCachePCData) iter.next()).getId());\n+            for (Iterator iter = existingUpdates.iterator(); iter.hasNext();)\n+                exIds.add(((DataCachePCData) iter.next()).getId());\n+\n+            log.trace(s_loc.get(\"cache-commit\",\n+                new Object[]{ addIds, upIds, exIds, deletes }));\n+        }\n+    }\n+\n+    public boolean contains(Object key) {\n+        DataCachePCData o = getInternal(key);\n+        if (o != null && o.isTimedOut()) {\n+            o = null;\n+            removeInternal(key);\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-timeout\", key));\n+        }\n+        return o != null;\n+    }\n+\n+    public BitSet containsAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (contains(iter.next()))\n+                set.set(i);\n+        return set;\n+    }\n+\n+    public DataCachePCData get(Object key) {\n+        DataCachePCData o = getInternal(key);\n+        if (o != null && o.isTimedOut()) {\n+            o = null;\n+            removeInternal(key);\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-timeout\", key));\n+        }\n+\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-hit\", key));\n+        }\n+\n+        return o;\n+    }\n+\n+    public DataCachePCData put(DataCachePCData data) {\n+        DataCachePCData o = putInternal(data.getId(), data);\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-put\", data.getId()));\n+        return (o == null || o.isTimedOut()) ? null : o;\n+    }\n+\n+    public void update(DataCachePCData data) {\n+        if (recacheUpdates())\n+            putInternal(data.getId(), data);\n+    }\n+\n+    public DataCachePCData remove(Object key) {\n+        DataCachePCData o = removeInternal(key);\n+        if (o != null && o.isTimedOut())\n+            o = null;\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-remove-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-remove-hit\", key));\n+        }\n+        return o;\n+    }\n+\n+    public BitSet removeAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (remove(iter.next()) != null)\n+                set.set(i);\n+        return set;\n+    }\n+\n+    /**\n+     * Remove the objects of the given class from the cache.\n+     */\n+    public void removeAll(Class cls, boolean subClasses) {\n+        removeAllInternal(cls, subClasses);\n+    }\n+\n+    public boolean pin(Object key) {\n+        boolean bool = pinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-pin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-pin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public BitSet pinAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (pin(iter.next()))\n+                set.set(i);\n+        return set;\n+    }\n+\n+    public boolean unpin(Object key) {\n+        boolean bool = unpinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-unpin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-unpin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public BitSet unpinAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (unpin(iter.next()))\n+                set.set(i);\n+        return set;\n+    }\n+\n+    public void clear() {\n+        clearInternal();\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-clear\", getName()));\n+    }\n+\n+    public void close() {\n+        close(true);\n+    }\n+\n+    protected void close(boolean clear) {\n+        if (!_closed) {\n+            if (clear)\n+                clearInternal();\n+            _closed = true;\n+        }\n+    }\n+\n+    public boolean isClosed() {\n+        return _closed;\n+    }\n+\n+    public void addExpirationListener(ExpirationListener listen) {\n+        addListener(listen);\n+    }\n+\n+    public boolean removeExpirationListener(ExpirationListener listen) {\n+        return removeListener(listen);\n+    }\n+\n+    public String toString() {\n+        return \"[\" + super.toString() + \":\" + _name + \"]\";\n+    }\n+\n+    /**\n+     * This method is part of the {@link RemoteCommitListener} interface.  If\n+     * your cache subclass relies on OpenJPA for clustering support, make it\n+     * implement <code>RemoteCommitListener</code>.  This method will take\n+     * care of invalidating entries from remote commits.\n+     */\n+    public void afterCommit(RemoteCommitEvent event) {\n+        if (_closed)\n+            return;\n+\n+        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\n+            removeAllTypeNamesInternal(event.getUpdatedTypeNames());\n+            removeAllTypeNamesInternal(event.getDeletedTypeNames());\n+        } else {\n+            // drop all the committed OIDs, excepting brand\n+            // new OIDs. brand new OIDs either won't be in\n+            // the cache, or if they are, will be more up to date\n+            removeAllInternal(event.getUpdatedObjectIds());\n+            removeAllInternal(event.getDeletedObjectIds());\n+        }\n+    }\n+\n+    /**\n+     * Invoke when a key is removed from this cache. Propagates the\n+     * expiration event on to all expiration listeners registered\n+     * with this class.\n+     */\n+    protected void keyRemoved(Object key, boolean expired) {\n+        // Notify any expiration listeners of the expiration.\n+        if (hasListeners())\n+            fireEvent(new ExpirationEvent(this, key, expired));\n+\n+        if (expired && log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-expired\", key));\n+    }\n+\n+    /**\n+     * Return <code>true</code> if updates to data already in the\n+     * cache (either in {@link #commit} or the {@link #update})\n+     * should be put back into the cache.  Returns false by default.\n+     */\n+    protected boolean recacheUpdates() {\n+        return false;\n+    }\n+\n+    /**\n+     * Return the object for the given oid.\n+     */\n+    protected abstract DataCachePCData getInternal(Object oid);\n+\n+    /**\n+     * Add the given object to the cache, returning the old object under the\n+     * given oid.\n+     */\n+    protected abstract DataCachePCData putInternal(Object oid,\n+        DataCachePCData pc);\n+\n+    /**\n+     * All all of the given objects to the cache.\n+     */\n+    protected void putAllInternal(Collection pcs) {\n+        DataCachePCData pc;\n+        for (Iterator iter = pcs.iterator(); iter.hasNext();) {\n+            pc = (DataCachePCData) iter.next();\n+            putInternal(pc.getId(), pc);\n+        }\n+    }\n+\n+    /**\n+     * Remove the object under the given oid from the cache.\n+     */\n+    protected abstract DataCachePCData removeInternal(Object oid);\n+\n+    /**\n+     * Evict objects in cache by class.\n+     */\n+    protected abstract void removeAllInternal(Class cls, boolean subclasses);\n+\n+    /**\n+     * Remove all objects under the given oids from the cache.\n+     */\n+    protected void removeAllInternal(Collection oids) {\n+        for (Iterator iter = oids.iterator(); iter.hasNext();)\n+            removeInternal(iter.next());\n+    }\n+\n+    /**\n+     * Remove all objects of the given class names from the cache.\n+     */\n+    protected void removeAllTypeNamesInternal(Collection classNames) {\n+        Collection classes = Caches.addTypesByName(conf, classNames, null);\n+        if (classes == null)\n+            return;\n+\n+        Class cls;\n+        for (Iterator iter = classes.iterator(); iter.hasNext();) {\n+            cls = (Class) iter.next();\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-removeclass\", cls.getName()));\n+            removeAllInternal(cls, false);\n+        }\n+    }\n+\n+    /**\n+     * Clear the cache.\n+     */\n+    protected abstract void clearInternal();\n+\n+    /**\n+     * Pin an object to the cache.\n+     */\n+    protected abstract boolean pinInternal(Object oid);\n+\n+    /**\n+     * Unpin an object from the cache.\n+     */\n+    protected abstract boolean unpinInternal(Object oid);\n+\n+    // ---------- Configurable implementation ----------\n+\n+    public void setConfiguration(Configuration conf) {\n+        this.conf = (OpenJPAConfiguration) conf;\n+        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+        if (_name == null)\n+            setName(NAME_DEFAULT);\n+    }\n+\n+    // ---------- AbstractEventManager implementation ----------\n+\n+    protected void fireEvent(Object event, Object listener) {\n+        ExpirationListener listen = (ExpirationListener) listener;\n+        ExpirationEvent ev = (ExpirationEvent) event;\n+        try {\n+            listen.onExpire(ev);\n+        }\n+        catch (Exception e) {\n+            if (log.isWarnEnabled())\n+                log.warn(s_loc.get (\"exp-listener-ex\"), e);\n+\t\t}\n+\t}\n+}"},{"sha":"58fde027b8a7f7e39286062368a01375bc8748d8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","status":"modified","additions":322,"deletions":307,"changes":629,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,307 +1,322 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.event.RemoteCommitEvent;\r\n-import org.apache.openjpa.event.RemoteCommitListener;\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.AbstractEventManager;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.ReferenceHashSet;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.util.Id;\r\n-\r\n-/**\r\n- * Abstract {@link QueryCache} implementation that provides various\r\n- * statistics, logging, and timeout functionality common across cache\r\n- * implementations.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @author Abe White\r\n- */\r\n-public abstract class AbstractQueryCache\r\n-    extends AbstractEventManager //### use concurrent; need to mod OpenJPA\r\n-    implements QueryCache, Configurable {\r\n-\r\n-    private static final Localizer s_loc =\r\n-        Localizer.forPackage(AbstractQueryCache.class);\r\n-\r\n-    /**\r\n-     * The configuration set by the system.\r\n-     */\r\n-    protected OpenJPAConfiguration conf;\r\n-\r\n-    /**\r\n-     * The log to use.\r\n-     */\r\n-    protected Log log;\r\n-    private boolean _closed = false;\r\n-\r\n-    public void initialize(DataCacheManager manager) {\r\n-    }\r\n-\r\n-    public void onTypesChanged(TypesChangedEvent ev) {\r\n-        writeLock();\r\n-        Collection keys = null;\r\n-        try {\r\n-            if (hasListeners())\r\n-                fireEvent(ev);\r\n-            keys = keySet();\r\n-        }\r\n-        finally {\r\n-            writeUnlock();\r\n-        }\r\n-        QueryKey qk;\r\n-        List removes = null;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext();) {\r\n-            qk = (QueryKey) iter.next();\r\n-            if (qk.changeInvalidatesQuery(ev.getTypes())) {\r\n-                if (removes == null)\r\n-                    removes = new ArrayList();\r\n-                removes.add(qk);\r\n-            }\r\n-        }\r\n-        if (removes != null)\r\n-            removeAllInternal(removes);\r\n-    }\r\n-\r\n-    public QueryResult get(QueryKey key) {\r\n-        QueryResult o = getInternal(key);\r\n-        if (o != null && o.isTimedOut()) {\r\n-            o = null;\r\n-            removeInternal(key);\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-timeout\", key));\r\n-        }\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-miss\", key));\r\n-            else log.trace(s_loc.get(\"cache-hit\", key));\r\n-        }\r\n-        return o;\r\n-    }\r\n-\r\n-    public QueryResult put(QueryKey qk, QueryResult oids) {\r\n-        QueryResult o = putInternal(qk, oids);\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-put\", qk));\r\n-        return (o == null || o.isTimedOut()) ? null : o;\r\n-    }\r\n-\r\n-    public QueryResult remove(QueryKey key) {\r\n-        QueryResult o = removeInternal(key);\r\n-        if (o != null && o.isTimedOut())\r\n-            o = null;\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-remove-miss\", key));\r\n-            else log.trace(s_loc.get(\"cache-remove-hit\", key));\r\n-        }\r\n-        return o;\r\n-    }\r\n-\r\n-    public boolean pin(QueryKey key) {\r\n-        boolean bool = pinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-pin-hit\", key));\r\n-            else log.trace(s_loc.get(\"cache-pin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public boolean unpin(QueryKey key) {\r\n-        boolean bool = unpinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-unpin-hit\", key));\r\n-            else log.trace(s_loc.get(\"cache-unpin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        clearInternal();\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-clear\", \"<query-cache>\"));\r\n-    }\r\n-\r\n-    public void close() {\r\n-        close(true);\r\n-    }\r\n-\r\n-    protected void close(boolean clear) {\r\n-        if (!_closed) {\r\n-            if (clear)\r\n-                clearInternal();\r\n-            _closed = true;\r\n-        }\r\n-    }\r\n-\r\n-    public boolean isClosed() {\r\n-        return _closed;\r\n-    }\r\n-\r\n-    public void addTypesChangedListener(TypesChangedListener listen) {\r\n-        addListener(listen);\r\n-    }\r\n-\r\n-    public boolean removeTypesChangedListener(TypesChangedListener listen) {\r\n-        return removeListener(listen);\r\n-    }\r\n-\r\n-    /**\r\n-     * This method is part of the {@link RemoteCommitListener} interface. If\r\n-     * your cache subclass relies on OpenJPA for clustering support, make it\r\n-     * implement <code>RemoteCommitListener</code>. This method will take\r\n-     * care of invalidating entries from remote commits, by delegating to\r\n-     * {@link #typesChanged}.\r\n-     */\r\n-    public void afterCommit(RemoteCommitEvent event) {\r\n-        if (_closed)\r\n-            return;\r\n-        // drop all committed classes\r\n-        Set classes = Caches.addTypesByName(conf,\r\n-            event.getPersistedTypeNames(), null);\r\n-        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\r\n-            classes = Caches.addTypesByName(conf, event.getUpdatedTypeNames(),\r\n-                classes);\r\n-            classes = Caches.addTypesByName(conf, event.getDeletedTypeNames(),\r\n-                classes);\r\n-        } else {\r\n-            classes = addTypes(event.getUpdatedObjectIds(), classes);\r\n-            classes = addTypes(event.getDeletedObjectIds(), classes);\r\n-        }\r\n-        if (classes != null)\r\n-            onTypesChanged(new TypesChangedEvent(this, classes));\r\n-    }\r\n-\r\n-    /**\r\n-     * Build up a set of classes for the given oids.\r\n-     */\r\n-    private Set addTypes(Collection oids, Set classes) {\r\n-        if (oids.isEmpty())\r\n-            return classes;\r\n-        if (classes == null)\r\n-            classes = new HashSet();\r\n-        MetaDataRepository repos = conf.getMetaDataRepository();\r\n-        ClassMetaData meta;\r\n-        Object oid;\r\n-        for (Iterator itr = oids.iterator(); itr.hasNext();) {\r\n-            oid = itr.next();\r\n-            if (oid instanceof Id)\r\n-                classes.add(((Id) oid).getType());\r\n-            else {\r\n-                // ok if no metadata for oid; that just means the pc type\r\n-                // probably hasn't been loaded into this JVM yet, and therefore\r\n-                // there's no chance that it's in the cache anyway\r\n-                meta = repos.getMetaData(oid, null, false);\r\n-                if (meta != null)\r\n-                    classes.add(meta.getDescribedType());\r\n-            }\r\n-        }\r\n-        return classes;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a threadsafe view of the keys in this cache. This collection\r\n-     * must be iterable without risk of concurrent modification exceptions.\r\n-     * It does not have to implement contains() efficiently or use set\r\n-     * semantics.\r\n-     */\r\n-    protected abstract Collection keySet();\r\n-\r\n-    /**\r\n-     * Return the list for the given key.\r\n-     */\r\n-    protected abstract QueryResult getInternal(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Add the given result to the cache, returning the old result under the\r\n-     * given key.\r\n-     */\r\n-    protected abstract QueryResult putInternal(QueryKey qk, QueryResult oids);\r\n-\r\n-    /**\r\n-     * Remove the result under the given key from the cache.\r\n-     */\r\n-    protected abstract QueryResult removeInternal(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Remove all results under the given keys from the cache.\r\n-     */\r\n-    protected void removeAllInternal(Collection qks) {\r\n-        for (Iterator iter = qks.iterator(); iter.hasNext();)\r\n-            removeInternal((QueryKey) iter.next());\r\n-    }\r\n-\r\n-    /**\r\n-     * Clear the cache.\r\n-     */\r\n-    protected abstract void clearInternal();\r\n-\r\n-    /**\r\n-     * Pin an object to the cache.\r\n-     */\r\n-    protected abstract boolean pinInternal(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Unpin an object from the cache.\r\n-     */\r\n-    protected abstract boolean unpinInternal(QueryKey qk);\r\n-\r\n-    // ---------- Configurable implementation ----------\r\n-    public void setConfiguration(Configuration conf) {\r\n-        this.conf = (OpenJPAConfiguration) conf;\r\n-        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-    }\r\n-\r\n-    // ---------- AbstractEventManager implementation ----------\r\n-    protected void fireEvent(Object event, Object listener) {\r\n-        TypesChangedListener listen = (TypesChangedListener) listener;\r\n-        TypesChangedEvent ev = (TypesChangedEvent) event;\r\n-        try {\r\n-            listen.onTypesChanged(ev);\r\n-        } catch (Exception e) {\r\n-            if (log.isWarnEnabled())\r\n-                log.warn(s_loc.get(\"exp-listener-ex\"), e);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Individual query results will be registered as types changed\r\n-     * listeners. We want such query results to be gc'd once\r\n-     * the only reference is held by the list of expiration listeners.\r\n-     */\r\n-    protected Collection newListenerCollection() {\r\n-        //### use concurrent\r\n-        return new ReferenceHashSet(ReferenceHashSet.WEAK);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.event.RemoteCommitEvent;\n+import org.apache.openjpa.event.RemoteCommitListener;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.AbstractEventManager;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.ReferenceHashSet;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.util.Id;\n+\n+/**\n+ * Abstract {@link QueryCache} implementation that provides various\n+ * statistics, logging, and timeout functionality common across cache\n+ * implementations.\n+ *\n+ * @author Patrick Linskey\n+ * @author Abe White\n+ */\n+public abstract class AbstractQueryCache\n+    extends AbstractEventManager //### use concurrent; need to mod OpenJPA\n+    implements QueryCache, Configurable {\n+\n+    private static final Localizer s_loc =\n+        Localizer.forPackage(AbstractQueryCache.class);\n+\n+    /**\n+     * The configuration set by the system.\n+     */\n+    protected OpenJPAConfiguration conf;\n+\n+    /**\n+     * The log to use.\n+     */\n+    protected Log log;\n+\n+    private boolean _closed = false;\n+\n+    public void initialize(DataCacheManager manager) {\n+    }\n+\n+    public void onTypesChanged(TypesChangedEvent ev) {\n+        writeLock();\n+        Collection keys = null;\n+        try {\n+            if (hasListeners())\n+                fireEvent(ev);\n+            keys = keySet();\n+        }\n+        finally {\n+            writeUnlock();\n+        }\n+\n+        QueryKey qk;\n+        List removes = null;\n+        for (Iterator iter = keys.iterator(); iter.hasNext();) {\n+            qk = (QueryKey) iter.next();\n+            if (qk.changeInvalidatesQuery(ev.getTypes())) {\n+                if (removes == null)\n+                    removes = new ArrayList();\n+                removes.add(qk);\n+            }\n+        }\n+        if (removes != null)\n+            removeAllInternal(removes);\n+    }\n+\n+    public QueryResult get(QueryKey key) {\n+        QueryResult o = getInternal(key);\n+        if (o != null && o.isTimedOut()) {\n+            o = null;\n+            removeInternal(key);\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-timeout\", key));\n+        }\n+\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-hit\", key));\n+        }\n+        return o;\n+    }\n+\n+    public QueryResult put(QueryKey qk, QueryResult oids) {\n+        QueryResult o = putInternal(qk, oids);\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-put\", qk));\n+        return (o == null || o.isTimedOut()) ? null : o;\n+    }\n+\n+    public QueryResult remove(QueryKey key) {\n+        QueryResult o = removeInternal(key);\n+        if (o != null && o.isTimedOut())\n+            o = null;\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-remove-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-remove-hit\", key));\n+        }\n+        return o;\n+    }\n+\n+    public boolean pin(QueryKey key) {\n+        boolean bool = pinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-pin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-pin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public boolean unpin(QueryKey key) {\n+        boolean bool = unpinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-unpin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-unpin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public void clear() {\n+        clearInternal();\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-clear\", \"<query-cache>\"));\n+    }\n+\n+    public void close() {\n+        close(true);\n+    }\n+\n+    protected void close(boolean clear) {\n+        if (!_closed) {\n+            if (clear)\n+                clearInternal();\n+            _closed = true;\n+        }\n+    }\n+\n+    public boolean isClosed() {\n+        return _closed;\n+    }\n+\n+    public void addTypesChangedListener(TypesChangedListener listen) {\n+        addListener(listen);\n+    }\n+\n+    public boolean removeTypesChangedListener(TypesChangedListener listen) {\n+        return removeListener(listen);\n+    }\n+\n+    /**\n+     * This method is part of the {@link RemoteCommitListener} interface.  If\n+     * your cache subclass relies on OpenJPA for clustering support, make it\n+     * implement <code>RemoteCommitListener</code>.  This method will take\n+     * care of invalidating entries from remote commits, by delegating to\n+     * {@link #typesChanged}.\n+     */\n+    public void afterCommit(RemoteCommitEvent event) {\n+        if (_closed)\n+            return;\n+\n+        // drop all committed classes\n+        Set classes = Caches.addTypesByName(conf,\n+            event.getPersistedTypeNames(), null);\n+        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\n+            classes = Caches.addTypesByName(conf, event.getUpdatedTypeNames(),\n+                classes);\n+            classes = Caches.addTypesByName(conf, event.getDeletedTypeNames(),\n+                classes);\n+        } else {\n+            classes = addTypes(event.getUpdatedObjectIds(), classes);\n+            classes = addTypes(event.getDeletedObjectIds(), classes);\n+        }\n+        if (classes != null)\n+            onTypesChanged(new TypesChangedEvent(this, classes));\n+    }\n+\n+    /**\n+     * Build up a set of classes for the given oids.\n+     */\n+    private Set addTypes(Collection oids, Set classes) {\n+        if (oids.isEmpty())\n+            return classes;\n+        if (classes == null)\n+            classes = new HashSet();\n+\n+        MetaDataRepository repos = conf.getMetaDataRepository();\n+        ClassMetaData meta;\n+        Object oid;\n+        for (Iterator itr = oids.iterator(); itr.hasNext();) {\n+            oid = itr.next();\n+            if (oid instanceof Id)\n+                classes.add(((Id) oid).getType());\n+            else {\n+                // ok if no metadata for oid; that just means the pc type\n+                // probably hasn't been loaded into this JVM yet, and therefore\n+                // there's no chance that it's in the cache anyway\n+                meta = repos.getMetaData(oid, null, false);\n+                if (meta != null)\n+                    classes.add(meta.getDescribedType());\n+            }\n+        }\n+        return classes;\n+    }\n+\n+    /**\n+     * Return a threadsafe view of the keys in this cache.  This collection\n+     * must be iterable without risk of concurrent modification exceptions.\n+     * It does not have to implement contains() efficiently or use set\n+     * semantics.\n+     */\n+    protected abstract Collection keySet();\n+\n+    /**\n+     * Return the list for the given key.\n+     */\n+    protected abstract QueryResult getInternal(QueryKey qk);\n+\n+    /**\n+     * Add the given result to the cache, returning the old result under the\n+     * given key.\n+     */\n+    protected abstract QueryResult putInternal(QueryKey qk, QueryResult oids);\n+\n+    /**\n+     * Remove the result under the given key from the cache.\n+     */\n+    protected abstract QueryResult removeInternal(QueryKey qk);\n+\n+    /**\n+     * Remove all results under the given keys from the cache.\n+     */\n+    protected void removeAllInternal(Collection qks) {\n+        for (Iterator iter = qks.iterator(); iter.hasNext();)\n+            removeInternal((QueryKey) iter.next());\n+    }\n+\n+    /**\n+     * Clear the cache.\n+     */\n+    protected abstract void clearInternal();\n+\n+    /**\n+     * Pin an object to the cache.\n+     */\n+    protected abstract boolean pinInternal(QueryKey qk);\n+\n+    /**\n+     * Unpin an object from the cache.\n+     */\n+    protected abstract boolean unpinInternal(QueryKey qk);\n+\n+    // ---------- Configurable implementation ----------\n+\n+    public void setConfiguration(Configuration conf) {\n+        this.conf = (OpenJPAConfiguration) conf;\n+        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+    }\n+\n+    // ---------- AbstractEventManager implementation ----------\n+\n+    protected void fireEvent(Object event, Object listener) {\n+        TypesChangedListener listen = (TypesChangedListener) listener;\n+        TypesChangedEvent ev = (TypesChangedEvent) event;\n+        try {\n+            listen.onTypesChanged(ev);\n+        }\n+        catch (Exception e) {\n+            if (log.isWarnEnabled())\n+                log.warn(s_loc.get(\"exp-listener-ex\"), e);\n+        }\n+    }\n+\n+    /**\n+     *\tIndividual query results will be registered as types changed\n+     *\tlisteners. We want such query results to be gc'd once\n+     *\tthe only reference is held by the list of expiration listeners.\n+     */\n+    protected Collection newListenerCollection() {\n+        //### use concurrent\n+        return new ReferenceHashSet (ReferenceHashSet.WEAK);\n+\t}\n+}"},{"sha":"4e4be50db1e8888e7d8f738ed6cd64b1d860d42c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java","status":"modified","additions":57,"deletions":50,"changes":107,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,50 +1,57 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-\r\n-class Caches {\r\n-\r\n-    /**\r\n-     * Utility to build up a set of classes from their class names\r\n-     * when operating outside the context of a persistence manager.\r\n-     * The set classes can be null, in which case a new Set will be created.\r\n-     */\r\n-    static Set addTypesByName(OpenJPAConfiguration conf,\r\n-        Collection classNames, Set classes) {\r\n-        if (classNames.isEmpty())\r\n-            return classes;\r\n-        ClassLoader loader = conf.getClassResolverInstance().\r\n-            getClassLoader(null, null);\r\n-        Class cls;\r\n-        String className;\r\n-        for (Iterator iter = classNames.iterator(); iter.hasNext();) {\r\n-            className = (String) iter.next();\r\n-            try {\r\n-                cls = Class.forName(className, true, loader);\r\n-                if (classes == null)\r\n-                    classes = new HashSet();\r\n-                classes.add(cls);\r\n-            } catch (Throwable t) {\r\n-                conf.getLog(OpenJPAConfiguration.LOG_RUNTIME).warn(t, t);\r\n-            }\r\n-        }\r\n-        return classes;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+\n+class Caches {\n+\n+    /**\n+     * Utility to build up a set of classes from their class names\n+     * when operating outside the context of a persistence manager.\n+     * The set classes can be null, in which case a new Set will be\n+     * created.\n+     */\n+    static Set addTypesByName(OpenJPAConfiguration conf,\n+        Collection classNames, Set classes) {\n+        if (classNames.isEmpty())\n+            return classes;\n+\n+        ClassLoader loader = conf.getClassResolverInstance().\n+            getClassLoader(null, null);\n+\n+        Class cls;\n+        String className;\n+        for (Iterator iter = classNames.iterator(); iter.hasNext();) {\n+            className = (String) iter.next();\n+            try {\n+                cls = Class.forName(className, true, loader);\n+                if (classes == null)\n+                    classes = new HashSet();\n+                classes.add(cls);\n+            }\n+            catch (Throwable t) {\n+                conf.getLog(OpenJPAConfiguration.LOG_RUNTIME).warn(t, t);\n+            }\n+        }\n+        return classes;\n+    }\n+}"},{"sha":"88485ed20c247bf8e7eb394375a76c3dccb73a57","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentDataCache.java","status":"modified","additions":12,"deletions":8,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentDataCache.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,10 +1,13 @@\n /*\r\n  * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  * you may not use this file except in compliance with the License.\r\n  * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  * See the License for the specific language governing permissions and\r\n@@ -17,14 +20,15 @@\n \r\n /**\r\n  * A {@link DataCache} implementation that is optimized for concurrent\r\n- * access. When the cache fills up, values to remove from cache are chosen\r\n- * randomly. Due to race conditions, it is possible that a get call might not\r\n+ * access.  When the cache fills up, values to remove from cache are chosen\r\n+ * randomly.  Due to race conditions, it is possible that a get call might not\r\n  * return a cached instance if that instance is being transferred between\r\n  * internal datastructures.\r\n  *\r\n  * @since 4.0\r\n  */\r\n-public class ConcurrentDataCache extends AbstractDataCache\r\n+public class ConcurrentDataCache\r\n+    extends AbstractDataCache\r\n     implements RemoteCommitListener {\r\n \r\n     private final CacheMap _cache = newCacheMap();\r\n@@ -131,6 +135,6 @@ protected boolean pinInternal(Object key) {\n     }\r\n \r\n     protected boolean unpinInternal(Object key) {\r\n-        return _cache.unpin(key);\r\n-    }\r\n+        return _cache.unpin (key);\r\n+\t}\r\n }\r"},{"sha":"f5b3b1baca92b3421fa0ac9912bf017bfa5e7a71","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentQueryCache.java","status":"modified","additions":137,"deletions":133,"changes":270,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentQueryCache.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,133 +1,137 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.Collection;\r\n-\r\n-import org.apache.openjpa.event.RemoteCommitListener;\r\n-import org.apache.openjpa.util.CacheMap;\r\n-\r\n-/**\r\n- * A {@link QueryCache} implementation that is optimized for concurrent\r\n- * access. When the cache fill up, values to remove from the cache are chosen\r\n- * randomly. Due to race conditions, it is possible that a get call might not\r\n- * retur a cached instance if that instance is being transferred between\r\n- * internal datastructures.\r\n- *\r\n- * @since 4.1\r\n- */\r\n-public class ConcurrentQueryCache extends AbstractQueryCache\r\n-    implements RemoteCommitListener {\r\n-\r\n-    private CacheMap _cache = newCacheMap();\r\n-\r\n-    /**\r\n-     * Returns the underlying {@link CacheMap} that this cache is using.\r\n-     * This is not an unmodifiable view on the map, so care should be taken\r\n-     * with this reference. Implementations should probably not modify the\r\n-     * contents of the cache, but should only use this reference\r\n-     * to obtain cache metrics. Additionally, this map may contain\r\n-     * expired data. Removal of timed-out data is done in a lazy\r\n-     * fashion, so the actual size of the map may be greater than the\r\n-     * number of non-expired query results in cache.\r\n-     */\r\n-    public CacheMap getCacheMap() {\r\n-        return _cache;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the maximum number of unpinned objects to keep hard\r\n-     * references to.\r\n-     */\r\n-    public int getCacheSize() {\r\n-        return _cache.getCacheSize();\r\n-    }\r\n-\r\n-    /**\r\n-     * Sets the maximum number of unpinned objects to keep hard\r\n-     * references to. If the map contains more unpinned objects than\r\n-     * <code>size</code>, then this method will result in the cache\r\n-     * flushing old values.\r\n-     */\r\n-    public void setCacheSize(int size) {\r\n-        _cache.setCacheSize(size);\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the maximum number of unpinned objects to keep soft\r\n-     * references to. Defaults to <code>-1</code>.\r\n-     */\r\n-    public int getSoftReferenceSize() {\r\n-        return _cache.getSoftReferenceSize();\r\n-    }\r\n-\r\n-    /**\r\n-     * Sets the maximum number of unpinned objects to keep soft\r\n-     * references to. If the map contains more soft references than\r\n-     * <code>size</code>, then this method will result in the cache\r\n-     * flushing values.\r\n-     */\r\n-    public synchronized void setSoftReferenceSize(int size) {\r\n-        _cache.setSoftReferenceSize(size);\r\n-    }\r\n-\r\n-    public void initialize(DataCacheManager mgr) {\r\n-        super.initialize(mgr);\r\n-        conf.getRemoteCommitEventManager().addListener(this);\r\n-    }\r\n-\r\n-    public void writeLock() {\r\n-        // delegate actually does nothing, but in case that changes...\r\n-        _cache.writeLock();\r\n-    }\r\n-\r\n-    public void writeUnlock() {\r\n-        // delegate actually does nothing, but in case that changes...\r\n-        _cache.writeUnlock();\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the map to use as an internal cache.\r\n-     */\r\n-    protected CacheMap newCacheMap() {\r\n-        return new CacheMap();\r\n-    }\r\n-\r\n-    protected QueryResult getInternal(QueryKey qk) {\r\n-        return (QueryResult) _cache.get(qk);\r\n-    }\r\n-\r\n-    protected QueryResult putInternal(QueryKey qk, QueryResult result) {\r\n-        return (QueryResult) _cache.put(qk, result);\r\n-    }\r\n-\r\n-    protected QueryResult removeInternal(QueryKey qk) {\r\n-        return (QueryResult) _cache.remove(qk);\r\n-    }\r\n-\r\n-    protected void clearInternal() {\r\n-        _cache.clear();\r\n-    }\r\n-\r\n-    protected boolean pinInternal(QueryKey qk) {\r\n-        return _cache.pin(qk);\r\n-    }\r\n-\r\n-    protected boolean unpinInternal(QueryKey qk) {\r\n-        return _cache.unpin(qk);\r\n-    }\r\n-\r\n-    protected Collection keySet() {\r\n-        return _cache.keySet();\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.Collection;\n+\n+import org.apache.openjpa.event.RemoteCommitListener;\n+import org.apache.openjpa.util.CacheMap;\n+\n+/**\n+ * A {@link QueryCache} implementation that is optimized for concurrent\n+ * access.  When the cache fill up, values to remove from the cache are chosen\n+ * randomly.  Due to race conditions, it is possible that a get call might not\n+ * retur a cached instance if that instance is being transferred between\n+ * internal datastructures.\n+ *\n+ * @since 4.1\n+ */\n+public class ConcurrentQueryCache\n+    extends AbstractQueryCache\n+    implements RemoteCommitListener {\n+\n+    private CacheMap _cache = newCacheMap();\n+\n+    /**\n+     * Returns the underlying {@link CacheMap} that this cache is using.\n+     * This is not an unmodifiable view on the map, so care should be taken\n+     * with this reference. Implementations should probably not modify the\n+     * contents of the cache, but should only use this reference\n+     * to obtain cache metrics. Additionally, this map may contain\n+     * expired data. Removal of timed-out data is done in a lazy\n+     * fashion, so the actual size of the map may be greater than the\n+     * number of non-expired query results in cache.\n+     */\n+    public CacheMap getCacheMap() {\n+        return _cache;\n+    }\n+\n+    /**\n+     * Returns the maximum number of unpinned objects to keep hard\n+     * references to.\n+     */\n+    public int getCacheSize() {\n+        return _cache.getCacheSize();\n+    }\n+\n+    /**\n+     * Sets the maximum number of unpinned objects to keep hard\n+     * references to. If the map contains more unpinned objects than\n+     * <code>size</code>, then this method will result in the cache\n+     * flushing old values.\n+     */\n+    public void setCacheSize(int size) {\n+        _cache.setCacheSize(size);\n+    }\n+\n+    /**\n+     * Returns the maximum number of unpinned objects to keep soft\n+     * references to. Defaults to <code>-1</code>.\n+     */\n+    public int getSoftReferenceSize() {\n+        return _cache.getSoftReferenceSize();\n+    }\n+\n+    /**\n+     * Sets the maximum number of unpinned objects to keep soft\n+     * references to. If the map contains more soft references than\n+     * <code>size</code>, then this method will result in the cache\n+     * flushing values.\n+     */\n+    public synchronized void setSoftReferenceSize(int size) {\n+        _cache.setSoftReferenceSize(size);\n+    }\n+\n+    public void initialize(DataCacheManager mgr) {\n+        super.initialize(mgr);\n+        conf.getRemoteCommitEventManager().addListener(this);\n+    }\n+\n+    public void writeLock() {\n+        // delegate actually does nothing, but in case that changes...\n+        _cache.writeLock();\n+    }\n+\n+    public void writeUnlock() {\n+        // delegate actually does nothing, but in case that changes...\n+        _cache.writeUnlock();\n+    }\n+\n+    /**\n+     * Return the map to use as an internal cache.\n+     */\n+    protected CacheMap newCacheMap() {\n+        return new CacheMap();\n+    }\n+\n+    protected QueryResult getInternal(QueryKey qk) {\n+        return (QueryResult) _cache.get(qk);\n+    }\n+\n+    protected QueryResult putInternal(QueryKey qk, QueryResult result) {\n+        return (QueryResult) _cache.put(qk, result);\n+    }\n+\n+    protected QueryResult removeInternal(QueryKey qk) {\n+        return (QueryResult) _cache.remove(qk);\n+    }\n+\n+    protected void clearInternal() {\n+        _cache.clear();\n+    }\n+\n+    protected boolean pinInternal(QueryKey qk) {\n+        return _cache.pin(qk);\n+    }\n+\n+    protected boolean unpinInternal(QueryKey qk) {\n+        return _cache.unpin(qk);\n+    }\n+\n+    protected Collection keySet() {\n+        return _cache.keySet ();\n+\t}\n+}"},{"sha":"39ca5af2ff325e488917de2beac7b4b231a32319","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java","status":"modified","additions":258,"deletions":242,"changes":500,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,242 +1,258 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.BitSet;\r\n-import java.util.Collection;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.lib.util.Closeable;\r\n-\r\n-/**\r\n- * Interface that must be implemented by any level 2 cache used by\r\n- * OpenJPA. Most data caches will choose to implement the\r\n- * {@link org.apache.openjpa.lib.conf.Configurable} interface as well so that\r\n- * they will be given the system configuration just after construction.\r\n- * Implementations should take care not to return timed out data.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @author Abe White\r\n- * @see AbstractDataCache\r\n- * @see DataCachePCData#isTimedOut\r\n- */\r\n-public interface DataCache extends Closeable {\r\n-\r\n-    /**\r\n-     * The name of the default data cache: <code>default</code>\r\n-     */\r\n-    public static final String NAME_DEFAULT = \"default\";\r\n-\r\n-    /**\r\n-     * Returns a string name that can be used by end-user-visible\r\n-     * code to identify this cache.\r\n-     *\r\n-     * @since 2.5.0\r\n-     */\r\n-    public String getName();\r\n-\r\n-    /**\r\n-     * Sets a string name to be used to identify this cache to end-user needs.\r\n-     *\r\n-     * @since 2.5.0\r\n-     */\r\n-    public void setName(String name);\r\n-\r\n-    /**\r\n-     * Initialize any resources associated with the given\r\n-     * {@link DataCacheManager}.\r\n-     */\r\n-    public void initialize(DataCacheManager manager);\r\n-\r\n-    /**\r\n-     * Perform a batch update of the cache. Add all {@link DataCachePCData}\r\n-     * objects in <code>additions</code> and in\r\n-     * <code>newUpdates</code>, make the appropriate modifications to\r\n-     * all DataCachePCDatas in <code>existingUpdates</code>, and delete all\r\n-     * OIDs in <code>deletes</code>.\r\n-     * All changes made to cached data must be made via this\r\n-     * method. It is this method that is responsible for performing\r\n-     * any side-effects that should happen on meaningful cache changes.\r\n-     * Implementations should bear in mind that the\r\n-     * <code>deletes</code> collection may contain oids that are also\r\n-     * in the <code>additions</code> map. This is possible because it\r\n-     * is valid for a user to delete an object with a particular oid\r\n-     * and then add that object in the same batch.\r\n-     *\r\n-     * @param additions       A collection of {@link DataCachePCData} objects.\r\n-     *                        These represent data that have been newly created,\r\n-     *                        and thus must be added to the cache.\r\n-     * @param newUpdates      A collection of {@link DataCachePCData} objects.\r\n-     *                        These represent data that have been modified but\r\n-     *                        were not originally in the cache, and thus must be added to the cache.\r\n-     * @param existingUpdates A collection of {@link DataCachePCData} objects.\r\n-     *                        These represent data that have been modified and\r\n-     *                        were originally loaded from the cache. It is\r\n-     *                        up to the cache implementation to decide if\r\n-     *                        these values must be re-enlisted in the cache.\r\n-     *                        Some caches may return live data from {@link #get}\r\n-     *                        invocations, in which case these values need not be re-enlisted.\r\n-     * @param deletes         A collection of object IDs that have been deleted\r\n-     *                        and must therefore be dropped from the cache.\r\n-     */\r\n-    public void commit(Collection additions, Collection newUpdates,\r\n-        Collection existingUpdates, Collection deletes);\r\n-\r\n-    /**\r\n-     * Returns <code>true</code> if this cache contains data\r\n-     * corresponding to <code>oid</code>; otherwise returns\r\n-     * <code>false</code>.\r\n-     */\r\n-    public boolean contains(Object oid);\r\n-\r\n-    /**\r\n-     * Returns the indexes of the oids in this cache.\r\n-     */\r\n-    public BitSet containsAll(Collection oids);\r\n-\r\n-    /**\r\n-     * Return the cached object for the given oid. Modifying the returned\r\n-     * object may or may not change the cached value; the {@link #update}\r\n-     * method should be used to re-cache any changed objects.\r\n-     *\r\n-     * @return the object matching the given oid, or null if none\r\n-     */\r\n-    public DataCachePCData get(Object oid);\r\n-\r\n-    /**\r\n-     * Set the cached value for the given instance. This does <em>not</em>\r\n-     * result in an update of other caches. Rather, it should only be\r\n-     * used for loading clean data into the cache. Meaningful changes\r\n-     * to the state of the cache should be made via the {@link #commit} method.\r\n-     *\r\n-     * @return The previously cached value, or <code>null</code> if\r\n-     *         the value was not previously cached. See {@link Map#put}\r\n-     *         for more information.\r\n-     */\r\n-    public DataCachePCData put(DataCachePCData value);\r\n-\r\n-    /**\r\n-     * Update the cached value for the given instance. This does\r\n-     * <em>not</em> result in an update of other caches. Rather, it should\r\n-     * only be used for loading clean data into the cache. Meaningful changes\r\n-     * to the state of the cache should be made via the {@link #commit} method.\r\n-     * A cache implementation may or may not return a live object\r\n-     * from {@link #get} invocations. If an object retrieved from a\r\n-     * {@link #get} operation needs to be updated, this method can be\r\n-     * invoked instead of invoking {@link #put}. The DataCache implementation\r\n-     * can then make optimizations based on how its {@link #get} method works.\r\n-     */\r\n-    public void update(DataCachePCData value);\r\n-\r\n-    /**\r\n-     * Remove the value stored under the given oid. This does\r\n-     * <em>not</em> result in an update of other caches. Rather, it\r\n-     * should only be used for removing data in the cache.\r\n-     * Meaningful changes to the state of the cache should be made\r\n-     * via the {@link #commit} method.\r\n-     *\r\n-     * @return The previously cached value, or <code>null</code> if\r\n-     *         the oid was not previously cached. See {@link Map#remove}\r\n-     *         for more information.\r\n-     */\r\n-    public DataCachePCData remove(Object oid);\r\n-\r\n-    /**\r\n-     * Remove the values stored under the given oids.\r\n-     *\r\n-     * @return the indexes of the removed oids\r\n-     * @see #remove\r\n-     */\r\n-    public BitSet removeAll(Collection oids);\r\n-\r\n-    /**\r\n-     * Evict all values of a specified type.\r\n-     */\r\n-    public void removeAll(Class cls, boolean subclasses);\r\n-\r\n-    /**\r\n-     * Remove all data from this cache. This does <em>not</em> result\r\n-     * in an update of other caches. Rather, it should only be used\r\n-     * for clearing the cache. Meaningful changes to the state of the\r\n-     * cache should be made via the {@link #commit} method.\r\n-     */\r\n-    public void clear();\r\n-\r\n-    /**\r\n-     * Pin the value stored under <code>oid</code> into the cache.\r\n-     * This method guarantees that <code>oid</code>'s value will not\r\n-     * be dropped by the caching algorithm. This method does not\r\n-     * affect the behavior of {@link #remove}.\r\n-     *\r\n-     * @return <code>true</code> if <code>oid</code>'s value was\r\n-     *         pinned into the cache; <code>false</code> if the oid is not in the cache.\r\n-     */\r\n-    public boolean pin(Object oid);\r\n-\r\n-    /**\r\n-     * Pin all oids to the cache.\r\n-     *\r\n-     * @return the indexes of the pinned oids\r\n-     * @see #pin\r\n-     */\r\n-    public BitSet pinAll(Collection oids);\r\n-\r\n-    /**\r\n-     * Unpin the value stored under <code>oid</code> from the cache.\r\n-     * This method reverses a previous invocation of {@link #pin}.\r\n-     * This method does not remove anything from the cache; it merely\r\n-     * makes <code>oid</code>'s value a candidate for flushing from the cache.\r\n-     *\r\n-     * @return <code>true</code> if <code>oid</code>'s value was\r\n-     *         unpinned from the cache; <code>false</code> if the\r\n-     *         oid is not in the cache.\r\n-     */\r\n-    public boolean unpin(Object oid);\r\n-\r\n-    /**\r\n-     * Unpin all oids from the cache.\r\n-     *\r\n-     * @return the indexes of the unpinned oids\r\n-     * @see #unpin\r\n-     */\r\n-    public BitSet unpinAll(Collection oids);\r\n-\r\n-    /**\r\n-     * Obtain a write lock on the cache.\r\n-     */\r\n-    public void writeLock();\r\n-\r\n-    /**\r\n-     * Release the write lock on the cache.\r\n-     */\r\n-    public void writeUnlock();\r\n-\r\n-    /**\r\n-     * Add a new expiration event listener to this cache.\r\n-     *\r\n-     * @since 2.5.0\r\n-     */\r\n-    public void addExpirationListener(ExpirationListener listen);\r\n-\r\n-    /**\r\n-     * Remove an expiration event listener from this cache.\r\n-     *\r\n-     * @since 2.5.0\r\n-     */\r\n-    public boolean removeExpirationListener(ExpirationListener listen);\r\n-\r\n-    /**\r\n-     * Free the resources used by this cache.\r\n-     */\r\n-    public void close();\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.util.Closeable;\n+\n+/**\n+ * <p>Interface that must be implemented by any level 2 cache used by\n+ * OpenJPA. Most data caches will choose to implement the\n+ * {@link org.apache.openjpa.lib.conf.Configurable} interface as well so that\n+ * they will be given the system configuration just after construction.</p>\n+ * <p/>\n+ * <p>Implementations should take care not to return timed out data.</p>\n+ *\n+ * @see        AbstractDataCache\n+ * @see        DataCachePCData#isTimedOut\n+ * @author Patrick Linskey\n+ * @author Abe White\n+ */\n+public interface DataCache\n+    extends Closeable {\n+\n+    /**\n+     * The name of the default data cache: <code>default</code>\n+     */\n+    public static final String NAME_DEFAULT = \"default\";\n+\n+    /**\n+     * Returns a string name that can be used by end-user-visible\n+     * code to identify this cache.\n+     *\n+     * @since 2.5.0\n+     */\n+    public String getName();\n+\n+    /**\n+     * Sets a string name to be used to identify this cache to\n+     * end-user needs.\n+     *\n+     * @since 2.5.0\n+     */\n+    public void setName(String name);\n+\n+    /**\n+     * Initialize any resources associated with the given\n+     * {@link DataCacheManager}.\n+     */\n+    public void initialize(DataCacheManager manager);\n+\n+    /**\n+     * <p>Perform a batch update of the cache. Add all {@link DataCachePCData}\n+     * objects in <code>additions</code> and in\n+     * <code>newUpdates</code>, make the appropriate modifications to\n+     * all DataCachePCDatas in <code>existingUpdates</code>, and delete all\n+     * OIDs in <code>deletes</code>.</p>\n+     * <p/>\n+     * <p>All changes made to cached data must be made via this\n+     * method. It is this method that is responsible for performing\n+     * any side-effects that should happen on meaningful cache\n+     * changes.</p>\n+     * <p/>\n+     * <p>Implementations should bear in mind that the\n+     * <code>deletes</code> collection may contain oids that are also\n+     * in the <code>additions</code> map. This is possible because it\n+     * is valid for a user to delete an object with a particular oid\n+     * and then add that object in the same batch.</p>\n+     *\n+     * @param    additions    A collection of {@link DataCachePCData} objects.\n+     * These represent data that have been newly created,\n+     * and thus must be added to the cache.\n+     * @param    newUpdates    A collection of {@link DataCachePCData} objects.\n+     * These represent data that have been modified but\n+     * were not originally in the cache, and thus\n+     * must be added to the cache.\n+     * @param    existingUpdates    A collection of {@link DataCachePCData} objects.\n+     * These represent data that have been modified and\n+     * were originally loaded from the cache. It is\n+     * up to the cache implementation to decide if\n+     * these values must be re-enlisted in the cache.\n+     * Some caches may return live data from {@link #get}\n+     * invocations, in which case these values need\n+     * not be re-enlisted.\n+     * @param    deletes        A collection of object IDs that have been deleted\n+     * and must therefore be dropped from the cache.\n+     */\n+    public void commit(Collection additions, Collection newUpdates,\n+        Collection existingUpdates, Collection deletes);\n+\n+    /**\n+     * Returns <code>true</code> if this cache contains data\n+     * corresponding to <code>oid</code>; otherwise returns\n+     * <code>false</code>.\n+     */\n+    public boolean contains(Object oid);\n+\n+    /**\n+     * Returns the indexes of the oids in this cache.\n+     */\n+    public BitSet containsAll(Collection oids);\n+\n+    /**\n+     * Return the cached object for the given oid.  Modifying the returned\n+     * object may or may not change the cached value; the {@link #update}\n+     * method should be used to re-cache any changed objects.\n+     *\n+     * @return the object matching the given oid, or null if none\n+     */\n+    public DataCachePCData get(Object oid);\n+\n+    /**\n+     * Set the cached value for the given instance. This does <em>not</em>\n+     * result in an update of other caches. Rather, it should only be\n+     * used for loading clean data into the cache. Meaningful changes\n+     * to the state of the cache should be made via the {@link #commit} method.\n+     *\n+     * @return The previously cached value, or <code>null</code> if\n+     * the value was not previously cached. See {@link Map#put}\n+     * for more information.\n+     */\n+    public DataCachePCData put(DataCachePCData value);\n+\n+    /**\n+     * <p>Update the cached value for the given instance. This does\n+     * <em>not</em> result in an update of other caches. Rather, it should\n+     * only be used for loading clean data into the cache. Meaningful changes\n+     * to the state of the cache should be made via the {@link #commit}\n+     * method.</p>\n+     * <p/>\n+     * <p>A cache implementation may or may not return a live object\n+     * from {@link #get} invocations. If an object retrieved from a\n+     * {@link #get} operation needs to be updated, this method can be\n+     * invoked instead of invoking {@link #put}. The DataCache implementation\n+     * can then make optimizations based on how its {@link #get} method\n+     * works.</p>\n+     */\n+    public void update(DataCachePCData value);\n+\n+    /**\n+     * Remove the value stored under the given oid. This does\n+     * <em>not</em> result in an update of other caches. Rather, it\n+     * should only be used for removing data in the cache.\n+     * Meaningful changes to the state of the cache should be made\n+     * via the {@link #commit} method.\n+     *\n+     * @return The previously cached value, or <code>null</code> if\n+     * the oid was not previously cached. See {@link Map#remove}\n+     * for more information.\n+     */\n+    public DataCachePCData remove(Object oid);\n+\n+    /**\n+     * Remove the values stored under the given oids.\n+     *\n+     * @return the indexes of the removed oids\n+     * @see        #remove\n+     */\n+    public BitSet removeAll(Collection oids);\n+\n+    /**\n+     * Evict all values of a specified type.\n+     */\n+    public void removeAll(Class cls, boolean subclasses);\n+\n+    /**\n+     * Remove all data from this cache. This does <em>not</em> result\n+     * in an update of other caches. Rather, it should only be used\n+     * for clearing the cache. Meaningful changes to the state of the\n+     * cache should be made via the {@link #commit} method.\n+     */\n+    public void clear();\n+\n+    /**\n+     * Pin the value stored under <code>oid</code> into the cache.\n+     * This method guarantees that <code>oid</code>'s value will not\n+     * be dropped by the caching algorithm. This method does not\n+     * affect the behavior of {@link #remove}.\n+     *\n+     * @return <code>true</code> if <code>oid</code>'s value was\n+     *         pinned into the cache; <code>false</code> if the\n+     *         oid is not in the cache.\n+     */\n+    public boolean pin(Object oid);\n+\n+    /**\n+     * Pin all oids to the cache.\n+     *\n+     * @return the indexes of the pinned oids\n+     * @see        #pin\n+     */\n+    public BitSet pinAll(Collection oids);\n+\n+    /**\n+     * Unpin the value stored under <code>oid</code> from the cache.\n+     * This method reverses a previous invocation of {@link #pin}.\n+     * This method does not remove anything from the cache; it merely\n+     * makes <code>oid</code>'s value a candidate for flushing from\n+     * the cache.\n+     *\n+     * @return <code>true</code> if <code>oid</code>'s value was\n+     *         unpinned from the cache; <code>false</code> if the\n+     *         oid is not in the cache.\n+     */\n+    public boolean unpin(Object oid);\n+\n+    /**\n+     * Unpin all oids from the cache.\n+     *\n+     * @return the indexes of the unpinned oids\n+     * @see        #unpin\n+     */\n+    public BitSet unpinAll(Collection oids);\n+\n+    /**\n+     * Obtain a write lock on the cache.\n+     */\n+    public void writeLock();\n+\n+    /**\n+     * Release the write lock on the cache.\n+     */\n+    public void writeUnlock();\n+\n+    /**\n+     * Add a new expiration event listener to this cache.\n+     *\n+     * @since 2.5.0\n+     */\n+    public void addExpirationListener(ExpirationListener listen);\n+\n+    /**\n+     * Remove an expiration event listener from this cache.\n+     *\n+     * @since 2.5.0\n+     */\n+    public boolean removeExpirationListener(ExpirationListener listen);\n+\n+    /**\n+     *\tFree the resources used by this cache.\n+\t */\n+\tpublic void close ();\n+}"},{"sha":"df1509a88277b32591741257a112d28747f8bd2e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManager.java","status":"modified","additions":13,"deletions":10,"changes":23,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,10 +1,13 @@\n /*\r\n  * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  * you may not use this file except in compliance with the License.\r\n  * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  * See the License for the specific language governing permissions and\r\n@@ -16,8 +19,8 @@\n import org.apache.openjpa.lib.conf.ObjectValue;\r\n \r\n /**\r\n- * Manages the system's data and query caches. You can\r\n- * retrieve the data cache manager from the {@link OpenJPAConfiguration}.\r\n+ * <p>Manages the system's data and query caches.  You can\r\n+ * retrieve the data cache manager from the {@link OpenJPAConfiguration}.</p>\r\n  *\r\n  * @author Abe White\r\n  * @author Patrick Linskey\r\n@@ -41,11 +44,11 @@ public void initialize(OpenJPAConfiguration conf, ObjectValue dataCache,\n     public DataCache getDataCache(String name);\r\n \r\n     /**\r\n-     * Return the named data cache. If the given name is null, the default\r\n+     * Return the named data cache.  If the given name is null, the default\r\n      * data cache is returned.\r\n      *\r\n-     * @param create if true, the cache will be created if it does\r\n-     *               not already exist\r\n+     * @param    create    if true, the cache will be created if it does\r\n+     * not already exist\r\n      */\r\n     public DataCache getDataCache(String name, boolean create);\r\n \r\n@@ -65,7 +68,7 @@ public void initialize(OpenJPAConfiguration conf, ObjectValue dataCache,\n     public DataCacheScheduler getDataCacheScheduler();\r\n \r\n     /**\r\n-     * Close all caches.\r\n+     *\tClose all caches.\r\n      */\r\n-    public void close();\r\n+    public void close ();\r\n }\r"},{"sha":"00b391fff3f87d3ae8f8991f0f6aca901b667e9a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManagerImpl.java","status":"modified","additions":87,"deletions":81,"changes":168,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManagerImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,81 +1,87 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.conf.ObjectValue;\r\n-import org.apache.openjpa.lib.util.Closeable;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-\r\n-/**\r\n- * Default data cache manager.\r\n- *\r\n- * @author Abe White\r\n- * @author Patrick Linskey\r\n- */\r\n-public class DataCacheManagerImpl implements Closeable, DataCacheManager {\r\n-\r\n-    private DataCache _cache = null;\r\n-    private QueryCache _queryCache = null;\r\n-    private DataCachePCDataGenerator _pcGenerator = null;\r\n-    private DataCacheScheduler _scheduler = null;\r\n-\r\n-    public void initialize(OpenJPAConfiguration conf, ObjectValue dataCache,\r\n-        ObjectValue queryCache) {\r\n-        _cache = (DataCache) dataCache.instantiate(DataCache.class, conf);\r\n-        if (_cache == null)\r\n-            return;\r\n-        // create helpers before initializing caches\r\n-        if (conf.getDynamicDataStructs())\r\n-            _pcGenerator = new DataCachePCDataGenerator(conf);\r\n-        _scheduler = new DataCacheScheduler(conf);\r\n-        _cache.initialize(this);\r\n-        _queryCache = (QueryCache) queryCache.instantiate(QueryCache.class,\r\n-            conf);\r\n-        if (_queryCache != null)\r\n-            _queryCache.initialize(this);\r\n-    }\r\n-\r\n-    public DataCache getSystemDataCache() {\r\n-        return getDataCache(null, false);\r\n-    }\r\n-\r\n-    public DataCache getDataCache(String name) {\r\n-        return getDataCache(name, false);\r\n-    }\r\n-\r\n-    public DataCache getDataCache(String name, boolean create) {\r\n-        if (name == null || (_cache != null && name.equals(_cache.getName())))\r\n-            return _cache;\r\n-        return null;\r\n-    }\r\n-\r\n-    public QueryCache getSystemQueryCache() {\r\n-        return _queryCache;\r\n-    }\r\n-\r\n-    public DataCachePCDataGenerator getPCDataGenerator() {\r\n-        return _pcGenerator;\r\n-    }\r\n-\r\n-    public DataCacheScheduler getDataCacheScheduler() {\r\n-        return _scheduler;\r\n-    }\r\n-\r\n-    public void close() {\r\n-        ImplHelper.close(_cache);\r\n-        ImplHelper.close(_queryCache);\r\n-        if (_scheduler != null)\r\n-            _scheduler.stop();\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.conf.ObjectValue;\n+import org.apache.openjpa.lib.util.Closeable;\n+import org.apache.openjpa.util.ImplHelper;\n+\n+/**\n+ * <p>Default data cache manager.</p>\n+ *\n+ * @author Abe White\n+ * @author Patrick Linskey\n+ */\n+public class DataCacheManagerImpl\n+    implements Closeable, DataCacheManager {\n+\n+    private DataCache _cache = null;\n+    private QueryCache _queryCache = null;\n+    private DataCachePCDataGenerator _pcGenerator = null;\n+    private DataCacheScheduler _scheduler = null;\n+\n+    public void initialize(OpenJPAConfiguration conf, ObjectValue dataCache,\n+        ObjectValue queryCache) {\n+        _cache = (DataCache) dataCache.instantiate(DataCache.class, conf);\n+        if (_cache == null)\n+            return;\n+\n+        // create helpers before initializing caches\n+        if (conf.getDynamicDataStructs())\n+            _pcGenerator = new DataCachePCDataGenerator(conf);\n+        _scheduler = new DataCacheScheduler(conf);\n+\n+        _cache.initialize(this);\n+        _queryCache = (QueryCache) queryCache.instantiate(QueryCache.class,\n+            conf);\n+        if (_queryCache != null)\n+            _queryCache.initialize(this);\n+    }\n+\n+    public DataCache getSystemDataCache() {\n+        return getDataCache(null, false);\n+    }\n+\n+    public DataCache getDataCache(String name) {\n+        return getDataCache(name, false);\n+    }\n+\n+    public DataCache getDataCache(String name, boolean create) {\n+        if (name == null || (_cache != null && name.equals(_cache.getName())))\n+            return _cache;\n+        return null;\n+    }\n+\n+    public QueryCache getSystemQueryCache() {\n+        return _queryCache;\n+    }\n+\n+    public DataCachePCDataGenerator getPCDataGenerator() {\n+        return _pcGenerator;\n+    }\n+\n+    public DataCacheScheduler getDataCacheScheduler() {\n+        return _scheduler;\n+    }\n+\n+    public void close() {\n+        ImplHelper.close(_cache);\n+        ImplHelper.close(_queryCache);\n+        if (_scheduler != null)\n+            _scheduler.stop();\n+    }\n+}"},{"sha":"a5d3d167709a200276cab844a5a788167417a9f9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCData.java","status":"modified","additions":32,"deletions":28,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCData.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCData.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,28 +1,32 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import org.apache.openjpa.kernel.PCData;\r\n-\r\n-/**\r\n- * Specialized {@link PCData} implementation for data caching.\r\n- *\r\n- * @author Patrick Linskey\r\n- */\r\n-public interface DataCachePCData extends PCData {\r\n-\r\n-    /**\r\n-     * Whether this data is timed out.\r\n-     */\r\n-    public boolean isTimedOut();\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import org.apache.openjpa.kernel.PCData;\n+\n+/**\n+ * Specialized {@link PCData} implementation for data caching.\n+ *\n+ * @author Patrick Linskey\n+ */\n+public interface DataCachePCData\n+    extends PCData {\n+\n+    /**\n+     * Whether this data is timed out.\n+     */\n+    public boolean isTimedOut();\n+}"},{"sha":"8820b6c43f940b35eeff3468ffdcb2190ae5f4bf","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataGenerator.java","status":"modified","additions":232,"deletions":216,"changes":448,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataGenerator.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,216 +1,232 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.Collection;\r\n-import java.util.HashSet;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.enhance.PCDataGenerator;\r\n-import org.apache.openjpa.kernel.AbstractPCData;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.meta.ValueMetaData;\r\n-import serp.bytecode.BCClass;\r\n-import serp.bytecode.BCField;\r\n-import serp.bytecode.BCMethod;\r\n-import serp.bytecode.Code;\r\n-import serp.bytecode.Instruction;\r\n-import serp.bytecode.JumpInstruction;\r\n-\r\n-/**\r\n- * A {@link PCDataGenerator} instance which generates properly\r\n- * synchronized instances suitable for use in the cache. In addition,\r\n- * proper timed behavior is added.\r\n- *\r\n- * @author Steve Kim\r\n- * @since 3.3.0\r\n- */\r\n-public class DataCachePCDataGenerator extends PCDataGenerator {\r\n-\r\n-    public static final String POSTFIX = \"datacache\";\r\n-    private static final Set _synchs = new HashSet(Arrays.asList\r\n-        (new String []{ \"getData\", \"setData\", \"clearData\", \"getImplData\",\r\n-            \"setImplData\", \"setIntermediate\", \"getIntermediate\",\r\n-            \"isLoaded\", \"setLoaded\", \"setVersion\", \"getVersion\", \"store\" }));\r\n-\r\n-    public DataCachePCDataGenerator(OpenJPAConfiguration conf) {\r\n-        super(conf);\r\n-    }\r\n-\r\n-    protected String getUniqueName(Class type) {\r\n-        return super.getUniqueName(type) + POSTFIX;\r\n-    }\r\n-\r\n-    protected void finish(DynamicPCData data, ClassMetaData meta) {\r\n-        int timeout = meta.getDataCacheTimeout();\r\n-        if (timeout > 0)\r\n-            ((Timed) data).setTimeout(timeout + System.currentTimeMillis());\r\n-        else ((Timed) data).setTimeout(-1);\r\n-    }\r\n-\r\n-    protected void decorate(BCClass bc, ClassMetaData meta) {\r\n-        enhanceToData(bc);\r\n-        enhanceToNestedData(bc);\r\n-        replaceToEmbeddedData(bc);\r\n-        addSynchronization(bc);\r\n-        addTimeout(bc);\r\n-    }\r\n-\r\n-    private void enhanceToData(BCClass bc) {\r\n-        BCMethod meth = bc.declareMethod(\"toData\", Object.class,\r\n-            new Class []{ FieldMetaData.class, Object.class });\r\n-        Code code = meth.getCode(true);\r\n-        // if (fmd.isLRS()))\r\n-        // return NULL;\r\n-        code.aload().setParam(0);\r\n-        code.invokevirtual().setMethod(FieldMetaData.class, \"isLRS\",\r\n-            boolean.class, null);\r\n-        JumpInstruction ifins = code.ifeq();\r\n-        code.getstatic().setField(AbstractPCData.class, \"NULL\", Object.class);\r\n-        code.areturn();\r\n-        // super.toData(fmd, val);\r\n-        ifins.setTarget(code.aload().setThis());\r\n-        code.aload().setParam(0);\r\n-        code.aload().setParam(1);\r\n-        code.invokespecial().setMethod(AbstractPCData.class, \"toData\",\r\n-            Object.class, new Class[]{ FieldMetaData.class, Object.class });\r\n-        code.areturn();\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    private void enhanceToNestedData(BCClass bc) {\r\n-        BCMethod meth = bc.declareMethod(\"toNestedData\", Object.class,\r\n-            new Class []{ ValueMetaData.class, Object.class });\r\n-        Code code = meth.getCode(true);\r\n-        // if (val == null)\r\n-        // return null;\r\n-        code.aload().setParam(1);\r\n-        JumpInstruction ifins = code.ifnonnull();\r\n-        code.constant().setNull();\r\n-        code.areturn();\r\n-        // int type = vmd.getDeclaredTypeCode();\r\n-        ifins.setTarget(code.aload().setParam(0));\r\n-        code.invokeinterface().setMethod(ValueMetaData.class,\r\n-            \"getDeclaredTypeCode\", int.class, null);\r\n-        int local = code.getNextLocalsIndex();\r\n-        code.istore().setLocal(local);\r\n-        // if (type != JavaTypes.COLLECTION &&\r\n-        //    type != JavaTypes.MAP &&\r\n-        //    type != JavaTypes.ARRAY)\r\n-        //    return super.toNestedData(type, val, embedded);\r\n-        // else\r\n-        // return NULL;\r\n-        Collection jumps = new ArrayList(3);\r\n-        code.iload().setLocal(local);\r\n-        code.constant().setValue(JavaTypes.COLLECTION);\r\n-        jumps.add(code.ificmpeq());\r\n-        code.iload().setLocal(local);\r\n-        code.constant().setValue(JavaTypes.MAP);\r\n-        jumps.add(code.ificmpeq());\r\n-        code.iload().setLocal(local);\r\n-        code.constant().setValue(JavaTypes.ARRAY);\r\n-        jumps.add(code.ificmpeq());\r\n-        code.aload().setThis();\r\n-        code.aload().setParam(0);\r\n-        code.aload().setParam(1);\r\n-        code.invokespecial().setMethod(AbstractPCData.class, \"toNestedData\",\r\n-            Object.class, new Class[]{ ValueMetaData.class, Object.class });\r\n-        code.areturn();\r\n-        setTarget(code.getstatic().setField\r\n-            (AbstractPCData.class, \"NULL\", Object.class), jumps);\r\n-        code.areturn();\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    private void replaceToEmbeddedData(BCClass bc) {\r\n-        BCMethod meth = bc.declareMethod(\"toEmbeddedData\", Object.class,\r\n-            new Class[]{ Object.class });\r\n-        Code code = meth.getCode(true);\r\n-        code.getstatic().setField(AbstractPCData.class, \"NULL\", Object.class);\r\n-        code.areturn();\r\n-        code.calculateMaxLocals();\r\n-        code.calculateMaxStack();\r\n-    }\r\n-\r\n-    private void addTimeout(BCClass bc) {\r\n-        bc.declareInterface(DataCachePCData.class);\r\n-        bc.declareInterface(Timed.class);\r\n-        // public boolean isTimedOut();\r\n-        BCField field = addBeanField(bc, \"timeout\", long.class);\r\n-        BCMethod meth = bc.declareMethod(\"isTimedOut\", boolean.class, null);\r\n-        Code code = meth.getCode(true);\r\n-        // if (timeout == -1) ...\r\n-        code.aload().setThis();\r\n-        code.getfield().setField(field);\r\n-        code.constant().setValue(-1L);\r\n-        code.lcmp();\r\n-        JumpInstruction ifneg = code.ifeq();\r\n-        // if (timeout >= System.currentTimeMillis())\r\n-        code.aload().setThis();\r\n-        code.getfield().setField(field);\r\n-        code.invokestatic().setMethod(System.class, \"currentTimeMillis\",\r\n-            long.class, null);\r\n-        code.lcmp();\r\n-        JumpInstruction ifnexp = code.ifge();\r\n-        // return true;\r\n-        code.constant().setValue(1);\r\n-        // ... else return false;\r\n-        JumpInstruction go2 = code.go2();\r\n-        Instruction flse = code.constant().setValue(0);\r\n-        ifneg.setTarget(flse);\r\n-        ifnexp.setTarget(flse);\r\n-        go2.setTarget(code.ireturn());\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    private void addSynchronization(BCClass bc) {\r\n-        BCMethod[] methods = bc.getDeclaredMethods();\r\n-        for (int i = 0; i < methods.length; i++) {\r\n-            if (methods[i].isPublic()\r\n-                && _synchs.contains(methods[i].getName()))\r\n-                methods[i].setSynchronized(true);\r\n-        }\r\n-        // add synchronized isLoaded call.\r\n-        // public synchronized boolean isLoaded(int field)\r\n-        // {\r\n-        // return super.isLoaded(field);\r\n-        // }\r\n-        BCMethod method = bc.declareMethod(\"isLoaded\", boolean.class,\r\n-            new Class[]{ int.class });\r\n-        method.setSynchronized(true);\r\n-        Code code = method.getCode(true);\r\n-        code.aload().setThis();\r\n-        code.iload().setParam(0);\r\n-        code.invokespecial().setMethod(AbstractPCData.class, \"isLoaded\",\r\n-            boolean.class, new Class[]{ int.class });\r\n-        code.calculateMaxLocals();\r\n-        code.calculateMaxStack();\r\n-        code.ireturn();\r\n-    }\r\n-\r\n-    /**\r\n-     * Simple interface to give access to expiration time.\r\n-     */\r\n-    public static interface Timed {\r\n-\r\n-        public void setTimeout(long time);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.enhance.PCDataGenerator;\n+import org.apache.openjpa.kernel.AbstractPCData;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.ValueMetaData;\n+import serp.bytecode.BCClass;\n+import serp.bytecode.BCField;\n+import serp.bytecode.BCMethod;\n+import serp.bytecode.Code;\n+import serp.bytecode.Instruction;\n+import serp.bytecode.JumpInstruction;\n+\n+/**\n+ * <p>A {@link PCDataGenerator} instance which generates properly\n+ * synchronized instances suitable for use in the cache.  In addition,\n+ * proper timed behavior is added.</p>\n+ *\n+ * @author Steve Kim\n+ * @since 3.3.0\n+ */\n+public class DataCachePCDataGenerator extends PCDataGenerator {\n+\n+    public static final String POSTFIX = \"datacache\";\n+\n+    private static final Set _synchs = new HashSet(Arrays.asList\n+        (new String []{ \"getData\", \"setData\", \"clearData\", \"getImplData\",\n+            \"setImplData\", \"setIntermediate\", \"getIntermediate\",\n+            \"isLoaded\", \"setLoaded\", \"setVersion\", \"getVersion\", \"store\"\n+        }));\n+\n+    public DataCachePCDataGenerator(OpenJPAConfiguration conf) {\n+        super(conf);\n+    }\n+\n+    protected String getUniqueName(Class type) {\n+        return super.getUniqueName(type) + POSTFIX;\n+    }\n+\n+    protected void finish(DynamicPCData data, ClassMetaData meta) {\n+        int timeout = meta.getDataCacheTimeout();\n+        if (timeout > 0)\n+            ((Timed) data).setTimeout(timeout + System.currentTimeMillis());\n+        else\n+            ((Timed) data).setTimeout(-1);\n+    }\n+\n+    protected void decorate(BCClass bc, ClassMetaData meta) {\n+        enhanceToData(bc);\n+        enhanceToNestedData(bc);\n+        replaceToEmbeddedData(bc);\n+        addSynchronization(bc);\n+        addTimeout(bc);\n+    }\n+\n+    private void enhanceToData(BCClass bc) {\n+        BCMethod meth = bc.declareMethod(\"toData\", Object.class,\n+            new Class []{ FieldMetaData.class, Object.class });\n+        Code code = meth.getCode(true);\n+        // if (fmd.isLRS ()))\n+        // \t\treturn NULL;\n+        code.aload().setParam(0);\n+        code.invokevirtual().setMethod(FieldMetaData.class, \"isLRS\",\n+            boolean.class, null);\n+        JumpInstruction ifins = code.ifeq();\n+        code.getstatic().setField(AbstractPCData.class, \"NULL\", Object.class);\n+        code.areturn();\n+        // super.toData (fmd, val);\n+        ifins.setTarget(code.aload().setThis());\n+        code.aload().setParam(0);\n+        code.aload().setParam(1);\n+        code.invokespecial().setMethod(AbstractPCData.class, \"toData\",\n+            Object.class, new Class[]{ FieldMetaData.class, Object.class });\n+        code.areturn();\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    private void enhanceToNestedData(BCClass bc) {\n+        BCMethod meth = bc.declareMethod(\"toNestedData\", Object.class,\n+            new Class []{ ValueMetaData.class, Object.class });\n+        Code code = meth.getCode(true);\n+\n+        // if (val == null)\n+        // \t\treturn null;\n+        code.aload().setParam(1);\n+        JumpInstruction ifins = code.ifnonnull();\n+        code.constant().setNull();\n+        code.areturn();\n+\n+        // int type = vmd.getDeclaredTypeCode ();\n+        ifins.setTarget(code.aload().setParam(0));\n+        code.invokeinterface().setMethod(ValueMetaData.class,\n+            \"getDeclaredTypeCode\", int.class, null);\n+        int local = code.getNextLocalsIndex();\n+        code.istore().setLocal(local);\n+\n+        // if (type != JavaTypes.COLLECTION &&\n+        // \t   type != JavaTypes.MAP &&\n+        // \t   type != JavaTypes.ARRAY)\n+        // \t   return super.toNestedData (type, val, embedded);\n+        // \telse\n+        // \t\treturn NULL;\n+        Collection jumps = new ArrayList(3);\n+        code.iload().setLocal(local);\n+        code.constant().setValue(JavaTypes.COLLECTION);\n+        jumps.add(code.ificmpeq());\n+        code.iload().setLocal(local);\n+        code.constant().setValue(JavaTypes.MAP);\n+        jumps.add(code.ificmpeq());\n+        code.iload().setLocal(local);\n+        code.constant().setValue(JavaTypes.ARRAY);\n+        jumps.add(code.ificmpeq());\n+        code.aload().setThis();\n+        code.aload().setParam(0);\n+        code.aload().setParam(1);\n+        code.invokespecial().setMethod(AbstractPCData.class, \"toNestedData\",\n+            Object.class, new Class[]{ ValueMetaData.class, Object.class });\n+        code.areturn();\n+        setTarget(code.getstatic().setField\n+            (AbstractPCData.class, \"NULL\", Object.class), jumps);\n+        code.areturn();\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    private void replaceToEmbeddedData(BCClass bc) {\n+        BCMethod meth = bc.declareMethod(\"toEmbeddedData\", Object.class,\n+            new Class[]{ Object.class });\n+        Code code = meth.getCode(true);\n+        code.getstatic().setField(AbstractPCData.class, \"NULL\", Object.class);\n+        code.areturn();\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n+    }\n+\n+    private void addTimeout(BCClass bc) {\n+        bc.declareInterface(DataCachePCData.class);\n+        bc.declareInterface(Timed.class);\n+\n+        // public boolean isTimedOut ();\n+        BCField field = addBeanField(bc, \"timeout\", long.class);\n+        BCMethod meth = bc.declareMethod(\"isTimedOut\", boolean.class, null);\n+        Code code = meth.getCode(true);\n+\n+        // if (timeout == -1) ...\n+        code.aload().setThis();\n+        code.getfield().setField(field);\n+        code.constant().setValue(-1L);\n+        code.lcmp();\n+        JumpInstruction ifneg = code.ifeq();\n+\n+        // if (timeout >= System.currentTimeMillis ())\n+        code.aload().setThis();\n+        code.getfield().setField(field);\n+        code.invokestatic().setMethod(System.class, \"currentTimeMillis\",\n+            long.class, null);\n+        code.lcmp();\n+        JumpInstruction ifnexp = code.ifge();\n+\n+        // return true;\n+        code.constant().setValue(1);\n+\n+        // ... else return false;\n+        JumpInstruction go2 = code.go2();\n+        Instruction flse = code.constant().setValue(0);\n+        ifneg.setTarget(flse);\n+        ifnexp.setTarget(flse);\n+        go2.setTarget(code.ireturn());\n+\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    private void addSynchronization(BCClass bc) {\n+        BCMethod[] methods = bc.getDeclaredMethods();\n+        for (int i = 0; i < methods.length; i++) {\n+            if (methods[i].isPublic()\n+                && _synchs.contains(methods[i].getName()))\n+                methods[i].setSynchronized(true);\n+        }\n+\n+        // add synchronized isLoaded call.\n+        // public synchronized boolean isLoaded (int field)\n+        // {\n+        // \t\treturn super.isLoaded (field);\n+        // }\n+        BCMethod method = bc.declareMethod(\"isLoaded\", boolean.class,\n+            new Class[]{ int.class });\n+        method.setSynchronized(true);\n+        Code code = method.getCode(true);\n+        code.aload().setThis();\n+        code.iload().setParam(0);\n+        code.invokespecial().setMethod(AbstractPCData.class, \"isLoaded\",\n+            boolean.class, new Class[]{ int.class });\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n+        code.ireturn();\n+    }\n+\n+    /**\n+     * Simple interface to give access to expiration time.\n+     */\n+    public static interface Timed {\n+\n+        public void setTimeout(long time);\n+    }\n+}"},{"sha":"bb8e26cfc00b8c4d4c466ad338e9e92998e411a7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java","status":"modified","additions":145,"deletions":137,"changes":282,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,137 +1,145 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.BitSet;\r\n-\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.PCData;\r\n-import org.apache.openjpa.kernel.PCDataImpl;\r\n-import org.apache.openjpa.kernel.StoreContext;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.meta.ValueMetaData;\r\n-\r\n-/**\r\n- * Specialized {@link PCData} implementation for data caching. This\r\n- * implementation is properly synchronized.\r\n- *\r\n- * @author Patrick Linskey\r\n- */\r\n-public class DataCachePCDataImpl extends PCDataImpl implements DataCachePCData {\r\n-\r\n-    private final long _exp;\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     */\r\n-    public DataCachePCDataImpl(Object oid, ClassMetaData meta) {\r\n-        super(oid, meta);\r\n-        int timeout = meta.getDataCacheTimeout();\r\n-        if (timeout > 0)\r\n-            _exp = System.currentTimeMillis() + timeout;\r\n-        else _exp = -1;\r\n-    }\r\n-\r\n-    public boolean isTimedOut() {\r\n-        return _exp != -1 && _exp < System.currentTimeMillis();\r\n-    }\r\n-\r\n-    public synchronized Object getData(int index) {\r\n-        return super.getData(index);\r\n-    }\r\n-\r\n-    public synchronized void setData(int index, Object val) {\r\n-        super.setData(index, val);\r\n-    }\r\n-\r\n-    public synchronized void clearData(int index) {\r\n-        super.clearData(index);\r\n-    }\r\n-\r\n-    public synchronized Object getImplData() {\r\n-        return super.getImplData();\r\n-    }\r\n-\r\n-    public synchronized void setImplData(Object val) {\r\n-        super.setImplData(val);\r\n-    }\r\n-\r\n-    public synchronized Object getImplData(int index) {\r\n-        return super.getImplData(index);\r\n-    }\r\n-\r\n-    public synchronized void setImplData(int index, Object val) {\r\n-        super.setImplData(index, val);\r\n-    }\r\n-\r\n-    public synchronized Object getIntermediate(int index) {\r\n-        return super.getIntermediate(index);\r\n-    }\r\n-\r\n-    public synchronized void setIntermediate(int index, Object val) {\r\n-        super.setIntermediate(index, val);\r\n-    }\r\n-\r\n-    public synchronized boolean isLoaded(int index) {\r\n-        return super.isLoaded(index);\r\n-    }\r\n-\r\n-    public synchronized void setLoaded(int index, boolean loaded) {\r\n-        super.setLoaded(index, loaded);\r\n-    }\r\n-\r\n-    public synchronized Object getVersion() {\r\n-        return super.getVersion();\r\n-    }\r\n-\r\n-    public synchronized void setVersion(Object version) {\r\n-        super.setVersion(version);\r\n-    }\r\n-\r\n-    public synchronized void store(OpenJPAStateManager sm) {\r\n-        super.store(sm);\r\n-    }\r\n-\r\n-    public synchronized void store(OpenJPAStateManager sm, BitSet fields) {\r\n-        super.store(sm, fields);\r\n-    }\r\n-\r\n-    protected Object toData(FieldMetaData fmd, Object val, StoreContext ctx) {\r\n-        // avoid caching large result set fields\r\n-        if (fmd.isLRS())\r\n-            return NULL;\r\n-        return super.toData(fmd, val, ctx);\r\n-    }\r\n-\r\n-    protected Object toNestedData(ValueMetaData vmd, Object val,\r\n-        StoreContext ctx) {\r\n-        if (val == null)\r\n-            return null;\r\n-        // don't try to cache nested containers\r\n-        switch (vmd.getDeclaredTypeCode()) {\r\n-            case JavaTypes.COLLECTION:\r\n-            case JavaTypes.MAP:\r\n-            case JavaTypes.ARRAY:\r\n-                return NULL;\r\n-            default:\r\n-                return super.toNestedData(vmd, val, ctx);\r\n-        }\r\n-    }\r\n-\r\n-    protected Object toEmbeddedData(Object val) {\r\n-        // don't try to cache embedded pcs until we do some testing\r\n-        return NULL;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.BitSet;\n+\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.PCData;\n+import org.apache.openjpa.kernel.PCDataImpl;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.ValueMetaData;\n+\n+/**\n+ * Specialized {@link PCData} implementation for data caching.  This\n+ * implementation is properly synchronized.\n+ *\n+ * @author Patrick Linskey\n+ */\n+public class DataCachePCDataImpl\n+    extends PCDataImpl\n+    implements DataCachePCData {\n+\n+    private final long _exp;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DataCachePCDataImpl(Object oid, ClassMetaData meta) {\n+        super(oid, meta);\n+\n+        int timeout = meta.getDataCacheTimeout();\n+        if (timeout > 0)\n+            _exp = System.currentTimeMillis() + timeout;\n+        else\n+            _exp = -1;\n+    }\n+\n+    public boolean isTimedOut() {\n+        return _exp != -1 && _exp < System.currentTimeMillis();\n+    }\n+\n+    public synchronized Object getData(int index) {\n+        return super.getData(index);\n+    }\n+\n+    public synchronized void setData(int index, Object val) {\n+        super.setData(index, val);\n+    }\n+\n+    public synchronized void clearData(int index) {\n+        super.clearData(index);\n+    }\n+\n+    public synchronized Object getImplData() {\n+        return super.getImplData();\n+    }\n+\n+    public synchronized void setImplData(Object val) {\n+        super.setImplData(val);\n+    }\n+\n+    public synchronized Object getImplData(int index) {\n+        return super.getImplData(index);\n+    }\n+\n+    public synchronized void setImplData(int index, Object val) {\n+        super.setImplData(index, val);\n+    }\n+\n+    public synchronized Object getIntermediate(int index) {\n+        return super.getIntermediate(index);\n+    }\n+\n+    public synchronized void setIntermediate(int index, Object val) {\n+        super.setIntermediate(index, val);\n+    }\n+\n+    public synchronized boolean isLoaded(int index) {\n+        return super.isLoaded(index);\n+    }\n+\n+    public synchronized void setLoaded(int index, boolean loaded) {\n+        super.setLoaded(index, loaded);\n+    }\n+\n+    public synchronized Object getVersion() {\n+        return super.getVersion();\n+    }\n+\n+    public synchronized void setVersion(Object version) {\n+        super.setVersion(version);\n+    }\n+\n+    public synchronized void store(OpenJPAStateManager sm) {\n+        super.store(sm);\n+    }\n+\n+    public synchronized void store(OpenJPAStateManager sm, BitSet fields) {\n+        super.store(sm, fields);\n+    }\n+\n+    protected Object toData(FieldMetaData fmd, Object val, StoreContext ctx) {\n+        // avoid caching large result set fields\n+        if (fmd.isLRS())\n+            return NULL;\n+        return super.toData(fmd, val, ctx);\n+    }\n+\n+    protected Object toNestedData(ValueMetaData vmd, Object val,\n+        StoreContext ctx) {\n+        if (val == null)\n+            return null;\n+\n+        // don't try to cache nested containers\n+        switch (vmd.getDeclaredTypeCode()) {\n+            case JavaTypes.COLLECTION:\n+            case JavaTypes.MAP:\n+            case JavaTypes.ARRAY:\n+                return NULL;\n+            default:\n+                return super.toNestedData(vmd, val, ctx);\n+        }\n+    }\n+\n+    protected Object toEmbeddedData(Object val) {\n+        // don't try to cache embedded pcs until we do some testing\n+        return NULL;\n+    }\n+}"},{"sha":"f39fba9a8d3baecd87e69be47e1c9bb7b48850e2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","status":"modified","additions":248,"deletions":226,"changes":474,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,226 +1,248 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.text.DateFormat;\r\n-import java.text.SimpleDateFormat;\r\n-import java.util.Calendar;\r\n-import java.util.Date;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-import java.util.StringTokenizer;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\r\n-import org.apache.openjpa.util.InvalidStateException;\r\n-import org.apache.openjpa.util.UserException;\r\n-import serp.util.Strings;\r\n-\r\n-/**\r\n- * Cron-style cache eviction. Understands schedules based on cron format:\r\n- * <code>minute hour mday month wday</code>\r\n- * For example:\r\n- * <code>15,30 6,19 2,10 1 2 </code>\r\n- * Would run at 15 and 30 past the 6AM and 7PM, on the 2nd and 10th\r\n- * of January when its a Monday.\r\n- *\r\n- * @author Steve Kim\r\n- */\r\n-public class DataCacheScheduler implements Runnable {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (DataCacheScheduler.class);\r\n-    private static final DateFormat _fom = new SimpleDateFormat(\"E HH:mm:ss\");\r\n-    private Map _caches = new ConcurrentHashMap();\r\n-    private boolean _stop = false;\r\n-    private int _interval = 2;\r\n-    private Log _log;\r\n-    private Thread _thread;\r\n-\r\n-    public DataCacheScheduler(OpenJPAConfiguration conf) {\r\n-        _log = conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n-    }\r\n-\r\n-    /**\r\n-     * The interval time in minutes between cache checks. Defaults to 2.\r\n-     */\r\n-    public int getInterval() {\r\n-        return _interval;\r\n-    }\r\n-\r\n-    /**\r\n-     * The interval time in minutes between cache checks. Defaults to 2.\r\n-     */\r\n-    public void setInterval(int interval) {\r\n-        _interval = interval;\r\n-    }\r\n-\r\n-    /**\r\n-     * Stop the associated thread if there and stop the current runnable.\r\n-     */\r\n-    public synchronized void stop() {\r\n-        _stop = true;\r\n-    }\r\n-\r\n-    private boolean isStopped() {\r\n-        return _stop;\r\n-    }\r\n-\r\n-    /**\r\n-     * Schedule the given cache for eviction. Starts the scheduling thread\r\n-     * if not started.\r\n-     */\r\n-    public synchronized void scheduleEviction(DataCache cache, String times) {\r\n-        if (times == null)\r\n-            return;\r\n-        Schedule schedule = new Schedule(times);\r\n-        _caches.put(cache, schedule);\r\n-        _stop = false;\r\n-        if (_thread == null) {\r\n-            _thread = new Thread(this, _loc.get(\"scheduler-name\"));\r\n-            _thread.start();\r\n-            if (_log.isTraceEnabled())\r\n-                _log.trace(_loc.get(\"scheduler-start\", _thread.getName()));\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove the given cache from scheduling.\r\n-     */\r\n-    public synchronized void removeFromSchedule(DataCache cache) {\r\n-        _caches.remove(cache);\r\n-        if (_caches.size() == 0)\r\n-            stop();\r\n-    }\r\n-\r\n-    public void run() {\r\n-        if (_log.isTraceEnabled())\r\n-            _log.trace(_loc.get(\"scheduler-interval\", _interval + \"\"));\r\n-        Date lastRun = new Date();\r\n-        while (!isStopped()) {\r\n-            try {\r\n-                Thread.sleep(_interval * 60 * 1000);\r\n-                Date now = new Date();\r\n-                DataCache cache;\r\n-                Schedule schedule;\r\n-                Map.Entry entry;\r\n-                for (Iterator i = _caches.entrySet().iterator(); i.hasNext();) {\r\n-                    entry = (Map.Entry) i.next();\r\n-                    cache = (DataCache) entry.getKey();\r\n-                    schedule = (Schedule) entry.getValue();\r\n-                    if (schedule.matches(lastRun, now)) {\r\n-                        if (_log.isTraceEnabled())\r\n-                            _log.trace(_loc.get(\"scheduler-clear\",\r\n-                                cache.getName(), _fom.format(now)));\r\n-                        evict(cache);\r\n-                    }\r\n-                }\r\n-                lastRun = now;\r\n-            } catch (Exception e) {\r\n-                throw new InvalidStateException(_loc.get(\"scheduler-fail\"), e).\r\n-                    setFatal(true);\r\n-            }\r\n-        }\r\n-        _log.info(_loc.get(\"scheduler-stop\"));\r\n-        synchronized (this) {\r\n-            if (isStopped())\r\n-                _thread = null; // be sure to deref the thread so it can restart\r\n-        }\r\n-    }\r\n-\r\n-    protected void evict(DataCache cache) {\r\n-        cache.clear();\r\n-    }\r\n-\r\n-    /**\r\n-     * Simple class which represents the given time schedule.\r\n-     */\r\n-    private static class Schedule {\r\n-\r\n-        static final int[] WILDCARD = new int[0];\r\n-        static final int[] UNITS = {\r\n-            Calendar.MONTH, Calendar.DAY_OF_MONTH, Calendar.DAY_OF_WEEK,\r\n-            Calendar.HOUR_OF_DAY, Calendar.MINUTE };\r\n-        final int[] month;\r\n-        final int[] dayOfMonth;\r\n-        final int[] dayOfWeek;\r\n-        final int[] hour;\r\n-        final int[] min;\r\n-\r\n-        public Schedule(String date) {\r\n-            StringTokenizer token = new StringTokenizer(date, \" \\t\");\r\n-            if (token.countTokens() != 5)\r\n-                throw new UserException(_loc.get(\"bad-count\", date)).\r\n-                    setFatal(true);\r\n-            try {\r\n-                min = parse(token.nextToken(), 0, 60);\r\n-                hour = parse(token.nextToken(), 0, 24);\r\n-                dayOfMonth = parse(token.nextToken(), 1, 31);\r\n-                month = parse(token.nextToken(), 1, 13);\r\n-                dayOfWeek = parse(token.nextToken(), 1, 8);\r\n-            } catch (Throwable t) {\r\n-                throw new UserException(_loc.get(\"bad-schedule\", date), t).\r\n-                    setFatal(true);\r\n-            }\r\n-        }\r\n-\r\n-        private int[] parse(String token, int min, int max) {\r\n-            if (token.trim().equals(\"*\"))\r\n-                return WILDCARD;\r\n-            String[] tokens = Strings.split(token, \",\", 0);\r\n-            int [] times = new int[tokens.length];\r\n-            for (int i = 0; i < tokens.length; i++) {\r\n-                try {\r\n-                    times[i] = Integer.parseInt(tokens[i]);\r\n-                } catch (Throwable t) {\r\n-                    throw new UserException(_loc.get(\"not-number\", token)).\r\n-                        setFatal(true);\r\n-                }\r\n-                if (times[i] < min || times[i] >= max)\r\n-                    throw new UserException(_loc.get(\"not-range\", token,\r\n-                        String.valueOf(min), String.valueOf(max))).\r\n-                        setFatal(true);\r\n-            }\r\n-            return times;\r\n-        }\r\n-\r\n-        boolean matches(Date last, Date now) {\r\n-            Calendar time = Calendar.getInstance();\r\n-            time.setTime(now);\r\n-            time.set(Calendar.SECOND, 0);\r\n-            time.set(Calendar.MILLISECOND, 0);\r\n-            int[][] all =\r\n-                new int[][]{ month, dayOfMonth, dayOfWeek, hour, min };\r\n-            return matches(last, now, time, all, 0);\r\n-        }\r\n-\r\n-        private boolean matches(Date last, Date now, Calendar time,\r\n-            int[][] times, int depth) {\r\n-            if (depth == UNITS.length) {\r\n-                Date compare = time.getTime();\r\n-                return compare.compareTo(last) >= 0 &&\r\n-                    compare.compareTo(now) < 0;\r\n-            }\r\n-            if (times[depth] != WILDCARD) {\r\n-                for (int i = 0; i < times[depth].length; i++) {\r\n-                    time.set(UNITS[depth], times[depth][i]);\r\n-                    if (matches(last, now, time, times, depth + 1))\r\n-                        return true;\r\n-                }\r\n-            }\r\n-            return matches(last, now, time, times, depth + 1);\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.StringTokenizer;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n+import org.apache.openjpa.util.InvalidStateException;\n+import org.apache.openjpa.util.UserException;\n+import serp.util.Strings;\n+\n+/**\n+ * <p>Cron-style cache eviction.  Understands schedules based on cron\n+ * format:<p>\n+ * <code>minute hour mday month wday</code>\n+ * <p/>\n+ * <p>For example:</p>\n+ * <code>15,30 6,19 2,10 1 2 </code>\n+ * <p/>\n+ * <p>Would run at 15 and 30 past the 6AM and 7PM, on the 2nd and 10th\n+ * of January when its a Monday</p>.\n+ *\n+ * @author Steve Kim\n+ */\n+public class DataCacheScheduler\n+    implements Runnable {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (DataCacheScheduler.class);\n+\n+    private static final DateFormat _fom = new SimpleDateFormat(\"E HH:mm:ss\");\n+\n+    private Map _caches = new ConcurrentHashMap();\n+    private boolean _stop = false;\n+    private int _interval = 2;\n+    private Log _log;\n+    private Thread _thread;\n+\n+    public DataCacheScheduler(OpenJPAConfiguration conf) {\n+        _log = conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_DATACACHE);\n+    }\n+\n+    /**\n+     * The interval time in minutes between cache checks.  Defaults to 2.\n+     */\n+    public int getInterval() {\n+        return _interval;\n+    }\n+\n+    /**\n+     * The interval time in minutes between cache checks.  Defaults to 2.\n+     */\n+    public void setInterval(int interval) {\n+        _interval = interval;\n+    }\n+\n+    /**\n+     * Stop the associated thread if there and stop the current runnable.\n+     */\n+    public synchronized void stop() {\n+        _stop = true;\n+    }\n+\n+    private boolean isStopped() {\n+        return _stop;\n+    }\n+\n+    /**\n+     * Schedule the given cache for eviction.  Starts the scheduling thread\n+     * if not started.\n+     */\n+    public synchronized void scheduleEviction(DataCache cache, String times) {\n+        if (times == null)\n+            return;\n+\n+        Schedule schedule = new Schedule(times);\n+        _caches.put(cache, schedule);\n+        _stop = false;\n+        if (_thread == null) {\n+            _thread = new Thread(this, _loc.get(\"scheduler-name\"));\n+            _thread.start();\n+            if (_log.isTraceEnabled())\n+                _log.trace(_loc.get(\"scheduler-start\", _thread.getName()));\n+        }\n+    }\n+\n+    /**\n+     * Remove the given cache from scheduling.\n+     */\n+    public synchronized void removeFromSchedule(DataCache cache) {\n+        _caches.remove(cache);\n+        if (_caches.size() == 0)\n+            stop();\n+    }\n+\n+    public void run() {\n+        if (_log.isTraceEnabled())\n+            _log.trace(_loc.get(\"scheduler-interval\", _interval + \"\"));\n+\n+        Date lastRun = new Date();\n+        while (!isStopped()) {\n+            try {\n+                Thread.sleep(_interval * 60 * 1000);\n+\n+                Date now = new Date();\n+                DataCache cache;\n+                Schedule schedule;\n+                Map.Entry entry;\n+                for (Iterator i = _caches.entrySet().iterator(); i.hasNext();) {\n+                    entry = (Map.Entry) i.next();\n+                    cache = (DataCache) entry.getKey();\n+                    schedule = (Schedule) entry.getValue();\n+                    if (schedule.matches(lastRun, now)) {\n+                        if (_log.isTraceEnabled())\n+                            _log.trace(_loc.get(\"scheduler-clear\",\n+                                cache.getName(), _fom.format(now)));\n+                        evict(cache);\n+                    }\n+                }\n+                lastRun = now;\n+            }\n+            catch (Exception e) {\n+                throw new InvalidStateException(_loc.get(\"scheduler-fail\"), e).\n+                    setFatal(true);\n+            }\n+        }\n+\n+        _log.info(_loc.get(\"scheduler-stop\"));\n+        synchronized (this) {\n+            if (isStopped())\n+                _thread = null; // be sure to deref the thread so it can restart\n+        }\n+    }\n+\n+    protected void evict(DataCache cache) {\n+        cache.clear();\n+    }\n+\n+    /**\n+     *\tSimple class which represents the given time schedule.\n+     */\n+    private static class Schedule {\n+\n+        static final int[] WILDCARD = new int[0];\n+        static final int[] UNITS = {\n+            Calendar.MONTH,\n+            Calendar.DAY_OF_MONTH,\n+            Calendar.DAY_OF_WEEK,\n+            Calendar.HOUR_OF_DAY,\n+            Calendar.MINUTE\n+        };\n+        final int[] month;\n+        final int[] dayOfMonth;\n+        final int[] dayOfWeek;\n+        final int[] hour;\n+        final int[] min;\n+\n+        public Schedule(String date) {\n+            StringTokenizer token = new StringTokenizer(date, \" \\t\");\n+            if (token.countTokens() != 5)\n+                throw new UserException(_loc.get(\"bad-count\", date)).\n+                    setFatal(true);\n+            try {\n+                min = parse(token.nextToken(), 0, 60);\n+                hour = parse(token.nextToken(), 0, 24);\n+                dayOfMonth = parse(token.nextToken(), 1, 31);\n+                month = parse(token.nextToken(), 1, 13);\n+                dayOfWeek = parse(token.nextToken(), 1, 8);\n+            }\n+            catch (Throwable t) {\n+                throw new UserException(_loc.get(\"bad-schedule\", date), t).\n+                    setFatal(true);\n+            }\n+        }\n+\n+        private int[] parse(String token, int min, int max) {\n+            if (token.trim().equals(\"*\"))\n+                return WILDCARD;\n+            String[] tokens = Strings.split(token, \",\", 0);\n+            int [] times = new int[tokens.length];\n+            for (int i = 0; i < tokens.length; i++) {\n+                try {\n+                    times[i] = Integer.parseInt(tokens[i]);\n+                }\n+                catch (Throwable t) {\n+                    throw new UserException(_loc.get(\"not-number\", token)).\n+                        setFatal(true);\n+                }\n+                if (times[i] < min || times[i] >= max)\n+                    throw new UserException(_loc.get(\"not-range\", token,\n+                        String.valueOf(min), String.valueOf(max))).\n+                        setFatal(true);\n+            }\n+            return times;\n+        }\n+\n+        boolean matches(Date last, Date now) {\n+            Calendar time = Calendar.getInstance();\n+            time.setTime(now);\n+            time.set(Calendar.SECOND, 0);\n+            time.set(Calendar.MILLISECOND, 0);\n+\n+            int[][] all =\n+                new int[][]{ month, dayOfMonth, dayOfWeek, hour, min };\n+            return matches(last, now, time, all, 0);\n+        }\n+\n+        private boolean matches(Date last, Date now, Calendar time,\n+            int[][] times, int depth) {\n+            if (depth == UNITS.length) {\n+                Date compare = time.getTime();\n+                return compare.compareTo(last) >= 0 &&\n+                    compare.compareTo(now) < 0;\n+            }\n+\n+            if (times[depth] != WILDCARD) {\n+                for (int i = 0; i < times[depth].length; i++) {\n+                    time.set(UNITS[depth], times[depth][i]);\n+                    if (matches(last, now, time, times, depth + 1))\n+                        return true;\n+                }\n+            }\n+            return matches(last, now, time, times, depth + 1);\n+\t\t}\n+\t}\n+}"},{"sha":"a8cbf32c9455a4513049e605ec47b6875a0e92f0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","status":"modified","additions":618,"deletions":563,"changes":1181,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,563 +1,618 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.BitSet;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.enhance.PCDataGenerator;\r\n-import org.apache.openjpa.kernel.DelegatingStoreManager;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.FetchState;\r\n-import org.apache.openjpa.kernel.LockLevels;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.PCState;\r\n-import org.apache.openjpa.kernel.QueryLanguages;\r\n-import org.apache.openjpa.kernel.StoreContext;\r\n-import org.apache.openjpa.kernel.StoreManager;\r\n-import org.apache.openjpa.kernel.StoreQuery;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-\r\n-/**\r\n- * StoreManager proxy that delegates to a data cache when possible.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @nojavadoc\r\n- */\r\n-public class DataCacheStoreManager extends DelegatingStoreManager {\r\n-\r\n-    // all the state managers changed in this transaction\r\n-    private Collection _inserts = null; // statemanagers\r\n-    private Map _updates = null; // statemanager -> fmd set\r\n-    private Collection _deletes = null; // statemanagers\r\n-    // the owning context\r\n-    private StoreContext _ctx = null;\r\n-    // pc data generator\r\n-    private PCDataGenerator _gen = null;\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param sm the store manager to delegate to\r\n-     */\r\n-    public DataCacheStoreManager(StoreManager sm) {\r\n-        super(sm);\r\n-    }\r\n-\r\n-    public void setContext(StoreContext ctx) {\r\n-        _ctx = ctx;\r\n-        _gen = ctx.getConfiguration().getDataCacheManagerInstance().\r\n-            getPCDataGenerator();\r\n-        super.setContext(ctx);\r\n-    }\r\n-\r\n-    public void begin() {\r\n-        super.begin();\r\n-    }\r\n-\r\n-    public void commit() {\r\n-        try {\r\n-            super.commit();\r\n-            updateCaches();\r\n-        }\r\n-        finally {\r\n-            _inserts = null;\r\n-            _updates = null;\r\n-            _deletes = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void rollback() {\r\n-        try {\r\n-            super.rollback();\r\n-        }\r\n-        finally {\r\n-            _inserts = null;\r\n-            _updates = null;\r\n-            _deletes = null;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Evict all members of the given classes.\r\n-     */\r\n-    private void evictTypes(Collection classes) {\r\n-        if (classes.isEmpty())\r\n-            return;\r\n-        MetaDataRepository mdr =\r\n-            _ctx.getConfiguration(). getMetaDataRepository();\r\n-        ClassLoader loader = _ctx.getClassLoader();\r\n-        Class cls;\r\n-        DataCache cache;\r\n-        for (Iterator itr = classes.iterator(); itr.hasNext();) {\r\n-            cls = (Class) itr.next();\r\n-            cache = mdr.getMetaData(cls, loader, false).getDataCache();\r\n-            if (cache != null)\r\n-                cache.removeAll(cls, false);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Update all caches with the committed inserts, updates, and deletes.\r\n-     */\r\n-    private void updateCaches() {\r\n-        // map each data cache to the modifications we need to perform\r\n-        Map modMap = null;\r\n-        Modifications mods;\r\n-        OpenJPAStateManager sm;\r\n-        DataCachePCData data;\r\n-        DataCache cache;\r\n-        // create pc datas for inserts\r\n-        if (_ctx.getPopulateDataCache() && _inserts != null) {\r\n-            for (Iterator itr = _inserts.iterator(); itr.hasNext();) {\r\n-                sm = (OpenJPAStateManager) itr.next();\r\n-                cache = sm.getMetaData().getDataCache();\r\n-                if (cache == null)\r\n-                    continue;\r\n-                if (modMap == null)\r\n-                    modMap = new HashMap();\r\n-                mods = getModifications(modMap, cache);\r\n-                data = newPCData(sm);\r\n-                data.store(sm);\r\n-                mods.additions.add(new PCDataHolder(data, sm));\r\n-            }\r\n-        }\r\n-        // update pcdatas for updates\r\n-        Map.Entry entry;\r\n-        if (_updates != null) {\r\n-            BitSet fields;\r\n-            for (Iterator itr = _updates.entrySet().iterator();\r\n-                itr.hasNext();) {\r\n-                entry = (Map.Entry) itr.next();\r\n-                sm = (OpenJPAStateManager) entry.getKey();\r\n-                fields = (BitSet) entry.getValue();\r\n-                cache = sm.getMetaData().getDataCache();\r\n-                if (cache == null)\r\n-                    continue;\r\n-                // it's ok not to clone the object that we get from the cache,\r\n-                // since we're inside the commit() method, so any modifications\r\n-                // to the underlying cache are valid. If the commit had not\r\n-                // already succeeded, then we'd want to clone the retrieved\r\n-                // object.\r\n-                if (modMap == null)\r\n-                    modMap = new HashMap();\r\n-                data = cache.get(sm.getObjectId());\r\n-                mods = getModifications(modMap, cache);\r\n-                // data should always be non-null, since the object is\r\n-                // dirty, but maybe it got dropped from the cache in the\r\n-                // interim\r\n-                if (data == null) {\r\n-                    data = newPCData(sm);\r\n-                    data.store(sm);\r\n-                    mods.newUpdates.add(new PCDataHolder(data, sm));\r\n-                } else {\r\n-                    data.store(sm, fields);\r\n-                    mods.existingUpdates.add(new PCDataHolder(data, sm));\r\n-                }\r\n-            }\r\n-        }\r\n-        // remove pcdatas for deletes\r\n-        if (_deletes != null) {\r\n-            for (Iterator itr = _deletes.iterator(); itr.hasNext();) {\r\n-                sm = (OpenJPAStateManager) itr.next();\r\n-                cache = sm.getMetaData().getDataCache();\r\n-                if (cache == null)\r\n-                    continue;\r\n-                if (modMap == null)\r\n-                    modMap = new HashMap();\r\n-                mods = getModifications(modMap, cache);\r\n-                mods.deletes.add(sm.getObjectId());\r\n-            }\r\n-        }\r\n-        // notify the caches of the changes\r\n-        if (modMap != null) {\r\n-            for (Iterator itr = modMap.entrySet().iterator(); itr.hasNext();) {\r\n-                entry = (Map.Entry) itr.next();\r\n-                cache = (DataCache) entry.getKey();\r\n-                mods = (Modifications) entry.getValue();\r\n-                // make sure we're not caching old versions\r\n-                cache.writeLock();\r\n-                try {\r\n-                    transformToVersionSafePCDatas(cache, mods.additions);\r\n-                    transformToVersionSafePCDatas(cache, mods.newUpdates);\r\n-                    transformToVersionSafePCDatas(cache, mods.existingUpdates);\r\n-                    cache.commit(mods.additions, mods.newUpdates,\r\n-                        mods.existingUpdates, mods.deletes);\r\n-                }\r\n-                finally {\r\n-                    cache.writeUnlock();\r\n-                }\r\n-            }\r\n-        }\r\n-        // if we were in largeTransaction mode, then we have recorded\r\n-        // the classes of updated/deleted objects and these now need to be\r\n-        // evicted\r\n-        if (_ctx.isLargeTransaction()) {\r\n-            evictTypes(_ctx.getDeletedTypes());\r\n-            evictTypes(_ctx.getUpdatedTypes());\r\n-        }\r\n-        // and notify the query cache.  notify in one batch to reduce synch\r\n-        QueryCache queryCache = _ctx.getConfiguration().\r\n-            getDataCacheManagerInstance().getSystemQueryCache();\r\n-        if (queryCache != null) {\r\n-            Collection pers = _ctx.getPersistedTypes();\r\n-            Collection del = _ctx.getDeletedTypes();\r\n-            Collection up = _ctx.getUpdatedTypes();\r\n-            int size = pers.size() + del.size() + up.size();\r\n-            if (size > 0) {\r\n-                Collection types = new ArrayList(size);\r\n-                types.addAll(pers);\r\n-                types.addAll(del);\r\n-                types.addAll(up);\r\n-                queryCache.onTypesChanged(new TypesChangedEvent(this, types));\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Transforms a collection of {@link PCDataHolder}s that might contain\r\n-     * stale instances into a collection of up-to-date {@link DataCachePCData}s.\r\n-     */\r\n-    private void transformToVersionSafePCDatas(DataCache cache, List holders) {\r\n-        PCDataHolder holder;\r\n-        DataCachePCData oldpc;\r\n-        for (ListIterator iter = holders.listIterator(); iter.hasNext();) {\r\n-            holder = (PCDataHolder) iter.next();\r\n-            oldpc = cache.get(holder.sm.getObjectId());\r\n-            if (oldpc != null && compareVersion(holder.sm,\r\n-                holder.sm.getVersion(), oldpc.getVersion()) == VERSION_EARLIER)\r\n-                iter.remove();\r\n-            else iter.set(holder.pcdata);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a {@link Modifications} instance to track modifications\r\n-     * to the given cache, creating and caching the instance if it does\r\n-     * not already exist in the given map.\r\n-     */\r\n-    private static Modifications getModifications(Map modMap, DataCache cache) {\r\n-        Modifications mods = (Modifications) modMap.get(cache);\r\n-        if (mods == null) {\r\n-            mods = new Modifications();\r\n-            modMap.put(cache, mods);\r\n-        }\r\n-        return mods;\r\n-    }\r\n-\r\n-    public boolean exists(OpenJPAStateManager sm, Object edata) {\r\n-        DataCache cache = sm.getMetaData().getDataCache();\r\n-        if (cache != null && !isLocking(null)\r\n-            && cache.contains(sm.getObjectId()))\r\n-            return true;\r\n-        return super.exists(sm, edata);\r\n-    }\r\n-\r\n-    public boolean syncVersion(OpenJPAStateManager sm, Object edata) {\r\n-        DataCache cache = sm.getMetaData().getDataCache();\r\n-        if (cache == null || sm.isEmbedded())\r\n-            return super.syncVersion(sm, edata);\r\n-        DataCachePCData data;\r\n-        Object version = null;\r\n-        data = cache.get(sm.getObjectId());\r\n-        if (!isLocking(null) && data != null)\r\n-            version = data.getVersion();\r\n-        // if we have a cached version update from there\r\n-        if (version != null) {\r\n-            if (!version.equals(sm.getVersion())) {\r\n-                sm.setVersion(version);\r\n-                return false;\r\n-            }\r\n-            return true;\r\n-        }\r\n-        // use data store version\r\n-        return super.syncVersion(sm, edata);\r\n-    }\r\n-\r\n-    public boolean initialize(OpenJPAStateManager sm, PCState state,\r\n-        FetchState fetchState, Object edata) {\r\n-        DataCache cache = sm.getMetaData().getDataCache();\r\n-        if (cache == null || sm.isEmbedded())\r\n-            return super.initialize(sm, state, fetchState, edata);\r\n-        DataCachePCData data = cache.get(sm.getObjectId());\r\n-        FetchConfiguration fetch = (fetchState == null)\r\n-            ? _ctx.getFetchConfiguration()\r\n-            : fetchState.getFetchConfiguration();\r\n-        if (data != null && !isLocking(fetch)) {\r\n-            //### the 'data.type' access here probably needs to be\r\n-            //### addressed for bug 511\r\n-            sm.initialize(data.getType(), state);\r\n-            data.load(sm, fetchState, edata);\r\n-            return true;\r\n-        }\r\n-        // initialize from store manager\r\n-        if (!super.initialize(sm, state, fetchState, edata))\r\n-            return false;\r\n-        if (!_ctx.getPopulateDataCache())\r\n-            return true;\r\n-        // make sure that we're not trying to cache an old version\r\n-        cache.writeLock();\r\n-        try {\r\n-            data = cache.get(sm.getObjectId());\r\n-            if (data != null && compareVersion(sm, sm.getVersion(),\r\n-                data.getVersion()) == VERSION_EARLIER)\r\n-                return true;\r\n-            // cache newly loaded info. It is safe to cache data frorm\r\n-            // initialize() because this method is only called upon\r\n-            // initial load of the data.\r\n-            if (data == null)\r\n-                data = newPCData(sm);\r\n-            data.store(sm);\r\n-            cache.put(data);\r\n-        }\r\n-        finally {\r\n-            cache.writeUnlock();\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    public boolean load(OpenJPAStateManager sm, BitSet fields,\r\n-        FetchState fetchState, int lockLevel, Object edata) {\r\n-        FetchConfiguration fetch = (fetchState == null)\r\n-            ? _ctx.getFetchConfiguration()\r\n-            : fetchState.getFetchConfiguration();\r\n-        DataCache cache = sm.getMetaData().getDataCache();\r\n-        if (cache == null || sm.isEmbedded())\r\n-            return super.load(sm, fields, fetchState, lockLevel, edata);\r\n-        DataCachePCData data = cache.get(sm.getObjectId());\r\n-        if (lockLevel == LockLevels.LOCK_NONE && !isLocking(fetch)\r\n-            && data != null)\r\n-            data.load(sm, fields, fetchState, edata);\r\n-        if (fields.length() == 0)\r\n-            return true;\r\n-        // load from store manager; clone the set of still-unloaded fields\r\n-        // so that if the store manager decides to modify it it won't affect us\r\n-        if (!super.load(sm, (BitSet) fields.clone(), fetchState,\r\n-            lockLevel, edata))\r\n-            return false;\r\n-        if (!_ctx.getPopulateDataCache())\r\n-            return true;\r\n-        // make sure that we're not trying to cache an old version\r\n-        cache.writeLock();\r\n-        try {\r\n-            data = cache.get(sm.getObjectId());\r\n-            if (data != null && compareVersion(sm, sm.getVersion(),\r\n-                data.getVersion()) == VERSION_EARLIER)\r\n-                return true;\r\n-            // cache newly loaded info\r\n-            boolean isNew = data == null;\r\n-            if (isNew)\r\n-                data = newPCData(sm);\r\n-            data.store(sm, fields);\r\n-            if (isNew)\r\n-                cache.put(data);\r\n-            else cache.update(data);\r\n-        }\r\n-        finally {\r\n-            cache.writeUnlock();\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    public Collection loadAll(Collection sms, PCState state, int load,\r\n-        FetchState fetchState, Object edata) {\r\n-        FetchConfiguration fetch = (fetchState == null)\r\n-            ? _ctx.getFetchConfiguration()\r\n-            : fetchState.getFetchConfiguration();\r\n-        if (isLocking(fetch))\r\n-            return super.loadAll(sms, state, load, fetchState, edata);\r\n-        Map unloaded = null;\r\n-        OpenJPAStateManager sm;\r\n-        DataCache cache;\r\n-        DataCachePCData data;\r\n-        BitSet fields;\r\n-        FetchConfiguration fc;\r\n-        for (Iterator itr = sms.iterator(); itr.hasNext();) {\r\n-            sm = (OpenJPAStateManager) itr.next();\r\n-            cache = sm.getMetaData().getDataCache();\r\n-            if (cache == null || sm.isEmbedded()) {\r\n-                unloaded = addUnloaded(sm, null, unloaded);\r\n-                continue;\r\n-            }\r\n-            if (sm.getManagedInstance() == null) {\r\n-                data = cache.get(sm.getObjectId());\r\n-                if (data != null) {\r\n-                    //### the 'data.type' access here probably needs\r\n-                    //### to be addressed for bug 511\r\n-                    sm.initialize(data.getType(), state);\r\n-                    data.load(sm, fetchState, edata);\r\n-                } else unloaded = addUnloaded(sm, null, unloaded);\r\n-            } else if (load != FORCE_LOAD_NONE\r\n-                || sm.getPCState() == PCState.HOLLOW) {\r\n-                data = cache.get(sm.getObjectId());\r\n-                if (data != null) {\r\n-                    // ### fc isn't ever accessed; we should check that\r\n-                    // ### getFetchConfiguration() doesn't have any side-effects\r\n-                    // ### and remove this code.\r\n-                    fc = (load == FORCE_LOAD_ALL) ? null\r\n-                        : fetchState.getFetchConfiguration();\r\n-                    // load unloaded fields\r\n-                    fields = sm.getUnloaded(fetchState);\r\n-                    data.load(sm, fields, fetchState, edata);\r\n-                    if (fields.length() > 0)\r\n-                        unloaded = addUnloaded(sm, fields, unloaded);\r\n-                } else unloaded = addUnloaded(sm, null, unloaded);\r\n-            } else if (!cache.contains(sm.getObjectId()))\r\n-                unloaded = addUnloaded(sm, null, unloaded);\r\n-        }\r\n-        if (unloaded == null)\r\n-            return Collections.EMPTY_LIST;\r\n-        // load with delegate\r\n-        Collection failed = super.loadAll(unloaded.keySet(), state, load,\r\n-            fetchState, edata);\r\n-        if (!_ctx.getPopulateDataCache())\r\n-            return failed;\r\n-        // for each loaded instance, merge loaded state into cached data\r\n-        Map.Entry entry;\r\n-        boolean isNew;\r\n-        for (Iterator itr = unloaded.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            sm = (OpenJPAStateManager) entry.getKey();\r\n-            fields = (BitSet) entry.getValue();\r\n-            cache = sm.getMetaData().getDataCache();\r\n-            if (cache == null || sm.isEmbedded() || (failed != null\r\n-                && failed.contains(sm.getId())))\r\n-                continue;\r\n-            // make sure that we're not trying to cache an old version\r\n-            cache.writeLock();\r\n-            try {\r\n-                data = cache.get(sm.getObjectId());\r\n-                if (data != null && compareVersion(sm, sm.getVersion(),\r\n-                    data.getVersion()) == VERSION_EARLIER)\r\n-                    continue;\r\n-                isNew = data == null;\r\n-                if (isNew)\r\n-                    data = newPCData(sm);\r\n-                if (fields == null)\r\n-                    data.store(sm);\r\n-                else data.store(sm, fields);\r\n-                if (isNew)\r\n-                    cache.put(data);\r\n-                else cache.update(data);\r\n-            }\r\n-            finally {\r\n-                cache.writeUnlock();\r\n-            }\r\n-        }\r\n-        return failed;\r\n-    }\r\n-\r\n-    /**\r\n-     * Helper method to add an unloaded instance to the given map.\r\n-     */\r\n-    private static Map addUnloaded(OpenJPAStateManager sm, BitSet fields,\r\n-        Map unloaded) {\r\n-        if (unloaded == null)\r\n-            unloaded = new HashMap();\r\n-        unloaded.put(sm, fields);\r\n-        return unloaded;\r\n-    }\r\n-\r\n-    public Collection flush(Collection states) {\r\n-        Collection exceps = super.flush(states);\r\n-        if (!exceps.isEmpty() || _ctx.isLargeTransaction())\r\n-            return exceps;\r\n-        OpenJPAStateManager sm;\r\n-        for (Iterator itr = states.iterator(); itr.hasNext();) {\r\n-            sm = (OpenJPAStateManager) itr.next();\r\n-            if (sm.getPCState() == PCState.PNEW) {\r\n-                if (_inserts == null)\r\n-                    _inserts = new LinkedList();\r\n-                _inserts.add(sm);\r\n-            } else if (_inserts != null &&\r\n-                sm.getPCState() == PCState.PNEWDELETED ||\r\n-                sm.getPCState() == PCState.PNEWFLUSHEDDELETED)\r\n-                _inserts.remove(sm);\r\n-            else if (sm.getPCState() == PCState.PDIRTY) {\r\n-                if (_updates == null)\r\n-                    _updates = new HashMap();\r\n-                _updates.put(sm, sm.getDirty());\r\n-            } else if (sm.getPCState() == PCState.PDELETED) {\r\n-                if (_deletes == null)\r\n-                    _deletes = new LinkedList();\r\n-                _deletes.add(sm);\r\n-            }\r\n-        }\r\n-        return Collections.EMPTY_LIST;\r\n-    }\r\n-\r\n-    public StoreQuery newQuery(String language) {\r\n-        StoreQuery q = super.newQuery(language);\r\n-        // if the query can't be parsed or it's using a non-parsed language\r\n-        // (one for which there is no OpenJPA ExpressionParser), we can't cache it.\r\n-        if (q == null || QueryLanguages.parserForLanguage(language) == null)\r\n-            return q;\r\n-        QueryCache queryCache = _ctx.getConfiguration().\r\n-            getDataCacheManagerInstance().getSystemQueryCache();\r\n-        if (queryCache == null)\r\n-            return q;\r\n-        return new QueryCacheStoreQuery(q, queryCache);\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new cacheable instance for the given state manager.\r\n-     */\r\n-    private DataCachePCData newPCData(OpenJPAStateManager sm) {\r\n-        ClassMetaData meta = sm.getMetaData();\r\n-        if (_gen != null)\r\n-            return (DataCachePCData) _gen.generatePCData\r\n-                (sm.getObjectId(), meta);\r\n-        return new DataCachePCDataImpl(sm.getObjectId(), meta);\r\n-    }\r\n-\r\n-    /**\r\n-     * Return whether the context is locking loaded data.\r\n-     */\r\n-    private boolean isLocking(FetchConfiguration fetch) {\r\n-        if (fetch == null)\r\n-            fetch = _ctx.getFetchConfiguration();\r\n-        return fetch.getReadLockLevel() > LockLevels.LOCK_NONE;\r\n-    }\r\n-\r\n-    /**\r\n-     * Structure used during the commit process to track cache modifications.\r\n-     */\r\n-    private static class Modifications {\r\n-\r\n-        public final List additions = new LinkedList();\r\n-        public final List newUpdates = new LinkedList();\r\n-        public final List existingUpdates = new LinkedList();\r\n-        public final List deletes = new LinkedList();\r\n-    }\r\n-\r\n-    private static class PCDataHolder {\r\n-\r\n-        public final DataCachePCData pcdata;\r\n-        public final OpenJPAStateManager sm;\r\n-\r\n-        public PCDataHolder(DataCachePCData pcdata, OpenJPAStateManager sm) {\r\n-            this.pcdata = pcdata;\r\n-            this.sm = sm;\r\n-        }\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+\n+import org.apache.openjpa.enhance.PCDataGenerator;\n+import org.apache.openjpa.kernel.DelegatingStoreManager;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.FetchState;\n+import org.apache.openjpa.kernel.LockLevels;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.PCState;\n+import org.apache.openjpa.kernel.QueryLanguages;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+\n+/**\n+ * <p>StoreManager proxy that delegates to a data cache when possible.</p>\n+ *\n+ * @author Patrick Linskey\n+ * @nojavadoc\n+ */\n+public class DataCacheStoreManager\n+    extends DelegatingStoreManager {\n+\n+    // all the state managers changed in this transaction\n+    private Collection _inserts = null;    // statemanagers\n+    private Map _updates = null;    // statemanager -> fmd set\n+    private Collection _deletes = null;    // statemanagers\n+\n+    // the owning context\n+    private StoreContext _ctx = null;\n+\n+    // pc data generator\n+    private PCDataGenerator _gen = null;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param    sm            the store manager to delegate to\n+     */\n+    public DataCacheStoreManager(StoreManager sm) {\n+        super(sm);\n+    }\n+\n+    public void setContext(StoreContext ctx) {\n+        _ctx = ctx;\n+        _gen = ctx.getConfiguration().getDataCacheManagerInstance().\n+            getPCDataGenerator();\n+        super.setContext(ctx);\n+    }\n+\n+    public void begin() {\n+        super.begin();\n+    }\n+\n+    public void commit() {\n+        try {\n+            super.commit();\n+            updateCaches();\n+        }\n+        finally {\n+            _inserts = null;\n+            _updates = null;\n+            _deletes = null;\n+        }\n+    }\n+\n+    public void rollback() {\n+        try {\n+            super.rollback();\n+        }\n+        finally {\n+            _inserts = null;\n+            _updates = null;\n+            _deletes = null;\n+        }\n+    }\n+\n+    /**\n+     * Evict all members of the given classes.\n+     */\n+    private void evictTypes(Collection classes) {\n+        if (classes.isEmpty())\n+            return;\n+\n+        MetaDataRepository mdr = _ctx.getConfiguration().\n+            getMetaDataRepository();\n+        ClassLoader loader = _ctx.getClassLoader();\n+\n+        Class cls;\n+        DataCache cache;\n+        for (Iterator itr = classes.iterator(); itr.hasNext();) {\n+            cls = (Class) itr.next();\n+            cache = mdr.getMetaData(cls, loader, false).getDataCache();\n+            if (cache != null)\n+                cache.removeAll(cls, false);\n+        }\n+    }\n+\n+    /**\n+     * Update all caches with the committed inserts, updates, and deletes.\n+     */\n+    private void updateCaches() {\n+        // map each data cache to the modifications we need to perform\n+        Map modMap = null;\n+        Modifications mods;\n+        OpenJPAStateManager sm;\n+        DataCachePCData data;\n+        DataCache cache;\n+\n+        // create pc datas for inserts\n+        if (_ctx.getPopulateDataCache() && _inserts != null) {\n+            for (Iterator itr = _inserts.iterator(); itr.hasNext();) {\n+                sm = (OpenJPAStateManager) itr.next();\n+                cache = sm.getMetaData().getDataCache();\n+                if (cache == null)\n+                    continue;\n+\n+                if (modMap == null)\n+                    modMap = new HashMap();\n+                mods = getModifications(modMap, cache);\n+                data = newPCData(sm);\n+                data.store(sm);\n+                mods.additions.add(new PCDataHolder(data, sm));\n+            }\n+        }\n+\n+        // update pcdatas for updates\n+        Map.Entry entry;\n+        if (_updates != null) {\n+            BitSet fields;\n+            for (Iterator itr = _updates.entrySet().iterator();\n+                itr.hasNext();) {\n+                entry = (Map.Entry) itr.next();\n+                sm = (OpenJPAStateManager) entry.getKey();\n+                fields = (BitSet) entry.getValue();\n+\n+                cache = sm.getMetaData().getDataCache();\n+                if (cache == null)\n+                    continue;\n+\n+                // it's ok not to clone the object that we get from the cache,\n+                // since we're inside the commit() method, so any modifications\n+                // to the underlying cache are valid. If the commit had not\n+                // already succeeded, then we'd want to clone the retrieved\n+                // object.\n+                if (modMap == null)\n+                    modMap = new HashMap();\n+                data = cache.get(sm.getObjectId());\n+                mods = getModifications(modMap, cache);\n+\n+                // data should always be non-null, since the object is\n+                // dirty, but maybe it got dropped from the cache in the\n+                // interim\n+                if (data == null) {\n+                    data = newPCData(sm);\n+                    data.store(sm);\n+                    mods.newUpdates.add(new PCDataHolder(data, sm));\n+                } else {\n+                    data.store(sm, fields);\n+                    mods.existingUpdates.add(new PCDataHolder(data, sm));\n+                }\n+            }\n+        }\n+\n+        // remove pcdatas for deletes\n+        if (_deletes != null) {\n+            for (Iterator itr = _deletes.iterator(); itr.hasNext();) {\n+                sm = (OpenJPAStateManager) itr.next();\n+                cache = sm.getMetaData().getDataCache();\n+                if (cache == null)\n+                    continue;\n+\n+                if (modMap == null)\n+                    modMap = new HashMap();\n+                mods = getModifications(modMap, cache);\n+                mods.deletes.add(sm.getObjectId());\n+            }\n+        }\n+\n+        // notify the caches of the changes\n+        if (modMap != null) {\n+            for (Iterator itr = modMap.entrySet().iterator(); itr.hasNext();) {\n+                entry = (Map.Entry) itr.next();\n+                cache = (DataCache) entry.getKey();\n+                mods = (Modifications) entry.getValue();\n+\n+                // make sure we're not caching old versions\n+                cache.writeLock();\n+                try {\n+                    transformToVersionSafePCDatas(cache, mods.additions);\n+                    transformToVersionSafePCDatas(cache, mods.newUpdates);\n+                    transformToVersionSafePCDatas(cache, mods.existingUpdates);\n+                    cache.commit(mods.additions, mods.newUpdates,\n+                        mods.existingUpdates, mods.deletes);\n+                }\n+                finally {\n+                    cache.writeUnlock();\n+                }\n+            }\n+        }\n+\n+        // if we were in largeTransaction mode, then we have recorded\n+        // the classes of updated/deleted objects and these now need to be\n+        // evicted\n+        if (_ctx.isLargeTransaction()) {\n+            evictTypes(_ctx.getDeletedTypes());\n+            evictTypes(_ctx.getUpdatedTypes());\n+        }\n+\n+        // and notify the query cache.  notify in one batch to reduce synch\n+        QueryCache queryCache = _ctx.getConfiguration().\n+            getDataCacheManagerInstance().getSystemQueryCache();\n+        if (queryCache != null) {\n+            Collection pers = _ctx.getPersistedTypes();\n+            Collection del = _ctx.getDeletedTypes();\n+            Collection up = _ctx.getUpdatedTypes();\n+            int size = pers.size() + del.size() + up.size();\n+            if (size > 0) {\n+                Collection types = new ArrayList(size);\n+                types.addAll(pers);\n+                types.addAll(del);\n+                types.addAll(up);\n+                queryCache.onTypesChanged(new TypesChangedEvent(this, types));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Transforms a collection of {@link PCDataHolder}s that might contain\n+     * stale instances into a collection of up-to-date\n+     * {@link DataCachePCData}s.\n+     */\n+    private void transformToVersionSafePCDatas(DataCache cache,\n+        List holders) {\n+        PCDataHolder holder;\n+        DataCachePCData oldpc;\n+        for (ListIterator iter = holders.listIterator(); iter.hasNext();) {\n+            holder = (PCDataHolder) iter.next();\n+            oldpc = cache.get(holder.sm.getObjectId());\n+            if (oldpc != null && compareVersion(holder.sm,\n+                holder.sm.getVersion(), oldpc.getVersion()) == VERSION_EARLIER)\n+                iter.remove();\n+            else\n+                iter.set(holder.pcdata);\n+        }\n+    }\n+\n+    /**\n+     * Return a {@link Modifications} instance to track modifications\n+     * to the given cache, creating and caching the instance if it does\n+     * not already exist in the given map.\n+     */\n+    private static Modifications getModifications(Map modMap, DataCache cache) {\n+        Modifications mods = (Modifications) modMap.get(cache);\n+        if (mods == null) {\n+            mods = new Modifications();\n+            modMap.put(cache, mods);\n+        }\n+        return mods;\n+    }\n+\n+    public boolean exists(OpenJPAStateManager sm, Object edata) {\n+        DataCache cache = sm.getMetaData().getDataCache();\n+        if (cache != null && !isLocking(null)\n+            && cache.contains(sm.getObjectId()))\n+            return true;\n+        return super.exists(sm, edata);\n+    }\n+\n+    public boolean syncVersion(OpenJPAStateManager sm, Object edata) {\n+        DataCache cache = sm.getMetaData().getDataCache();\n+        if (cache == null || sm.isEmbedded())\n+            return super.syncVersion(sm, edata);\n+\n+        DataCachePCData data;\n+        Object version = null;\n+        data = cache.get(sm.getObjectId());\n+        if (!isLocking(null) && data != null)\n+            version = data.getVersion();\n+\n+        // if we have a cached version update from there\n+        if (version != null) {\n+            if (!version.equals(sm.getVersion())) {\n+                sm.setVersion(version);\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        // use data store version\n+        return super.syncVersion(sm, edata);\n+    }\n+\n+    public boolean initialize(OpenJPAStateManager sm, PCState state,\n+        FetchState fetchState, Object edata) {\n+        DataCache cache = sm.getMetaData().getDataCache();\n+        if (cache == null || sm.isEmbedded())\n+            return super.initialize(sm, state, fetchState, edata);\n+\n+        DataCachePCData data = cache.get(sm.getObjectId());\n+        FetchConfiguration fetch = (fetchState == null)\n+            ? _ctx.getFetchConfiguration()\n+            : fetchState.getFetchConfiguration();\n+        if (data != null && !isLocking(fetch)) {\n+            //### the 'data.type' access here probably needs to be\n+            //### addressed for bug 511\n+            sm.initialize(data.getType(), state);\n+            data.load(sm, fetchState, edata);\n+            return true;\n+        }\n+\n+        // initialize from store manager\n+        if (!super.initialize(sm, state, fetchState, edata))\n+            return false;\n+        if (!_ctx.getPopulateDataCache())\n+            return true;\n+\n+        // make sure that we're not trying to cache an old version\n+        cache.writeLock();\n+        try {\n+            data = cache.get(sm.getObjectId());\n+            if (data != null && compareVersion(sm, sm.getVersion(),\n+                data.getVersion()) == VERSION_EARLIER)\n+                return true;\n+\n+            // cache newly loaded info. It is safe to cache data frorm\n+            // initialize() because this method is only called upon\n+            // initial load of the data.\n+            if (data == null)\n+                data = newPCData(sm);\n+            data.store(sm);\n+            cache.put(data);\n+        }\n+        finally {\n+            cache.writeUnlock();\n+        }\n+        return true;\n+    }\n+\n+    public boolean load(OpenJPAStateManager sm, BitSet fields,\n+        FetchState fetchState, int lockLevel, Object edata) {\n+        FetchConfiguration fetch = (fetchState == null)\n+            ? _ctx.getFetchConfiguration()\n+            : fetchState.getFetchConfiguration();\n+        DataCache cache = sm.getMetaData().getDataCache();\n+        if (cache == null || sm.isEmbedded())\n+            return super.load(sm, fields, fetchState, lockLevel, edata);\n+\n+        DataCachePCData data = cache.get(sm.getObjectId());\n+        if (lockLevel == LockLevels.LOCK_NONE && !isLocking(fetch)\n+            && data != null)\n+            data.load(sm, fields, fetchState, edata);\n+        if (fields.length() == 0)\n+            return true;\n+\n+        // load from store manager; clone the set of still-unloaded fields\n+        // so that if the store manager decides to modify it it won't affect us\n+        if (!super.load(sm, (BitSet) fields.clone(), fetchState,\n+            lockLevel, edata))\n+            return false;\n+        if (!_ctx.getPopulateDataCache())\n+            return true;\n+\n+        // make sure that we're not trying to cache an old version\n+        cache.writeLock();\n+        try {\n+            data = cache.get(sm.getObjectId());\n+            if (data != null && compareVersion(sm, sm.getVersion(),\n+                data.getVersion()) == VERSION_EARLIER)\n+                return true;\n+\n+            // cache newly loaded info\n+            boolean isNew = data == null;\n+            if (isNew)\n+                data = newPCData(sm);\n+            data.store(sm, fields);\n+            if (isNew)\n+                cache.put(data);\n+            else\n+                cache.update(data);\n+        }\n+        finally {\n+            cache.writeUnlock();\n+        }\n+        return true;\n+    }\n+\n+    public Collection loadAll(Collection sms, PCState state, int load,\n+        FetchState fetchState, Object edata) {\n+        FetchConfiguration fetch = (fetchState == null)\n+            ? _ctx.getFetchConfiguration()\n+            : fetchState.getFetchConfiguration();\n+        if (isLocking(fetch))\n+            return super.loadAll(sms, state, load, fetchState, edata);\n+\n+        Map unloaded = null;\n+        OpenJPAStateManager sm;\n+        DataCache cache;\n+        DataCachePCData data;\n+        BitSet fields;\n+        FetchConfiguration fc;\n+\n+        for (Iterator itr = sms.iterator(); itr.hasNext();) {\n+            sm = (OpenJPAStateManager) itr.next();\n+            cache = sm.getMetaData().getDataCache();\n+            if (cache == null || sm.isEmbedded()) {\n+                unloaded = addUnloaded(sm, null, unloaded);\n+                continue;\n+            }\n+\n+            if (sm.getManagedInstance() == null) {\n+                data = cache.get(sm.getObjectId());\n+                if (data != null) {\n+                    //### the 'data.type' access here probably needs\n+                    //### to be addressed for bug 511\n+                    sm.initialize(data.getType(), state);\n+                    data.load(sm, fetchState, edata);\n+                } else\n+                    unloaded = addUnloaded(sm, null, unloaded);\n+            } else if (load != FORCE_LOAD_NONE\n+                || sm.getPCState() == PCState.HOLLOW) {\n+                data = cache.get(sm.getObjectId());\n+                if (data != null) {\n+                    // ### fc isn't ever accessed; we should check that\n+                    // ### getFetchConfiguration() doesn't have any side-effects\n+                    // ### and remove this code.\n+                    fc = (load == FORCE_LOAD_ALL) ? null\n+                        : fetchState.getFetchConfiguration();\n+\n+                    // load unloaded fields\n+                    fields = sm.getUnloaded(fetchState);\n+                    data.load(sm, fields, fetchState, edata);\n+                    if (fields.length() > 0)\n+                        unloaded = addUnloaded(sm, fields, unloaded);\n+                } else\n+                    unloaded = addUnloaded(sm, null, unloaded);\n+            } else if (!cache.contains(sm.getObjectId()))\n+                unloaded = addUnloaded(sm, null, unloaded);\n+        }\n+\n+        if (unloaded == null)\n+            return Collections.EMPTY_LIST;\n+\n+        // load with delegate\n+        Collection failed = super.loadAll(unloaded.keySet(), state, load,\n+            fetchState, edata);\n+        if (!_ctx.getPopulateDataCache())\n+            return failed;\n+\n+        // for each loaded instance, merge loaded state into cached data\n+        Map.Entry entry;\n+        boolean isNew;\n+        for (Iterator itr = unloaded.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            sm = (OpenJPAStateManager) entry.getKey();\n+            fields = (BitSet) entry.getValue();\n+\n+            cache = sm.getMetaData().getDataCache();\n+            if (cache == null || sm.isEmbedded() || (failed != null\n+                && failed.contains(sm.getId())))\n+                continue;\n+\n+            // make sure that we're not trying to cache an old version\n+            cache.writeLock();\n+            try {\n+                data = cache.get(sm.getObjectId());\n+                if (data != null && compareVersion(sm, sm.getVersion(),\n+                    data.getVersion()) == VERSION_EARLIER)\n+                    continue;\n+\n+                isNew = data == null;\n+                if (isNew)\n+                    data = newPCData(sm);\n+                if (fields == null)\n+                    data.store(sm);\n+                else\n+                    data.store(sm, fields);\n+                if (isNew)\n+                    cache.put(data);\n+                else\n+                    cache.update(data);\n+            }\n+            finally {\n+                cache.writeUnlock();\n+            }\n+        }\n+        return failed;\n+    }\n+\n+    /**\n+     * Helper method to add an unloaded instance to the given map.\n+     */\n+    private static Map addUnloaded(OpenJPAStateManager sm, BitSet fields,\n+        Map unloaded) {\n+        if (unloaded == null)\n+            unloaded = new HashMap();\n+        unloaded.put(sm, fields);\n+        return unloaded;\n+    }\n+\n+    public Collection flush(Collection states) {\n+        Collection exceps = super.flush(states);\n+        if (!exceps.isEmpty() || _ctx.isLargeTransaction())\n+            return exceps;\n+\n+        OpenJPAStateManager sm;\n+        for (Iterator itr = states.iterator(); itr.hasNext();) {\n+            sm = (OpenJPAStateManager) itr.next();\n+\n+            if (sm.getPCState() == PCState.PNEW) {\n+                if (_inserts == null)\n+                    _inserts = new LinkedList();\n+                _inserts.add(sm);\n+            } else if (_inserts != null &&\n+                sm.getPCState() == PCState.PNEWDELETED ||\n+                sm.getPCState() == PCState.PNEWFLUSHEDDELETED)\n+                _inserts.remove(sm);\n+            else if (sm.getPCState() == PCState.PDIRTY) {\n+                if (_updates == null)\n+                    _updates = new HashMap();\n+                _updates.put(sm, sm.getDirty());\n+            } else if (sm.getPCState() == PCState.PDELETED) {\n+                if (_deletes == null)\n+                    _deletes = new LinkedList();\n+                _deletes.add(sm);\n+            }\n+        }\n+        return Collections.EMPTY_LIST;\n+    }\n+\n+    public StoreQuery newQuery(String language) {\n+        StoreQuery q = super.newQuery(language);\n+\n+        // if the query can't be parsed or it's using a non-parsed language\n+        // (one for which there is no OpenJPA ExpressionParser), we can't cache it.\n+        if (q == null || QueryLanguages.parserForLanguage(language) == null)\n+            return q;\n+\n+        QueryCache queryCache = _ctx.getConfiguration().\n+            getDataCacheManagerInstance().getSystemQueryCache();\n+        if (queryCache == null)\n+            return q;\n+\n+        return new QueryCacheStoreQuery(q, queryCache);\n+    }\n+\n+    /**\n+     * Create a new cacheable instance for the given state manager.\n+     */\n+    private DataCachePCData newPCData(OpenJPAStateManager sm) {\n+        ClassMetaData meta = sm.getMetaData();\n+        if (_gen != null)\n+            return (DataCachePCData) _gen.generatePCData\n+                (sm.getObjectId(), meta);\n+        return new DataCachePCDataImpl(sm.getObjectId(), meta);\n+    }\n+\n+    /**\n+     * Return whether the context is locking loaded data.\n+     */\n+    private boolean isLocking(FetchConfiguration fetch) {\n+        if (fetch == null)\n+            fetch = _ctx.getFetchConfiguration();\n+        return fetch.getReadLockLevel() > LockLevels.LOCK_NONE;\n+    }\n+\n+    /**\n+     * Structure used during the commit process to track cache modifications.\n+     */\n+    private static class Modifications {\n+\n+        public final List additions = new LinkedList();\n+        public final List newUpdates = new LinkedList();\n+        public final List existingUpdates = new LinkedList();\n+        public final List deletes = new LinkedList();\n+    }\n+\n+    private static class PCDataHolder {\n+\n+        public final DataCachePCData pcdata;\n+        public final OpenJPAStateManager sm;\n+\n+        public PCDataHolder(DataCachePCData pcdata,\n+            OpenJPAStateManager sm) {\n+            this.pcdata = pcdata;\n+            this.sm = sm;\n+\t\t}\n+\t}\n+}\n+"},{"sha":"be59417a8faf5e6ba92a0ec47c71b8c3997f8136","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java","status":"modified","additions":335,"deletions":307,"changes":642,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,307 +1,335 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.BitSet;\r\n-import java.util.Collection;\r\n-\r\n-import org.apache.commons.lang.ObjectUtils;\r\n-import org.apache.openjpa.util.RuntimeExceptionTranslator;\r\n-\r\n-/**\r\n- * Delegating data cache that can also perform exception translation for\r\n- * use in facades. This cache allows its delegate to be null, in which\r\n- * case it returns default values for all operations.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class DelegatingDataCache implements DataCache {\r\n-\r\n-    private static final BitSet EMPTY_BITSET = new BitSet(0);\r\n-    private final DataCache _cache;\r\n-    private final DelegatingDataCache _del;\r\n-    private final RuntimeExceptionTranslator _trans;\r\n-\r\n-    /**\r\n-     * Constructor. Supply delegate.\r\n-     */\r\n-    public DelegatingDataCache(DataCache cache) {\r\n-        this(cache, null);\r\n-    }\r\n-\r\n-    public DelegatingDataCache(DataCache cache,\r\n-        RuntimeExceptionTranslator trans) {\r\n-        _cache = cache;\r\n-        _trans = trans;\r\n-        if (cache instanceof DelegatingDataCache)\r\n-            _del = (DelegatingDataCache) _cache;\r\n-        else _del = null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the direct delegate.\r\n-     */\r\n-    public DataCache getDelegate() {\r\n-        return _cache;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the native delegate.\r\n-     */\r\n-    public DataCache getInnermostDelegate() {\r\n-        return (_del == null) ? _cache : _del.getInnermostDelegate();\r\n-    }\r\n-\r\n-    public int hashCode() {\r\n-        if (_cache == null)\r\n-            return super.hashCode();\r\n-        return getInnermostDelegate().hashCode();\r\n-    }\r\n-\r\n-    public boolean equals(Object other) {\r\n-        if (other == this)\r\n-            return true;\r\n-        if (other instanceof DelegatingDataCache)\r\n-            other = ((DelegatingDataCache) other).getInnermostDelegate();\r\n-        return ObjectUtils.equals(getInnermostDelegate(), other);\r\n-    }\r\n-\r\n-    /**\r\n-     * Translate the OpenJPA exception.\r\n-     */\r\n-    protected RuntimeException translate(RuntimeException re) {\r\n-        return (_trans == null) ? re : _trans.translate(re);\r\n-    }\r\n-\r\n-    public String getName() {\r\n-        if (_cache == null)\r\n-            return null;\r\n-        try {\r\n-            return _cache.getName();\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void setName(String name) {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.setName(name);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void initialize(DataCacheManager manager) {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.initialize(manager);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void commit(Collection additions, Collection newUpdates,\r\n-        Collection existingUpdates, Collection deletes) {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.commit(additions, newUpdates, existingUpdates, deletes);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean contains(Object oid) {\r\n-        if (_cache == null)\r\n-            return false;\r\n-        try {\r\n-            return _cache.contains(oid);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public BitSet containsAll(Collection oids) {\r\n-        if (_cache == null)\r\n-            return EMPTY_BITSET;\r\n-        try {\r\n-            return _cache.containsAll(oids);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public DataCachePCData get(Object oid) {\r\n-        if (_cache == null)\r\n-            return null;\r\n-        try {\r\n-            return _cache.get(oid);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public DataCachePCData put(DataCachePCData value) {\r\n-        if (_cache == null)\r\n-            return null;\r\n-        try {\r\n-            return _cache.put(value);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void update(DataCachePCData value) {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.update(value);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public DataCachePCData remove(Object oid) {\r\n-        if (_cache == null)\r\n-            return null;\r\n-        try {\r\n-            return _cache.remove(oid);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public BitSet removeAll(Collection oids) {\r\n-        if (_cache == null)\r\n-            return EMPTY_BITSET;\r\n-        try {\r\n-            return _cache.removeAll(oids);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void removeAll(Class cls, boolean subclasses) {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.removeAll(cls, subclasses);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.clear();\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean pin(Object oid) {\r\n-        if (_cache == null)\r\n-            return false;\r\n-        try {\r\n-            return _cache.pin(oid);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public BitSet pinAll(Collection oids) {\r\n-        if (_cache == null)\r\n-            return EMPTY_BITSET;\r\n-        try {\r\n-            return _cache.pinAll(oids);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean unpin(Object oid) {\r\n-        if (_cache == null)\r\n-            return false;\r\n-        try {\r\n-            return _cache.unpin(oid);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public BitSet unpinAll(Collection oids) {\r\n-        if (_cache == null)\r\n-            return EMPTY_BITSET;\r\n-        try {\r\n-            return _cache.unpinAll(oids);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void writeLock() {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.writeLock();\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void writeUnlock() {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.writeUnlock();\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void addExpirationListener(ExpirationListener listen) {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.addExpirationListener(listen);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeExpirationListener(ExpirationListener listen) {\r\n-        if (_cache == null)\r\n-            return false;\r\n-        try {\r\n-            return _cache.removeExpirationListener(listen);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.close();\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.BitSet;\n+import java.util.Collection;\n+\n+import org.apache.commons.lang.ObjectUtils;\n+import org.apache.openjpa.util.RuntimeExceptionTranslator;\n+\n+/**\n+ * <p>Delegating data cache that can also perform exception translation for\n+ * use in facades.  This cache allows its delegate to be null, in which\n+ * case it returns default values for all operations.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class DelegatingDataCache\n+    implements DataCache {\n+\n+    private static final BitSet EMPTY_BITSET = new BitSet(0);\n+\n+    private final DataCache _cache;\n+    private final DelegatingDataCache _del;\n+    private final RuntimeExceptionTranslator _trans;\n+\n+    /**\n+     * Constructor.  Supply delegate.\n+     */\n+    public DelegatingDataCache(DataCache cache) {\n+        this(cache, null);\n+    }\n+\n+    public DelegatingDataCache(DataCache cache,\n+        RuntimeExceptionTranslator trans) {\n+        _cache = cache;\n+        _trans = trans;\n+        if (cache instanceof DelegatingDataCache)\n+            _del = (DelegatingDataCache) _cache;\n+        else\n+            _del = null;\n+    }\n+\n+    /**\n+     * Return the direct delegate.\n+     */\n+    public DataCache getDelegate() {\n+        return _cache;\n+    }\n+\n+    /**\n+     * Return the native delegate.\n+     */\n+    public DataCache getInnermostDelegate() {\n+        return (_del == null) ? _cache : _del.getInnermostDelegate();\n+    }\n+\n+    public int hashCode() {\n+        if (_cache == null)\n+            return super.hashCode();\n+        return getInnermostDelegate().hashCode();\n+    }\n+\n+    public boolean equals(Object other) {\n+        if (other == this)\n+            return true;\n+        if (other instanceof DelegatingDataCache)\n+            other = ((DelegatingDataCache) other).getInnermostDelegate();\n+        return ObjectUtils.equals(getInnermostDelegate(), other);\n+    }\n+\n+    /**\n+     * Translate the OpenJPA exception.\n+     */\n+    protected RuntimeException translate(RuntimeException re) {\n+        return (_trans == null) ? re : _trans.translate(re);\n+    }\n+\n+    public String getName() {\n+        if (_cache == null)\n+            return null;\n+        try {\n+            return _cache.getName();\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void setName(String name) {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.setName(name);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void initialize(DataCacheManager manager) {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.initialize(manager);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void commit(Collection additions, Collection newUpdates,\n+        Collection existingUpdates, Collection deletes) {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.commit(additions, newUpdates, existingUpdates, deletes);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public boolean contains(Object oid) {\n+        if (_cache == null)\n+            return false;\n+        try {\n+            return _cache.contains(oid);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public BitSet containsAll(Collection oids) {\n+        if (_cache == null)\n+            return EMPTY_BITSET;\n+        try {\n+            return _cache.containsAll(oids);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public DataCachePCData get(Object oid) {\n+        if (_cache == null)\n+            return null;\n+        try {\n+            return _cache.get(oid);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public DataCachePCData put(DataCachePCData value) {\n+        if (_cache == null)\n+            return null;\n+        try {\n+            return _cache.put(value);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void update(DataCachePCData value) {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.update(value);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public DataCachePCData remove(Object oid) {\n+        if (_cache == null)\n+            return null;\n+        try {\n+            return _cache.remove(oid);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public BitSet removeAll(Collection oids) {\n+        if (_cache == null)\n+            return EMPTY_BITSET;\n+        try {\n+            return _cache.removeAll(oids);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void removeAll(Class cls, boolean subclasses) {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.removeAll(cls, subclasses);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void clear() {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.clear();\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public boolean pin(Object oid) {\n+        if (_cache == null)\n+            return false;\n+        try {\n+            return _cache.pin(oid);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public BitSet pinAll(Collection oids) {\n+        if (_cache == null)\n+            return EMPTY_BITSET;\n+        try {\n+            return _cache.pinAll(oids);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public boolean unpin(Object oid) {\n+        if (_cache == null)\n+            return false;\n+        try {\n+            return _cache.unpin(oid);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public BitSet unpinAll(Collection oids) {\n+        if (_cache == null)\n+            return EMPTY_BITSET;\n+        try {\n+            return _cache.unpinAll(oids);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void writeLock() {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.writeLock();\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void writeUnlock() {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.writeUnlock();\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void addExpirationListener(ExpirationListener listen) {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.addExpirationListener(listen);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public boolean removeExpirationListener(ExpirationListener listen) {\n+        if (_cache == null)\n+            return false;\n+        try {\n+            return _cache.removeExpirationListener(listen);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void close() {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.close();\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+\t\t}\n+\t}\n+}"},{"sha":"72b855fb0de6a242881862c301ba9874900323ec","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java","status":"modified","additions":229,"deletions":211,"changes":440,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,211 +1,229 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import org.apache.commons.lang.ObjectUtils;\r\n-import org.apache.openjpa.util.RuntimeExceptionTranslator;\r\n-\r\n-/**\r\n- * Delegating query cache that can also perform exception translation for\r\n- * use in facades. This cache allows its delegate to be null, in which case\r\n- * it returns default values or all methods.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- * @since 4.0\r\n- */\r\n-public class DelegatingQueryCache implements QueryCache {\r\n-\r\n-    private final QueryCache _cache;\r\n-    private final DelegatingQueryCache _del;\r\n-    private final RuntimeExceptionTranslator _trans;\r\n-\r\n-    /**\r\n-     * Constructor. Supply delegate.\r\n-     */\r\n-    public DelegatingQueryCache(QueryCache cache) {\r\n-        this(cache, null);\r\n-    }\r\n-\r\n-    public DelegatingQueryCache(QueryCache cache,\r\n-        RuntimeExceptionTranslator trans) {\r\n-        _cache = cache;\r\n-        _trans = trans;\r\n-        if (cache instanceof DelegatingQueryCache)\r\n-            _del = (DelegatingQueryCache) _cache;\r\n-        else _del = null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the direct delegate.\r\n-     */\r\n-    public QueryCache getDelegate() {\r\n-        return _cache;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the native delegate.\r\n-     */\r\n-    public QueryCache getInnermostDelegate() {\r\n-        return (_del == null) ? _cache : _del.getInnermostDelegate();\r\n-    }\r\n-\r\n-    public int hashCode() {\r\n-        return getInnermostDelegate().hashCode();\r\n-    }\r\n-\r\n-    public boolean equals(Object other) {\r\n-        if (other == this)\r\n-            return true;\r\n-        if (other instanceof DelegatingQueryCache)\r\n-            other = ((DelegatingQueryCache) other).getInnermostDelegate();\r\n-        return ObjectUtils.equals(getInnermostDelegate(), other);\r\n-    }\r\n-\r\n-    /**\r\n-     * Translate the OpenJPA exception.\r\n-     */\r\n-    protected RuntimeException translate(RuntimeException re) {\r\n-        return (_trans == null) ? re : _trans.translate(re);\r\n-    }\r\n-\r\n-    public void initialize(DataCacheManager mgr) {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.initialize(mgr);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void onTypesChanged(TypesChangedEvent e) {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.onTypesChanged(e);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public QueryResult get(QueryKey qk) {\r\n-        if (_cache == null)\r\n-            return null;\r\n-        try {\r\n-            return _cache.get(qk);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public QueryResult put(QueryKey qk, QueryResult oids) {\r\n-        if (_cache == null)\r\n-            return null;\r\n-        try {\r\n-            return _cache.put(qk, oids);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public QueryResult remove(QueryKey qk) {\r\n-        if (_cache == null)\r\n-            return null;\r\n-        try {\r\n-            return _cache.remove(qk);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.clear();\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean pin(QueryKey qk) {\r\n-        if (_cache == null)\r\n-            return false;\r\n-        try {\r\n-            return _cache.pin(qk);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean unpin(QueryKey qk) {\r\n-        if (_cache == null)\r\n-            return false;\r\n-        try {\r\n-            return _cache.unpin(qk);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void writeLock() {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.writeLock();\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void writeUnlock() {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.writeUnlock();\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void addTypesChangedListener(TypesChangedListener listen) {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.addTypesChangedListener(listen);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeTypesChangedListener(TypesChangedListener listen) {\r\n-        if (_cache == null)\r\n-            return false;\r\n-        try {\r\n-            return _cache.removeTypesChangedListener(listen);\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (_cache == null)\r\n-            return;\r\n-        try {\r\n-            _cache.close();\r\n-        } catch (RuntimeException re) {\r\n-            throw translate(re);\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import org.apache.commons.lang.ObjectUtils;\n+import org.apache.openjpa.util.RuntimeExceptionTranslator;\n+\n+/**\n+ * <p>Delegating query cache that can also perform exception translation for\n+ * use in facades.  This cache allows its delegate to be null, in which case\n+ * it returns default values or all methods.</p>\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ * @nojavadoc\n+ */\n+public class DelegatingQueryCache\n+    implements QueryCache {\n+\n+    private final QueryCache _cache;\n+    private final DelegatingQueryCache _del;\n+    private final RuntimeExceptionTranslator _trans;\n+\n+    /**\n+     * Constructor.  Supply delegate.\n+     */\n+    public DelegatingQueryCache(QueryCache cache) {\n+        this(cache, null);\n+    }\n+\n+    public DelegatingQueryCache(QueryCache cache,\n+        RuntimeExceptionTranslator trans) {\n+        _cache = cache;\n+        _trans = trans;\n+        if (cache instanceof DelegatingQueryCache)\n+            _del = (DelegatingQueryCache) _cache;\n+        else\n+            _del = null;\n+    }\n+\n+    /**\n+     * Return the direct delegate.\n+     */\n+    public QueryCache getDelegate() {\n+        return _cache;\n+    }\n+\n+    /**\n+     * Return the native delegate.\n+     */\n+    public QueryCache getInnermostDelegate() {\n+        return (_del == null) ? _cache : _del.getInnermostDelegate();\n+    }\n+\n+    public int hashCode() {\n+        return getInnermostDelegate().hashCode();\n+    }\n+\n+    public boolean equals(Object other) {\n+        if (other == this)\n+            return true;\n+        if (other instanceof DelegatingQueryCache)\n+            other = ((DelegatingQueryCache) other).getInnermostDelegate();\n+        return ObjectUtils.equals(getInnermostDelegate(), other);\n+    }\n+\n+    /**\n+     * Translate the OpenJPA exception.\n+     */\n+    protected RuntimeException translate(RuntimeException re) {\n+        return (_trans == null) ? re : _trans.translate(re);\n+    }\n+\n+    public void initialize(DataCacheManager mgr) {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.initialize(mgr);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void onTypesChanged(TypesChangedEvent e) {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.onTypesChanged(e);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public QueryResult get(QueryKey qk) {\n+        if (_cache == null)\n+            return null;\n+        try {\n+            return _cache.get(qk);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public QueryResult put(QueryKey qk, QueryResult oids) {\n+        if (_cache == null)\n+            return null;\n+        try {\n+            return _cache.put(qk, oids);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public QueryResult remove(QueryKey qk) {\n+        if (_cache == null)\n+            return null;\n+        try {\n+            return _cache.remove(qk);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void clear() {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.clear();\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public boolean pin(QueryKey qk) {\n+        if (_cache == null)\n+            return false;\n+        try {\n+            return _cache.pin(qk);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public boolean unpin(QueryKey qk) {\n+        if (_cache == null)\n+            return false;\n+        try {\n+            return _cache.unpin(qk);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void writeLock() {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.writeLock();\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void writeUnlock() {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.writeUnlock();\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void addTypesChangedListener(TypesChangedListener listen) {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.addTypesChangedListener(listen);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public boolean removeTypesChangedListener(TypesChangedListener listen) {\n+        if (_cache == null)\n+            return false;\n+        try {\n+            return _cache.removeTypesChangedListener(listen);\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public void close() {\n+        if (_cache == null)\n+            return;\n+        try {\n+            _cache.close();\n+        }\n+        catch (RuntimeException re) {\n+            throw translate(re);\n+\t\t}\n+\t}\n+}"},{"sha":"89853f0a4c96399d3bc2904352ef501367f77cc7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationEvent.java","status":"modified","additions":62,"deletions":58,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationEvent.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationEvent.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,58 +1,62 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.EventObject;\r\n-\r\n-/**\r\n- * An event indicating the expiration of an object from the data cache,\r\n- * or an expiration of a result list from the query cache.\r\n- * The source of the event will be the cache.\r\n- *\r\n- * @author Abe White\r\n- * @since 3.0\r\n- */\r\n-public class ExpirationEvent extends EventObject {\r\n-\r\n-    private final Object _key;\r\n-    private final boolean _expired;\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param source  the data or query cache\r\n-     * @param key     the expired object oid or query key\r\n-     * @param expired <code>true</code> if the object was expired\r\n-     *                naturally; else <code>false</code>.\r\n-     */\r\n-    public ExpirationEvent(Object source, Object key, boolean expired) {\r\n-        super(source);\r\n-        _key = key;\r\n-        _expired = expired;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the expired object id or query key.\r\n-     */\r\n-    public Object getKey() {\r\n-        return _key;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return whether the expired object was expired naturally, or if\r\n-     * the object was explicitly removed.\r\n-     */\r\n-    public boolean getExpired() {\r\n-        return _expired;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.EventObject;\n+\n+/**\n+ * <p>An event indicating the expiration of an object from the data cache,\n+ * or an expiration of a result list from the query cache.\n+ * The source of the event will be the cache.</p>\n+ *\n+ * @since 3.0\n+ * @author Abe White\n+ */\n+public class ExpirationEvent\n+    extends EventObject {\n+\n+    private final Object _key;\n+    private final boolean _expired;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param    source    the data or query cache\n+     * @param    key        the expired object oid or query key\n+     * @param    expired    <code>true</code> if the object was expired\n+     * naturally; else <code>false</code>.\n+     */\n+    public ExpirationEvent(Object source, Object key, boolean expired) {\n+        super(source);\n+        _key = key;\n+        _expired = expired;\n+    }\n+\n+    /**\n+     * Return the expired object id or query key.\n+     */\n+    public Object getKey() {\n+        return _key;\n+    }\n+\n+    /**\n+     *\tReturn whether the expired object was expired naturally, or if\n+     *\tthe object was explicitly removed.\n+     */\n+    public boolean getExpired() {\n+        return _expired;\n+\t}\n+}"},{"sha":"89e0628470d160af80ccc28c6861b12c2700a05d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationListener.java","status":"modified","additions":30,"deletions":27,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,27 +1,30 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-/**\r\n- * An entity that wishes to be notified when cache keys expire.\r\n- *\r\n- * @author Abe White\r\n- * @since 3.0\r\n- */\r\n-public interface ExpirationListener {\r\n-\r\n-    /**\r\n-     * Notification that an object has expired from the cache.\r\n-     */\r\n-    public void onExpire(ExpirationEvent event);\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+/**\n+ * <p>An entity that wishes to be notified when cache keys expire.</p>\n+ *\n+ * @author Abe White\n+ * @since 3.0\n+ */\n+public interface ExpirationListener {\n+\n+    /**\n+     * Notification that an object has expired from the cache.\n+     */\n+    public void onExpire(ExpirationEvent event);\n+}"},{"sha":"775d7afacb970aee08301f45a76ef3499f29f075","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCache.java","status":"modified","additions":138,"deletions":130,"changes":268,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCache.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,130 +1,138 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.lib.util.Closeable;\r\n-\r\n-/**\r\n- * Interface that must be implemented by any level 2 query cache\r\n- * used by OpenJPA. These methods should be threadsafe.\r\n- * Most query cache implementations will probably implement\r\n- * {@link org.apache.openjpa.lib.conf.Configurable} to receive a handle to the\r\n- * system configuration on construction.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @since 2.5\r\n- */\r\n-public interface QueryCache extends TypesChangedListener, Closeable {\r\n-\r\n-    /**\r\n-     * Initialize any resources associated with the given\r\n-     * {@link DataCacheManager}.\r\n-     *\r\n-     * @since 4.1\r\n-     */\r\n-    public void initialize(DataCacheManager manager);\r\n-\r\n-    /**\r\n-     * Return a list of oids for the given query key. This is an\r\n-     * unmodifiable list.\r\n-     *\r\n-     * @return The query results matching the given key, or null if none\r\n-     */\r\n-    public QueryResult get(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Set the list of OIDs for the given query key. A reference\r\n-     * to the given list will be stored in the query cache, so the\r\n-     * list should not be modified after invoking this method.\r\n-     *\r\n-     * @return The previously cached value, or <code>null</code> if\r\n-     *         the key was not previously cached. See {@link Map#put}\r\n-     *         for more information.\r\n-     */\r\n-    public QueryResult put(QueryKey qk, QueryResult oids);\r\n-\r\n-    /**\r\n-     * Remove the value stored under the given query key.\r\n-     * This method is typically not invoked directly from outside\r\n-     * the <code>QueryCache</code> class. Instead, the cache should\r\n-     * be updated by invoking {@link #typesChanged}, which will\r\n-     * result in all queries that may be invalid being dropped.\r\n-     *\r\n-     * @return The previously cached value, or <code>null</code> if\r\n-     *         the key was not previously cached. See {@link Map#remove}\r\n-     *         for more information.\r\n-     */\r\n-    public QueryResult remove(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Remove all data from this cache.\r\n-     */\r\n-    public void clear();\r\n-\r\n-    /**\r\n-     * Pin the value stored under <code>qk</code> into the\r\n-     * cache. This method guarantees that <code>qk</code>'s value\r\n-     * will not be expired if the cache exceeds its capacity. It\r\n-     * causes this data to be ignored when determining whether or not\r\n-     * the cache is full, effectively increasing the total amount of\r\n-     * data stored in the cache. This method does not affect the\r\n-     * behavior of {@link #remove} or {@link #typesChanged}.\r\n-     *\r\n-     * @return <code>true</code> if <code>key</code>'s value was\r\n-     *         pinned into the cache; <code>false</code> if the key is not in the cache.\r\n-     */\r\n-    public boolean pin(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Unpin the value stored under <code>key</code> into the cache.\r\n-     * This method reverses a previous invocation of {@link #pin}.\r\n-     * This method does not remove anything from the cache; it merely\r\n-     * makes <code>key</code>'s value a candidate for flushing from the cache.\r\n-     *\r\n-     * @return <code>true</code> if <code>key</code>'s value was\r\n-     *         unpinned from the cache; <code>false</code> if the\r\n-     *         key is not in the cache.\r\n-     */\r\n-    public boolean unpin(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Obtain a write lock on the cache.\r\n-     */\r\n-    public void writeLock();\r\n-\r\n-    /**\r\n-     * Release the write lock on the cache.\r\n-     */\r\n-    public void writeUnlock();\r\n-\r\n-    /**\r\n-     * Add a new types event listener to this cache.\r\n-     *\r\n-     * @since 3.3\r\n-     */\r\n-    public void addTypesChangedListener(TypesChangedListener listen);\r\n-\r\n-    /**\r\n-     * Remove an types event listener from this cache.\r\n-     *\r\n-     * @since 3.3\r\n-     */\r\n-    public boolean removeTypesChangedListener(TypesChangedListener listen);\r\n-\r\n-    /**\r\n-     * Free the resources used by this cache.\r\n-     */\r\n-    public void close();\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.util.Closeable;\n+\n+/**\n+ * <p>Interface that must be implemented by any level 2 query cache\n+ * used by OpenJPA. These methods should be threadsafe.\n+ * Most query cache implementations will probably implement\n+ * {@link org.apache.openjpa.lib.conf.Configurable} to receive a handle to the\n+ * system configuration on construction.</p>\n+ *\n+ * @since 2.5\n+ * @author Patrick Linskey\n+ */\n+public interface QueryCache\n+    extends TypesChangedListener, Closeable {\n+\n+    /**\n+     * Initialize any resources associated with the given\n+     * {@link DataCacheManager}.\n+     *\n+     * @since 4.1\n+     */\n+    public void initialize(DataCacheManager manager);\n+\n+    /**\n+     * <p>Return a list of oids for the given query key. This is an\n+     * unmodifiable list.</p>\n+     *\n+     * @return The query results matching the given key, or null\n+     * if none\n+     */\n+    public QueryResult get(QueryKey qk);\n+\n+    /**\n+     * <p>Set the list of OIDs for the given query key. A reference\n+     * to the given list will be stored in the query cache, so the\n+     * list should not be modified after invoking this method.</p>\n+     *\n+     * @return The previously cached value, or <code>null</code> if\n+     * the key was not previously cached. See {@link Map#put}\n+     * for more information.\n+     */\n+    public QueryResult put(QueryKey qk, QueryResult oids);\n+\n+    /**\n+     * <p>Remove the value stored under the given query key.</p>\n+     * <p/>\n+     * <p>This method is typically not invoked directly from outside\n+     * the <code>QueryCache</code> class. Instead, the cache should\n+     * be updated by invoking {@link #typesChanged}, which will\n+     * result in all queries that may be invalid being dropped.</p>\n+     *\n+     * @return The previously cached value, or <code>null</code> if\n+     * the key was not previously cached. See {@link Map#remove}\n+     * for more information.\n+     */\n+    public QueryResult remove(QueryKey qk);\n+\n+    /**\n+     * <p>Remove all data from this cache.</p>\n+     */\n+    public void clear();\n+\n+    /**\n+     * Pin the value stored under <code>qk</code> into the\n+     * cache. This method guarantees that <code>qk</code>'s value\n+     * will not be expired if the cache exceeds its capacity. It\n+     * causes this data to be ignored when determining whether or not\n+     * the cache is full, effectively increasing the total amount of\n+     * data stored in the cache. This method does not affect the\n+     * behavior of {@link #remove} or {@link #typesChanged}.\n+     *\n+     * @return <code>true</code> if <code>key</code>'s value was\n+     *         pinned into the cache; <code>false</code> if the\n+     *         key is not in the cache.\n+     */\n+    public boolean pin(QueryKey qk);\n+\n+    /**\n+     * Unpin the value stored under <code>key</code> into the cache.\n+     * This method reverses a previous invocation of {@link #pin}.\n+     * This method does not remove anything from the cache; it merely\n+     * makes <code>key</code>'s value a candidate for flushing from\n+     * the cache.\n+     *\n+     * @return <code>true</code> if <code>key</code>'s value was\n+     *         unpinned from the cache; <code>false</code> if the\n+     *         key is not in the cache.\n+     */\n+    public boolean unpin(QueryKey qk);\n+\n+    /**\n+     * Obtain a write lock on the cache.\n+     */\n+    public void writeLock();\n+\n+    /**\n+     * Release the write lock on the cache.\n+     */\n+    public void writeUnlock();\n+\n+    /**\n+     * Add a new types event listener to this cache.\n+     *\n+     * @since 3.3\n+     */\n+    public void addTypesChangedListener(TypesChangedListener listen);\n+\n+    /**\n+     * Remove an types event listener from this cache.\n+     *\n+     * @since 3.3\n+     */\n+    public boolean removeTypesChangedListener(TypesChangedListener listen);\n+\n+    /**\n+     *\tFree the resources used by this cache.\n+\t */\n+\tpublic void close ();\n+}"},{"sha":"72590f0f07e04b252b713d703f405ca05bae0898","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","status":"modified","additions":682,"deletions":644,"changes":1326,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,644 +1,682 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.io.Serializable;\r\n-import java.util.AbstractList;\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.BitSet;\r\n-import java.util.Collections;\r\n-import java.util.Date;\r\n-import java.util.List;\r\n-import java.util.Locale;\r\n-import java.util.Map;\r\n-import java.util.TreeMap;\r\n-\r\n-import org.apache.commons.collections.map.LinkedMap;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.LockLevels;\r\n-import org.apache.openjpa.kernel.QueryContext;\r\n-import org.apache.openjpa.kernel.StoreContext;\r\n-import org.apache.openjpa.kernel.StoreQuery;\r\n-import org.apache.openjpa.kernel.exps.AggregateListener;\r\n-import org.apache.openjpa.kernel.exps.FilterListener;\r\n-import org.apache.openjpa.lib.rop.ListResultObjectProvider;\r\n-import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.util.ObjectNotFoundException;\r\n-import serp.util.Numbers;\r\n-\r\n-/**\r\n- * A {@link StoreQuery} implementation that caches the OIDs involved in\r\n- * the query, and can determine whether or not the query has been dirtied.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @since 2.5.0\r\n- */\r\n-public class QueryCacheStoreQuery implements StoreQuery {\r\n-\r\n-    private static Object NULL = new Object();\r\n-    private final StoreQuery _query;\r\n-    private final QueryCache _cache;\r\n-    private StoreContext _sctx;\r\n-    private MetaDataRepository _repos;\r\n-\r\n-    /**\r\n-     * Create a new instance that delegates to <code>query</code> if no\r\n-     * cached results are available.\r\n-     */\r\n-    public QueryCacheStoreQuery(StoreQuery query, QueryCache cache) {\r\n-        _query = query;\r\n-        _cache = cache;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the {@link QueryCache} that this object is associated with.\r\n-     */\r\n-    public QueryCache getCache() {\r\n-        return _cache;\r\n-    }\r\n-\r\n-    /**\r\n-     * Delegate.\r\n-     */\r\n-    public StoreQuery getDelegate() {\r\n-        return _query;\r\n-    }\r\n-\r\n-    /**\r\n-     * Look in the query cache for a result for the given query\r\n-     * key. Only look if this query is being executed outside a\r\n-     * transaction or in a transaction with IgnoreChanges set to true\r\n-     * or in a transaction with IgnoreChanges set to false but in which\r\n-     * none of the classes involved in this query have been touched.\r\n-     * Caching is not used when using object locking.\r\n-     * This is because we must obtain locks on the\r\n-     * data, and it is likely that making n trips to the database to\r\n-     * make the locks will be slower than running the query against\r\n-     * the database.\r\n-     * If the fetch configuration has query caching disabled,\r\n-     * then this method returns <code>null</code>.\r\n-     * Return the list if we meet the above criteria and if a list\r\n-     * is found for <code>qk</code>. Else, return\r\n-     * <code>null</code>.\r\n-     * This implementation means that queries against the cache\r\n-     * are of READ_COMMITTED isolation level. It'd be nice to support\r\n-     * READ_SERIALIZABLE -- to do so, we'd just return false when in\r\n-     * a transaction.\r\n-     */\r\n-    private List checkCache(QueryKey qk) {\r\n-        if (qk == null)\r\n-            return null;\r\n-        FetchConfiguration fetch = getContext().getFetchConfiguration();\r\n-        if (!fetch.getQueryCache())\r\n-            return null;\r\n-        if (fetch.getReadLockLevel() > LockLevels.LOCK_NONE)\r\n-            return null;\r\n-        // get the cached oids\r\n-        QueryResult res = _cache.get(qk);\r\n-        if (res == null)\r\n-            return null;\r\n-        if (res.isEmpty())\r\n-            return Collections.EMPTY_LIST;\r\n-        int projs = getContext().getProjectionAliases().length;\r\n-        if (projs == 0) {\r\n-            // make sure the data cache contains the oids for the query result;\r\n-            // if it doesn't, then using the result could be slower than not\r\n-            // using it becauseo of the individual by-oid lookups\r\n-            ClassMetaData meta = _repos.getMetaData(getContext().\r\n-                getCandidateType(), _sctx.getClassLoader(), true);\r\n-            BitSet idxs = meta.getDataCache().containsAll(res);\r\n-            // eventually we should optimize this to figure out how many objects\r\n-            // the cache is missing and if only a few do a bulk fetch for them\r\n-            int len = idxs.length();\r\n-            if (len < res.size())\r\n-                return null;\r\n-            for (int i = 0; i < len; i++)\r\n-                if (!idxs.get(i))\r\n-                    return null;\r\n-        }\r\n-        return new CachedList(res, projs != 0, _sctx);\r\n-    }\r\n-\r\n-    /**\r\n-     * Wrap the result object provider returned by our delegate in a\r\n-     * caching provider.\r\n-     */\r\n-    private ResultObjectProvider wrapResult(ResultObjectProvider rop,\r\n-        QueryKey key) {\r\n-        if (key == null)\r\n-            return rop;\r\n-        return new CachingResultObjectProvider(rop, getContext().\r\n-            getProjectionAliases().length > 0, key);\r\n-    }\r\n-\r\n-    /**\r\n-     * Copy a projection element for caching / returning.\r\n-     */\r\n-    private static Object copyProjection(Object obj, StoreContext ctx) {\r\n-        if (obj == null)\r\n-            return null;\r\n-        switch (JavaTypes.getTypeCode(obj.getClass())) {\r\n-            case JavaTypes.STRING:\r\n-            case JavaTypes.BOOLEAN_OBJ:\r\n-            case JavaTypes.BYTE_OBJ:\r\n-            case JavaTypes.CHAR_OBJ:\r\n-            case JavaTypes.DOUBLE_OBJ:\r\n-            case JavaTypes.FLOAT_OBJ:\r\n-            case JavaTypes.INT_OBJ:\r\n-            case JavaTypes.LONG_OBJ:\r\n-            case JavaTypes.SHORT_OBJ:\r\n-            case JavaTypes.BIGDECIMAL:\r\n-            case JavaTypes.BIGINTEGER:\r\n-            case JavaTypes.OID:\r\n-                return obj;\r\n-            case JavaTypes.DATE:\r\n-                return ((Date) obj).clone();\r\n-            case JavaTypes.LOCALE:\r\n-                return ((Locale) obj).clone();\r\n-            default:\r\n-                if (obj instanceof CachedObjectId)\r\n-                    return fromObjectId(((CachedObjectId) obj).oid, ctx);\r\n-                Object oid = ctx.getObjectId(obj);\r\n-                if (oid != null)\r\n-                    return new CachedObjectId(oid);\r\n-                return obj;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the result object based on its cached oid.\r\n-     */\r\n-    private static Object fromObjectId(Object oid, StoreContext sctx) {\r\n-        if (oid == null)\r\n-            return null;\r\n-        Object obj = sctx.find(oid, null, null, null, 0);\r\n-        if (obj == null)\r\n-            throw new ObjectNotFoundException(oid);\r\n-        return obj;\r\n-    }\r\n-\r\n-    public Object writeReplace() throws ObjectStreamException {\r\n-        return _query;\r\n-    }\r\n-\r\n-    public QueryContext getContext() {\r\n-        return _query.getContext();\r\n-    }\r\n-\r\n-    public void setContext(QueryContext qctx) {\r\n-        _query.setContext(qctx);\r\n-        _sctx = qctx.getStoreContext();\r\n-        _repos = _sctx.getConfiguration().getMetaDataRepository();\r\n-    }\r\n-\r\n-    public boolean setQuery(Object query) {\r\n-        return _query.setQuery(query);\r\n-    }\r\n-\r\n-    public FilterListener getFilterListener(String tag) {\r\n-        return _query.getFilterListener(tag);\r\n-    }\r\n-\r\n-    public AggregateListener getAggregateListener(String tag) {\r\n-        return _query.getAggregateListener(tag);\r\n-    }\r\n-\r\n-    public Object newCompilationKey() {\r\n-        return _query.newCompilationKey();\r\n-    }\r\n-\r\n-    public Object newCompilation() {\r\n-        return _query.newCompilation();\r\n-    }\r\n-\r\n-    public void populateFromCompilation(Object comp) {\r\n-        _query.populateFromCompilation(comp);\r\n-    }\r\n-\r\n-    public void invalidateCompilation() {\r\n-        _query.invalidateCompilation();\r\n-    }\r\n-\r\n-    public boolean supportsDataStoreExecution() {\r\n-        return _query.supportsDataStoreExecution();\r\n-    }\r\n-\r\n-    public boolean supportsInMemoryExecution() {\r\n-        return _query.supportsInMemoryExecution();\r\n-    }\r\n-\r\n-    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs) {\r\n-        return _query.newInMemoryExecutor(meta, subs);\r\n-    }\r\n-\r\n-    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\r\n-        Executor ex = _query.newDataStoreExecutor(meta, subs);\r\n-        return new QueryCacheExecutor(ex, meta, subs);\r\n-    }\r\n-\r\n-    public boolean supportsAbstractExecutors() {\r\n-        return _query.supportsAbstractExecutors();\r\n-    }\r\n-\r\n-    public boolean requiresCandidateType() {\r\n-        return _query.requiresCandidateType();\r\n-    }\r\n-\r\n-    public boolean requiresParameterDeclarations() {\r\n-        return _query.requiresParameterDeclarations();\r\n-    }\r\n-\r\n-    public boolean supportsParameterDeclarations() {\r\n-        return _query.supportsParameterDeclarations();\r\n-    }\r\n-\r\n-    /**\r\n-     * Caching executor.\r\n-     */\r\n-    private static class QueryCacheExecutor implements Executor {\r\n-\r\n-        private final Executor _ex;\r\n-        private final Class _candidate;\r\n-        private final boolean _subs;\r\n-\r\n-        public QueryCacheExecutor(Executor ex, ClassMetaData meta,\r\n-            boolean subs) {\r\n-            _ex = ex;\r\n-            _candidate = (meta == null) ? null : meta.getDescribedType();\r\n-            _subs = subs;\r\n-        }\r\n-\r\n-        public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\r\n-            boolean lrs, long startIdx, long endIdx) {\r\n-            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\r\n-            QueryKey key = QueryKey.newInstance(cq.getContext(),\r\n-                _ex.isPacking(q), params, _candidate, _subs, startIdx, endIdx);\r\n-            List cached = cq.checkCache(key);\r\n-            if (cached != null)\r\n-                return new ListResultObjectProvider(cached);\r\n-            ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\r\n-                params, lrs, startIdx, endIdx);\r\n-            return cq.wrapResult(rop, key);\r\n-        }\r\n-\r\n-        public ResultObjectProvider executeQuery(StoreQuery q, Map params,\r\n-            boolean lrs, long startIdx, long endIdx) {\r\n-            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\r\n-            QueryKey key = QueryKey.newInstance(cq.getContext(),\r\n-                _ex.isPacking(q), params, _candidate, _subs, startIdx, endIdx);\r\n-            List cached = cq.checkCache(key);\r\n-            if (cached != null)\r\n-                return new ListResultObjectProvider(cached);\r\n-            ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\r\n-                params, lrs, startIdx, endIdx);\r\n-            return cq.wrapResult(rop, key);\r\n-        }\r\n-\r\n-        /**\r\n-         * Clear the cached queries associated with the access path\r\n-         * classes in the query. This is done when bulk operations\r\n-         * (such as deletes or updates) are performed so that the\r\n-         * cache remains up-to-date.\r\n-         */\r\n-        private void clearAccesssPath(StoreQuery q) {\r\n-            if (q == null)\r\n-                return;\r\n-            ClassMetaData[] cmd = getAccessPathMetaDatas(q);\r\n-            if (cmd == null || cmd.length == 0)\r\n-                return;\r\n-            Class[] classes = new Class[cmd.length];\r\n-            for (int i = 0; i < cmd.length; i++)\r\n-                classes[i] = cmd[i].getDescribedType();\r\n-            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\r\n-            cq.getCache().onTypesChanged(new TypesChangedEvent\r\n-                (q.getContext(), Arrays.asList(classes)));\r\n-        }\r\n-\r\n-        public Number executeDelete(StoreQuery q, Object[] params) {\r\n-            try {\r\n-                return _ex.executeDelete(unwrap(q), params);\r\n-            }\r\n-            finally {\r\n-                clearAccesssPath(q);\r\n-            }\r\n-        }\r\n-\r\n-        public Number executeDelete(StoreQuery q, Map params) {\r\n-            try {\r\n-                return _ex.executeDelete(unwrap(q), params);\r\n-            }\r\n-            finally {\r\n-                clearAccesssPath(q);\r\n-            }\r\n-        }\r\n-\r\n-        public Number executeUpdate(StoreQuery q, Object[] params) {\r\n-            try {\r\n-                return _ex.executeUpdate(unwrap(q), params);\r\n-            }\r\n-            finally {\r\n-                clearAccesssPath(q);\r\n-            }\r\n-        }\r\n-\r\n-        public Number executeUpdate(StoreQuery q, Map params) {\r\n-            try {\r\n-                return _ex.executeUpdate(unwrap(q), params);\r\n-            }\r\n-            finally {\r\n-                clearAccesssPath(q);\r\n-            }\r\n-        }\r\n-\r\n-        public String[] getDataStoreActions(StoreQuery q, Object[] params,\r\n-            long startIdx, long endIdx) {\r\n-            return EMPTY_STRINGS;\r\n-        }\r\n-\r\n-        public Object getOrderingValue(StoreQuery q, Object[] params,\r\n-            Object resultObject, int orderIndex) {\r\n-            return _ex.getOrderingValue(unwrap(q), params, resultObject,\r\n-                orderIndex);\r\n-        }\r\n-\r\n-        public boolean[] getAscending(StoreQuery q) {\r\n-            return _ex.getAscending(unwrap(q));\r\n-        }\r\n-\r\n-        public boolean isPacking(StoreQuery q) {\r\n-            return _ex.isPacking(unwrap(q));\r\n-        }\r\n-\r\n-        public String getAlias(StoreQuery q) {\r\n-            return _ex.getAlias(unwrap(q));\r\n-        }\r\n-\r\n-        public Class getResultClass(StoreQuery q) {\r\n-            return _ex.getResultClass(unwrap(q));\r\n-        }\r\n-\r\n-        public String[] getProjectionAliases(StoreQuery q) {\r\n-            return _ex.getProjectionAliases(unwrap(q));\r\n-        }\r\n-\r\n-        public Class[] getProjectionTypes(StoreQuery q) {\r\n-            return _ex.getProjectionTypes(unwrap(q));\r\n-        }\r\n-\r\n-        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q) {\r\n-            return _ex.getAccessPathMetaDatas(unwrap(q));\r\n-        }\r\n-\r\n-        public int getOperation(StoreQuery q) {\r\n-            return _ex.getOperation(unwrap(q));\r\n-        }\r\n-\r\n-        public boolean isAggregate(StoreQuery q) {\r\n-            return _ex.isAggregate(unwrap(q));\r\n-        }\r\n-\r\n-        public boolean hasGrouping(StoreQuery q) {\r\n-            return _ex.hasGrouping(unwrap(q));\r\n-        }\r\n-\r\n-        public LinkedMap getParameterTypes(StoreQuery q) {\r\n-            return _ex.getParameterTypes(unwrap(q));\r\n-        }\r\n-\r\n-        public Map getUpdates(StoreQuery q) {\r\n-            return _ex.getUpdates(unwrap(q));\r\n-        }\r\n-\r\n-        private static StoreQuery unwrap(StoreQuery q) {\r\n-            return ((QueryCacheStoreQuery) q).getDelegate();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Result list implementation for a cached query result. Public visibility\r\n-     * for testing.\r\n-     */\r\n-    public static class CachedList extends AbstractList\r\n-        implements Serializable {\r\n-\r\n-        private final QueryResult _res;\r\n-        private final boolean _proj;\r\n-        private final StoreContext _sctx;\r\n-\r\n-        public CachedList(QueryResult res, boolean proj, StoreContext ctx) {\r\n-            _res = res;\r\n-            _proj = proj;\r\n-            _sctx = ctx;\r\n-        }\r\n-\r\n-        public Object get(int idx) {\r\n-            if (!_proj)\r\n-                return fromObjectId(_res.get(idx), _sctx);\r\n-            Object[] cached = (Object[]) _res.get(idx);\r\n-            if (cached == null)\r\n-                return null;\r\n-            Object[] uncached = new Object[cached.length];\r\n-            for (int i = 0; i < cached.length; i++)\r\n-                uncached[i] = copyProjection(cached[i], _sctx);\r\n-            return uncached;\r\n-        }\r\n-\r\n-        public int size() {\r\n-            return _res.size();\r\n-        }\r\n-\r\n-        public Object writeReplace() throws ObjectStreamException {\r\n-            return new ArrayList(this);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * A wrapper around a {@link ResultObjectProvider} that builds up a list of\r\n-     * all the OIDs in this list and registers that list with the\r\n-     * query cache. Abandons monitoring and registering if one of the classes\r\n-     * in the access path is modified while the query results are being loaded.\r\n-     */\r\n-    private class CachingResultObjectProvider\r\n-        implements ResultObjectProvider, TypesChangedListener {\r\n-\r\n-        private final ResultObjectProvider _rop;\r\n-        private final boolean _proj;\r\n-        private final QueryKey _qk;\r\n-        private final TreeMap _data = new TreeMap();\r\n-        private boolean _maintainCache = true;\r\n-        private int _pos = -1;\r\n-        // used to determine list size without necessarily calling size(),\r\n-        // which may require a DB trip or return Integer.MAX_VALUE\r\n-        private int _max = -1;\r\n-        private int _size = Integer.MAX_VALUE;\r\n-\r\n-        /**\r\n-         * Constructor. Supply delegate result provider and our query key.\r\n-         */\r\n-        public CachingResultObjectProvider(ResultObjectProvider rop,\r\n-            boolean proj, QueryKey key) {\r\n-            _rop = rop;\r\n-            _proj = proj;\r\n-            _qk = key;\r\n-            _cache.addTypesChangedListener(this);\r\n-        }\r\n-\r\n-        /**\r\n-         * Stop caching.\r\n-         */\r\n-        private void abortCaching() {\r\n-            if (!_maintainCache)\r\n-                return;\r\n-            // this can be called via an event from another thread\r\n-            synchronized (this) {\r\n-                // it's important that we set this flag first so that any\r\n-                // subsequent calls to this object are bypassed.\r\n-                _maintainCache = false;\r\n-                _cache.removeTypesChangedListener(this);\r\n-                _data.clear();\r\n-            }\r\n-        }\r\n-\r\n-        /**\r\n-         * Check whether we've buffered all results, while optionally adding\r\n-         * the given result.\r\n-         */\r\n-        private void checkFinished(Object obj, boolean result) {\r\n-            // this can be called at the same time as abortCaching via\r\n-            // a types changed event\r\n-            boolean finished = false;\r\n-            synchronized (this) {\r\n-                if (_maintainCache) {\r\n-                    if (result) {\r\n-                        Integer index = Numbers.valueOf(_pos);\r\n-                        if (!_data.containsKey(index)) {\r\n-                            Object cached;\r\n-                            if (obj == null)\r\n-                                cached = null;\r\n-                            else if (!_proj)\r\n-                                cached = _sctx.getObjectId(obj);\r\n-                            else {\r\n-                                Object[] arr = (Object[]) obj;\r\n-                                Object[] cp = new Object[arr.length];\r\n-                                for (int i = 0; i < arr.length; i++)\r\n-                                    cp[i] = copyProjection(arr[i], _sctx);\r\n-                                cached = cp;\r\n-                            }\r\n-                            if (cached != null)\r\n-                                _data.put(index, cached);\r\n-                        }\r\n-                    }\r\n-                    finished = _size == _data.size();\r\n-                }\r\n-            }\r\n-            if (finished) {\r\n-                // an abortCaching call can sneak in here via onExpire; the\r\n-                // cache is locked during event firings, so the lock here will\r\n-                // wait for it(or will force the next firing to wait)\r\n-                _cache.writeLock();\r\n-                try {\r\n-                    // make sure we didn't abort\r\n-                    if (_maintainCache) {\r\n-                        QueryResult res = new QueryResult(_qk, _data.values());\r\n-                        _cache.put(_qk, res);\r\n-                        abortCaching();\r\n-                    }\r\n-                }\r\n-                finally {\r\n-                    _cache.writeUnlock();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        public boolean supportsRandomAccess() {\r\n-            return _rop.supportsRandomAccess();\r\n-        }\r\n-\r\n-        public void open() throws Exception {\r\n-            _rop.open();\r\n-        }\r\n-\r\n-        public Object getResultObject() throws Exception {\r\n-            Object obj = _rop.getResultObject();\r\n-            checkFinished(obj, true);\r\n-            return obj;\r\n-        }\r\n-\r\n-        public boolean next() throws Exception {\r\n-            _pos++;\r\n-            boolean next = _rop.next();\r\n-            if (!next && _pos == _max + 1) {\r\n-                _size = _pos;\r\n-                checkFinished(null, false);\r\n-            } else if (next && _pos > _max)\r\n-                _max = _pos;\r\n-            return next;\r\n-        }\r\n-\r\n-        public boolean absolute(int pos) throws Exception {\r\n-            _pos = pos;\r\n-            boolean valid = _rop.absolute(pos);\r\n-            if (!valid && _pos == _max + 1) {\r\n-                _size = _pos;\r\n-                checkFinished(null, false);\r\n-            } else if (valid && _pos > _max)\r\n-                _max = _pos;\r\n-            return valid;\r\n-        }\r\n-\r\n-        public int size() throws Exception {\r\n-            if (_size != Integer.MAX_VALUE)\r\n-                return _size;\r\n-            int size = _rop.size();\r\n-            _size = size;\r\n-            checkFinished(null, false);\r\n-            return size;\r\n-        }\r\n-\r\n-        public void reset() throws Exception {\r\n-            _rop.reset();\r\n-            _pos = -1;\r\n-        }\r\n-\r\n-        public void close() throws Exception {\r\n-            abortCaching();\r\n-            _rop.close();\r\n-        }\r\n-\r\n-        public void handleCheckedException(Exception e) {\r\n-            _rop.handleCheckedException(e);\r\n-        }\r\n-\r\n-        public void onTypesChanged(TypesChangedEvent ev) {\r\n-            if (_qk.changeInvalidatesQuery(ev.getTypes()))\r\n-                abortCaching();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Struct to recognize cached oids.\r\n-     */\r\n-    private static class CachedObjectId {\r\n-\r\n-        public final Object oid;\r\n-\r\n-        public CachedObjectId(Object oid) {\r\n-            this.oid = oid;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import java.util.AbstractList;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.map.LinkedMap;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.LockLevels;\n+import org.apache.openjpa.kernel.QueryContext;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.kernel.exps.AggregateListener;\n+import org.apache.openjpa.kernel.exps.FilterListener;\n+import org.apache.openjpa.lib.rop.ListResultObjectProvider;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.util.ObjectNotFoundException;\n+import serp.util.Numbers;\n+\n+/**\n+ * A {@link StoreQuery} implementation that caches the OIDs involved in\n+ * the query, and can determine whether or not the query has been\n+ * dirtied.\n+ *\n+ * @author Patrick Linskey\n+ * @since 2.5.0\n+ */\n+class QueryCacheStoreQuery\n+    implements StoreQuery {\n+\n+    private static Object NULL = new Object();\n+\n+    private final StoreQuery _query;\n+    private final QueryCache _cache;\n+    private StoreContext _sctx;\n+    private MetaDataRepository _repos;\n+\n+    /**\n+     * Create a new instance that delegates to <code>query</code> if no\n+     * cached results are available.\n+     */\n+    public QueryCacheStoreQuery(StoreQuery query, QueryCache cache) {\n+        _query = query;\n+        _cache = cache;\n+    }\n+\n+    /**\n+     * Return the {@link QueryCache} that this object is associated\n+     * with.\n+     */\n+    public QueryCache getCache() {\n+        return _cache;\n+    }\n+\n+    /**\n+     * Delegate.\n+     */\n+    public StoreQuery getDelegate() {\n+        return _query;\n+    }\n+\n+    /**\n+     * <p>Look in the query cache for a result for the given query\n+     * key. Only look if this query is being executed outside a\n+     * transaction or in a transaction with IgnoreChanges set to true\n+     * or in a transaction with IgnoreChanges set to false but in which\n+     * none of the classes involved in this query have been\n+     * touched.</p>\n+     * <p/>\n+     * <p>Caching is not used when using object locking.\n+     * This is because we must obtain locks on the\n+     * data, and it is likely that making n trips to the database to\n+     * make the locks will be slower than running the query against\n+     * the database.</p>\n+     * <p/>\n+     * <p>If the fetch configuration has query caching disabled,\n+     * then this method returns <code>null</code>.</p>\n+     * <p/>\n+     * <p>Return the list if we meet the above criteria and if a list\n+     * is found for <code>qk</code>. Else, return\n+     * <code>null</code>.</p>\n+     * <p/>\n+     * <p>This implementation means that queries against the cache\n+     * are of READ_COMMITTED isolation level. It'd be nice to support\n+     * READ_SERIALIZABLE -- to do so, we'd just return false when in\n+     * a transaction.</p>\n+     */\n+    private List checkCache(QueryKey qk) {\n+        if (qk == null)\n+            return null;\n+        FetchConfiguration fetch = getContext().getFetchConfiguration();\n+        if (!fetch.getQueryCache())\n+            return null;\n+        if (fetch.getReadLockLevel() > LockLevels.LOCK_NONE)\n+            return null;\n+\n+        // get the cached oids\n+        QueryResult res = _cache.get(qk);\n+        if (res == null)\n+            return null;\n+        if (res.isEmpty())\n+            return Collections.EMPTY_LIST;\n+\n+        int projs = getContext().getProjectionAliases().length;\n+        if (projs == 0) {\n+            // make sure the data cache contains the oids for the query result;\n+            // if it doesn't, then using the result could be slower than not\n+            // using it becauseo of the individual by-oid lookups\n+            ClassMetaData meta = _repos.getMetaData(getContext().\n+                getCandidateType(), _sctx.getClassLoader(), true);\n+            BitSet idxs = meta.getDataCache().containsAll(res);\n+\n+            // eventually we should optimize this to figure out how many objects\n+            // the cache is missing and if only a few do a bulk fetch for them\n+            int len = idxs.length();\n+            if (len < res.size())\n+                return null;\n+            for (int i = 0; i < len; i++)\n+                if (!idxs.get(i))\n+                    return null;\n+        }\n+        return new CachedList(res, projs != 0, _sctx);\n+    }\n+\n+    /**\n+     * Wrap the result object provider returned by our delegate in a\n+     * caching provider.\n+     */\n+    private ResultObjectProvider wrapResult(ResultObjectProvider rop,\n+        QueryKey key) {\n+        if (key == null)\n+            return rop;\n+        return new CachingResultObjectProvider(rop, getContext().\n+            getProjectionAliases().length > 0, key);\n+    }\n+\n+    /**\n+     * Copy a projection element for caching / returning.\n+     */\n+    private static Object copyProjection(Object obj, StoreContext ctx) {\n+        if (obj == null)\n+            return null;\n+        switch (JavaTypes.getTypeCode(obj.getClass())) {\n+            case JavaTypes.STRING:\n+            case JavaTypes.BOOLEAN_OBJ:\n+            case JavaTypes.BYTE_OBJ:\n+            case JavaTypes.CHAR_OBJ:\n+            case JavaTypes.DOUBLE_OBJ:\n+            case JavaTypes.FLOAT_OBJ:\n+            case JavaTypes.INT_OBJ:\n+            case JavaTypes.LONG_OBJ:\n+            case JavaTypes.SHORT_OBJ:\n+            case JavaTypes.BIGDECIMAL:\n+            case JavaTypes.BIGINTEGER:\n+            case JavaTypes.OID:\n+                return obj;\n+            case JavaTypes.DATE:\n+                return ((Date) obj).clone();\n+            case JavaTypes.LOCALE:\n+                return ((Locale) obj).clone();\n+            default:\n+                if (obj instanceof CachedObjectId)\n+                    return fromObjectId(((CachedObjectId) obj).oid, ctx);\n+                Object oid = ctx.getObjectId(obj);\n+                if (oid != null)\n+                    return new CachedObjectId(oid);\n+                return obj;\n+        }\n+    }\n+\n+    /**\n+     * Return the result object based on its cached oid.\n+     */\n+    private static Object fromObjectId(Object oid, StoreContext sctx) {\n+        if (oid == null)\n+            return null;\n+\n+        Object obj = sctx.find(oid, null, null, null, 0);\n+        if (obj == null)\n+            throw new ObjectNotFoundException(oid);\n+        return obj;\n+    }\n+\n+    public Object writeReplace()\n+        throws ObjectStreamException {\n+        return _query;\n+    }\n+\n+    public QueryContext getContext() {\n+        return _query.getContext();\n+    }\n+\n+    public void setContext(QueryContext qctx) {\n+        _query.setContext(qctx);\n+        _sctx = qctx.getStoreContext();\n+        _repos = _sctx.getConfiguration().getMetaDataRepository();\n+    }\n+\n+    public boolean setQuery(Object query) {\n+        return _query.setQuery(query);\n+    }\n+\n+    public FilterListener getFilterListener(String tag) {\n+        return _query.getFilterListener(tag);\n+    }\n+\n+    public AggregateListener getAggregateListener(String tag) {\n+        return _query.getAggregateListener(tag);\n+    }\n+\n+    public Object newCompilationKey() {\n+        return _query.newCompilationKey();\n+    }\n+\n+    public Object newCompilation() {\n+        return _query.newCompilation();\n+    }\n+\n+    public void populateFromCompilation(Object comp) {\n+        _query.populateFromCompilation(comp);\n+    }\n+\n+    public void invalidateCompilation() {\n+        _query.invalidateCompilation();\n+    }\n+\n+    public boolean supportsDataStoreExecution() {\n+        return _query.supportsDataStoreExecution();\n+    }\n+\n+    public boolean supportsInMemoryExecution() {\n+        return _query.supportsInMemoryExecution();\n+    }\n+\n+    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs) {\n+        return _query.newInMemoryExecutor(meta, subs);\n+    }\n+\n+    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\n+        Executor ex = _query.newDataStoreExecutor(meta, subs);\n+        return new QueryCacheExecutor(ex, meta, subs);\n+    }\n+\n+    public boolean supportsAbstractExecutors() {\n+        return _query.supportsAbstractExecutors();\n+    }\n+\n+    public boolean requiresCandidateType() {\n+        return _query.requiresCandidateType();\n+    }\n+\n+    public boolean requiresParameterDeclarations() {\n+        return _query.requiresParameterDeclarations();\n+    }\n+\n+    public boolean supportsParameterDeclarations() {\n+        return _query.supportsParameterDeclarations();\n+    }\n+\n+    /**\n+     * Caching executor.\n+     */\n+    private static class QueryCacheExecutor\n+        implements Executor {\n+\n+        private final Executor _ex;\n+        private final Class _candidate;\n+        private final boolean _subs;\n+\n+        public QueryCacheExecutor(Executor ex, ClassMetaData meta,\n+            boolean subs) {\n+            _ex = ex;\n+            _candidate = (meta == null) ? null : meta.getDescribedType();\n+            _subs = subs;\n+        }\n+\n+        public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\n+            boolean lrs, long startIdx, long endIdx) {\n+            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\n+            QueryKey key = QueryKey.newInstance(cq.getContext(),\n+                _ex.isPacking(q), params, _candidate, _subs, startIdx, endIdx);\n+            List cached = cq.checkCache(key);\n+            if (cached != null)\n+                return new ListResultObjectProvider(cached);\n+\n+            ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\n+                params, lrs, startIdx, endIdx);\n+            return cq.wrapResult(rop, key);\n+        }\n+\n+        public ResultObjectProvider executeQuery(StoreQuery q, Map params,\n+            boolean lrs, long startIdx, long endIdx) {\n+            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\n+            QueryKey key = QueryKey.newInstance(cq.getContext(),\n+                _ex.isPacking(q), params, _candidate, _subs, startIdx, endIdx);\n+            List cached = cq.checkCache(key);\n+            if (cached != null)\n+                return new ListResultObjectProvider(cached);\n+\n+            ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\n+                params, lrs, startIdx, endIdx);\n+            return cq.wrapResult(rop, key);\n+        }\n+\n+        /**\n+         * Clear the cached queries associated with the access path\n+         * classes in the query. This is done when bulk operations\n+         * (such as deletes or updates) are performed so that the\n+         * cache remains up-to-date.\n+         */\n+        private void clearAccesssPath(StoreQuery q) {\n+            if (q == null)\n+                return;\n+\n+            ClassMetaData[] cmd = getAccessPathMetaDatas(q);\n+            if (cmd == null || cmd.length == 0)\n+                return;\n+\n+            Class[] classes = new Class[cmd.length];\n+            for (int i = 0; i < cmd.length; i++)\n+                classes[i] = cmd[i].getDescribedType();\n+\n+            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\n+            cq.getCache().onTypesChanged(new TypesChangedEvent\n+                (q.getContext(), Arrays.asList(classes)));\n+        }\n+\n+        public Number executeDelete(StoreQuery q, Object[] params) {\n+            try {\n+                return _ex.executeDelete(unwrap(q), params);\n+            }\n+            finally {\n+                clearAccesssPath(q);\n+            }\n+        }\n+\n+        public Number executeDelete(StoreQuery q, Map params) {\n+            try {\n+                return _ex.executeDelete(unwrap(q), params);\n+            }\n+            finally {\n+                clearAccesssPath(q);\n+            }\n+        }\n+\n+        public Number executeUpdate(StoreQuery q, Object[] params) {\n+            try {\n+                return _ex.executeUpdate(unwrap(q), params);\n+            }\n+            finally {\n+                clearAccesssPath(q);\n+            }\n+        }\n+\n+        public Number executeUpdate(StoreQuery q, Map params) {\n+            try {\n+                return _ex.executeUpdate(unwrap(q), params);\n+            }\n+            finally {\n+                clearAccesssPath(q);\n+            }\n+        }\n+\n+        public String[] getDataStoreActions(StoreQuery q, Object[] params,\n+            long startIdx, long endIdx) {\n+            return EMPTY_STRINGS;\n+        }\n+\n+        public Object getOrderingValue(StoreQuery q, Object[] params,\n+            Object resultObject, int orderIndex) {\n+            return _ex.getOrderingValue(unwrap(q), params, resultObject,\n+                orderIndex);\n+        }\n+\n+        public boolean[] getAscending(StoreQuery q) {\n+            return _ex.getAscending(unwrap(q));\n+        }\n+\n+        public boolean isPacking(StoreQuery q) {\n+            return _ex.isPacking(unwrap(q));\n+        }\n+\n+        public String getAlias(StoreQuery q) {\n+            return _ex.getAlias(unwrap(q));\n+        }\n+\n+        public Class getResultClass(StoreQuery q) {\n+            return _ex.getResultClass(unwrap(q));\n+        }\n+\n+        public String[] getProjectionAliases(StoreQuery q) {\n+            return _ex.getProjectionAliases(unwrap(q));\n+        }\n+\n+        public Class[] getProjectionTypes(StoreQuery q) {\n+            return _ex.getProjectionTypes(unwrap(q));\n+        }\n+\n+        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q) {\n+            return _ex.getAccessPathMetaDatas(unwrap(q));\n+        }\n+\n+        public int getOperation(StoreQuery q) {\n+            return _ex.getOperation(unwrap(q));\n+        }\n+\n+        public boolean isAggregate(StoreQuery q) {\n+            return _ex.isAggregate(unwrap(q));\n+        }\n+\n+        public boolean hasGrouping(StoreQuery q) {\n+            return _ex.hasGrouping(unwrap(q));\n+        }\n+\n+        public LinkedMap getParameterTypes(StoreQuery q) {\n+            return _ex.getParameterTypes(unwrap(q));\n+        }\n+\n+        public Map getUpdates(StoreQuery q) {\n+            return _ex.getUpdates(unwrap(q));\n+        }\n+\n+        private static StoreQuery unwrap(StoreQuery q) {\n+            return ((QueryCacheStoreQuery) q).getDelegate();\n+        }\n+    }\n+\n+    /**\n+     * Result list implementation for a cached query result.  Package-protected\n+     * for testing.\n+     */\n+    static class CachedList\n+        extends AbstractList\n+        implements Serializable {\n+\n+        private final QueryResult _res;\n+        private final boolean _proj;\n+        private final StoreContext _sctx;\n+\n+        public CachedList(QueryResult res, boolean proj, StoreContext ctx) {\n+            _res = res;\n+            _proj = proj;\n+            _sctx = ctx;\n+        }\n+\n+        public Object get(int idx) {\n+            if (!_proj)\n+                return fromObjectId(_res.get(idx), _sctx);\n+\n+            Object[] cached = (Object[]) _res.get(idx);\n+            if (cached == null)\n+                return null;\n+            Object[] uncached = new Object[cached.length];\n+            for (int i = 0; i < cached.length; i++)\n+                uncached[i] = copyProjection(cached[i], _sctx);\n+            return uncached;\n+        }\n+\n+        public int size() {\n+            return _res.size();\n+        }\n+\n+        public Object writeReplace()\n+            throws ObjectStreamException {\n+            return new ArrayList(this);\n+        }\n+    }\n+\n+    /**\n+     * A wrapper around a {@link ResultObjectProvider} that builds up a list of\n+     * all the OIDs in this list and registers that list with the\n+     * query cache. Abandons monitoring and registering if one of the classes\n+     * in the access path is modified while the query results are being\n+     * loaded.\n+     */\n+    private class CachingResultObjectProvider\n+        implements ResultObjectProvider, TypesChangedListener {\n+\n+        private final ResultObjectProvider _rop;\n+        private final boolean _proj;\n+        private final QueryKey _qk;\n+        private final TreeMap _data = new TreeMap();\n+        private boolean _maintainCache = true;\n+        private int _pos = -1;\n+\n+        // used to determine list size without necessarily calling size(),\n+        // which may require a DB trip or return Integer.MAX_VALUE\n+        private int _max = -1;\n+        private int _size = Integer.MAX_VALUE;\n+\n+        /**\n+         * Constructor.  Supply delegate result provider and our query key.\n+         */\n+        public CachingResultObjectProvider(ResultObjectProvider rop,\n+            boolean proj, QueryKey key) {\n+            _rop = rop;\n+            _proj = proj;\n+            _qk = key;\n+            _cache.addTypesChangedListener(this);\n+        }\n+\n+        /**\n+         * Stop caching.\n+         */\n+        private void abortCaching() {\n+            if (!_maintainCache)\n+                return;\n+\n+            // this can be called via an event from another thread\n+            synchronized (this) {\n+                // it's important that we set this flag first so that any\n+                // subsequent calls to this object are bypassed.\n+                _maintainCache = false;\n+                _cache.removeTypesChangedListener(this);\n+                _data.clear();\n+            }\n+        }\n+\n+        /**\n+         * Check whether we've buffered all results, while optionally adding\n+         * the given result.\n+         */\n+        private void checkFinished(Object obj, boolean result) {\n+            // this can be called at the same time as abortCaching via\n+            // a types changed event\n+            boolean finished = false;\n+            synchronized (this) {\n+                if (_maintainCache) {\n+                    if (result) {\n+                        Integer index = Numbers.valueOf(_pos);\n+                        if (!_data.containsKey(index)) {\n+                            Object cached;\n+                            if (obj == null)\n+                                cached = null;\n+                            else if (!_proj)\n+                                cached = _sctx.getObjectId(obj);\n+                            else {\n+                                Object[] arr = (Object[]) obj;\n+                                Object[] cp = new Object[arr.length];\n+                                for (int i = 0; i < arr.length; i++)\n+                                    cp[i] = copyProjection(arr[i], _sctx);\n+                                cached = cp;\n+                            }\n+                            if (cached != null)\n+                                _data.put(index, cached);\n+                        }\n+                    }\n+                    finished = _size == _data.size();\n+                }\n+            }\n+\n+            if (finished) {\n+                // an abortCaching call can sneak in here via onExpire; the\n+                // cache is locked during event firings, so the lock here will\n+                // wait for it (or will force the next firing to wait)\n+                _cache.writeLock();\n+                try {\n+                    // make sure we didn't abort\n+                    if (_maintainCache) {\n+                        QueryResult res = new QueryResult(_qk, _data.values());\n+                        _cache.put(_qk, res);\n+                        abortCaching();\n+                    }\n+                }\n+                finally {\n+                    _cache.writeUnlock();\n+                }\n+            }\n+        }\n+\n+        public boolean supportsRandomAccess() {\n+            return _rop.supportsRandomAccess();\n+        }\n+\n+        public void open()\n+            throws Exception {\n+            _rop.open();\n+        }\n+\n+        public Object getResultObject()\n+            throws Exception {\n+            Object obj = _rop.getResultObject();\n+            checkFinished(obj, true);\n+            return obj;\n+        }\n+\n+        public boolean next()\n+            throws Exception {\n+            _pos++;\n+            boolean next = _rop.next();\n+            if (!next && _pos == _max + 1) {\n+                _size = _pos;\n+                checkFinished(null, false);\n+            } else if (next && _pos > _max)\n+                _max = _pos;\n+            return next;\n+        }\n+\n+        public boolean absolute(int pos)\n+            throws Exception {\n+            _pos = pos;\n+            boolean valid = _rop.absolute(pos);\n+            if (!valid && _pos == _max + 1) {\n+                _size = _pos;\n+                checkFinished(null, false);\n+            } else if (valid && _pos > _max)\n+                _max = _pos;\n+            return valid;\n+        }\n+\n+        public int size()\n+            throws Exception {\n+            if (_size != Integer.MAX_VALUE)\n+                return _size;\n+            int size = _rop.size();\n+            _size = size;\n+            checkFinished(null, false);\n+            return size;\n+        }\n+\n+        public void reset()\n+            throws Exception {\n+            _rop.reset();\n+            _pos = -1;\n+        }\n+\n+        public void close()\n+            throws Exception {\n+            abortCaching();\n+            _rop.close();\n+        }\n+\n+        public void handleCheckedException(Exception e) {\n+            _rop.handleCheckedException(e);\n+        }\n+\n+        public void onTypesChanged(TypesChangedEvent ev) {\n+            if (_qk.changeInvalidatesQuery(ev.getTypes()))\n+                abortCaching();\n+        }\n+    }\n+\n+    /**\n+     *\tStruct to recognize cached oids.\n+     */\n+    private static class CachedObjectId {\n+\n+        public final Object oid;\n+\n+        public CachedObjectId (Object oid)\n+\t\t{\n+\t\t\tthis.oid = oid;\n+\t\t}\n+\t}\n+}"},{"sha":"5ad70d06a811d982db1fcfb02b318ae989569b16","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryKey.java","status":"modified","additions":465,"deletions":432,"changes":897,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryKey.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryKey.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,432 +1,465 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.io.Externalizable;\r\n-import java.io.IOException;\r\n-import java.io.ObjectInput;\r\n-import java.io.ObjectOutput;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.Date;\r\n-import java.util.HashMap;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-import java.util.SortedSet;\r\n-import java.util.TreeSet;\r\n-\r\n-import org.apache.commons.lang.ObjectUtils;\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.enhance.PCRegistry;\r\n-import org.apache.openjpa.kernel.Query;\r\n-import org.apache.openjpa.kernel.QueryContext;\r\n-import org.apache.openjpa.kernel.StoreContext;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-\r\n-/**\r\n- * This class stores information about a particular invocation of\r\n- * a query. It contains a reference to the external properties of the\r\n- * query that was executed, as well as any parameters used to execute\r\n- * that query, with one exception: first-class objects used as\r\n- * parameter values are converted to OIDs.\r\n- *\r\n- * @author Patrick Linskey\r\n- */\r\n-public class QueryKey implements Externalizable {\r\n-\r\n-    // initialize the set of unmodifiable classes. This allows us\r\n-    // to avoid cloning collections that are not modifiable,\r\n-    // provided that they do not contain mutable objects.\r\n-    private static Collection s_unmod = new HashSet();\r\n-\r\n-    static {\r\n-        // handle the set types; jdk uses different classes for collection,\r\n-        // set, and sorted set\r\n-        TreeSet s = new TreeSet();\r\n-        s_unmod.add(Collections.unmodifiableCollection(s).getClass());\r\n-        s_unmod.add(Collections.unmodifiableSet(s).getClass());\r\n-        s_unmod.add(Collections.unmodifiableSortedSet(s).getClass());\r\n-        // handle the list types; jdk uses different classes for standard\r\n-        // and random access lists\r\n-        List l = new LinkedList();\r\n-        s_unmod.add(Collections.unmodifiableList(l).getClass());\r\n-        l = new ArrayList(0);\r\n-        s_unmod.add(Collections.unmodifiableList(l).getClass());\r\n-        // handle the constant types\r\n-        s_unmod.add(Collections.EMPTY_SET.getClass());\r\n-        s_unmod.add(Collections.EMPTY_LIST.getClass());\r\n-    }\r\n-\r\n-    // caching state; no need to include parameter and variable declarations\r\n-    // because they are implicit in the filter\r\n-    private String _candidateClassName;\r\n-    private boolean _subclasses;\r\n-    private Set _accessPathClassNames;\r\n-    private String _query;\r\n-    private boolean _ignoreChanges;\r\n-    private Map _params;\r\n-    private long _rangeStart;\r\n-    private long _rangeEnd;\r\n-    // ### pcl: 2 May 2003: should this timeout take into account the\r\n-    // ### timeouts for classes in the access path of the query?\r\n-    // ### Currently, it only considers the candidate class and its\r\n-    // ### subclasses. Note that this value is used to decide whether\r\n-    // ### or not OIDs should be registered for expiration callbacks\r\n-    private int _timeout = -1;\r\n-\r\n-    /**\r\n-     * Return a key for the given query, or null if it is not cacheable.\r\n-     */\r\n-    public static QueryKey newInstance(Query q) {\r\n-        return newInstance(q, (Object[]) null);\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a key for the given query, or null if it is not cacheable.\r\n-     */\r\n-    public static QueryKey newInstance(Query q, Object[] args) {\r\n-        // compile to make sure info encoded in query string is available\r\n-        // via API calls(candidate class, result class, etc)\r\n-        q.compile();\r\n-        return newInstance(q, false, args, q.getCandidateType(),\r\n-            q.hasSubclasses(), q.getStartRange(), q.getEndRange());\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a key for the given query, or null if it is not cacheable.\r\n-     */\r\n-    public static QueryKey newInstance(Query q, Map args) {\r\n-        // compile to make sure info encoded in query string is available\r\n-        // via API calls(candidate class, result class, etc)\r\n-        q.compile();\r\n-        return newInstance(q, false, args, q.getCandidateType(),\r\n-            q.hasSubclasses(), q.getStartRange(), q.getEndRange());\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a key for the given query, or null if it is not cacheable.\r\n-     */\r\n-    static QueryKey newInstance(QueryContext q, boolean packed, Object[] args,\r\n-        Class candidate, boolean subs, long startIdx, long endIdx) {\r\n-        QueryKey key = createKey(q, packed, candidate, subs, startIdx, endIdx);\r\n-        if (key != null && setParams(key, q, args))\r\n-            return key;\r\n-        return null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a key for the given query, or null if it is not cacheable.\r\n-     */\r\n-    static QueryKey newInstance(QueryContext q, boolean packed, Map args,\r\n-        Class candidate, boolean subs, long startIdx, long endIdx) {\r\n-        QueryKey key = createKey(q, packed, candidate, subs, startIdx, endIdx);\r\n-        if (key != null && (args == null || args.isEmpty() ||\r\n-            setParams(key, q.getStoreContext(), new HashMap(args))))\r\n-            return key;\r\n-        return null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Extract the relevant identifying information from\r\n-     * <code>q</code>. This includes information such as candidate\r\n-     * class, query filter, etc.\r\n-     */\r\n-    private static QueryKey createKey(QueryContext q, boolean packed,\r\n-        Class candidateClass, boolean subclasses, long startIdx, long endIdx) {\r\n-        if (candidateClass == null)\r\n-            return null;\r\n-        // can only cache datastore queries\r\n-        if (q.getCandidateCollection() != null)\r\n-            return null;\r\n-        // no support already-packed results\r\n-        if (q.getResultType() != null && packed)\r\n-            return null;\r\n-        // can't cache non-serializable non-managed complex types\r\n-        Class[] types = q.getProjectionTypes();\r\n-        for (int i = 0; i < types.length; i++) {\r\n-            switch (JavaTypes.getTypeCode(types[i])) {\r\n-                case JavaTypes.ARRAY:\r\n-                    return null;\r\n-                case JavaTypes.COLLECTION:\r\n-                case JavaTypes.MAP:\r\n-                case JavaTypes.OBJECT:\r\n-                    if (!ImplHelper.isManagedType(types[i]))\r\n-                        return null;\r\n-                    break;\r\n-            }\r\n-        }\r\n-        // we can't cache the query if we don't know which classes are in the\r\n-        // access path\r\n-        ClassMetaData[] metas = q.getAccessPathMetaDatas();\r\n-        if (metas.length == 0)\r\n-            return null;\r\n-        Set accessPathClassNames = new HashSet((int) (metas.length * 1.33 + 1));\r\n-        ClassMetaData meta;\r\n-        for (int i = 0; i < metas.length; i++) {\r\n-            // since the class change framework deals with least-derived types,\r\n-            // record the least-derived access path types\r\n-            meta = metas[i];\r\n-            while (meta.getPCSuperclass() != null)\r\n-                meta = meta.getPCSuperclassMetaData();\r\n-            // ensure that this metadata is cacheable\r\n-            if (meta.getDataCache() == null)\r\n-                return null;\r\n-            accessPathClassNames.add(meta.getDescribedType().getName());\r\n-        }\r\n-        // if any of the types are currently dirty, we can't cache this query\r\n-        StoreContext ctx = q.getStoreContext();\r\n-        if (intersects(accessPathClassNames, ctx.getPersistedTypes())\r\n-            || intersects(accessPathClassNames, ctx.getUpdatedTypes())\r\n-            || intersects(accessPathClassNames, ctx.getDeletedTypes()))\r\n-            return null;\r\n-        // calculate the timeout for the key\r\n-        MetaDataRepository repos = ctx.getConfiguration().\r\n-            getMetaDataRepository();\r\n-        // won't find metadata for interfaces.\r\n-        if (candidateClass.isInterface())\r\n-            return null;\r\n-        meta = repos.getMetaData(candidateClass, ctx.getClassLoader(), true);\r\n-        int timeout = meta.getDataCacheTimeout();\r\n-        if (subclasses) {\r\n-            metas = meta.getPCSubclassMetaDatas();\r\n-            int subTimeout;\r\n-            for (int i = 0; i < metas.length; i++) {\r\n-                if (metas[i].getDataCache() == null)\r\n-                    return null;\r\n-                subTimeout = metas[i].getDataCacheTimeout();\r\n-                if (subTimeout != -1 && subTimeout < timeout)\r\n-                    timeout = subTimeout;\r\n-            }\r\n-        }\r\n-        // tests all passed; cacheable\r\n-        QueryKey key = new QueryKey();\r\n-        key._candidateClassName = candidateClass.getName();\r\n-        key._subclasses = subclasses;\r\n-        key._accessPathClassNames = accessPathClassNames;\r\n-        key._timeout = timeout;\r\n-        key._query = q.getQueryString();\r\n-        key._ignoreChanges = q.getIgnoreChanges();\r\n-        key._rangeStart = startIdx;\r\n-        key._rangeEnd = endIdx;\r\n-        return key;\r\n-    }\r\n-\r\n-    /**\r\n-     * Convert an array of arguments into the corresponding parameter\r\n-     * map, and do any PC to OID conversion necessary.\r\n-     */\r\n-    private static boolean setParams(QueryKey key, QueryContext q,\r\n-        Object[] args) {\r\n-        if (args == null || args.length == 0)\r\n-            return true;\r\n-        // Create a map for the given parameters, and convert the\r\n-        // parameter list into a map, using the query's parameter\r\n-        // declaration to determine ordering etc.\r\n-        Map types = q.getParameterTypes();\r\n-        Map map = new HashMap((int) (types.size() * 1.33 + 1));\r\n-        int idx = 0;\r\n-        for (Iterator iter = types.keySet().iterator(); iter.hasNext(); idx++)\r\n-            map.put(iter.next(), args[idx]);\r\n-        return setParams(key, q.getStoreContext(), map);\r\n-    }\r\n-\r\n-    /**\r\n-     * Convert parameters to a form that is cacheable. Mutable params\r\n-     * will be cloned.\r\n-     */\r\n-    private static boolean setParams(QueryKey key, StoreContext ctx,\r\n-        Map params) {\r\n-        if (params == null || params.isEmpty())\r\n-            return true;\r\n-        Map.Entry e;\r\n-        Object v;\r\n-        for (Iterator iter = params.entrySet().iterator(); iter.hasNext();) {\r\n-            e = (Map.Entry) iter.next();\r\n-            v = e.getValue();\r\n-            if (ImplHelper.isManageable(v)) {\r\n-                if (!ctx.isPersistent(v) || ctx.isNew(v) || ctx.isDeleted(v))\r\n-                    return false;\r\n-                e.setValue(ctx.getObjectId(v));\r\n-            }\r\n-            if (v instanceof Collection) {\r\n-                Collection c = (Collection) v;\r\n-                boolean contentsAreDates = false;\r\n-                if (c.iterator().hasNext()) {\r\n-                    // this assumes that the collection is homogeneous\r\n-                    Object o = c.iterator().next();\r\n-                    if (ImplHelper.isManageable(o))\r\n-                        return false;\r\n-                    // pcl: 27 Jun 2004: if we grow this logic to\r\n-                    // handle other mutable types that are not\r\n-                    // known to be cloneable, we will have to add\r\n-                    // logic to handle them. This is because we\r\n-                    // can't just cast to Cloneable and invoke\r\n-                    // clone(), as clone() is a protected method\r\n-                    // in Object.\r\n-                    if (o instanceof Date)\r\n-                        contentsAreDates = true;\r\n-                    // if the collection is not a known immutable\r\n-                    // type, or if it contains mutable instances,\r\n-                    // clone it for good measure.\r\n-                    if (contentsAreDates || !s_unmod.contains(c.getClass())) {\r\n-                        // copy the collection\r\n-                        Collection copy;\r\n-                        if (c instanceof SortedSet)\r\n-                            copy = new TreeSet();\r\n-                        else if (c instanceof Set)\r\n-                            copy = new HashSet();\r\n-                        else copy = new ArrayList(c.size());\r\n-                        if (contentsAreDates) {\r\n-                            // must go through by hand and do the\r\n-                            // copy, since Date is mutable.\r\n-                            for (Iterator itr2 = c.iterator(); itr2.hasNext();)\r\n-                                copy.add(((Date) itr2.next()).clone());\r\n-                        } else copy.addAll(c);\r\n-                        e.setValue(copy);\r\n-                    }\r\n-                }\r\n-            } else if (v instanceof Date)\r\n-                e.setValue(((Date) v).clone());\r\n-        }\r\n-        key._params = params;\r\n-        return true;\r\n-    }\r\n-\r\n-    /**\r\n-     * Public constructor for externalization only.\r\n-     */\r\n-    public QueryKey() {\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the candidate class name for this query.\r\n-     */\r\n-    public String getCandidateTypeName() {\r\n-        return _candidateClassName;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the amount of time this key is good for.\r\n-     */\r\n-    public int getTimeout() {\r\n-        return _timeout;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns <code>true</code> if modifications to any of the\r\n-     * classes in <code>changed</code> results in a possible\r\n-     * invalidation of this query; otherwise returns\r\n-     * <code>false</code>. Invalidation is possible if one or more of\r\n-     * the classes in this query key's access path has been changed.\r\n-     */\r\n-    public boolean changeInvalidatesQuery(Collection changed) {\r\n-        return intersects(_accessPathClassNames, changed);\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether the given set of least-derived class names intersects with\r\n-     * the given set of changed classes.\r\n-     */\r\n-    private static boolean intersects(Collection names, Collection changed) {\r\n-        Class cls;\r\n-        Class sup;\r\n-        for (Iterator iter = changed.iterator(); iter.hasNext();) {\r\n-            cls = (Class) iter.next();\r\n-            while ((sup = PCRegistry.getPersistentSuperclass(cls)) != null)\r\n-                cls = sup;\r\n-            if (names.contains(cls.getName()))\r\n-                return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Determine equality based on identifying information. Keys\r\n-     * created for queries that specify a candidate collection are\r\n-     * always not equal.\r\n-     */\r\n-    public boolean equals(Object ob) {\r\n-        if (this == ob)\r\n-            return true;\r\n-        if (ob == null || getClass() != ob.getClass())\r\n-            return false;\r\n-        QueryKey other = (QueryKey) ob;\r\n-        return StringUtils.equals(_candidateClassName,\r\n-            other._candidateClassName)\r\n-            && _subclasses == other._subclasses\r\n-            && _ignoreChanges == other._ignoreChanges\r\n-            && _rangeStart == other._rangeStart && _rangeEnd == other._rangeEnd\r\n-            && StringUtils.equals(_query, other._query)\r\n-            && ObjectUtils.equals(_params, other._params);\r\n-    }\r\n-\r\n-    /**\r\n-     * Define a hashing algorithm corresponding to the {@link #equals}\r\n-     * method defined above.\r\n-     */\r\n-    public int hashCode() {\r\n-        int code = 37 * 17 + _candidateClassName.hashCode();\r\n-        if (_query != null)\r\n-            code = 37 * code + _query.hashCode();\r\n-        if (_params != null)\r\n-            code = 37 * code + _params.hashCode();\r\n-        return code;\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        StringBuffer buf = new StringBuffer(255);\r\n-        buf.append(super.toString()).\r\n-            append(\"[query:[\").append(_query).append(\"]\").\r\n-            append(\",access path:\").append(_accessPathClassNames).\r\n-            append(\",subs:\").append(_subclasses).\r\n-            append(\",ignoreChanges:\").append(_ignoreChanges).\r\n-            append(\",startRange:\").append(_rangeStart).\r\n-            append(\",endRange:\").append(_rangeEnd).\r\n-            append(\",timeout:\").append(_timeout). append(\"]\");\r\n-        return buf.toString();\r\n-    }\r\n-\r\n-    // ---------- Externalizable implementation ----------\r\n-    public void writeExternal(ObjectOutput out) throws IOException {\r\n-        out.writeObject(_candidateClassName);\r\n-        out.writeBoolean(_subclasses);\r\n-        out.writeObject(_accessPathClassNames);\r\n-        out.writeObject(_query);\r\n-        out.writeBoolean(_ignoreChanges);\r\n-        out.writeObject(_params);\r\n-        out.writeLong(_rangeStart);\r\n-        out.writeLong(_rangeEnd);\r\n-        out.writeInt(_timeout);\r\n-    }\r\n-\r\n-    public void readExternal(ObjectInput in)\r\n-        throws IOException, ClassNotFoundException {\r\n-        _candidateClassName = (String) in.readObject();\r\n-        _subclasses = in.readBoolean();\r\n-        _accessPathClassNames = (Set) in.readObject();\r\n-        _query = (String) in.readObject();\r\n-        _ignoreChanges = in.readBoolean();\r\n-        _params = (Map) in.readObject();\r\n-        _rangeStart = in.readLong();\r\n-        _rangeEnd = in.readLong();\r\n-        _timeout = in.readInt();\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.lang.ObjectUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.enhance.PCRegistry;\n+import org.apache.openjpa.kernel.Query;\n+import org.apache.openjpa.kernel.QueryContext;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.util.ImplHelper;\n+\n+/**\n+ * <p>This class stores information about a particular invocation of\n+ * a query. It contains a reference to the external properties of the\n+ * query that was executed, as well as any parameters used to execute\n+ * that query, with one exception: first-class objects used as\n+ * parameter values are converted to OIDs.</p>\n+ *\n+ * @author Patrick Linskey\n+ */\n+public class QueryKey\n+    implements Externalizable {\n+\n+    // initialize the set of unmodifiable classes. This allows us\n+    // to avoid cloning collections that are not modifiable,\n+    // provided that they do not contain mutable objects.\n+    private static Collection s_unmod = new HashSet();\n+\n+    static {\n+        // handle the set types; jdk uses different classes for collection,\n+        // set, and sorted set\n+        TreeSet s = new TreeSet();\n+        s_unmod.add(Collections.unmodifiableCollection(s).getClass());\n+        s_unmod.add(Collections.unmodifiableSet(s).getClass());\n+        s_unmod.add(Collections.unmodifiableSortedSet(s).getClass());\n+\n+        // handle the list types; jdk uses different classes for standard\n+        // and random access lists\n+        List l = new LinkedList();\n+        s_unmod.add(Collections.unmodifiableList(l).getClass());\n+        l = new ArrayList(0);\n+        s_unmod.add(Collections.unmodifiableList(l).getClass());\n+\n+        // handle the constant types\n+        s_unmod.add(Collections.EMPTY_SET.getClass());\n+        s_unmod.add(Collections.EMPTY_LIST.getClass());\n+    }\n+\n+    // caching state; no need to include parameter and variable declarations\n+    // because they are implicit in the filter\n+    private String _candidateClassName;\n+    private boolean _subclasses;\n+    private Set _accessPathClassNames;\n+    private String _query;\n+    private boolean _ignoreChanges;\n+    private Map _params;\n+    private long _rangeStart;\n+    private long _rangeEnd;\n+\n+    // ### pcl: 2 May 2003: should this timeout take into account the\n+    // ### timeouts for classes in the access path of the query?\n+    // ### Currently, it only considers the candidate class and its\n+    // ### subclasses. Note that this value is used to decide whether\n+    // ### or not OIDs should be registered for expiration callbacks\n+    private int _timeout = -1;\n+\n+    /**\n+     * Return a key for the given query, or null if it is not cacheable.\n+     */\n+    public static QueryKey newInstance(Query q) {\n+        return newInstance(q, (Object[]) null);\n+    }\n+\n+    /**\n+     * Return a key for the given query, or null if it is not cacheable.\n+     */\n+    public static QueryKey newInstance(Query q, Object[] args) {\n+        // compile to make sure info encoded in query string is available\n+        // via API calls (candidate class, result class, etc)\n+        q.compile();\n+        return newInstance(q, false, args, q.getCandidateType(),\n+            q.hasSubclasses(), q.getStartRange(), q.getEndRange());\n+    }\n+\n+    /**\n+     * Return a key for the given query, or null if it is not cacheable.\n+     */\n+    public static QueryKey newInstance(Query q, Map args) {\n+        // compile to make sure info encoded in query string is available\n+        // via API calls (candidate class, result class, etc)\n+        q.compile();\n+        return newInstance(q, false, args, q.getCandidateType(),\n+            q.hasSubclasses(), q.getStartRange(), q.getEndRange());\n+    }\n+\n+    /**\n+     * Return a key for the given query, or null if it is not cacheable.\n+     */\n+    static QueryKey newInstance(QueryContext q, boolean packed, Object[] args,\n+        Class candidate, boolean subs, long startIdx, long endIdx) {\n+        QueryKey key = createKey(q, packed, candidate, subs, startIdx, endIdx);\n+        if (key != null && setParams(key, q, args))\n+            return key;\n+        return null;\n+    }\n+\n+    /**\n+     * Return a key for the given query, or null if it is not cacheable.\n+     */\n+    static QueryKey newInstance(QueryContext q, boolean packed, Map args,\n+        Class candidate, boolean subs, long startIdx, long endIdx) {\n+        QueryKey key = createKey(q, packed, candidate, subs, startIdx, endIdx);\n+        if (key != null && (args == null || args.isEmpty() ||\n+            setParams(key, q.getStoreContext(), new HashMap(args))))\n+            return key;\n+        return null;\n+    }\n+\n+    /**\n+     * Extract the relevant identifying information from\n+     * <code>q</code>. This includes information such as candidate\n+     * class, query filter, etc.\n+     */\n+    private static QueryKey createKey(QueryContext q, boolean packed,\n+        Class candidateClass, boolean subclasses, long startIdx, long endIdx) {\n+        if (candidateClass == null)\n+            return null;\n+\n+        // can only cache datastore queries\n+        if (q.getCandidateCollection() != null)\n+            return null;\n+\n+        // no support already-packed results\n+        if (q.getResultType() != null && packed)\n+            return null;\n+\n+        // can't cache non-serializable non-managed complex types\n+        Class[] types = q.getProjectionTypes();\n+        for (int i = 0; i < types.length; i++) {\n+            switch (JavaTypes.getTypeCode(types[i])) {\n+                case JavaTypes.ARRAY:\n+                    return null;\n+                case JavaTypes.COLLECTION:\n+                case JavaTypes.MAP:\n+                case JavaTypes.OBJECT:\n+                    if (!ImplHelper.isManagedType(types[i]))\n+                        return null;\n+                    break;\n+            }\n+        }\n+\n+        // we can't cache the query if we don't know which classes are in the\n+        // access path\n+        ClassMetaData[] metas = q.getAccessPathMetaDatas();\n+        if (metas.length == 0)\n+            return null;\n+\n+        Set accessPathClassNames = new HashSet((int) (metas.length * 1.33 + 1));\n+        ClassMetaData meta;\n+        for (int i = 0; i < metas.length; i++) {\n+            // since the class change framework deals with least-derived types,\n+            // record the least-derived access path types\n+            meta = metas[i];\n+            while (meta.getPCSuperclass() != null)\n+                meta = meta.getPCSuperclassMetaData();\n+\n+            // ensure that this metadata is cacheable\n+            if (meta.getDataCache() == null)\n+                return null;\n+            accessPathClassNames.add(meta.getDescribedType().getName());\n+        }\n+\n+        // if any of the types are currently dirty, we can't cache this query\n+        StoreContext ctx = q.getStoreContext();\n+        if (intersects(accessPathClassNames, ctx.getPersistedTypes())\n+            || intersects(accessPathClassNames, ctx.getUpdatedTypes())\n+            || intersects(accessPathClassNames, ctx.getDeletedTypes()))\n+            return null;\n+\n+        // calculate the timeout for the key\n+        MetaDataRepository repos = ctx.getConfiguration().\n+            getMetaDataRepository();\n+\n+        // won't find metadata for interfaces.\n+        if (candidateClass.isInterface())\n+            return null;\n+        meta = repos.getMetaData(candidateClass, ctx.getClassLoader(), true);\n+        int timeout = meta.getDataCacheTimeout();\n+        if (subclasses) {\n+            metas = meta.getPCSubclassMetaDatas();\n+            int subTimeout;\n+            for (int i = 0; i < metas.length; i++) {\n+                if (metas[i].getDataCache() == null)\n+                    return null;\n+\n+                subTimeout = metas[i].getDataCacheTimeout();\n+                if (subTimeout != -1 && subTimeout < timeout)\n+                    timeout = subTimeout;\n+            }\n+        }\n+\n+        // tests all passed; cacheable\n+        QueryKey key = new QueryKey();\n+        key._candidateClassName = candidateClass.getName();\n+        key._subclasses = subclasses;\n+        key._accessPathClassNames = accessPathClassNames;\n+        key._timeout = timeout;\n+        key._query = q.getQueryString();\n+        key._ignoreChanges = q.getIgnoreChanges();\n+        key._rangeStart = startIdx;\n+        key._rangeEnd = endIdx;\n+        return key;\n+    }\n+\n+    /**\n+     * Convert an array of arguments into the corresponding parameter\n+     * map, and do any PC to OID conversion necessary.\n+     */\n+    private static boolean setParams(QueryKey key, QueryContext q,\n+        Object[] args) {\n+        if (args == null || args.length == 0)\n+            return true;\n+\n+        // Create a map for the given parameters, and convert the\n+        // parameter list into a map, using the query's parameter\n+        // declaration to determine ordering etc.\n+        Map types = q.getParameterTypes();\n+        Map map = new HashMap((int) (types.size() * 1.33 + 1));\n+        int idx = 0;\n+        for (Iterator iter = types.keySet().iterator(); iter.hasNext(); idx++)\n+            map.put(iter.next(), args[idx]);\n+        return setParams(key, q.getStoreContext(), map);\n+    }\n+\n+    /**\n+     * Convert parameters to a form that is cacheable. Mutable params\n+     * will be cloned.\n+     */\n+    private static boolean setParams(QueryKey key, StoreContext ctx,\n+        Map params) {\n+        if (params == null || params.isEmpty())\n+            return true;\n+\n+        Map.Entry e;\n+        Object v;\n+        for (Iterator iter = params.entrySet().iterator(); iter.hasNext();) {\n+            e = (Map.Entry) iter.next();\n+            v = e.getValue();\n+            if (ImplHelper.isManageable(v)) {\n+                if (!ctx.isPersistent(v) || ctx.isNew(v) || ctx.isDeleted(v))\n+                    return false;\n+                e.setValue(ctx.getObjectId(v));\n+            }\n+\n+            if (v instanceof Collection) {\n+                Collection c = (Collection) v;\n+                boolean contentsAreDates = false;\n+                if (c.iterator().hasNext()) {\n+                    // this assumes that the collection is homogeneous\n+                    Object o = c.iterator().next();\n+                    if (ImplHelper.isManageable(o))\n+                        return false;\n+\n+                    // pcl: 27 Jun 2004: if we grow this logic to\n+                    // handle other mutable types that are not\n+                    // known to be cloneable, we will have to add\n+                    // logic to handle them. This is because we\n+                    // can't just cast to Cloneable and invoke\n+                    // clone(), as clone() is a protected method\n+                    // in Object.\n+                    if (o instanceof Date)\n+                        contentsAreDates = true;\n+\n+                    // if the collection is not a known immutable\n+                    // type, or if it contains mutable instances,\n+                    // clone it for good measure.\n+                    if (contentsAreDates || !s_unmod.contains(c.getClass())) {\n+                        // copy the collection\n+                        Collection copy;\n+                        if (c instanceof SortedSet)\n+                            copy = new TreeSet();\n+                        else if (c instanceof Set)\n+                            copy = new HashSet();\n+                        else\n+                            copy = new ArrayList(c.size());\n+\n+                        if (contentsAreDates) {\n+                            // must go through by hand and do the\n+                            // copy, since Date is mutable.\n+                            for (Iterator itr2 = c.iterator(); itr2.hasNext();)\n+                                copy.add(((Date) itr2.next()).clone());\n+                        } else\n+                            copy.addAll(c);\n+\n+                        e.setValue(copy);\n+                    }\n+                }\n+            } else if (v instanceof Date)\n+                e.setValue(((Date) v).clone());\n+        }\n+\n+        key._params = params;\n+        return true;\n+    }\n+\n+    /**\n+     * Public constructor for externalization only.\n+     */\n+    public QueryKey() {\n+    }\n+\n+    /**\n+     * Returns the candidate class name for this query.\n+     */\n+    public String getCandidateTypeName() {\n+        return _candidateClassName;\n+    }\n+\n+    /**\n+     * Return the amount of time this key is good for.\n+     */\n+    public int getTimeout() {\n+        return _timeout;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if modifications to any of the\n+     * classes in <code>changed</code> results in a possible\n+     * invalidation of this query; otherwise returns\n+     * <code>false</code>. Invalidation is possible if one or more of\n+     * the classes in this query key's access path has been changed.\n+     */\n+    public boolean changeInvalidatesQuery(Collection changed) {\n+        return intersects(_accessPathClassNames, changed);\n+    }\n+\n+    /**\n+     * Whether the given set of least-derived class names intersects with\n+     * the given set of changed classes.\n+     */\n+    private static boolean intersects(Collection names, Collection changed) {\n+        Class cls;\n+        Class sup;\n+        for (Iterator iter = changed.iterator(); iter.hasNext();) {\n+            cls = (Class) iter.next();\n+            while ((sup = PCRegistry.getPersistentSuperclass(cls)) != null)\n+                cls = sup;\n+            if (names.contains(cls.getName()))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Determine equality based on identifying information. Keys\n+     * created for queries that specify a candidate collection are\n+     * always not equal.\n+     */\n+    public boolean equals(Object ob) {\n+        if (this == ob)\n+            return true;\n+        if (ob == null || getClass() != ob.getClass())\n+            return false;\n+\n+        QueryKey other = (QueryKey) ob;\n+        return StringUtils.equals(_candidateClassName,\n+            other._candidateClassName)\n+            && _subclasses == other._subclasses\n+            && _ignoreChanges == other._ignoreChanges\n+            && _rangeStart == other._rangeStart\n+            && _rangeEnd == other._rangeEnd\n+            && StringUtils.equals(_query, other._query)\n+            && ObjectUtils.equals(_params, other._params);\n+    }\n+\n+    /**\n+     * Define a hashing algorithm corresponding to the {@link #equals}\n+     * method defined above.\n+     */\n+    public int hashCode() {\n+        int code = 37 * 17 + _candidateClassName.hashCode();\n+        if (_query != null)\n+            code = 37 * code + _query.hashCode();\n+        if (_params != null)\n+            code = 37 * code + _params.hashCode();\n+        return code;\n+    }\n+\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer(255);\n+        buf.append(super.toString()).\n+            append(\"[query:[\").append(_query).append(\"]\").\n+            append(\",access path:\").append(_accessPathClassNames).\n+            append(\",subs:\").append(_subclasses).\n+            append(\",ignoreChanges:\").append(_ignoreChanges).\n+            append(\",startRange:\").append(_rangeStart).\n+            append(\",endRange:\").append(_rangeEnd).\n+            append(\",timeout:\").append(_timeout).\n+            append(\"]\");\n+        return buf.toString();\n+    }\n+\n+    // ---------- Externalizable implementation ----------\n+\n+    public void writeExternal(ObjectOutput out)\n+        throws IOException {\n+        out.writeObject(_candidateClassName);\n+        out.writeBoolean(_subclasses);\n+        out.writeObject(_accessPathClassNames);\n+        out.writeObject(_query);\n+        out.writeBoolean(_ignoreChanges);\n+        out.writeObject(_params);\n+        out.writeLong(_rangeStart);\n+        out.writeLong(_rangeEnd);\n+        out.writeInt(_timeout);\n+    }\n+\n+    public void readExternal(ObjectInput in)\n+        throws IOException, ClassNotFoundException {\n+        _candidateClassName = (String) in.readObject();\n+        _subclasses = in.readBoolean();\n+        _accessPathClassNames = (Set) in.readObject();\n+        _query = (String) in.readObject();\n+        _ignoreChanges = in.readBoolean();\n+        _params = (Map) in.readObject();\n+        _rangeStart = in.readLong();\n+        _rangeEnd = in.readLong ();\n+\t\t_timeout = in.readInt ();\n+\t}\n+}"},{"sha":"3d2f1bb372d395d36358888499466ab405472f28","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java","status":"modified","additions":64,"deletions":58,"changes":122,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,58 +1,64 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-\r\n-/**\r\n- * A query result.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public class QueryResult extends ArrayList {\r\n-\r\n-    private final long _ex;\r\n-\r\n-    /**\r\n-     * Constructor; supply corresponding query key and result data.\r\n-     */\r\n-    public QueryResult(QueryKey key, Collection data) {\r\n-        super(data);\r\n-        if (key.getTimeout() == -1)\r\n-            _ex = -1;\r\n-        else _ex = System.currentTimeMillis() + key.getTimeout();\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructor to set internal data from a serializer.\r\n-     */\r\n-    public QueryResult(Collection data, long ex) {\r\n-        super(data);\r\n-        _ex = ex;\r\n-    }\r\n-\r\n-    /**\r\n-     * Expiration time, or -1 for no timeout.\r\n-     */\r\n-    public long getTimeoutTime() {\r\n-        return _ex;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether this data is timed out.\r\n-     */\r\n-    public boolean isTimedOut() {\r\n-        return _ex != -1 && _ex < System.currentTimeMillis();\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+/**\n+ * <p>A query result.</p>\n+ *\n+ * @author Abe White\n+ */\n+public class QueryResult\n+    extends ArrayList {\n+\n+    private final long _ex;\n+\n+    /**\n+     * Constructor; supply corresponding query key and result data.\n+     */\n+    public QueryResult(QueryKey key, Collection data) {\n+        super(data);\n+\n+        if (key.getTimeout() == -1)\n+            _ex = -1;\n+        else\n+            _ex = System.currentTimeMillis() + key.getTimeout();\n+    }\n+\n+    /**\n+     * Constructor to set internal data from a serializer.\n+     */\n+    public QueryResult(Collection data, long ex) {\n+        super(data);\n+        _ex = ex;\n+    }\n+\n+    /**\n+     * Expiration time, or -1 for no timeout.\n+     */\n+    public long getTimeoutTime() {\n+        return _ex;\n+    }\n+\n+    /**\n+     *\tWhether this data is timed out.\n+     */\n+    public boolean isTimedOut() {\n+        return _ex != -1 && _ex < System.currentTimeMillis();\n+\t}\n+}"},{"sha":"f52246c81c745fc4451a58cc28fba0549bbc987e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedEvent.java","status":"modified","additions":49,"deletions":45,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedEvent.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedEvent.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,45 +1,49 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.EventObject;\r\n-\r\n-/**\r\n- * An event indicating that instances of given persistent types have\r\n- * been modified.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public class TypesChangedEvent extends EventObject {\r\n-\r\n-    private final Collection _types;\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param source the data or query cache\r\n-     * @param types  the changed types\r\n-     */\r\n-    public TypesChangedEvent(Object source, Collection types) {\r\n-        super(source);\r\n-        _types = types;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the expired types.\r\n-     */\r\n-    public Collection getTypes() {\r\n-        return _types;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.Collection;\n+import java.util.EventObject;\n+\n+/**\n+ * <p>An event indicating that instances of given persistent types have\n+ * been modified.</p>\n+ *\n+ * @author Abe White\n+ */\n+public class TypesChangedEvent\n+    extends EventObject {\n+\n+    private final Collection _types;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param    source    the data or query cache\n+     * @param    types    the changed types\n+     */\n+    public TypesChangedEvent(Object source, Collection types) {\n+        super(source);\n+        _types = types;\n+    }\n+\n+    /**\n+     * Return the expired types.\n+     */\n+    public Collection getTypes() {\n+        return _types;\n+\t}\n+}"},{"sha":"e09778c029abc6d0815c6209b30c161ff6e8878e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedListener.java","status":"modified","additions":30,"deletions":27,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,27 +1,30 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-/**\r\n- * An entity that wishes to be notified when types change.\r\n- *\r\n- * @author Abe White\r\n- * @since 3.0\r\n- */\r\n-public interface TypesChangedListener {\r\n-\r\n-    /**\r\n-     * Notification that instances of persistent types have changed.\r\n-     */\r\n-    public void onTypesChanged(TypesChangedEvent event);\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.datacache;\n+\n+/**\n+ * <p>An entity that wishes to be notified when types change.</p>\n+ *\n+ * @author Abe White\n+ * @since 3.0\n+ */\n+public interface TypesChangedListener {\n+\n+    /**\n+     * Notification that instances of persistent types have changed.\n+     */\n+    public void onTypesChanged(TypesChangedEvent event);\n+}"},{"sha":"6e9a48e14f8c15ce7d27332499b5b8af98bf959c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java","status":"modified","additions":178,"deletions":160,"changes":338,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,160 +1,178 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.ee;\r\n-\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import javax.transaction.TransactionManager;\r\n-\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.InvalidStateException;\r\n-\r\n-/**\r\n- * Implementation of the {@link ManagedRuntime} interface that searches\r\n- * through a set of known JNDI locations and method invocations to locate the\r\n- * appropriate mechanism for obtaining a TransactionManager.\r\n- * Built in support is provided for the following Application Servers:\r\n- * <ul>\r\n- * <li>Bluestone</li>\r\n- * <li>HP Application Server</li>\r\n- * <li>JBoss</li>\r\n- * <li>JRun</li>\r\n- * <li>OpenEJB</li>\r\n- * <li>Oracle Application Server</li>\r\n- * <li>Orion</li>\r\n- * <li>SunONE</li>\r\n- * <li>Weblogic</li>\r\n- * <li>Websphere</li>\r\n- * </ul>\r\n- *\r\n- * @author Marc Prud'hommeaux\r\n- */\r\n-public class AutomaticManagedRuntime implements ManagedRuntime, Configurable {\r\n-\r\n-    private static final String [] JNDI_LOCS = new String []{\r\n-        \"javax.transaction.TransactionManager\", // weblogic\r\n-        \"java:/TransactionManager\", // jboss & jrun\r\n-        \"java:/DefaultDomain/TransactionManager\", // jrun too\r\n-        \"java:comp/pm/TransactionManager\", // orion & oracle\r\n-        \"java:comp/TransactionManager\", // generic\r\n-        \"java:pm/TransactionManager\", // borland\r\n-    };\r\n-    private static final String [] METHODS = new String[]{\r\n-        \"com.arjuna.jta.JTA_TransactionManager.transactionManager\", // hp\r\n-        \"com.bluestone.jta.SaTransactionManagerFactory.SaGetTransactionManager\",\r\n-        \"com.ibm.ejs.jts.jta.JTSXA.getTransactionManager\",\r\n-        \"com.ibm.ejs.jts.jta.TransactionManagerFactory.getTransactionManager\",\r\n-        \"com.ibm.ws.Transaction.TransactionManagerFactory.\"\r\n-            + \"getTransactionManager\", // WS 5.1\r\n-        \"org.openejb.OpenEJB.getTransactionManager\",\r\n-        \"com.sun.jts.jta.TransactionManagerImpl.getTransactionManagerImpl\",\r\n-        \"com.inprise.visitransact.jta.TransactionManagerImpl.\"\r\n-            + \"getTransactionManagerImpl\", // borland\r\n-    };\r\n-    private static final ManagedRuntime WLS;\r\n-    private static final ManagedRuntime SUNONE;\r\n-    private static Localizer _loc = Localizer.forPackage\r\n-        (AutomaticManagedRuntime.class);\r\n-\r\n-    static {\r\n-        ManagedRuntime mr = null;\r\n-        try {\r\n-            mr = new WLSManagedRuntime();\r\n-        } catch (Throwable t) {\r\n-        }\r\n-        WLS = mr;\r\n-        mr = null;\r\n-        try {\r\n-            mr = new SunOneManagedRuntime();\r\n-        } catch (Throwable t) {\r\n-        }\r\n-        SUNONE = mr;\r\n-    }\r\n-\r\n-    private Configuration _conf = null;\r\n-    private ManagedRuntime _runtime = null;\r\n-\r\n-    public TransactionManager getTransactionManager() throws Exception {\r\n-        if (_runtime != null)\r\n-            return _runtime.getTransactionManager();\r\n-        List errors = new LinkedList();\r\n-        TransactionManager tm = null;\r\n-        if (WLS != null) {\r\n-            try {\r\n-                tm = WLS.getTransactionManager();\r\n-            } catch (Throwable t) {\r\n-                errors.add(t);\r\n-            }\r\n-            if (tm != null) {\r\n-                _runtime = WLS;\r\n-                return tm;\r\n-            }\r\n-        }\r\n-        // try to find a jndi runtime\r\n-        JNDIManagedRuntime jmr = new JNDIManagedRuntime();\r\n-        for (int i = 0; i < JNDI_LOCS.length; i++) {\r\n-            jmr.setTransactionManagerName(JNDI_LOCS[i]);\r\n-            try {\r\n-                tm = jmr.getTransactionManager();\r\n-            } catch (Throwable t) {\r\n-                errors.add(t);\r\n-            }\r\n-            if (tm != null) {\r\n-                _runtime = jmr;\r\n-                return tm;\r\n-            }\r\n-        }\r\n-        // look for a method runtime\r\n-        InvocationManagedRuntime imr = new InvocationManagedRuntime();\r\n-        for (int i = 0; i < METHODS.length; i++) {\r\n-            imr.setConfiguration(_conf);\r\n-            imr.setTransactionManagerMethod(METHODS[i]);\r\n-            try {\r\n-                tm = imr.getTransactionManager();\r\n-            } catch (Throwable t) {\r\n-                errors.add(t);\r\n-            }\r\n-            if (tm != null) {\r\n-                _runtime = imr;\r\n-                return tm;\r\n-            }\r\n-        }\r\n-        if (SUNONE != null) {\r\n-            try {\r\n-                tm = SUNONE.getTransactionManager();\r\n-            } catch (Throwable t) {\r\n-                errors.add(t);\r\n-            }\r\n-            if (tm != null) {\r\n-                _runtime = SUNONE;\r\n-                return tm;\r\n-            }\r\n-        }\r\n-        Throwable[] t =\r\n-            (Throwable []) errors.toArray(new Throwable [errors.size()]);\r\n-        throw new InvalidStateException(_loc.get(\"tm-not-found\")).\r\n-            setFatal(true).setNestedThrowables(t);\r\n-    }\r\n-\r\n-    public void setConfiguration(Configuration conf) {\r\n-        _conf = conf;\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.ee;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import javax.transaction.TransactionManager;\n+\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InvalidStateException;\n+\n+/**\n+ * <p>Implementation of the {@link ManagedRuntime} interface that searches\n+ * through a set of known JNDI locations and method invocations to locate the\n+ * appropriate mechanism for obtaining a TransactionManager.</p>\n+ * <p/>\n+ * <p>Built in support is provided for the following Application Servers:\n+ * <ul>\n+ * <li>Bluestone</li>\n+ * <li>HP Application Server</li>\n+ * <li>JBoss</li>\n+ * <li>JRun</li>\n+ * <li>OpenEJB</li>\n+ * <li>Oracle Application Server</li>\n+ * <li>Orion</li>\n+ * <li>SunONE</li>\n+ * <li>Weblogic</li>\n+ * <li>Websphere</li>\n+ * </ul></p>\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+public class AutomaticManagedRuntime\n+    implements ManagedRuntime, Configurable {\n+\n+    private static final String [] JNDI_LOCS = new String []{\n+        \"javax.transaction.TransactionManager\",        // weblogic\n+        \"java:/TransactionManager\",                    // jboss & jrun\n+        \"java:/DefaultDomain/TransactionManager\",    // jrun too\n+        \"java:comp/pm/TransactionManager\",            // orion & oracle\n+        \"java:comp/TransactionManager\",                // generic\n+        \"java:pm/TransactionManager\",                // borland\n+    };\n+    private static final String [] METHODS = new String[]{\n+        \"com.arjuna.jta.JTA_TransactionManager.transactionManager\", // hp\n+        \"com.bluestone.jta.SaTransactionManagerFactory.SaGetTransactionManager\",\n+        \"com.ibm.ejs.jts.jta.JTSXA.getTransactionManager\",\n+        \"com.ibm.ejs.jts.jta.TransactionManagerFactory.getTransactionManager\",\n+        \"com.ibm.ws.Transaction.TransactionManagerFactory.\"\n+            + \"getTransactionManager\", // WS 5.1\n+        \"org.openejb.OpenEJB.getTransactionManager\",\n+        \"com.sun.jts.jta.TransactionManagerImpl.getTransactionManagerImpl\",\n+        \"com.inprise.visitransact.jta.TransactionManagerImpl.\"\n+            + \"getTransactionManagerImpl\",                            // borland\n+    };\n+    private static final ManagedRuntime WLS;\n+    private static final ManagedRuntime SUNONE;\n+\n+    private static Localizer _loc = Localizer.forPackage\n+        (AutomaticManagedRuntime.class);\n+\n+    static {\n+        ManagedRuntime mr = null;\n+        try {\n+            mr = new WLSManagedRuntime();\n+        } catch (Throwable t) {\n+        }\n+        WLS = mr;\n+\n+        mr = null;\n+        try {\n+            mr = new SunOneManagedRuntime();\n+        } catch (Throwable t) {\n+        }\n+        SUNONE = mr;\n+    }\n+\n+    private Configuration _conf = null;\n+    private ManagedRuntime _runtime = null;\n+\n+    public TransactionManager getTransactionManager()\n+        throws Exception {\n+        if (_runtime != null)\n+            return _runtime.getTransactionManager();\n+\n+        List errors = new LinkedList();\n+        TransactionManager tm = null;\n+\n+        if (WLS != null) {\n+            try {\n+                tm = WLS.getTransactionManager();\n+            }\n+            catch (Throwable t) {\n+                errors.add(t);\n+            }\n+            if (tm != null) {\n+                _runtime = WLS;\n+                return tm;\n+            }\n+        }\n+\n+        // try to find a jndi runtime\n+        JNDIManagedRuntime jmr = new JNDIManagedRuntime();\n+        for (int i = 0; i < JNDI_LOCS.length; i++) {\n+            jmr.setTransactionManagerName(JNDI_LOCS[i]);\n+            try {\n+                tm = jmr.getTransactionManager();\n+            }\n+            catch (Throwable t) {\n+                errors.add(t);\n+            }\n+            if (tm != null) {\n+                _runtime = jmr;\n+                return tm;\n+            }\n+        }\n+\n+        // look for a method runtime\n+        InvocationManagedRuntime imr = new InvocationManagedRuntime();\n+        for (int i = 0; i < METHODS.length; i++) {\n+            imr.setConfiguration(_conf);\n+            imr.setTransactionManagerMethod(METHODS[i]);\n+            try {\n+                tm = imr.getTransactionManager();\n+            }\n+            catch (Throwable t) {\n+                errors.add(t);\n+            }\n+            if (tm != null) {\n+                _runtime = imr;\n+                return tm;\n+            }\n+        }\n+\n+        if (SUNONE != null) {\n+            try {\n+                tm = SUNONE.getTransactionManager();\n+            }\n+            catch (Throwable t) {\n+                errors.add(t);\n+            }\n+            if (tm != null) {\n+                _runtime = SUNONE;\n+                return tm;\n+            }\n+        }\n+\n+        Throwable[] t = (Throwable []) errors.toArray(\n+            new Throwable [errors.size()]);\n+        throw new InvalidStateException(_loc.get(\"tm-not-found\")).\n+            setFatal(true).setNestedThrowables(t);\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+        _conf = conf;\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+    }\n+}"},{"sha":"dda4ff73ec67baa66bdd8815de90a3f6c2a1abba","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/InvocationManagedRuntime.java","status":"modified","additions":81,"deletions":74,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ee/InvocationManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ee/InvocationManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/InvocationManagedRuntime.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,74 +1,81 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.ee;\r\n-\r\n-import java.lang.reflect.Method;\r\n-import javax.transaction.TransactionManager;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-\r\n-/**\r\n- * Implementation of the {@link ManagedRuntime} interface that uses\r\n- * a static method call to find the TransactionManager.\r\n- * For example, to configure it to use IBM Websphere's TransactionManager,\r\n- * use the method:<br />\r\n- * <code>com.ibm.ejs.jts.jta.JTSXA.getTransactionManager</code>\r\n- *\r\n- * @author Marc Prud'hommeaux\r\n- */\r\n-public class InvocationManagedRuntime implements ManagedRuntime, Configurable {\r\n-\r\n-    private String _methodName = null;\r\n-    private String _clazz = null;\r\n-    private transient Method _method = null;\r\n-    private OpenJPAConfiguration _conf = null;\r\n-\r\n-    /**\r\n-     * Return the method to invoke to get the {@link TransactionManager}.\r\n-     */\r\n-    public String getTransactionManagerMethod() {\r\n-        return _methodName;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set the method to invoke to get the {@link TransactionManager}.\r\n-     * E.g.: com.ibm.ejs.jts.jta.JTSXA.getTransactionManager\r\n-     */\r\n-    public void setTransactionManagerMethod(String methodName) {\r\n-        _clazz = methodName.substring(0, methodName.lastIndexOf('.'));\r\n-        _methodName = methodName.substring(methodName.lastIndexOf('.') + 1);\r\n-        _method = null;\r\n-    }\r\n-\r\n-    public TransactionManager getTransactionManager() throws Exception {\r\n-        if (_method == null) {\r\n-            ClassLoader loader = _conf.getClassResolverInstance().\r\n-                getClassLoader(getClass(), null);\r\n-            _method = Class.forName(_clazz, true, loader)\r\n-                .getMethod(_methodName, null);\r\n-        }\r\n-        return (TransactionManager) _method.invoke(null, null);\r\n-    }\r\n-\r\n-    public void setConfiguration(Configuration conf) {\r\n-        _conf = (OpenJPAConfiguration) conf;\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.ee;\n+\n+import java.lang.reflect.Method;\n+import javax.transaction.TransactionManager;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+\n+/**\n+ * <p>Implementation of the {@link ManagedRuntime} interface that uses\n+ * a static method call to find the TransactionManager.</p>\n+ * <p/>\n+ * <p>For example, to configure it to use IBM Websphere's TransactionManager,\n+ * use the method:<br />\n+ * <code>com.ibm.ejs.jts.jta.JTSXA.getTransactionManager</code></p>\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+public class InvocationManagedRuntime\n+    implements ManagedRuntime, Configurable {\n+\n+    private String _methodName = null;\n+    private String _clazz = null;\n+    private transient Method _method = null;\n+    private OpenJPAConfiguration _conf = null;\n+\n+    /**\n+     * Return the method to invoke to get the {@link TransactionManager}.\n+     */\n+    public String getTransactionManagerMethod() {\n+        return _methodName;\n+    }\n+\n+    /**\n+     * Set the method to invoke to get the {@link TransactionManager}.\n+     * <p/>\n+     * E.g.: com.ibm.ejs.jts.jta.JTSXA.getTransactionManager\n+     */\n+    public void setTransactionManagerMethod(String methodName) {\n+        _clazz = methodName.substring(0, methodName.lastIndexOf('.'));\n+        _methodName = methodName.substring(methodName.lastIndexOf('.') + 1);\n+        _method = null;\n+    }\n+\n+    public TransactionManager getTransactionManager()\n+        throws Exception {\n+        if (_method == null) {\n+            ClassLoader loader = _conf.getClassResolverInstance().\n+                getClassLoader(getClass(), null);\n+            _method = Class.forName(_clazz, true, loader)\n+                .getMethod(_methodName, null);\n+        }\n+        return (TransactionManager) _method.invoke(null, null);\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+        _conf = (OpenJPAConfiguration) conf;\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+\t}\n+}"},{"sha":"2cfcb638f1eafea8c15fb9ff2e3a5f0afd49753d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","status":"modified","additions":57,"deletions":52,"changes":109,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,52 +1,57 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.ee;\r\n-\r\n-import javax.naming.Context;\r\n-import javax.naming.InitialContext;\r\n-import javax.transaction.TransactionManager;\r\n-\r\n-/**\r\n- * Implementation of the {@link ManagedRuntime} interface that uses JNDI to\r\n- * find the TransactionManager.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public class JNDIManagedRuntime implements ManagedRuntime {\r\n-\r\n-    private String _tmLoc = \"java:/TransactionManager\";\r\n-\r\n-    /**\r\n-     * Return the location of the {@link TransactionManager} in JNDI.\r\n-     */\r\n-    public String getTransactionManagerName() {\r\n-        return _tmLoc;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set the location of the {@link TransactionManager} in JNDI.\r\n-     */\r\n-    public void setTransactionManagerName(String name) {\r\n-        _tmLoc = name;\r\n-    }\r\n-\r\n-    public TransactionManager getTransactionManager() throws Exception {\r\n-        Context ctx = new InitialContext();\r\n-        try {\r\n-            return (TransactionManager) ctx.lookup(_tmLoc);\r\n-        }\r\n-        finally {\r\n-            ctx.close();\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.ee;\n+\n+import javax.naming.Context;\n+import javax.naming.InitialContext;\n+import javax.transaction.TransactionManager;\n+\n+/**\n+ * <p>Implementation of the {@link ManagedRuntime} interface that uses JNDI to\n+ * find the TransactionManager.</p>\n+ *\n+ * @author Abe White\n+ */\n+public class JNDIManagedRuntime\n+    implements ManagedRuntime {\n+\n+    private String _tmLoc = \"java:/TransactionManager\";\n+\n+    /**\n+     * Return the location of the {@link TransactionManager} in JNDI.\n+     */\n+    public String getTransactionManagerName() {\n+        return _tmLoc;\n+    }\n+\n+    /**\n+     * Set the location of the {@link TransactionManager} in JNDI.\n+     */\n+    public void setTransactionManagerName(String name) {\n+        _tmLoc = name;\n+    }\n+\n+    public TransactionManager getTransactionManager()\n+        throws Exception {\n+        Context ctx = new InitialContext();\n+        try {\n+            return (TransactionManager) ctx.lookup(_tmLoc);\n+        }\n+        finally {\n+            ctx.close();\n+        }\n+\t}\n+}"},{"sha":"0439614eb949f95834fc705524e84cf3d8e6085b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/ManagedRuntime.java","status":"modified","additions":36,"deletions":32,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ee/ManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ee/ManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/ManagedRuntime.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,32 +1,36 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.ee;\r\n-\r\n-import javax.transaction.TransactionManager;\r\n-\r\n-/**\r\n- * This interface must be implemented by concrete plugins to application\r\n- * servers in order to integrate the OpenJPA runtime in a managed environment.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public interface ManagedRuntime {\r\n-\r\n-    /**\r\n-     * Return the TransactionManager for the managed runtime. This\r\n-     * manager is used to register synchronization listeners, to\r\n-     * map transactional PersistenceManagers to the current transaction,\r\n-     * and possibly to enlist XA resources.\r\n-     */\r\n-    public TransactionManager getTransactionManager() throws Exception;\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.ee;\n+\n+import javax.transaction.TransactionManager;\n+\n+/**\n+ * <p>This interface must be implemented by concrete plugins to application\n+ * servers in order to integrate the OpenJPA runtime in a managed environment.</p>\n+ *\n+ * @author Abe White\n+ */\n+public interface ManagedRuntime {\n+\n+    /**\n+     * Return the TransactionManager for the managed runtime.  This\n+     * manager is used to register synchronization listeners, to\n+     * map transactional PersistenceManagers to the current transaction,\n+     * and possibly to enlist XA resources.\n+     */\n+    public TransactionManager getTransactionManager()\n+        throws Exception;\n+}"},{"sha":"9785e0607a195d2a966a9659102a6e6c2c71eb7c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/SunOneManagedRuntime.java","status":"modified","additions":46,"deletions":41,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ee/SunOneManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ee/SunOneManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/SunOneManagedRuntime.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,41 +1,46 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.ee;\r\n-\r\n-import java.lang.reflect.Method;\r\n-import javax.transaction.TransactionManager;\r\n-\r\n-/**\r\n- * {@link ManagedRuntime} implementation for SunONE.\r\n- *\r\n- * @author Marc Prud'hommeaux\r\n- */\r\n-public class SunOneManagedRuntime implements ManagedRuntime {\r\n-\r\n-    private Method _switchMeth;\r\n-    private Method _txManagerMeth;\r\n-\r\n-    public SunOneManagedRuntime()\r\n-        throws ClassNotFoundException, NoSuchMethodException {\r\n-        Class swtch = Class.forName(\"com.sun.enterprise.Switch\");\r\n-        _switchMeth = swtch.getMethod(\"getSwitch\", (Class[]) null);\r\n-        _txManagerMeth = swtch.getMethod(\"getTransactionManager\",\r\n-            (Class[]) null);\r\n-    }\r\n-\r\n-    public TransactionManager getTransactionManager() throws Exception {\r\n-        // return Switch.getSwitch().getTransactionManager();\r\n-        Object sw = _switchMeth.invoke(null, (Object[]) null);\r\n-        return (TransactionManager) _txManagerMeth.invoke(sw, (Object[]) null);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.ee;\n+\n+import java.lang.reflect.Method;\n+import javax.transaction.TransactionManager;\n+\n+/**\n+ * {@link ManagedRuntime} implementation for SunONE.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+public class SunOneManagedRuntime\n+    implements ManagedRuntime {\n+\n+    private Method _switchMeth;\n+    private Method _txManagerMeth;\n+\n+    public SunOneManagedRuntime()\n+        throws ClassNotFoundException, NoSuchMethodException {\n+        Class swtch = Class.forName(\"com.sun.enterprise.Switch\");\n+        _switchMeth = swtch.getMethod(\"getSwitch\", (Class[]) null);\n+        _txManagerMeth = swtch.getMethod(\"getTransactionManager\",\n+            (Class[]) null);\n+    }\n+\n+    public TransactionManager getTransactionManager()\n+        throws Exception {\n+        // return Switch.getSwitch ().getTransactionManager ();\n+        Object sw = _switchMeth.invoke(null, (Object[]) null);\n+        return (TransactionManager) _txManagerMeth.invoke(sw, (Object[]) null);\n+    }\n+}"},{"sha":"ee3f9b9425402d1fd7312b7e1febbab124e779de","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/WLSManagedRuntime.java","status":"modified","additions":48,"deletions":43,"changes":91,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WLSManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WLSManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WLSManagedRuntime.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,43 +1,48 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.ee;\r\n-\r\n-import java.lang.reflect.Method;\r\n-import javax.transaction.TransactionManager;\r\n-\r\n-/**\r\n- * {@link ManagedRuntime} implementation that directly accesses the\r\n- * transaction manager via WebLogic Server helper classes.\r\n- *\r\n- * @author Arunabh Hazarika, Patrick Linskey\r\n- */\r\n-public class WLSManagedRuntime implements ManagedRuntime {\r\n-\r\n-    private final Method _txHelperMeth;\r\n-    private final Method _txManagerMeth;\r\n-\r\n-    public WLSManagedRuntime()\r\n-        throws ClassNotFoundException, NoSuchMethodException {\r\n-        Class txHelper = Class.forName\r\n-            (\"weblogic.transaction.TransactionHelper\");\r\n-        _txHelperMeth = txHelper.getMethod(\"getTransactionHelper\", null);\r\n-        _txManagerMeth = txHelper.getMethod(\"getTransactionManager\", null);\r\n-    }\r\n-\r\n-    public TransactionManager getTransactionManager() throws Exception {\r\n-        // return TransactionHelper.getTransactionHelper().\r\n-        // getTransactionManager();\r\n-        Object o = _txHelperMeth.invoke(null, null);\r\n-        return (TransactionManager) _txManagerMeth.invoke(o, null);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.ee;\n+\n+import java.lang.reflect.Method;\n+import javax.transaction.TransactionManager;\n+\n+/**\n+ * {@link ManagedRuntime} implementation that directly accesses the\n+ * transaction manager via WebLogic Server helper classes.\n+ *\n+ * @author Arunabh Hazarika, Patrick Linskey\n+ */\n+public class WLSManagedRuntime\n+    implements ManagedRuntime {\n+\n+    private final Method _txHelperMeth;\n+    private final Method _txManagerMeth;\n+\n+    public WLSManagedRuntime()\n+        throws ClassNotFoundException, NoSuchMethodException {\n+        Class txHelper = Class.forName\n+            (\"weblogic.transaction.TransactionHelper\");\n+        _txHelperMeth = txHelper.getMethod(\"getTransactionHelper\", null);\n+        _txManagerMeth = txHelper.getMethod(\"getTransactionManager\", null);\n+    }\n+\n+    public TransactionManager getTransactionManager()\n+        throws Exception {\n+        // return TransactionHelper.getTransactionHelper ().\n+        //\tgetTransactionManager ();\n+        Object o = _txHelperMeth.invoke(null, null);\n+        return (TransactionManager) _txManagerMeth.invoke(o, null);\n+    }\n+}"},{"sha":"0524b90c6bb2638a3a42984b58d6a8601e867be6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"8f53cb3cdb26f2be1bf4687891dbe91b93cb30cd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java","status":"modified","additions":537,"deletions":492,"changes":1029,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"0cedb308c9acfb710b4ba4ce739ac4aae11bd5e7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorage.java","status":"modified","additions":138,"deletions":135,"changes":273,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorage.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorage.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorage.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a182b573a6ac66154518abdfaa31d448850c6630","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java","status":"modified","additions":530,"deletions":498,"changes":1028,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b9831cca70e12059fcf4270de23db69466a8f3d2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldConsumer.java","status":"modified","additions":72,"deletions":69,"changes":141,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldConsumer.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldConsumer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldConsumer.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"f4c96bd878c1534ae395c5a67d238f35fca7a7a9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldManager.java","status":"modified","additions":24,"deletions":20,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"243464a6b810addec4f1f3d17a5769b448d9a571","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldSupplier.java","status":"modified","additions":72,"deletions":69,"changes":141,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldSupplier.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldSupplier.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldSupplier.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"078775751253514c5ea2e018ff5a51cd03b47ff3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","status":"modified","additions":1081,"deletions":1024,"changes":2105,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"6c0b3852757540151c29f80d76065032724e9186","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","status":"modified","additions":3542,"deletions":3202,"changes":6744,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"e437c81de10e3242f91175a76504e6e61a2f634e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","status":"modified","additions":257,"deletions":247,"changes":504,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"0ed2e4d6223b6a23c76fec1e10db46c7ebb912ce","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PersistenceCapable.java","status":"modified","additions":91,"deletions":87,"changes":178,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PersistenceCapable.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"3aeb7b46a63c85b83de4e43eed162dd644b0e3bb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/StateManager.java","status":"modified","additions":282,"deletions":277,"changes":559,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/StateManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/StateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/StateManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"2fff1f3c1dca5c534eee3bf4bd8132871b156656","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractLifecycleListener.java","status":"modified","additions":81,"deletions":77,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractLifecycleListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractLifecycleListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractLifecycleListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"63f7a1de4cc4cce06a4c8d015b1d20712e354e93","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractRemoteCommitProvider.java","status":"modified","additions":67,"deletions":63,"changes":130,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractRemoteCommitProvider.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"f804364a5484608436a4e3dead4fcbfc2648d48f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractTransactionListener.java","status":"modified","additions":70,"deletions":67,"changes":137,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractTransactionListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractTransactionListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractTransactionListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"01b81ed46746150c17580f334e5cf74fd1756e38","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/AttachListener.java","status":"modified","additions":34,"deletions":31,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/AttachListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/AttachListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/AttachListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"33dbb8337c8ab8a37dd4154b72068a3effb73485","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java","status":"modified","additions":70,"deletions":63,"changes":133,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"3164e0eff27c9bbd75cdc935a9fd96dc77507d67","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BeginTransactionListener.java","status":"modified","additions":33,"deletions":30,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeginTransactionListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeginTransactionListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeginTransactionListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a60378873a29c5ea5ce6c3a03e630668003aa7d2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/CallbackModes.java","status":"modified","additions":50,"deletions":47,"changes":97,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/CallbackModes.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/CallbackModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/CallbackModes.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"107a235187c3a72840afb9347469cf391cf32bd5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/ClearListener.java","status":"modified","additions":35,"deletions":32,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/ClearListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/ClearListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/ClearListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"69ea212932e62b3e8ae1046d7729525306322b57","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/DeleteListener.java","status":"modified","additions":35,"deletions":32,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/DeleteListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/DeleteListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/DeleteListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"4c1abd34e1fdb59cf6b7d4b00d38d5878c05bc98","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/DetachListener.java","status":"modified","additions":34,"deletions":31,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/DetachListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/DetachListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/DetachListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"cb423d5dcdd7e9268ef2fd62be520303cf7c8fb7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/DirtyListener.java","status":"modified","additions":45,"deletions":42,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/DirtyListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/DirtyListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/DirtyListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"d2ea5a4f48ad10adf9d3fb5ec1295d9230b886b6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/EndTransactionListener.java","status":"modified","additions":70,"deletions":67,"changes":137,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/EndTransactionListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/EndTransactionListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/EndTransactionListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"d2e07bd4e28ea51aa0f53b427d78b67b89cdb109","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/ExceptionOrphanedKeyAction.java","status":"modified","additions":40,"deletions":35,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/ExceptionOrphanedKeyAction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/ExceptionOrphanedKeyAction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/ExceptionOrphanedKeyAction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"1e643b0a09840516a4013a5d744674804db8ebe1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/FlushTransactionListener.java","status":"modified","additions":40,"deletions":37,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/FlushTransactionListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/FlushTransactionListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/FlushTransactionListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a4df85579f88642ed8df936086dc504bfa659604","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java","status":"modified","additions":281,"deletions":255,"changes":536,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"005a4f12a789b3a8010d7730ba9852cb90e17cd5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleCallbacks.java","status":"modified","additions":36,"deletions":33,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleCallbacks.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"e88a85212527defbf4ba73186432d0275d333ad6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java","status":"modified","additions":185,"deletions":164,"changes":349,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"6382a2285b1dddf4963b366978ec496581fe7db1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","status":"modified","additions":588,"deletions":553,"changes":1141,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"051414537f4c67c6f71723d90dafd81188a29189","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleListener.java","status":"modified","additions":28,"deletions":25,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"816a9a3f0adce20a2cd73822450c01fabac3f27e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LoadListener.java","status":"modified","additions":35,"deletions":32,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/LoadListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/LoadListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LoadListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b21e4d5fa8184f7d450289b42127ba315b0a318a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LogOrphanedKeyAction.java","status":"modified","additions":108,"deletions":103,"changes":211,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/LogOrphanedKeyAction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/LogOrphanedKeyAction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LogOrphanedKeyAction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"cbde25b04928f6b5e983491062c32ed35ad1ee49","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java","status":"modified","additions":112,"deletions":103,"changes":215,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"0d5e26e1b606e581425fca0de174e75dccac752a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/NoneOrphanedKeyAction.java","status":"modified","additions":34,"deletions":30,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/NoneOrphanedKeyAction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/NoneOrphanedKeyAction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/NoneOrphanedKeyAction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"097645a8fc01c1e3da2c97e893f9dfa6b6076ce7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/OrphanedKeyAction.java","status":"modified","additions":40,"deletions":37,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/OrphanedKeyAction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/OrphanedKeyAction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/OrphanedKeyAction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"185d5ec2ef7b9a19c6f2f7d69db4705aceeb9754","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/PersistListener.java","status":"modified","additions":34,"deletions":31,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/PersistListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/PersistListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/PersistListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"6a42f44ee2532f6312310268209c69414e14559a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java","status":"modified","additions":187,"deletions":175,"changes":362,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"d9695ab6708febac99fb676b06f5efb167d5b6f7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","status":"modified","additions":225,"deletions":212,"changes":437,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b506997170c516b0c8e26e70bd614beb2904f48c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitListener.java","status":"modified","additions":65,"deletions":52,"changes":117,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"d52eca55d69b45d3ffa252ba231307f65501ad31","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitProvider.java","status":"modified","additions":63,"deletions":55,"changes":118,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitProvider.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"455d57bdd7172c816aa51cf6db91edafbbef7ba7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","status":"modified","additions":66,"deletions":61,"changes":127,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"3358e76dbc4d61510db5394f36c508615cfae434","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/StoreListener.java","status":"modified","additions":35,"deletions":32,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/StoreListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/StoreListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/StoreListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"da28abb5519ee47415073a674ec522e85a7fba6d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","status":"modified","additions":940,"deletions":869,"changes":1809,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"8745367cd87eb604f94026bf99f1c503427a2c46","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEvent.java","status":"modified","additions":157,"deletions":147,"changes":304,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEvent.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEvent.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"949bcfc3c8c51d165ea9741ecae35d7cc6eecc62","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","status":"modified","additions":126,"deletions":121,"changes":247,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"23f12918069827bddcf28dcb376914ab3ccc8d06","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionListener.java","status":"modified","additions":29,"deletions":26,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"1b68bebc071384b04185f829162a193c99bda0f4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"modified","additions":666,"deletions":612,"changes":1278,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"200411ba5a38be933c146a2d0b4bfa148b722c14","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractFieldManager.java","status":"modified","additions":109,"deletions":105,"changes":214,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractFieldManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"c866dd526ff058c3954646fd8ad6834d66203483","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractLockManager.java","status":"modified","additions":80,"deletions":75,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractLockManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"8c63db3f55f655f340cff9665fc42f5ea277c5ef","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java","status":"modified","additions":315,"deletions":299,"changes":614,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"61fa66ce25873d4c050aee9a9b4fb24c46b499b7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCResultObjectProvider.java","status":"modified","additions":169,"deletions":154,"changes":323,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCResultObjectProvider.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"09d93c9be705fffe99063caed32d2b716c7b71ca","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","status":"modified","additions":193,"deletions":188,"changes":381,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"5db310fc59161a1cf8d1fe2860cbc97841ba93fc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","status":"modified","additions":335,"deletions":317,"changes":652,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"39e6ec0bfc62d4bc7ba75e9cfa631caad18f81cd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java","status":"modified","additions":502,"deletions":474,"changes":976,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"2a1723c1f42abbeb2544d99c7b79b46d30b1f8ad","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoClear.java","status":"modified","additions":35,"deletions":32,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoClear.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoClear.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoClear.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a0744e4561fe934e7dae3040a4cc13ad62d0a44b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoDetach.java","status":"modified","additions":38,"deletions":35,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoDetach.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoDetach.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoDetach.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"cc7d83e55976cf04c6d54f72983c9b27388e7c6a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java","status":"modified","additions":143,"deletions":129,"changes":272,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"be107dcf28e7b9351ebe2df28f67d98372a8fb87","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Broker.java","status":"modified","additions":665,"deletions":652,"changes":1317,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Broker.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Broker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Broker.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"3d5fe220d4b390b0dbe29e6fb17e783746ab33a3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java","status":"modified","additions":101,"deletions":97,"changes":198,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"4485b333739b468d454a6b2e4d67cc078764232c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":4980,"deletions":4565,"changes":9545,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"082bfd73a1f3f8bd82c16e4b37d8d3c13aa9dbf7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ClearFieldManager.java","status":"modified","additions":75,"deletions":71,"changes":146,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ClearFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ClearFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ClearFieldManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"4cc3c3787906c70d9db9aeb094d255878fba1171","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ConnectionRetainModes.java","status":"modified","additions":42,"deletions":39,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ConnectionRetainModes.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ConnectionRetainModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ConnectionRetainModes.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"f7ce77cdec2634ada51f16b2aace0998abbfe9af","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","status":"modified","additions":1496,"deletions":1333,"changes":2829,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"9ba7ab22c18ebd989ea93f5d101fb7e33f75bcc6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java","status":"modified","additions":205,"deletions":187,"changes":392,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"bb4364819ab94ac7ed731e7f5cfef180aee888fb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java","status":"modified","additions":193,"deletions":176,"changes":369,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"cc28cb36d72c9f2666550b02a16a67fbb8c66fcf","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","status":"modified","additions":495,"deletions":447,"changes":942,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"1158e604712497bf738362115e44e669f28f3460","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java","status":"modified","additions":723,"deletions":649,"changes":1372,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"737705a229cb72a94b30ae8ec2bd6f506a26a980","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java","status":"modified","additions":473,"deletions":429,"changes":902,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"48a2a71a6cb67b77219d2c5e56504fe959388445","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java","status":"modified","additions":136,"deletions":125,"changes":261,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b8bac2f1f9804cd18bcf920ee948549bc32c70cb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java","status":"modified","additions":199,"deletions":194,"changes":393,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"2affc96f7faf1f783aedd9906889831327523e27","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","status":"modified","additions":822,"deletions":768,"changes":1590,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"71faf992969405db19861400746fcca6b0fe591b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachState.java","status":"modified","additions":40,"deletions":37,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"26a538f9b89f2e03e7933f0162ce0c701087491d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","status":"modified","additions":191,"deletions":173,"changes":364,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"1f09c9777cde8062eedc61f6e87537474d4adf00","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","status":"modified","additions":930,"deletions":901,"changes":1831,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"d2b1d78ef1f19a260f8426ad0502a724cf4aa6fe","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","status":"modified","additions":591,"deletions":583,"changes":1174,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b227547affb7950872f75ed056aa1874995c31a0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECleanState.java","status":"modified","additions":84,"deletions":79,"changes":163,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECleanState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECleanState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECleanState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"45920f4c1c103cd5d09eeb0c370b0219cc84c924","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECopyState.java","status":"modified","additions":81,"deletions":76,"changes":157,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECopyState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECopyState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECopyState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"f9c441b5e098a3ce9d6b595977adeb59788b6f97","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDeletedState.java","status":"modified","additions":72,"deletions":67,"changes":139,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDeletedState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDeletedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDeletedState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"0df48317e1035d5249e6ce9f30f47263fb492e12","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDirtyState.java","status":"modified","additions":88,"deletions":83,"changes":171,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDirtyState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDirtyState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDirtyState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"030420df29102af0a8efa91adeff06b2b2a1e181","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ENonTransState.java","status":"modified","additions":77,"deletions":71,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ENonTransState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ENonTransState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ENonTransState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"7ab8608ca0110276db02059aede630bedd238a5f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java","status":"modified","additions":665,"deletions":627,"changes":1292,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"0cfb72891bbb066f96f8867a78556b181eef2acd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Extent.java","status":"modified","additions":90,"deletions":85,"changes":175,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Extent.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Extent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Extent.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"c508aea12340bd81dfa96988e0891b1c0e5522e1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","status":"modified","additions":357,"deletions":328,"changes":685,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"d561d39ab8877f49d492cc80310946ff99a05507","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","status":"modified","additions":316,"deletions":312,"changes":628,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"202eab49d5208d0d279c4569ff4f8f27aca09a9a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","status":"modified","additions":436,"deletions":410,"changes":846,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ea05868719e4b62256ad039cfe9b2de69a2124b4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchState.java","status":"modified","additions":68,"deletions":65,"changes":133,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"961543d974f8a58f7fe04cd2f23dd2fd861555d4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchStateImpl.java","status":"modified","additions":245,"deletions":233,"changes":478,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchStateImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchStateImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchStateImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"6c03913461b6c9deb9f677eb844d074fa7d64a6a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","status":"modified","additions":867,"deletions":822,"changes":1689,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"092d20185e30d75fae65e0052f233cbd9d608d71","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FindCallbacks.java","status":"modified","additions":40,"deletions":37,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FindCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FindCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FindCallbacks.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"815fbfbfd24e27a85c09e11469705572d8b12306","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/HollowState.java","status":"modified","additions":81,"deletions":76,"changes":157,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/HollowState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/HollowState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/HollowState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"7600dfbe0437bdb3263625b22ee9a4fc44c18a85","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InMemorySavepointManager.java","status":"modified","additions":63,"deletions":58,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InMemorySavepointManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InMemorySavepointManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InMemorySavepointManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"c5a6917a0eddc4a95c7b6d96926338008e1ce468","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InverseManager.java","status":"modified","additions":407,"deletions":385,"changes":792,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InverseManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InverseManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InverseManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"09d8c6d7f60fe652a869782b920d955aba7d170f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java","status":"modified","additions":208,"deletions":187,"changes":395,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"5f1e834e978c308530b46fefeaab6bcdac724d13","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockLevels.java","status":"modified","additions":40,"deletions":37,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockLevels.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockLevels.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockLevels.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a99a99d47e9ac523bcd6c3569ec9e76955401cf3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockManager.java","status":"modified","additions":108,"deletions":103,"changes":211,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b545d3ba4ee08b87b59a3e1f47b8e8d40e617487","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java","status":"modified","additions":260,"deletions":237,"changes":497,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b85e0369f36331549f3d0fc26d051ff876be5d2f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/NoneLockManager.java","status":"modified","additions":38,"deletions":34,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/NoneLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/NoneLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/NoneLockManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"44a3e196ddcd004198e9b16b742301bcf10fb63a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","status":"modified","additions":745,"deletions":728,"changes":1473,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"3908d055219ab50fa30933a808c9c8ea00b392e9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpCallbacks.java","status":"modified","additions":52,"deletions":48,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpCallbacks.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"be20cb806fc67e21cf53f415cdbd7b1410b9d175","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java","status":"modified","additions":124,"deletions":119,"changes":243,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"8b37d9380e15c4c63afd2f884640c2568bcc2ea7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java","status":"modified","additions":495,"deletions":488,"changes":983,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"d67df31c912809691e8d3a35800d058fc57f5bf3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OrderingMergedResultObjectProvider.java","status":"modified","additions":108,"deletions":102,"changes":210,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OrderingMergedResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OrderingMergedResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OrderingMergedResultObjectProvider.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"c8aa40cd465d97e9b6cc58ff53359aa1a2cbc9ab","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCData.java","status":"modified","additions":108,"deletions":102,"changes":210,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCData.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCData.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"7e6ed424c59a7786a8f8a63ad216de9e6f1b4806","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCDataImpl.java","status":"modified","additions":308,"deletions":294,"changes":602,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCDataImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCDataImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCDataImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b6c07395f8840bb69b490aa52787976d7acd7ac3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCResultObjectProvider.java","status":"modified","additions":41,"deletions":34,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCResultObjectProvider.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b76012a3a15c167991d73ed4cf7f7b6c1f827ec9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java","status":"modified","additions":467,"deletions":453,"changes":920,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"3d800eb525e1ac744f81a3ace0b8a82e042e8bf6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCleanState.java","status":"modified","additions":83,"deletions":78,"changes":161,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCleanState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCleanState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCleanState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"14af67d99ce3132bb530bab7be5d5a6817104643","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedFlushedState.java","status":"modified","additions":37,"deletions":32,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedFlushedState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedFlushedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedFlushedState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"005159fc00a349c12e76fbdb2f913003a4ebba06","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedState.java","status":"modified","additions":88,"deletions":83,"changes":171,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"3dc413ad2036f72631611bb8a4362000f3db1d1a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDirtyState.java","status":"modified","additions":88,"deletions":83,"changes":171,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDirtyState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDirtyState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDirtyState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b5d6ca936daa35221264ae3d287e82e7fb3c8bc2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewDeletedState.java","status":"modified","additions":90,"deletions":85,"changes":175,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewDeletedState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewDeletedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewDeletedState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"7c8aa359960a94b7bb6f18af695a34ac3bcf7f83","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedFlushedState.java","status":"modified","additions":36,"deletions":31,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedFlushedState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedFlushedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedFlushedState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ad8976387520c6f52a718a8b752575483ee79a32","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedState.java","status":"modified","additions":92,"deletions":87,"changes":179,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"3673b13c0b58a5f63811b3d576aafb0adac9e169","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewState.java","status":"modified","additions":87,"deletions":82,"changes":169,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"271bbd7b2d61155f5975c9f38923c3215b0881e1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDeletedState.java","status":"modified","additions":77,"deletions":72,"changes":149,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDeletedState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDeletedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDeletedState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"dde772832c0f8374ba1d08c8e3a75f52bb812132","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDirtyState.java","status":"modified","additions":67,"deletions":62,"changes":129,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDirtyState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDirtyState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDirtyState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a7b30affc14e4b73492b28197be66483b97e9701","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransNewState.java","status":"modified","additions":61,"deletions":56,"changes":117,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransNewState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransNewState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransNewState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"f2486964c33e995b82ca54f7596436b43a229845","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java","status":"modified","additions":121,"deletions":114,"changes":235,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a1efb687d018c0e30c4bb82b286c0bd72e0b7842","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Query.java","status":"modified","additions":194,"deletions":187,"changes":381,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Query.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Query.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Query.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"f5297b9c1f477bb528ccb63f345478f186dccb2c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java","status":"modified","additions":289,"deletions":282,"changes":571,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"815745531ab6216e358f6f6bcfdf76628e84d69f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryFlushModes.java","status":"modified","additions":53,"deletions":50,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryFlushModes.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryFlushModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryFlushModes.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"4f23cccbc751b1a586e645060f001921a5c16032","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","status":"modified","additions":2249,"deletions":2108,"changes":4357,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"486d7c670294696b4fa4f34b57417dc8d464d35c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java","status":"modified","additions":65,"deletions":59,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"485a7c894f3ed832b295ce23a1987a3bd439ba28","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryOperations.java","status":"modified","additions":48,"deletions":45,"changes":93,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryOperations.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryOperations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryOperations.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"9ad987b117dc02d765dc1eb548fd3f472f9ef5f1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java","status":"modified","additions":80,"deletions":74,"changes":154,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"3af27be5b548d10ceb51c7b7ba8d76062a39aa41","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/RestoreState.java","status":"modified","additions":40,"deletions":37,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/RestoreState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/RestoreState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/RestoreState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"f4936e3260d8c1df595c8443f322c2e11e69bcbe","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java","status":"modified","additions":353,"deletions":330,"changes":683,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"5dc81280a4fc05bf3576e5f4d1e54bba8ed07f79","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","status":"modified","additions":208,"deletions":190,"changes":398,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"7339fea0fd8c48485ee206f8a660ebd343243265","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java","status":"modified","additions":214,"deletions":201,"changes":415,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"d00aeb7e33134e87e8bc53293507cd1d27c467f7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointManager.java","status":"modified","additions":36,"deletions":33,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"0586383090a3f330b23f23f3a89220e979a3c1fe","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Seq.java","status":"modified","additions":70,"deletions":66,"changes":136,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Seq.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Seq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Seq.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"e6e9de3f06836cdfb479595fa23af7e1c9cc6ae1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","status":"modified","additions":838,"deletions":800,"changes":1638,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b5b3aad195802324c2f3a9ea0cfdb5b97defef2c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":3026,"deletions":2831,"changes":5857,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a3ab1d28091afa6cfa241fba22ffe616b9897f6e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","status":"modified","additions":437,"deletions":430,"changes":867,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"c4c5d0405c1f1114fd5808cda975349d367ebd17","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","status":"modified","additions":427,"deletions":416,"changes":843,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"5e9938711808a46daa2a4eb916b71a8d50683143","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","status":"modified","additions":314,"deletions":308,"changes":622,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"5ca754ead3ca6fd58886f835b9fa53d7ca41db10","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TCleanState.java","status":"modified","additions":61,"deletions":55,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TCleanState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TCleanState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TCleanState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"06657bcd7688e0f936c9fc32ee6c28e3cb1eef65","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TDirtyState.java","status":"modified","additions":72,"deletions":67,"changes":139,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TDirtyState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TDirtyState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TDirtyState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"4875c3a82ea89d9d461ae877ddfd7d49d05b13c6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TLoadedState.java","status":"modified","additions":38,"deletions":33,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TLoadedState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TLoadedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TLoadedState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"2e19f4a64514371ef9982352c225ad34cb83b8ae","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TimeSeededSeq.java","status":"modified","additions":64,"deletions":59,"changes":123,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TimeSeededSeq.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TimeSeededSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TimeSeededSeq.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"35a60249f3f56cf88ba9f444bdca54626ba480bb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransferFieldManager.java","status":"modified","additions":136,"deletions":131,"changes":267,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransferFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransferFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransferFieldManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"497c5c1a6c1c9c741177abf0f50a86437bab54db","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransientState.java","status":"modified","additions":37,"deletions":32,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransientState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransientState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransientState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"6d64f0932ee222f352398a70c77bdf5ccd91cef1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDHexSeq.java","status":"modified","additions":63,"deletions":58,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDHexSeq.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDHexSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDHexSeq.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"7f4064f6a24bf7d6560542e7ba27fcb757f384a2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDStringSeq.java","status":"modified","additions":63,"deletions":58,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDStringSeq.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDStringSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDStringSeq.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"9d39e427dc5e3e0d1e0afc2992c2b770387bfeea","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","status":"modified","additions":333,"deletions":310,"changes":643,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"64a0f53b7b1018db297d17e7e9841bc35d0c8048","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java","status":"modified","additions":140,"deletions":132,"changes":272,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ccd16a1d26d12cfef6789132638e97949161a2d8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Abs.java","status":"modified","additions":68,"deletions":60,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Abs.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Abs.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Abs.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ff4ddd89c27e365651f1a058a103b2fb52557e8e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","status":"modified","additions":484,"deletions":447,"changes":931,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"76764186e5d4d24bc0e520a68ec957d2b9e9ceca","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Add.java","status":"modified","additions":38,"deletions":34,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Add.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Add.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Add.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"566a1a23ef57df1b0b76221ad3878ebfce606962","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Aggregate.java","status":"modified","additions":91,"deletions":84,"changes":175,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Aggregate.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Aggregate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Aggregate.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"be2100737325252b0e9163ec22de893b4a9728dc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateListener.java","status":"modified","additions":69,"deletions":65,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"271f17d1358f16e771245185360147979c392611","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateVal.java","status":"modified","additions":88,"deletions":82,"changes":170,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateVal.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateVal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateVal.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"87f6c88723fd62c8b440c94c545ba8cd3d3654a6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/All.java","status":"modified","additions":56,"deletions":49,"changes":105,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/All.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/All.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/All.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"c40f1859d75fd5a43c9046c1e37ba8c94e4aeaa7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AndExpression.java","status":"modified","additions":61,"deletions":57,"changes":118,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AndExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AndExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AndExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a7987cf8889ce7724a6e9ced84a64fe6faa6e785","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Any.java","status":"modified","additions":55,"deletions":48,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Any.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Any.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Any.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"7a4f24036ffb30289124f3c9dbbca14cef5082ed","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Args.java","status":"modified","additions":84,"deletions":77,"changes":161,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Args.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Args.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Args.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"efe5c33cc32a25b07c8c8fcdb1c4b7ccb6f7ab65","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Arguments.java","status":"modified","additions":30,"deletions":26,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Arguments.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Arguments.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Arguments.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"2469471cff673c6464d96bea02b0313074f8142e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Avg.java","status":"modified","additions":62,"deletions":56,"changes":118,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Avg.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Avg.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Avg.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"d39c1f3b2b47dafa484f7d4f820cd432122ffbfc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindKeyVariableExpression.java","status":"modified","additions":44,"deletions":40,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindKeyVariableExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindKeyVariableExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindKeyVariableExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"3794a3c51cf672b6abdf82db27a854a8eaadb42a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindValueVariableExpression.java","status":"modified","additions":44,"deletions":40,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindValueVariableExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindValueVariableExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindValueVariableExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"7f38d87494108f6b96525b792d372b905945f42f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableAndExpression.java","status":"modified","additions":76,"deletions":69,"changes":145,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableAndExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableAndExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableAndExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"f43738756fffcf2924a179bc8bb8b615075f2a89","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableExpression.java","status":"modified","additions":83,"deletions":79,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"53d2f65baeb56bfc828faf33c93d6ab43321815d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BoundVariable.java","status":"modified","additions":86,"deletions":82,"changes":168,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BoundVariable.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BoundVariable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BoundVariable.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"37809ccb2b1dc7f35a14397472fb9c8a0d55540a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","status":"modified","additions":170,"deletions":158,"changes":328,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"8dedf7f95ad7b22320dc779772c2abaa923e7bf2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Cast.java","status":"modified","additions":75,"deletions":70,"changes":145,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Cast.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Cast.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Cast.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"28c1affca407ffd5aeabd54a0f2c4600cf80d0ca","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CompareExpression.java","status":"modified","additions":75,"deletions":68,"changes":143,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CompareExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CompareExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CompareExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"4707ec89800063dc81221288b6bab67a89f63c7e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Concat.java","status":"modified","additions":71,"deletions":64,"changes":135,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Concat.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Concat.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Concat.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ddb21917102cd28b9c8cb514c2dbf098ccb3faa4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java","status":"modified","additions":31,"deletions":27,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"e9bbef2bc9ee1b30514c1c2de735252ff2bb7153","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsExpression.java","status":"modified","additions":74,"deletions":69,"changes":143,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"9063f05f776075f0d7253835cf1b2def524e4ff0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsKeyExpression.java","status":"modified","additions":43,"deletions":39,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsKeyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsKeyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsKeyExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"061436bfae84cd73cfec49e8e675a92850d438da","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsValueExpression.java","status":"modified","additions":43,"deletions":39,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsValueExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsValueExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsValueExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"45c88d1f2c6d005be97a578d68ab0e7cd00dae6d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Count.java","status":"modified","additions":49,"deletions":45,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Count.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Count.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Count.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"8542d60b68506562bfe80fabb7166f374f08375c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CurrentDate.java","status":"modified","additions":49,"deletions":45,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CurrentDate.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CurrentDate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CurrentDate.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"eda29b2cbe77fb5ac2272e36091390dbc29def23","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Distinct.java","status":"modified","additions":78,"deletions":71,"changes":149,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Distinct.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Distinct.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Distinct.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"94a95b5190486c825e2e446e2da116995601d43b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Divide.java","status":"modified","additions":39,"deletions":35,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Divide.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Divide.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Divide.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"bc0523140e203d7d4e33fd9324b9f2c424f7dd3d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EndsWithExpression.java","status":"modified","additions":38,"deletions":34,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EndsWithExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EndsWithExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EndsWithExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"064bc42ea10cbe8ab069e3e8421ae04ffa604a34","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EqualExpression.java","status":"modified","additions":39,"deletions":34,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EqualExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"db94b66d0b21442354b0f82f98347f8802688596","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java","status":"modified","additions":78,"deletions":70,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"9172b8eb8b6c1f90ff18dff25fd0e1d3d0dfd35c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Expression.java","status":"modified","additions":26,"deletions":23,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Expression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Expression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Expression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"5f27693b0f80bcde2d6194d6430698f241bae53a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionFactory.java","status":"modified","additions":404,"deletions":398,"changes":802,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionFactory.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"d67d0d2cf3352fccc916b7d915fe9713fc9aa631","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionParser.java","status":"modified","additions":61,"deletions":57,"changes":118,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionParser.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionParser.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"cc78146f0af0a34d430dd7ab23d48c8a29c839ed","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Extension.java","status":"modified","additions":90,"deletions":86,"changes":176,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Extension.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Extension.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Extension.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"c7d23a69eb621933b92fd61827376d7b1b72cef9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/FilterListener.java","status":"modified","additions":89,"deletions":82,"changes":171,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/FilterListener.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/FilterListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/FilterListener.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"eab395db4e58a6a71d9133998393145504341b18","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetObjectId.java","status":"modified","additions":56,"deletions":52,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetObjectId.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetObjectId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetObjectId.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"aa8f4b19f6095cc2149eaffbb1ee57e1eb958041","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanEqualExpression.java","status":"modified","additions":40,"deletions":35,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanEqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanEqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanEqualExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"68929ecf763b784a834f7c62533a39115307e58b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanExpression.java","status":"modified","additions":40,"deletions":35,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"13fd566e8b18a2344820e30155c1b2d7632176e7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java","status":"modified","additions":725,"deletions":688,"changes":1413,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b7c71fa0757c5bdf30c4f493264a9540d902a835","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IndexOf.java","status":"modified","additions":69,"deletions":64,"changes":133,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IndexOf.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IndexOf.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IndexOf.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ccaa75e8f5996d229b60d57dc801e5cef4a56f48","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InstanceofExpression.java","status":"modified","additions":60,"deletions":56,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InstanceofExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InstanceofExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InstanceofExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"17bf1887c33196a040c1160ee7c3bad1ad197500","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IsEmptyExpression.java","status":"modified","additions":67,"deletions":63,"changes":130,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IsEmptyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IsEmptyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IsEmptyExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"0b2e8f7d10d0c474626d909a9484ddc6cbe06d73","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanEqualExpression.java","status":"modified","additions":40,"deletions":35,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanEqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanEqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanEqualExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"82f3ce7899033b80a14d15b5a266d526e6ff205f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanExpression.java","status":"modified","additions":40,"deletions":35,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"f0fce2838c447628eb31424c1c9355b3844e9b15","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Lit.java","status":"modified","additions":77,"deletions":72,"changes":149,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Lit.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Lit.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Lit.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a6861c176f11d3af097de73c8beba588c36edb51","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java","status":"modified","additions":48,"deletions":44,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"846da35f716f67f346c5f00959fb966a1a5783ca","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MatchesExpression.java","status":"modified","additions":73,"deletions":64,"changes":137,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MatchesExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MatchesExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MatchesExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"45c9bc05c59b2cb8fc4e9196ab6e3cc2c5cf348e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MathVal.java","status":"modified","additions":69,"deletions":65,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MathVal.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MathVal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MathVal.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"70583b387f3c1945dd8fe9aae50a3ba64b5dfc3d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Max.java","status":"modified","additions":50,"deletions":46,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Max.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Max.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Max.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"0423c7b8d9ed9da7dc59073e00711bea8ad94bf3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Min.java","status":"modified","additions":50,"deletions":46,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Min.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Min.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Min.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"c491a3427aefafe388369812a584033ec61bd6c9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Mod.java","status":"modified","additions":39,"deletions":35,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Mod.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Mod.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Mod.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ca69ac4d609c6f08ad951e11d596e1653ed30f49","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Multiply.java","status":"modified","additions":39,"deletions":35,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Multiply.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Multiply.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Multiply.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"832fd3a578db6410199ad98c8e62b7c231d9a2ea","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotEqualExpression.java","status":"modified","additions":39,"deletions":34,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotEqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotEqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotEqualExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"1cdd4f44c57facd3adef5005c85fd071a1b3e9e4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotExpression.java","status":"modified","additions":49,"deletions":45,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"df5b01538ef8af358770e8117b1c5fb88f21e116","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Null.java","status":"modified","additions":47,"deletions":43,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Null.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Null.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Null.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"132ec3d54a6ceba6328727ba600432542a52eacb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/OrExpression.java","status":"modified","additions":53,"deletions":49,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/OrExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/OrExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/OrExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"79a9365838c3312e376cece97bec1d8a5af4c864","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Param.java","status":"modified","additions":74,"deletions":69,"changes":143,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Param.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Param.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Param.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"98f31bcd36f8ea9cbfcb7b3013c73998e4e3e97c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java","status":"modified","additions":36,"deletions":32,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"78bd15b201d863430e2d32b66da4365a3a187054","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java","status":"modified","additions":41,"deletions":37,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"8bb4fd45a965abf03387c4aa3748675909e88874","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java","status":"modified","additions":63,"deletions":59,"changes":122,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"87de0507b12764f9f3dc86622446353f849f9627","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Resolver.java","status":"modified","additions":51,"deletions":48,"changes":99,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Resolver.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Resolver.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Resolver.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"e27b99eed9b97f859d8947fcf3231790f757386f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Size.java","status":"modified","additions":46,"deletions":42,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Size.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Size.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Size.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"d284ec3d979164dd34f4aa7bdb340d363c898045","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sqrt.java","status":"modified","additions":40,"deletions":36,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sqrt.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sqrt.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sqrt.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"342817ffc5954cb8c9dda07b93b0a99664b798cc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StartsWithExpression.java","status":"modified","additions":38,"deletions":34,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StartsWithExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StartsWithExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StartsWithExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"87c858b9346cf14aa37cb7c826e971043204cd92","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringContains.java","status":"modified","additions":64,"deletions":58,"changes":122,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringContains.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringContains.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringContains.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"0334edae95d874373a8ffb26e866256ead744cf3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringLength.java","status":"modified","additions":66,"deletions":61,"changes":127,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringLength.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringLength.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringLength.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"f9331953a5bb58ace1ec049901d56058f468499e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java","status":"modified","additions":69,"deletions":63,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ebb7d081567043f667adb0011dfe398a595fe186","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java","status":"modified","additions":37,"deletions":33,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"bb09a206f614721d84398753f32ebea7b6499eb6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Substring.java","status":"modified","additions":66,"deletions":62,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Substring.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Substring.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Substring.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"cafaf40a1976844b04e8cebbc0324a86768bf516","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subtract.java","status":"modified","additions":39,"deletions":35,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subtract.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subtract.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subtract.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a7561650d7b7aed43d05f29e36aeb3cd4bf30496","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sum.java","status":"modified","additions":62,"deletions":55,"changes":117,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sum.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sum.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sum.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"0dad186d29e34a632c0b09b7916f52ace25a2545","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/This.java","status":"modified","additions":47,"deletions":43,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/This.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/This.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/This.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"db34923f9009313c8a3a3236947a054c0640b815","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToLowerCase.java","status":"modified","additions":57,"deletions":53,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToLowerCase.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToLowerCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToLowerCase.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"6c65fac59d377f4fe69364f6982055658b59c95e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToUpperCase.java","status":"modified","additions":57,"deletions":53,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToUpperCase.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToUpperCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToUpperCase.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"06e2c7520af324d7116a98768f10ac8c10fd0b89","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Trim.java","status":"modified","additions":83,"deletions":73,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Trim.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Trim.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Trim.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"953f6d0e60e6b4b11f96625efdc31774bb60ecf4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnaryMathVal.java","status":"modified","additions":68,"deletions":64,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnaryMathVal.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnaryMathVal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnaryMathVal.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"914d2cc2e4bbf887432135626c6974ea3b89808f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnboundVariable.java","status":"modified","additions":74,"deletions":69,"changes":143,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnboundVariable.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnboundVariable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnboundVariable.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"e5833635bba79d9e99f5df149a8d7a03e26aaab3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","status":"modified","additions":110,"deletions":102,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"f7ec13a3580967853370a33359fa068e6eb3b6cc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValExpression.java","status":"modified","additions":51,"deletions":47,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValExpression.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"294ea8efaf6784c8d24b383b70c9aca781637fe2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java","status":"modified","additions":55,"deletions":52,"changes":107,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"28f9f2b2e005994e0c44a2f4214e2b5a90106e74","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValuePath.java","status":"modified","additions":52,"deletions":48,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValuePath.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValuePath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValuePath.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b7b5281a1f8b464075d2fa76551a78412d7d6828","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/WildcardMatch.java","status":"modified","additions":72,"deletions":64,"changes":136,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/WildcardMatch.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/WildcardMatch.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/WildcardMatch.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"86c553cce001a8d781f7ff8138010b01a89b0def","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","status":"modified","additions":1676,"deletions":1440,"changes":3116,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"abf319b0582e4203b73e74187fcfd9c2e41088ae","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java","status":"modified","additions":77,"deletions":69,"changes":146,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"885a41ff56275d16c5731be7660ccf048c6bf87b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/ParseException.java","status":"modified","additions":162,"deletions":146,"changes":308,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/ParseException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/ParseException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/ParseException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"cdde6be334969e90183fb07aa47561f35768381c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/SimpleNode.java","status":"modified","additions":31,"deletions":27,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/SimpleNode.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/SimpleNode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/SimpleNode.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"9973de9f2a4ea99b88e31ffb359aaaacec271fda","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java","status":"modified","additions":775,"deletions":740,"changes":1515,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"0337de9e881621e75757c8a6656b693c756d2074","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","status":"modified","additions":339,"deletions":311,"changes":650,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"248f214bbb1c9bedc74517b5c7e2e441ecb775fd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataFactory.java","status":"modified","additions":110,"deletions":106,"changes":216,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataFactory.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"8f522818eaea3d82715d899be7d3c169f8026dfd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","status":"modified","additions":2199,"deletions":2084,"changes":4283,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ea163c06b512ac1fcc3222f59de9915bb7816f24","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/DelegatingMetaDataFactory.java","status":"modified","additions":117,"deletions":113,"changes":230,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/DelegatingMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/DelegatingMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/DelegatingMetaDataFactory.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"21e6ddffe9f0816de4e4579d289a9500cdbb02dd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/Extensions.java","status":"modified","additions":460,"deletions":437,"changes":897,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Extensions.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Extensions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Extensions.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"1f9281887f13c6990ea5fd3807520fa51f396312","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","status":"modified","additions":206,"deletions":189,"changes":395,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"c36de9e3ced8ea36167dee8ae0f3671c5b8dd085","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","status":"modified","additions":1856,"deletions":1762,"changes":3618,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a5748e522c0e1e56f81e979459ae4711bf56e144","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryRelatedFieldOrder.java","status":"modified","additions":76,"deletions":70,"changes":146,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryRelatedFieldOrder.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryRelatedFieldOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryRelatedFieldOrder.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"8813a55eea64b0d151ef96c7f70cd29c38fd3c0a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryValueOrder.java","status":"modified","additions":110,"deletions":101,"changes":211,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryValueOrder.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryValueOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryValueOrder.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"d615a156489c08d60435fa052fb2473793beb7cf","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java","status":"modified","additions":79,"deletions":73,"changes":152,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"467466e4ae7bac3d860edb4df2b54ddde43b01cc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/JavaTypes.java","status":"modified","additions":425,"deletions":411,"changes":836,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/JavaTypes.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/JavaTypes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/JavaTypes.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"dc7a24d8d0282a6c4f52a30711f8e8d76f788849","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/LifecycleMetaData.java","status":"modified","additions":253,"deletions":238,"changes":491,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/LifecycleMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/LifecycleMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/LifecycleMetaData.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"9ff72f403907820b84ff77d35e5a5f58b9b41aae","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataContext.java","status":"modified","additions":29,"deletions":26,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataContext.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataContext.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataContext.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"7c5e09ff8f4182df4d135645907f4fd92a6aae01","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataDefaults.java","status":"modified","additions":64,"deletions":60,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataDefaults.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"e155e9e9f59bcbccec74e2763c824de97f425ab9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataFactory.java","status":"modified","additions":138,"deletions":134,"changes":272,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataFactory.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ff8683558d6535fe7f74f9311d3ceb5258426b5f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataInheritanceComparator.java","status":"modified","additions":31,"deletions":27,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataInheritanceComparator.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataInheritanceComparator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataInheritanceComparator.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"34f1ad22c88222b66f185c106f8850927113c0f3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataModes.java","status":"modified","additions":32,"deletions":29,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataModes.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataModes.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"34119ff07280cadd63bd7152c9b923460d838655","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","status":"modified","additions":1610,"deletions":1501,"changes":3111,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"}]}

