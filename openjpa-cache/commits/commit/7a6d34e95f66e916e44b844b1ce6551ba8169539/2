{"sha":"7a6d34e95f66e916e44b844b1ce6551ba8169539","node_id":"MDY6Q29tbWl0MjA2MzY0OjdhNmQzNGU5NWY2NmU5MTZlNDRiODQ0YjFjZTY1NTFiYTgxNjk1Mzk=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-12T01:06:30Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-12T01:06:30Z"},"message":"re-applied conversion from SolarMetric code formatting.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@421062 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5ec8e1f7fce68f4452491ebdc47aa9bd6b5cebcd","url":"https://api.github.com/repos/apache/openjpa/git/trees/5ec8e1f7fce68f4452491ebdc47aa9bd6b5cebcd"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/7a6d34e95f66e916e44b844b1ce6551ba8169539","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/7a6d34e95f66e916e44b844b1ce6551ba8169539","html_url":"https://github.com/apache/openjpa/commit/7a6d34e95f66e916e44b844b1ce6551ba8169539","comments_url":"https://api.github.com/repos/apache/openjpa/commits/7a6d34e95f66e916e44b844b1ce6551ba8169539/comments","author":null,"committer":null,"parents":[{"sha":"b9636bb8786de3ffbc3c897f4fe5f38e979c9df7","url":"https://api.github.com/repos/apache/openjpa/commits/b9636bb8786de3ffbc3c897f4fe5f38e979c9df7","html_url":"https://github.com/apache/openjpa/commit/b9636bb8786de3ffbc3c897f4fe5f38e979c9df7"}],"stats":{"total":190652,"additions":98492,"deletions":92160},"files":[{"sha":"a2e71ed83479a49348afb95314006b7ec9d17e4b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataTool.java","status":"modified","additions":351,"deletions":325,"changes":676,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataTool.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataTool.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,325 +1,351 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.meta;\r\n-\r\n-import java.io.File;\r\n-import java.io.IOException;\r\n-import java.io.PrintWriter;\r\n-import java.io.Writer;\r\n-import java.util.HashMap;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\r\n-import org.apache.openjpa.lib.conf.Configurations;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.meta.ClassArgParser;\r\n-import org.apache.openjpa.lib.util.Files;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.Options;\r\n-import org.apache.openjpa.util.MetaDataException;\r\n-\r\n-/**\r\n- * Tool for generating default metadata.\r\n- *\r\n- * @author Abe White\r\n- * @since 3.0\r\n- */\r\n-public class MetaDataTool implements MetaDataModes {\r\n-\r\n-    public static final String ACTION_ADD = \"add\";\r\n-    public static final String ACTION_DROP = \"drop\";\r\n-    public static final String[] ACTIONS = new String[]{\r\n-        ACTION_ADD, ACTION_DROP, };\r\n-    private static Localizer _loc = Localizer.forPackage(MetaDataTool.class);\r\n-    private final OpenJPAConfiguration _conf;\r\n-    private final String _action;\r\n-    private final Set _drop;\r\n-    private MetaDataRepository _repos = null;\r\n-    private File _file = null;\r\n-    private Writer _writer = null;\r\n-    private boolean _flush = false;\r\n-\r\n-    /**\r\n-     * Constructor. Supply configuration and action.\r\n-     */\r\n-    public MetaDataTool(OpenJPAConfiguration conf, String action) {\r\n-        _conf = conf;\r\n-        _action = (action == null) ? ACTION_ADD : action;\r\n-        if (ACTION_DROP.equals(_action))\r\n-            _drop = new HashSet();\r\n-        else _drop = null;\r\n-    }\r\n-\r\n-    /**\r\n-     * The action supplied on construction.\r\n-     */\r\n-    public String getAction() {\r\n-        return _action;\r\n-    }\r\n-\r\n-    /**\r\n-     * The file to generate metadata to.\r\n-     */\r\n-    public File getFile() {\r\n-        return _file;\r\n-    }\r\n-\r\n-    /**\r\n-     * The file to generate metadata to.\r\n-     */\r\n-    public void setFile(File file) {\r\n-        _file = file;\r\n-    }\r\n-\r\n-    /**\r\n-     * The writer to generate metadata to.\r\n-     */\r\n-    public Writer getWriter() {\r\n-        return _writer;\r\n-    }\r\n-\r\n-    /**\r\n-     * The writer to generate metadata to.\r\n-     */\r\n-    public void setWriter(Writer writer) {\r\n-        _writer = writer;\r\n-    }\r\n-\r\n-    /**\r\n-     * The repository to use to hold metadata.\r\n-     */\r\n-    public MetaDataRepository getRepository() {\r\n-        if (_repos == null) {\r\n-            _repos = newRepository();\r\n-            _repos.setResolve(MODE_MAPPING, false);\r\n-            MetaDataFactory factory = _repos.getMetaDataFactory();\r\n-            factory.getDefaults().setIgnoreNonPersistent(false);\r\n-            factory.setStoreMode(MetaDataFactory.STORE_VERBOSE);\r\n-        }\r\n-        return _repos;\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new metadata repository.\r\n-     */\r\n-    protected MetaDataRepository newRepository() {\r\n-        return new MetaDataRepository(_conf);\r\n-    }\r\n-\r\n-    /**\r\n-     * The repository to use to hold metadata.\r\n-     */\r\n-    public void setRepository(MetaDataRepository repos) {\r\n-        _repos = repos;\r\n-    }\r\n-\r\n-    /**\r\n-     * Reset state. This is called automatically after every {@link #record}.\r\n-     */\r\n-    public void clear() {\r\n-        _repos = null;\r\n-        if (_drop != null)\r\n-            _drop.clear();\r\n-        _flush = false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Generate new metadata for the given class.\r\n-     */\r\n-    public void run(Class cls) {\r\n-        if (cls == null)\r\n-            return;\r\n-        if (ACTION_DROP.equals(_action))\r\n-            _drop.add(cls);\r\n-        else if (ACTION_ADD.equals(_action))\r\n-            add(cls);\r\n-        else throw new IllegalArgumentException(\"action == \" + _action);\r\n-    }\r\n-\r\n-    private void add(Class cls) {\r\n-        // assume all user-defined types are PCs\r\n-        ClassMetaData meta = getRepository().addMetaData(cls);\r\n-        FieldMetaData[] fmds = meta.getDeclaredFields();\r\n-        for (int i = 0; i < fmds.length; i++) {\r\n-            if (fmds[i].getDeclaredTypeCode() == JavaTypes.OBJECT\r\n-                && fmds[i].getDeclaredType() != Object.class)\r\n-                fmds[i].setDeclaredTypeCode(JavaTypes.PC);\r\n-        }\r\n-        meta.setSource(_file, meta.getSourceType());\r\n-        _flush = true;\r\n-    }\r\n-\r\n-    /**\r\n-     * Record metadata changes.\r\n-     */\r\n-    public void record() {\r\n-        MetaDataRepository repos = getRepository();\r\n-        MetaDataFactory mdf = repos.getMetaDataFactory();\r\n-        try {\r\n-            if (_drop != null && !_drop.isEmpty()\r\n-                && !mdf.drop((Class[]) _drop.toArray(new Class[_drop.size()]),\r\n-                MODE_META | MODE_MAPPING | MODE_QUERY, null)) {\r\n-                Log log = _conf.getLog(OpenJPAConfiguration.LOG_METADATA);\r\n-                if (log.isWarnEnabled())\r\n-                    log.warn(_loc.get(\"bad-drop\", _drop));\r\n-            }\r\n-            if (!_flush)\r\n-                return;\r\n-            ClassMetaData[] metas = repos.getMetaDatas();\r\n-            Map output = null;\r\n-            // if we're outputting to stream, set all metas to same file so\r\n-            // they get placed in single string\r\n-            if (_writer != null) {\r\n-                output = new HashMap();\r\n-                File tmp = new File(\"openjpatmp\");\r\n-                for (int i = 0; i < metas.length; i++)\r\n-                    metas[i].setSource(tmp, metas[i].getSourceType());\r\n-            }\r\n-            if (!mdf.store(metas, new QueryMetaData[0],\r\n-                new SequenceMetaData[0], MODE_META, output))\r\n-                throw new MetaDataException(_loc.get(\"bad-store\"));\r\n-            if (_writer != null) {\r\n-                PrintWriter out = new PrintWriter(_writer);\r\n-                for (Iterator itr = output.values().iterator();\r\n-                    itr.hasNext();)\r\n-                    out.println((String) itr.next());\r\n-                out.flush();\r\n-            }\r\n-        }\r\n-        finally {\r\n-            clear();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Usage: java org.apache.openjpa.meta.MetaDataTool [option]*\r\n-     * [-action/-a &lt;add | drop&gt;]\r\n-     * &lt;class name | .java file | .class file&gt;+\r\n-     * Where the following options are recognized.\r\n-     * <ul>\r\n-     * <li><i>-properties/-p &lt;properties file or resource&gt;</i>: The path\r\n-     * or resource name of a OpenJPA properties file containing information\r\n-     * such as the license key data as outlined in\r\n-     * {@link OpenJPAConfiguration}. Optional.</li>\r\n-     * <li><i>-&lt;property name&gt; &lt;property value&gt;</i>: All bean\r\n-     * properties of the OpenJPA {@link OpenJPAConfiguration} can be set by\r\n-     * using their names and supplying a value. For example:\r\n-     * <code>-licenseKey adslfja83r3lkadf</code></li>\r\n-     * <li><i>-file/-f &lt;stdout | output file or resource&gt;</i>: The path\r\n-     * or resource name of a file the metadata should be generated to.\r\n-     * If the given file already contains metadata, the generated\r\n-     * metadata will be merged into the existing document.</li>\r\n-     * </ul>\r\n-     * The available actions are:\r\n-     * <ul>\r\n-     * <li><i>add</i>: Generate default metadata for the given classes. This\r\n-     * is the default action.</li>\r\n-     * <li><i>drop</i>: Remove existing metadata for the given classes.</li>\r\n-     * </ul>\r\n-     */\r\n-    public static void main(String[] args) throws IOException {\r\n-        Options opts = new Options();\r\n-        args = opts.setFromCmdLine(args);\r\n-        OpenJPAConfiguration conf = new OpenJPAConfigurationImpl();\r\n-        try {\r\n-            if (!run(conf, args, opts))\r\n-                System.err.println(_loc.get(\"tool-usage\"));\r\n-        }\r\n-        finally {\r\n-            conf.close();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Run the tool. Returns false if any invalid options were given.\r\n-     */\r\n-    public static boolean run(OpenJPAConfiguration conf, String[] args,\r\n-        Options opts) throws IOException {\r\n-        if (args.length == 0 || opts.containsKey(\"help\")\r\n-            || opts.containsKey(\"-help\"))\r\n-            return false;\r\n-        Flags flags = new Flags();\r\n-        flags.action = opts.removeProperty(\"action\", \"a\", flags.action);\r\n-        String fileName = opts.removeProperty(\"file\", \"f\", null);\r\n-        if (\"stdout\".equals(fileName)) {\r\n-            flags.writer = new PrintWriter(System.out);\r\n-            fileName = null;\r\n-        } else if (\"stderr\".equals(fileName)) {\r\n-            flags.writer = new PrintWriter(System.err);\r\n-            fileName = null;\r\n-        }\r\n-        Configurations.populateConfiguration(conf, opts);\r\n-        ClassLoader loader = conf.getClassResolverInstance().\r\n-            getClassLoader(MetaDataTool.class, null);\r\n-        if (fileName != null)\r\n-            flags.file = Files.getFile(fileName, loader);\r\n-        return run(conf, args, flags, null, loader);\r\n-    }\r\n-\r\n-    /**\r\n-     * Run the tool. Return false if invalid options were given. The given\r\n-     * repository may be null.\r\n-     */\r\n-    public static boolean run(OpenJPAConfiguration conf, String[] args,\r\n-        Flags flags, MetaDataRepository repos, ClassLoader loader)\r\n-        throws IOException {\r\n-        if (args.length == 0)\r\n-            return false;\r\n-        if (flags.action == null)\r\n-            flags.action = ACTION_ADD;\r\n-        MetaDataTool tool = new MetaDataTool(conf, flags.action);\r\n-        if (repos != null) {\r\n-            MetaDataFactory factory = repos.getMetaDataFactory();\r\n-            factory.getDefaults().setIgnoreNonPersistent(false);\r\n-            factory.setStoreMode(MetaDataFactory.STORE_VERBOSE);\r\n-            tool.setRepository(repos);\r\n-        }\r\n-        if (flags.file != null)\r\n-            tool.setFile(flags.file);\r\n-        if (flags.writer != null)\r\n-            tool.setWriter(flags.writer);\r\n-        Log log = conf.getLog(OpenJPAConfiguration.LOG_TOOL);\r\n-        ClassArgParser cap = conf.getMetaDataRepository().\r\n-            getMetaDataFactory().newClassArgParser();\r\n-        cap.setClassLoader(loader);\r\n-        Class[] classes;\r\n-        for (int i = 0; i < args.length; i++) {\r\n-            classes = cap.parseTypes(args[i]);\r\n-            for (int j = 0; j < classes.length; j++) {\r\n-                log.info(_loc.get(\"tool-running\", classes[j], flags.action));\r\n-                try {\r\n-                    tool.run(classes[j]);\r\n-                } catch (IllegalArgumentException iae) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        log.info(_loc.get(\"tool-record\"));\r\n-        tool.record();\r\n-        return true;\r\n-    }\r\n-\r\n-    /**\r\n-     * Run flags.\r\n-     */\r\n-    public static class Flags {\r\n-\r\n-        public String action = ACTION_ADD;\r\n-        public File file = null;\r\n-        public Writer writer = null;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.meta.ClassArgParser;\n+import org.apache.openjpa.lib.util.Files;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Options;\n+import org.apache.openjpa.util.MetaDataException;\n+\n+/**\n+ * <p>Tool for generating default metadata.</p>\n+ *\n+ * @since 3.0\n+ * @author Abe White\n+ */\n+public class MetaDataTool\n+    implements MetaDataModes {\n+\n+    public static final String ACTION_ADD = \"add\";\n+    public static final String ACTION_DROP = \"drop\";\n+\n+    public static final String[] ACTIONS = new String[]{\n+        ACTION_ADD,\n+        ACTION_DROP,\n+    };\n+\n+    private static Localizer _loc = Localizer.forPackage(MetaDataTool.class);\n+\n+    private final OpenJPAConfiguration _conf;\n+    private final String _action;\n+\n+    private final Set _drop;\n+    private MetaDataRepository _repos = null;\n+    private File _file = null;\n+    private Writer _writer = null;\n+    private boolean _flush = false;\n+\n+    /**\n+     * Constructor.  Supply configuration and action.\n+     */\n+    public MetaDataTool(OpenJPAConfiguration conf, String action) {\n+        _conf = conf;\n+        _action = (action == null) ? ACTION_ADD : action;\n+\n+        if (ACTION_DROP.equals(_action))\n+            _drop = new HashSet();\n+        else\n+            _drop = null;\n+    }\n+\n+    /**\n+     * The action supplied on construction.\n+     */\n+    public String getAction() {\n+        return _action;\n+    }\n+\n+    /**\n+     * The file to generate metadata to.\n+     */\n+    public File getFile() {\n+        return _file;\n+    }\n+\n+    /**\n+     * The file to generate metadata to.\n+     */\n+    public void setFile(File file) {\n+        _file = file;\n+    }\n+\n+    /**\n+     * The writer to generate metadata to.\n+     */\n+    public Writer getWriter() {\n+        return _writer;\n+    }\n+\n+    /**\n+     * The writer to generate metadata to.\n+     */\n+    public void setWriter(Writer writer) {\n+        _writer = writer;\n+    }\n+\n+    /**\n+     * The repository to use to hold metadata.\n+     */\n+    public MetaDataRepository getRepository() {\n+        if (_repos == null) {\n+            _repos = newRepository();\n+            _repos.setResolve(MODE_MAPPING, false);\n+            MetaDataFactory factory = _repos.getMetaDataFactory();\n+            factory.getDefaults().setIgnoreNonPersistent(false);\n+            factory.setStoreMode(MetaDataFactory.STORE_VERBOSE);\n+        }\n+        return _repos;\n+    }\n+\n+    /**\n+     * Create a new metadata repository.\n+     */\n+    protected MetaDataRepository newRepository() {\n+        return new MetaDataRepository(_conf);\n+    }\n+\n+    /**\n+     * The repository to use to hold metadata.\n+     */\n+    public void setRepository(MetaDataRepository repos) {\n+        _repos = repos;\n+    }\n+\n+    /**\n+     * Reset state.  This is called automatically after every {@link #record}.\n+     */\n+    public void clear() {\n+        _repos = null;\n+        if (_drop != null)\n+            _drop.clear();\n+        _flush = false;\n+    }\n+\n+    /**\n+     * Generate new metadata for the given class.\n+     */\n+    public void run(Class cls) {\n+        if (cls == null)\n+            return;\n+        if (ACTION_DROP.equals(_action))\n+            _drop.add(cls);\n+        else if (ACTION_ADD.equals(_action))\n+            add(cls);\n+        else\n+            throw new IllegalArgumentException(\"action == \" + _action);\n+    }\n+\n+    private void add(Class cls) {\n+        // assume all user-defined types are PCs\n+        ClassMetaData meta = getRepository().addMetaData(cls);\n+        FieldMetaData[] fmds = meta.getDeclaredFields();\n+        for (int i = 0; i < fmds.length; i++) {\n+            if (fmds[i].getDeclaredTypeCode() == JavaTypes.OBJECT\n+                && fmds[i].getDeclaredType() != Object.class)\n+                fmds[i].setDeclaredTypeCode(JavaTypes.PC);\n+        }\n+        meta.setSource(_file, meta.getSourceType());\n+        _flush = true;\n+    }\n+\n+    /**\n+     * Record metadata changes.\n+     */\n+    public void record() {\n+        MetaDataRepository repos = getRepository();\n+        MetaDataFactory mdf = repos.getMetaDataFactory();\n+        try {\n+            if (_drop != null && !_drop.isEmpty()\n+                && !mdf.drop((Class[]) _drop.toArray(new Class[_drop.size()]),\n+                MODE_META | MODE_MAPPING | MODE_QUERY, null)) {\n+                Log log = _conf.getLog(OpenJPAConfiguration.LOG_METADATA);\n+                if (log.isWarnEnabled())\n+                    log.warn(_loc.get(\"bad-drop\", _drop));\n+            }\n+            if (!_flush)\n+                return;\n+\n+            ClassMetaData[] metas = repos.getMetaDatas();\n+            Map output = null;\n+\n+            // if we're outputting to stream, set all metas to same file so\n+            // they get placed in single string\n+            if (_writer != null) {\n+                output = new HashMap();\n+                File tmp = new File(\"openjpatmp\");\n+                for (int i = 0; i < metas.length; i++)\n+                    metas[i].setSource(tmp, metas[i].getSourceType());\n+            }\n+            if (!mdf.store(metas, new QueryMetaData[0],\n+                new SequenceMetaData[0], MODE_META, output))\n+                throw new MetaDataException(_loc.get(\"bad-store\"));\n+            if (_writer != null) {\n+                PrintWriter out = new PrintWriter(_writer);\n+                for (Iterator itr = output.values().iterator();\n+                    itr.hasNext();)\n+                    out.println((String) itr.next());\n+                out.flush();\n+            }\n+        }\n+        finally {\n+            clear();\n+        }\n+    }\n+\n+    /**\n+     * <p>Usage: java org.apache.openjpa.meta.MetaDataTool [option]*\n+     * [-action/-a &lt;add | drop&gt;]\n+     * &lt;class name | .java file | .class file&gt;+</p>\n+     * <p/>\n+     * <p>Where the following options are recognized.\n+     * <ul>\n+     * <li><i>-properties/-p &lt;properties file or resource&gt;</i>: The path\n+     * or resource name of a OpenJPA properties file containing information\n+     * such as the license key\tdata as outlined in\n+     * {@link OpenJPAConfiguration}.  Optional.</li>\n+     * <li><i>-&lt;property name&gt; &lt;property value&gt;</i>: All bean\n+     * properties of the OpenJPA {@link OpenJPAConfiguration} can be set by\n+     * using their\tnames and supplying a value.  For example:\n+     * <code>-licenseKey adslfja83r3lkadf</code></li>\n+     * <li><i>-file/-f &lt;stdout | output file or resource&gt;</i>: The path\n+     * or resource name of a file the metadata should be generated to.\n+     * If the given file already contains metadata, the generated\n+     * metadata will be merged into the existing document.</li>\n+     * </ul></p>\n+     * <p/>\n+     * <p>The available actions are:\n+     * <ul>\n+     * <li><i>add</i>: Generate default metadata for the given classes.  This\n+     * is the default action.</li>\n+     * <li><i>drop</i>: Remove existing metadata for the given classes.</li>\n+     * </ul></p>\n+     */\n+    public static void main(String[] args)\n+        throws IOException {\n+        Options opts = new Options();\n+        args = opts.setFromCmdLine(args);\n+        OpenJPAConfiguration conf = new OpenJPAConfigurationImpl();\n+        try {\n+            if (!run(conf, args, opts))\n+                System.err.println(_loc.get(\"tool-usage\"));\n+        }\n+        finally {\n+            conf.close();\n+        }\n+    }\n+\n+    /**\n+     * Run the tool.  Returns false if any invalid options were given.\n+     */\n+    public static boolean run(OpenJPAConfiguration conf, String[] args,\n+        Options opts)\n+        throws IOException {\n+        if (args.length == 0 || opts.containsKey(\"help\")\n+            || opts.containsKey(\"-help\"))\n+            return false;\n+\n+        Flags flags = new Flags();\n+        flags.action = opts.removeProperty(\"action\", \"a\", flags.action);\n+        String fileName = opts.removeProperty(\"file\", \"f\", null);\n+        if (\"stdout\".equals(fileName)) {\n+            flags.writer = new PrintWriter(System.out);\n+            fileName = null;\n+        } else if (\"stderr\".equals(fileName)) {\n+            flags.writer = new PrintWriter(System.err);\n+            fileName = null;\n+        }\n+\n+        Configurations.populateConfiguration(conf, opts);\n+        ClassLoader loader = conf.getClassResolverInstance().\n+            getClassLoader(MetaDataTool.class, null);\n+\n+        if (fileName != null)\n+            flags.file = Files.getFile(fileName, loader);\n+        return run(conf, args, flags, null, loader);\n+    }\n+\n+    /**\n+     * Run the tool.  Return false if invalid options were given.  The given\n+     * repository may be null.\n+     */\n+    public static boolean run(OpenJPAConfiguration conf, String[] args,\n+        Flags flags, MetaDataRepository repos, ClassLoader loader)\n+        throws IOException {\n+        if (args.length == 0)\n+            return false;\n+        if (flags.action == null)\n+            flags.action = ACTION_ADD;\n+\n+        MetaDataTool tool = new MetaDataTool(conf, flags.action);\n+        if (repos != null) {\n+            MetaDataFactory factory = repos.getMetaDataFactory();\n+            factory.getDefaults().setIgnoreNonPersistent(false);\n+            factory.setStoreMode(MetaDataFactory.STORE_VERBOSE);\n+            tool.setRepository(repos);\n+        }\n+        if (flags.file != null)\n+            tool.setFile(flags.file);\n+        if (flags.writer != null)\n+            tool.setWriter(flags.writer);\n+\n+        Log log = conf.getLog(OpenJPAConfiguration.LOG_TOOL);\n+        ClassArgParser cap = conf.getMetaDataRepository().\n+            getMetaDataFactory().newClassArgParser();\n+        cap.setClassLoader(loader);\n+        Class[] classes;\n+        for (int i = 0; i < args.length; i++) {\n+            classes = cap.parseTypes(args[i]);\n+            for (int j = 0; j < classes.length; j++) {\n+                log.info(_loc.get(\"tool-running\", classes[j], flags.action));\n+                try {\n+                    tool.run(classes[j]);\n+                }\n+                catch (IllegalArgumentException iae) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        log.info(_loc.get(\"tool-record\"));\n+        tool.record();\n+        return true;\n+    }\n+\n+    /**\n+     *\tRun flags.\n+     */\n+    public static class Flags {\n+\n+        public String action = ACTION_ADD;\n+        public File file = null;\n+\t\tpublic Writer writer = null;\n+\t}\n+}"},{"sha":"87ace9b7f132cad4d4451bacfe111a7346855052","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/NoneMetaDataFactory.java","status":"modified","additions":113,"deletions":109,"changes":222,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NoneMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NoneMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NoneMetaDataFactory.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,109 +1,113 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.meta;\r\n-\r\n-import java.io.File;\r\n-import java.lang.reflect.Member;\r\n-import java.util.Collection;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.lib.meta.ClassArgParser;\r\n-\r\n-/**\r\n- * No-op metadata I/O to prevent attempts to load other classes.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class NoneMetaDataFactory implements MetaDataFactory, MetaDataDefaults {\r\n-\r\n-    private static final NoneMetaDataFactory _instance =\r\n-        new NoneMetaDataFactory();\r\n-\r\n-    public static NoneMetaDataFactory getInstance() {\r\n-        return _instance;\r\n-    }\r\n-\r\n-    public void setRepository(MetaDataRepository repos) {\r\n-    }\r\n-\r\n-    public void setStoreDirectory(File dir) {\r\n-    }\r\n-\r\n-    public void setStoreMode(int store) {\r\n-    }\r\n-\r\n-    public void setStrict(boolean strict) {\r\n-    }\r\n-\r\n-    public void load(Class cls, int mode, ClassLoader envLoader) {\r\n-    }\r\n-\r\n-    public boolean store(ClassMetaData[] metas, QueryMetaData[] queries,\r\n-        SequenceMetaData[] seqs, int mode, Map output) {\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean drop(Class[] cls, int mode, ClassLoader envLoader) {\r\n-        return false;\r\n-    }\r\n-\r\n-    public MetaDataDefaults getDefaults() {\r\n-        return this;\r\n-    }\r\n-\r\n-    public Set getPersistentTypeNames(boolean classpath,\r\n-        ClassLoader envLoader) {\r\n-        return null;\r\n-    }\r\n-\r\n-    public Class getQueryScope(String queryName, ClassLoader loader) {\r\n-        return null;\r\n-    }\r\n-\r\n-    public ClassArgParser newClassArgParser() {\r\n-        return new ClassArgParser();\r\n-    }\r\n-\r\n-    public void clear() {\r\n-    }\r\n-\r\n-    public void addClassExtensionKeys(Collection exts) {\r\n-    }\r\n-\r\n-    public void addFieldExtensionKeys(Collection exts) {\r\n-    }\r\n-\r\n-    public int getDefaultAccessType() {\r\n-        return ClassMetaData.ACCESS_UNKNOWN;\r\n-    }\r\n-\r\n-    public int getCallbackMode() {\r\n-        return CALLBACK_IGNORE;\r\n-    }\r\n-\r\n-    public boolean getCallbacksBeforeListeners(int type) {\r\n-        return false;\r\n-    }\r\n-\r\n-    public void setIgnoreNonPersistent(boolean ignore) {\r\n-    }\r\n-\r\n-    public void populate(ClassMetaData meta, int access) {\r\n-    }\r\n-\r\n-    public Member getBackingMember(FieldMetaData fmd) {\r\n-        return null;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.File;\n+import java.lang.reflect.Member;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.openjpa.lib.meta.ClassArgParser;\n+\n+/**\n+ * </p>No-op metadata I/O to prevent attempts to load other classes.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class NoneMetaDataFactory\n+    implements MetaDataFactory, MetaDataDefaults {\n+\n+    private static final NoneMetaDataFactory _instance =\n+        new NoneMetaDataFactory();\n+\n+    public static NoneMetaDataFactory getInstance() {\n+        return _instance;\n+    }\n+\n+    public void setRepository(MetaDataRepository repos) {\n+    }\n+\n+    public void setStoreDirectory(File dir) {\n+    }\n+\n+    public void setStoreMode(int store) {\n+    }\n+\n+    public void setStrict(boolean strict) {\n+    }\n+\n+    public void load(Class cls, int mode, ClassLoader envLoader) {\n+    }\n+\n+    public boolean store(ClassMetaData[] metas, QueryMetaData[] queries,\n+        SequenceMetaData[] seqs, int mode, Map output) {\n+        return false;\n+    }\n+\n+    public boolean drop(Class[] cls, int mode, ClassLoader envLoader) {\n+        return false;\n+    }\n+\n+    public MetaDataDefaults getDefaults() {\n+        return this;\n+    }\n+\n+    public Set getPersistentTypeNames(boolean classpath,\n+        ClassLoader envLoader) {\n+        return null;\n+    }\n+\n+    public Class getQueryScope(String queryName, ClassLoader loader) {\n+        return null;\n+    }\n+\n+    public ClassArgParser newClassArgParser() {\n+        return new ClassArgParser();\n+    }\n+\n+    public void clear() {\n+    }\n+\n+    public void addClassExtensionKeys(Collection exts) {\n+    }\n+\n+    public void addFieldExtensionKeys(Collection exts) {\n+    }\n+\n+    public int getDefaultAccessType() {\n+        return ClassMetaData.ACCESS_UNKNOWN;\n+    }\n+\n+    public int getCallbackMode() {\n+        return CALLBACK_IGNORE;\n+    }\n+\n+    public boolean getCallbacksBeforeListeners(int type) {\n+        return false;\n+    }\n+\n+    public void setIgnoreNonPersistent(boolean ignore) {\n+    }\n+\n+    public void populate(ClassMetaData meta, int access) {\n+    }\n+\n+    public Member getBackingMember(FieldMetaData fmd) {\n+        return null;\n+    }\n+}"},{"sha":"f4946670bea756a5b0033c37a100d572b82669cc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/Order.java","status":"modified","additions":47,"deletions":44,"changes":91,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Order.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Order.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Order.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,44 +1,47 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.meta;\r\n-\r\n-import java.util.Comparator;\r\n-\r\n-/**\r\n- * Order a field.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public interface Order {\r\n-\r\n-    /**\r\n-     * Token denoting to order by the element value.\r\n-     */\r\n-    public static final String ELEMENT = \"#element\";\r\n-\r\n-    /**\r\n-     * Return the name of the orderable.\r\n-     */\r\n-    public String getName();\r\n-\r\n-    /**\r\n-     * Order direction.\r\n-     */\r\n-    public boolean isAscending();\r\n-\r\n-    /**\r\n-     * Return a comparator for ordering by this element, or null if\r\n-     * the ordering is done in the datastore.\r\n-     */\r\n-    public Comparator getComparator();\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.util.Comparator;\n+\n+/**\n+ * <p>Order a field.</p>\n+ *\n+ * @author Abe White\n+ */\n+public interface Order {\n+\n+    /**\n+     * Token denoting to order by the element value.\n+     */\n+    public static final String ELEMENT = \"#element\";\n+\n+    /**\n+     * Return the name of the orderable.\n+     */\n+    public String getName();\n+\n+    /**\n+     * Order direction.\n+     */\n+    public boolean isAscending();\n+\n+    /**\n+     *\tReturn a comparator for ordering by this element, or null if\n+     *\tthe ordering is done in the datastore.\n+     */\n+    public Comparator getComparator ();\n+}"},{"sha":"7ae926b96d8936883038797198ac660b2918a09e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ProxySetupStateManager.java","status":"modified","additions":277,"deletions":270,"changes":547,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ProxySetupStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ProxySetupStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ProxySetupStateManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,270 +1,277 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.meta;\r\n-\r\n-import java.io.ObjectOutput;\r\n-import java.util.Calendar;\r\n-import java.util.SortedMap;\r\n-import java.util.SortedSet;\r\n-\r\n-import org.apache.openjpa.enhance.PersistenceCapable;\r\n-import org.apache.openjpa.enhance.StateManager;\r\n-import org.apache.openjpa.util.InternalException;\r\n-\r\n-/**\r\n- * Mostly-unimplemented state manager type whose sole purpose is to\r\n- * check the initial value of all SCO container fields for their initialized\r\n- * types and comparators.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-class ProxySetupStateManager implements StateManager {\r\n-\r\n-    private Object _object = null;\r\n-\r\n-    public void setProxyData(PersistenceCapable pc, ClassMetaData meta) {\r\n-        FieldMetaData[] fmds = meta.getFields();\r\n-        for (int i = 0; i < fmds.length; i++) {\r\n-            if (fmds[i].getDefiningMetaData() != meta)\r\n-                continue;\r\n-            switch (fmds[i].getDeclaredTypeCode()) {\r\n-                case JavaTypes.CALENDAR:\r\n-                    pc.pcProvideField(fmds[i].getIndex());\r\n-                    if (_object != null) {\r\n-                        // specified timezone\r\n-                        fmds[i]\r\n-                            .setInitializer(((Calendar) _object).getTimeZone());\r\n-                    }\r\n-                    break;\r\n-                case JavaTypes.COLLECTION:\r\n-                    pc.pcProvideField(fmds[i].getIndex());\r\n-                    if (_object != null) {\r\n-                        // more specific type?\r\n-                        if (_object.getClass() != fmds[i].getDeclaredType())\r\n-                            fmds[i].setProxyType(_object.getClass());\r\n-                        // custom comparator?\r\n-                        if (_object instanceof SortedSet)\r\n-                            fmds[i].setInitializer(((SortedSet) _object).\r\n-                                comparator());\r\n-                    }\r\n-                    break;\r\n-                case JavaTypes.MAP:\r\n-                    pc.pcProvideField(fmds[i].getIndex());\r\n-                    if (_object != null) {\r\n-                        // more specific type?\r\n-                        if (_object.getClass() != fmds[i].getDeclaredType())\r\n-                            fmds[i].setProxyType(_object.getClass());\r\n-                        // custom comparator?\r\n-                        if (_object instanceof SortedMap)\r\n-                            fmds[i].setInitializer(((SortedMap) _object).\r\n-                                comparator());\r\n-                    }\r\n-                    break;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public byte replaceFlags() {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public StateManager replaceStateManager(StateManager sm) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public boolean isDirty() {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public boolean isTransactional() {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public boolean isPersistent() {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public boolean isNew() {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public boolean isDeleted() {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public boolean isDetached() {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public Object getGenericContext() {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void dirty(String s) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public Object fetchObjectId() {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public Object getVersion() {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void accessingField(int i) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public boolean serializing() {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public boolean writeDetached(ObjectOutput out) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void proxyDetachedDeserialized(int idx) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void settingBooleanField(PersistenceCapable pc, int i, boolean b,\r\n-        boolean b2, int set) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void settingCharField(PersistenceCapable pc, int i, char c, char c2,\r\n-        int set) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void settingByteField(PersistenceCapable pc, int i, byte b, byte b2,\r\n-        int set) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void settingShortField(PersistenceCapable pc, int i, short s,\r\n-        short s2, int set) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void settingIntField(PersistenceCapable pc, int i, int i2, int i3,\r\n-        int set) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void settingLongField(PersistenceCapable pc, int i, long l, long l2,\r\n-        int set) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void settingFloatField(PersistenceCapable pc, int i, float f,\r\n-        float f2, int set) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void settingDoubleField(PersistenceCapable pc, int i, double d,\r\n-        double d2, int set) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void settingStringField(PersistenceCapable pc, int i, String s,\r\n-        String s2, int set) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void settingObjectField(PersistenceCapable pc, int i, Object o,\r\n-        Object o2, int set) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void providedBooleanField(PersistenceCapable pc, int i, boolean b) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void providedCharField(PersistenceCapable pc, int i, char c) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void providedByteField(PersistenceCapable pc, int i, byte b) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void providedShortField(PersistenceCapable pc, int i, short s) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void providedIntField(PersistenceCapable pc, int i, int i2) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void providedLongField(PersistenceCapable pc, int i, long l) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void providedFloatField(PersistenceCapable pc, int i, float f) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void providedDoubleField(PersistenceCapable pc, int i, double d) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void providedStringField(PersistenceCapable pc, int i, String s) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void providedObjectField(PersistenceCapable pc, int i, Object o) {\r\n-        _object = o;\r\n-    }\r\n-\r\n-    public boolean replaceBooleanField(PersistenceCapable pc, int i) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public char replaceCharField(PersistenceCapable pc, int i) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public byte replaceByteField(PersistenceCapable pc, int i) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public short replaceShortField(PersistenceCapable pc, int i) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public int replaceIntField(PersistenceCapable pc, int i) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public long replaceLongField(PersistenceCapable pc, int i) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public float replaceFloatField(PersistenceCapable pc, int i) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public double replaceDoubleField(PersistenceCapable pc, int i) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public String replaceStringField(PersistenceCapable pc, int i) {\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public Object replaceObjectField(PersistenceCapable pc, int i) {\r\n-        throw new InternalException();\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.ObjectOutput;\n+import java.util.Calendar;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.enhance.StateManager;\n+import org.apache.openjpa.util.InternalException;\n+\n+/**\n+ * <p>Mostly-unimplemented state manager type whose sole purpose is to\n+ * check the initial value of all SCO container fields for their initialized\n+ * types and comparators.</p>\n+ *\n+ * @author Abe White\n+ */\n+class ProxySetupStateManager\n+    implements StateManager {\n+\n+    private Object _object = null;\n+\n+    public void setProxyData(PersistenceCapable pc, ClassMetaData meta) {\n+        FieldMetaData[] fmds = meta.getFields();\n+        for (int i = 0; i < fmds.length; i++) {\n+            if (fmds[i].getDefiningMetaData() != meta)\n+                continue;\n+\n+            switch (fmds[i].getDeclaredTypeCode()) {\n+                case JavaTypes.CALENDAR:\n+                    pc.pcProvideField(fmds[i].getIndex());\n+                    if (_object != null) {\n+                        // specified timezone\n+                        fmds[i]\n+                            .setInitializer(((Calendar) _object).getTimeZone());\n+                    }\n+                    break;\n+                case JavaTypes.COLLECTION:\n+                    pc.pcProvideField(fmds[i].getIndex());\n+                    if (_object != null) {\n+                        // more specific type?\n+                        if (_object.getClass() != fmds[i].getDeclaredType())\n+                            fmds[i].setProxyType(_object.getClass());\n+\n+                        // custom comparator?\n+                        if (_object instanceof SortedSet)\n+                            fmds[i].setInitializer(((SortedSet) _object).\n+                                comparator());\n+                    }\n+                    break;\n+                case JavaTypes.MAP:\n+                    pc.pcProvideField(fmds[i].getIndex());\n+                    if (_object != null) {\n+                        // more specific type?\n+                        if (_object.getClass() != fmds[i].getDeclaredType())\n+                            fmds[i].setProxyType(_object.getClass());\n+\n+                        // custom comparator?\n+                        if (_object instanceof SortedMap)\n+                            fmds[i].setInitializer(((SortedMap) _object).\n+                                comparator());\n+                    }\n+                    break;\n+            }\n+        }\n+    }\n+\n+    public byte replaceFlags() {\n+        throw new InternalException();\n+    }\n+\n+    public StateManager replaceStateManager(StateManager sm) {\n+        throw new InternalException();\n+    }\n+\n+    public boolean isDirty() {\n+        throw new InternalException();\n+    }\n+\n+    public boolean isTransactional() {\n+        throw new InternalException();\n+    }\n+\n+    public boolean isPersistent() {\n+        throw new InternalException();\n+    }\n+\n+    public boolean isNew() {\n+        throw new InternalException();\n+    }\n+\n+    public boolean isDeleted() {\n+        throw new InternalException();\n+    }\n+\n+    public boolean isDetached() {\n+        throw new InternalException();\n+    }\n+\n+    public Object getGenericContext() {\n+        throw new InternalException();\n+    }\n+\n+    public void dirty(String s) {\n+        throw new InternalException();\n+    }\n+\n+    public Object fetchObjectId() {\n+        throw new InternalException();\n+    }\n+\n+    public Object getVersion() {\n+        throw new InternalException();\n+    }\n+\n+    public void accessingField(int i) {\n+        throw new InternalException();\n+    }\n+\n+    public boolean serializing() {\n+        throw new InternalException();\n+    }\n+\n+    public boolean writeDetached(ObjectOutput out) {\n+        throw new InternalException();\n+    }\n+\n+    public void proxyDetachedDeserialized(int idx) {\n+        throw new InternalException();\n+    }\n+\n+    public void settingBooleanField(PersistenceCapable pc, int i, boolean b,\n+        boolean b2, int set) {\n+        throw new InternalException();\n+    }\n+\n+    public void settingCharField(PersistenceCapable pc, int i, char c, char c2,\n+        int set) {\n+        throw new InternalException();\n+    }\n+\n+    public void settingByteField(PersistenceCapable pc, int i, byte b, byte b2,\n+        int set) {\n+        throw new InternalException();\n+    }\n+\n+    public void settingShortField(PersistenceCapable pc, int i, short s,\n+        short s2, int set) {\n+        throw new InternalException();\n+    }\n+\n+    public void settingIntField(PersistenceCapable pc, int i, int i2, int i3,\n+        int set) {\n+        throw new InternalException();\n+    }\n+\n+    public void settingLongField(PersistenceCapable pc, int i, long l, long l2,\n+        int set) {\n+        throw new InternalException();\n+    }\n+\n+    public void settingFloatField(PersistenceCapable pc, int i, float f,\n+        float f2, int set) {\n+        throw new InternalException();\n+    }\n+\n+    public void settingDoubleField(PersistenceCapable pc, int i, double d,\n+        double d2, int set) {\n+        throw new InternalException();\n+    }\n+\n+    public void settingStringField(PersistenceCapable pc, int i, String s,\n+        String s2, int set) {\n+        throw new InternalException();\n+    }\n+\n+    public void settingObjectField(PersistenceCapable pc, int i, Object o,\n+        Object o2, int set) {\n+        throw new InternalException();\n+    }\n+\n+    public void providedBooleanField(PersistenceCapable pc, int i, boolean b) {\n+        throw new InternalException();\n+    }\n+\n+    public void providedCharField(PersistenceCapable pc, int i, char c) {\n+        throw new InternalException();\n+    }\n+\n+    public void providedByteField(PersistenceCapable pc, int i, byte b) {\n+        throw new InternalException();\n+    }\n+\n+    public void providedShortField(PersistenceCapable pc, int i, short s) {\n+        throw new InternalException();\n+    }\n+\n+    public void providedIntField(PersistenceCapable pc, int i, int i2) {\n+        throw new InternalException();\n+    }\n+\n+    public void providedLongField(PersistenceCapable pc, int i, long l) {\n+        throw new InternalException();\n+    }\n+\n+    public void providedFloatField(PersistenceCapable pc, int i, float f) {\n+        throw new InternalException();\n+    }\n+\n+    public void providedDoubleField(PersistenceCapable pc, int i, double d) {\n+        throw new InternalException();\n+    }\n+\n+    public void providedStringField(PersistenceCapable pc, int i, String s) {\n+        throw new InternalException();\n+    }\n+\n+    public void providedObjectField(PersistenceCapable pc, int i, Object o) {\n+        _object = o;\n+    }\n+\n+    public boolean replaceBooleanField(PersistenceCapable pc, int i) {\n+        throw new InternalException();\n+    }\n+\n+    public char replaceCharField(PersistenceCapable pc, int i) {\n+        throw new InternalException();\n+    }\n+\n+    public byte replaceByteField(PersistenceCapable pc, int i) {\n+        throw new InternalException();\n+    }\n+\n+    public short replaceShortField(PersistenceCapable pc, int i) {\n+        throw new InternalException();\n+    }\n+\n+    public int replaceIntField(PersistenceCapable pc, int i) {\n+        throw new InternalException();\n+    }\n+\n+    public long replaceLongField(PersistenceCapable pc, int i) {\n+        throw new InternalException();\n+    }\n+\n+    public float replaceFloatField(PersistenceCapable pc, int i) {\n+        throw new InternalException();\n+    }\n+\n+    public double replaceDoubleField(PersistenceCapable pc, int i) {\n+        throw new InternalException();\n+    }\n+\n+    public String replaceStringField(PersistenceCapable pc, int i) {\n+        throw new InternalException();\n+    }\n+\n+    public Object replaceObjectField(PersistenceCapable pc, int i) {\n+        throw new InternalException();\n+    }\n+}"},{"sha":"4e1cd36aa2c56279fc36362dde04ec3725efddc6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/QueryMetaData.java","status":"modified","additions":263,"deletions":256,"changes":519,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/QueryMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/QueryMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/QueryMetaData.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,256 +1,263 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.meta;\r\n-\r\n-import java.io.File;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-\r\n-import org.apache.openjpa.kernel.Query;\r\n-import org.apache.openjpa.lib.meta.SourceTracker;\r\n-import org.apache.openjpa.lib.xml.Commentable;\r\n-\r\n-/**\r\n- * Holds metadata about named queries.\r\n- * Information stored in this instance gets transfered to\r\n- * new {@link Query} instances.\r\n- *\r\n- * @author Steve Kim\r\n- */\r\n-public class QueryMetaData\r\n-    implements MetaDataModes, SourceTracker, Commentable {\r\n-\r\n-    private static final String[] EMPTY_KEYS = new String[0];\r\n-    private static final Object[] EMPTY_VALS = new Object[0];\r\n-    private final String _name;\r\n-    private Boolean _readOnly;\r\n-    private File _file;\r\n-    private Object _scope;\r\n-    private int _srcType;\r\n-    private int _mode = MODE_QUERY;\r\n-    private String _language;\r\n-    private Class _class;\r\n-    private Class _candidate;\r\n-    private Class _res;\r\n-    private String _query;\r\n-    private String[] _comments;\r\n-    private List _hintKeys;\r\n-    private List _hintVals;\r\n-\r\n-    /**\r\n-     * Construct with the given name.\r\n-     */\r\n-    protected QueryMetaData(String name) {\r\n-        _name = name;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the name for this query.\r\n-     */\r\n-    public String getName() {\r\n-        return _name;\r\n-    }\r\n-\r\n-    /**\r\n-     * The class that defines this query, or null if none.\r\n-     */\r\n-    public Class getDefiningType() {\r\n-        return _class;\r\n-    }\r\n-\r\n-    /**\r\n-     * The class that defines this query, or null if none.\r\n-     */\r\n-    public void setDefiningType(Class cls) {\r\n-        _class = cls;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether the query has been marked read-only.\r\n-     */\r\n-    public boolean isReadOnly() {\r\n-        return _readOnly != null && _readOnly.booleanValue();\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether the query has been marked read-only.\r\n-     */\r\n-    public void setReadOnly(boolean readOnly) {\r\n-        _readOnly = (readOnly) ? Boolean.TRUE : Boolean.FALSE;\r\n-    }\r\n-\r\n-    /**\r\n-     * The query candidate class, or null if none.\r\n-     */\r\n-    public Class getCandidateType() {\r\n-        return _candidate;\r\n-    }\r\n-\r\n-    /**\r\n-     * The query result class, or null if none.\r\n-     */\r\n-    public void setCandidateType(Class cls) {\r\n-        _candidate = cls;\r\n-    }\r\n-\r\n-    /**\r\n-     * The query result class, or null if none.\r\n-     */\r\n-    public Class getResultType() {\r\n-        return _res;\r\n-    }\r\n-\r\n-    /**\r\n-     * The query result class, or null if none.\r\n-     */\r\n-    public void setResultType(Class cls) {\r\n-        _res = cls;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the query language.\r\n-     */\r\n-    public String getLanguage() {\r\n-        return _language;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set the language for this query.\r\n-     */\r\n-    public void setLanguage(String language) {\r\n-        _language = language;\r\n-    }\r\n-\r\n-    /**\r\n-     * The full query string, or null if none.\r\n-     */\r\n-    public String getQueryString() {\r\n-        return _query;\r\n-    }\r\n-\r\n-    /**\r\n-     * The full query string, or null if none.\r\n-     */\r\n-    public void setQueryString(String query) {\r\n-        _query = query;\r\n-    }\r\n-\r\n-    /**\r\n-     * Query hints.\r\n-     */\r\n-    public String[] getHintKeys() {\r\n-        return (_hintKeys == null) ? EMPTY_KEYS\r\n-            : (String[]) _hintKeys.toArray(new String[_hintKeys.size()]);\r\n-    }\r\n-\r\n-    /**\r\n-     * Query hints.\r\n-     */\r\n-    public Object[] getHintValues() {\r\n-        return (_hintVals == null) ? EMPTY_VALS : _hintVals.toArray();\r\n-    }\r\n-\r\n-    /**\r\n-     * Add a query hint.\r\n-     */\r\n-    public void addHint(String key, Object value) {\r\n-        if (_hintKeys == null) {\r\n-            _hintKeys = new LinkedList();\r\n-            _hintVals = new LinkedList();\r\n-        }\r\n-        _hintKeys.add(key);\r\n-        _hintVals.add(value);\r\n-    }\r\n-\r\n-    /**\r\n-     * Set query template information into the given concrete\r\n-     * query instance. However, the language, query string, and\r\n-     * candidate class are assumed to be declared in the query\r\n-     * instantiation, and hints are not transferred.\r\n-     */\r\n-    public void setInto(Query query) {\r\n-        if (_candidate != null)\r\n-            query.setCandidateType(_candidate, true);\r\n-        if (_query != null && _query.length() > 0)\r\n-            query.setQuery(_query);\r\n-        if (_res != null)\r\n-            query.setResultType(_res);\r\n-        if (_readOnly != null)\r\n-            query.setReadOnly(_readOnly.booleanValue());\r\n-    }\r\n-\r\n-    /**\r\n-     * Initialize this instance from the values held in the\r\n-     * specified {@link Query}.\r\n-     */\r\n-    public void setFrom(Query query) {\r\n-        _language = query.getLanguage();\r\n-        _candidate = query.getCandidateType();\r\n-        _res = query.getResultType();\r\n-        _query = query.getQueryString();\r\n-    }\r\n-\r\n-    /**\r\n-     * The source mode of this query.\r\n-     */\r\n-    public int getSourceMode() {\r\n-        return _mode;\r\n-    }\r\n-\r\n-    /**\r\n-     * The source mode of this query.\r\n-     */\r\n-    public void setSourceMode(int mode) {\r\n-        _mode = mode;\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return _name;\r\n-    }\r\n-\r\n-    ///////////////\r\n-    // Commentable\r\n-    ///////////////\r\n-    public String[] getComments() {\r\n-        return (_comments == null) ? EMPTY_COMMENTS : _comments;\r\n-    }\r\n-\r\n-    public void setComments(String[] comments) {\r\n-        _comments = comments;\r\n-    }\r\n-\r\n-    ////////////////////////////////\r\n-    // SourceTracker implementation\r\n-    ////////////////////////////////\r\n-    public File getSourceFile() {\r\n-        return _file;\r\n-    }\r\n-\r\n-    public Object getSourceScope() {\r\n-        return _scope;\r\n-    }\r\n-\r\n-    public int getSourceType() {\r\n-        return _srcType;\r\n-    }\r\n-\r\n-    public void setSource(File file, Object scope, int srcType) {\r\n-        _file = file;\r\n-        _scope = scope;\r\n-        _srcType = srcType;\r\n-    }\r\n-\r\n-    public String getResourceName() {\r\n-        return (_class == null) ? _name : _class.getName() + \":\" + _name;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.File;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.openjpa.kernel.Query;\n+import org.apache.openjpa.lib.meta.SourceTracker;\n+import org.apache.openjpa.lib.xml.Commentable;\n+\n+/**\n+ * <p>Holds metadata about named queries.</p>\n+ * <p/>\n+ * <p>Information stored in this instance gets transfered to\n+ * new {@link Query} instances.</p>\n+ *\n+ * @author Steve Kim\n+ */\n+public class QueryMetaData\n+    implements MetaDataModes, SourceTracker, Commentable {\n+\n+    private static final String[] EMPTY_KEYS = new String[0];\n+    private static final Object[] EMPTY_VALS = new Object[0];\n+\n+    private final String _name;\n+    private Boolean _readOnly;\n+    private File _file;\n+    private Object _scope;\n+    private int _srcType;\n+    private int _mode = MODE_QUERY;\n+    private String _language;\n+    private Class _class;\n+    private Class _candidate;\n+    private Class _res;\n+    private String _query;\n+    private String[] _comments;\n+    private List _hintKeys;\n+    private List _hintVals;\n+\n+    /**\n+     * Construct with the given name.\n+     */\n+    protected QueryMetaData(String name) {\n+        _name = name;\n+    }\n+\n+    /**\n+     * Return the name for this query.\n+     */\n+    public String getName() {\n+        return _name;\n+    }\n+\n+    /**\n+     * The class that defines this query, or null if none.\n+     */\n+    public Class getDefiningType() {\n+        return _class;\n+    }\n+\n+    /**\n+     * The class that defines this query, or null if none.\n+     */\n+    public void setDefiningType(Class cls) {\n+        _class = cls;\n+    }\n+\n+    /**\n+     * Whether the query has been marked read-only.\n+     */\n+    public boolean isReadOnly() {\n+        return _readOnly != null && _readOnly.booleanValue();\n+    }\n+\n+    /**\n+     * Whether the query has been marked read-only.\n+     */\n+    public void setReadOnly(boolean readOnly) {\n+        _readOnly = (readOnly) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * The query candidate class, or null if none.\n+     */\n+    public Class getCandidateType() {\n+        return _candidate;\n+    }\n+\n+    /**\n+     * The query result class, or null if none.\n+     */\n+    public void setCandidateType(Class cls) {\n+        _candidate = cls;\n+    }\n+\n+    /**\n+     * The query result class, or null if none.\n+     */\n+    public Class getResultType() {\n+        return _res;\n+    }\n+\n+    /**\n+     * The query result class, or null if none.\n+     */\n+    public void setResultType(Class cls) {\n+        _res = cls;\n+    }\n+\n+    /**\n+     * Return the query language.\n+     */\n+    public String getLanguage() {\n+        return _language;\n+    }\n+\n+    /**\n+     * Set the language for this query.\n+     */\n+    public void setLanguage(String language) {\n+        _language = language;\n+    }\n+\n+    /**\n+     * The full query string, or null if none.\n+     */\n+    public String getQueryString() {\n+        return _query;\n+    }\n+\n+    /**\n+     * The full query string, or null if none.\n+     */\n+    public void setQueryString(String query) {\n+        _query = query;\n+    }\n+\n+    /**\n+     * Query hints.\n+     */\n+    public String[] getHintKeys() {\n+        return (_hintKeys == null) ? EMPTY_KEYS\n+            : (String[]) _hintKeys.toArray(new String[_hintKeys.size()]);\n+    }\n+\n+    /**\n+     * Query hints.\n+     */\n+    public Object[] getHintValues() {\n+        return (_hintVals == null) ? EMPTY_VALS : _hintVals.toArray();\n+    }\n+\n+    /**\n+     * Add a query hint.\n+     */\n+    public void addHint(String key, Object value) {\n+        if (_hintKeys == null) {\n+            _hintKeys = new LinkedList();\n+            _hintVals = new LinkedList();\n+        }\n+        _hintKeys.add(key);\n+        _hintVals.add(value);\n+    }\n+\n+    /**\n+     * Set query template information into the given concrete\n+     * query instance.  However, the language, query string, and\n+     * candidate class are assumed to be declared in the query\n+     * instantiation, and hints are not transferred.\n+     */\n+    public void setInto(Query query) {\n+        if (_candidate != null)\n+            query.setCandidateType(_candidate, true);\n+        if (_query != null && _query.length() > 0)\n+            query.setQuery(_query);\n+        if (_res != null)\n+            query.setResultType(_res);\n+        if (_readOnly != null)\n+            query.setReadOnly(_readOnly.booleanValue());\n+    }\n+\n+    /**\n+     * Initialize this instance from the values held in the\n+     * specified {@link Query}.\n+     */\n+    public void setFrom(Query query) {\n+        _language = query.getLanguage();\n+        _candidate = query.getCandidateType();\n+        _res = query.getResultType();\n+        _query = query.getQueryString();\n+    }\n+\n+    /**\n+     * The source mode of this query.\n+     */\n+    public int getSourceMode() {\n+        return _mode;\n+    }\n+\n+    /**\n+     * The source mode of this query.\n+     */\n+    public void setSourceMode(int mode) {\n+        _mode = mode;\n+    }\n+\n+    public String toString() {\n+        return _name;\n+    }\n+\n+    ///////////////\n+    // Commentable\n+    ///////////////\n+\n+    public String[] getComments() {\n+        return (_comments == null) ? EMPTY_COMMENTS : _comments;\n+    }\n+\n+    public void setComments(String[] comments) {\n+        _comments = comments;\n+    }\n+\n+    ////////////////////////////////\n+    // SourceTracker implementation\n+    ////////////////////////////////\n+\n+    public File getSourceFile() {\n+        return _file;\n+    }\n+\n+    public Object getSourceScope() {\n+        return _scope;\n+    }\n+\n+    public int getSourceType() {\n+        return _srcType;\n+    }\n+\n+    public void setSource(File file, Object scope, int srcType) {\n+        _file = file;\n+        _scope = scope;\n+        _srcType = srcType;\n+    }\n+\n+    public String getResourceName() {\n+        return (_class == null) ? _name : _class.getName () + \":\" + _name;\n+\t}\n+}"},{"sha":"38528af7afffa870d41427580802e8a406dd72dd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/SequenceMetaData.java","status":"modified","additions":360,"deletions":344,"changes":704,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/SequenceMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/SequenceMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/SequenceMetaData.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,344 +1,360 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.meta;\r\n-\r\n-import java.io.File;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.conf.SeqValue;\r\n-import org.apache.openjpa.kernel.Seq;\r\n-import org.apache.openjpa.lib.conf.Configurations;\r\n-import org.apache.openjpa.lib.conf.PluginValue;\r\n-import org.apache.openjpa.lib.meta.SourceTracker;\r\n-import org.apache.openjpa.lib.util.Closeable;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.xml.Commentable;\r\n-import org.apache.openjpa.util.MetaDataException;\r\n-import org.apache.openjpa.util.OpenJPAException;\r\n-\r\n-/**\r\n- * Metadata about a named sequence.\r\n- *\r\n- * @author Abe White\r\n- * @since 4.0\r\n- */\r\n-public class SequenceMetaData\r\n-    implements SourceTracker, MetaDataContext, Closeable, Commentable {\r\n-\r\n-    /**\r\n-     * Sequence name that means to use the system default sequence.\r\n-     */\r\n-    public static final String NAME_SYSTEM = \"system\";\r\n-\r\n-    /**\r\n-     * Default plugin alias name; every back end should have some 'native'\r\n-     * sequence implementation.\r\n-     */\r\n-    public static final String IMPL_NATIVE = \"native\";\r\n-\r\n-    /**\r\n-     * Time-based sequence values.\r\n-     */\r\n-    public static final String IMPL_TIME = \"time\";\r\n-    // plugin property names for standard props\r\n-    private static final String PROP_SEQUENCE = \"Sequence\";\r\n-    private static final String PROP_INITIAL_VALUE = \"InitialValue\";\r\n-    private static final String PROP_ALLOCATE = \"Allocate\";\r\n-    private static final String PROP_INCREMENT = \"Increment\";\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (SequenceMetaData.class);\r\n-    private final MetaDataRepository _repos;\r\n-    private final String _name;\r\n-    private int _type = Seq.TYPE_DEFAULT;\r\n-    private String _plugin = IMPL_NATIVE;\r\n-    private SequenceFactory _factory = null;\r\n-    private File _source = null;\r\n-    private Object _scope = null;\r\n-    private int _srcType = SRC_OTHER;\r\n-    private String[] _comments = null;\r\n-    private String _sequence = null;\r\n-    private int _increment = -1;\r\n-    private int _allocate = -1;\r\n-    private int _initial = -1;\r\n-    // instantiated lazily\r\n-    private Seq _instance = null;\r\n-\r\n-    /**\r\n-     * Constructor; supply sequence name.\r\n-     */\r\n-    public SequenceMetaData(String name, MetaDataRepository repos) {\r\n-        _name = name;\r\n-        _repos = repos;\r\n-    }\r\n-\r\n-    /**\r\n-     * The owning repository.\r\n-     */\r\n-    public MetaDataRepository getRepository() {\r\n-        return _repos;\r\n-    }\r\n-\r\n-    /**\r\n-     * The sequence name.\r\n-     */\r\n-    public String getName() {\r\n-        return _name;\r\n-    }\r\n-\r\n-    public File getSourceFile() {\r\n-        return _source;\r\n-    }\r\n-\r\n-    public Object getSourceScope() {\r\n-        return _scope;\r\n-    }\r\n-\r\n-    public int getSourceType() {\r\n-        return _srcType;\r\n-    }\r\n-\r\n-    public void setSource(File file, Object scope, int srcType) {\r\n-        _source = file;\r\n-        _scope = scope;\r\n-        _srcType = srcType;\r\n-    }\r\n-\r\n-    public String getResourceName() {\r\n-        return _name;\r\n-    }\r\n-\r\n-    /**\r\n-     * The sequence type.\r\n-     */\r\n-    public int getType() {\r\n-        return _type;\r\n-    }\r\n-\r\n-    /**\r\n-     * The sequence type.\r\n-     */\r\n-    public void setType(int type) {\r\n-        _type = type;\r\n-    }\r\n-\r\n-    /**\r\n-     * Native sequence name.\r\n-     */\r\n-    public String getSequence() {\r\n-        return _sequence;\r\n-    }\r\n-\r\n-    /**\r\n-     * Native sequence name.\r\n-     */\r\n-    public void setSequence(String sequence) {\r\n-        _sequence = sequence;\r\n-    }\r\n-\r\n-    /**\r\n-     * Sequence increment, or -1 for default.\r\n-     */\r\n-    public int getIncrement() {\r\n-        return _increment;\r\n-    }\r\n-\r\n-    /**\r\n-     * Sequence increment, or -1 for default.\r\n-     */\r\n-    public void setIncrement(int increment) {\r\n-        _increment = increment;\r\n-    }\r\n-\r\n-    /**\r\n-     * Sequence values to allocate, or -1 for default.\r\n-     */\r\n-    public int getAllocate() {\r\n-        return _allocate;\r\n-    }\r\n-\r\n-    /**\r\n-     * Sequence values to allocate, or -1 for default.\r\n-     */\r\n-    public void setAllocate(int allocate) {\r\n-        _allocate = allocate;\r\n-    }\r\n-\r\n-    /**\r\n-     * Initial sequence value, or -1 for default.\r\n-     */\r\n-    public int getInitialValue() {\r\n-        return _initial;\r\n-    }\r\n-\r\n-    /**\r\n-     * Initial sequence value, or -1 for default.\r\n-     */\r\n-    public void setInitialValue(int initial) {\r\n-        _initial = initial;\r\n-    }\r\n-\r\n-    /**\r\n-     * Plugin string describing the {@link Seq}.\r\n-     */\r\n-    public String getSequencePlugin() {\r\n-        return _plugin;\r\n-    }\r\n-\r\n-    /**\r\n-     * Plugin string describing the {@link Seq}.\r\n-     */\r\n-    public void setSequencePlugin(String plugin) {\r\n-        _plugin = plugin;\r\n-    }\r\n-\r\n-    /**\r\n-     * A factory to transform spec sequences produced by user factories into\r\n-     * the OpenJPA sequence type.\r\n-     */\r\n-    public SequenceFactory getSequenceFactory() {\r\n-        return _factory;\r\n-    }\r\n-\r\n-    /**\r\n-     * A factory to transform spec sequences produced by user factories into\r\n-     * the OpenJPA sequence type.\r\n-     */\r\n-    public void setSequenceFactory(SequenceFactory factory) {\r\n-        _factory = factory;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the initialized sequence instance.\r\n-     */\r\n-    public synchronized Seq getInstance(ClassLoader envLoader) {\r\n-        if (_instance == null)\r\n-            _instance = instantiate(envLoader);\r\n-        return _instance;\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new uninitialized instance of this sequence.\r\n-     */\r\n-    protected Seq instantiate(ClassLoader envLoader) {\r\n-        if (NAME_SYSTEM.equals(_name))\r\n-            return _repos.getConfiguration().getSequenceInstance();\r\n-        try {\r\n-            PluginValue plugin = newPluginValue(\"sequence-plugin\");\r\n-            plugin.setString(_plugin);\r\n-            String clsName = plugin.getClassName();\r\n-            Class cls =\r\n-                Class.forName(clsName, true, Seq.class.getClassLoader());\r\n-            StringBuffer props = new StringBuffer();\r\n-            if (plugin.getProperties() != null)\r\n-                props.append(plugin.getProperties());\r\n-            addStandardProperties(props);\r\n-            // allow user-class specification of either our sequence\r\n-            // interface or a factory class\r\n-            Seq seq;\r\n-            if (Seq.class.isAssignableFrom(cls)) {\r\n-                seq = (Seq) cls.newInstance();\r\n-                Configurations.configureInstance(seq,\r\n-                    _repos.getConfiguration(), props.toString());\r\n-                seq.setType(_type);\r\n-            } else if (_factory != null)\r\n-                seq = _factory.toSequence(cls, props.toString());\r\n-            else throw new MetaDataException(_loc.get(\"not-seq-cls\", _name,\r\n-                cls));\r\n-            return seq;\r\n-        } catch (OpenJPAException ke) {\r\n-            throw ke;\r\n-        } catch (Exception e) {\r\n-            throw new MetaDataException(_loc.get(\"cant-init-seq\", _name)).\r\n-                setCause(e);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new plugin value for sequences. Returns a standard\r\n-     * {@link SeqValue} by default.\r\n-     */\r\n-    protected PluginValue newPluginValue(String property) {\r\n-        return new SeqValue(property);\r\n-    }\r\n-\r\n-    /**\r\n-     * Add standard properties to the given properties buffer.\r\n-     */\r\n-    protected void addStandardProperties(StringBuffer props) {\r\n-        appendProperty(props, PROP_SEQUENCE, _sequence);\r\n-        appendProperty(props, PROP_INITIAL_VALUE, _initial);\r\n-        appendProperty(props, PROP_ALLOCATE, _allocate);\r\n-        appendProperty(props, PROP_INCREMENT, _increment);\r\n-    }\r\n-\r\n-    /**\r\n-     * Add a string property to the buffer. Nothing will be added if value\r\n-     * is null or empty string.\r\n-     */\r\n-    protected void appendProperty(StringBuffer props, String name, String val) {\r\n-        if (StringUtils.isEmpty(val))\r\n-            return;\r\n-        if (props.length() > 0)\r\n-            props.append(\",\");\r\n-        props.append(name).append(\"=\").append(val);\r\n-    }\r\n-\r\n-    /**\r\n-     * Add an int property to the buffer. Nothing will be added if value is -1.\r\n-     */\r\n-    protected void appendProperty(StringBuffer props, String name, int val) {\r\n-        if (val == -1)\r\n-            return;\r\n-        if (props.length() > 0)\r\n-            props.append(\",\");\r\n-        props.append(name).append(\"=\").append(val);\r\n-    }\r\n-\r\n-    /**\r\n-     * Close user sequence instance.\r\n-     */\r\n-    public void close() {\r\n-        if (_instance != null && !NAME_SYSTEM.equals(_name))\r\n-            try {\r\n-                _instance.close();\r\n-            } catch (Exception e) {\r\n-            }\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return _name;\r\n-    }\r\n-\r\n-    ///////////////\r\n-    // Commentable\r\n-    ///////////////\r\n-    public String[] getComments() {\r\n-        return (_comments == null) ? EMPTY_COMMENTS : _comments;\r\n-    }\r\n-\r\n-    public void setComments(String[] comments) {\r\n-        _comments = comments;\r\n-    }\r\n-\r\n-    /**\r\n-     * Allow facades to supply adapters from a spec sequence type to the\r\n-     * OpenJPA sequence type.\r\n-     */\r\n-    public static interface SequenceFactory {\r\n-\r\n-        /**\r\n-         * Transform the given class named in metadata into a sequence.\r\n-         */\r\n-        public Seq toSequence(Class cls, String props) throws Exception;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.File;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.conf.SeqValue;\n+import org.apache.openjpa.kernel.Seq;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.lib.meta.SourceTracker;\n+import org.apache.openjpa.lib.util.Closeable;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.xml.Commentable;\n+import org.apache.openjpa.util.MetaDataException;\n+import org.apache.openjpa.util.OpenJPAException;\n+\n+/**\n+ * <p>Metadata about a named sequence.</p>\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+public class SequenceMetaData\n+    implements SourceTracker, MetaDataContext, Closeable, Commentable {\n+\n+    /**\n+     * Sequence name that means to use the system default sequence.\n+     */\n+    public static final String NAME_SYSTEM = \"system\";\n+\n+    /**\n+     * Default plugin alias name; every back end should have some 'native'\n+     * sequence implementation.\n+     */\n+    public static final String IMPL_NATIVE = \"native\";\n+\n+    /**\n+     * Time-based sequence values.\n+     */\n+    public static final String IMPL_TIME = \"time\";\n+\n+    // plugin property names for standard props\n+    private static final String PROP_SEQUENCE = \"Sequence\";\n+    private static final String PROP_INITIAL_VALUE = \"InitialValue\";\n+    private static final String PROP_ALLOCATE = \"Allocate\";\n+    private static final String PROP_INCREMENT = \"Increment\";\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (SequenceMetaData.class);\n+\n+    private final MetaDataRepository _repos;\n+    private final String _name;\n+    private int _type = Seq.TYPE_DEFAULT;\n+    private String _plugin = IMPL_NATIVE;\n+    private SequenceFactory _factory = null;\n+    private File _source = null;\n+    private Object _scope = null;\n+    private int _srcType = SRC_OTHER;\n+    private String[] _comments = null;\n+    private String _sequence = null;\n+    private int _increment = -1;\n+    private int _allocate = -1;\n+    private int _initial = -1;\n+\n+    // instantiated lazily\n+    private Seq _instance = null;\n+\n+    /**\n+     * Constructor; supply sequence name.\n+     */\n+    public SequenceMetaData(String name, MetaDataRepository repos) {\n+        _name = name;\n+        _repos = repos;\n+    }\n+\n+    /**\n+     * The owning repository.\n+     */\n+    public MetaDataRepository getRepository() {\n+        return _repos;\n+    }\n+\n+    /**\n+     * The sequence name.\n+     */\n+    public String getName() {\n+        return _name;\n+    }\n+\n+    public File getSourceFile() {\n+        return _source;\n+    }\n+\n+    public Object getSourceScope() {\n+        return _scope;\n+    }\n+\n+    public int getSourceType() {\n+        return _srcType;\n+    }\n+\n+    public void setSource(File file, Object scope, int srcType) {\n+        _source = file;\n+        _scope = scope;\n+        _srcType = srcType;\n+    }\n+\n+    public String getResourceName() {\n+        return _name;\n+    }\n+\n+    /**\n+     * The sequence type.\n+     */\n+    public int getType() {\n+        return _type;\n+    }\n+\n+    /**\n+     * The sequence type.\n+     */\n+    public void setType(int type) {\n+        _type = type;\n+    }\n+\n+    /**\n+     * Native sequence name.\n+     */\n+    public String getSequence() {\n+        return _sequence;\n+    }\n+\n+    /**\n+     * Native sequence name.\n+     */\n+    public void setSequence(String sequence) {\n+        _sequence = sequence;\n+    }\n+\n+    /**\n+     * Sequence increment, or -1 for default.\n+     */\n+    public int getIncrement() {\n+        return _increment;\n+    }\n+\n+    /**\n+     * Sequence increment, or -1 for default.\n+     */\n+    public void setIncrement(int increment) {\n+        _increment = increment;\n+    }\n+\n+    /**\n+     * Sequence values to allocate, or -1 for default.\n+     */\n+    public int getAllocate() {\n+        return _allocate;\n+    }\n+\n+    /**\n+     * Sequence values to allocate, or -1 for default.\n+     */\n+    public void setAllocate(int allocate) {\n+        _allocate = allocate;\n+    }\n+\n+    /**\n+     * Initial sequence value, or -1 for default.\n+     */\n+    public int getInitialValue() {\n+        return _initial;\n+    }\n+\n+    /**\n+     * Initial sequence value, or -1 for default.\n+     */\n+    public void setInitialValue(int initial) {\n+        _initial = initial;\n+    }\n+\n+    /**\n+     * Plugin string describing the {@link Seq}.\n+     */\n+    public String getSequencePlugin() {\n+        return _plugin;\n+    }\n+\n+    /**\n+     * Plugin string describing the {@link Seq}.\n+     */\n+    public void setSequencePlugin(String plugin) {\n+        _plugin = plugin;\n+    }\n+\n+    /**\n+     * A factory to transform spec sequences produced by user factories into\n+     * the OpenJPA sequence type.\n+     */\n+    public SequenceFactory getSequenceFactory() {\n+        return _factory;\n+    }\n+\n+    /**\n+     * A factory to transform spec sequences produced by user factories into\n+     * the OpenJPA sequence type.\n+     */\n+    public void setSequenceFactory(SequenceFactory factory) {\n+        _factory = factory;\n+    }\n+\n+    /**\n+     * Return the initialized sequence instance.\n+     */\n+    public synchronized Seq getInstance(ClassLoader envLoader) {\n+        if (_instance == null)\n+            _instance = instantiate(envLoader);\n+        return _instance;\n+    }\n+\n+    /**\n+     * Create a new uninitialized instance of this sequence.\n+     */\n+    protected Seq instantiate(ClassLoader envLoader) {\n+        if (NAME_SYSTEM.equals(_name))\n+            return _repos.getConfiguration().getSequenceInstance();\n+\n+        try {\n+            PluginValue plugin = newPluginValue(\"sequence-plugin\");\n+            plugin.setString(_plugin);\n+            String clsName = plugin.getClassName();\n+\n+            Class cls = Class.forName(clsName, true,\n+                Seq.class.getClassLoader());\n+            StringBuffer props = new StringBuffer();\n+            if (plugin.getProperties() != null)\n+                props.append(plugin.getProperties());\n+            addStandardProperties(props);\n+\n+            // allow user-class specification of either our sequence\n+            // interface or a factory class\n+            Seq seq;\n+            if (Seq.class.isAssignableFrom(cls)) {\n+                seq = (Seq) cls.newInstance();\n+                Configurations.configureInstance(seq,\n+                    _repos.getConfiguration(), props.toString());\n+                seq.setType(_type);\n+            } else if (_factory != null)\n+                seq = _factory.toSequence(cls, props.toString());\n+            else\n+                throw new MetaDataException(_loc.get(\"not-seq-cls\", _name,\n+                    cls));\n+            return seq;\n+        }\n+        catch (OpenJPAException ke) {\n+            throw ke;\n+        }\n+        catch (Exception e) {\n+            throw new MetaDataException(_loc.get(\"cant-init-seq\", _name)).\n+                setCause(e);\n+        }\n+    }\n+\n+    /**\n+     * Create a new plugin value for sequences.  Returns a standard\n+     * {@link SeqValue} by default.\n+     */\n+    protected PluginValue newPluginValue(String property) {\n+        return new SeqValue(property);\n+    }\n+\n+    /**\n+     * Add standard properties to the given properties buffer.\n+     */\n+    protected void addStandardProperties(StringBuffer props) {\n+        appendProperty(props, PROP_SEQUENCE, _sequence);\n+        appendProperty(props, PROP_INITIAL_VALUE, _initial);\n+        appendProperty(props, PROP_ALLOCATE, _allocate);\n+        appendProperty(props, PROP_INCREMENT, _increment);\n+    }\n+\n+    /**\n+     * Add a string property to the buffer.  Nothing will be added if value\n+     * is null or empty string.\n+     */\n+    protected void appendProperty(StringBuffer props, String name, String val) {\n+        if (StringUtils.isEmpty(val))\n+            return;\n+        if (props.length() > 0)\n+            props.append(\",\");\n+        props.append(name).append(\"=\").append(val);\n+    }\n+\n+    /**\n+     * Add an int property to the buffer.  Nothing will be added if value\n+     * is -1.\n+     */\n+    protected void appendProperty(StringBuffer props, String name, int val) {\n+        if (val == -1)\n+            return;\n+        if (props.length() > 0)\n+            props.append(\",\");\n+        props.append(name).append(\"=\").append(val);\n+    }\n+\n+    /**\n+     * Close user sequence instance.\n+     */\n+    public void close() {\n+        if (_instance != null && !NAME_SYSTEM.equals(_name))\n+            try {\n+                _instance.close();\n+            } catch (Exception e) {\n+            }\n+    }\n+\n+    public String toString() {\n+        return _name;\n+    }\n+\n+    ///////////////\n+    // Commentable\n+    ///////////////\n+\n+    public String[] getComments() {\n+        return (_comments == null) ? EMPTY_COMMENTS : _comments;\n+    }\n+\n+    public void setComments(String[] comments) {\n+        _comments = comments;\n+    }\n+\n+    /**\n+     *\tAllow facades to supply adapters from a spec sequence type to the\n+     *\tOpenJPA sequence type.\n+     */\n+    public static interface SequenceFactory {\n+\n+        /**\n+         *\tTransform the given class named in metadata into a sequence.\n+         */\n+\t\tpublic Seq toSequence (Class cls, String props)\n+\t\t\tthrows Exception;\n+\t}\n+}"},{"sha":"e3d6ec50b1564198cd428283a665a9311073ed8a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/UpdateStrategies.java","status":"modified","additions":88,"deletions":82,"changes":170,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/UpdateStrategies.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/UpdateStrategies.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/UpdateStrategies.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,82 +1,88 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.meta;\r\n-\r\n-import java.util.Arrays;\r\n-import java.util.List;\r\n-\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.StringDistance;\r\n-\r\n-/**\r\n- * Strategies for persistent value updates.\r\n- *\r\n- * @author Abe White\r\n- * @since 4.0\r\n- */\r\n-public class UpdateStrategies {\r\n-\r\n-    /**\r\n-     * No update strategy.\r\n-     */\r\n-    public static final int NONE = 0;\r\n-\r\n-    /**\r\n-     * Ignore updates; field is always considered clean.\r\n-     */\r\n-    public static final int IGNORE = 1;\r\n-\r\n-    /**\r\n-     * Throw an exception on attempt to update.\r\n-     */\r\n-    public static final int RESTRICT = 2;\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (UpdateStrategies.class);\r\n-\r\n-    /**\r\n-     * Convert the given strategy to a name.\r\n-     */\r\n-    public static String getName(int strategy) {\r\n-        switch (strategy) {\r\n-            case NONE:\r\n-                return \"none\";\r\n-            case IGNORE:\r\n-                return \"ignore\";\r\n-            case RESTRICT:\r\n-                return \"restrict\";\r\n-            default:\r\n-                throw new IllegalArgumentException(String.valueOf(strategy));\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Convert the given strategy name to its constant.\r\n-     */\r\n-    public static int getCode(String val, Object context) {\r\n-        if (\"none\".equals(val))\r\n-            return NONE;\r\n-        if (\"ignore\".equals(val))\r\n-            return IGNORE;\r\n-        if (\"restrict\".equals(val))\r\n-            return RESTRICT;\r\n-        List opts = Arrays.asList(new String[]{ \"none\", \"ignore\", \"restrict\" });\r\n-        String closest = StringDistance.getClosestLevenshteinDistance(val,\r\n-            opts, .5F);\r\n-        String msg;\r\n-        if (closest != null)\r\n-            msg = _loc.get(\"bad-update-strategy-hint\", new Object[]{\r\n-                context, val, closest, opts });\r\n-        else msg = _loc.get(\"bad-update-strategy\", context, val, opts);\r\n-        throw new IllegalArgumentException(msg);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.StringDistance;\n+\n+/**\n+ * <p>Strategies for persistent value updates.</p>\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+public class UpdateStrategies {\n+\n+    /**\n+     * No update strategy.\n+     */\n+    public static final int NONE = 0;\n+\n+    /**\n+     * Ignore updates; field is always considered clean.\n+     */\n+    public static final int IGNORE = 1;\n+\n+    /**\n+     * Throw an exception on attempt to update.\n+     */\n+    public static final int RESTRICT = 2;\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (UpdateStrategies.class);\n+\n+    /**\n+     * Convert the given strategy to a name.\n+     */\n+    public static String getName(int strategy) {\n+        switch (strategy) {\n+            case NONE:\n+                return \"none\";\n+            case IGNORE:\n+                return \"ignore\";\n+            case RESTRICT:\n+                return \"restrict\";\n+            default:\n+                throw new IllegalArgumentException(String.valueOf(strategy));\n+        }\n+    }\n+\n+    /**\n+     *\tConvert the given strategy name to its constant.\n+     */\n+    public static int getCode(String val, Object context) {\n+        if (\"none\".equals(val))\n+            return NONE;\n+        if (\"ignore\".equals(val))\n+            return IGNORE;\n+        if (\"restrict\".equals(val))\n+            return RESTRICT;\n+\n+        List opts = Arrays.asList(new String[]{ \"none\", \"ignore\", \"restrict\" });\n+        String closest = StringDistance.getClosestLevenshteinDistance(val,\n+            opts, .5F);\n+        String msg;\n+        if (closest != null)\n+            msg = _loc.get(\"bad-update-strategy-hint\", new Object[]{\n+                context, val, closest, opts });\n+        else\n+            msg = _loc.get(\"bad-update-strategy\", context, val, opts);\n+        throw new IllegalArgumentException(msg);\n+\t}\n+}"},{"sha":"56d22ea27960af39d1058952f13b5461f3716dde","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaData.java","status":"modified","additions":300,"deletions":296,"changes":596,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaData.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,296 +1,300 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.meta;\r\n-\r\n-/**\r\n- * Holds metadata on a value; this could be a field value, key value, or\r\n- * element value.\r\n- *\r\n- * @author Abe White\r\n- * @since 4.0\r\n- */\r\n-public interface ValueMetaData extends MetaDataContext, MetaDataModes {\r\n-\r\n-    /**\r\n-     * The operation is not cascaded to this field.\r\n-     */\r\n-    public int CASCADE_NONE = 0;\r\n-\r\n-    /**\r\n-     * The operation is immediately cascaded to this field.\r\n-     */\r\n-    public int CASCADE_IMMEDIATE = 1;\r\n-\r\n-    /**\r\n-     * Use automatic cascade behavior. Persistence-by-reachability,\r\n-     * delete-dependent, attach-if-detached, etc.\r\n-     */\r\n-    public int CASCADE_AUTO = 2;\r\n-\r\n-    /**\r\n-     * Marker to set on {@link #setValueMappedBy} to denote that the map key\r\n-     * is mapped by the primary key field of the value.\r\n-     */\r\n-    public static final String MAPPED_BY_PK = \"`pk`\";\r\n-\r\n-    /**\r\n-     * Return the owning field for this value.\r\n-     */\r\n-    public FieldMetaData getFieldMetaData();\r\n-\r\n-    /**\r\n-     * The value class.\r\n-     */\r\n-    public Class getType();\r\n-\r\n-    /**\r\n-     * The value class.\r\n-     */\r\n-    public void setType(Class type);\r\n-\r\n-    /**\r\n-     * The type code of the value class.\r\n-     */\r\n-    public int getTypeCode();\r\n-\r\n-    /**\r\n-     * The type code of the value class.\r\n-     */\r\n-    public void setTypeCode(int code);\r\n-\r\n-    /**\r\n-     * Whether the type is a persistence capable instance.\r\n-     */\r\n-    public boolean isTypePC();\r\n-\r\n-    /**\r\n-     * The metadata for the value class, if the type is persistent.\r\n-     */\r\n-    public ClassMetaData getTypeMetaData();\r\n-\r\n-    /**\r\n-     * Return the declared class of the value. This can differ\r\n-     * from the return value of {@link #getType} if the user indicates\r\n-     * a different type or the value has an externalizer.\r\n-     */\r\n-    public Class getDeclaredType();\r\n-\r\n-    /**\r\n-     * Set the declared class of the value.\r\n-     */\r\n-    public void setDeclaredType(Class type);\r\n-\r\n-    /**\r\n-     * Return the declared type code of the value. This can differ\r\n-     * from the return value of {@link #getTypeCode} if the user indicates\r\n-     * a different type or the value has an externalizer.\r\n-     */\r\n-    public int getDeclaredTypeCode();\r\n-\r\n-    /**\r\n-     * Set the type code for the value. The type code is usually\r\n-     * computed automatically, but it can be useful to set it explicitly\r\n-     * when creating metadatas from scratch.\r\n-     */\r\n-    public void setDeclaredTypeCode(int type);\r\n-\r\n-    /**\r\n-     * Whether the type is a persistence capable instance.\r\n-     */\r\n-    public boolean isDeclaredTypePC();\r\n-\r\n-    /**\r\n-     * Return metadata for the value's class, if the type is persistent.\r\n-     */\r\n-    public ClassMetaData getDeclaredTypeMetaData();\r\n-\r\n-    /**\r\n-     * This attribute is a hint to the implementation to store this value\r\n-     * in the same structure as the class, rather than as a separate datastore\r\n-     * structure. Defaults to true if the field is not a collection or map\r\n-     * or persistence-capable object; defaults to false otherwise.\r\n-     * Implementations are permitted to ignore this attribute.\r\n-     */\r\n-    public boolean isEmbedded();\r\n-\r\n-    /**\r\n-     * This attribute is a hint to the implementation to store this value\r\n-     * in the same structure as the class, rather than as a separate datastore\r\n-     * structure. Defaults to true if the field is not a collection or map\r\n-     * or persistence-capable objects; defaults to false otherwise.\r\n-     * Implementations are permitted to ignore this attribute.\r\n-     */\r\n-    public void setEmbedded(boolean embedded);\r\n-\r\n-    /**\r\n-     * Whether this is an embedded persistence capable value.\r\n-     */\r\n-    public boolean isEmbeddedPC();\r\n-\r\n-    /**\r\n-     * The embedded class metadata for the value.\r\n-     */\r\n-    public ClassMetaData getEmbeddedMetaData();\r\n-\r\n-    /**\r\n-     * Add embedded metadata for this value.\r\n-     */\r\n-    public ClassMetaData addEmbeddedMetaData();\r\n-\r\n-    /**\r\n-     * Cascade behavior for delete operation. Only applies to\r\n-     * persistence-capable values. Options are:<br />\r\n-     * <ul>\r\n-     * <li><code>CASCADE_NONE</code>: No cascades.</li>\r\n-     * <li><code>CASCADE_IMMEDIATE</code>: Value is deleted immediately when\r\n-     * the owning object is deleted.</li>\r\n-     * <li><code>CASCADE_AUTO</code>: Value will be deleted on flush\r\n-     * if the owning object is deleted or if the value is removed from the\r\n-     * owning object, and if the value is not assigned to another relation in\r\n-     * the same transaction.</li>\r\n-     * </ul>\r\n-     */\r\n-    public int getCascadeDelete();\r\n-\r\n-    /**\r\n-     * Cascade behavior for deletion.\r\n-     *\r\n-     * @see #getCascadeDelete\r\n-     */\r\n-    public void setCascadeDelete(int cascade);\r\n-\r\n-    /**\r\n-     * Cascade behavior for persist operation. Only applies to\r\n-     * persistence-capable values. Options are:<br />\r\n-     * <ul>\r\n-     * <li><code>CASCADE_NONE</code>: No cascades. If a transient relation\r\n-     * is held at flush, an error is thrown.</li>\r\n-     * <li><code>CASCADE_IMMEDIATE</code>: Value is persisted immediately when\r\n-     * the owning object is persisted.</li>\r\n-     * <li><code>CASCADE_AUTO</code>: Value will be persisted on flush.</li>\r\n-     * </ul>\r\n-     */\r\n-    public int getCascadePersist();\r\n-\r\n-    /**\r\n-     * Cascade behavior for persist operation.\r\n-     *\r\n-     * @see #getCascadePersist\r\n-     */\r\n-    public void setCascadePersist(int cascade);\r\n-\r\n-    /**\r\n-     * Cascade behavior for attach operation. Only applies to\r\n-     * persistence-capable values. Options are:<br />\r\n-     * <ul>\r\n-     * <li><code>CASCADE_NONE</code>: No cascades of attach. Relation\r\n-     * remains detached.</li>\r\n-     * <li><code>CASCADE_IMMEDIATE</code>: Value is attached immediately.</li>\r\n-     * </ul>\r\n-     */\r\n-    public int getCascadeAttach();\r\n-\r\n-    /**\r\n-     * Cascade behavior for attach operation.\r\n-     *\r\n-     * @see #getCascadeAttach\r\n-     */\r\n-    public void setCascadeAttach(int cascade);\r\n-\r\n-    /**\r\n-     * Cascade behavior for refresh operation. Only applies to\r\n-     * persistence-capable values. Options are:<br />\r\n-     * <ul>\r\n-     * <li><code>CASCADE_NONE</code>: No cascades of refresh.</li>\r\n-     * <li><code>CASCADE_IMMEDIATE</code>: Persistent value object is also\r\n-     * refreshed.</li>\r\n-     * <li><code>CASCADE_AUTO</code>: Value will be refreshed if it is\r\n-     * in the current fetch groups.</li>\r\n-     * </ul>\r\n-     */\r\n-    public int getCascadeRefresh();\r\n-\r\n-    /**\r\n-     * Cascade behavior for refresh operation.\r\n-     *\r\n-     * @see #getCascadeRefresh\r\n-     */\r\n-    public void setCascadeRefresh(int cascade);\r\n-\r\n-    /**\r\n-     * Whether this value is serialized when stored.\r\n-     */\r\n-    public boolean isSerialized();\r\n-\r\n-    /**\r\n-     * Whether this value is serialized when stored.\r\n-     */\r\n-    public void setSerialized(boolean serialized);\r\n-\r\n-    /**\r\n-     * The field that this value shares a mapping with. Currently the only\r\n-     * supported use for a mapped-by value is when a map field key is\r\n-     * determined by a field of the persistence-capable map value.\r\n-     */\r\n-    public String getValueMappedBy();\r\n-\r\n-    /**\r\n-     * The field that this value shares a mapping with. Currently the only\r\n-     * supported use for a mapped-by value is when a map field key is\r\n-     * determined by a field of the persistence-capable map value.\r\n-     */\r\n-    public void setValueMappedBy(String mapped);\r\n-\r\n-    /**\r\n-     * The field that this value shares a mapping with. Currently the only\r\n-     * supported use for a mapped-by value is when a map field key is\r\n-     * determined by a field of the persistence-capable map value.\r\n-     */\r\n-    public FieldMetaData getValueMappedByMetaData();\r\n-\r\n-    /**\r\n-     * User-supplied type overriding assumed type based on field.\r\n-     */\r\n-    public Class getTypeOverride();\r\n-\r\n-    /**\r\n-     * User-supplied type overriding assumed type based on field.\r\n-     */\r\n-    public void setTypeOverride(Class type);\r\n-\r\n-    /**\r\n-     * Resolve mode for metadata.\r\n-     */\r\n-    public int getResolve();\r\n-\r\n-    /**\r\n-     * Resolve mode for metadata.\r\n-     */\r\n-    public void setResolve(int mode);\r\n-\r\n-    /**\r\n-     * Resolve mode for metadata.\r\n-     */\r\n-    public void setResolve(int mode, boolean on);\r\n-\r\n-    /**\r\n-     * Resolve and validate metadata. Return true if already resolved.\r\n-     */\r\n-    public boolean resolve(int mode);\r\n-\r\n-    /**\r\n-     * Copy state from the given value to this one. Do not copy mapping\r\n-     * information.\r\n-     */\r\n-    public void copy(ValueMetaData vmd);\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.meta;\n+\n+/**\n+ * <p>Holds metadata on a value; this could be a field value, key value, or\n+ * element value.</p>\n+ *\n+ * @since 4.0\n+ * @author Abe White\n+ */\n+public interface ValueMetaData\n+    extends MetaDataContext, MetaDataModes {\n+\n+    /**\n+     * The operation is not cascaded to this field.\n+     */\n+    public int CASCADE_NONE = 0;\n+\n+    /**\n+     * The operation is immediately cascaded to this field.\n+     */\n+    public int CASCADE_IMMEDIATE = 1;\n+\n+    /**\n+     * Use automatic cascade behavior.  Persistence-by-reachability,\n+     * delete-dependent, attach-if-detached, etc.\n+     */\n+    public int CASCADE_AUTO = 2;\n+\n+    /**\n+     * Marker to set on {@link #setValueMappedBy} to denote that the map key\n+     * is mapped by the primary key field of the value.\n+     */\n+    public static final String MAPPED_BY_PK = \"`pk`\";\n+\n+    /**\n+     * Return the owning field for this value.\n+     */\n+    public FieldMetaData getFieldMetaData();\n+\n+    /**\n+     * The value class.\n+     */\n+    public Class getType();\n+\n+    /**\n+     * The value class.\n+     */\n+    public void setType(Class type);\n+\n+    /**\n+     * The type code of the value class.\n+     */\n+    public int getTypeCode();\n+\n+    /**\n+     * The type code of the value class.\n+     */\n+    public void setTypeCode(int code);\n+\n+    /**\n+     * Whether the type is a persistence capable instance.\n+     */\n+    public boolean isTypePC();\n+\n+    /**\n+     * The metadata for the value class, if the type is persistent.\n+     */\n+    public ClassMetaData getTypeMetaData();\n+\n+    /**\n+     * Return the declared class of the value.  This can differ\n+     * from the return value of {@link #getType} if the user indicates\n+     * a different type or the value has an externalizer.\n+     */\n+    public Class getDeclaredType();\n+\n+    /**\n+     * Set the declared class of the value.\n+     */\n+    public void setDeclaredType(Class type);\n+\n+    /**\n+     * Return the declared type code of the value.  This can differ\n+     * from the return value of {@link #getTypeCode} if the user indicates\n+     * a different type or the value has an externalizer.\n+     */\n+    public int getDeclaredTypeCode();\n+\n+    /**\n+     * Set the type code for the value.  The type code is usually\n+     * computed automatically, but it can be useful to set it explicitly\n+     * when creating metadatas from scratch.\n+     */\n+    public void setDeclaredTypeCode(int type);\n+\n+    /**\n+     * Whether the type is a persistence capable instance.\n+     */\n+    public boolean isDeclaredTypePC();\n+\n+    /**\n+     * Return metadata for the value's class, if the type is persistent.\n+     */\n+    public ClassMetaData getDeclaredTypeMetaData();\n+\n+    /**\n+     * This attribute is a hint to the implementation to store this value\n+     * in the same structure as the class, rather than as a separate datastore\n+     * structure.  Defaults to true if the field is not a collection or map\n+     * or persistence-capable object; defaults to false otherwise.\n+     * Implementations are permitted to ignore this attribute.\n+     */\n+    public boolean isEmbedded();\n+\n+    /**\n+     * This attribute is a hint to the implementation to store this value\n+     * in the same structure as the class, rather than as a separate datastore\n+     * structure.  Defaults to true if the field is not a collection or map\n+     * or persistence-capable objects; defaults to false otherwise.\n+     * Implementations are permitted to ignore this attribute.\n+     */\n+    public void setEmbedded(boolean embedded);\n+\n+    /**\n+     * Whether this is an embedded persistence capable value.\n+     */\n+    public boolean isEmbeddedPC();\n+\n+    /**\n+     * The embedded class metadata for the value.\n+     */\n+    public ClassMetaData getEmbeddedMetaData();\n+\n+    /**\n+     * Add embedded metadata for this value.\n+     */\n+    public ClassMetaData addEmbeddedMetaData();\n+\n+    /**\n+     * Cascade behavior for delete operation.  Only applies to\n+     * persistence-capable values.  Options are:<br />\n+     * <ul>\n+     * <li><code>CASCADE_NONE</code>: No cascades.</li>\n+     * <li><code>CASCADE_IMMEDIATE</code>: Value is deleted immediately when\n+     * the owning object is deleted.</li>\n+     * <li><code>CASCADE_AUTO</code>: Value will be deleted on flush\n+     * if the owning object is deleted or if the value is removed from the\n+     * owning object, and if the value is not assigned to another relation in\n+     * the same transaction.</li>\n+     * </ul>\n+     */\n+    public int getCascadeDelete();\n+\n+    /**\n+     * Cascade behavior for deletion.\n+     *\n+     * @see    #getCascadeDelete\n+     */\n+    public void setCascadeDelete(int cascade);\n+\n+    /**\n+     * Cascade behavior for persist operation.  Only applies to\n+     * persistence-capable values.  Options are:<br />\n+     * <ul>\n+     * <li><code>CASCADE_NONE</code>: No cascades.  If a transient relation\n+     * is held at flush, an error is thrown.</li>\n+     * <li><code>CASCADE_IMMEDIATE</code>: Value is persisted immediately when\n+     * the owning object is persisted.</li>\n+     * <li><code>CASCADE_AUTO</code>: Value will be persisted on flush.</li>\n+     * </ul>\n+     */\n+    public int getCascadePersist();\n+\n+    /**\n+     * Cascade behavior for persist operation.\n+     *\n+     * @see    #getCascadePersist\n+     */\n+    public void setCascadePersist(int cascade);\n+\n+    /**\n+     * Cascade behavior for attach operation.  Only applies to\n+     * persistence-capable values.  Options are:<br />\n+     * <ul>\n+     * <li><code>CASCADE_NONE</code>: No cascades of attach.  Relation\n+     * remains detached.</li>\n+     * <li><code>CASCADE_IMMEDIATE</code>: Value is attached immediately.</li>\n+     * </ul>\n+     */\n+    public int getCascadeAttach();\n+\n+    /**\n+     * Cascade behavior for attach operation.\n+     *\n+     * @see    #getCascadeAttach\n+     */\n+    public void setCascadeAttach(int cascade);\n+\n+    /**\n+     * Cascade behavior for refresh operation.  Only applies to\n+     * persistence-capable values.  Options are:<br />\n+     * <ul>\n+     * <li><code>CASCADE_NONE</code>: No cascades of refresh.</li>\n+     * <li><code>CASCADE_IMMEDIATE</code>: Persistent value object is also\n+     * refreshed.</li>\n+     * <li><code>CASCADE_AUTO</code>: Value will be refreshed if it is\n+     * in the current fetch groups.</li>\n+     * </ul>\n+     */\n+    public int getCascadeRefresh();\n+\n+    /**\n+     * Cascade behavior for refresh operation.\n+     *\n+     * @see    #getCascadeRefresh\n+     */\n+    public void setCascadeRefresh(int cascade);\n+\n+    /**\n+     * Whether this value is serialized when stored.\n+     */\n+    public boolean isSerialized();\n+\n+    /**\n+     * Whether this value is serialized when stored.\n+     */\n+    public void setSerialized(boolean serialized);\n+\n+    /**\n+     * The field that this value shares a mapping with.  Currently the only\n+     * supported use for a mapped-by value is when a map field key is\n+     * determined by a field of the persistence-capable map value.\n+     */\n+    public String getValueMappedBy();\n+\n+    /**\n+     * The field that this value shares a mapping with.  Currently the only\n+     * supported use for a mapped-by value is when a map field key is\n+     * determined by a field of the persistence-capable map value.\n+     */\n+    public void setValueMappedBy(String mapped);\n+\n+    /**\n+     * The field that this value shares a mapping with.  Currently the only\n+     * supported use for a mapped-by value is when a map field key is\n+     * determined by a field of the persistence-capable map value.\n+     */\n+    public FieldMetaData getValueMappedByMetaData();\n+\n+    /**\n+     * User-supplied type overriding assumed type based on field.\n+     */\n+    public Class getTypeOverride();\n+\n+    /**\n+     * User-supplied type overriding assumed type based on field.\n+     */\n+    public void setTypeOverride(Class type);\n+\n+    /**\n+     * Resolve mode for metadata.\n+     */\n+    public int getResolve();\n+\n+    /**\n+     * Resolve mode for metadata.\n+     */\n+    public void setResolve(int mode);\n+\n+    /**\n+     * Resolve mode for metadata.\n+     */\n+    public void setResolve(int mode, boolean on);\n+\n+    /**\n+     * Resolve and validate metadata.  Return true if already resolved.\n+     */\n+    public boolean resolve(int mode);\n+\n+    /**\n+     *\tCopy state from the given value to this one.  Do not copy mapping\n+      *\tinformation.\n+     */\n+    public void copy (ValueMetaData vmd);\n+}"},{"sha":"23154617a022fff67d2219e9a95aa66e31656124","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java","status":"modified","additions":443,"deletions":423,"changes":866,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,423 +1,443 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.meta;\r\n-\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.MetaDataException;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * Default {@link ValueMetaData} implementation.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class ValueMetaDataImpl implements ValueMetaData {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (ValueMetaDataImpl.class);\r\n-    ///////////////////////////////////////////////////////////////\r\n-    // Note: if you add additional state that should be copied to\r\n-    // embedded metadata, make sure to add it to the copy() method\r\n-    ///////////////////////////////////////////////////////////////\r\n-    private final FieldMetaData _owner;\r\n-    private Class _decType = Object.class;\r\n-    private int _decCode = JavaTypes.OBJECT;\r\n-    private ClassMetaData _decTypeMeta = null;\r\n-    private Class _type = null;\r\n-    private int _code = JavaTypes.OBJECT;\r\n-    private ClassMetaData _typeMeta = null;\r\n-    private Class _typeOverride = null;\r\n-    private int _delete = CASCADE_NONE;\r\n-    private int _persist = CASCADE_AUTO;\r\n-    private int _attach = CASCADE_IMMEDIATE;\r\n-    private int _refresh = CASCADE_AUTO;\r\n-    private boolean _serialized = false;\r\n-    private Boolean _embedded = null;\r\n-    private ClassMetaData _embeddedMeta = null;\r\n-    private int _resMode = MODE_NONE;\r\n-    private String _mappedBy = null;\r\n-    private FieldMetaData _mappedByMeta = null;\r\n-\r\n-    protected ValueMetaDataImpl(FieldMetaData owner) {\r\n-        _owner = owner;\r\n-    }\r\n-\r\n-    public FieldMetaData getFieldMetaData() {\r\n-        return _owner;\r\n-    }\r\n-\r\n-    public MetaDataRepository getRepository() {\r\n-        return _owner.getRepository();\r\n-    }\r\n-\r\n-    public Class getType() {\r\n-        return (_type == null) ? _decType : _type;\r\n-    }\r\n-\r\n-    public void setType(Class type) {\r\n-        _type = type;\r\n-        _typeMeta = null;\r\n-        if (type != null)\r\n-            setTypeCode(JavaTypes.getTypeCode(type));\r\n-    }\r\n-\r\n-    public int getTypeCode() {\r\n-        return (_type == null) ? _decCode : _code;\r\n-    }\r\n-\r\n-    public void setTypeCode(int code) {\r\n-        _code = code;\r\n-    }\r\n-\r\n-    public boolean isTypePC() {\r\n-        return getTypeCode() == JavaTypes.PC\r\n-            || getTypeCode() == JavaTypes.PC_UNTYPED;\r\n-    }\r\n-\r\n-    public ClassMetaData getTypeMetaData() {\r\n-        if (_type == null)\r\n-            return getDeclaredTypeMetaData();\r\n-        if (_typeMeta == null && _code == JavaTypes.PC) {\r\n-            ClassMetaData meta = _owner.getDefiningMetaData();\r\n-            _typeMeta = meta.getRepository().getMetaData(_type,\r\n-                meta.getEnvClassLoader(), true);\r\n-        }\r\n-        return _typeMeta;\r\n-    }\r\n-\r\n-    public Class getDeclaredType() {\r\n-        return _decType;\r\n-    }\r\n-\r\n-    public void setDeclaredType(Class type) {\r\n-        _decType = type;\r\n-        _decTypeMeta = null;\r\n-        _decCode = JavaTypes.getTypeCode(type);\r\n-        if (_embeddedMeta != null)\r\n-            _embeddedMeta.setDescribedType(type);\r\n-    }\r\n-\r\n-    public int getDeclaredTypeCode() {\r\n-        return _decCode;\r\n-    }\r\n-\r\n-    public void setDeclaredTypeCode(int code) {\r\n-        _decCode = code;\r\n-    }\r\n-\r\n-    public boolean isDeclaredTypePC() {\r\n-        return _decCode == JavaTypes.PC || _decCode == JavaTypes.PC_UNTYPED;\r\n-    }\r\n-\r\n-    public ClassMetaData getDeclaredTypeMetaData() {\r\n-        if (_decTypeMeta == null && _decCode == JavaTypes.PC) {\r\n-            if (isEmbedded())\r\n-                _decTypeMeta = getEmbeddedMetaData();\r\n-            else {\r\n-                ClassMetaData meta = _owner.getDefiningMetaData();\r\n-                _decTypeMeta = meta.getRepository().getMetaData(_decType,\r\n-                    meta.getEnvClassLoader(), true);\r\n-            }\r\n-        }\r\n-        return _decTypeMeta;\r\n-    }\r\n-\r\n-    public boolean isEmbedded() {\r\n-        if (_owner.getManagement() != _owner.MANAGE_PERSISTENT)\r\n-            return false;\r\n-        if (_embedded == null) {\r\n-            // field left as default; embedded setting depends on type\r\n-            switch (_decCode) {\r\n-                case JavaTypes.PC:\r\n-                case JavaTypes.COLLECTION:\r\n-                case JavaTypes.MAP:\r\n-                case JavaTypes.PC_UNTYPED:\r\n-                    _embedded = Boolean.FALSE;\r\n-                    break;\r\n-                default:\r\n-                    _embedded = Boolean.TRUE;\r\n-            }\r\n-        }\r\n-        return _embedded.booleanValue();\r\n-    }\r\n-\r\n-    public void setEmbedded(boolean embedded) {\r\n-        if (embedded && _embedded != Boolean.TRUE) {\r\n-            _decTypeMeta = null;\r\n-            _typeMeta = null;\r\n-        }\r\n-        _embedded = (embedded) ? Boolean.TRUE : Boolean.FALSE;\r\n-    }\r\n-\r\n-    public boolean isEmbeddedPC() {\r\n-        return _decCode == JavaTypes.PC && isEmbedded();\r\n-    }\r\n-\r\n-    public ClassMetaData getEmbeddedMetaData() {\r\n-        if (_embeddedMeta == null && isEmbeddedPC())\r\n-            addEmbeddedMetaData();\r\n-        return _embeddedMeta;\r\n-    }\r\n-\r\n-    public ClassMetaData addEmbeddedMetaData() {\r\n-        MetaDataRepository repos = _owner.getRepository();\r\n-        _embeddedMeta = repos.newEmbeddedClassMetaData(this);\r\n-        _embeddedMeta.setDescribedType(_decType);\r\n-        repos.getMetaDataFactory().getDefaults().populate(_embeddedMeta,\r\n-            ClassMetaData.ACCESS_UNKNOWN);\r\n-        setEmbedded(true);\r\n-        return _embeddedMeta;\r\n-    }\r\n-\r\n-    public int getCascadeDelete() {\r\n-        if (_owner.getManagement() != FieldMetaData.MANAGE_PERSISTENT)\r\n-            return CASCADE_NONE;\r\n-        if (isEmbeddedPC())\r\n-            return CASCADE_IMMEDIATE;\r\n-        switch (_delete) {\r\n-            case CASCADE_NONE:\r\n-                // if the user marks the owning field dependent and we externalize\r\n-                // to a pc type, then become dependent\r\n-                if (this != _owner.getValue() && isTypePC()\r\n-                    && ((ValueMetaDataImpl) _owner.getValue())._delete\r\n-                    == CASCADE_AUTO)\r\n-                    return CASCADE_AUTO;\r\n-                break;\r\n-            case CASCADE_AUTO:\r\n-                if (isTypePC())\r\n-                    return CASCADE_AUTO;\r\n-                break;\r\n-            case CASCADE_IMMEDIATE:\r\n-                if (isDeclaredTypePC())\r\n-                    return CASCADE_IMMEDIATE;\r\n-                break;\r\n-        }\r\n-        return CASCADE_NONE;\r\n-    }\r\n-\r\n-    public void setCascadeDelete(int delete) {\r\n-        _delete = delete;\r\n-    }\r\n-\r\n-    public int getCascadePersist() {\r\n-        if (_owner.getManagement() != FieldMetaData.MANAGE_PERSISTENT)\r\n-            return CASCADE_NONE;\r\n-        if (isDeclaredTypePC())\r\n-            return _persist;\r\n-        if (!isTypePC())\r\n-            return CASCADE_NONE;\r\n-        // if only externalized type is pc, can't cascade immediate\r\n-        return (_persist == CASCADE_IMMEDIATE) ? CASCADE_AUTO : _persist;\r\n-    }\r\n-\r\n-    public void setCascadePersist(int persist) {\r\n-        _persist = persist;\r\n-    }\r\n-\r\n-    public int getCascadeAttach() {\r\n-        if (_owner.getManagement() != FieldMetaData.MANAGE_PERSISTENT\r\n-            || !isDeclaredTypePC()) // attach acts on declared type\r\n-            return CASCADE_NONE;\r\n-        return _attach;\r\n-    }\r\n-\r\n-    public void setCascadeAttach(int attach) {\r\n-        if (attach == CASCADE_AUTO)\r\n-            throw new IllegalArgumentException(\"CASCADE_AUTO\");\r\n-        _attach = attach;\r\n-    }\r\n-\r\n-    public int getCascadeRefresh() {\r\n-        if (_owner.getManagement() != FieldMetaData.MANAGE_PERSISTENT\r\n-            || !isDeclaredTypePC()) // refresh acts on declared type\r\n-            return CASCADE_NONE;\r\n-        return _refresh;\r\n-    }\r\n-\r\n-    public void setCascadeRefresh(int refresh) {\r\n-        _refresh = refresh;\r\n-    }\r\n-\r\n-    public boolean isSerialized() {\r\n-        return _serialized;\r\n-    }\r\n-\r\n-    public void setSerialized(boolean serialized) {\r\n-        _serialized = serialized;\r\n-    }\r\n-\r\n-    public String getValueMappedBy() {\r\n-        if (_mappedBy == MAPPED_BY_PK) {\r\n-            // use this instead of getting meta from element b/c that\r\n-            // requires element to be resolved\r\n-            ClassMetaData meta = getRepository().getMetaData\r\n-                (_owner.getElement().getType(), null, false);\r\n-            if (meta == null)\r\n-                throw new MetaDataException(_loc.get(\"val-not-pc\", _owner));\r\n-            if (meta.getPrimaryKeyFields().length != 1)\r\n-                throw new MetaDataException(_loc.get(\"val-not-one-pk\",\r\n-                    _owner));\r\n-            _mappedByMeta = meta.getPrimaryKeyFields()[0];\r\n-            _mappedBy = _mappedByMeta.getName();\r\n-        }\r\n-        return _mappedBy;\r\n-    }\r\n-\r\n-    public void setValueMappedBy(String mapped) {\r\n-        if (_owner.getKey() != this && mapped != null)\r\n-            throw new UserException(_loc.get(\"mapped-by-not-key\", this));\r\n-        else {\r\n-            _mappedBy = mapped;\r\n-            _mappedByMeta = null;\r\n-        }\r\n-    }\r\n-\r\n-    public FieldMetaData getValueMappedByMetaData() {\r\n-        if (getValueMappedBy() != null && _mappedByMeta == null) {\r\n-            ClassMetaData meta = _owner.getElement().getTypeMetaData();\r\n-            FieldMetaData field = (meta == null) ? null\r\n-                : meta.getField(getValueMappedBy());\r\n-            if (field == null)\r\n-                throw new MetaDataException(_loc.get(\"no-mapped-by\", this,\r\n-                    getValueMappedBy()));\r\n-            if (field.getMappedBy() != null)\r\n-                throw new MetaDataException(_loc.get(\"circ-mapped-by\", this,\r\n-                    getValueMappedBy()));\r\n-            _mappedByMeta = field;\r\n-        }\r\n-        return _mappedByMeta;\r\n-    }\r\n-\r\n-    public Class getTypeOverride() {\r\n-        return _typeOverride;\r\n-    }\r\n-\r\n-    public void setTypeOverride(Class val) {\r\n-        _typeOverride = val;\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        String ret = _owner.getFullName();\r\n-        if (this == _owner.getKey())\r\n-            return ret + \"<key:\" + _decType + \">\";\r\n-        if (this == _owner.getElement()) {\r\n-            if (_owner.getTypeCode() == JavaTypes.MAP)\r\n-                return ret + \"<value:\" + _decType + \">\";\r\n-            return ret + \"<element:\" + _decType + \">\";\r\n-        }\r\n-        return ret + \"<\" + _decType + \">\";\r\n-    }\r\n-\r\n-    ////////////////////////\r\n-    // Resolve and validate\r\n-    ////////////////////////\r\n-    public int getResolve() {\r\n-        return _resMode;\r\n-    }\r\n-\r\n-    public void setResolve(int mode) {\r\n-        _resMode = mode;\r\n-    }\r\n-\r\n-    public void setResolve(int mode, boolean on) {\r\n-        if (mode == MODE_NONE)\r\n-            _resMode = mode;\r\n-        else if (on)\r\n-            _resMode |= mode;\r\n-        else _resMode &= ~mode;\r\n-    }\r\n-\r\n-    public boolean resolve(int mode) {\r\n-        if ((_resMode & mode) == mode)\r\n-            return true;\r\n-        int cur = _resMode;\r\n-        _resMode |= mode;\r\n-        // we only perform actions for meta mode\r\n-        if ((mode & MODE_META) == 0 || (cur & MODE_META) != 0)\r\n-            return false;\r\n-        // check for type extension\r\n-        int codeOverride = JavaTypes.OBJECT;\r\n-        if (_typeOverride != null) {\r\n-            codeOverride = JavaTypes.getTypeCode(_typeOverride);\r\n-            // if there is no externalizer method or this value is a key or\r\n-            // element, set our type to the type extension; otherwise, use the\r\n-            // type extension as a hint to the actual type of the declared\r\n-            // value(e.g. marking an interface as non-pc)\r\n-            if (_owner.getExternalizerMethod() == null\r\n-                || _owner.getValue() != this) {\r\n-                _type = _typeOverride;\r\n-                _code = codeOverride;\r\n-            } else {\r\n-                _decCode = codeOverride;\r\n-                if (JavaTypes.maybePC(codeOverride, _typeOverride))\r\n-                    resolveDeclaredType(_typeOverride);\r\n-            }\r\n-        }\r\n-        // see if actual type is pc\r\n-        if (JavaTypes.maybePC(_code, _type)) {\r\n-            _typeMeta = _owner.getRepository().getMetaData(_type,\r\n-                _owner.getDefiningMetaData().getEnvClassLoader(), false);\r\n-            if (_typeMeta != null)\r\n-                _code = JavaTypes.PC;\r\n-        }\r\n-        // if there is no externalizer, set our declared type code to the\r\n-        // actual type so that we treat the value correctly at runtime\r\n-        // (pers by reach, etc)\r\n-        if (_typeOverride != null && _owner.getExternalizerMethod() == null\r\n-            && _owner.getExternalValues() == null) {\r\n-            // cache the metadata immediately since we won't be able to get\r\n-            // it lazily, since we're not resetting _decType to _type\r\n-            _decCode = _code;\r\n-            _decTypeMeta = _typeMeta;\r\n-        } else if (JavaTypes.maybePC(_decCode, _decType))\r\n-            resolveDeclaredType(_decType);\r\n-        // resolves mapped by\r\n-        getValueMappedBy();\r\n-        ClassMetaData embed = getEmbeddedMetaData();\r\n-        if (embed != null)\r\n-            embed.resolve(MODE_META);\r\n-        // oid as primary key field?\r\n-        if (_decCode == JavaTypes.PC && isEmbedded()\r\n-            && _owner.isPrimaryKey() && _owner.getValue() == this)\r\n-            _code = _decCode = JavaTypes.OID;\r\n-        return false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Resolve the declared type.\r\n-     */\r\n-    private void resolveDeclaredType(Class type) {\r\n-        ClassMetaData meta = _owner.getRepository().getMetaData(type,\r\n-            _owner.getDefiningMetaData().getEnvClassLoader(), false);\r\n-        if (meta != null)\r\n-            _decCode = JavaTypes.PC;\r\n-        if (!isEmbedded())\r\n-            _decTypeMeta = meta;\r\n-    }\r\n-\r\n-    public void copy(ValueMetaData vmd) {\r\n-        _decType = vmd.getDeclaredType();\r\n-        _decCode = vmd.getDeclaredTypeCode();\r\n-        _delete = vmd.getCascadeDelete();\r\n-        _persist = vmd.getCascadePersist();\r\n-        _attach = vmd.getCascadeAttach();\r\n-        _refresh = vmd.getCascadeRefresh();\r\n-        _typeOverride = vmd.getTypeOverride();\r\n-        if (_embeddedMeta != null)\r\n-            _embeddedMeta.setDescribedType(vmd.getDeclaredType());\r\n-        // don't allow copy to override embedded; don't copy serialized at all\r\n-        if (_embedded == null)\r\n-            setEmbedded(vmd.isEmbedded());\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.meta;\n+\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.MetaDataException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * <p>Default {@link ValueMetaData} implementation.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ValueMetaDataImpl\n+    implements ValueMetaData {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ValueMetaDataImpl.class);\n+\n+    ///////////////////////////////////////////////////////////////\n+    // Note: if you add additional state that should be copied to\n+    // embedded metadata, make sure to add it to the copy() method\n+    ///////////////////////////////////////////////////////////////\n+\n+    private final FieldMetaData _owner;\n+    private Class _decType = Object.class;\n+    private int _decCode = JavaTypes.OBJECT;\n+    private ClassMetaData _decTypeMeta = null;\n+    private Class _type = null;\n+    private int _code = JavaTypes.OBJECT;\n+    private ClassMetaData _typeMeta = null;\n+    private Class _typeOverride = null;\n+    private int _delete = CASCADE_NONE;\n+    private int _persist = CASCADE_AUTO;\n+    private int _attach = CASCADE_IMMEDIATE;\n+    private int _refresh = CASCADE_AUTO;\n+    private boolean _serialized = false;\n+    private Boolean _embedded = null;\n+    private ClassMetaData _embeddedMeta = null;\n+    private int _resMode = MODE_NONE;\n+    private String _mappedBy = null;\n+    private FieldMetaData _mappedByMeta = null;\n+\n+    protected ValueMetaDataImpl(FieldMetaData owner) {\n+        _owner = owner;\n+    }\n+\n+    public FieldMetaData getFieldMetaData() {\n+        return _owner;\n+    }\n+\n+    public MetaDataRepository getRepository() {\n+        return _owner.getRepository();\n+    }\n+\n+    public Class getType() {\n+        return (_type == null) ? _decType : _type;\n+    }\n+\n+    public void setType(Class type) {\n+        _type = type;\n+        _typeMeta = null;\n+        if (type != null)\n+            setTypeCode(JavaTypes.getTypeCode(type));\n+    }\n+\n+    public int getTypeCode() {\n+        return (_type == null) ? _decCode : _code;\n+    }\n+\n+    public void setTypeCode(int code) {\n+        _code = code;\n+    }\n+\n+    public boolean isTypePC() {\n+        return getTypeCode() == JavaTypes.PC\n+            || getTypeCode() == JavaTypes.PC_UNTYPED;\n+    }\n+\n+    public ClassMetaData getTypeMetaData() {\n+        if (_type == null)\n+            return getDeclaredTypeMetaData();\n+        if (_typeMeta == null && _code == JavaTypes.PC) {\n+            ClassMetaData meta = _owner.getDefiningMetaData();\n+            _typeMeta = meta.getRepository().getMetaData(_type,\n+                meta.getEnvClassLoader(), true);\n+        }\n+        return _typeMeta;\n+    }\n+\n+    public Class getDeclaredType() {\n+        return _decType;\n+    }\n+\n+    public void setDeclaredType(Class type) {\n+        _decType = type;\n+        _decTypeMeta = null;\n+        _decCode = JavaTypes.getTypeCode(type);\n+        if (_embeddedMeta != null)\n+            _embeddedMeta.setDescribedType(type);\n+    }\n+\n+    public int getDeclaredTypeCode() {\n+        return _decCode;\n+    }\n+\n+    public void setDeclaredTypeCode(int code) {\n+        _decCode = code;\n+    }\n+\n+    public boolean isDeclaredTypePC() {\n+        return _decCode == JavaTypes.PC || _decCode == JavaTypes.PC_UNTYPED;\n+    }\n+\n+    public ClassMetaData getDeclaredTypeMetaData() {\n+        if (_decTypeMeta == null && _decCode == JavaTypes.PC) {\n+            if (isEmbedded())\n+                _decTypeMeta = getEmbeddedMetaData();\n+            else {\n+                ClassMetaData meta = _owner.getDefiningMetaData();\n+                _decTypeMeta = meta.getRepository().getMetaData(_decType,\n+                    meta.getEnvClassLoader(), true);\n+            }\n+        }\n+        return _decTypeMeta;\n+    }\n+\n+    public boolean isEmbedded() {\n+        if (_owner.getManagement() != _owner.MANAGE_PERSISTENT)\n+            return false;\n+        if (_embedded == null) {\n+            // field left as default; embedded setting depends on type\n+            switch (_decCode) {\n+                case JavaTypes.PC:\n+                case JavaTypes.COLLECTION:\n+                case JavaTypes.MAP:\n+                case JavaTypes.PC_UNTYPED:\n+                    _embedded = Boolean.FALSE;\n+                    break;\n+                default:\n+                    _embedded = Boolean.TRUE;\n+            }\n+        }\n+        return _embedded.booleanValue();\n+    }\n+\n+    public void setEmbedded(boolean embedded) {\n+        if (embedded && _embedded != Boolean.TRUE) {\n+            _decTypeMeta = null;\n+            _typeMeta = null;\n+        }\n+        _embedded = (embedded) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    public boolean isEmbeddedPC() {\n+        return _decCode == JavaTypes.PC && isEmbedded();\n+    }\n+\n+    public ClassMetaData getEmbeddedMetaData() {\n+        if (_embeddedMeta == null && isEmbeddedPC())\n+            addEmbeddedMetaData();\n+        return _embeddedMeta;\n+    }\n+\n+    public ClassMetaData addEmbeddedMetaData() {\n+        MetaDataRepository repos = _owner.getRepository();\n+        _embeddedMeta = repos.newEmbeddedClassMetaData(this);\n+        _embeddedMeta.setDescribedType(_decType);\n+        repos.getMetaDataFactory().getDefaults().populate(_embeddedMeta,\n+            ClassMetaData.ACCESS_UNKNOWN);\n+\n+        setEmbedded(true);\n+        return _embeddedMeta;\n+    }\n+\n+    public int getCascadeDelete() {\n+        if (_owner.getManagement() != FieldMetaData.MANAGE_PERSISTENT)\n+            return CASCADE_NONE;\n+        if (isEmbeddedPC())\n+            return CASCADE_IMMEDIATE;\n+\n+        switch (_delete) {\n+            case CASCADE_NONE:\n+                // if the user marks the owning field dependent and we externalize\n+                // to a pc type, then become dependent\n+                if (this != _owner.getValue() && isTypePC()\n+                    && ((ValueMetaDataImpl) _owner.getValue())._delete\n+                    == CASCADE_AUTO)\n+                    return CASCADE_AUTO;\n+                break;\n+            case CASCADE_AUTO:\n+                if (isTypePC())\n+                    return CASCADE_AUTO;\n+                break;\n+            case CASCADE_IMMEDIATE:\n+                if (isDeclaredTypePC())\n+                    return CASCADE_IMMEDIATE;\n+                break;\n+        }\n+        return CASCADE_NONE;\n+    }\n+\n+    public void setCascadeDelete(int delete) {\n+        _delete = delete;\n+    }\n+\n+    public int getCascadePersist() {\n+        if (_owner.getManagement() != FieldMetaData.MANAGE_PERSISTENT)\n+            return CASCADE_NONE;\n+        if (isDeclaredTypePC())\n+            return _persist;\n+        if (!isTypePC())\n+            return CASCADE_NONE;\n+        // if only externalized type is pc, can't cascade immediate\n+        return (_persist == CASCADE_IMMEDIATE) ? CASCADE_AUTO : _persist;\n+    }\n+\n+    public void setCascadePersist(int persist) {\n+        _persist = persist;\n+    }\n+\n+    public int getCascadeAttach() {\n+        if (_owner.getManagement() != FieldMetaData.MANAGE_PERSISTENT\n+            || !isDeclaredTypePC())    // attach acts on declared type\n+            return CASCADE_NONE;\n+        return _attach;\n+    }\n+\n+    public void setCascadeAttach(int attach) {\n+        if (attach == CASCADE_AUTO)\n+            throw new IllegalArgumentException(\"CASCADE_AUTO\");\n+        _attach = attach;\n+    }\n+\n+    public int getCascadeRefresh() {\n+        if (_owner.getManagement() != FieldMetaData.MANAGE_PERSISTENT\n+            || !isDeclaredTypePC())    // refresh acts on declared type\n+            return CASCADE_NONE;\n+        return _refresh;\n+    }\n+\n+    public void setCascadeRefresh(int refresh) {\n+        _refresh = refresh;\n+    }\n+\n+    public boolean isSerialized() {\n+        return _serialized;\n+    }\n+\n+    public void setSerialized(boolean serialized) {\n+        _serialized = serialized;\n+    }\n+\n+    public String getValueMappedBy() {\n+        if (_mappedBy == MAPPED_BY_PK) {\n+            // use this instead of getting meta from element b/c that\n+            // requires element to be resolved\n+            ClassMetaData meta = getRepository().getMetaData\n+                (_owner.getElement().getType(), null, false);\n+            if (meta == null)\n+                throw new MetaDataException(_loc.get(\"val-not-pc\", _owner));\n+            if (meta.getPrimaryKeyFields().length != 1)\n+                throw new MetaDataException(_loc.get(\"val-not-one-pk\",\n+                    _owner));\n+            _mappedByMeta = meta.getPrimaryKeyFields()[0];\n+            _mappedBy = _mappedByMeta.getName();\n+        }\n+        return _mappedBy;\n+    }\n+\n+    public void setValueMappedBy(String mapped) {\n+        if (_owner.getKey() != this && mapped != null)\n+            throw new UserException(_loc.get(\"mapped-by-not-key\", this));\n+        else {\n+            _mappedBy = mapped;\n+            _mappedByMeta = null;\n+        }\n+    }\n+\n+    public FieldMetaData getValueMappedByMetaData() {\n+        if (getValueMappedBy() != null && _mappedByMeta == null) {\n+            ClassMetaData meta = _owner.getElement().getTypeMetaData();\n+            FieldMetaData field = (meta == null) ? null\n+                : meta.getField(getValueMappedBy());\n+            if (field == null)\n+                throw new MetaDataException(_loc.get(\"no-mapped-by\", this,\n+                    getValueMappedBy()));\n+            if (field.getMappedBy() != null)\n+                throw new MetaDataException(_loc.get(\"circ-mapped-by\", this,\n+                    getValueMappedBy()));\n+            _mappedByMeta = field;\n+        }\n+        return _mappedByMeta;\n+    }\n+\n+    public Class getTypeOverride() {\n+        return _typeOverride;\n+    }\n+\n+    public void setTypeOverride(Class val) {\n+        _typeOverride = val;\n+    }\n+\n+    public String toString() {\n+        String ret = _owner.getFullName();\n+        if (this == _owner.getKey())\n+            return ret + \"<key:\" + _decType + \">\";\n+        if (this == _owner.getElement()) {\n+            if (_owner.getTypeCode() == JavaTypes.MAP)\n+                return ret + \"<value:\" + _decType + \">\";\n+            return ret + \"<element:\" + _decType + \">\";\n+        }\n+        return ret + \"<\" + _decType + \">\";\n+    }\n+\n+    ////////////////////////\n+    // Resolve and validate\n+    ////////////////////////\n+\n+    public int getResolve() {\n+        return _resMode;\n+    }\n+\n+    public void setResolve(int mode) {\n+        _resMode = mode;\n+    }\n+\n+    public void setResolve(int mode, boolean on) {\n+        if (mode == MODE_NONE)\n+            _resMode = mode;\n+        else if (on)\n+            _resMode |= mode;\n+        else\n+            _resMode &= ~mode;\n+    }\n+\n+    public boolean resolve(int mode) {\n+        if ((_resMode & mode) == mode)\n+            return true;\n+        int cur = _resMode;\n+        _resMode |= mode;\n+\n+        // we only perform actions for meta mode\n+        if ((mode & MODE_META) == 0 || (cur & MODE_META) != 0)\n+            return false;\n+\n+        // check for type extension\n+        int codeOverride = JavaTypes.OBJECT;\n+        if (_typeOverride != null) {\n+            codeOverride = JavaTypes.getTypeCode(_typeOverride);\n+\n+            // if there is no externalizer method or this value is a key or\n+            // element, set our type to the type extension; otherwise, use the\n+            // type extension as a hint to the actual type of the declared\n+            // value (e.g. marking an interface as non-pc)\n+            if (_owner.getExternalizerMethod() == null\n+                || _owner.getValue() != this) {\n+                _type = _typeOverride;\n+                _code = codeOverride;\n+            } else {\n+                _decCode = codeOverride;\n+                if (JavaTypes.maybePC(codeOverride, _typeOverride))\n+                    resolveDeclaredType(_typeOverride);\n+            }\n+        }\n+\n+        // see if actual type is pc\n+        if (JavaTypes.maybePC(_code, _type)) {\n+            _typeMeta = _owner.getRepository().getMetaData(_type,\n+                _owner.getDefiningMetaData().getEnvClassLoader(), false);\n+            if (_typeMeta != null)\n+                _code = JavaTypes.PC;\n+        }\n+\n+        // if there is no externalizer, set our declared type code to the\n+        // actual type so that we treat the value correctly at runtime\n+        // (pers by reach, etc)\n+        if (_typeOverride != null && _owner.getExternalizerMethod() == null\n+            && _owner.getExternalValues() == null) {\n+            // cache the metadata immediately since we won't be able to get\n+            // it lazily, since we're not resetting _decType to _type\n+            _decCode = _code;\n+            _decTypeMeta = _typeMeta;\n+        } else if (JavaTypes.maybePC(_decCode, _decType))\n+            resolveDeclaredType(_decType);\n+\n+        // resolves mapped by\n+        getValueMappedBy();\n+\n+        ClassMetaData embed = getEmbeddedMetaData();\n+        if (embed != null)\n+            embed.resolve(MODE_META);\n+\n+        // oid as primary key field?\n+        if (_decCode == JavaTypes.PC && isEmbedded()\n+            && _owner.isPrimaryKey() && _owner.getValue() == this)\n+            _code = _decCode = JavaTypes.OID;\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Resolve the declared type.\n+     */\n+    private void resolveDeclaredType(Class type) {\n+        ClassMetaData meta = _owner.getRepository().getMetaData(type,\n+            _owner.getDefiningMetaData().getEnvClassLoader(), false);\n+        if (meta != null)\n+            _decCode = JavaTypes.PC;\n+        if (!isEmbedded())\n+            _decTypeMeta = meta;\n+    }\n+\n+    public void copy(ValueMetaData vmd) {\n+        _decType = vmd.getDeclaredType();\n+        _decCode = vmd.getDeclaredTypeCode();\n+        _delete = vmd.getCascadeDelete();\n+        _persist = vmd.getCascadePersist();\n+        _attach = vmd.getCascadeAttach();\n+        _refresh = vmd.getCascadeRefresh();\n+        _typeOverride = vmd.getTypeOverride();\n+        if (_embeddedMeta != null)\n+            _embeddedMeta.setDescribedType(vmd.getDeclaredType());\n+\n+        // don't allow copy to override embedded; don't copy serialized at all\n+        if (_embedded == null)\n+            setEmbedded(vmd.isEmbedded());\n+    }\n+}"},{"sha":"b28d67e20c733042cdf5bd07ae492a0e3e346c11","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueStrategies.java","status":"modified","additions":141,"deletions":134,"changes":275,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueStrategies.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueStrategies.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueStrategies.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,134 +1,141 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.meta;\r\n-\r\n-import org.apache.commons.collections.bidimap.TreeBidiMap;\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.StringDistance;\r\n-import org.apache.openjpa.util.MetaDataException;\r\n-import serp.util.Numbers;\r\n-\r\n-/**\r\n- * Strategies for persistent value generation.\r\n- *\r\n- * @author Abe White\r\n- * @since 4.0\r\n- */\r\n-public class ValueStrategies {\r\n-\r\n-    /**\r\n-     * No value strategy.\r\n-     */\r\n-    public static final int NONE = 0;\r\n-\r\n-    /**\r\n-     * \"native\" value strategy.\r\n-     */\r\n-    public static final int NATIVE = 1;\r\n-\r\n-    /**\r\n-     * \"sequence\" value strategy.\r\n-     */\r\n-    public static final int SEQUENCE = 2;\r\n-\r\n-    /**\r\n-     * \"autoassigned\" value strategy.\r\n-     */\r\n-    public static final int AUTOASSIGN = 3;\r\n-\r\n-    /**\r\n-     * \"increment\" value strategy.\r\n-     */\r\n-    public static final int INCREMENT = 4;\r\n-\r\n-    /**\r\n-     * \"uuid-string\" value strategy.\r\n-     */\r\n-    public static final int UUID_STRING = 5;\r\n-\r\n-    /**\r\n-     * \"uuid-hex\" value strategy.\r\n-     */\r\n-    public static final int UUID_HEX = 6;\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (ValueStrategies.class);\r\n-    // table of names and strategies\r\n-    private static final TreeBidiMap _map = new TreeBidiMap();\r\n-\r\n-    static {\r\n-        _map.put(\"none\", Numbers.valueOf(NONE));\r\n-        _map.put(\"native\", Numbers.valueOf(NATIVE));\r\n-        _map.put(\"sequence\", Numbers.valueOf(SEQUENCE));\r\n-        _map.put(\"autoassign\", Numbers.valueOf(AUTOASSIGN));\r\n-        _map.put(\"increment\", Numbers.valueOf(INCREMENT));\r\n-        _map.put(\"uuid-string\", Numbers.valueOf(UUID_STRING));\r\n-        _map.put(\"uuid-hex\", Numbers.valueOf(UUID_HEX));\r\n-    }\r\n-\r\n-    /**\r\n-     * Convert the given strategy to a name.\r\n-     */\r\n-    public static String getName(int strategy) {\r\n-        Object code = Numbers.valueOf(strategy);\r\n-        String name = (String) _map.getKey(code);\r\n-        if (name != null)\r\n-            return name;\r\n-        throw new IllegalArgumentException(code.toString());\r\n-    }\r\n-\r\n-    /**\r\n-     * Convert the given strategy name to its constant.\r\n-     */\r\n-    public static int getCode(String val, Object context) {\r\n-        if (val == null)\r\n-            return NONE;\r\n-        Object code = _map.get(val);\r\n-        if (code != null)\r\n-            return ((Number) code).intValue();\r\n-        // not a recognized strategy; check for typo\r\n-        String closest = StringDistance.getClosestLevenshteinDistance(val,\r\n-            _map.keySet(), .5F);\r\n-        String msg;\r\n-        if (closest != null)\r\n-            msg = _loc.get(\"bad-value-strategy-hint\", new Object[]{\r\n-                context, val, closest, _map.keySet() });\r\n-        else msg = _loc.get(\"bad-value-strategy\", context, val, _map.keySet());\r\n-        throw new IllegalArgumentException(msg);\r\n-    }\r\n-\r\n-    /**\r\n-     * Assert that the given strategy is supported by the current runtime.\r\n-     */\r\n-    public static void assertSupported(int strategy, MetaDataContext context,\r\n-        String attributeName) {\r\n-        OpenJPAConfiguration conf = context.getRepository().getConfiguration();\r\n-        boolean supported = true;\r\n-        switch (strategy) {\r\n-            case AUTOASSIGN:\r\n-                supported = conf.supportedOptions().contains\r\n-                    (OpenJPAConfiguration.OPTION_VALUE_AUTOASSIGN);\r\n-                break;\r\n-            case INCREMENT:\r\n-                supported = conf.supportedOptions().contains\r\n-                    (OpenJPAConfiguration.OPTION_VALUE_INCREMENT);\r\n-                break;\r\n-            case NATIVE:\r\n-                supported = context instanceof ClassMetaData;\r\n-                break;\r\n-        }\r\n-        if (!supported)\r\n-            throw new MetaDataException(_loc.get(\"unsupported-value-strategy\",\r\n-                context, getName(strategy), attributeName));\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.meta;\n+\n+import org.apache.commons.collections.bidimap.TreeBidiMap;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.StringDistance;\n+import org.apache.openjpa.util.MetaDataException;\n+import serp.util.Numbers;\n+\n+/**\n+ * <p>Strategies for persistent value generation.</p>\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+public class ValueStrategies {\n+\n+    /**\n+     * No value strategy.\n+     */\n+    public static final int NONE = 0;\n+\n+    /**\n+     * \"native\" value strategy.\n+     */\n+    public static final int NATIVE = 1;\n+\n+    /**\n+     * \"sequence\" value strategy.\n+     */\n+    public static final int SEQUENCE = 2;\n+\n+    /**\n+     * \"autoassigned\" value strategy.\n+     */\n+    public static final int AUTOASSIGN = 3;\n+\n+    /**\n+     * \"increment\" value strategy.\n+     */\n+    public static final int INCREMENT = 4;\n+\n+    /**\n+     * \"uuid-string\" value strategy.\n+     */\n+    public static final int UUID_STRING = 5;\n+\n+    /**\n+     * \"uuid-hex\" value strategy.\n+     */\n+    public static final int UUID_HEX = 6;\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ValueStrategies.class);\n+\n+    // table of names and strategies\n+    private static final TreeBidiMap _map = new TreeBidiMap();\n+\n+    static {\n+        _map.put(\"none\", Numbers.valueOf(NONE));\n+        _map.put(\"native\", Numbers.valueOf(NATIVE));\n+        _map.put(\"sequence\", Numbers.valueOf(SEQUENCE));\n+        _map.put(\"autoassign\", Numbers.valueOf(AUTOASSIGN));\n+        _map.put(\"increment\", Numbers.valueOf(INCREMENT));\n+        _map.put(\"uuid-string\", Numbers.valueOf(UUID_STRING));\n+        _map.put(\"uuid-hex\", Numbers.valueOf(UUID_HEX));\n+    }\n+\n+    /**\n+     * Convert the given strategy to a name.\n+     */\n+    public static String getName(int strategy) {\n+        Object code = Numbers.valueOf(strategy);\n+        String name = (String) _map.getKey(code);\n+        if (name != null)\n+            return name;\n+        throw new IllegalArgumentException(code.toString());\n+    }\n+\n+    /**\n+     * Convert the given strategy name to its constant.\n+     */\n+    public static int getCode(String val, Object context) {\n+        if (val == null)\n+            return NONE;\n+        Object code = _map.get(val);\n+        if (code != null)\n+            return ((Number) code).intValue();\n+\n+        // not a recognized strategy; check for typo\n+        String closest = StringDistance.getClosestLevenshteinDistance(val,\n+            _map.keySet(), .5F);\n+        String msg;\n+        if (closest != null)\n+            msg = _loc.get(\"bad-value-strategy-hint\", new Object[]{\n+                context, val, closest, _map.keySet() });\n+        else\n+            msg = _loc.get(\"bad-value-strategy\", context, val, _map.keySet());\n+        throw new IllegalArgumentException(msg);\n+    }\n+\n+    /**\n+     *\tAssert that the given strategy is supported by the current runtime.\n+     */\n+    public static void assertSupported(int strategy, MetaDataContext context,\n+        String attributeName) {\n+        OpenJPAConfiguration conf = context.getRepository().getConfiguration();\n+        boolean supported = true;\n+        switch (strategy) {\n+            case AUTOASSIGN:\n+                supported = conf.supportedOptions().contains\n+                    (OpenJPAConfiguration.OPTION_VALUE_AUTOASSIGN);\n+                break;\n+            case INCREMENT:\n+                supported = conf.supportedOptions().contains\n+                    (OpenJPAConfiguration.OPTION_VALUE_INCREMENT);\n+                break;\n+            case NATIVE:\n+                supported = context instanceof ClassMetaData;\n+                break;\n+        }\n+        if (!supported)\n+            throw new MetaDataException(_loc.get(\"unsupported-value-strategy\",\n+                context, getName(strategy), attributeName));\n+\t}\n+}"},{"sha":"3efa838de9c6ecc1118e507f1c4c91c02c41c605","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractChangeTracker.java","status":"modified","additions":239,"deletions":230,"changes":469,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractChangeTracker.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractChangeTracker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractChangeTracker.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,230 +1,239 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.HashSet;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.commons.collections.map.IdentityMap;\r\n-import org.apache.commons.collections.set.MapBackedSet;\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-\r\n-/**\r\n- * Base class that provides utilities to change trackers.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public abstract class AbstractChangeTracker implements ChangeTracker {\r\n-\r\n-    /**\r\n-     * Collection of added items. May be null.\r\n-     */\r\n-    protected Collection add = null;\r\n-\r\n-    /**\r\n-     * Collection of removed items. May be null.\r\n-     */\r\n-    protected Collection rem = null;\r\n-\r\n-    /**\r\n-     * Collection of changed items. May be null.\r\n-     */\r\n-    protected Collection change = null;\r\n-    // we need the configuration for context when figuring out if a type\r\n-    // is managed\r\n-    private final OpenJPAConfiguration _conf;\r\n-    private boolean _autoOff = true;\r\n-    private boolean _track = false;\r\n-    private Boolean _identity = null;\r\n-    private int _seq = -1;\r\n-\r\n-    /**\r\n-     * Constructor; supply configuration.\r\n-     */\r\n-    public AbstractChangeTracker(OpenJPAConfiguration conf) {\r\n-        _conf = conf;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to automatically stop tracking when the number of changes\r\n-     * exceeds the container size. Defaults to true.\r\n-     */\r\n-    public boolean getAutoOff() {\r\n-        return _autoOff;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to automatically stop tracking when the number of changes\r\n-     * exceeds the container size. Defaults to true.\r\n-     */\r\n-    public void setAutoOff(boolean autoOff) {\r\n-        _autoOff = autoOff;\r\n-    }\r\n-\r\n-    public boolean isTracking() {\r\n-        return _track;\r\n-    }\r\n-\r\n-    public void startTracking() {\r\n-        _track = true;\r\n-        if (_seq == -1)\r\n-            _seq = initialSequence();\r\n-        reset();\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the initial sequence value for this proxy. Typically this is\r\n-     * the container size. Assumes an unordered collection by default,\r\n-     * returning 0.\r\n-     */\r\n-    protected int initialSequence() {\r\n-        return 0;\r\n-    }\r\n-\r\n-    public void stopTracking() {\r\n-        _track = false;\r\n-        _seq = -1;\r\n-        reset();\r\n-    }\r\n-\r\n-    /**\r\n-     * Reset the state of the tracker.\r\n-     */\r\n-    protected void reset() {\r\n-        if (add != null)\r\n-            add.clear();\r\n-        if (rem != null)\r\n-            rem.clear();\r\n-        if (change != null)\r\n-            change.clear();\r\n-        _identity = null;\r\n-    }\r\n-\r\n-    public Collection getAdded() {\r\n-        return (add == null) ? Collections.EMPTY_LIST : add;\r\n-    }\r\n-\r\n-    public Collection getRemoved() {\r\n-        return (rem == null) ? Collections.EMPTY_LIST : rem;\r\n-    }\r\n-\r\n-    public Collection getChanged() {\r\n-        return (change == null) ? Collections.EMPTY_LIST : change;\r\n-    }\r\n-\r\n-    /**\r\n-     * Notify the tracker that the given object was added.\r\n-     */\r\n-    protected void added(Object val) {\r\n-        if (!_track)\r\n-            return;\r\n-        setIdentity(val);\r\n-        add(val);\r\n-    }\r\n-\r\n-    /**\r\n-     * Mark the given value as added.\r\n-     */\r\n-    protected abstract void add(Object val);\r\n-\r\n-    /**\r\n-     * Notify the tracker that the given object was removed.\r\n-     */\r\n-    protected void removed(Object val) {\r\n-        if (!_track)\r\n-            return;\r\n-        setIdentity(val);\r\n-        remove(val);\r\n-    }\r\n-\r\n-    /**\r\n-     * Mark the given value as removed.\r\n-     */\r\n-    protected abstract void remove(Object val);\r\n-\r\n-    /**\r\n-     * Notify the tracker that the given object was changed.\r\n-     */\r\n-    protected void changed(Object val) {\r\n-        if (!_track)\r\n-            return;\r\n-        setIdentity(val);\r\n-        change(val);\r\n-    }\r\n-\r\n-    /**\r\n-     * Mark the given value as changed.\r\n-     */\r\n-    protected abstract void change(Object val);\r\n-\r\n-    public int getNextSequence() {\r\n-        return _seq;\r\n-    }\r\n-\r\n-    public void setNextSequence(int seq) {\r\n-        _seq = seq;\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new set for storing adds/removes/changes. Takes into account\r\n-     * whether we need to use an identity set or standard set.\r\n-     */\r\n-    protected Set newSet() {\r\n-        if (_identity == Boolean.TRUE)\r\n-            return MapBackedSet.decorate(new IdentityMap());\r\n-        return new HashSet();\r\n-    }\r\n-\r\n-    /**\r\n-     * Set whether to use identity-based datastructures, and switch our current\r\n-     * datastructures appropriately if needed. We use identity structures for\r\n-     * PC types in case the user has coded them such that two objects with\r\n-     * different identities can compare equals().\r\n-     */\r\n-    private void setIdentity(Object val) {\r\n-        if (val == null || _identity != null)\r\n-            return;\r\n-        if (ImplHelper.isManagedType(val.getClass()))\r\n-            _identity = Boolean.TRUE;\r\n-        else _identity = Boolean.FALSE;\r\n-        add = switchStructure(add, _identity.booleanValue());\r\n-        rem = switchStructure(rem, _identity.booleanValue());\r\n-        change = switchStructure(change, _identity.booleanValue());\r\n-    }\r\n-\r\n-    /**\r\n-     * Switch from an identity structure to a standard one, or vice versa.\r\n-     */\r\n-    private static Collection switchStructure(Collection cur,\r\n-        boolean identity) {\r\n-        if (cur == null)\r\n-            return null;\r\n-        if (identity && cur instanceof HashSet) {\r\n-            if (cur.isEmpty())\r\n-                return null;\r\n-            Set replace = MapBackedSet.decorate(new IdentityMap());\r\n-            replace.addAll(cur);\r\n-            return replace;\r\n-        }\r\n-        if (!identity && !(cur instanceof HashSet) && cur instanceof Set) {\r\n-            if (cur.isEmpty())\r\n-                return null;\r\n-            return new HashSet(cur);\r\n-        }\r\n-        return cur;\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.map.IdentityMap;\n+import org.apache.commons.collections.set.MapBackedSet;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+\n+/**\n+ * <p>Base class that provides utilities to change trackers.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public abstract class AbstractChangeTracker\n+    implements ChangeTracker {\n+\n+    /**\n+     * Collection of added items.  May be null.\n+     */\n+    protected Collection add = null;\n+\n+    /**\n+     * Collection of removed items.  May be null.\n+     */\n+    protected Collection rem = null;\n+\n+    /**\n+     * Collection of changed items.  May be null.\n+     */\n+    protected Collection change = null;\n+\n+    // we need the configuration for context when figuring out if a type\n+    // is managed\n+    private final OpenJPAConfiguration _conf;\n+\n+    private boolean _autoOff = true;\n+    private boolean _track = false;\n+    private Boolean _identity = null;\n+    private int _seq = -1;\n+\n+    /**\n+     * Constructor; supply configuration.\n+     */\n+    public AbstractChangeTracker(OpenJPAConfiguration conf) {\n+        _conf = conf;\n+    }\n+\n+    /**\n+     * Whether to automatically stop tracking when the number of changes\n+     * exceeds the container size.  Defaults to true.\n+     */\n+    public boolean getAutoOff() {\n+        return _autoOff;\n+    }\n+\n+    /**\n+     * Whether to automatically stop tracking when the number of changes\n+     * exceeds the container size.  Defaults to true.\n+     */\n+    public void setAutoOff(boolean autoOff) {\n+        _autoOff = autoOff;\n+    }\n+\n+    public boolean isTracking() {\n+        return _track;\n+    }\n+\n+    public void startTracking() {\n+        _track = true;\n+        if (_seq == -1)\n+            _seq = initialSequence();\n+        reset();\n+    }\n+\n+    /**\n+     * Return the initial sequence value for this proxy.  Typically this is\n+     * the container size.  Assumes an unordered collection by default,\n+     * returning 0.\n+     */\n+    protected int initialSequence() {\n+        return 0;\n+    }\n+\n+    public void stopTracking() {\n+        _track = false;\n+        _seq = -1;\n+        reset();\n+    }\n+\n+    /**\n+     * Reset the state of the tracker.\n+     */\n+    protected void reset() {\n+        if (add != null)\n+            add.clear();\n+        if (rem != null)\n+            rem.clear();\n+        if (change != null)\n+            change.clear();\n+        _identity = null;\n+    }\n+\n+    public Collection getAdded() {\n+        return (add == null) ? Collections.EMPTY_LIST : add;\n+    }\n+\n+    public Collection getRemoved() {\n+        return (rem == null) ? Collections.EMPTY_LIST : rem;\n+    }\n+\n+    public Collection getChanged() {\n+        return (change == null) ? Collections.EMPTY_LIST : change;\n+    }\n+\n+    /**\n+     * Notify the tracker that the given object was added.\n+     */\n+    protected void added(Object val) {\n+        if (!_track)\n+            return;\n+        setIdentity(val);\n+        add(val);\n+    }\n+\n+    /**\n+     * Mark the given value as added.\n+     */\n+    protected abstract void add(Object val);\n+\n+    /**\n+     * Notify the tracker that the given object was removed.\n+     */\n+    protected void removed(Object val) {\n+        if (!_track)\n+            return;\n+        setIdentity(val);\n+        remove(val);\n+    }\n+\n+    /**\n+     * Mark the given value as removed.\n+     */\n+    protected abstract void remove(Object val);\n+\n+    /**\n+     * Notify the tracker that the given object was changed.\n+     */\n+    protected void changed(Object val) {\n+        if (!_track)\n+            return;\n+        setIdentity(val);\n+        change(val);\n+    }\n+\n+    /**\n+     * Mark the given value as changed.\n+     */\n+    protected abstract void change(Object val);\n+\n+    public int getNextSequence() {\n+        return _seq;\n+    }\n+\n+    public void setNextSequence(int seq) {\n+        _seq = seq;\n+    }\n+\n+    /**\n+     * Create a new set for storing adds/removes/changes.  Takes into account\n+     * whether we need to use an identity set or standard set.\n+     */\n+    protected Set newSet() {\n+        if (_identity == Boolean.TRUE)\n+            return MapBackedSet.decorate(new IdentityMap());\n+        return new HashSet();\n+    }\n+\n+    /**\n+     * Set whether to use identity-based datastructures, and switch our current\n+     * datastructures appropriately if needed.  We use identity structures for\n+     * PC types in case the user has coded them such that two objects with\n+     * different identities can compare equals().\n+     */\n+    private void setIdentity(Object val) {\n+        if (val == null || _identity != null)\n+            return;\n+\n+        if (ImplHelper.isManagedType(val.getClass()))\n+            _identity = Boolean.TRUE;\n+        else\n+            _identity = Boolean.FALSE;\n+\n+        add = switchStructure(add, _identity.booleanValue());\n+        rem = switchStructure(rem, _identity.booleanValue());\n+        change = switchStructure(change, _identity.booleanValue());\n+    }\n+\n+    /**\n+     *\tSwitch from an identity structure to a standard one, or vice versa.\n+     */\n+    private static Collection switchStructure(Collection cur,\n+        boolean identity) {\n+        if (cur == null)\n+            return null;\n+        if (identity && cur instanceof HashSet) {\n+            if (cur.isEmpty())\n+                return null;\n+            Set replace = MapBackedSet.decorate(new IdentityMap());\n+            replace.addAll(cur);\n+            return replace;\n+        }\n+        if (!identity && !(cur instanceof HashSet) && cur instanceof Set) {\n+            if (cur.isEmpty())\n+                return null;\n+            return new HashSet (cur);\n+\t\t}\n+\t\treturn cur;\n+\t}\n+}\n+"},{"sha":"a8501645e7c981a0ba46e0f177c213ad8115f865","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyCollection.java","status":"modified","additions":428,"deletions":412,"changes":840,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyCollection.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyCollection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyCollection.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,412 +1,428 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.NoSuchElementException;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.commons.collections.Predicate;\r\n-import org.apache.commons.collections.iterators.FilterIterator;\r\n-import org.apache.commons.collections.iterators.IteratorChain;\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.lib.util.Closeable;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-\r\n-/**\r\n- * A collection proxy designed for collections backed by extremely large\r\n- * result sets in which each call to {@link #iterator} may perform a database\r\n- * query. Changes to the collection are tracked through a\r\n- * {@link ChangeTracker}. This collection has the following limitations:\r\n- * <ul>\r\n- * <li>The <code>size</code> method may return {@link Integer#MAX_VALUE}.</li>\r\n- * <li>The collection cannot contain duplicate elements.</li>\r\n- * </ul>\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public abstract class AbstractLRSProxyCollection\r\n-    implements Set, LRSProxy, Predicate, CollectionChangeTracker {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (AbstractLRSProxyCollection.class);\r\n-    private Class _elementType = null;\r\n-    private CollectionChangeTrackerImpl _ct = null;\r\n-    private OpenJPAStateManager _sm = null;\r\n-    private int _field = -1;\r\n-    private OpenJPAStateManager _origOwner = null;\r\n-    private int _origField = -1;\r\n-    private int _count = -1;\r\n-    private boolean _iterated = false;\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param elementType the allowed type of elements, or null for no\r\n-     *                    restrictions\r\n-     * @param ordered     true if this collection is ordered\r\n-     */\r\n-    public AbstractLRSProxyCollection(Class elementType, boolean ordered,\r\n-        OpenJPAConfiguration conf) {\r\n-        _elementType = elementType;\r\n-        _ct = new CollectionChangeTrackerImpl(this, false, ordered, conf);\r\n-        _ct.setAutoOff(false);\r\n-    }\r\n-\r\n-    public void setOwner(OpenJPAStateManager sm, int field) {\r\n-        // can't transfer ownership of an lrs proxy\r\n-        if (sm != null && _origOwner != null\r\n-            && (_origOwner != sm || _origField != field)) {\r\n-            throw new InvalidStateException(_loc.get(\"transfer-lrs\",\r\n-                _origOwner.getMetaData().getField(_origField)));\r\n-        }\r\n-        _sm = sm;\r\n-        _field = field;\r\n-        // keep track of original owner so we can detect transfer attempts\r\n-        if (sm != null) {\r\n-            _origOwner = sm;\r\n-            _origField = field;\r\n-        }\r\n-    }\r\n-\r\n-    public OpenJPAStateManager getOwner() {\r\n-        return _sm;\r\n-    }\r\n-\r\n-    public int getOwnerField() {\r\n-        return _field;\r\n-    }\r\n-\r\n-    public ChangeTracker getChangeTracker() {\r\n-        return this;\r\n-    }\r\n-\r\n-    public Object copy(Object orig) {\r\n-        // used to store fields for rollback; we don't store lrs fields\r\n-        return null;\r\n-    }\r\n-\r\n-    public boolean add(Object o) {\r\n-        Proxies.assertAllowedType(o, _elementType);\r\n-        Proxies.dirty(this);\r\n-        _ct.added(o);\r\n-        return true;\r\n-    }\r\n-\r\n-    public boolean addAll(Collection all) {\r\n-        Proxies.dirty(this);\r\n-        boolean added = false;\r\n-        Object add;\r\n-        for (Iterator itr = all.iterator(); itr.hasNext();) {\r\n-            add = itr.next();\r\n-            Proxies.assertAllowedType(add, _elementType);\r\n-            _ct.added(add);\r\n-            added = true;\r\n-        }\r\n-        return added;\r\n-    }\r\n-\r\n-    public boolean remove(Object o) {\r\n-        if (!contains(o))\r\n-            return false;\r\n-        Proxies.dirty(this);\r\n-        Proxies.removed(this, o, false);\r\n-        _ct.removed(o);\r\n-        return true;\r\n-    }\r\n-\r\n-    public boolean removeAll(Collection all) {\r\n-        Proxies.dirty(this);\r\n-        boolean removed = false;\r\n-        Object rem;\r\n-        for (Iterator itr = all.iterator(); itr.hasNext();) {\r\n-            rem = itr.next();\r\n-            if (remove(rem)) {\r\n-                Proxies.removed(this, rem, false);\r\n-                _ct.removed(rem);\r\n-                removed = true;\r\n-            }\r\n-        }\r\n-        return removed;\r\n-    }\r\n-\r\n-    public boolean retainAll(Collection all) {\r\n-        if (all.isEmpty()) {\r\n-            clear();\r\n-            return true;\r\n-        }\r\n-        Proxies.dirty(this);\r\n-        Itr itr = (Itr) iterator();\r\n-        try {\r\n-            boolean removed = false;\r\n-            Object rem;\r\n-            while (itr.hasNext()) {\r\n-                rem = itr.next();\r\n-                if (!all.contains(rem)) {\r\n-                    Proxies.removed(this, rem, false);\r\n-                    _ct.removed(rem);\r\n-                    removed = true;\r\n-                }\r\n-            }\r\n-            return removed;\r\n-        }\r\n-        finally {\r\n-            itr.close();\r\n-        }\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        Proxies.dirty(this);\r\n-        Itr itr = (Itr) iterator();\r\n-        try {\r\n-            Object rem;\r\n-            while (itr.hasNext()) {\r\n-                rem = itr.next();\r\n-                Proxies.removed(this, rem, false);\r\n-                _ct.removed(rem);\r\n-            }\r\n-        }\r\n-        finally {\r\n-            itr.close();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean contains(Object o) {\r\n-        if (_elementType != null && !_elementType.isInstance(o))\r\n-            return false;\r\n-        if (_ct.getAdded().contains(o))\r\n-            return true;\r\n-        if (_ct.getRemoved().contains(o))\r\n-            return false;\r\n-        if (!has(o))\r\n-            return false;\r\n-        return true;\r\n-    }\r\n-\r\n-    public boolean containsAll(Collection all) {\r\n-        for (Iterator itr = all.iterator(); itr.hasNext();)\r\n-            if (!contains(itr.next()))\r\n-                return false;\r\n-        return true;\r\n-    }\r\n-\r\n-    public Object[] toArray() {\r\n-        return asList().toArray();\r\n-    }\r\n-\r\n-    public Object[] toArray(Object[] a) {\r\n-        return asList().toArray(a);\r\n-    }\r\n-\r\n-    private List asList() {\r\n-        Itr itr = (Itr) iterator();\r\n-        try {\r\n-            List list = new ArrayList();\r\n-            while (itr.hasNext())\r\n-                list.add(itr.next());\r\n-            return list;\r\n-        }\r\n-        finally {\r\n-            itr.close();\r\n-        }\r\n-    }\r\n-\r\n-    public int size() {\r\n-        if (_count == -1)\r\n-            _count = count();\r\n-        if (_count == Integer.MAX_VALUE)\r\n-            return _count;\r\n-        return _count + _ct.getAdded().size() - _ct.getRemoved().size();\r\n-    }\r\n-\r\n-    public boolean isEmpty() {\r\n-        return size() == 0;\r\n-    }\r\n-\r\n-    public Iterator iterator() {\r\n-        _iterated = true;\r\n-        IteratorChain chain = new IteratorChain();\r\n-        chain.addIterator(new FilterIterator(itr(), this));\r\n-        // note have to copy _ct.getAdded to prevent concurrent mod errors\r\n-        chain.addIterator(new ArrayList(_ct.getAdded()).iterator());\r\n-        return new Itr(chain);\r\n-    }\r\n-\r\n-    /**\r\n-     * used in testing; we need to be able to make sure that OpenJPA does not\r\n-     * iterate lrs fields during standard crud operations\r\n-     */\r\n-    boolean isIterated() {\r\n-        return _iterated;\r\n-    }\r\n-\r\n-    /**\r\n-     * used in testing; we need to be able to make sure that OpenJPA does not\r\n-     * iterate lrs fields during standard crud operations\r\n-     */\r\n-    void setIterated(boolean it) {\r\n-        _iterated = it;\r\n-    }\r\n-\r\n-    protected Object writeReplace() throws ObjectStreamException {\r\n-        return asList();\r\n-    }\r\n-\r\n-    /**\r\n-     * Implement this method to return an iterator over the contents of the\r\n-     * collection. This method may be invoked multiple times. The returned\r\n-     * iterator does not have to support the {@link Iterator#remove} method,\r\n-     * and may implement {@link org.apache.openjpa.lib.util.Closeable}.\r\n-     */\r\n-    protected abstract Iterator itr();\r\n-\r\n-    /**\r\n-     * Return whether the collection contains the given element.\r\n-     */\r\n-    protected abstract boolean has(Object o);\r\n-\r\n-    /**\r\n-     * Return the number of elements in the collection, or\r\n-     * {@link Integer#MAX_VALUE}.\r\n-     */\r\n-    protected abstract int count();\r\n-\r\n-    ////////////////////////////\r\n-    // Predicate Implementation\r\n-    ////////////////////////////\r\n-    public boolean evaluate(Object o) {\r\n-        return !_ct.getRemoved().contains(o);\r\n-    }\r\n-\r\n-    //////////////////////////////////////////\r\n-    // CollectionChangeTracker Implementation\r\n-    //////////////////////////////////////////\r\n-    public boolean isTracking() {\r\n-        return _ct.isTracking();\r\n-    }\r\n-\r\n-    public void startTracking() {\r\n-        _ct.startTracking();\r\n-        reset();\r\n-    }\r\n-\r\n-    public void stopTracking() {\r\n-        _ct.stopTracking();\r\n-        reset();\r\n-    }\r\n-\r\n-    private void reset() {\r\n-        if (_count != Integer.MAX_VALUE)\r\n-            _count = -1;\r\n-    }\r\n-\r\n-    public Collection getAdded() {\r\n-        return _ct.getAdded();\r\n-    }\r\n-\r\n-    public Collection getRemoved() {\r\n-        return _ct.getRemoved();\r\n-    }\r\n-\r\n-    public Collection getChanged() {\r\n-        return _ct.getChanged();\r\n-    }\r\n-\r\n-    public void added(Object val) {\r\n-        _ct.added(val);\r\n-    }\r\n-\r\n-    public void removed(Object val) {\r\n-        _ct.removed(val);\r\n-    }\r\n-\r\n-    public int getNextSequence() {\r\n-        return _ct.getNextSequence();\r\n-    }\r\n-\r\n-    public void setNextSequence(int seq) {\r\n-        _ct.setNextSequence(seq);\r\n-    }\r\n-\r\n-    /**\r\n-     * Wrapper around our filtering iterator chain.\r\n-     */\r\n-    private class Itr implements Iterator, Closeable {\r\n-\r\n-        private static final int OPEN = 0;\r\n-        private static final int LAST_ELEM = 1;\r\n-        private static final int CLOSED = 2;\r\n-        private final IteratorChain _itr;\r\n-        private Object _last = null;\r\n-        private int _state = OPEN;\r\n-\r\n-        public Itr(IteratorChain itr) {\r\n-            _itr = itr;\r\n-        }\r\n-\r\n-        public boolean hasNext() {\r\n-            if (_state == CLOSED)\r\n-                return false;\r\n-            // close automatically if no more elements\r\n-            if (!_itr.hasNext()) {\r\n-                free();\r\n-                _state = LAST_ELEM;\r\n-                return false;\r\n-            }\r\n-            return true;\r\n-        }\r\n-\r\n-        public Object next() {\r\n-            if (_state != OPEN)\r\n-                throw new NoSuchElementException();\r\n-            _last = _itr.next();\r\n-            return _last;\r\n-        }\r\n-\r\n-        public void remove() {\r\n-            if (_state == CLOSED || _last == null)\r\n-                throw new NoSuchElementException();\r\n-            Proxies.dirty(AbstractLRSProxyCollection.this);\r\n-            _ct.removed(_last);\r\n-            Proxies.removed(AbstractLRSProxyCollection.this, _last, false);\r\n-            _last = null;\r\n-        }\r\n-\r\n-        public void close() {\r\n-            free();\r\n-            _state = CLOSED;\r\n-        }\r\n-\r\n-        private void free() {\r\n-            if (_state != OPEN)\r\n-                return;\r\n-            List itrs = _itr.getIterators();\r\n-            Iterator itr;\r\n-            for (int i = 0; i < itrs.size(); i++) {\r\n-                itr = (Iterator) itrs.get(i);\r\n-                if (itr instanceof FilterIterator)\r\n-                    itr = ((FilterIterator) itr).getIterator();\r\n-                ImplHelper.close(itr);\r\n-            }\r\n-        }\r\n-\r\n-        protected void finalize() {\r\n-            close();\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.ObjectStreamException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.iterators.FilterIterator;\n+import org.apache.commons.collections.iterators.IteratorChain;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.lib.util.Closeable;\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+/**\n+ * <p>A collection proxy designed for collections backed by extremely large\n+ * result sets in which each call to {@link #iterator} may perform a database\n+ * query.  Changes to the collection are tracked through a\n+ * {@link ChangeTracker}.  This collection has the following limitations:\n+ * <ul>\n+ * <li>The <code>size</code> method may return {@link Integer#MAX_VALUE}.</li>\n+ * <li>The collection cannot contain duplicate elements.</li>\n+ * </ul></p>\n+ *\n+ * @author Abe White\n+ */\n+public abstract class AbstractLRSProxyCollection\n+    implements Set, LRSProxy, Predicate, CollectionChangeTracker {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (AbstractLRSProxyCollection.class);\n+\n+    private Class _elementType = null;\n+    private CollectionChangeTrackerImpl _ct = null;\n+    private OpenJPAStateManager _sm = null;\n+    private int _field = -1;\n+    private OpenJPAStateManager _origOwner = null;\n+    private int _origField = -1;\n+    private int _count = -1;\n+    private boolean _iterated = false;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param    elementType        the allowed type of elements, or null for no\n+     * restrictions\n+     * @param    ordered            true if this collection is ordered\n+     */\n+    public AbstractLRSProxyCollection(Class elementType, boolean ordered,\n+        OpenJPAConfiguration conf) {\n+        _elementType = elementType;\n+        _ct = new CollectionChangeTrackerImpl(this, false, ordered, conf);\n+        _ct.setAutoOff(false);\n+    }\n+\n+    public void setOwner(OpenJPAStateManager sm, int field) {\n+        // can't transfer ownership of an lrs proxy\n+        if (sm != null && _origOwner != null\n+            && (_origOwner != sm || _origField != field)) {\n+            throw new InvalidStateException(_loc.get(\"transfer-lrs\",\n+                _origOwner.getMetaData().getField(_origField)));\n+        }\n+\n+        _sm = sm;\n+        _field = field;\n+\n+        // keep track of original owner so we can detect transfer attempts\n+        if (sm != null) {\n+            _origOwner = sm;\n+            _origField = field;\n+        }\n+    }\n+\n+    public OpenJPAStateManager getOwner() {\n+        return _sm;\n+    }\n+\n+    public int getOwnerField() {\n+        return _field;\n+    }\n+\n+    public ChangeTracker getChangeTracker() {\n+        return this;\n+    }\n+\n+    public Object copy(Object orig) {\n+        // used to store fields for rollback; we don't store lrs fields\n+        return null;\n+    }\n+\n+    public boolean add(Object o) {\n+        Proxies.assertAllowedType(o, _elementType);\n+        Proxies.dirty(this);\n+        _ct.added(o);\n+        return true;\n+    }\n+\n+    public boolean addAll(Collection all) {\n+        Proxies.dirty(this);\n+        boolean added = false;\n+        Object add;\n+        for (Iterator itr = all.iterator(); itr.hasNext();) {\n+            add = itr.next();\n+            Proxies.assertAllowedType(add, _elementType);\n+            _ct.added(add);\n+            added = true;\n+        }\n+        return added;\n+    }\n+\n+    public boolean remove(Object o) {\n+        if (!contains(o))\n+            return false;\n+        Proxies.dirty(this);\n+        Proxies.removed(this, o, false);\n+        _ct.removed(o);\n+        return true;\n+    }\n+\n+    public boolean removeAll(Collection all) {\n+        Proxies.dirty(this);\n+        boolean removed = false;\n+        Object rem;\n+        for (Iterator itr = all.iterator(); itr.hasNext();) {\n+            rem = itr.next();\n+            if (remove(rem)) {\n+                Proxies.removed(this, rem, false);\n+                _ct.removed(rem);\n+                removed = true;\n+            }\n+        }\n+        return removed;\n+    }\n+\n+    public boolean retainAll(Collection all) {\n+        if (all.isEmpty()) {\n+            clear();\n+            return true;\n+        }\n+\n+        Proxies.dirty(this);\n+        Itr itr = (Itr) iterator();\n+        try {\n+            boolean removed = false;\n+            Object rem;\n+            while (itr.hasNext()) {\n+                rem = itr.next();\n+                if (!all.contains(rem)) {\n+                    Proxies.removed(this, rem, false);\n+                    _ct.removed(rem);\n+                    removed = true;\n+                }\n+            }\n+            return removed;\n+        }\n+        finally {\n+            itr.close();\n+        }\n+    }\n+\n+    public void clear() {\n+        Proxies.dirty(this);\n+        Itr itr = (Itr) iterator();\n+        try {\n+            Object rem;\n+            while (itr.hasNext()) {\n+                rem = itr.next();\n+                Proxies.removed(this, rem, false);\n+                _ct.removed(rem);\n+            }\n+        }\n+        finally {\n+            itr.close();\n+        }\n+    }\n+\n+    public boolean contains(Object o) {\n+        if (_elementType != null && !_elementType.isInstance(o))\n+            return false;\n+        if (_ct.getAdded().contains(o))\n+            return true;\n+        if (_ct.getRemoved().contains(o))\n+            return false;\n+        if (!has(o))\n+            return false;\n+        return true;\n+    }\n+\n+    public boolean containsAll(Collection all) {\n+        for (Iterator itr = all.iterator(); itr.hasNext();)\n+            if (!contains(itr.next()))\n+                return false;\n+        return true;\n+    }\n+\n+    public Object[] toArray() {\n+        return asList().toArray();\n+    }\n+\n+    public Object[] toArray(Object[] a) {\n+        return asList().toArray(a);\n+    }\n+\n+    private List asList() {\n+        Itr itr = (Itr) iterator();\n+        try {\n+            List list = new ArrayList();\n+            while (itr.hasNext())\n+                list.add(itr.next());\n+            return list;\n+        }\n+        finally {\n+            itr.close();\n+        }\n+    }\n+\n+    public int size() {\n+        if (_count == -1)\n+            _count = count();\n+        if (_count == Integer.MAX_VALUE)\n+            return _count;\n+        return _count + _ct.getAdded().size() - _ct.getRemoved().size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    public Iterator iterator() {\n+        _iterated = true;\n+\n+        IteratorChain chain = new IteratorChain();\n+        chain.addIterator(new FilterIterator(itr(), this));\n+\n+        // note have to copy _ct.getAdded to prevent concurrent mod errors\n+        chain.addIterator(new ArrayList(_ct.getAdded()).iterator());\n+        return new Itr(chain);\n+    }\n+\n+    /**\n+     * used in testing; we need to be able to make sure that OpenJPA does not\n+     * iterate lrs fields during standard crud operations\n+     */\n+    boolean isIterated() {\n+        return _iterated;\n+    }\n+\n+    /**\n+     * used in testing; we need to be able to make sure that OpenJPA does not\n+     * iterate lrs fields during standard crud operations\n+     */\n+    void setIterated(boolean it) {\n+        _iterated = it;\n+    }\n+\n+    protected Object writeReplace()\n+        throws ObjectStreamException {\n+        return asList();\n+    }\n+\n+    /**\n+     * Implement this method to return an iterator over the contents of the\n+     * collection.  This method may be invoked multiple times.  The returned\n+     * iterator does not have to support the {@link Iterator#remove} method,\n+     * and may implement {@link org.apache.openjpa.lib.util.Closeable}.\n+     */\n+    protected abstract Iterator itr();\n+\n+    /**\n+     * Return whether the collection contains the given element.\n+     */\n+    protected abstract boolean has(Object o);\n+\n+    /**\n+     * Return the number of elements in the collection, or\n+     * {@link Integer#MAX_VALUE}.\n+     */\n+    protected abstract int count();\n+\n+    ////////////////////////////\n+    // Predicate Implementation\n+    ////////////////////////////\n+\n+    public boolean evaluate(Object o) {\n+        return !_ct.getRemoved().contains(o);\n+    }\n+\n+    //////////////////////////////////////////\n+    // CollectionChangeTracker Implementation\n+    //////////////////////////////////////////\n+\n+    public boolean isTracking() {\n+        return _ct.isTracking();\n+    }\n+\n+    public void startTracking() {\n+        _ct.startTracking();\n+        reset();\n+    }\n+\n+    public void stopTracking() {\n+        _ct.stopTracking();\n+        reset();\n+    }\n+\n+    private void reset() {\n+        if (_count != Integer.MAX_VALUE)\n+            _count = -1;\n+    }\n+\n+    public Collection getAdded() {\n+        return _ct.getAdded();\n+    }\n+\n+    public Collection getRemoved() {\n+        return _ct.getRemoved();\n+    }\n+\n+    public Collection getChanged() {\n+        return _ct.getChanged();\n+    }\n+\n+    public void added(Object val) {\n+        _ct.added(val);\n+    }\n+\n+    public void removed(Object val) {\n+        _ct.removed(val);\n+    }\n+\n+    public int getNextSequence() {\n+        return _ct.getNextSequence();\n+    }\n+\n+    public void setNextSequence(int seq) {\n+        _ct.setNextSequence(seq);\n+    }\n+\n+    /**\n+     *\tWrapper around our filtering iterator chain.\n+     */\n+    private class Itr\n+        implements Iterator, Closeable {\n+\n+        private static final int OPEN = 0;\n+        private static final int LAST_ELEM = 1;\n+        private static final int CLOSED = 2;\n+\n+        private final IteratorChain _itr;\n+        private Object _last = null;\n+        private int _state = OPEN;\n+\n+        public Itr(IteratorChain itr) {\n+            _itr = itr;\n+        }\n+\n+        public boolean hasNext() {\n+            if (_state == CLOSED)\n+                return false;\n+\n+            // close automatically if no more elements\n+            if (!_itr.hasNext()) {\n+                free();\n+                _state = LAST_ELEM;\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        public Object next() {\n+            if (_state != OPEN)\n+                throw new NoSuchElementException();\n+            _last = _itr.next();\n+            return _last;\n+        }\n+\n+        public void remove() {\n+            if (_state == CLOSED || _last == null)\n+                throw new NoSuchElementException();\n+            Proxies.dirty(AbstractLRSProxyCollection.this);\n+            _ct.removed(_last);\n+            Proxies.removed(AbstractLRSProxyCollection.this, _last, false);\n+            _last = null;\n+        }\n+\n+        public void close() {\n+            free();\n+            _state = CLOSED;\n+        }\n+\n+        private void free() {\n+            if (_state != OPEN)\n+                return;\n+\n+            List itrs = _itr.getIterators();\n+            Iterator itr;\n+            for (int i = 0; i < itrs.size(); i++) {\n+                itr = (Iterator) itrs.get(i);\n+                if (itr instanceof FilterIterator)\n+                    itr = ((FilterIterator) itr).getIterator();\n+                ImplHelper.close(itr);\n+            }\n+        }\n+\n+        protected void finalize() {\n+            close();\n+\t\t}\n+\t}\n+}"},{"sha":"6ddab4c425964167898a8a683d9da765bdba20e3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyMap.java","status":"modified","additions":526,"deletions":504,"changes":1030,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyMap.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyMap.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,504 +1,526 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.util.AbstractCollection;\r\n-import java.util.AbstractSet;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.NoSuchElementException;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.commons.collections.Predicate;\r\n-import org.apache.commons.collections.iterators.FilterIterator;\r\n-import org.apache.commons.collections.iterators.IteratorChain;\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.lib.util.Closeable;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-\r\n-/**\r\n- * A map proxy designed for maps backed by extremely large result sets in\r\n- * which each call to {@link #get} or {@link #containsKey} may perform a\r\n- * database query. Changes to the map are tracked through a\r\n- * {@link ChangeTracker}. This map has the following limitations:\r\n- * <ul>\r\n- * <li>The <code>size</code> method may return {@link Integer#MAX_VALUE}.</li>\r\n- * <li>Null keys and values are not supported.</li>\r\n- * </ul>\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public abstract class AbstractLRSProxyMap\r\n-    implements Map, LRSProxy, MapChangeTracker, Predicate {\r\n-\r\n-    private static final int MODE_KEY = 0;\r\n-    private static final int MODE_VALUE = 1;\r\n-    private static final int MODE_ENTRY = 2;\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (AbstractLRSProxyMap.class);\r\n-    private Class _keyType = null;\r\n-    private Class _valueType = null;\r\n-    private MapChangeTrackerImpl _ct = null;\r\n-    private OpenJPAStateManager _sm = null;\r\n-    private int _field = -1;\r\n-    private OpenJPAStateManager _origOwner = null;\r\n-    private int _origField = -1;\r\n-    private Map _map = null;\r\n-    private int _count = -1;\r\n-    private boolean _iterated = false;\r\n-\r\n-    public AbstractLRSProxyMap(Class keyType, Class valueType,\r\n-        OpenJPAConfiguration conf) {\r\n-        _keyType = keyType;\r\n-        _valueType = valueType;\r\n-        _ct = new MapChangeTrackerImpl(this, conf);\r\n-        _ct.setAutoOff(false);\r\n-    }\r\n-\r\n-    public void setOwner(OpenJPAStateManager sm, int field) {\r\n-        // can't transfer ownership of an lrs proxy\r\n-        if (sm != null && _origOwner != null\r\n-            && (_origOwner != sm || _origField != field)) {\r\n-            throw new InvalidStateException(_loc.get(\"transfer-lrs\",\r\n-                _origOwner.getMetaData().getField(_origField)));\r\n-        }\r\n-        _sm = sm;\r\n-        _field = field;\r\n-        // keep track of original owner so we can detect transfer attempts\r\n-        if (sm != null) {\r\n-            _origOwner = sm;\r\n-            _origField = field;\r\n-        }\r\n-    }\r\n-\r\n-    public OpenJPAStateManager getOwner() {\r\n-        return _sm;\r\n-    }\r\n-\r\n-    public int getOwnerField() {\r\n-        return _field;\r\n-    }\r\n-\r\n-    public ChangeTracker getChangeTracker() {\r\n-        return this;\r\n-    }\r\n-\r\n-    public Object copy(Object orig) {\r\n-        // used to store fields for rollbac; we don't store lrs fields\r\n-        return null;\r\n-    }\r\n-\r\n-    /**\r\n-     * used in testing; we need to be able to make sure that OpenJPA does not\r\n-     * iterate lrs fields during standard crud operations\r\n-     */\r\n-    boolean isIterated() {\r\n-        return _iterated;\r\n-    }\r\n-\r\n-    /**\r\n-     * used in testing; we need to be able to make sure that OpenJPA does not\r\n-     * iterate lrs fields during standard crud operations\r\n-     */\r\n-    void setIterated(boolean it) {\r\n-        _iterated = it;\r\n-    }\r\n-\r\n-    public int size() {\r\n-        if (_count == -1)\r\n-            _count = count();\r\n-        if (_count == Integer.MAX_VALUE)\r\n-            return _count;\r\n-        return _count + _ct.getAdded().size() - _ct.getRemoved().size();\r\n-    }\r\n-\r\n-    public boolean isEmpty() {\r\n-        return size() == 0;\r\n-    }\r\n-\r\n-    public boolean containsKey(Object key) {\r\n-        if (_keyType != null && !_keyType.isInstance(key))\r\n-            return false;\r\n-        if (_map != null && _map.containsKey(key))\r\n-            return true;\r\n-        if (_ct.getTrackKeys()) {\r\n-            if (_ct.getRemoved().contains(key))\r\n-                return false;\r\n-            return hasKey(key);\r\n-        }\r\n-        // value tracking:\r\n-        // if we've removed values, we need to see if this key represents\r\n-        // a removed instance. otherwise we can rely on the 1-1 between\r\n-        // keys and values when using value tracking\r\n-        if (_ct.getRemoved().isEmpty())\r\n-            return hasKey(key);\r\n-        return get(key) != null;\r\n-    }\r\n-\r\n-    public boolean containsValue(Object val) {\r\n-        if (_valueType != null && !_valueType.isInstance(val))\r\n-            return false;\r\n-        if (_map != null && _map.containsValue(val))\r\n-            return true;\r\n-        if (!_ct.getTrackKeys()) {\r\n-            if (_ct.getRemoved().contains(val))\r\n-                return false;\r\n-            return hasValue(val);\r\n-        }\r\n-        // key tracking\r\n-        Collection keys = keys(val);\r\n-        if (keys == null || keys.isEmpty())\r\n-            return false;\r\n-        keys.removeAll(_ct.getRemoved());\r\n-        keys.removeAll(_ct.getChanged());\r\n-        return keys.size() > 0;\r\n-    }\r\n-\r\n-    public Object get(Object key) {\r\n-        if (_keyType != null && !_keyType.isInstance(key))\r\n-            return null;\r\n-        Object ret = (_map == null) ? null : _map.get(key);\r\n-        if (ret != null)\r\n-            return ret;\r\n-        if (_ct.getTrackKeys() && _ct.getRemoved().contains(key))\r\n-            return null;\r\n-        Object val = value(key);\r\n-        if (!_ct.getTrackKeys() && _ct.getRemoved().contains(val))\r\n-            return null;\r\n-        return val;\r\n-    }\r\n-\r\n-    public Object put(Object key, Object value) {\r\n-        Proxies.assertAllowedType(key, _keyType);\r\n-        Proxies.assertAllowedType(value, _valueType);\r\n-        Proxies.dirty(this);\r\n-        if (_map == null)\r\n-            _map = new HashMap();\r\n-        Object old = _map.put(key, value);\r\n-        if (old == null && (!_ct.getTrackKeys()\r\n-            || !_ct.getRemoved().contains(key)))\r\n-            old = value(key);\r\n-        if (old != null) {\r\n-            _ct.changed(key, old, value);\r\n-            Proxies.removed(this, old, false);\r\n-        } else _ct.added(key, value);\r\n-        return old;\r\n-    }\r\n-\r\n-    public void putAll(Map m) {\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = m.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            put(entry.getKey(), entry.getValue());\r\n-        }\r\n-    }\r\n-\r\n-    public Object remove(Object key) {\r\n-        Proxies.dirty(this);\r\n-        Object old = (_map == null) ? null : _map.remove(key);\r\n-        if (old == null && (!_ct.getTrackKeys()\r\n-            || !_ct.getRemoved().contains(key)))\r\n-            old = value(key);\r\n-        if (old != null) {\r\n-            _ct.removed(key, old);\r\n-            Proxies.removed(this, key, true);\r\n-            Proxies.removed(this, old, false);\r\n-        }\r\n-        return old;\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        Proxies.dirty(this);\r\n-        Itr itr = iterator(MODE_ENTRY);\r\n-        try {\r\n-            Map.Entry entry;\r\n-            while (itr.hasNext()) {\r\n-                entry = (Map.Entry) itr.next();\r\n-                Proxies.removed(this, entry.getKey(), true);\r\n-                Proxies.removed(this, entry.getValue(), false);\r\n-                _ct.removed(entry.getKey(), entry.getValue());\r\n-            }\r\n-        }\r\n-        finally {\r\n-            itr.close();\r\n-        }\r\n-    }\r\n-\r\n-    public Set keySet() {\r\n-        return new AbstractSet() {\r\n-            public int size() {\r\n-                return AbstractLRSProxyMap.this.size();\r\n-            }\r\n-\r\n-            public boolean remove(Object o) {\r\n-                return AbstractLRSProxyMap.this.remove(o) != null;\r\n-            }\r\n-\r\n-            public Iterator iterator() {\r\n-                return AbstractLRSProxyMap.this.iterator(MODE_KEY);\r\n-            }\r\n-        };\r\n-    }\r\n-\r\n-    public Collection values() {\r\n-        return new AbstractCollection() {\r\n-            public int size() {\r\n-                return AbstractLRSProxyMap.this.size();\r\n-            }\r\n-\r\n-            public Iterator iterator() {\r\n-                return AbstractLRSProxyMap.this.iterator(MODE_VALUE);\r\n-            }\r\n-        };\r\n-    }\r\n-\r\n-    public Set entrySet() {\r\n-        return new AbstractSet() {\r\n-            public int size() {\r\n-                return AbstractLRSProxyMap.this.size();\r\n-            }\r\n-\r\n-            public Iterator iterator() {\r\n-                return AbstractLRSProxyMap.this.iterator(MODE_ENTRY);\r\n-            }\r\n-        };\r\n-    }\r\n-\r\n-    protected Object writeReplace() throws ObjectStreamException {\r\n-        Itr itr = iterator(MODE_ENTRY);\r\n-        try {\r\n-            Map map = new HashMap();\r\n-            Map.Entry entry;\r\n-            while (itr.hasNext()) {\r\n-                entry = (Map.Entry) itr.next();\r\n-                map.put(entry.getKey(), entry.getValue());\r\n-            }\r\n-            return map;\r\n-        }\r\n-        finally {\r\n-            itr.close();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Return whether the given key exists in the map.\r\n-     */\r\n-    protected abstract boolean hasKey(Object key);\r\n-\r\n-    /**\r\n-     * Return whether the given value exists in the map.\r\n-     */\r\n-    protected abstract boolean hasValue(Object value);\r\n-\r\n-    /**\r\n-     * Return all keys for the given value.\r\n-     */\r\n-    protected abstract Collection keys(Object value);\r\n-\r\n-    /**\r\n-     * Return the value of the given key.\r\n-     */\r\n-    protected abstract Object value(Object key);\r\n-\r\n-    /**\r\n-     * Implement this method to return an iterator over the entries\r\n-     * in the map. Each returned object must implement the\r\n-     * <code>Map.Entry</code> interface. This method may be invoked multiple\r\n-     * times. The iterator does not have to support the\r\n-     * {@link Iterator#remove} method, and may implement\r\n-     * {@link org.apache.openjpa.lib.util.Closeable}.\r\n-     */\r\n-    protected abstract Iterator itr();\r\n-\r\n-    /**\r\n-     * Return the number of entries in the map, or {@link Integer#MAX_VALUE}.\r\n-     */\r\n-    protected abstract int count();\r\n-\r\n-    private Itr iterator(int mode) {\r\n-        _iterated = true;\r\n-        // have to copy the entry set of _map to prevent concurrent mod errors\r\n-        IteratorChain chain = new IteratorChain();\r\n-        if (_map != null)\r\n-            chain.addIterator(new ArrayList(_map.entrySet()).iterator());\r\n-        chain.addIterator(new FilterIterator(itr(), this));\r\n-        return new Itr(mode, chain);\r\n-    }\r\n-\r\n-    ////////////////////////////\r\n-    // Predicate Implementation\r\n-    ////////////////////////////\r\n-    public boolean evaluate(Object obj) {\r\n-        Map.Entry entry = (Map.Entry) obj;\r\n-        return (_ct.getTrackKeys()\r\n-            && !_ct.getRemoved().contains(entry.getKey())\r\n-            || (!_ct.getTrackKeys()\r\n-            && !_ct.getRemoved().contains(entry.getValue())))\r\n-            && (_map == null || !_map.containsKey(entry.getKey()));\r\n-    }\r\n-\r\n-    ///////////////////////////////////\r\n-    // MapChangeTracker Implementation\r\n-    ///////////////////////////////////\r\n-    public boolean isTracking() {\r\n-        return _ct.isTracking();\r\n-    }\r\n-\r\n-    public void startTracking() {\r\n-        _ct.startTracking();\r\n-        reset();\r\n-    }\r\n-\r\n-    public void stopTracking() {\r\n-        _ct.stopTracking();\r\n-        reset();\r\n-    }\r\n-\r\n-    private void reset() {\r\n-        if (_map != null)\r\n-            _map.clear();\r\n-        if (_count != Integer.MAX_VALUE)\r\n-            _count = -1;\r\n-    }\r\n-\r\n-    public boolean getTrackKeys() {\r\n-        return _ct.getTrackKeys();\r\n-    }\r\n-\r\n-    public void setTrackKeys(boolean keys) {\r\n-        _ct.setTrackKeys(keys);\r\n-    }\r\n-\r\n-    public Collection getAdded() {\r\n-        return _ct.getAdded();\r\n-    }\r\n-\r\n-    public Collection getRemoved() {\r\n-        return _ct.getRemoved();\r\n-    }\r\n-\r\n-    public Collection getChanged() {\r\n-        return _ct.getChanged();\r\n-    }\r\n-\r\n-    public void added(Object key, Object val) {\r\n-        _ct.added(key, val);\r\n-    }\r\n-\r\n-    public void removed(Object key, Object val) {\r\n-        _ct.removed(key, val);\r\n-    }\r\n-\r\n-    public void changed(Object key, Object orig, Object val) {\r\n-        _ct.changed(key, orig, val);\r\n-    }\r\n-\r\n-    public int getNextSequence() {\r\n-        return _ct.getNextSequence();\r\n-    }\r\n-\r\n-    public void setNextSequence(int seq) {\r\n-        _ct.setNextSequence(seq);\r\n-    }\r\n-\r\n-    /**\r\n-     * Wrapper around our filtering iterator chain.\r\n-     */\r\n-    private class Itr implements Iterator, Closeable {\r\n-\r\n-        private static final int OPEN = 0;\r\n-        private static final int LAST_ELEM = 1;\r\n-        private static final int CLOSED = 2;\r\n-        private final int _mode;\r\n-        private final IteratorChain _itr;\r\n-        private Map.Entry _last = null;\r\n-        private int _state = OPEN;\r\n-\r\n-        public Itr(int mode, IteratorChain itr) {\r\n-            _mode = mode;\r\n-            _itr = itr;\r\n-        }\r\n-\r\n-        public boolean hasNext() {\r\n-            if (_state != OPEN)\r\n-                return false;\r\n-            // close automatically if no more elements\r\n-            if (!_itr.hasNext()) {\r\n-                free();\r\n-                _state = LAST_ELEM;\r\n-                return false;\r\n-            }\r\n-            return true;\r\n-        }\r\n-\r\n-        public Object next() {\r\n-            if (_state != OPEN)\r\n-                throw new NoSuchElementException();\r\n-            _last = (Map.Entry) _itr.next();\r\n-            switch (_mode) {\r\n-                case MODE_KEY:\r\n-                    return _last.getKey();\r\n-                case MODE_VALUE:\r\n-                    return _last.getValue();\r\n-                default:\r\n-                    return _last;\r\n-            }\r\n-        }\r\n-\r\n-        public void remove() {\r\n-            if (_state == CLOSED || _last == null)\r\n-                throw new NoSuchElementException();\r\n-            Proxies.dirty(AbstractLRSProxyMap.this);\r\n-            Proxies.removed(AbstractLRSProxyMap.this, _last.getKey(), true);\r\n-            Proxies.removed(AbstractLRSProxyMap.this, _last.getValue(), false);\r\n-            // need to get a reference to the key before we remove it\r\n-            // from the map, since in JDK 1.3-, the act of removing an entry\r\n-            // from the map will also null the entry's value, which would\r\n-            // result in incorrectly passing a null to the change tracker\r\n-            Object key = _last.getKey();\r\n-            Object value = _last.getValue();\r\n-            if (_map != null)\r\n-                _map.remove(key);\r\n-            _ct.removed(key, value);\r\n-            _last = null;\r\n-        }\r\n-\r\n-        public void close() {\r\n-            free();\r\n-            _state = CLOSED;\r\n-        }\r\n-\r\n-        private void free() {\r\n-            if (_state != OPEN)\r\n-                return;\r\n-            List itrs = _itr.getIterators();\r\n-            Iterator itr;\r\n-            for (int i = 0; i < itrs.size(); i++) {\r\n-                itr = (Iterator) itrs.get(i);\r\n-                if (itr instanceof FilterIterator)\r\n-                    itr = ((FilterIterator) itr).getIterator();\r\n-                ImplHelper.close(itr);\r\n-            }\r\n-        }\r\n-\r\n-        protected void finalize() {\r\n-            close();\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.ObjectStreamException;\n+import java.util.AbstractCollection;\n+import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.iterators.FilterIterator;\n+import org.apache.commons.collections.iterators.IteratorChain;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.lib.util.Closeable;\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+/**\n+ * <p>A map proxy designed for maps backed by extremely large result sets in\n+ * which each call to {@link #get} or {@link #containsKey} may perform a\n+ * database query.  Changes to the map are tracked through a\n+ * {@link ChangeTracker}.  This map has the following limitations:\n+ * <ul>\n+ * <li>The <code>size</code> method may return {@link Integer#MAX_VALUE}.</li>\n+ * <li>Null keys and values are not supported.</li>\n+ * </ul></p>\n+ *\n+ * @author Abe White\n+ */\n+public abstract class AbstractLRSProxyMap\n+    implements Map, LRSProxy, MapChangeTracker, Predicate {\n+\n+    private static final int MODE_KEY = 0;\n+    private static final int MODE_VALUE = 1;\n+    private static final int MODE_ENTRY = 2;\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (AbstractLRSProxyMap.class);\n+\n+    private Class _keyType = null;\n+    private Class _valueType = null;\n+    private MapChangeTrackerImpl _ct = null;\n+    private OpenJPAStateManager _sm = null;\n+    private int _field = -1;\n+    private OpenJPAStateManager _origOwner = null;\n+    private int _origField = -1;\n+    private Map _map = null;\n+    private int _count = -1;\n+    private boolean _iterated = false;\n+\n+    public AbstractLRSProxyMap(Class keyType, Class valueType,\n+        OpenJPAConfiguration conf) {\n+        _keyType = keyType;\n+        _valueType = valueType;\n+        _ct = new MapChangeTrackerImpl(this, conf);\n+        _ct.setAutoOff(false);\n+    }\n+\n+    public void setOwner(OpenJPAStateManager sm, int field) {\n+        // can't transfer ownership of an lrs proxy\n+        if (sm != null && _origOwner != null\n+            && (_origOwner != sm || _origField != field)) {\n+            throw new InvalidStateException(_loc.get(\"transfer-lrs\",\n+                _origOwner.getMetaData().getField(_origField)));\n+        }\n+\n+        _sm = sm;\n+        _field = field;\n+\n+        // keep track of original owner so we can detect transfer attempts\n+        if (sm != null) {\n+            _origOwner = sm;\n+            _origField = field;\n+        }\n+    }\n+\n+    public OpenJPAStateManager getOwner() {\n+        return _sm;\n+    }\n+\n+    public int getOwnerField() {\n+        return _field;\n+    }\n+\n+    public ChangeTracker getChangeTracker() {\n+        return this;\n+    }\n+\n+    public Object copy(Object orig) {\n+        // used to store fields for rollbac; we don't store lrs fields\n+        return null;\n+    }\n+\n+    /**\n+     * used in testing; we need to be able to make sure that OpenJPA does not\n+     * iterate lrs fields during standard crud operations\n+     */\n+    boolean isIterated() {\n+        return _iterated;\n+    }\n+\n+    /**\n+     * used in testing; we need to be able to make sure that OpenJPA does not\n+     * iterate lrs fields during standard crud operations\n+     */\n+    void setIterated(boolean it) {\n+        _iterated = it;\n+    }\n+\n+    public int size() {\n+        if (_count == -1)\n+            _count = count();\n+        if (_count == Integer.MAX_VALUE)\n+            return _count;\n+        return _count + _ct.getAdded().size() - _ct.getRemoved().size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    public boolean containsKey(Object key) {\n+        if (_keyType != null && !_keyType.isInstance(key))\n+            return false;\n+        if (_map != null && _map.containsKey(key))\n+            return true;\n+        if (_ct.getTrackKeys()) {\n+            if (_ct.getRemoved().contains(key))\n+                return false;\n+            return hasKey(key);\n+        }\n+\n+        // value tracking:\n+        // if we've removed values, we need to see if this key represents\n+        // a removed instance. otherwise we can rely on the 1-1 between\n+        // keys and values when using value tracking\n+        if (_ct.getRemoved().isEmpty())\n+            return hasKey(key);\n+        return get(key) != null;\n+    }\n+\n+    public boolean containsValue(Object val) {\n+        if (_valueType != null && !_valueType.isInstance(val))\n+            return false;\n+        if (_map != null && _map.containsValue(val))\n+            return true;\n+        if (!_ct.getTrackKeys()) {\n+            if (_ct.getRemoved().contains(val))\n+                return false;\n+            return hasValue(val);\n+        }\n+\n+        // key tracking\n+        Collection keys = keys(val);\n+        if (keys == null || keys.isEmpty())\n+            return false;\n+        keys.removeAll(_ct.getRemoved());\n+        keys.removeAll(_ct.getChanged());\n+        return keys.size() > 0;\n+    }\n+\n+    public Object get(Object key) {\n+        if (_keyType != null && !_keyType.isInstance(key))\n+            return null;\n+        Object ret = (_map == null) ? null : _map.get(key);\n+        if (ret != null)\n+            return ret;\n+        if (_ct.getTrackKeys() && _ct.getRemoved().contains(key))\n+            return null;\n+        Object val = value(key);\n+        if (!_ct.getTrackKeys() && _ct.getRemoved().contains(val))\n+            return null;\n+        return val;\n+    }\n+\n+    public Object put(Object key, Object value) {\n+        Proxies.assertAllowedType(key, _keyType);\n+        Proxies.assertAllowedType(value, _valueType);\n+        Proxies.dirty(this);\n+        if (_map == null)\n+            _map = new HashMap();\n+        Object old = _map.put(key, value);\n+        if (old == null && (!_ct.getTrackKeys()\n+            || !_ct.getRemoved().contains(key)))\n+            old = value(key);\n+        if (old != null) {\n+            _ct.changed(key, old, value);\n+            Proxies.removed(this, old, false);\n+        } else\n+            _ct.added(key, value);\n+        return old;\n+    }\n+\n+    public void putAll(Map m) {\n+        Map.Entry entry;\n+        for (Iterator itr = m.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    public Object remove(Object key) {\n+        Proxies.dirty(this);\n+        Object old = (_map == null) ? null : _map.remove(key);\n+        if (old == null && (!_ct.getTrackKeys()\n+            || !_ct.getRemoved().contains(key)))\n+            old = value(key);\n+        if (old != null) {\n+            _ct.removed(key, old);\n+            Proxies.removed(this, key, true);\n+            Proxies.removed(this, old, false);\n+        }\n+        return old;\n+    }\n+\n+    public void clear() {\n+        Proxies.dirty(this);\n+        Itr itr = iterator(MODE_ENTRY);\n+        try {\n+            Map.Entry entry;\n+            while (itr.hasNext()) {\n+                entry = (Map.Entry) itr.next();\n+                Proxies.removed(this, entry.getKey(), true);\n+                Proxies.removed(this, entry.getValue(), false);\n+                _ct.removed(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        finally {\n+            itr.close();\n+        }\n+    }\n+\n+    public Set keySet() {\n+        return new AbstractSet() {\n+            public int size() {\n+                return AbstractLRSProxyMap.this.size();\n+            }\n+\n+            public boolean remove(Object o) {\n+                return AbstractLRSProxyMap.this.remove(o) != null;\n+            }\n+\n+            public Iterator iterator() {\n+                return AbstractLRSProxyMap.this.iterator(MODE_KEY);\n+            }\n+        };\n+    }\n+\n+    public Collection values() {\n+        return new AbstractCollection() {\n+            public int size() {\n+                return AbstractLRSProxyMap.this.size();\n+            }\n+\n+            public Iterator iterator() {\n+                return AbstractLRSProxyMap.this.iterator(MODE_VALUE);\n+            }\n+        };\n+    }\n+\n+    public Set entrySet() {\n+        return new AbstractSet() {\n+            public int size() {\n+                return AbstractLRSProxyMap.this.size();\n+            }\n+\n+            public Iterator iterator() {\n+                return AbstractLRSProxyMap.this.iterator(MODE_ENTRY);\n+            }\n+        };\n+    }\n+\n+    protected Object writeReplace()\n+        throws ObjectStreamException {\n+        Itr itr = iterator(MODE_ENTRY);\n+        try {\n+            Map map = new HashMap();\n+            Map.Entry entry;\n+            while (itr.hasNext()) {\n+                entry = (Map.Entry) itr.next();\n+                map.put(entry.getKey(), entry.getValue());\n+            }\n+            return map;\n+        }\n+        finally {\n+            itr.close();\n+        }\n+    }\n+\n+    /**\n+     * Return whether the given key exists in the map.\n+     */\n+    protected abstract boolean hasKey(Object key);\n+\n+    /**\n+     * Return whether the given value exists in the map.\n+     */\n+    protected abstract boolean hasValue(Object value);\n+\n+    /**\n+     * Return all keys for the given value.\n+     */\n+    protected abstract Collection keys(Object value);\n+\n+    /**\n+     * Return the value of the given key.\n+     */\n+    protected abstract Object value(Object key);\n+\n+    /**\n+     * Implement this method to return an iterator over the entries\n+     * in the map.  Each returned object must implement the\n+     * <code>Map.Entry</code> interface.  This method may be invoked multiple\n+     * times.  The iterator does not have to support the\n+     * {@link Iterator#remove} method, and may implement\n+     * {@link org.apache.openjpa.lib.util.Closeable}.\n+     */\n+    protected abstract Iterator itr();\n+\n+    /**\n+     * Return the number of entries in the map, or {@link Integer#MAX_VALUE}.\n+     */\n+    protected abstract int count();\n+\n+    private Itr iterator(int mode) {\n+        _iterated = true;\n+\n+        // have to copy the entry set of _map to prevent concurrent mod errors\n+        IteratorChain chain = new IteratorChain();\n+        if (_map != null)\n+            chain.addIterator(new ArrayList(_map.entrySet()).iterator());\n+        chain.addIterator(new FilterIterator(itr(), this));\n+        return new Itr(mode, chain);\n+    }\n+\n+    ////////////////////////////\n+    // Predicate Implementation\n+    ////////////////////////////\n+\n+    public boolean evaluate(Object obj) {\n+        Map.Entry entry = (Map.Entry) obj;\n+        return (_ct.getTrackKeys()\n+            && !_ct.getRemoved().contains(entry.getKey())\n+            || (!_ct.getTrackKeys()\n+            && !_ct.getRemoved().contains(entry.getValue())))\n+            && (_map == null || !_map.containsKey(entry.getKey()));\n+    }\n+\n+    ///////////////////////////////////\n+    // MapChangeTracker Implementation\n+    ///////////////////////////////////\n+\n+    public boolean isTracking() {\n+        return _ct.isTracking();\n+    }\n+\n+    public void startTracking() {\n+        _ct.startTracking();\n+        reset();\n+    }\n+\n+    public void stopTracking() {\n+        _ct.stopTracking();\n+        reset();\n+    }\n+\n+    private void reset() {\n+        if (_map != null)\n+            _map.clear();\n+        if (_count != Integer.MAX_VALUE)\n+            _count = -1;\n+    }\n+\n+    public boolean getTrackKeys() {\n+        return _ct.getTrackKeys();\n+    }\n+\n+    public void setTrackKeys(boolean keys) {\n+        _ct.setTrackKeys(keys);\n+    }\n+\n+    public Collection getAdded() {\n+        return _ct.getAdded();\n+    }\n+\n+    public Collection getRemoved() {\n+        return _ct.getRemoved();\n+    }\n+\n+    public Collection getChanged() {\n+        return _ct.getChanged();\n+    }\n+\n+    public void added(Object key, Object val) {\n+        _ct.added(key, val);\n+    }\n+\n+    public void removed(Object key, Object val) {\n+        _ct.removed(key, val);\n+    }\n+\n+    public void changed(Object key, Object orig, Object val) {\n+        _ct.changed(key, orig, val);\n+    }\n+\n+    public int getNextSequence() {\n+        return _ct.getNextSequence();\n+    }\n+\n+    public void setNextSequence(int seq) {\n+        _ct.setNextSequence(seq);\n+    }\n+\n+    /**\n+     *\tWrapper around our filtering iterator chain.\n+     */\n+    private class Itr\n+        implements Iterator, Closeable {\n+\n+        private static final int OPEN = 0;\n+        private static final int LAST_ELEM = 1;\n+        private static final int CLOSED = 2;\n+\n+        private final int _mode;\n+        private final IteratorChain _itr;\n+        private Map.Entry _last = null;\n+        private int _state = OPEN;\n+\n+        public Itr(int mode, IteratorChain itr) {\n+            _mode = mode;\n+            _itr = itr;\n+        }\n+\n+        public boolean hasNext() {\n+            if (_state != OPEN)\n+                return false;\n+\n+            // close automatically if no more elements\n+            if (!_itr.hasNext()) {\n+                free();\n+                _state = LAST_ELEM;\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        public Object next() {\n+            if (_state != OPEN)\n+                throw new NoSuchElementException();\n+\n+            _last = (Map.Entry) _itr.next();\n+            switch (_mode) {\n+                case MODE_KEY:\n+                    return _last.getKey();\n+                case MODE_VALUE:\n+                    return _last.getValue();\n+                default:\n+                    return _last;\n+            }\n+        }\n+\n+        public void remove() {\n+            if (_state == CLOSED || _last == null)\n+                throw new NoSuchElementException();\n+\n+            Proxies.dirty(AbstractLRSProxyMap.this);\n+            Proxies.removed(AbstractLRSProxyMap.this, _last.getKey(), true);\n+            Proxies.removed(AbstractLRSProxyMap.this, _last.getValue(), false);\n+\n+            // need to get a reference to the key before we remove it\n+            // from the map, since in JDK 1.3-, the act of removing an entry\n+            // from the map will also null the entry's value, which would\n+            // result in incorrectly passing a null to the change tracker\n+            Object key = _last.getKey();\n+            Object value = _last.getValue();\n+\n+            if (_map != null)\n+                _map.remove(key);\n+            _ct.removed(key, value);\n+            _last = null;\n+        }\n+\n+        public void close() {\n+            free();\n+            _state = CLOSED;\n+        }\n+\n+        private void free() {\n+            if (_state != OPEN)\n+                return;\n+\n+            List itrs = _itr.getIterators();\n+            Iterator itr;\n+            for (int i = 0; i < itrs.size(); i++) {\n+                itr = (Iterator) itrs.get(i);\n+                if (itr instanceof FilterIterator)\n+                    itr = ((FilterIterator) itr).getIterator();\n+                ImplHelper.close(itr);\n+            }\n+        }\n+\n+        protected void finalize() {\n+            close ();\n+\t\t}\n+\t}\n+}"},{"sha":"296b05165020704919512df3bd52df6d951bf859","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java","status":"modified","additions":513,"deletions":479,"changes":992,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,479 +1,513 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.lang.reflect.Field;\r\n-import java.lang.reflect.Method;\r\n-import java.lang.reflect.Modifier;\r\n-import java.util.Date;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.enhance.FieldManager;\r\n-import org.apache.openjpa.enhance.PCRegistry;\r\n-import org.apache.openjpa.enhance.PersistenceCapable;\r\n-import org.apache.openjpa.kernel.ObjectIdStateManager;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.StoreManager;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.meta.ValueStrategies;\r\n-import serp.util.Numbers;\r\n-\r\n-/**\r\n- * Utility class for manipulating application object ids.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class ApplicationIds {\r\n-\r\n-    /**\r\n-     * Return the primary key values for the given object id. The values\r\n-     * will be returned in the same order as the metadata primary key fields.\r\n-     */\r\n-    public static Object[] toPKValues(Object oid, ClassMetaData meta) {\r\n-        if (meta == null)\r\n-            return null;\r\n-        Object[] pks;\r\n-        if (meta.isOpenJPAIdentity()) {\r\n-            pks = new Object[1];\r\n-            if (oid != null)\r\n-                pks[0] = ((OpenJPAId) oid).getIdObject();\r\n-            return pks;\r\n-        }\r\n-        // reset owning 'meta' to the owner of the primary key fields, because\r\n-        // the one passed in might be a proxy, like for embedded mappings;\r\n-        // since getPrimaryKeyFields is guaranteed to return the primary\r\n-        // keys in the order of inheritance, we are guaranteed that\r\n-        // the last element will be the most-derived class.\r\n-        FieldMetaData[] fmds = meta.getPrimaryKeyFields();\r\n-        meta = fmds[fmds.length - 1].getDeclaringMetaData();\r\n-        pks = new Object[fmds.length];\r\n-        if (oid == null)\r\n-            return pks;\r\n-        if (!Modifier.isAbstract(meta.getDescribedType().getModifiers())) {\r\n-            // copy fields from the oid\r\n-            PrimaryKeyFieldManager consumer = new PrimaryKeyFieldManager();\r\n-            consumer.setStore(pks);\r\n-            PCRegistry.copyKeyFieldsFromObjectId(meta.getDescribedType(),\r\n-                consumer, oid);\r\n-            return consumer.getStore();\r\n-        }\r\n-        // default to reflection\r\n-        if (meta.isObjectIdTypeShared())\r\n-            oid = ((ObjectId) oid).getId();\r\n-        Class oidType = oid.getClass();\r\n-        try {\r\n-            Field field;\r\n-            Method meth;\r\n-            for (int i = 0; i < fmds.length; i++) {\r\n-                if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD) {\r\n-                    field = oidType.getField(fmds[i].getName());\r\n-                    pks[i] = field.get(oid);\r\n-                } else { // property\r\n-                    meth = ImplHelper.getGetter(oidType, fmds[i].getName());\r\n-                    pks[i] = meth.invoke(oid, (Object[]) null);\r\n-                }\r\n-            }\r\n-            return pks;\r\n-        } catch (OpenJPAException ke) {\r\n-            throw ke;\r\n-        } catch (Throwable t) {\r\n-            throw new GeneralException(t);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a new object id constructed from the given primary key values.\r\n-     */\r\n-    public static Object fromPKValues(Object[] pks, ClassMetaData meta) {\r\n-        if (meta == null || pks == null)\r\n-            return null;\r\n-        boolean convert = !meta.getRepository().getConfiguration().\r\n-            getCompatibilityInstance().getStrictIdentityValues();\r\n-        if (meta.isOpenJPAIdentity()) {\r\n-            int type = meta.getPrimaryKeyFields()[0].getDeclaredTypeCode();\r\n-            Object val = (convert) ? JavaTypes.convert(pks[0], type) : pks[0];\r\n-            switch (type) {\r\n-                case JavaTypes.BYTE:\r\n-                case JavaTypes.BYTE_OBJ:\r\n-                    if (!convert && !(val instanceof Byte))\r\n-                        throw new ClassCastException(\"!(x instanceof Byte)\");\r\n-                    return new ByteId(meta.getDescribedType(),\r\n-                        ((Number) val).byteValue());\r\n-                case JavaTypes.CHAR:\r\n-                case JavaTypes.CHAR_OBJ:\r\n-                    return new CharId(meta.getDescribedType(),\r\n-                        ((Character) val).charValue());\r\n-                case JavaTypes.INT:\r\n-                case JavaTypes.INT_OBJ:\r\n-                    if (!convert && !(val instanceof Integer))\r\n-                        throw new ClassCastException(\"!(x instanceof Byte)\");\r\n-                    return new IntId(meta.getDescribedType(),\r\n-                        ((Number) val).intValue());\r\n-                case JavaTypes.LONG:\r\n-                case JavaTypes.LONG_OBJ:\r\n-                    if (!convert && !(val instanceof Long))\r\n-                        throw new ClassCastException(\"!(x instanceof Byte)\");\r\n-                    return new LongId(meta.getDescribedType(),\r\n-                        ((Number) val).longValue());\r\n-                case JavaTypes.SHORT:\r\n-                case JavaTypes.SHORT_OBJ:\r\n-                    if (!convert && !(val instanceof Short))\r\n-                        throw new ClassCastException(\"!(x instanceof Byte)\");\r\n-                    return new ShortId(meta.getDescribedType(),\r\n-                        ((Number) val).shortValue());\r\n-                case JavaTypes.STRING:\r\n-                    return new StringId(meta.getDescribedType(), (String) val);\r\n-                case JavaTypes.DATE:\r\n-                    return new DateId(meta.getDescribedType(), (Date) val);\r\n-                case JavaTypes.OID:\r\n-                    return new ObjectId(meta.getDescribedType(), val);\r\n-                default:\r\n-                    throw new InternalException();\r\n-            }\r\n-        }\r\n-        // copy pks to oid\r\n-        if (!Modifier.isAbstract(meta.getDescribedType().getModifiers())) {\r\n-            Object oid = PCRegistry.newObjectId(meta.getDescribedType());\r\n-            PrimaryKeyFieldManager producer = new PrimaryKeyFieldManager();\r\n-            producer.setStore(pks);\r\n-            if (convert)\r\n-                producer.setMetaData(meta);\r\n-            PCRegistry.copyKeyFieldsToObjectId(meta.getDescribedType(),\r\n-                producer, oid);\r\n-            return oid;\r\n-        }\r\n-        // default to reflection\r\n-        Class oidType = meta.getObjectIdType();\r\n-        try {\r\n-            // create a new id\r\n-            Object copy = oidType.newInstance();\r\n-            // set each field\r\n-            FieldMetaData[] fmds = meta.getPrimaryKeyFields();\r\n-            Field field;\r\n-            Method meth;\r\n-            Class[] paramTypes = null;\r\n-            Object[] params = null;\r\n-            for (int i = 0; i < fmds.length; i++) {\r\n-                if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD) {\r\n-                    field = oidType.getField(fmds[i].getName());\r\n-                    field.set(copy, (convert) ? JavaTypes.convert(pks[i],\r\n-                        fmds[i].getDeclaredTypeCode()) : pks[i]);\r\n-                } else { // property\r\n-                    if (paramTypes == null)\r\n-                        paramTypes = new Class[1];\r\n-                    paramTypes[0] = fmds[i].getDeclaredType();\r\n-                    meth = oidType.getMethod(\"set\" + StringUtils.capitalize\r\n-                        (fmds[i].getName()), paramTypes);\r\n-                    if (params == null)\r\n-                        params = new Object[1];\r\n-                    params[0] = (convert) ? JavaTypes.convert(pks[i],\r\n-                        fmds[i].getDeclaredTypeCode()) : pks[i];\r\n-                    meth.invoke(copy, params);\r\n-                }\r\n-            }\r\n-            if (meta.isObjectIdTypeShared())\r\n-                copy = new ObjectId(meta.getDescribedType(), copy);\r\n-            return copy;\r\n-        } catch (Throwable t) {\r\n-            throw new GeneralException(t);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Copy the given oid value.\r\n-     */\r\n-    public static Object copy(Object oid, ClassMetaData meta) {\r\n-        if (meta == null || oid == null)\r\n-            return null;\r\n-        if (meta.isOpenJPAIdentity()) {\r\n-            // use meta type instead of oid type in case it's a subclass\r\n-            Class cls = meta.getDescribedType();\r\n-            OpenJPAId koid = (OpenJPAId) oid;\r\n-            FieldMetaData pk = meta.getPrimaryKeyFields()[0];\r\n-            switch (pk.getDeclaredTypeCode()) {\r\n-                case JavaTypes.BYTE:\r\n-                case JavaTypes.BYTE_OBJ:\r\n-                    return new ByteId(cls, ((ByteId) oid).getId(),\r\n-                        koid.hasSubclasses());\r\n-                case JavaTypes.CHAR:\r\n-                case JavaTypes.CHAR_OBJ:\r\n-                    return new CharId(cls, ((CharId) oid).getId(),\r\n-                        koid.hasSubclasses());\r\n-                case JavaTypes.INT:\r\n-                case JavaTypes.INT_OBJ:\r\n-                    return new IntId(cls, ((IntId) oid).getId(),\r\n-                        koid.hasSubclasses());\r\n-                case JavaTypes.LONG:\r\n-                case JavaTypes.LONG_OBJ:\r\n-                    return new LongId(cls, ((LongId) oid).getId(),\r\n-                        koid.hasSubclasses());\r\n-                case JavaTypes.SHORT:\r\n-                case JavaTypes.SHORT_OBJ:\r\n-                    return new ShortId(cls, ((ShortId) oid).getId(),\r\n-                        koid.hasSubclasses());\r\n-                case JavaTypes.STRING:\r\n-                    return new StringId(cls, oid.toString(),\r\n-                        koid.hasSubclasses());\r\n-                case JavaTypes.OID:\r\n-                    ClassMetaData embed = pk.getEmbeddedMetaData();\r\n-                    Object inner = koid.getIdObject();\r\n-                    if (embed != null)\r\n-                        inner = copy(inner, embed, embed.getFields());\r\n-                    return new ObjectId(cls, inner, koid.hasSubclasses());\r\n-                default:\r\n-                    throw new InternalException();\r\n-            }\r\n-        }\r\n-        // create a new pc instance of the right type, set its key fields\r\n-        // to the original oid values, then copy its key fields to a new\r\n-        // oid instance\r\n-        if (!Modifier.isAbstract(meta.getDescribedType().getModifiers())) {\r\n-            PersistenceCapable pc = PCRegistry.newInstance\r\n-                (meta.getDescribedType(), null, oid, false);\r\n-            Object copy = pc.pcNewObjectIdInstance();\r\n-            pc.pcCopyKeyFieldsToObjectId(copy);\r\n-            return copy;\r\n-        }\r\n-        Object copy =\r\n-            (!meta.isObjectIdTypeShared()) ? oid : ((ObjectId) oid).getId();\r\n-        copy = copy(copy, meta, meta.getPrimaryKeyFields());\r\n-        if (meta.isObjectIdTypeShared())\r\n-            copy = new ObjectId(meta.getDescribedType(), copy,\r\n-                ((OpenJPAId) oid).hasSubclasses());\r\n-        return copy;\r\n-    }\r\n-\r\n-    /**\r\n-     * Copy the given identity object using reflection.\r\n-     */\r\n-    private static Object copy(Object oid, ClassMetaData meta,\r\n-        FieldMetaData[] fmds) {\r\n-        if (oid == null)\r\n-            return null;\r\n-        // default to using reflection\r\n-        Class oidType = oid.getClass();\r\n-        try {\r\n-            Object copy = oidType.newInstance();\r\n-            Field field;\r\n-            Method meth;\r\n-            String cap;\r\n-            Class[] paramTypes = null;\r\n-            Object[] params = null;\r\n-            for (int i = 0; i < fmds.length; i++) {\r\n-                if (fmds[i].getManagement() != FieldMetaData.MANAGE_PERSISTENT)\r\n-                    continue;\r\n-                if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD) {\r\n-                    field = oidType.getField(fmds[i].getName());\r\n-                    field.set(copy, field.get(oid));\r\n-                } else { // property\r\n-                    if (paramTypes == null)\r\n-                        paramTypes = new Class[1];\r\n-                    paramTypes[0] = fmds[i].getDeclaredType();\r\n-                    cap = StringUtils.capitalize(fmds[i].getName());\r\n-                    meth = oidType.getMethod(\"set\" + cap, paramTypes);\r\n-                    if (params == null)\r\n-                        params = new Object[1];\r\n-                    params[0] = ImplHelper.getGetter(oidType, cap).\r\n-                        invoke(oid, (Object[]) null);\r\n-                    meth.invoke(copy, params);\r\n-                }\r\n-            }\r\n-            return copy;\r\n-        } catch (OpenJPAException ke) {\r\n-            throw ke;\r\n-        } catch (Throwable t) {\r\n-            throw new GeneralException(t);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Generate an application id based on the current primary key field state\r\n-     * of the given instance.\r\n-     */\r\n-    public static Object create(PersistenceCapable pc, ClassMetaData meta) {\r\n-        if (pc == null)\r\n-            return null;\r\n-        Object oid = pc.pcNewObjectIdInstance();\r\n-        if (oid == null)\r\n-            return null;\r\n-        if (!meta.isOpenJPAIdentity()) {\r\n-            pc.pcCopyKeyFieldsToObjectId(oid);\r\n-            return oid;\r\n-        }\r\n-        FieldMetaData pk = meta.getPrimaryKeyFields()[0];\r\n-        if (pk.getDeclaredTypeCode() != JavaTypes.OID)\r\n-            return oid;\r\n-        // always copy oid object in case field value mutates or becomes\r\n-        // managed\r\n-        ObjectId objid = (ObjectId) oid;\r\n-        ClassMetaData embed = pk.getEmbeddedMetaData();\r\n-        objid.setId(copy(objid.getId(), embed, embed.getFields()));\r\n-        return objid;\r\n-    }\r\n-\r\n-    /**\r\n-     * Assign an application identity object to the given state, or return\r\n-     * false if determining the application identity requires a flush.\r\n-     */\r\n-    public static boolean assign(OpenJPAStateManager sm, StoreManager store,\r\n-        boolean preFlush) {\r\n-        ClassMetaData meta = sm.getMetaData();\r\n-        if (meta.getIdentityType() != ClassMetaData.ID_APPLICATION)\r\n-            throw new InternalException();\r\n-        boolean ret;\r\n-        FieldMetaData[] pks = meta.getPrimaryKeyFields();\r\n-        if (meta.isOpenJPAIdentity()\r\n-            && pks[0].getDeclaredTypeCode() == JavaTypes.OID) {\r\n-            OpenJPAStateManager oidsm = new ObjectIdStateManager\r\n-                (sm.fetchObjectField(pks[0].getIndex()), sm, pks[0]);\r\n-            ret = assign(oidsm, store, pks[0].getEmbeddedMetaData().\r\n-                getFields(), preFlush);\r\n-            sm.storeObjectField(pks[0].getIndex(), oidsm.getManagedInstance());\r\n-        } else ret = assign(sm, store, meta.getPrimaryKeyFields(), preFlush);\r\n-        if (!ret)\r\n-            return false;\r\n-        // base oid on field values\r\n-        sm.setObjectId(create(sm.getPersistenceCapable(), meta));\r\n-        return true;\r\n-    }\r\n-\r\n-    /**\r\n-     * Assign generated values to given fields.\r\n-     */\r\n-    private static boolean assign(OpenJPAStateManager sm, StoreManager store,\r\n-        FieldMetaData[] pks, boolean preFlush) {\r\n-        for (int i = 0; i < pks.length; i++)\r\n-            if (pks[i].getValueStrategy() != ValueStrategies.NONE\r\n-                && sm.isDefaultValue(pks[i].getIndex())\r\n-                && !store.assignField(sm, pks[i].getIndex(), preFlush))\r\n-                return false;\r\n-        return true;\r\n-    }\r\n-\r\n-    /**\r\n-     * Helper class used to transfer pk values to/from application oids.\r\n-     */\r\n-    private static class PrimaryKeyFieldManager implements FieldManager {\r\n-\r\n-        private Object[] _store = null;\r\n-        private int _index = 0;\r\n-        private ClassMetaData _meta = null;\r\n-\r\n-        public void setMetaData(ClassMetaData meta) {\r\n-            _meta = meta;\r\n-        }\r\n-\r\n-        public Object[] getStore() {\r\n-            return _store;\r\n-        }\r\n-\r\n-        public void setStore(Object[] store) {\r\n-            _store = store;\r\n-        }\r\n-\r\n-        public void storeBooleanField(int field, boolean val) {\r\n-            store((val) ? Boolean.TRUE : Boolean.FALSE);\r\n-        }\r\n-\r\n-        public void storeByteField(int field, byte val) {\r\n-            store(new Byte(val));\r\n-        }\r\n-\r\n-        public void storeCharField(int field, char val) {\r\n-            store(new Character(val));\r\n-        }\r\n-\r\n-        public void storeShortField(int field, short val) {\r\n-            store(new Short(val));\r\n-        }\r\n-\r\n-        public void storeIntField(int field, int val) {\r\n-            store(Numbers.valueOf(val));\r\n-        }\r\n-\r\n-        public void storeLongField(int field, long val) {\r\n-            store(Numbers.valueOf(val));\r\n-        }\r\n-\r\n-        public void storeFloatField(int field, float val) {\r\n-            store(new Float(val));\r\n-        }\r\n-\r\n-        public void storeDoubleField(int field, double val) {\r\n-            store(new Double(val));\r\n-        }\r\n-\r\n-        public void storeStringField(int field, String val) {\r\n-            store(val);\r\n-        }\r\n-\r\n-        public void storeObjectField(int field, Object val) {\r\n-            store(val);\r\n-        }\r\n-\r\n-        public boolean fetchBooleanField(int field) {\r\n-            return (retrieve(field) == Boolean.TRUE) ? true : false;\r\n-        }\r\n-\r\n-        public char fetchCharField(int field) {\r\n-            return ((Character) retrieve(field)).charValue();\r\n-        }\r\n-\r\n-        public byte fetchByteField(int field) {\r\n-            return ((Number) retrieve(field)).byteValue();\r\n-        }\r\n-\r\n-        public short fetchShortField(int field) {\r\n-            return ((Number) retrieve(field)).shortValue();\r\n-        }\r\n-\r\n-        public int fetchIntField(int field) {\r\n-            return ((Number) retrieve(field)).intValue();\r\n-        }\r\n-\r\n-        public long fetchLongField(int field) {\r\n-            return ((Number) retrieve(field)).longValue();\r\n-        }\r\n-\r\n-        public float fetchFloatField(int field) {\r\n-            return ((Number) retrieve(field)).floatValue();\r\n-        }\r\n-\r\n-        public double fetchDoubleField(int field) {\r\n-            return ((Number) retrieve(field)).doubleValue();\r\n-        }\r\n-\r\n-        public String fetchStringField(int field) {\r\n-            return (String) retrieve(field);\r\n-        }\r\n-\r\n-        public Object fetchObjectField(int field) {\r\n-            return retrieve(field);\r\n-        }\r\n-\r\n-        private void store(Object val) {\r\n-            _store[_index++] = val;\r\n-        }\r\n-\r\n-        private Object retrieve(int field) {\r\n-            Object val = _store[_index++];\r\n-            if (_meta != null)\r\n-                val = JavaTypes.convert(val, _meta.getField(field).\r\n-                    getDeclaredTypeCode());\r\n-            return val;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Date;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.enhance.FieldManager;\n+import org.apache.openjpa.enhance.PCRegistry;\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.kernel.ObjectIdStateManager;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.ValueStrategies;\n+import serp.util.Numbers;\n+\n+/**\n+ * <p>Utility class for manipulating application object ids.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ApplicationIds {\n+\n+    /**\n+     * Return the primary key values for the given object id.  The values\n+     * will be returned in the same order as the metadata primary key fields.\n+     */\n+    public static Object[] toPKValues(Object oid, ClassMetaData meta) {\n+        if (meta == null)\n+            return null;\n+\n+        Object[] pks;\n+        if (meta.isOpenJPAIdentity()) {\n+            pks = new Object[1];\n+            if (oid != null)\n+                pks[0] = ((OpenJPAId) oid).getIdObject();\n+            return pks;\n+        }\n+\n+        // reset owning 'meta' to the owner of the primary key fields, because\n+        // the one passed in might be a proxy, like for embedded mappings;\n+        // since getPrimaryKeyFields is guaranteed to return the primary\n+        // keys in the order of inheritance, we are guaranteed that\n+        // the last element will be the most-derived class.\n+        FieldMetaData[] fmds = meta.getPrimaryKeyFields();\n+        meta = fmds[fmds.length - 1].getDeclaringMetaData();\n+        pks = new Object[fmds.length];\n+        if (oid == null)\n+            return pks;\n+\n+        if (!Modifier.isAbstract(meta.getDescribedType().getModifiers())) {\n+            // copy fields from the oid\n+            PrimaryKeyFieldManager consumer = new PrimaryKeyFieldManager();\n+            consumer.setStore(pks);\n+            PCRegistry.copyKeyFieldsFromObjectId(meta.getDescribedType(),\n+                consumer, oid);\n+            return consumer.getStore();\n+        }\n+\n+        // default to reflection\n+        if (meta.isObjectIdTypeShared())\n+            oid = ((ObjectId) oid).getId();\n+        Class oidType = oid.getClass();\n+        try {\n+            Field field;\n+            Method meth;\n+            for (int i = 0; i < fmds.length; i++) {\n+                if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD) {\n+                    field = oidType.getField(fmds[i].getName());\n+                    pks[i] = field.get(oid);\n+                } else // property\n+                {\n+                    meth = ImplHelper.getGetter(oidType, fmds[i].getName());\n+                    pks[i] = meth.invoke(oid, (Object[]) null);\n+                }\n+            }\n+            return pks;\n+        }\n+        catch (OpenJPAException ke) {\n+            throw ke;\n+        }\n+        catch (Throwable t) {\n+            throw new GeneralException(t);\n+        }\n+    }\n+\n+    /**\n+     * Return a new object id constructed from the given primary key values.\n+     */\n+    public static Object fromPKValues(Object[] pks, ClassMetaData meta) {\n+        if (meta == null || pks == null)\n+            return null;\n+\n+        boolean convert = !meta.getRepository().getConfiguration().\n+            getCompatibilityInstance().getStrictIdentityValues();\n+        if (meta.isOpenJPAIdentity()) {\n+            int type = meta.getPrimaryKeyFields()[0].getDeclaredTypeCode();\n+            Object val = (convert) ? JavaTypes.convert(pks[0], type) : pks[0];\n+            switch (type) {\n+                case JavaTypes.BYTE:\n+                case JavaTypes.BYTE_OBJ:\n+                    if (!convert && !(val instanceof Byte))\n+                        throw new ClassCastException(\"!(x instanceof Byte)\");\n+                    return new ByteId(meta.getDescribedType(),\n+                        ((Number) val).byteValue());\n+                case JavaTypes.CHAR:\n+                case JavaTypes.CHAR_OBJ:\n+                    return new CharId(meta.getDescribedType(),\n+                        ((Character) val).charValue());\n+                case JavaTypes.INT:\n+                case JavaTypes.INT_OBJ:\n+                    if (!convert && !(val instanceof Integer))\n+                        throw new ClassCastException(\"!(x instanceof Byte)\");\n+                    return new IntId(meta.getDescribedType(),\n+                        ((Number) val).intValue());\n+                case JavaTypes.LONG:\n+                case JavaTypes.LONG_OBJ:\n+                    if (!convert && !(val instanceof Long))\n+                        throw new ClassCastException(\"!(x instanceof Byte)\");\n+                    return new LongId(meta.getDescribedType(),\n+                        ((Number) val).longValue());\n+                case JavaTypes.SHORT:\n+                case JavaTypes.SHORT_OBJ:\n+                    if (!convert && !(val instanceof Short))\n+                        throw new ClassCastException(\"!(x instanceof Byte)\");\n+                    return new ShortId(meta.getDescribedType(),\n+                        ((Number) val).shortValue());\n+                case JavaTypes.STRING:\n+                    return new StringId(meta.getDescribedType(), (String) val);\n+                case JavaTypes.DATE:\n+                    return new DateId(meta.getDescribedType(), (Date) val);\n+                case JavaTypes.OID:\n+                    return new ObjectId(meta.getDescribedType(), val);\n+                default:\n+                    throw new InternalException();\n+            }\n+        }\n+\n+        // copy pks to oid\n+        if (!Modifier.isAbstract(meta.getDescribedType().getModifiers())) {\n+            Object oid = PCRegistry.newObjectId(meta.getDescribedType());\n+            PrimaryKeyFieldManager producer = new PrimaryKeyFieldManager();\n+            producer.setStore(pks);\n+            if (convert)\n+                producer.setMetaData(meta);\n+            PCRegistry.copyKeyFieldsToObjectId(meta.getDescribedType(),\n+                producer, oid);\n+            return oid;\n+        }\n+\n+        // default to reflection\n+        Class oidType = meta.getObjectIdType();\n+        try {\n+            // create a new id\n+            Object copy = oidType.newInstance();\n+\n+            // set each field\n+            FieldMetaData[] fmds = meta.getPrimaryKeyFields();\n+            Field field;\n+            Method meth;\n+            Class[] paramTypes = null;\n+            Object[] params = null;\n+            for (int i = 0; i < fmds.length; i++) {\n+                if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD) {\n+                    field = oidType.getField(fmds[i].getName());\n+                    field.set(copy, (convert) ? JavaTypes.convert(pks[i],\n+                        fmds[i].getDeclaredTypeCode()) : pks[i]);\n+                } else // property\n+                {\n+                    if (paramTypes == null)\n+                        paramTypes = new Class[1];\n+                    paramTypes[0] = fmds[i].getDeclaredType();\n+                    meth = oidType.getMethod(\"set\" + StringUtils.capitalize\n+                        (fmds[i].getName()), paramTypes);\n+                    if (params == null)\n+                        params = new Object[1];\n+                    params[0] = (convert) ? JavaTypes.convert(pks[i],\n+                        fmds[i].getDeclaredTypeCode()) : pks[i];\n+                    meth.invoke(copy, params);\n+                }\n+            }\n+\n+            if (meta.isObjectIdTypeShared())\n+                copy = new ObjectId(meta.getDescribedType(), copy);\n+            return copy;\n+        }\n+        catch (Throwable t) {\n+            throw new GeneralException(t);\n+        }\n+    }\n+\n+    /**\n+     * Copy the given oid value.\n+     */\n+    public static Object copy(Object oid, ClassMetaData meta) {\n+        if (meta == null || oid == null)\n+            return null;\n+\n+        if (meta.isOpenJPAIdentity()) {\n+            // use meta type instead of oid type in case it's a subclass\n+            Class cls = meta.getDescribedType();\n+            OpenJPAId koid = (OpenJPAId) oid;\n+            FieldMetaData pk = meta.getPrimaryKeyFields()[0];\n+            switch (pk.getDeclaredTypeCode()) {\n+                case JavaTypes.BYTE:\n+                case JavaTypes.BYTE_OBJ:\n+                    return new ByteId(cls, ((ByteId) oid).getId(),\n+                        koid.hasSubclasses());\n+                case JavaTypes.CHAR:\n+                case JavaTypes.CHAR_OBJ:\n+                    return new CharId(cls, ((CharId) oid).getId(),\n+                        koid.hasSubclasses());\n+                case JavaTypes.INT:\n+                case JavaTypes.INT_OBJ:\n+                    return new IntId(cls, ((IntId) oid).getId(),\n+                        koid.hasSubclasses());\n+                case JavaTypes.LONG:\n+                case JavaTypes.LONG_OBJ:\n+                    return new LongId(cls, ((LongId) oid).getId(),\n+                        koid.hasSubclasses());\n+                case JavaTypes.SHORT:\n+                case JavaTypes.SHORT_OBJ:\n+                    return new ShortId(cls, ((ShortId) oid).getId(),\n+                        koid.hasSubclasses());\n+                case JavaTypes.STRING:\n+                    return new StringId(cls, oid.toString(),\n+                        koid.hasSubclasses());\n+                case JavaTypes.OID:\n+                    ClassMetaData embed = pk.getEmbeddedMetaData();\n+                    Object inner = koid.getIdObject();\n+                    if (embed != null)\n+                        inner = copy(inner, embed, embed.getFields());\n+                    return new ObjectId(cls, inner, koid.hasSubclasses());\n+                default:\n+                    throw new InternalException();\n+            }\n+        }\n+\n+        // create a new pc instance of the right type, set its key fields\n+        // to the original oid values, then copy its key fields to a new\n+        // oid instance\n+        if (!Modifier.isAbstract(meta.getDescribedType().getModifiers())) {\n+            PersistenceCapable pc = PCRegistry.newInstance\n+                (meta.getDescribedType(), null, oid, false);\n+            Object copy = pc.pcNewObjectIdInstance();\n+            pc.pcCopyKeyFieldsToObjectId(copy);\n+            return copy;\n+        }\n+\n+        Object copy = (!meta.isObjectIdTypeShared()) ? oid\n+            : ((ObjectId) oid).getId();\n+        copy = copy(copy, meta, meta.getPrimaryKeyFields());\n+        if (meta.isObjectIdTypeShared())\n+            copy = new ObjectId(meta.getDescribedType(), copy,\n+                ((OpenJPAId) oid).hasSubclasses());\n+        return copy;\n+    }\n+\n+    /**\n+     * Copy the given identity object using reflection.\n+     */\n+    private static Object copy(Object oid, ClassMetaData meta,\n+        FieldMetaData[] fmds) {\n+        if (oid == null)\n+            return null;\n+\n+        // default to using reflection\n+        Class oidType = oid.getClass();\n+        try {\n+            Object copy = oidType.newInstance();\n+            Field field;\n+            Method meth;\n+            String cap;\n+            Class[] paramTypes = null;\n+            Object[] params = null;\n+            for (int i = 0; i < fmds.length; i++) {\n+                if (fmds[i].getManagement() != FieldMetaData.MANAGE_PERSISTENT)\n+                    continue;\n+\n+                if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD) {\n+                    field = oidType.getField(fmds[i].getName());\n+                    field.set(copy, field.get(oid));\n+                } else // property\n+                {\n+                    if (paramTypes == null)\n+                        paramTypes = new Class[1];\n+                    paramTypes[0] = fmds[i].getDeclaredType();\n+                    cap = StringUtils.capitalize(fmds[i].getName());\n+                    meth = oidType.getMethod(\"set\" + cap, paramTypes);\n+                    if (params == null)\n+                        params = new Object[1];\n+                    params[0] = ImplHelper.getGetter(oidType, cap).\n+                        invoke(oid, (Object[]) null);\n+                    meth.invoke(copy, params);\n+                }\n+            }\n+            return copy;\n+        }\n+        catch (OpenJPAException ke) {\n+            throw ke;\n+        }\n+        catch (Throwable t) {\n+            throw new GeneralException(t);\n+        }\n+    }\n+\n+    /**\n+     * Generate an application id based on the current primary key field state\n+     * of the given instance.\n+     */\n+    public static Object create(PersistenceCapable pc, ClassMetaData meta) {\n+        if (pc == null)\n+            return null;\n+\n+        Object oid = pc.pcNewObjectIdInstance();\n+        if (oid == null)\n+            return null;\n+\n+        if (!meta.isOpenJPAIdentity()) {\n+            pc.pcCopyKeyFieldsToObjectId(oid);\n+            return oid;\n+        }\n+\n+        FieldMetaData pk = meta.getPrimaryKeyFields()[0];\n+        if (pk.getDeclaredTypeCode() != JavaTypes.OID)\n+            return oid;\n+\n+        // always copy oid object in case field value mutates or becomes\n+        // managed\n+        ObjectId objid = (ObjectId) oid;\n+        ClassMetaData embed = pk.getEmbeddedMetaData();\n+        objid.setId(copy(objid.getId(), embed, embed.getFields()));\n+        return objid;\n+    }\n+\n+    /**\n+     * Assign an application identity object to the given state, or return\n+     * false if determining the application identity requires a flush.\n+     */\n+    public static boolean assign(OpenJPAStateManager sm, StoreManager store,\n+        boolean preFlush) {\n+        ClassMetaData meta = sm.getMetaData();\n+        if (meta.getIdentityType() != ClassMetaData.ID_APPLICATION)\n+            throw new InternalException();\n+\n+        boolean ret;\n+        FieldMetaData[] pks = meta.getPrimaryKeyFields();\n+        if (meta.isOpenJPAIdentity()\n+            && pks[0].getDeclaredTypeCode() == JavaTypes.OID) {\n+            OpenJPAStateManager oidsm = new ObjectIdStateManager\n+                (sm.fetchObjectField(pks[0].getIndex()), sm, pks[0]);\n+            ret = assign(oidsm, store, pks[0].getEmbeddedMetaData().\n+                getFields(), preFlush);\n+            sm.storeObjectField(pks[0].getIndex(),\n+                oidsm.getManagedInstance());\n+        } else\n+            ret = assign(sm, store, meta.getPrimaryKeyFields(), preFlush);\n+        if (!ret)\n+            return false;\n+\n+        // base oid on field values\n+        sm.setObjectId(create(sm.getPersistenceCapable(), meta));\n+        return true;\n+    }\n+\n+    /**\n+     * Assign generated values to given fields.\n+     */\n+    private static boolean assign(OpenJPAStateManager sm, StoreManager store,\n+        FieldMetaData[] pks, boolean preFlush) {\n+        for (int i = 0; i < pks.length; i++)\n+            if (pks[i].getValueStrategy() != ValueStrategies.NONE\n+                && sm.isDefaultValue(pks[i].getIndex())\n+                && !store.assignField(sm, pks[i].getIndex(), preFlush))\n+                return false;\n+        return true;\n+    }\n+\n+    /**\n+     *\tHelper class used to transfer pk values to/from application oids.\n+     */\n+    private static class PrimaryKeyFieldManager\n+        implements FieldManager {\n+\n+        private Object[] _store = null;\n+        private int _index = 0;\n+        private ClassMetaData _meta = null;\n+\n+        public void setMetaData(ClassMetaData meta) {\n+            _meta = meta;\n+        }\n+\n+        public Object[] getStore() {\n+            return _store;\n+        }\n+\n+        public void setStore(Object[] store) {\n+            _store = store;\n+        }\n+\n+        public void storeBooleanField(int field, boolean val) {\n+            store((val) ? Boolean.TRUE : Boolean.FALSE);\n+        }\n+\n+        public void storeByteField(int field, byte val) {\n+            store(new Byte(val));\n+        }\n+\n+        public void storeCharField(int field, char val) {\n+            store(new Character(val));\n+        }\n+\n+        public void storeShortField(int field, short val) {\n+            store(new Short(val));\n+        }\n+\n+        public void storeIntField(int field, int val) {\n+            store(Numbers.valueOf(val));\n+        }\n+\n+        public void storeLongField(int field, long val) {\n+            store(Numbers.valueOf(val));\n+        }\n+\n+        public void storeFloatField(int field, float val) {\n+            store(new Float(val));\n+        }\n+\n+        public void storeDoubleField(int field, double val) {\n+            store(new Double(val));\n+        }\n+\n+        public void storeStringField(int field, String val) {\n+            store(val);\n+        }\n+\n+        public void storeObjectField(int field, Object val) {\n+            store(val);\n+        }\n+\n+        public boolean fetchBooleanField(int field) {\n+            return (retrieve(field) == Boolean.TRUE) ? true : false;\n+        }\n+\n+        public char fetchCharField(int field) {\n+            return ((Character) retrieve(field)).charValue();\n+        }\n+\n+        public byte fetchByteField(int field) {\n+            return ((Number) retrieve(field)).byteValue();\n+        }\n+\n+        public short fetchShortField(int field) {\n+            return ((Number) retrieve(field)).shortValue();\n+        }\n+\n+        public int fetchIntField(int field) {\n+            return ((Number) retrieve(field)).intValue();\n+        }\n+\n+        public long fetchLongField(int field) {\n+            return ((Number) retrieve(field)).longValue();\n+        }\n+\n+        public float fetchFloatField(int field) {\n+            return ((Number) retrieve(field)).floatValue();\n+        }\n+\n+        public double fetchDoubleField(int field) {\n+            return ((Number) retrieve(field)).doubleValue();\n+        }\n+\n+        public String fetchStringField(int field) {\n+            return (String) retrieve(field);\n+        }\n+\n+        public Object fetchObjectField(int field) {\n+            return retrieve(field);\n+        }\n+\n+        private void store(Object val) {\n+            _store[_index++] = val;\n+        }\n+\n+        private Object retrieve(int field) {\n+            Object val = _store[_index++];\n+            if (_meta != null)\n+                val = JavaTypes.convert(val, _meta.getField(field).\n+                    getDeclaredTypeCode());\n+            return val;\n+\t\t}\n+\t}\n+}"},{"sha":"cee1f16afbef1867d92f714c17c7ff1c00fd45fc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ArrayStateImage.java","status":"modified","additions":104,"deletions":99,"changes":203,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ArrayStateImage.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ArrayStateImage.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ArrayStateImage.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,99 +1,104 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.util.BitSet;\r\n-\r\n-import org.apache.commons.lang.ObjectUtils;\r\n-\r\n-/**\r\n- * Utilities for dealing with a simple state image consisting of an\r\n- * <code>Object[]</code> of field values with one extra index containing a\r\n- * {@link BitSet} of loaded fields. This simplistic state image might be used\r\n- * for optimistic versioning.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class ArrayStateImage {\r\n-\r\n-    /**\r\n-     * Create a new state image for the given number of fields.\r\n-     */\r\n-    public static Object[] newImage(int numFields) {\r\n-        Object[] state = new Object[numFields + 1];\r\n-        state[numFields] = new BitSet(numFields);\r\n-        return state;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return true if the given version object appears to be an array state\r\n-     * image.\r\n-     */\r\n-    public static boolean isImage(Object obj) {\r\n-        if (!(obj instanceof Object[]))\r\n-            return false;\r\n-        Object[] arr = (Object[]) obj;\r\n-        return arr.length > 0 && arr[arr.length - 1] instanceof BitSet;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get the loaded mask from a state image.\r\n-     */\r\n-    public static BitSet getLoaded(Object[] state) {\r\n-        return (BitSet) state[state.length - 1];\r\n-    }\r\n-\r\n-    /**\r\n-     * Set the loaded mask into a state image.\r\n-     */\r\n-    public static void setLoaded(Object[] state, BitSet loaded) {\r\n-        state[state.length - 1] = loaded;\r\n-    }\r\n-\r\n-    /**\r\n-     * Clone a state array.\r\n-     */\r\n-    public static Object[] clone(Object[] state) {\r\n-        Object[] copy = new Object[state.length];\r\n-        System.arraycopy(state, 0, copy, 0, state.length - 1);\r\n-        BitSet loaded = (BitSet) state[state.length - 1];\r\n-        copy[copy.length - 1] = loaded.clone();\r\n-        return copy;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return whether the given images are equivalent from an optimistic\r\n-     * locking perspective.\r\n-     */\r\n-    public static boolean sameVersion(Object[] state1, Object[] state2) {\r\n-        if (state1 == state2)\r\n-            return true;\r\n-        // if either state is null, then we report that it is the\r\n-        // same: this is because a null version will indicate that\r\n-        // there are no loaded fields in the version at all, which\r\n-        // indicates that there is nothing to compare\r\n-        if (state1 == null || state2 == null)\r\n-            return true;\r\n-        // check only the fields that are in the loaded set for the\r\n-        // first version\r\n-        BitSet loaded1 = getLoaded(state1);\r\n-        BitSet loaded2 = getLoaded(state2);\r\n-        for (int i = 0, max = loaded1.length(); i < max; i++) {\r\n-            if (loaded1.get(i) && loaded2.get(i)\r\n-                && !ObjectUtils.equals(state1[i], state2[i]))\r\n-                return false;\r\n-        }\r\n-        return true;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.util.BitSet;\n+\n+import org.apache.commons.lang.ObjectUtils;\n+\n+/**\n+ * <p>Utilities for dealing with a simple state image consisting of an\n+ * <code>Object[]</code> of field values with one extra index containing a\n+ * {@link BitSet} of loaded fields.  This simplistic state image might be used\n+ * for optimistic versioning.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ArrayStateImage {\n+\n+    /**\n+     * Create a new state image for the given number of fields.\n+     */\n+    public static Object[] newImage(int numFields) {\n+        Object[] state = new Object[numFields + 1];\n+        state[numFields] = new BitSet(numFields);\n+        return state;\n+    }\n+\n+    /**\n+     * Return true if the given version object appears to be an array state\n+     * image.\n+     */\n+    public static boolean isImage(Object obj) {\n+        if (!(obj instanceof Object[]))\n+            return false;\n+        Object[] arr = (Object[]) obj;\n+        return arr.length > 0 && arr[arr.length - 1] instanceof BitSet;\n+    }\n+\n+    /**\n+     * Get the loaded mask from a state image.\n+     */\n+    public static BitSet getLoaded(Object[] state) {\n+        return (BitSet) state[state.length - 1];\n+    }\n+\n+    /**\n+     * Set the loaded mask into a state image.\n+     */\n+    public static void setLoaded(Object[] state, BitSet loaded) {\n+        state[state.length - 1] = loaded;\n+    }\n+\n+    /**\n+     * Clone a state array.\n+     */\n+    public static Object[] clone(Object[] state) {\n+        Object[] copy = new Object[state.length];\n+        System.arraycopy(state, 0, copy, 0, state.length - 1);\n+        BitSet loaded = (BitSet) state[state.length - 1];\n+        copy[copy.length - 1] = loaded.clone();\n+        return copy;\n+    }\n+\n+    /**\n+     *\tReturn whether the given images are equivalent from an optimistic\n+     *\tlocking perspective.\n+     */\n+    public static boolean sameVersion(Object[] state1, Object[] state2) {\n+        if (state1 == state2)\n+            return true;\n+\n+        // if either state is null, then we report that it is the\n+        // same: this is because a null version will indicate that\n+        // there are no loaded fields in the version at all, which\n+        // indicates that there is nothing to compare\n+        if (state1 == null || state2 == null)\n+            return true;\n+\n+        // check only the fields that are in the loaded set for the\n+        // first version\n+        BitSet loaded1 = getLoaded(state1);\n+        BitSet loaded2 = getLoaded(state2);\n+        for (int i = 0, max = loaded1.length(); i < max; i++) {\n+            if (loaded1.get(i) && loaded2.get(i)\n+                && !ObjectUtils.equals(state1[i], state2[i]))\n+                return false;\n+        }\n+        return true;\n+\t}\n+} "},{"sha":"0ea2df70f95b38d5d6c058117fba17d8b2bc3a31","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ByteId.java","status":"modified","additions":64,"deletions":61,"changes":125,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ByteId.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ByteId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ByteId.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,61 +1,64 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-/**\r\n- * {@link OpenJPAId} subclass appropriate for byte fields.\r\n- *\r\n- * @author Steve Kim\r\n- */\r\n-public final class ByteId extends OpenJPAId {\r\n-\r\n-    private final byte key;\r\n-\r\n-    public ByteId(Class cls, Byte key) {\r\n-        this(cls, (key == null) ? (byte) 0 : key.byteValue());\r\n-    }\r\n-\r\n-    public ByteId(Class cls, String key) {\r\n-        this(cls, (key == null) ? (byte) 0 : Byte.parseByte(key));\r\n-    }\r\n-\r\n-    public ByteId(Class cls, byte key) {\r\n-        super(cls);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public ByteId(Class cls, byte key, boolean subs) {\r\n-        super(cls, subs);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public byte getId() {\r\n-        return key;\r\n-    }\r\n-\r\n-    public Object getIdObject() {\r\n-        return new Byte(key);\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return Byte.toString(key);\r\n-    }\r\n-\r\n-    protected int idHash() {\r\n-        return key;\r\n-    }\r\n-\r\n-    protected boolean idEquals(OpenJPAId o) {\r\n-        return key == ((ByteId) o).key;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+/**\n+ * {@link OpenJPAId} subclass appropriate for byte fields.\n+ *\n+ * @author Steve Kim\n+ */\n+public final class ByteId extends OpenJPAId {\n+\n+    private final byte key;\n+\n+    public ByteId(Class cls, Byte key) {\n+        this(cls, (key == null) ? (byte) 0 : key.byteValue());\n+    }\n+\n+    public ByteId(Class cls, String key) {\n+        this(cls, (key == null) ? (byte) 0 : Byte.parseByte(key));\n+    }\n+\n+    public ByteId(Class cls, byte key) {\n+        super(cls);\n+        this.key = key;\n+    }\n+\n+    public ByteId(Class cls, byte key, boolean subs) {\n+        super(cls, subs);\n+        this.key = key;\n+    }\n+\n+    public byte getId() {\n+        return key;\n+    }\n+\n+    public Object getIdObject() {\n+        return new Byte(key);\n+    }\n+\n+    public String toString() {\n+        return Byte.toString(key);\n+    }\n+\n+    protected int idHash() {\n+        return key;\n+    }\n+\n+    protected boolean idEquals(OpenJPAId o) {\n+        return key == ((ByteId) o).key;\n+    }\n+}"},{"sha":"066f7fbccef869177bc5dc989a86041d68b5aca8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","status":"modified","additions":650,"deletions":626,"changes":1276,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,626 +1,650 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.util.AbstractCollection;\r\n-import java.util.AbstractSet;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.commons.collections.Predicate;\r\n-import org.apache.commons.collections.iterators.FilterIterator;\r\n-import org.apache.commons.collections.iterators.IteratorChain;\r\n-import org.apache.openjpa.lib.util.LRUMap;\r\n-import org.apache.openjpa.lib.util.ReferenceHashMap;\r\n-import org.apache.openjpa.lib.util.ReferenceMap;\r\n-import org.apache.openjpa.lib.util.SizedMap;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\r\n-import org.apache.openjpa.lib.util.concurrent.ReentrantLock;\r\n-\r\n-/**\r\n- * Fixed-size map that has ability to pin/unpin entries and move overflow to\r\n- * a backing soft map.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @author Abe White\r\n- */\r\n-public class CacheMap implements Map {\r\n-\r\n-    /**\r\n-     * The map for non-expired and non-pinned references.\r\n-     */\r\n-    protected final SizedMap cacheMap;\r\n-\r\n-    /**\r\n-     * The map for expired references.\r\n-     */\r\n-    protected final SizedMap softMap;\r\n-\r\n-    /**\r\n-     * The set of objects pinned into the cache.\r\n-     */\r\n-    protected final Map pinnedMap;\r\n-    // number of pinned values(not including keys not mapped to values)\r\n-    private int _pinnedSize = 0;\r\n-    private final ReentrantLock _writeLock = new ReentrantLock();\r\n-    private final ReentrantLock _readLock;\r\n-\r\n-    /**\r\n-     * Create a non-LRU(and therefore highly concurrent) cache map with a\r\n-     * size of 1000.\r\n-     */\r\n-    public CacheMap() {\r\n-        this(false, 1000);\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a cache map with the given properties.\r\n-     */\r\n-    public CacheMap(boolean lru, int max) {\r\n-        this(lru, max, max / 2, .75F);\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a cache map with the given properties.\r\n-     */\r\n-    public CacheMap(boolean lru, int max, int size, float load) {\r\n-        if (size < 0)\r\n-            size = 500;\r\n-        if (!lru) {\r\n-            cacheMap = new ConcurrentHashMap(size, load) {\r\n-                public void overflowRemoved(Object key, Object value) {\r\n-                    cacheMapOverflowRemoved(key, value);\r\n-                }\r\n-            };\r\n-            softMap = new ConcurrentReferenceHashMap(ReferenceMap.HARD,\r\n-                ReferenceMap.SOFT, size, load) {\r\n-                public void overflowRemoved(Object key, Object value) {\r\n-                    softMapOverflowRemoved(key, value);\r\n-                }\r\n-\r\n-                public void valueExpired(Object key) {\r\n-                    softMapValueExpired(key);\r\n-                }\r\n-            };\r\n-            pinnedMap = new ConcurrentHashMap();\r\n-            _readLock = null;\r\n-        } else {\r\n-            cacheMap = new LRUMap(size, load) {\r\n-                public void overflowRemoved(Object key, Object value) {\r\n-                    cacheMapOverflowRemoved(key, value);\r\n-                }\r\n-            };\r\n-            softMap = new ReferenceHashMap(ReferenceMap.HARD,\r\n-                ReferenceMap.SOFT, size, load) {\r\n-                public void overflowRemoved(Object key, Object value) {\r\n-                    softMapOverflowRemoved(key, value);\r\n-                }\r\n-\r\n-                public void valueExpired(Object key) {\r\n-                    softMapValueExpired(key);\r\n-                }\r\n-            };\r\n-            pinnedMap = new HashMap();\r\n-            _readLock = _writeLock;\r\n-        }\r\n-        cacheMap.setMaxSize((max < 0) ? Integer.MAX_VALUE : max);\r\n-    }\r\n-\r\n-    /**\r\n-     * Called from {@link SizedMap#overflowRemoved} in the cache map.\r\n-     */\r\n-    protected void cacheMapOverflowRemoved(Object key, Object value) {\r\n-        if (softMap.size() < softMap.getMaxSize())\r\n-            put(softMap, key, value);\r\n-        else entryRemoved(key, value, true);\r\n-    }\r\n-\r\n-    /**\r\n-     * Called from {@link SizedMap#overflowRemoved} in the soft map.\r\n-     */\r\n-    protected void softMapOverflowRemoved(Object key, Object value) {\r\n-        entryRemoved(key, value, true);\r\n-    }\r\n-\r\n-    /**\r\n-     * Called when a value expires from the soft map.\r\n-     */\r\n-    protected void softMapValueExpired(Object key) {\r\n-        entryRemoved(key, null, true);\r\n-    }\r\n-\r\n-    /**\r\n-     * Put the given entry into the given map. Allows subclasses to\r\n-     * take additional actions.\r\n-     */\r\n-    protected Object put(Map map, Object key, Object value) {\r\n-        return map.put(key, value);\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove the given key from the given map. Allows subclasses to\r\n-     * take additional actions.\r\n-     */\r\n-    protected Object remove(Map map, Object key) {\r\n-        return map.remove(key);\r\n-    }\r\n-\r\n-    /**\r\n-     * Acquire read lock.\r\n-     */\r\n-    public void readLock() {\r\n-        if (_readLock != null)\r\n-            _readLock.lock();\r\n-    }\r\n-\r\n-    /**\r\n-     * Release read lock.\r\n-     */\r\n-    public void readUnlock() {\r\n-        if (_readLock != null)\r\n-            _readLock.unlock();\r\n-    }\r\n-\r\n-    /**\r\n-     * Acquire write lock.\r\n-     */\r\n-    public void writeLock() {\r\n-        _writeLock.lock();\r\n-    }\r\n-\r\n-    /**\r\n-     * Release write lock.\r\n-     */\r\n-    public void writeUnlock() {\r\n-        _writeLock.unlock();\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether this cache map uses LRU eviction.\r\n-     */\r\n-    public boolean isLRU() {\r\n-        return _readLock != null;\r\n-    }\r\n-\r\n-    /**\r\n-     * The maximum number of hard references to maintain, or -1 for no limit.\r\n-     */\r\n-    public void setCacheSize(int size) {\r\n-        writeLock();\r\n-        try {\r\n-            cacheMap.setMaxSize((size < 0) ? Integer.MAX_VALUE : size);\r\n-        }\r\n-        finally {\r\n-            writeUnlock();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * The maximum number of hard references to maintain, or -1 for no limit.\r\n-     */\r\n-    public int getCacheSize() {\r\n-        int max = cacheMap.getMaxSize();\r\n-        return (max == Integer.MAX_VALUE) ? -1 : max;\r\n-    }\r\n-\r\n-    /**\r\n-     * The maximum number of soft references to maintain, or -1 for no limit.\r\n-     */\r\n-    public void setSoftReferenceSize(int size) {\r\n-        writeLock();\r\n-        try {\r\n-            softMap.setMaxSize((size < 0) ? Integer.MAX_VALUE : size);\r\n-        }\r\n-        finally {\r\n-            writeUnlock();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * The maximum number of soft references to maintain, or -1 for no limit.\r\n-     */\r\n-    public int getSoftReferenceSize() {\r\n-        int max = softMap.getMaxSize();\r\n-        return (max == Integer.MAX_VALUE) ? -1 : max;\r\n-    }\r\n-\r\n-    /**\r\n-     * The keys pinned into the map.\r\n-     */\r\n-    public Set getPinnedKeys() {\r\n-        readLock();\r\n-        try {\r\n-            return Collections.unmodifiableSet(pinnedMap.keySet());\r\n-        }\r\n-        finally {\r\n-            readUnlock();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Locks the given key and its value into the map. Objects pinned into\r\n-     * the map are not counted towards the maximum cache size, and are never\r\n-     * evicted implicitly. You may pin keys for which no value is in the map.\r\n-     *\r\n-     * @return true if the givne key's value was pinned; false if no value\r\n-     *         for the given key is cached\r\n-     */\r\n-    public boolean pin(Object key) {\r\n-        writeLock();\r\n-        try {\r\n-            // if we don't have a pinned map we need to create one; else if the\r\n-            // pinned map already contains the key, nothing to do\r\n-            if (pinnedMap.containsKey(key))\r\n-                return pinnedMap.get(key) != null;\r\n-            // check other maps for key\r\n-            Object val = remove(cacheMap, key);\r\n-            if (val == null)\r\n-                val = remove(softMap, key);\r\n-            // pin key\r\n-            put(pinnedMap, key, val);\r\n-            if (val != null) {\r\n-                _pinnedSize++;\r\n-                return true;\r\n-            }\r\n-            return false;\r\n-        }\r\n-        finally {\r\n-            writeUnlock();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Undo a pinning.\r\n-     */\r\n-    public boolean unpin(Object key) {\r\n-        writeLock();\r\n-        try {\r\n-            Object val = remove(pinnedMap, key);\r\n-            if (val != null) {\r\n-                // put back into unpinned cache\r\n-                put(key, val);\r\n-                _pinnedSize--;\r\n-                return true;\r\n-            }\r\n-            return false;\r\n-        }\r\n-        finally {\r\n-            writeUnlock();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Invoked when a key-value pair is evicted from this data\r\n-     * structure. This is invoked with <code>expired</code> set to\r\n-     * <code>true</code> when an object is dropped because of space\r\n-     * requirements or through garbage collection of soft references.\r\n-     * It is invoked with <code>expired</code> set to <code>false</code>\r\n-     * when an object is explicitly removed via the {@link #remove} or\r\n-     * {@link #clear} methods. This may be invoked more than once for a\r\n-     * given entry.\r\n-     *\r\n-     * @param value may be null if the value was a soft reference that has\r\n-     *              been GCd\r\n-     * @since 2.5.0\r\n-     */\r\n-    protected void entryRemoved(Object key, Object value, boolean expired) {\r\n-    }\r\n-\r\n-    /**\r\n-     * Invoked when an entry is added to the cache. This may be invoked\r\n-     * more than once for an entry.\r\n-     */\r\n-    protected void entryAdded(Object key, Object value) {\r\n-    }\r\n-\r\n-    public Object get(Object key) {\r\n-        readLock();\r\n-        try {\r\n-            Object val = pinnedMap.get(key);\r\n-            if (val != null)\r\n-                return val;\r\n-            val = cacheMap.get(key);\r\n-            if (val == null) {\r\n-                // if we find the key in the soft map, move it back into\r\n-                // the primary map\r\n-                val = softMap.get(key);\r\n-                if (val != null)\r\n-                    put(key, val);\r\n-            }\r\n-            return val;\r\n-        }\r\n-        finally {\r\n-            readUnlock();\r\n-        }\r\n-    }\r\n-\r\n-    public Object put(Object key, Object value) {\r\n-        writeLock();\r\n-        try {\r\n-            // if the key is pinned, just interact directly with the pinned map\r\n-            Object val;\r\n-            if (pinnedMap.containsKey(key)) {\r\n-                val = put(pinnedMap, key, value);\r\n-                if (val == null) {\r\n-                    _pinnedSize++;\r\n-                    entryAdded(key, value);\r\n-                } else {\r\n-                    entryRemoved(key, val, false);\r\n-                    entryAdded(key, value);\r\n-                }\r\n-                return val;\r\n-            }\r\n-            // if no hard refs, don't put anything\r\n-            if (cacheMap.getMaxSize() == 0)\r\n-                return null;\r\n-            // otherwise, put the value into the map and clear it from the\r\n-            // soft map\r\n-            val = put(cacheMap, key, value);\r\n-            if (val == null) {\r\n-                val = remove(softMap, key);\r\n-                if (val == null)\r\n-                    entryAdded(key, value);\r\n-                else {\r\n-                    entryRemoved(key, val, false);\r\n-                    entryAdded(key, value);\r\n-                }\r\n-            } else {\r\n-                entryRemoved(key, val, false);\r\n-                entryAdded(key, value);\r\n-            }\r\n-            return val;\r\n-        }\r\n-        finally {\r\n-            writeUnlock();\r\n-        }\r\n-    }\r\n-\r\n-    public void putAll(Map map) {\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            put(entry.getKey(), entry.getValue());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * If <code>key</code> is pinned into the cache, the pin is\r\n-     * cleared and the object is removed.\r\n-     */\r\n-    public Object remove(Object key) {\r\n-        writeLock();\r\n-        try {\r\n-            // if the key is pinned, just interact directly with the\r\n-            // pinned map\r\n-            Object val;\r\n-            if (pinnedMap.containsKey(key)) {\r\n-                // re-put with null value; we still want key pinned\r\n-                val = put(pinnedMap, key, null);\r\n-                if (val != null) {\r\n-                    _pinnedSize--;\r\n-                    entryRemoved(key, val, false);\r\n-                }\r\n-                return val;\r\n-            }\r\n-            val = remove(cacheMap, key);\r\n-            if (val == null)\r\n-                val = softMap.remove(key);\r\n-            if (val != null)\r\n-                entryRemoved(key, val, false);\r\n-            return val;\r\n-        }\r\n-        finally {\r\n-            writeUnlock();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Removes pinned objects as well as unpinned ones.\r\n-     */\r\n-    public void clear() {\r\n-        writeLock();\r\n-        try {\r\n-            notifyEntryRemovals(pinnedMap.entrySet());\r\n-            pinnedMap.clear();\r\n-            _pinnedSize = 0;\r\n-            notifyEntryRemovals(cacheMap.entrySet());\r\n-            cacheMap.clear();\r\n-            notifyEntryRemovals(softMap.entrySet());\r\n-            softMap.clear();\r\n-        }\r\n-        finally {\r\n-            writeUnlock();\r\n-        }\r\n-    }\r\n-\r\n-    private void notifyEntryRemovals(Set set) {\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = set.iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            if (entry.getValue() != null)\r\n-                entryRemoved(entry.getKey(), entry.getValue(), false);\r\n-        }\r\n-    }\r\n-\r\n-    public int size() {\r\n-        readLock();\r\n-        try {\r\n-            return _pinnedSize + cacheMap.size() + softMap.size();\r\n-        }\r\n-        finally {\r\n-            readUnlock();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean isEmpty() {\r\n-        return size() == 0;\r\n-    }\r\n-\r\n-    public boolean containsKey(Object key) {\r\n-        readLock();\r\n-        try {\r\n-            return pinnedMap.get(key) != null || cacheMap.containsKey(key)\r\n-                || softMap.containsKey(key);\r\n-        }\r\n-        finally {\r\n-            readUnlock();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean containsValue(Object val) {\r\n-        readLock();\r\n-        try {\r\n-            return pinnedMap.containsValue(val)\r\n-                || cacheMap.containsValue(val)\r\n-                || softMap.containsValue(val);\r\n-        }\r\n-        finally {\r\n-            readUnlock();\r\n-        }\r\n-    }\r\n-\r\n-    public Set keySet() {\r\n-        return new KeySet();\r\n-    }\r\n-\r\n-    public Collection values() {\r\n-        return new ValueCollection();\r\n-    }\r\n-\r\n-    public Set entrySet() {\r\n-        return new EntrySet();\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        readLock();\r\n-        try {\r\n-            return \"CacheMap:\" + cacheMap.toString() + \"::\"\r\n-                + softMap.toString();\r\n-        }\r\n-        finally {\r\n-            readUnlock();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * View of the entry set.\r\n-     */\r\n-    private class EntrySet extends AbstractSet {\r\n-\r\n-        public int size() {\r\n-            return CacheMap.this.size();\r\n-        }\r\n-\r\n-        public boolean add(Object o) {\r\n-            Map.Entry entry = (Map.Entry) o;\r\n-            put(entry.getKey(), entry.getValue());\r\n-            return true;\r\n-        }\r\n-\r\n-        public Iterator iterator() {\r\n-            return new EntryIterator(EntryIterator.ENTRY);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * View of the key set.\r\n-     */\r\n-    private class KeySet extends AbstractSet {\r\n-\r\n-        public int size() {\r\n-            return CacheMap.this.size();\r\n-        }\r\n-\r\n-        public Iterator iterator() {\r\n-            return new EntryIterator(EntryIterator.KEY);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * View of the value collection.\r\n-     */\r\n-    private class ValueCollection extends AbstractCollection {\r\n-\r\n-        public int size() {\r\n-            return CacheMap.this.size();\r\n-        }\r\n-\r\n-        public Iterator iterator() {\r\n-            return new EntryIterator(EntryIterator.VALUE);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Iterator over all entries.\r\n-     */\r\n-    private class EntryIterator implements Iterator, Predicate {\r\n-\r\n-        public static final int ENTRY = 0;\r\n-        public static final int KEY = 1;\r\n-        public static final int VALUE = 2;\r\n-        private final IteratorChain _itr = new IteratorChain();\r\n-        private final int _type;\r\n-\r\n-        public EntryIterator(int type) {\r\n-            _type = type;\r\n-            _itr.addIterator(new FilterIterator(getView(pinnedMap), this));\r\n-            _itr.addIterator(getView(cacheMap));\r\n-            _itr.addIterator(getView(softMap));\r\n-        }\r\n-\r\n-        /**\r\n-         * Return an iterator over the appropriate view of the given map.\r\n-         */\r\n-        private Iterator getView(Map m) {\r\n-            if (m == null)\r\n-                return null;\r\n-            switch (_type) {\r\n-                case KEY:\r\n-                    return m.keySet().iterator();\r\n-                case VALUE:\r\n-                    return m.values().iterator();\r\n-                default:\r\n-                    return m.entrySet().iterator();\r\n-            }\r\n-        }\r\n-\r\n-        public boolean hasNext() {\r\n-            return _itr.hasNext();\r\n-        }\r\n-\r\n-        public Object next() {\r\n-            return _itr.next();\r\n-        }\r\n-\r\n-        public void remove() {\r\n-            _itr.remove();\r\n-        }\r\n-\r\n-        public boolean evaluate(Object obj) {\r\n-            switch (_type) {\r\n-                case ENTRY:\r\n-                    return ((Map.Entry) obj).getValue() != null;\r\n-                case VALUE:\r\n-                    return obj != null;\r\n-                default:\r\n-                    return true;\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.util.AbstractCollection;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.iterators.FilterIterator;\n+import org.apache.commons.collections.iterators.IteratorChain;\n+import org.apache.openjpa.lib.util.LRUMap;\n+import org.apache.openjpa.lib.util.ReferenceHashMap;\n+import org.apache.openjpa.lib.util.ReferenceMap;\n+import org.apache.openjpa.lib.util.SizedMap;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n+import org.apache.openjpa.lib.util.concurrent.ReentrantLock;\n+\n+/**\n+ * Fixed-size map that has ability to pin/unpin entries and move overflow to\n+ * a backing soft map.\n+ *\n+ * @author Patrick Linskey\n+ * @author Abe White\n+ */\n+public class CacheMap\n+    implements Map {\n+\n+    /**\n+     * The map for non-expired and non-pinned references.\n+     */\n+    protected final SizedMap cacheMap;\n+\n+    /**\n+     * The map for expired references.\n+     */\n+    protected final SizedMap softMap;\n+\n+    /**\n+     * The set of objects pinned into the cache.\n+     */\n+    protected final Map pinnedMap;\n+\n+    // number of pinned values (not including keys not mapped to values)\n+    private int _pinnedSize = 0;\n+\n+    private final ReentrantLock _writeLock = new ReentrantLock();\n+    private final ReentrantLock _readLock;\n+\n+    /**\n+     * Create a non-LRU (and therefore highly concurrent) cache map with a\n+     * size of 1000.\n+     */\n+    public CacheMap() {\n+        this(false, 1000);\n+    }\n+\n+    /**\n+     * Create a cache map with the given properties.\n+     */\n+    public CacheMap(boolean lru, int max) {\n+        this(lru, max, max / 2, .75F);\n+    }\n+\n+    /**\n+     * Create a cache map with the given properties.\n+     */\n+    public CacheMap(boolean lru, int max, int size, float load) {\n+        if (size < 0)\n+            size = 500;\n+        if (!lru) {\n+            cacheMap = new ConcurrentHashMap(size, load) {\n+                public void overflowRemoved(Object key, Object value) {\n+                    cacheMapOverflowRemoved(key, value);\n+                }\n+            };\n+            softMap = new ConcurrentReferenceHashMap(ReferenceMap.HARD,\n+                ReferenceMap.SOFT, size, load) {\n+                public void overflowRemoved(Object key, Object value) {\n+                    softMapOverflowRemoved(key, value);\n+                }\n+\n+                public void valueExpired(Object key) {\n+                    softMapValueExpired(key);\n+                }\n+            };\n+            pinnedMap = new ConcurrentHashMap();\n+            _readLock = null;\n+        } else {\n+            cacheMap = new LRUMap(size, load) {\n+                public void overflowRemoved(Object key, Object value) {\n+                    cacheMapOverflowRemoved(key, value);\n+                }\n+            };\n+            softMap = new ReferenceHashMap(ReferenceMap.HARD,\n+                ReferenceMap.SOFT, size, load) {\n+                public void overflowRemoved(Object key, Object value) {\n+                    softMapOverflowRemoved(key, value);\n+                }\n+\n+                public void valueExpired(Object key) {\n+                    softMapValueExpired(key);\n+                }\n+            };\n+            pinnedMap = new HashMap();\n+            _readLock = _writeLock;\n+        }\n+        cacheMap.setMaxSize((max < 0) ? Integer.MAX_VALUE : max);\n+    }\n+\n+    /**\n+     * Called from {@link SizedMap#overflowRemoved} in the cache map.\n+     */\n+    protected void cacheMapOverflowRemoved(Object key, Object value) {\n+        if (softMap.size() < softMap.getMaxSize())\n+            put(softMap, key, value);\n+        else\n+            entryRemoved(key, value, true);\n+    }\n+\n+    /**\n+     * Called from {@link SizedMap#overflowRemoved} in the soft map.\n+     */\n+    protected void softMapOverflowRemoved(Object key, Object value) {\n+        entryRemoved(key, value, true);\n+    }\n+\n+    /**\n+     * Called when a value expires from the soft map.\n+     */\n+    protected void softMapValueExpired(Object key) {\n+        entryRemoved(key, null, true);\n+    }\n+\n+    /**\n+     * Put the given entry into the given map.  Allows subclasses to\n+     * take additional actions.\n+     */\n+    protected Object put(Map map, Object key, Object value) {\n+        return map.put(key, value);\n+    }\n+\n+    /**\n+     * Remove the given key from the given map.  Allows subclasses to\n+     * take additional actions.\n+     */\n+    protected Object remove(Map map, Object key) {\n+        return map.remove(key);\n+    }\n+\n+    /**\n+     * Acquire read lock.\n+     */\n+    public void readLock() {\n+        if (_readLock != null)\n+            _readLock.lock();\n+    }\n+\n+    /**\n+     * Release read lock.\n+     */\n+    public void readUnlock() {\n+        if (_readLock != null)\n+            _readLock.unlock();\n+    }\n+\n+    /**\n+     * Acquire write lock.\n+     */\n+    public void writeLock() {\n+        _writeLock.lock();\n+    }\n+\n+    /**\n+     * Release write lock.\n+     */\n+    public void writeUnlock() {\n+        _writeLock.unlock();\n+    }\n+\n+    /**\n+     * Whether this cache map uses LRU eviction.\n+     */\n+    public boolean isLRU() {\n+        return _readLock != null;\n+    }\n+\n+    /**\n+     * The maximum number of hard references to maintain, or -1 for no limit.\n+     */\n+    public void setCacheSize(int size) {\n+        writeLock();\n+        try {\n+            cacheMap.setMaxSize((size < 0) ? Integer.MAX_VALUE : size);\n+        }\n+        finally {\n+            writeUnlock();\n+        }\n+    }\n+\n+    /**\n+     * The maximum number of hard references to maintain, or -1 for no limit.\n+     */\n+    public int getCacheSize() {\n+        int max = cacheMap.getMaxSize();\n+        return (max == Integer.MAX_VALUE) ? -1 : max;\n+    }\n+\n+    /**\n+     * The maximum number of soft references to maintain, or -1 for no limit.\n+     */\n+    public void setSoftReferenceSize(int size) {\n+        writeLock();\n+        try {\n+            softMap.setMaxSize((size < 0) ? Integer.MAX_VALUE : size);\n+        }\n+        finally {\n+            writeUnlock();\n+        }\n+    }\n+\n+    /**\n+     * The maximum number of soft references to maintain, or -1 for no limit.\n+     */\n+    public int getSoftReferenceSize() {\n+        int max = softMap.getMaxSize();\n+        return (max == Integer.MAX_VALUE) ? -1 : max;\n+    }\n+\n+    /**\n+     * The keys pinned into the map.\n+     */\n+    public Set getPinnedKeys() {\n+        readLock();\n+        try {\n+            return Collections.unmodifiableSet(pinnedMap.keySet());\n+        }\n+        finally {\n+            readUnlock();\n+        }\n+    }\n+\n+    /**\n+     * Locks the given key and its value into the map.  Objects pinned into\n+     * the map are not counted towards the maximum cache size, and are never\n+     * evicted implicitly.  You may pin keys for which no value is in the map.\n+     *\n+     * @return true if the givne key's value was pinned; false if no value\n+     * for the given key is cached\n+     */\n+    public boolean pin(Object key) {\n+        writeLock();\n+        try {\n+            // if we don't have a pinned map we need to create one; else if the\n+            // pinned map already contains the key, nothing to do\n+            if (pinnedMap.containsKey(key))\n+                return pinnedMap.get(key) != null;\n+\n+            // check other maps for key\n+            Object val = remove(cacheMap, key);\n+            if (val == null)\n+                val = remove(softMap, key);\n+\n+            // pin key\n+            put(pinnedMap, key, val);\n+            if (val != null) {\n+                _pinnedSize++;\n+                return true;\n+            }\n+            return false;\n+        }\n+        finally {\n+            writeUnlock();\n+        }\n+    }\n+\n+    /**\n+     * Undo a pinning.\n+     */\n+    public boolean unpin(Object key) {\n+        writeLock();\n+        try {\n+            Object val = remove(pinnedMap, key);\n+            if (val != null) {\n+                // put back into unpinned cache\n+                put(key, val);\n+                _pinnedSize--;\n+                return true;\n+            }\n+            return false;\n+        }\n+        finally {\n+            writeUnlock();\n+        }\n+    }\n+\n+    /**\n+     * Invoked when a key-value pair is evicted from this data\n+     * structure. This is invoked with <code>expired</code> set to\n+     * <code>true</code> when an object is dropped because of space\n+     * requirements or through garbage collection of soft references.\n+     * It is invoked with <code>expired</code> set to <code>false</code>\n+     * when an object is explicitly removed via the {@link #remove} or\n+     * {@link #clear} methods.  This may be invoked more than once for a\n+     * given entry.\n+     *\n+     * @param    value    may be null if the value was a soft reference that has\n+     * been GCd\n+     * @since 2.5.0\n+     */\n+    protected void entryRemoved(Object key, Object value, boolean expired) {\n+    }\n+\n+    /**\n+     * Invoked when an entry is added to the cache.  This may be invoked\n+     * more than once for an entry.\n+     */\n+    protected void entryAdded(Object key, Object value) {\n+    }\n+\n+    public Object get(Object key) {\n+        readLock();\n+        try {\n+            Object val = pinnedMap.get(key);\n+            if (val != null)\n+                return val;\n+\n+            val = cacheMap.get(key);\n+            if (val == null) {\n+                // if we find the key in the soft map, move it back into\n+                // the primary map\n+                val = softMap.get(key);\n+                if (val != null)\n+                    put(key, val);\n+            }\n+            return val;\n+        }\n+        finally {\n+            readUnlock();\n+        }\n+    }\n+\n+    public Object put(Object key, Object value) {\n+        writeLock();\n+        try {\n+            // if the key is pinned, just interact directly with the pinned map\n+            Object val;\n+            if (pinnedMap.containsKey(key)) {\n+                val = put(pinnedMap, key, value);\n+                if (val == null) {\n+                    _pinnedSize++;\n+                    entryAdded(key, value);\n+                } else {\n+                    entryRemoved(key, val, false);\n+                    entryAdded(key, value);\n+                }\n+                return val;\n+            }\n+\n+            // if no hard refs, don't put anything\n+            if (cacheMap.getMaxSize() == 0)\n+                return null;\n+\n+            // otherwise, put the value into the map and clear it from the\n+            // soft map\n+            val = put(cacheMap, key, value);\n+            if (val == null) {\n+                val = remove(softMap, key);\n+                if (val == null)\n+                    entryAdded(key, value);\n+                else {\n+                    entryRemoved(key, val, false);\n+                    entryAdded(key, value);\n+                }\n+            } else {\n+                entryRemoved(key, val, false);\n+                entryAdded(key, value);\n+            }\n+            return val;\n+        }\n+        finally {\n+            writeUnlock();\n+        }\n+    }\n+\n+    public void putAll(Map map) {\n+        Map.Entry entry;\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    /**\n+     * If <code>key</code> is pinned into the cache, the pin is\n+     * cleared and the object is removed.\n+     */\n+    public Object remove(Object key) {\n+        writeLock();\n+        try {\n+            // if the key is pinned, just interact directly with the\n+            // pinned map\n+            Object val;\n+            if (pinnedMap.containsKey(key)) {\n+                // re-put with null value; we still want key pinned\n+                val = put(pinnedMap, key, null);\n+                if (val != null) {\n+                    _pinnedSize--;\n+                    entryRemoved(key, val, false);\n+                }\n+                return val;\n+            }\n+\n+            val = remove(cacheMap, key);\n+            if (val == null)\n+                val = softMap.remove(key);\n+            if (val != null)\n+                entryRemoved(key, val, false);\n+\n+            return val;\n+        }\n+        finally {\n+            writeUnlock();\n+        }\n+    }\n+\n+    /**\n+     * Removes pinned objects as well as unpinned ones.\n+     */\n+    public void clear() {\n+        writeLock();\n+        try {\n+            notifyEntryRemovals(pinnedMap.entrySet());\n+            pinnedMap.clear();\n+            _pinnedSize = 0;\n+\n+            notifyEntryRemovals(cacheMap.entrySet());\n+            cacheMap.clear();\n+\n+            notifyEntryRemovals(softMap.entrySet());\n+            softMap.clear();\n+        }\n+        finally {\n+            writeUnlock();\n+        }\n+    }\n+\n+    private void notifyEntryRemovals(Set set) {\n+        Map.Entry entry;\n+        for (Iterator itr = set.iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            if (entry.getValue() != null)\n+                entryRemoved(entry.getKey(), entry.getValue(), false);\n+        }\n+    }\n+\n+    public int size() {\n+        readLock();\n+        try {\n+            return _pinnedSize + cacheMap.size() + softMap.size();\n+        }\n+        finally {\n+            readUnlock();\n+        }\n+    }\n+\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    public boolean containsKey(Object key) {\n+        readLock();\n+        try {\n+            return pinnedMap.get(key) != null\n+                || cacheMap.containsKey(key)\n+                || softMap.containsKey(key);\n+        }\n+        finally {\n+            readUnlock();\n+        }\n+    }\n+\n+    public boolean containsValue(Object val) {\n+        readLock();\n+        try {\n+            return pinnedMap.containsValue(val)\n+                || cacheMap.containsValue(val)\n+                || softMap.containsValue(val);\n+        }\n+        finally {\n+            readUnlock();\n+        }\n+    }\n+\n+    public Set keySet() {\n+        return new KeySet();\n+    }\n+\n+    public Collection values() {\n+        return new ValueCollection();\n+    }\n+\n+    public Set entrySet() {\n+        return new EntrySet();\n+    }\n+\n+    public String toString() {\n+        readLock();\n+        try {\n+            return \"CacheMap:\" + cacheMap.toString() + \"::\"\n+                + softMap.toString();\n+        }\n+        finally {\n+            readUnlock();\n+        }\n+    }\n+\n+    /**\n+     * View of the entry set.\n+     */\n+    private class EntrySet\n+        extends AbstractSet {\n+\n+        public int size() {\n+            return CacheMap.this.size();\n+        }\n+\n+        public boolean add(Object o) {\n+            Map.Entry entry = (Map.Entry) o;\n+            put(entry.getKey(), entry.getValue());\n+            return true;\n+        }\n+\n+        public Iterator iterator() {\n+            return new EntryIterator(EntryIterator.ENTRY);\n+        }\n+    }\n+\n+    /**\n+     * View of the key set.\n+     */\n+    private class KeySet\n+        extends AbstractSet {\n+\n+        public int size() {\n+            return CacheMap.this.size();\n+        }\n+\n+        public Iterator iterator() {\n+            return new EntryIterator(EntryIterator.KEY);\n+        }\n+    }\n+\n+    /**\n+     * View of the value collection.\n+     */\n+    private class ValueCollection\n+        extends AbstractCollection {\n+\n+        public int size() {\n+            return CacheMap.this.size();\n+        }\n+\n+        public Iterator iterator() {\n+            return new EntryIterator(EntryIterator.VALUE);\n+        }\n+    }\n+\n+    /**\n+     *\tIterator over all entries.\n+     */\n+    private class EntryIterator\n+        implements Iterator, Predicate {\n+\n+        public static final int ENTRY = 0;\n+        public static final int KEY = 1;\n+        public static final int VALUE = 2;\n+\n+        private final IteratorChain _itr = new IteratorChain();\n+        private final int _type;\n+\n+        public EntryIterator(int type) {\n+            _type = type;\n+            _itr.addIterator(new FilterIterator(getView(pinnedMap), this));\n+            _itr.addIterator(getView(cacheMap));\n+            _itr.addIterator(getView(softMap));\n+        }\n+\n+        /**\n+         * Return an iterator over the appropriate view of the given map.\n+         */\n+        private Iterator getView(Map m) {\n+            if (m == null)\n+                return null;\n+\n+            switch (_type) {\n+                case KEY:\n+                    return m.keySet().iterator();\n+                case VALUE:\n+                    return m.values().iterator();\n+                default:\n+                    return m.entrySet().iterator();\n+            }\n+        }\n+\n+        public boolean hasNext() {\n+            return _itr.hasNext();\n+        }\n+\n+        public Object next() {\n+            return _itr.next();\n+        }\n+\n+        public void remove() {\n+            _itr.remove();\n+        }\n+\n+        public boolean evaluate(Object obj) {\n+            switch (_type) {\n+                case ENTRY:\n+                    return ((Map.Entry) obj).getValue() != null;\n+\t\t\tcase VALUE:\n+\t\t\t\treturn obj != null;\n+\t\t\tdefault:\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+"},{"sha":"df043ce3d250f1d21643847a0f37fbf161a72873","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/CallbackException.java","status":"modified","additions":42,"deletions":38,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/CallbackException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/CallbackException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/CallbackException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,38 +1,42 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-/**\r\n- * Exception type thrown when an error occurs in a callback.\r\n- *\r\n- * @author Marc Prud'hommeaux\r\n- * @since 4.0\r\n- */\r\n-public class CallbackException extends UserException {\r\n-\r\n-    public CallbackException() {\r\n-    }\r\n-\r\n-    public CallbackException(String msg) {\r\n-        super(msg);\r\n-    }\r\n-\r\n-    public CallbackException(String msg, Object failed) {\r\n-        super(msg);\r\n-        setFailedObject(failed);\r\n-    }\r\n-\r\n-    public int getSubtype() {\r\n-        return CALLBACK;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+/**\n+ * <p>Exception type thrown when an error occurs in a callback.</p>\n+ *\n+ * @since 4.0\n+ * @author Marc Prud'hommeaux\n+ */\n+public class CallbackException\n+    extends UserException {\n+\n+    public CallbackException() {\n+    }\n+\n+    public CallbackException(String msg) {\n+        super(msg);\n+    }\n+\n+    public CallbackException(String msg, Object failed) {\n+        super(msg);\n+        setFailedObject(failed);\n+    }\n+\n+    public int getSubtype() {\n+        return CALLBACK;\n+    }\n+}"},{"sha":"94c30aec6770ad06e5528aa3ca588b973d50ef0d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ChangeTracker.java","status":"modified","additions":86,"deletions":83,"changes":169,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ChangeTracker.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ChangeTracker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ChangeTracker.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,83 +1,86 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.util.Collection;\r\n-\r\n-/**\r\n- * Interface for components that track changes to containers at a\r\n- * fine-grained level. Proxies that use change trackers might have better\r\n- * update performance than non-tracking proxies.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public interface ChangeTracker {\r\n-\r\n-    /**\r\n-     * Return true if this tracker has an up-to-date view of all the changes\r\n-     * to the container it is managing.\r\n-     */\r\n-    public boolean isTracking();\r\n-\r\n-    /**\r\n-     * Reset the state of the change tracker, and turn change tracking back\r\n-     * on if it has been disabled.\r\n-     */\r\n-    public void startTracking();\r\n-\r\n-    /**\r\n-     * Tell the tracker to stop tracking changes for its container.\r\n-     */\r\n-    public void stopTracking();\r\n-\r\n-    /**\r\n-     * Return the collection of values that need to be added to the managed\r\n-     * container.\r\n-     */\r\n-    public Collection getAdded();\r\n-\r\n-    /**\r\n-     * Return the set of values that need to be removed from the managed\r\n-     * container.\r\n-     */\r\n-    public Collection getRemoved();\r\n-\r\n-    /**\r\n-     * Return the set of elements that have changed. In maps, this marks a\r\n-     * possible change in value for a key. In collections, this marks an\r\n-     * element that has been removed and re-added.\r\n-     */\r\n-    public Collection getChanged();\r\n-\r\n-    /**\r\n-     * The next element sequence value for this proxy at load time.\r\n-     * If the data store keeps this proxy's data in sequence order but allows\r\n-     * holes for removed objects, the implementation can set the next\r\n-     * sequence at load time, then retrieve it and start from there for\r\n-     * added objects at flush time. This value is set back to 0 if the\r\n-     * proxy stops tracking changes. For ordered proxies, it is set to the\r\n-     * proxy's size when the proxy starts tracking changes again.\r\n-     */\r\n-    public int getNextSequence();\r\n-\r\n-    /**\r\n-     * The maximum element sequence value for this proxy at load time.\r\n-     * If the data store keeps this proxy's data in sequence order but allows\r\n-     * holes for removed objects, the implementation can set the next\r\n-     * sequence at load time, then retrieve it and start from there for\r\n-     * added objects at flush time. This value is set back to 0 if the\r\n-     * proxy stops tracking changes. For ordered proxies, it is set to the\r\n-     * proxy's size when the proxy starts tracking changes again.\r\n-     */\r\n-    public void setNextSequence(int seq);\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.util.Collection;\n+\n+/**\n+ * <p>Interface for components that track changes to containers at a\n+ * fine-grained level.  Proxies that use change trackers might have better\n+ * update performance than non-tracking proxies.</p>\n+ *\n+ * @author Abe White\n+ */\n+public interface ChangeTracker {\n+\n+    /**\n+     * Return true if this tracker has an up-to-date view of all the changes\n+     * to the container it is managing.\n+     */\n+    public boolean isTracking();\n+\n+    /**\n+     * Reset the state of the change tracker, and turn change tracking back\n+     * on if it has been disabled.\n+     */\n+    public void startTracking();\n+\n+    /**\n+     * Tell the tracker to stop tracking changes for its container.\n+     */\n+    public void stopTracking();\n+\n+    /**\n+     * Return the collection of values that need to be added to the managed\n+     * container.\n+     */\n+    public Collection getAdded();\n+\n+    /**\n+     * Return the set of values that need to be removed from the managed\n+     * container.\n+     */\n+    public Collection getRemoved();\n+\n+    /**\n+     * Return the set of elements that have changed.  In maps, this marks a\n+     * possible change in value for a key.  In collections, this marks an\n+     * element that has been removed and re-added.\n+     */\n+    public Collection getChanged();\n+\n+    /**\n+     * The next element sequence value for this proxy at load time.\n+     * If the data store keeps this proxy's data in sequence order but allows\n+     * holes for removed objects, the implementation can set the next\n+     * sequence at load time, then retrieve it and start from there for\n+     * added objects at flush time.  This value is set back to 0 if the\n+     * proxy stops tracking changes.  For ordered proxies, it is set to the\n+     * proxy's size when the proxy starts tracking changes again.\n+     */\n+    public int getNextSequence();\n+\n+    /**\n+     *\tThe maximum element sequence value for this proxy at load time.\n+     *\tIf the data store keeps this proxy's data in sequence order but allows\n+     *\tholes for removed objects, the implementation can set the next\n+     *\tsequence at load time, then retrieve it and start from there for\n+     *\tadded objects at flush time.  This value is set back to 0 if the\n+     *\tproxy stops tracking changes.  For ordered proxies, it is set to the\n+     *\tproxy's size when the proxy starts tracking changes again.\n+     */\n+    public void setNextSequence (int seq);\n+}"},{"sha":"6e962a3ec4f713707a6443886e7c09f609abf313","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/CharId.java","status":"modified","additions":64,"deletions":61,"changes":125,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/CharId.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/CharId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/CharId.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,61 +1,64 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-/**\r\n- * {@link OpenJPAId} subclass appropriate for char fields.\r\n- *\r\n- * @author Steve Kim\r\n- */\r\n-public final class CharId extends OpenJPAId {\r\n-\r\n-    private final char key;\r\n-\r\n-    public CharId(Class cls, Character key) {\r\n-        this(cls, (key == null) ? (char) 0 : key.charValue());\r\n-    }\r\n-\r\n-    public CharId(Class cls, String key) {\r\n-        this(cls, (key == null) ? (char) 0 : key.charAt(0));\r\n-    }\r\n-\r\n-    public CharId(Class cls, char key) {\r\n-        super(cls);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public CharId(Class cls, char key, boolean subs) {\r\n-        super(cls, subs);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public char getId() {\r\n-        return key;\r\n-    }\r\n-\r\n-    public Object getIdObject() {\r\n-        return new Character(key);\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return String.valueOf(key);\r\n-    }\r\n-\r\n-    protected int idHash() {\r\n-        return key;\r\n-    }\r\n-\r\n-    protected boolean idEquals(OpenJPAId o) {\r\n-        return key == ((CharId) o).key;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+/**\n+ * {@link OpenJPAId} subclass appropriate for char fields.\n+ *\n+ * @author Steve Kim\n+ */\n+public final class CharId extends OpenJPAId {\n+\n+    private final char key;\n+\n+    public CharId(Class cls, Character key) {\n+        this(cls, (key == null) ? (char) 0 : key.charValue());\n+    }\n+\n+    public CharId(Class cls, String key) {\n+        this(cls, (key == null) ? (char) 0 : key.charAt(0));\n+    }\n+\n+    public CharId(Class cls, char key) {\n+        super(cls);\n+        this.key = key;\n+    }\n+\n+    public CharId(Class cls, char key, boolean subs) {\n+        super(cls, subs);\n+        this.key = key;\n+    }\n+\n+    public char getId() {\n+        return key;\n+    }\n+\n+    public Object getIdObject() {\n+        return new Character(key);\n+    }\n+\n+    public String toString() {\n+        return String.valueOf(key);\n+    }\n+\n+    protected int idHash() {\n+        return key;\n+    }\n+\n+    protected boolean idEquals(OpenJPAId o) {\n+        return key == ((CharId) o).key;\n+    }\n+}"},{"sha":"4c6501518f356007464970814eeb289288e75cc5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolver.java","status":"modified","additions":43,"deletions":39,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolver.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolver.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolver.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,39 +1,43 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import org.apache.openjpa.lib.util.MultiClassLoader;\r\n-\r\n-/**\r\n- * Interface to customize the loading of classes under OpenJPA.\r\n- *\r\n- * @author Marc Prud'hommeaux\r\n- * @author Abe White\r\n- * @since 3.0\r\n- */\r\n-public interface ClassResolver {\r\n-\r\n-    /**\r\n-     * Return a class loader that can be used to load classes and resources.\r\n-     * This can be a standard class loader, or a customized loader such\r\n-     * as a {@link MultiClassLoader}.\r\n-     *\r\n-     * @param contextClass the context class; may be null if no context class\r\n-     * @param envLoader    the thread's context class loader when the\r\n-     *                     persistence environment(i.e. broker)\r\n-     *                     was obtained; may be null if operating outside\r\n-     *                     the context of persistence environment\r\n-     */\r\n-    public ClassLoader getClassLoader(Class contextClass,\r\n-        ClassLoader envLoader);\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import org.apache.openjpa.lib.util.MultiClassLoader;\n+\n+/**\n+ * <p>Interface to customize the loading of classes under OpenJPA.</p>\n+ *\n+ * @since 3.0\n+ * @author Marc Prud'hommeaux\n+ * @author Abe White\n+ */\n+public interface ClassResolver {\n+\n+    /**\n+     * Return a class loader that can be used to load classes and resources.\n+     * This can be a standard class loader, or a customized loader such\n+     * as a {@link MultiClassLoader}.\n+     *\n+     * @param    contextClass    the context class; may be null if no context\n+     * class\n+     * @param    envLoader        the thread's context class loader when the\n+     * persistence environment (i.e. broker)\n+     * was obtained; may be null if operating outside\n+     * the context of persistence environment\n+     */\n+    public ClassLoader getClassLoader(Class contextClass,\n+        ClassLoader envLoader);\n+}"},{"sha":"0c776db11feea5bcaabb11642db35af134e54e62","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolverImpl.java","status":"modified","additions":59,"deletions":53,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolverImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolverImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolverImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,53 +1,59 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import org.apache.openjpa.lib.util.MultiClassLoader;\r\n-\r\n-/**\r\n- * Default class resolver implementation.\r\n- *\r\n- * @author Abe White\r\n- * @since 3.0\r\n- */\r\n-public class ClassResolverImpl implements ClassResolver {\r\n-\r\n-    public ClassLoader getClassLoader(Class contextClass,\r\n-        ClassLoader envLoader) {\r\n-        // get the context class' loader; if the class was loaded by the\r\n-        // bootstrap loader, use the system classloader in the hopes that\r\n-        // class.forName calls on it will find the bootstrap loader's cached\r\n-        // class(the bootstrap loader is the parent of the system loader)\r\n-        ClassLoader contextLoader = null;\r\n-        if (contextClass != null) {\r\n-            contextLoader = contextClass.getClassLoader();\r\n-            if (contextLoader == null)\r\n-                contextLoader = ClassLoader.getSystemClassLoader();\r\n-        }\r\n-        // if there is only one unique loader, just return it\r\n-        ClassLoader threadLoader = Thread.currentThread().\r\n-            getContextClassLoader();\r\n-        if ((contextLoader == null || contextLoader == threadLoader)\r\n-            && (envLoader == null || envLoader == threadLoader))\r\n-            return threadLoader;\r\n-        // construct a multi class loader that will delegate in the order\r\n-        // described in section 12.5 of the spec\r\n-        MultiClassLoader loader = new MultiClassLoader();\r\n-        if (contextLoader != null)\r\n-            loader.addClassLoader(contextLoader);\r\n-        loader.addClassLoader(threadLoader);\r\n-        if (envLoader != null)\r\n-            loader.addClassLoader(envLoader);\r\n-        return loader;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import org.apache.openjpa.lib.util.MultiClassLoader;\n+\n+/**\n+ * <p>Default class resolver implementation.</p>\n+ *\n+ * @since 3.0\n+ * @author Abe White\n+ */\n+public class ClassResolverImpl\n+    implements ClassResolver {\n+\n+    public ClassLoader getClassLoader(Class contextClass,\n+        ClassLoader envLoader) {\n+        // get the context class' loader; if the class was loaded by the\n+        // bootstrap loader, use the system classloader in the hopes that\n+        // class.forName calls on it will find the bootstrap loader's cached\n+        // class (the bootstrap loader is the parent of the system loader)\n+        ClassLoader contextLoader = null;\n+        if (contextClass != null) {\n+            contextLoader = contextClass.getClassLoader();\n+            if (contextLoader == null)\n+                contextLoader = ClassLoader.getSystemClassLoader();\n+        }\n+\n+        // if there is only one unique loader, just return it\n+        ClassLoader threadLoader = Thread.currentThread().\n+            getContextClassLoader();\n+        if ((contextLoader == null || contextLoader == threadLoader)\n+            && (envLoader == null || envLoader == threadLoader))\n+            return threadLoader;\n+\n+        // construct a multi class loader that will delegate in the order\n+        // described in section 12.5 of the spec\n+        MultiClassLoader loader = new MultiClassLoader();\n+        if (contextLoader != null)\n+            loader.addClassLoader(contextLoader);\n+        loader.addClassLoader(threadLoader);\n+        if (envLoader != null)\n+            loader.addClassLoader(envLoader);\n+        return loader;\n+    }\n+}"},{"sha":"2e7b55bfc6b01d0d3c00a2efb62ab5914826e2bb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTracker.java","status":"modified","additions":38,"deletions":34,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTracker.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTracker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTracker.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,34 +1,38 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-/**\r\n- * Change tracker that can be used for collections. If the user calls\r\n- * any mutating methods on the collection that do not have an equivalent in\r\n- * this change tracker, then you must call {@link #stopTracking} after\r\n- * applying the operation to the collection.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public interface CollectionChangeTracker extends ChangeTracker {\r\n-\r\n-    /**\r\n-     * Record that the given element was added.\r\n-     */\r\n-    public void added(Object elem);\r\n-\r\n-    /**\r\n-     * Record that the given element was removed.\r\n-     */\r\n-    public void removed(Object elem);\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+/**\n+ * <p>Change tracker that can be used for collections.  If the user calls\n+ * any mutating methods on the collection that do not have an equivalent in\n+ * this change tracker, then you must call {@link #stopTracking} after\n+ * applying the operation to the collection.</p>\n+ *\n+ * @author Abe White\n+ */\n+public interface CollectionChangeTracker\n+    extends ChangeTracker {\n+\n+    /**\n+     * Record that the given element was added.\n+     */\n+    public void added(Object elem);\n+\n+    /**\n+     * Record that the given element was removed.\n+     */\n+    public void removed(Object elem);\n+}"},{"sha":"10d09e85c9e1a988cd68cf0c5cbed8c51fd3769c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTrackerImpl.java","status":"modified","additions":113,"deletions":107,"changes":220,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTrackerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTrackerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTrackerImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,107 +1,113 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-\r\n-/**\r\n- * Default {@link CollectionChangeTracker}.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class CollectionChangeTrackerImpl extends AbstractChangeTracker\r\n-    implements CollectionChangeTracker {\r\n-\r\n-    private final Collection _coll;\r\n-    private final boolean _dups;\r\n-    private final boolean _order;\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param coll  the collection to delegate to\r\n-     * @param dups  true if the collection allows duplicates, false otherwise\r\n-     * @param order true if the collection is ordered, false otherwise\r\n-     */\r\n-    public CollectionChangeTrackerImpl(Collection coll, boolean dups,\r\n-        boolean order, OpenJPAConfiguration conf) {\r\n-        super(conf);\r\n-        _coll = coll;\r\n-        _dups = dups;\r\n-        _order = order;\r\n-    }\r\n-\r\n-    public void added(Object elem) {\r\n-        super.added(elem);\r\n-    }\r\n-\r\n-    public void removed(Object elem) {\r\n-        super.removed(elem);\r\n-    }\r\n-\r\n-    protected int initialSequence() {\r\n-        if (_order)\r\n-            return _coll.size();\r\n-        return super.initialSequence();\r\n-    }\r\n-\r\n-    protected void add(Object elem) {\r\n-        if (rem == null || !rem.remove(elem)) {\r\n-            // after a point it's inefficient to keep tracking\r\n-            if (getAutoOff()\r\n-                && getAdded().size() + getRemoved().size() >= _coll.size())\r\n-                stopTracking();\r\n-            else {\r\n-                if (add == null) {\r\n-                    if (_dups || _order)\r\n-                        add = new ArrayList();\r\n-                    else add = newSet();\r\n-                }\r\n-                add.add(elem);\r\n-            }\r\n-        } else if (_order)\r\n-            stopTracking();\r\n-        else {\r\n-            if (change == null)\r\n-                change = newSet();\r\n-            change.add(elem);\r\n-        }\r\n-    }\r\n-\r\n-    protected void remove(Object elem) {\r\n-        // if the collection contains multiple copies of the elem, we can't\r\n-        // use change tracking because some back-ends can't just delete a\r\n-        // single copy of a elem\r\n-        if (_dups && getAutoOff() && _coll.contains(elem))\r\n-            stopTracking();\r\n-        else if (add == null || !add.remove(elem)) {\r\n-            // after a point it's inefficient to keep tracking\r\n-            if (getAutoOff()\r\n-                && getRemoved().size() + getAdded().size() >= _coll.size())\r\n-                stopTracking();\r\n-            else {\r\n-                if (rem == null)\r\n-                    rem = newSet();\r\n-                rem.add(elem);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    protected void change(Object elem) {\r\n-        throw new InternalException();\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+\n+/**\n+ * <p>Default {@link CollectionChangeTracker}.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class CollectionChangeTrackerImpl\n+    extends AbstractChangeTracker\n+    implements CollectionChangeTracker {\n+\n+    private final Collection _coll;\n+    private final boolean _dups;\n+    private final boolean _order;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param    coll    the collection to delegate to\n+     * @param    dups    true if the collection allows duplicates, false\n+     * otherwise\n+     * @param    order    true if the collection is ordered, false otherwise\n+     */\n+    public CollectionChangeTrackerImpl(Collection coll, boolean dups,\n+        boolean order, OpenJPAConfiguration conf) {\n+        super(conf);\n+        _coll = coll;\n+        _dups = dups;\n+        _order = order;\n+    }\n+\n+    public void added(Object elem) {\n+        super.added(elem);\n+    }\n+\n+    public void removed(Object elem) {\n+        super.removed(elem);\n+    }\n+\n+    protected int initialSequence() {\n+        if (_order)\n+            return _coll.size();\n+        return super.initialSequence();\n+    }\n+\n+    protected void add(Object elem) {\n+        if (rem == null || !rem.remove(elem)) {\n+            // after a point it's inefficient to keep tracking\n+            if (getAutoOff()\n+                && getAdded().size() + getRemoved().size() >= _coll.size())\n+                stopTracking();\n+            else {\n+                if (add == null) {\n+                    if (_dups || _order)\n+                        add = new ArrayList();\n+                    else\n+                        add = newSet();\n+                }\n+                add.add(elem);\n+            }\n+        } else if (_order)\n+            stopTracking();\n+        else {\n+            if (change == null)\n+                change = newSet();\n+            change.add(elem);\n+        }\n+    }\n+\n+    protected void remove(Object elem) {\n+        // if the collection contains multiple copies of the elem, we can't\n+        // use change tracking because some back-ends can't just delete a\n+        // single copy of a elem\n+        if (_dups && getAutoOff() && _coll.contains(elem))\n+            stopTracking();\n+        else if (add == null || !add.remove(elem)) {\n+            // after a point it's inefficient to keep tracking\n+            if (getAutoOff()\n+                && getRemoved().size() + getAdded().size() >= _coll.size())\n+                stopTracking();\n+            else {\n+                if (rem == null)\n+                    rem = newSet();\n+                rem.add(elem);\n+            }\n+        }\n+    }\n+\n+    protected void change(Object elem) {\n+        throw new InternalException();\n+    }\n+}"},{"sha":"36b1548b71cd719074ef5221a609d970b62a9da9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/DateId.java","status":"modified","additions":72,"deletions":68,"changes":140,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/DateId.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/DateId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/DateId.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,68 +1,72 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.util.Date;\r\n-\r\n-/**\r\n- * {@link OpenJPAId} subclass appropriate for Date fields.\r\n- *\r\n- * @author Marc Prud'hommeaux\r\n- */\r\n-public final class DateId extends OpenJPAId {\r\n-\r\n-    private final Date key;\r\n-\r\n-    public DateId(Class cls, String key) {\r\n-        this(cls, new Date(Long.parseLong(key)));\r\n-    }\r\n-\r\n-    public DateId(Class cls, Date key) {\r\n-        super(cls);\r\n-        this.key = key == null ? new Date(0) : key;\r\n-    }\r\n-\r\n-    public DateId(Class cls, java.sql.Date key) {\r\n-        this(cls, (Date) key);\r\n-    }\r\n-\r\n-    public DateId(Class cls, java.sql.Timestamp key) {\r\n-        this(cls, (Date) key);\r\n-    }\r\n-\r\n-    public DateId(Class cls, Date key, boolean subs) {\r\n-        super(cls, subs);\r\n-        this.key = key == null ? new Date(0) : key;\r\n-    }\r\n-\r\n-    public Date getId() {\r\n-        return key;\r\n-    }\r\n-\r\n-    public Object getIdObject() {\r\n-        return getId();\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return Long.toString(key.getTime());\r\n-    }\r\n-\r\n-    protected int idHash() {\r\n-        return key.hashCode();\r\n-    }\r\n-\r\n-    protected boolean idEquals(OpenJPAId o) {\r\n-        return key.equals(((DateId) o).key);\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.util.Date;\n+\n+/**\n+ * {@link OpenJPAId} subclass appropriate for Date fields.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+public final class DateId\n+    extends OpenJPAId {\n+\n+    private final Date key;\n+\n+    public DateId(Class cls, String key) {\n+        this(cls, new Date(Long.parseLong(key)));\n+    }\n+\n+    public DateId(Class cls, Date key) {\n+        super(cls);\n+        this.key = key == null ? new Date(0) : key;\n+    }\n+\n+    public DateId(Class cls, java.sql.Date key) {\n+        this(cls, (Date) key);\n+    }\n+\n+    public DateId(Class cls, java.sql.Timestamp key) {\n+        this(cls, (Date) key);\n+    }\n+\n+    public DateId(Class cls, Date key, boolean subs) {\n+        super(cls, subs);\n+        this.key = key == null ? new Date(0) : key;\n+    }\n+\n+    public Date getId() {\n+        return key;\n+    }\n+\n+    public Object getIdObject() {\n+        return getId();\n+    }\n+\n+    public String toString() {\n+        return Long.toString(key.getTime());\n+    }\n+\n+    protected int idHash() {\n+        return key.hashCode();\n+    }\n+\n+    protected boolean idEquals(OpenJPAId o) {\n+        return key.equals(((DateId) o).key);\n+    }\n+}\n+"},{"sha":"5662a3eaa10fcf34ee5d17f4a3826c198a9656d4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ExceptionInfo.java","status":"modified","additions":80,"deletions":77,"changes":157,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ExceptionInfo.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ExceptionInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ExceptionInfo.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,77 +1,80 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-/**\r\n- * Interface supplying additional exception information. All OpenJPA\r\n- * exceptions implement this interface.\r\n- *\r\n- * @author Abe White\r\n- * @since 4.0\r\n- */\r\n-public interface ExceptionInfo {\r\n-\r\n-    public static final int GENERAL = 0;\r\n-    public static final int INTERNAL = 1;\r\n-    public static final int STORE = 2;\r\n-    public static final int UNSUPPORTED = 3;\r\n-    public static final int USER = 4;\r\n-\r\n-    /**\r\n-     * Exception message.\r\n-     *\r\n-     * @see Throwable#getMessage\r\n-     */\r\n-    public String getMessage();\r\n-\r\n-    /**\r\n-     * Returns the first {@link Throwable} from {@link #getNestedThrowables}\r\n-     * in order to conform to {@link Throwable#getCause} in Java 1.4+.\r\n-     *\r\n-     * @see Throwable#getCause\r\n-     */\r\n-    public Throwable getCause();\r\n-\r\n-    /**\r\n-     * Stack.\r\n-     *\r\n-     * @see Throwable#printStackTrace\r\n-     */\r\n-    public void printStackTrace();\r\n-\r\n-    /**\r\n-     * Exception type.\r\n-     */\r\n-    public int getType();\r\n-\r\n-    /**\r\n-     * Exception subtype.\r\n-     */\r\n-    public int getSubtype();\r\n-\r\n-    /**\r\n-     * Whether this error is fatal.\r\n-     */\r\n-    public boolean isFatal();\r\n-\r\n-    /**\r\n-     * The nested throwables.\r\n-     */\r\n-    public Throwable[] getNestedThrowables();\r\n-\r\n-    /**\r\n-     * The failed object.\r\n-     */\r\n-    public Object getFailedObject();\r\n-}\r\n-\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+/**\n+ * <p>Interface supplying additional exception information.  All OpenJPA\n+ * exceptions implement this interface.</p>\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+public interface ExceptionInfo {\n+\n+    public static final int GENERAL = 0;\n+    public static final int INTERNAL = 1;\n+    public static final int STORE = 2;\n+    public static final int UNSUPPORTED = 3;\n+    public static final int USER = 4;\n+\n+    /**\n+     * Exception message.\n+     *\n+     * @see    Throwable#getMessage\n+     */\n+    public String getMessage();\n+\n+    /**\n+     * Returns the first {@link Throwable} from {@link #getNestedThrowables}\n+     * in order to conform to {@link Throwable#getCause} in Java 1.4+.\n+     *\n+     * @see Throwable#getCause\n+     */\n+    public Throwable getCause();\n+\n+    /**\n+     * Stack.\n+     *\n+     * @see    Throwable#printStackTrace\n+     */\n+    public void printStackTrace();\n+\n+    /**\n+     * Exception type.\n+     */\n+    public int getType();\n+\n+    /**\n+     * Exception subtype.\n+     */\n+    public int getSubtype();\n+\n+    /**\n+     * Whether this error is fatal.\n+     */\n+    public boolean isFatal();\n+\n+    /**\n+     * The nested throwables.\n+     */\n+    public Throwable[] getNestedThrowables();\n+\n+    /**\n+     *\tThe failed object.\n+     */\n+    public Object getFailedObject ();\n+}\n+"},{"sha":"847808b927205280c645afe96043f5b80ab13a59","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java","status":"modified","additions":248,"deletions":227,"changes":475,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,227 +1,248 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.ObjectOutputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PrintStream;\r\n-import java.io.PrintWriter;\r\n-import java.io.Serializable;\r\n-import java.util.Collection;\r\n-import java.util.Iterator;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAVersion;\r\n-import org.apache.openjpa.enhance.PersistenceCapable;\r\n-import org.apache.openjpa.lib.util.JavaVersions;\r\n-\r\n-/**\r\n- * Utility methods for externalizing and handling exceptions.\r\n- *\r\n- * @author Marc Prud'hommeaux\r\n- * @nojavadoc\r\n- * @since 2.5\r\n- */\r\n-public class Exceptions {\r\n-\r\n-    public static final Throwable[] EMPTY_THROWABLES = new Throwable[0];\r\n-    static final String SEP = System.getProperty(\"line.separator\");\r\n-    private static final OutputStream DEV_NULL = new OutputStream() {\r\n-        public void write(int b) {\r\n-        }\r\n-    };\r\n-\r\n-    /**\r\n-     * Test to see if the specified object will be able to be serialized. This\r\n-     * will check if the object implements {@link Serializable}, and if so,\r\n-     * will try to perform an actual serialization. This is in case the object\r\n-     * has fields which, in turn, are not serializable.\r\n-     *\r\n-     * @param ob the object to test\r\n-     * @return true if the object will be able to be serialized\r\n-     */\r\n-    private static boolean isSerializable(Object ob) {\r\n-        if (!(ob instanceof Serializable))\r\n-            return false;\r\n-        // don't serialize persistent objects exceptions to prevent\r\n-        // reading in all the state\r\n-        if (!ImplHelper.isManagedType(ob.getClass()))\r\n-            return false;\r\n-        // now do an actual test to see if we will be\r\n-        // able to perform the serialization\r\n-        try {\r\n-            new ObjectOutputStream(DEV_NULL).writeObject(ob);\r\n-            return true;\r\n-        } catch (Throwable t) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Safely stringify the given object.\r\n-     */\r\n-    public static String toString(Object ob) {\r\n-        if (ob == null)\r\n-            return \"null\";\r\n-        // don't take oid of new objects since it can cause a flush if auto-inc\r\n-        // and the id is meaningless anyway\r\n-        Object oid = getObjectId(ob);\r\n-        if (oid != null) {\r\n-            if (oid instanceof Id)\r\n-                return oid.toString();\r\n-            return ob.getClass().getName() + \"-\" + oid.toString();\r\n-        }\r\n-        if (ImplHelper.isManagedType(ob.getClass())) {\r\n-            // never call toString() on a PersistenceCapable, since\r\n-            // it may access persistent fields; fall-back to using\r\n-            // the standard object stringification mechanism. New\r\n-            // instances that use proxying(property-access instances,\r\n-            // for example) that were created with the 'new' keyword\r\n-            // will not end up in this code, which is ok since they\r\n-            // don't do lazy loading anyways, so they will stringify\r\n-            // safely.\r\n-            return ob.getClass().getName() + \"@\"\r\n-                + Integer.toHexString(System.identityHashCode(ob));\r\n-        }\r\n-        try {\r\n-            String s = ob.toString();\r\n-            if (s.indexOf(ob.getClass().getName()) == -1)\r\n-                s += \" [\" + ob.getClass().getName() + \"]\";\r\n-            return s;\r\n-        } catch (Throwable t) {\r\n-            return ob.getClass().getName();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Safely stringify the given objects.\r\n-     */\r\n-    public static String toString(Collection failed) {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        buf.append(\"[\");\r\n-        for (Iterator itr = failed.iterator(); itr.hasNext();) {\r\n-            buf.append(Exceptions.toString(itr.next()));\r\n-            if (itr.hasNext())\r\n-                buf.append(\", \");\r\n-        }\r\n-        buf.append(\"]\");\r\n-        return buf.toString();\r\n-    }\r\n-\r\n-    /**\r\n-     * Stringify the given exception.\r\n-     */\r\n-    public static String toString(ExceptionInfo e) {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        buf.append(\"<\").append(e.getType()). append('|').append(e.isFatal()).\r\n-            append('|').append(OpenJPAVersion.VERSION_NUMBER). append(\"> \");\r\n-        buf.append(e.getClass().getName()).append(\": \").\r\n-            append(e.getMessage());\r\n-        Object failed = e.getFailedObject();\r\n-        if (failed != null)\r\n-            buf.append(SEP).append(\"FailedObject: \"). append(toString(failed));\r\n-        return buf.toString();\r\n-    }\r\n-\r\n-    /**\r\n-     * Print the stack trace of the exception's nested throwables.\r\n-     */\r\n-    public static void printNestedThrowables(ExceptionInfo e, PrintStream out) {\r\n-        // if this is Java 1.4 and there is exactly a single\r\n-        // exception, then defer to 1.4's behavior of printing\r\n-        // out the result of getCause(). This deferral happens in\r\n-        // the calling code.\r\n-        Throwable[] nested = e.getNestedThrowables();\r\n-        int i = (JavaVersions.VERSION >= 4) ? 1 : 0;\r\n-        if (i < nested.length) {\r\n-            out.println(\"NestedThrowables:\");\r\n-            for (; i < nested.length; i++)\r\n-                nested[i].printStackTrace(out);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Print the stack trace of the exception's nested throwables.\r\n-     */\r\n-    public static void printNestedThrowables(ExceptionInfo e, PrintWriter out) {\r\n-        // if this is Java 1.4 and there is exactly a single\r\n-        // exception, then defer to 1.4's behavior of printing\r\n-        // out the result of getCause(). This deferral happens in\r\n-        // the calling code.\r\n-        Throwable[] nested = e.getNestedThrowables();\r\n-        int i = (JavaVersions.VERSION >= 4) ? 1 : 0;\r\n-        if (i < nested.length) {\r\n-            out.println(\"NestedThrowables:\");\r\n-            for (; i < nested.length; i++)\r\n-                nested[i].printStackTrace(out);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Convert the specified failed object into a serializable\r\n-     * object for when we are serializing an Exception. It will\r\n-     * try the following:\r\n-     * <ul>\r\n-     * <li>if the object can be serialized, return the object itself</li>\r\n-     * <li>if the object has a serializable oid, return the oid</li>\r\n-     * <li>if the object has a non-serializable oid, return the oid's\r\n-     * toString and the object class</li>\r\n-     * <li>return the object's toString</li>\r\n-     * </ul>\r\n-     *\r\n-     * @param ob the object to convert\r\n-     * @return some serialized representation of the object\r\n-     */\r\n-    public static Object replaceFailedObject(Object ob) {\r\n-        if (ob == null)\r\n-            return null;\r\n-        if (isSerializable(ob))\r\n-            return ob;\r\n-        // don't take oid of new objects since it can cause a flush if auto-inc\r\n-        // and the id is meaningless anyway\r\n-        Object oid = getObjectId(ob);\r\n-        if (oid != null && isSerializable(oid))\r\n-            return oid;\r\n-        // last ditch: stringify the object\r\n-        return toString(ob);\r\n-    }\r\n-\r\n-    /**\r\n-     * Convert the specified throwables into a serialzable array. If\r\n-     * any of the nested throwables cannot be serialized, they will\r\n-     * be converted into a Exception with the original message.\r\n-     */\r\n-    public static Throwable[] replaceNestedThrowables(Throwable[] nested) {\r\n-        if (nested == null || nested.length == 0)\r\n-            return nested;\r\n-        if (isSerializable(nested))\r\n-            return nested;\r\n-        Throwable[] newNested = new Throwable[nested.length];\r\n-        for (int i = 0; i < nested.length; i++) {\r\n-            if (isSerializable(nested[i]))\r\n-                newNested[i] = nested[i];\r\n-            else newNested[i] = new Exception(nested[i].toString());\r\n-        }\r\n-        return newNested;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the object id for <code>ob</code> if it has one, or\r\n-     * <code>null</code> otherwise.\r\n-     */\r\n-    private static Object getObjectId(Object ob) {\r\n-        if (ob instanceof PersistenceCapable\r\n-            && !((PersistenceCapable) ob).pcIsNew())\r\n-            return ((PersistenceCapable) ob).pcFetchObjectId();\r\n-        else return null;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.openjpa.conf.OpenJPAVersion;\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.lib.util.JavaVersions;\n+\n+/**\n+ * Utility methods for externalizing and handling exceptions.\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @since 2.5\n+ * @nojavadoc\n+ */\n+public class Exceptions {\n+\n+    public static final Throwable[] EMPTY_THROWABLES = new Throwable[0];\n+\n+    static final String SEP = System.getProperty(\"line.separator\");\n+\n+    private static final OutputStream DEV_NULL = new OutputStream() {\n+        public void write(int b) {\n+        }\n+    };\n+\n+    /**\n+     * Test to see if the specified object will be able to be serialized. This\n+     * will check if the object implements {@link Serializable}, and if so,\n+     * will try to perform an actual serialization. This is in case the object\n+     * has fields which, in turn, are not serializable.\n+     *\n+     * @param ob the object to test\n+     * @return true if the object will be able to be serialized\n+     */\n+    private static boolean isSerializable(Object ob) {\n+        if (!(ob instanceof Serializable))\n+            return false;\n+\n+        // don't serialize persistent objects exceptions to prevent\n+        // reading in all the state\n+        if (!ImplHelper.isManagedType(ob.getClass()))\n+            return false;\n+\n+        // now do an actual test to see if we will be\n+        // able to perform the serialization\n+        try {\n+            new ObjectOutputStream(DEV_NULL).writeObject(ob);\n+            return true;\n+        }\n+        catch (Throwable t) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Safely stringify the given object.\n+     */\n+    public static String toString(Object ob) {\n+        if (ob == null)\n+            return \"null\";\n+\n+        // don't take oid of new objects since it can cause a flush if auto-inc\n+        // and the id is meaningless anyway\n+        Object oid = getObjectId(ob);\n+\n+        if (oid != null) {\n+            if (oid instanceof Id)\n+                return oid.toString();\n+            return ob.getClass().getName() + \"-\" + oid.toString();\n+        }\n+\n+        if (ImplHelper.isManagedType(ob.getClass())) {\n+            // never call toString() on a PersistenceCapable, since\n+            // it may access persistent fields; fall-back to using\n+            // the standard object stringification mechanism. New\n+            // instances that use proxying (property-access instances,\n+            // for example) that were created with the 'new' keyword\n+            // will not end up in this code, which is ok since they\n+            // don't do lazy loading anyways, so they will stringify\n+            // safely.\n+            return ob.getClass().getName() + \"@\"\n+                + Integer.toHexString(System.identityHashCode(ob));\n+        }\n+\n+        try {\n+            String s = ob.toString();\n+            if (s.indexOf(ob.getClass().getName()) == -1)\n+                s += \" [\" + ob.getClass().getName() + \"]\";\n+            return s;\n+        }\n+        catch (Throwable t) {\n+            return ob.getClass().getName();\n+        }\n+    }\n+\n+    /**\n+     * Safely stringify the given objects.\n+     */\n+    public static String toString(Collection failed) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"[\");\n+        for (Iterator itr = failed.iterator(); itr.hasNext();) {\n+            buf.append(Exceptions.toString(itr.next()));\n+            if (itr.hasNext())\n+                buf.append(\", \");\n+        }\n+        buf.append(\"]\");\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Stringify the given exception.\n+     */\n+    public static String toString(ExceptionInfo e) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"<\").append(e.getType()).\n+            append('|').append(e.isFatal()).\n+            append('|').append(OpenJPAVersion.VERSION_NUMBER).\n+            append(\"> \");\n+        buf.append(e.getClass().getName()).append(\": \").\n+            append(e.getMessage());\n+        Object failed = e.getFailedObject();\n+        if (failed != null)\n+            buf.append(SEP).append(\"FailedObject: \").\n+                append(toString(failed));\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Print the stack trace of the exception's nested throwables.\n+     */\n+    public static void printNestedThrowables(ExceptionInfo e, PrintStream out) {\n+        // if this is Java 1.4 and there is exactly a single\n+        // exception, then defer to 1.4's behavior of printing\n+        // out the result of getCause(). This deferral happens in\n+        // the calling code.\n+        Throwable[] nested = e.getNestedThrowables();\n+        int i = (JavaVersions.VERSION >= 4) ? 1 : 0;\n+        if (i < nested.length) {\n+            out.println(\"NestedThrowables:\");\n+            for (; i < nested.length; i++)\n+                nested[i].printStackTrace(out);\n+        }\n+    }\n+\n+    /**\n+     * Print the stack trace of the exception's nested throwables.\n+     */\n+    public static void printNestedThrowables(ExceptionInfo e, PrintWriter out) {\n+        // if this is Java 1.4 and there is exactly a single\n+        // exception, then defer to 1.4's behavior of printing\n+        // out the result of getCause(). This deferral happens in\n+        // the calling code.\n+        Throwable[] nested = e.getNestedThrowables();\n+        int i = (JavaVersions.VERSION >= 4) ? 1 : 0;\n+        if (i < nested.length) {\n+            out.println(\"NestedThrowables:\");\n+            for (; i < nested.length; i++)\n+                nested[i].printStackTrace(out);\n+        }\n+    }\n+\n+    /**\n+     * Convert the specified failed object into a serializable\n+     * object for when we are serializing an Exception. It will\n+     * try the following:\n+     * <ul>\n+     * <li>if the object can be serialized, return the object itself</li>\n+     * <li>if the object has a serializable oid, return the oid</li>\n+     * <li>if the object has a non-serializable oid, return the oid's\n+     * toString and the object class</li>\n+     * <li>return the object's toString</li>\n+     * </ul>\n+     *\n+     * @param ob the object to convert\n+     * @return some serialized representation of the object\n+     */\n+    public static Object replaceFailedObject(Object ob) {\n+        if (ob == null)\n+            return null;\n+        if (isSerializable(ob))\n+            return ob;\n+\n+        // don't take oid of new objects since it can cause a flush if auto-inc\n+        // and the id is meaningless anyway\n+        Object oid = getObjectId(ob);\n+        if (oid != null && isSerializable(oid))\n+            return oid;\n+\n+        // last ditch: stringify the object\n+        return toString(ob);\n+    }\n+\n+    /**\n+     * Convert the specified throwables into a serialzable array. If\n+     * any of the nested throwables cannot be serialized, they will\n+     * be converted into a Exception with the original message.\n+     */\n+    public static Throwable[] replaceNestedThrowables(Throwable[] nested) {\n+        if (nested == null || nested.length == 0)\n+            return nested;\n+        if (isSerializable(nested))\n+            return nested;\n+\n+        Throwable[] newNested = new Throwable[nested.length];\n+        for (int i = 0; i < nested.length; i++) {\n+            if (isSerializable(nested[i]))\n+                newNested[i] = nested[i];\n+            else\n+                newNested[i] = new Exception(nested[i].toString());\n+        }\n+        return newNested;\n+    }\n+\n+    /**\n+     *\tReturn the object id for <code>ob</code> if it has one, or\n+     *\t<code>null</code> otherwise.\n+     */\n+    private static Object getObjectId(Object ob) {\n+        if (ob instanceof PersistenceCapable\n+            && !((PersistenceCapable) ob).pcIsNew())\n+            return ((PersistenceCapable) ob).pcFetchObjectId();\n+        else\n+\t\t\treturn null;\n+\t}\n+}"},{"sha":"39ee4a82d1acb849add5473891c4e59b6eeeb0c3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneralException.java","status":"modified","additions":44,"deletions":40,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneralException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneralException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneralException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,40 +1,44 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-/**\r\n- * General exception type.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public class GeneralException extends OpenJPAException {\r\n-\r\n-    public GeneralException() {\r\n-    }\r\n-\r\n-    public GeneralException(String msg) {\r\n-        super(msg);\r\n-    }\r\n-\r\n-    public GeneralException(Throwable cause) {\r\n-        super(cause);\r\n-    }\r\n-\r\n-    public GeneralException(String msg, Throwable cause) {\r\n-        super(msg, cause);\r\n-    }\r\n-\r\n-    public int getType() {\r\n-        return GENERAL;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+/**\n+ * <p>General exception type.</p>\n+ *\n+ * @author Abe White\n+ */\n+public class GeneralException\n+    extends OpenJPAException {\n+\n+    public GeneralException() {\n+    }\n+\n+    public GeneralException(String msg) {\n+        super(msg);\n+    }\n+\n+    public GeneralException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    public GeneralException(String msg, Throwable cause) {\n+        super(msg, cause);\n+    }\n+\n+    public int getType() {\n+        return GENERAL;\n+    }\n+}"},{"sha":"b34287b6060fefeac707aed010896c2be643f7d0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java","status":"modified","additions":150,"deletions":142,"changes":292,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,142 +1,150 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import serp.util.Numbers;\r\n-\r\n-/**\r\n- * Datastore identity type. Implementations may choose to use this type,\r\n- * or choose to use their own datastore identity values.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public final class Id extends OpenJPAId {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage(Id.class);\r\n-    private final long _id;\r\n-\r\n-    /**\r\n-     * Create an id from the given type and value; the value might be an\r\n-     * id instnace, a stringified id, or a primary key value.\r\n-     */\r\n-    public static Id newInstance(Class cls, Object val) {\r\n-        if (val instanceof Id)\r\n-            return (Id) val;\r\n-        if (val instanceof String)\r\n-            return new Id(cls, (String) val);\r\n-        if (val instanceof Number)\r\n-            return new Id(cls, ((Number) val).longValue());\r\n-        if (val == null)\r\n-            return new Id(cls, 0L);\r\n-        throw new UserException(_loc.get(\"unknown-oid\", cls, val,\r\n-            val.getClass()));\r\n-    }\r\n-\r\n-    /**\r\n-     * Create an id from the result of a {@link #toString} call on another\r\n-     * instance.\r\n-     */\r\n-    public Id(String str) {\r\n-        this(str, (ClassLoader) null);\r\n-    }\r\n-\r\n-    /**\r\n-     * Create an id from the result of an {@link #toString} call on another\r\n-     * instance.\r\n-     */\r\n-    public Id(String str, OpenJPAConfiguration conf, ClassLoader brokerLoader) {\r\n-        this(str, (conf == null) ? brokerLoader : conf.\r\n-            getClassResolverInstance().getClassLoader(Id.class, brokerLoader));\r\n-    }\r\n-\r\n-    /**\r\n-     * Create an id from the result of an {@link #toString} call on another\r\n-     * instance.\r\n-     */\r\n-    public Id(String str, ClassLoader loader) {\r\n-        if (loader == null)\r\n-            loader = Thread.currentThread().getContextClassLoader();\r\n-        if (str == null)\r\n-            _id = 0L;\r\n-        else {\r\n-            int dash = str.indexOf('-');\r\n-            try {\r\n-                type = Class.forName(str.substring(0, dash), true, loader);\r\n-            } catch (Throwable t) {\r\n-                throw new UserException(_loc.get(\"string-id\", str), t);\r\n-            }\r\n-            _id = Long.parseLong(str.substring(dash + 1));\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct from the result of a {@link #toString} call on another\r\n-     * instance.\r\n-     */\r\n-    public Id(Class cls, String key) {\r\n-        super(cls);\r\n-        if (key == null)\r\n-            _id = 0L;\r\n-        else {\r\n-            // allow either stringified long or result of Id.toString\r\n-            int dash = key.indexOf('-');\r\n-            if (dash > 0) // don't check for -1; might be negative number\r\n-                key = key.substring(dash + 1);\r\n-            _id = Long.parseLong(key);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct from key value.\r\n-     */\r\n-    public Id(Class cls, Long key) {\r\n-        this(cls, (key == null) ? 0L : key.longValue());\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct from key value.\r\n-     */\r\n-    public Id(Class cls, long key) {\r\n-        super(cls);\r\n-        _id = key;\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct from key value.\r\n-     */\r\n-    public Id(Class cls, long key, boolean subs) {\r\n-        super(cls, subs);\r\n-        _id = key;\r\n-    }\r\n-\r\n-    /**\r\n-     * Primary key.\r\n-     */\r\n-    public long getId() {\r\n-        return _id;\r\n-    }\r\n-\r\n-    public Object getIdObject() {\r\n-        return Numbers.valueOf(_id);\r\n-    }\r\n-\r\n-    protected int idHash() {\r\n-        return (int) (_id ^ (_id >>> 32));\r\n-    }\r\n-\r\n-    protected boolean idEquals(OpenJPAId other) {\r\n-        return _id == ((Id) other)._id;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.util.Localizer;\n+import serp.util.Numbers;\n+\n+/**\n+ * <p>Datastore identity type.  Implementations may choose to use this type,\n+ * or choose to use their own datastore identity values.</p>\n+ *\n+ * @author Abe White\n+ */\n+public final class Id\n+    extends OpenJPAId {\n+\n+    private static final Localizer _loc = Localizer.forPackage(Id.class);\n+\n+    private final long _id;\n+\n+    /**\n+     * Create an id from the given type and value; the value might be an\n+     * id instnace, a stringified id, or a primary key value.\n+     */\n+    public static Id newInstance(Class cls, Object val) {\n+        if (val instanceof Id)\n+            return (Id) val;\n+        if (val instanceof String)\n+            return new Id(cls, (String) val);\n+        if (val instanceof Number)\n+            return new Id(cls, ((Number) val).longValue());\n+        if (val == null)\n+            return new Id(cls, 0L);\n+        throw new UserException(_loc.get(\"unknown-oid\", cls, val,\n+            val.getClass()));\n+    }\n+\n+    /**\n+     * Create an id from the result of a {@link #toString} call on another\n+     * instance.\n+     */\n+    public Id(String str) {\n+        this(str, (ClassLoader) null);\n+    }\n+\n+    /**\n+     * Create an id from the result of an {@link #toString} call on another\n+     * instance.\n+     */\n+    public Id(String str, OpenJPAConfiguration conf, ClassLoader brokerLoader) {\n+        this(str, (conf == null) ? brokerLoader : conf.\n+            getClassResolverInstance().getClassLoader(Id.class, brokerLoader));\n+    }\n+\n+    /**\n+     * Create an id from the result of an {@link #toString} call on another\n+     * instance.\n+     */\n+    public Id(String str, ClassLoader loader) {\n+        if (loader == null)\n+            loader = Thread.currentThread().getContextClassLoader();\n+\n+        if (str == null)\n+            _id = 0L;\n+        else {\n+            int dash = str.indexOf('-');\n+            try {\n+                type = Class.forName(str.substring(0, dash), true, loader);\n+            }\n+            catch (Throwable t) {\n+                throw new UserException(_loc.get(\"string-id\", str), t);\n+            }\n+            _id = Long.parseLong(str.substring(dash + 1));\n+        }\n+    }\n+\n+    /**\n+     * Construct from the result of a {@link #toString} call on another\n+     * instance.\n+     */\n+    public Id(Class cls, String key) {\n+        super(cls);\n+\n+        if (key == null)\n+            _id = 0L;\n+        else {\n+            // allow either stringified long or result of Id.toString\n+            int dash = key.indexOf('-');\n+            if (dash > 0)    // don't check for -1; might be negative number\n+                key = key.substring(dash + 1);\n+            _id = Long.parseLong(key);\n+        }\n+    }\n+\n+    /**\n+     * Construct from key value.\n+     */\n+    public Id(Class cls, Long key) {\n+        this(cls, (key == null) ? 0L : key.longValue());\n+    }\n+\n+    /**\n+     * Construct from key value.\n+     */\n+    public Id(Class cls, long key) {\n+        super(cls);\n+        _id = key;\n+    }\n+\n+    /**\n+     * Construct from key value.\n+     */\n+    public Id(Class cls, long key, boolean subs) {\n+        super(cls, subs);\n+        _id = key;\n+    }\n+\n+    /**\n+     * Primary key.\n+     */\n+    public long getId() {\n+        return _id;\n+    }\n+\n+    public Object getIdObject() {\n+        return Numbers.valueOf(_id);\n+    }\n+\n+    protected int idHash() {\n+        return (int) (_id ^ (_id >>> 32));\n+    }\n+\n+    protected boolean idEquals(OpenJPAId other) {\n+        return _id == ((Id) other)._id;\n+\t}\n+}"},{"sha":"f69a764504b9e97d05bf1d485069846cf5828292","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","status":"modified","additions":273,"deletions":260,"changes":533,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,260 +1,273 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.lang.reflect.Method;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.Iterator;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.enhance.PersistenceCapable;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.FetchState;\r\n-import org.apache.openjpa.kernel.LockManager;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.PCState;\r\n-import org.apache.openjpa.kernel.StoreContext;\r\n-import org.apache.openjpa.kernel.StoreManager;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Closeable;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.UUIDGenerator;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.meta.SequenceMetaData;\r\n-import org.apache.openjpa.meta.ValueStrategies;\r\n-import serp.util.Strings;\r\n-\r\n-/**\r\n- * Helper for OpenJPA back-ends.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- * @since 3.0\r\n- */\r\n-public class ImplHelper {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (ImplHelper.class);\r\n-\r\n-    /**\r\n-     * Return the getter method matching the given property name.\r\n-     */\r\n-    public static Method getGetter(Class cls, String prop) {\r\n-        prop = StringUtils.capitalize(prop);\r\n-        try {\r\n-            return cls.getMethod(\"get\" + prop, (Class[]) null);\r\n-        } catch (Exception e) {\r\n-            try {\r\n-                return cls.getMethod(\"is\" + prop, (Class[]) null);\r\n-            } catch (Exception e2) {\r\n-                throw new UserException(_loc.get(\"bad-getter\", cls,\r\n-                    prop)).setCause(e);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the setter method matching the given property name.\r\n-     */\r\n-    public static Method getSetter(Class cls, String prop) {\r\n-        Method getter = getGetter(cls, prop);\r\n-        prop = StringUtils.capitalize(prop);\r\n-        try {\r\n-            return cls.getMethod(\"set\" + prop,\r\n-                new Class[]{ getter.getReturnType() });\r\n-        } catch (Exception e) {\r\n-            throw new UserException(_loc.get(\"bad-setter\", cls, prop)).\r\n-                setCause(e);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Helper for store manager implementations. This method simply delegates\r\n-     * to the proper singular method for each state manager.\r\n-     *\r\n-     * @see StoreManager#loadAll\r\n-     * @since 4.0\r\n-     */\r\n-    public static Collection loadAll(Collection sms, StoreManager store,\r\n-        PCState state, int load, FetchState fetchState, Object context) {\r\n-        Collection failed = null;\r\n-        OpenJPAStateManager sm;\r\n-        FetchConfiguration fc;\r\n-        LockManager lm;\r\n-        for (Iterator itr = sms.iterator(); itr.hasNext();) {\r\n-            sm = (OpenJPAStateManager) itr.next();\r\n-            if (sm.getManagedInstance() == null) {\r\n-                if (!store.initialize(sm, state, fetchState, context))\r\n-                    failed = addFailedId(sm, failed);\r\n-            } else if (load != StoreManager.FORCE_LOAD_NONE\r\n-                || sm.getPCState() == PCState.HOLLOW) {\r\n-                fc = (load == StoreManager.FORCE_LOAD_ALL) ? null\r\n-                    : fetchState.getFetchConfiguration();\r\n-                lm = sm.getContext().getLockManager();\r\n-                if (!store.load(sm, sm.getUnloaded(fetchState),\r\n-                    fetchState, lm.getLockLevel(sm), context))\r\n-                    failed = addFailedId(sm, failed);\r\n-            } else if (!store.exists(sm, context))\r\n-                failed = addFailedId(sm, failed);\r\n-        }\r\n-        return (failed == null) ? Collections.EMPTY_LIST : failed;\r\n-    }\r\n-\r\n-    /**\r\n-     * Add identity of given instance to collection.\r\n-     */\r\n-    private static Collection addFailedId(OpenJPAStateManager sm,\r\n-        Collection failed) {\r\n-        if (failed == null)\r\n-            failed = new ArrayList();\r\n-        failed.add(sm.getId());\r\n-        return failed;\r\n-    }\r\n-\r\n-    /**\r\n-     * Generate a value for the given metadata, or return null. Generates\r\n-     * values for hte following strategies: {@link ValueStrategies#SEQUENCE},\r\n-     * {@link ValueStrategies#UUID_STRING}, {@link ValueStrategies#UUID_HEX}\r\n-     */\r\n-    public static Object generateIdentityValue(StoreContext ctx,\r\n-        ClassMetaData meta, int typeCode) {\r\n-        return generateValue(ctx, meta, null, typeCode);\r\n-    }\r\n-\r\n-    /**\r\n-     * Generate a value for the given metadata, or return null. Generates\r\n-     * values for hte following strategies: {@link ValueStrategies#SEQUENCE},\r\n-     * {@link ValueStrategies#UUID_STRING}, {@link ValueStrategies#UUID_HEX}\r\n-     */\r\n-    public static Object generateFieldValue(StoreContext ctx,\r\n-        FieldMetaData fmd) {\r\n-        return generateValue(ctx, null, fmd, fmd.getDeclaredTypeCode());\r\n-    }\r\n-\r\n-    /**\r\n-     * Generate a value for the given metadaa.\r\n-     */\r\n-    private static Object generateValue(StoreContext ctx,\r\n-        ClassMetaData meta, FieldMetaData fmd, int typeCode) {\r\n-        int strategy = (fmd == null) ? meta.getIdentityStrategy()\r\n-            : fmd.getValueStrategy();\r\n-        switch (strategy) {\r\n-            case ValueStrategies.SEQUENCE:\r\n-                SequenceMetaData smd = (fmd == null)\r\n-                    ? meta.getIdentitySequenceMetaData()\r\n-                    : fmd.getValueSequenceMetaData();\r\n-                return JavaTypes.convert(smd.getInstance(ctx.getClassLoader()).\r\n-                    next(ctx, meta), typeCode);\r\n-            case ValueStrategies.UUID_STRING:\r\n-                return UUIDGenerator.nextString();\r\n-            case ValueStrategies.UUID_HEX:\r\n-                return UUIDGenerator.nextHex();\r\n-            default:\r\n-                return null;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the store-specific facade class for the given broker\r\n-     * component class. This method is used by facade implementations to\r\n-     * wrap store-specific components without knowing about all possible\r\n-     * back-ends.\r\n-     *\r\n-     * @param conf        configuration for runtime\r\n-     * @param openjpaCls  class of OpenJPA component(e.g.\r\n-     *                    JDBCFetchConfiguration.class)\r\n-     * @param openjpaSuff suffix of OpenJPA component(e.g. \"FetchConfiguration\")\r\n-     * @param facadePkg   the unqualified facade package name(e.g. \"jdo\")\r\n-     * @param facadeCls   the generic facade interface's class(e.g.\r\n-     *                    FetchPlan.class)\r\n-     * @param facadeSuff  the suffix to append to the store prefix to get\r\n-     *                    the implementation class name(e.g. \"FetchPlanImpl\")\r\n-     *                    or null to use the unqualified name of\r\n-     *                    <code>facadeCls</code>\r\n-     * @return the class formed by taking the top-most org.apache.openjpa.aaa package and\r\n-     *         BBBStoreManager name prefix from <code>storeCls</code> and\r\n-     *         combining them with the facade package ccc and suffix DDD to\r\n-     *         get: org.apache.openjpa.ccc.aaa.BBBDDD\r\n-     */\r\n-    public static Class getStoreFacadeType(OpenJPAConfiguration conf,\r\n-        Class openjpaCls, String openjpaSuff, String facadePkg, Class facadeCls,\r\n-        String facadeSuff) {\r\n-        String clsName = openjpaCls.getName();\r\n-        int dotIdx = clsName.lastIndexOf('.');\r\n-        int suffixIdx = clsName.indexOf(openjpaSuff, dotIdx + 1);\r\n-        if (!clsName.startsWith(\"org.apache.openjpa.\") || suffixIdx == -1)\r\n-            return null;\r\n-\r\n-        // extract 'xxx.' from org.apache.openjpa.xxx.yyy..., and XXX from XXXStoreManager\r\n-        String pkg = clsName.substring(5, clsName.indexOf('.', 5) + 1);\r\n-        String prefix = clsName.substring(dotIdx + 1, suffixIdx);\r\n-        // suffix of impl class name\r\n-        if (facadeSuff == null)\r\n-            facadeSuff = Strings.getClassName(facadeCls);\r\n-        clsName =\r\n-            \"org.apache.openjpa.\" + facadePkg + \".\" + pkg + prefix + facadeSuff;\r\n-        try {\r\n-            return Class.forName(clsName, true, facadeCls.getClassLoader());\r\n-        } catch (ClassNotFoundException ncfe) {\r\n-            Log log = conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(_loc.get(\"no-store-exts\", clsName));\r\n-            return null;\r\n-        } catch (Exception e) {\r\n-            throw new InternalException(e);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Close the given resource. The resource can be an extent iterator,\r\n-     * query result, large result set relation, or any closeable OpenJPA\r\n-     * component.\r\n-     */\r\n-    public static void close(Object o) {\r\n-        try {\r\n-            if (o instanceof Closeable)\r\n-                ((Closeable) o).close();\r\n-        } catch (RuntimeException re) {\r\n-            throw re;\r\n-        } catch (Exception e) {\r\n-            throw new GeneralException(e);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns true if the specified class is a type that can be managed by\r\n-     * OpenJPA.\r\n-     *\r\n-     * @param type the class to test\r\n-     * @param conf the configuration that defines the current context\r\n-     * @return true if the class is manageable.\r\n-     */\r\n-    public static boolean isManagedType(Class type) {\r\n-        return PersistenceCapable.class.isAssignableFrom(type);\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns true if the specified instance is manageable.\r\n-     *\r\n-     * @param instance the object to check\r\n-     * @return true if the instance is a persistent type, false otherwise\r\n-     */\r\n-    public static boolean isManageable(Object instance) {\r\n-        return instance instanceof PersistenceCapable;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.FetchState;\n+import org.apache.openjpa.kernel.LockManager;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.PCState;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Closeable;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.UUIDGenerator;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.SequenceMetaData;\n+import org.apache.openjpa.meta.ValueStrategies;\n+import serp.util.Strings;\n+\n+/**\n+ * <p>Helper for OpenJPA back-ends.</p>\n+ *\n+ * @since 3.0\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ImplHelper {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ImplHelper.class);\n+\n+    /**\n+     * Return the getter method matching the given property name.\n+     */\n+    public static Method getGetter(Class cls, String prop) {\n+        prop = StringUtils.capitalize(prop);\n+        try {\n+            return cls.getMethod(\"get\" + prop, (Class[]) null);\n+        }\n+        catch (Exception e) {\n+            try {\n+                return cls.getMethod(\"is\" + prop, (Class[]) null);\n+            }\n+            catch (Exception e2) {\n+                throw new UserException(_loc.get(\"bad-getter\", cls,\n+                    prop)).setCause(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return the setter method matching the given property name.\n+     */\n+    public static Method getSetter(Class cls, String prop) {\n+        Method getter = getGetter(cls, prop);\n+        prop = StringUtils.capitalize(prop);\n+        try {\n+            return cls.getMethod(\"set\" + prop,\n+                new Class[]{ getter.getReturnType() });\n+        }\n+        catch (Exception e) {\n+            throw new UserException(_loc.get(\"bad-setter\", cls, prop)).\n+                setCause(e);\n+        }\n+    }\n+\n+    /**\n+     * Helper for store manager implementations.  This method simply delegates\n+     * to the proper singular method for each state manager.\n+     *\n+     * @see    StoreManager#loadAll\n+     * @since 4.0\n+     */\n+    public static Collection loadAll(Collection sms, StoreManager store,\n+        PCState state, int load, FetchState fetchState, Object context) {\n+        Collection failed = null;\n+        OpenJPAStateManager sm;\n+        FetchConfiguration fc;\n+        LockManager lm;\n+        for (Iterator itr = sms.iterator(); itr.hasNext();) {\n+            sm = (OpenJPAStateManager) itr.next();\n+            if (sm.getManagedInstance() == null) {\n+                if (!store.initialize(sm, state, fetchState, context))\n+                    failed = addFailedId(sm, failed);\n+            } else if (load != StoreManager.FORCE_LOAD_NONE\n+                || sm.getPCState() == PCState.HOLLOW) {\n+                fc = (load == StoreManager.FORCE_LOAD_ALL) ? null\n+                    : fetchState.getFetchConfiguration();\n+\n+                lm = sm.getContext().getLockManager();\n+                if (!store.load(sm, sm.getUnloaded(fetchState),\n+                    fetchState, lm.getLockLevel(sm), context))\n+                    failed = addFailedId(sm, failed);\n+            } else if (!store.exists(sm, context))\n+                failed = addFailedId(sm, failed);\n+        }\n+        return (failed == null) ? Collections.EMPTY_LIST : failed;\n+    }\n+\n+    /**\n+     * Add identity of given instance to collection.\n+     */\n+    private static Collection addFailedId(OpenJPAStateManager sm,\n+        Collection failed) {\n+        if (failed == null)\n+            failed = new ArrayList();\n+        failed.add(sm.getId());\n+        return failed;\n+    }\n+\n+    /**\n+     * Generate a value for the given metadata, or return null.  Generates\n+     * values for hte following strategies: {@link ValueStrategies#SEQUENCE},\n+     * {@link ValueStrategies#UUID_STRING}, {@link ValueStrategies#UUID_HEX}\n+     */\n+    public static Object generateIdentityValue(StoreContext ctx,\n+        ClassMetaData meta, int typeCode) {\n+        return generateValue(ctx, meta, null, typeCode);\n+    }\n+\n+    /**\n+     * Generate a value for the given metadata, or return null.  Generates\n+     * values for hte following strategies: {@link ValueStrategies#SEQUENCE},\n+     * {@link ValueStrategies#UUID_STRING}, {@link ValueStrategies#UUID_HEX}\n+     */\n+    public static Object generateFieldValue(StoreContext ctx,\n+        FieldMetaData fmd) {\n+        return generateValue(ctx, null, fmd, fmd.getDeclaredTypeCode());\n+    }\n+\n+    /**\n+     * Generate a value for the given metadaa.\n+     */\n+    private static Object generateValue(StoreContext ctx,\n+        ClassMetaData meta, FieldMetaData fmd, int typeCode) {\n+        int strategy = (fmd == null) ? meta.getIdentityStrategy()\n+            : fmd.getValueStrategy();\n+        switch (strategy) {\n+            case ValueStrategies.SEQUENCE:\n+                SequenceMetaData smd = (fmd == null)\n+                    ? meta.getIdentitySequenceMetaData()\n+                    : fmd.getValueSequenceMetaData();\n+                return JavaTypes.convert(smd.getInstance(ctx.getClassLoader()).\n+                    next(ctx, meta), typeCode);\n+            case ValueStrategies.UUID_STRING:\n+                return UUIDGenerator.nextString();\n+            case ValueStrategies.UUID_HEX:\n+                return UUIDGenerator.nextHex();\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    /**\n+     * Return the store-specific facade class for the given broker\n+     * component class.  This method is used by facade implementations to\n+     * wrap store-specific components without knowing about all possible\n+     * back-ends.\n+     *\n+     * @param    conf        configuration for runtime\n+     * @param    openjpaCls        class of OpenJPA component (e.g.\n+     * JDBCFetchConfiguration.class)\n+     * @param    openjpaSuff    suffix of OpenJPA component (e.g. \"FetchConfiguration\")\n+     * @param    facadePkg    the unqualified facade package name (e.g. \"jdo\")\n+     * @param    facadeCls    the generic facade interface's class (e.g.\n+     * FetchPlan.class)\n+     * @param    facadeSuff    the suffix to append to the store prefix to get\n+     * the implementation class name (e.g. \"FetchPlanImpl\")\n+     * or null to use the unqualified name of\n+     * <code>facadeCls</code>\n+     * @return the class formed by taking the top-most org.apache.openjpa.aaa package and\n+     * BBBStoreManager name prefix from <code>storeCls</code> and\n+     * combining them with the facade package ccc and suffix DDD to\n+     * get: org.apache.openjpa.ccc.aaa.BBBDDD\n+     */\n+    public static Class getStoreFacadeType(OpenJPAConfiguration conf,\n+        Class openjpaCls, String openjpaSuff, String facadePkg, Class facadeCls,\n+        String facadeSuff) {\n+        String clsName = openjpaCls.getName();\n+        int dotIdx = clsName.lastIndexOf('.');\n+        int suffixIdx = clsName.indexOf(openjpaSuff, dotIdx + 1);\n+        if (!clsName.startsWith(\"org.apache.openjpa.\") || suffixIdx == -1)\n+            return null;\n+\n+        // extract 'xxx.' from org.apache.openjpa.xxx.yyy..., and XXX from XXXStoreManager\n+        String pkg = clsName.substring(5, clsName.indexOf('.', 5) + 1);\n+        String prefix = clsName.substring(dotIdx + 1, suffixIdx);\n+\n+        // suffix of impl class name\n+        if (facadeSuff == null)\n+            facadeSuff = Strings.getClassName(facadeCls);\n+\n+        clsName =\n+            \"org.apache.openjpa.\" + facadePkg + \".\" + pkg + prefix + facadeSuff;\n+        try {\n+            return Class.forName(clsName, true, facadeCls.getClassLoader());\n+        }\n+        catch (ClassNotFoundException ncfe) {\n+            Log log = conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\n+            if (log.isTraceEnabled())\n+                log.trace(_loc.get(\"no-store-exts\", clsName));\n+            return null;\n+        }\n+        catch (Exception e) {\n+            throw new InternalException(e);\n+        }\n+    }\n+\n+    /**\n+     * Close the given resource.  The resource can be an extent iterator,\n+     * query result, large result set relation, or any closeable OpenJPA\n+     * component.\n+     */\n+    public static void close(Object o) {\n+        try {\n+            if (o instanceof Closeable)\n+                ((Closeable) o).close();\n+        }\n+        catch (RuntimeException re) {\n+            throw re;\n+        }\n+        catch (Exception e) {\n+            throw new GeneralException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns true if the specified class is a type that can be managed by\n+     * OpenJPA.\n+     *\n+     * @param type the class to test\n+     * @return true if the class is manageable.\n+     * @param    conf the configuration that defines the current context\n+     */\n+    public static boolean isManagedType(Class type) {\n+        return PersistenceCapable.class.isAssignableFrom(type);\n+    }\n+\n+    /**\n+     *  Returns true if the specified instance is manageable.\n+     *\n+     *  @param  instance  the object to check\n+     *  @return true if the instance is a persistent type, false otherwise\n+     */\n+    public static boolean isManageable(Object instance) {\n+        return instance instanceof PersistenceCapable;\n+\t}\n+}"},{"sha":"c98b46a720365ddcadac28b78dcc5ea671650383","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/IntId.java","status":"modified","additions":66,"deletions":63,"changes":129,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/IntId.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/IntId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/IntId.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,63 +1,66 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import serp.util.Numbers;\r\n-\r\n-/**\r\n- * {@link OpenJPAId} subclass appropriate for int fields.\r\n- *\r\n- * @author Steve Kim\r\n- */\r\n-public final class IntId extends OpenJPAId {\r\n-\r\n-    private final int key;\r\n-\r\n-    public IntId(Class cls, Integer key) {\r\n-        this(cls, (key == null) ? 0 : key.intValue());\r\n-    }\r\n-\r\n-    public IntId(Class cls, String key) {\r\n-        this(cls, (key == null) ? 0 : Integer.parseInt(key));\r\n-    }\r\n-\r\n-    public IntId(Class cls, int key) {\r\n-        super(cls);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public IntId(Class cls, int key, boolean subs) {\r\n-        super(cls, subs);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public int getId() {\r\n-        return key;\r\n-    }\r\n-\r\n-    public Object getIdObject() {\r\n-        return Numbers.valueOf(key);\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return String.valueOf(key);\r\n-    }\r\n-\r\n-    protected int idHash() {\r\n-        return key;\r\n-    }\r\n-\r\n-    protected boolean idEquals(OpenJPAId o) {\r\n-        return key == ((IntId) o).key;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import serp.util.Numbers;\n+\n+/**\n+ * {@link OpenJPAId} subclass appropriate for int fields.\n+ *\n+ * @author Steve Kim\n+ */\n+public final class IntId extends OpenJPAId {\n+\n+    private final int key;\n+\n+    public IntId(Class cls, Integer key) {\n+        this(cls, (key == null) ? 0 : key.intValue());\n+    }\n+\n+    public IntId(Class cls, String key) {\n+        this(cls, (key == null) ? 0 : Integer.parseInt(key));\n+    }\n+\n+    public IntId(Class cls, int key) {\n+        super(cls);\n+        this.key = key;\n+    }\n+\n+    public IntId(Class cls, int key, boolean subs) {\n+        super(cls, subs);\n+        this.key = key;\n+    }\n+\n+    public int getId() {\n+        return key;\n+    }\n+\n+    public Object getIdObject() {\n+        return Numbers.valueOf(key);\n+    }\n+\n+    public String toString() {\n+        return String.valueOf(key);\n+    }\n+\n+    protected int idHash() {\n+        return key;\n+    }\n+\n+    protected boolean idEquals(OpenJPAId o) {\n+        return key == ((IntId) o).key;\n+    }\n+}"},{"sha":"1cbfffdad69b627ad817c93c74183d6fb66e4791","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/InternalException.java","status":"modified","additions":49,"deletions":45,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/InternalException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/InternalException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/InternalException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,45 +1,49 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-/**\r\n- * Exception type for internal errors.\r\n- *\r\n- * @author Abe White\r\n- * @since 3.2\r\n- */\r\n-public class InternalException extends OpenJPAException {\r\n-\r\n-    public InternalException() {\r\n-        setFatal(true);\r\n-    }\r\n-\r\n-    public InternalException(String msg) {\r\n-        super(msg);\r\n-        setFatal(true);\r\n-    }\r\n-\r\n-    public InternalException(Throwable cause) {\r\n-        super(cause);\r\n-        setFatal(true);\r\n-    }\r\n-\r\n-    public InternalException(String msg, Throwable cause) {\r\n-        super(msg, cause);\r\n-        setFatal(true);\r\n-    }\r\n-\r\n-    public int getType() {\r\n-        return INTERNAL;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+/**\n+ * <p>Exception type for internal errors.</p>\n+ *\n+ * @author Abe White\n+ * @since 3.2\n+ */\n+public class InternalException\n+    extends OpenJPAException {\n+\n+    public InternalException() {\n+        setFatal(true);\n+    }\n+\n+    public InternalException(String msg) {\n+        super(msg);\n+        setFatal(true);\n+    }\n+\n+    public InternalException(Throwable cause) {\n+        super(cause);\n+        setFatal(true);\n+    }\n+\n+    public InternalException(String msg, Throwable cause) {\n+        super(msg, cause);\n+        setFatal(true);\n+    }\n+\n+    public int getType() {\n+        return INTERNAL;\n+    }\n+}"},{"sha":"98ada7d16dccbc016f90aa44ef463acbe39ae871","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/InvalidStateException.java","status":"modified","additions":43,"deletions":39,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/InvalidStateException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/InvalidStateException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/InvalidStateException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,39 +1,43 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-/**\r\n- * Exception type thrown when attempting to execute an operation that\r\n- * is not allowed by the current state.\r\n- *\r\n- * @author Abe White\r\n- * @since 4.0\r\n- */\r\n-public class InvalidStateException extends UserException {\r\n-\r\n-    public InvalidStateException() {\r\n-    }\r\n-\r\n-    public InvalidStateException(String msg) {\r\n-        super(msg);\r\n-    }\r\n-\r\n-    public InvalidStateException(String msg, Object failed) {\r\n-        super(msg);\r\n-        setFailedObject(failed);\r\n-    }\r\n-\r\n-    public int getSubtype() {\r\n-        return INVALID_STATE;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+/**\n+ * <p>Exception type thrown when attempting to execute an operation that\n+ * is not allowed by the current state.</p>\n+ *\n+ * @since 4.0\n+ * @author Abe White\n+ */\n+public class InvalidStateException\n+    extends UserException {\n+\n+    public InvalidStateException() {\n+    }\n+\n+    public InvalidStateException(String msg) {\n+        super(msg);\n+    }\n+\n+    public InvalidStateException(String msg, Object failed) {\n+        super(msg);\n+        setFailedObject(failed);\n+    }\n+\n+    public int getSubtype() {\n+        return INVALID_STATE;\n+    }\n+}"},{"sha":"8653b42a383e8b489ed14870f6ba4cc224ec4584","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/LRSProxy.java","status":"modified","additions":27,"deletions":23,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/LRSProxy.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/LRSProxy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/LRSProxy.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,23 +1,27 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-/**\r\n- * Marker interface for large result set proxies.\r\n- *\r\n- * @author Abe White\r\n- * @since 3.0.3\r\n- */\r\n-public interface LRSProxy extends Proxy {\r\n-\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+/**\n+ * <p>Marker interface for large result set proxies.</p>\n+ *\n+ * @author Abe White\n+ * @since 3.0.3\n+ */\n+public interface LRSProxy\n+    extends Proxy {\n+\n+}"},{"sha":"0699fcac2d75bdf34ba12a2703253f69ab89ec44","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/LockException.java","status":"modified","additions":93,"deletions":86,"changes":179,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/LockException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/LockException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/LockException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,86 +1,93 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ObjectOutputStream;\r\n-\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-\r\n-/**\r\n- * Exception indicating that locks on one or more objects could not be acquired.\r\n- *\r\n- * @author Marc Prud'hommeaux\r\n- * @since 3.1\r\n- */\r\n-public class LockException extends StoreException {\r\n-\r\n-    private static final transient Localizer _loc = Localizer.forPackage\r\n-        (LockException.class);\r\n-    private int timeout = -1;\r\n-\r\n-    public LockException() {\r\n-    }\r\n-\r\n-    public LockException(String msg) {\r\n-        super(msg);\r\n-    }\r\n-\r\n-    public LockException(Object failed) {\r\n-        super(_loc.get(\"lock-failed\", Exceptions.toString(failed)));\r\n-        setFailedObject(failed);\r\n-    }\r\n-\r\n-    public LockException(Object failed, int timeout) {\r\n-        super(_loc.get(\"lock-timeout\", Exceptions.toString(failed),\r\n-            String.valueOf(timeout)));\r\n-        setFailedObject(failed);\r\n-        setTimeout(timeout);\r\n-    }\r\n-\r\n-    public int getSubtype() {\r\n-        return LOCK;\r\n-    }\r\n-\r\n-    /**\r\n-     * The number of milliseconds to wait for a lock.\r\n-     */\r\n-    public int getTimeout() {\r\n-        return timeout;\r\n-    }\r\n-\r\n-    /**\r\n-     * The number of milliseconds to wait for a lock.\r\n-     */\r\n-    public LockException setTimeout(int timeout) {\r\n-        this.timeout = timeout;\r\n-        return this;\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        String str = super.toString();\r\n-        if (timeout < 0)\r\n-            return str;\r\n-        return str + Exceptions.SEP + \"Timeout: \" + timeout;\r\n-    }\r\n-\r\n-    private void writeObject(ObjectOutputStream out) throws IOException {\r\n-        out.writeInt(timeout);\r\n-    }\r\n-\r\n-    private void readObject(ObjectInputStream in)\r\n-        throws IOException, ClassNotFoundException {\r\n-        timeout = in.readInt();\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+/**\n+ * Exception indicating that locks on one or more objects could\n+ * not be acquired.\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @since 3.1\n+ */\n+public class LockException\n+    extends StoreException {\n+\n+    private static final transient Localizer _loc = Localizer.forPackage\n+        (LockException.class);\n+\n+    private int timeout = -1;\n+\n+    public LockException() {\n+    }\n+\n+    public LockException(String msg) {\n+        super(msg);\n+    }\n+\n+    public LockException(Object failed) {\n+        super(_loc.get(\"lock-failed\", Exceptions.toString(failed)));\n+        setFailedObject(failed);\n+    }\n+\n+    public LockException(Object failed, int timeout) {\n+        super(_loc.get(\"lock-timeout\", Exceptions.toString(failed),\n+            String.valueOf(timeout)));\n+        setFailedObject(failed);\n+        setTimeout(timeout);\n+    }\n+\n+    public int getSubtype() {\n+        return LOCK;\n+    }\n+\n+    /**\n+     * The number of milliseconds to wait for a lock.\n+     */\n+    public int getTimeout() {\n+        return timeout;\n+    }\n+\n+    /**\n+     * The number of milliseconds to wait for a lock.\n+     */\n+    public LockException setTimeout(int timeout) {\n+        this.timeout = timeout;\n+        return this;\n+    }\n+\n+    public String toString() {\n+        String str = super.toString();\n+        if (timeout < 0)\n+            return str;\n+        return str + Exceptions.SEP + \"Timeout: \" + timeout;\n+    }\n+\n+    private void writeObject(ObjectOutputStream out)\n+        throws IOException {\n+        out.writeInt(timeout);\n+    }\n+\n+    private void readObject(ObjectInputStream in)\n+        throws IOException, ClassNotFoundException {\n+        timeout = in.readInt();\n+\t}\n+}"},{"sha":"a86cf1dd3b4bfd57099f6012281af9872222782d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/LongId.java","status":"modified","additions":62,"deletions":59,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/LongId.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/LongId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/LongId.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,59 +1,62 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import serp.util.Numbers;\r\n-\r\n-/**\r\n- * {@link OpenJPAId} subclass appropriate for long fields.\r\n- *\r\n- * @author Steve Kim\r\n- */\r\n-public final class LongId extends OpenJPAId {\r\n-\r\n-    private final long key;\r\n-\r\n-    public LongId(Class cls, Long key) {\r\n-        this(cls, (key == null) ? 0L : key.longValue());\r\n-    }\r\n-\r\n-    public LongId(Class cls, String key) {\r\n-        this(cls, (key == null) ? 0L : Long.parseLong(key));\r\n-    }\r\n-\r\n-    public LongId(Class cls, long key) {\r\n-        super(cls);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public LongId(Class cls, long key, boolean subs) {\r\n-        super(cls, subs);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public long getId() {\r\n-        return key;\r\n-    }\r\n-\r\n-    public Object getIdObject() {\r\n-        return Numbers.valueOf(key);\r\n-    }\r\n-\r\n-    protected int idHash() {\r\n-        return (int) (key ^ (key >>> 32));\r\n-    }\r\n-\r\n-    protected boolean idEquals(OpenJPAId o) {\r\n-        return key == ((LongId) o).key;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import serp.util.Numbers;\n+\n+/**\n+ * {@link OpenJPAId} subclass appropriate for long fields.\n+ *\n+ * @author Steve Kim\n+ */\n+public final class LongId extends OpenJPAId {\n+\n+    private final long key;\n+\n+    public LongId(Class cls, Long key) {\n+        this(cls, (key == null) ? 0L : key.longValue());\n+    }\n+\n+    public LongId(Class cls, String key) {\n+        this(cls, (key == null) ? 0L : Long.parseLong(key));\n+    }\n+\n+    public LongId(Class cls, long key) {\n+        super(cls);\n+        this.key = key;\n+    }\n+\n+    public LongId(Class cls, long key, boolean subs) {\n+        super(cls, subs);\n+        this.key = key;\n+    }\n+\n+    public long getId() {\n+        return key;\n+    }\n+\n+    public Object getIdObject() {\n+        return Numbers.valueOf(key);\n+    }\n+\n+    protected int idHash() {\n+        return (int) (key ^ (key >>> 32));\n+    }\n+\n+    protected boolean idEquals(OpenJPAId o) {\n+        return key == ((LongId) o).key;\n+    }\n+}"},{"sha":"eee59f982a6b5c67ce1bf3d19eec84599bab24ba","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTracker.java","status":"modified","additions":59,"deletions":55,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTracker.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTracker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTracker.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,55 +1,59 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-/**\r\n- * Change tracker that can be used for maps. If the user calls\r\n- * any mutating methods on the map that do not have an equivalent in\r\n- * this change tracker, then you must call {@link #stopTracking} after\r\n- * applying the operation to the map. The collections returned from\r\n- * {@link ChangeTracker#getAdd} and {@link ChangeTracker#getRemove} will\r\n- * be collections of keys to add/remove.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public interface MapChangeTracker extends ChangeTracker {\r\n-\r\n-    /**\r\n-     * Whether to track keys or values. Defaults to keys.\r\n-     * If you set to values, it is assumed there is a 1-1 correlation\r\n-     * between keys and values in this map.\r\n-     */\r\n-    public boolean getTrackKeys();\r\n-\r\n-    /**\r\n-     * Whether to track keys or values. Defaults to keys.\r\n-     * If you set to values, it is assumed there is a 1-1 correlation\r\n-     * between keys and values in this map.\r\n-     */\r\n-    public void setTrackKeys(boolean keys);\r\n-\r\n-    /**\r\n-     * Record that the given entry was added to the map.\r\n-     */\r\n-    public void added(Object key, Object val);\r\n-\r\n-    /**\r\n-     * Record that the given entry was removed from the map.\r\n-     */\r\n-    public void removed(Object key, Object val);\r\n-\r\n-    /**\r\n-     * Record that the given entry was altered.\r\n-     */\r\n-    public void changed(Object key, Object oldVal, Object newVal);\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+/**\n+ * <p>Change tracker that can be used for maps.  If the user calls\n+ * any mutating methods on the map that do not have an equivalent in\n+ * this change tracker, then you must call {@link #stopTracking} after\n+ * applying the operation to the map.  The collections returned from\n+ * {@link ChangeTracker#getAdd} and {@link ChangeTracker#getRemove} will\n+ * be collections of keys to add/remove.</p>\n+ *\n+ * @author Abe White\n+ */\n+public interface MapChangeTracker\n+    extends ChangeTracker {\n+\n+    /**\n+     * Whether to track keys or values.  Defaults to keys.\n+     * If you set to values, it is assumed there is a 1-1 correlation\n+     * between keys and values in this map.\n+     */\n+    public boolean getTrackKeys();\n+\n+    /**\n+     * Whether to track keys or values.  Defaults to keys.\n+     * If you set to values, it is assumed there is a 1-1 correlation\n+     * between keys and values in this map.\n+     */\n+    public void setTrackKeys(boolean keys);\n+\n+    /**\n+     * Record that the given entry was added to the map.\n+     */\n+    public void added(Object key, Object val);\n+\n+    /**\n+     * Record that the given entry was removed from the map.\n+     */\n+    public void removed(Object key, Object val);\n+\n+    /**\n+     *\tRecord that the given entry was altered.\n+     */\n+    public void changed(Object key, Object oldVal, Object newVal);\n+}"},{"sha":"13000086a788e5e4930b23845d34f69c3b5efbb1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTrackerImpl.java","status":"modified","additions":132,"deletions":124,"changes":256,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTrackerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTrackerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTrackerImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,124 +1,132 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-\r\n-/**\r\n- * Default {@link MapChangeTracker}.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class MapChangeTrackerImpl extends AbstractChangeTracker\r\n-    implements MapChangeTracker {\r\n-\r\n-    private final Map _map;\r\n-    private boolean _keys = true;\r\n-\r\n-    /**\r\n-     * Constructor; supply delegate map.\r\n-     */\r\n-    public MapChangeTrackerImpl(Map map, OpenJPAConfiguration conf) {\r\n-        super(conf);\r\n-        _map = map;\r\n-    }\r\n-\r\n-    public boolean getTrackKeys() {\r\n-        return _keys;\r\n-    }\r\n-\r\n-    public void setTrackKeys(boolean keys) {\r\n-        _keys = keys;\r\n-    }\r\n-\r\n-    public void added(Object key, Object val) {\r\n-        if (_keys)\r\n-            super.added(key);\r\n-        else super.added(val);\r\n-    }\r\n-\r\n-    public void removed(Object key, Object val) {\r\n-        if (_keys)\r\n-            super.removed(key);\r\n-        else super.removed(val);\r\n-    }\r\n-\r\n-    public void changed(Object key, Object oldVal, Object newVal) {\r\n-        if (_keys)\r\n-            super.changed(key);\r\n-        else {\r\n-            super.removed(oldVal);\r\n-            super.added(newVal);\r\n-        }\r\n-    }\r\n-\r\n-    protected void add(Object obj) {\r\n-        // if the key was previously removed and now added back, mark\r\n-        // it as a change; otherwise it's a new addition\r\n-        if (rem != null && rem.remove(obj)) {\r\n-            if (change == null)\r\n-                change = newSet();\r\n-            change.add(obj);\r\n-        } else {\r\n-            // after a point it becomes inefficient to track changes\r\n-            if (getAutoOff() && getAdded().size() + getChanged().size()\r\n-                + getRemoved().size() >= _map.size())\r\n-                stopTracking();\r\n-            else {\r\n-                if (add == null)\r\n-                    add = newSet();\r\n-                add.add(obj);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    protected void remove(Object obj) {\r\n-        // no longer a change, if it was before\r\n-        if (change != null)\r\n-            change.remove(obj);\r\n-        // if it was a new addition, just forget it; otherwise remember\r\n-        // that it was removed\r\n-        if (add == null || !add.remove(obj)) {\r\n-            // after a point it becomes inefficient to track changes\r\n-            if (getAutoOff() && getAdded().size() + getChanged().size()\r\n-                + getRemoved().size() >= _map.size())\r\n-                stopTracking();\r\n-            else {\r\n-                if (rem == null)\r\n-                    rem = newSet();\r\n-                rem.add(obj);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    protected void change(Object key) {\r\n-        // if the key is already changed or the key is newly added, nothing\r\n-        // to do\r\n-        if ((change != null && change.contains(key))\r\n-            || (add != null && add.contains(key)))\r\n-            return;\r\n-        // after a point it becomes inefficient to track changes\r\n-        if (getAutoOff() && getAdded().size() + getChanged().size()\r\n-            + getRemoved().size() >= _map.size())\r\n-            stopTracking();\r\n-        else {\r\n-            // record the change\r\n-            if (change == null)\r\n-                change = newSet();\r\n-            change.add(key);\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+\n+/**\n+ * <p>Default {@link MapChangeTracker}.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class MapChangeTrackerImpl\n+    extends AbstractChangeTracker\n+    implements MapChangeTracker {\n+\n+    private final Map _map;\n+    private boolean _keys = true;\n+\n+    /**\n+     * Constructor; supply delegate map.\n+     */\n+    public MapChangeTrackerImpl(Map map, OpenJPAConfiguration conf) {\n+        super(conf);\n+        _map = map;\n+    }\n+\n+    public boolean getTrackKeys() {\n+        return _keys;\n+    }\n+\n+    public void setTrackKeys(boolean keys) {\n+        _keys = keys;\n+    }\n+\n+    public void added(Object key, Object val) {\n+        if (_keys)\n+            super.added(key);\n+        else\n+            super.added(val);\n+    }\n+\n+    public void removed(Object key, Object val) {\n+        if (_keys)\n+            super.removed(key);\n+        else\n+            super.removed(val);\n+    }\n+\n+    public void changed(Object key, Object oldVal, Object newVal) {\n+        if (_keys)\n+            super.changed(key);\n+        else {\n+            super.removed(oldVal);\n+            super.added(newVal);\n+        }\n+    }\n+\n+    protected void add(Object obj) {\n+        // if the key was previously removed and now added back, mark\n+        // it as a change; otherwise it's a new addition\n+        if (rem != null && rem.remove(obj)) {\n+            if (change == null)\n+                change = newSet();\n+            change.add(obj);\n+        } else {\n+            // after a point it becomes inefficient to track changes\n+            if (getAutoOff() && getAdded().size() + getChanged().size()\n+                + getRemoved().size() >= _map.size())\n+                stopTracking();\n+            else {\n+                if (add == null)\n+                    add = newSet();\n+                add.add(obj);\n+            }\n+        }\n+    }\n+\n+    protected void remove(Object obj) {\n+        // no longer a change, if it was before\n+        if (change != null)\n+            change.remove(obj);\n+\n+        // if it was a new addition, just forget it; otherwise remember\n+        // that it was removed\n+        if (add == null || !add.remove(obj)) {\n+            // after a point it becomes inefficient to track changes\n+            if (getAutoOff() && getAdded().size() + getChanged().size()\n+                + getRemoved().size() >= _map.size())\n+                stopTracking();\n+            else {\n+                if (rem == null)\n+                    rem = newSet();\n+                rem.add(obj);\n+            }\n+        }\n+    }\n+\n+    protected void change(Object key) {\n+        // if the key is already changed or the key is newly added, nothing\n+        // to do\n+        if ((change != null && change.contains(key))\n+            || (add != null && add.contains(key)))\n+            return;\n+\n+        // after a point it becomes inefficient to track changes\n+        if (getAutoOff() && getAdded().size() + getChanged().size()\n+            + getRemoved().size() >= _map.size())\n+            stopTracking();\n+        else {\n+            // record the change\n+            if (change == null)\n+                change = newSet();\n+            change.add(key);\n+        }\n+    }\n+}"},{"sha":"479c70feff3c12bdf3a19ccca4f3a9a86cd2d9bd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/MetaDataException.java","status":"modified","additions":45,"deletions":41,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/MetaDataException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/MetaDataException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/MetaDataException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,41 +1,45 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-/**\r\n- * Exception type reserved for missing or invalid metadata.\r\n- *\r\n- * @author Abe White\r\n- * @since 3.0\r\n- */\r\n-public class MetaDataException extends UserException {\r\n-\r\n-    public MetaDataException() {\r\n-        setFatal(true);\r\n-    }\r\n-\r\n-    public MetaDataException(String msg) {\r\n-        super(msg);\r\n-        setFatal(true);\r\n-    }\r\n-\r\n-    public MetaDataException(String msg, Object failed) {\r\n-        super(msg);\r\n-        setFatal(true);\r\n-        setFailedObject(failed);\r\n-    }\r\n-\r\n-    public int getSubtype() {\r\n-        return METADATA;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+/**\n+ * <p>Exception type reserved for missing or invalid metadata.</p>\n+ *\n+ * @since 3.0\n+ * @author Abe White\n+ */\n+public class MetaDataException\n+    extends UserException {\n+\n+    public MetaDataException() {\n+        setFatal(true);\n+    }\n+\n+    public MetaDataException(String msg) {\n+        super(msg);\n+        setFatal(true);\n+    }\n+\n+    public MetaDataException(String msg, Object failed) {\n+        super(msg);\n+        setFatal(true);\n+        setFailedObject(failed);\n+    }\n+\n+    public int getSubtype() {\n+        return METADATA;\n+    }\n+}"},{"sha":"884a53c6c1f16e7ecd132fd59219588f4d89e4ef","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/MultiLoaderClassResolver.java","status":"modified","additions":45,"deletions":42,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/MultiLoaderClassResolver.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/MultiLoaderClassResolver.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/MultiLoaderClassResolver.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,42 +1,45 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import org.apache.openjpa.lib.util.MultiClassLoader;\r\n-\r\n-/**\r\n- * A simple {@link ClassResolver} that uses multiple class loaders to\r\n- * resolve classes.\r\n- *\r\n- * @author Steve Kim\r\n- */\r\n-public class MultiLoaderClassResolver implements ClassResolver {\r\n-\r\n-    final private MultiClassLoader _loader = new MultiClassLoader();\r\n-\r\n-    public MultiLoaderClassResolver() {\r\n-    }\r\n-\r\n-    public MultiLoaderClassResolver(ClassLoader[] loaders) {\r\n-        for (int i = 0; i < loaders.length; i++)\r\n-            _loader.addClassLoader(loaders[i]);\r\n-    }\r\n-\r\n-    public boolean addClassLoader(ClassLoader loader) {\r\n-        return _loader.addClassLoader(loader);\r\n-    }\r\n-\r\n-    public ClassLoader getClassLoader(Class ctx, ClassLoader envLoader) {\r\n-        return _loader;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import org.apache.openjpa.lib.util.MultiClassLoader;\n+\n+/**\n+ * A simple {@link ClassResolver} that uses multiple class loaders to\n+ * resolve classes.\n+ *\n+ * @author Steve Kim\n+ */\n+public class MultiLoaderClassResolver implements ClassResolver {\n+\n+    final private MultiClassLoader _loader = new MultiClassLoader();\n+\n+    public MultiLoaderClassResolver() {\n+    }\n+\n+    public MultiLoaderClassResolver(ClassLoader[] loaders) {\n+        for (int i = 0; i < loaders.length; i++)\n+            _loader.addClassLoader(loaders[i]);\n+    }\n+\n+    public boolean addClassLoader(ClassLoader loader) {\n+        return _loader.addClassLoader(loader);\n+    }\n+\n+    public ClassLoader getClassLoader(Class ctx, ClassLoader envLoader) {\n+        return _loader;\n+    }\n+}"},{"sha":"957d0e2a93a53f14b53d0038c73cf4ba072ff0d8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/NoTransactionException.java","status":"modified","additions":43,"deletions":39,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/NoTransactionException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/NoTransactionException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/NoTransactionException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,39 +1,43 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-/**\r\n- * Exception type thrown when attempting a transactional operation without\r\n- * an active transaction.\r\n- *\r\n- * @author Abe White\r\n- * @since 4.0\r\n- */\r\n-public class NoTransactionException extends InvalidStateException {\r\n-\r\n-    public NoTransactionException() {\r\n-    }\r\n-\r\n-    public NoTransactionException(String msg) {\r\n-        super(msg);\r\n-    }\r\n-\r\n-    public NoTransactionException(String msg, Object failed) {\r\n-        super(msg);\r\n-        setFailedObject(failed);\r\n-    }\r\n-\r\n-    public int getSubtype() {\r\n-        return NO_TRANSACTION;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+/**\n+ * <p>Exception type thrown when attempting a transactional operation without\n+ * an active transaction.</p>\n+ *\n+ * @since 4.0\n+ * @author Abe White\n+ */\n+public class NoTransactionException\n+    extends InvalidStateException {\n+\n+    public NoTransactionException() {\n+    }\n+\n+    public NoTransactionException(String msg) {\n+        super(msg);\n+    }\n+\n+    public NoTransactionException(String msg, Object failed) {\n+        super(msg);\n+        setFailedObject(failed);\n+    }\n+\n+    public int getSubtype() {\n+        return NO_TRANSACTION;\n+    }\n+}"},{"sha":"59f0f1fcbf58ca14f31119227481afdcc2fba687","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectExistsException.java","status":"modified","additions":47,"deletions":43,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectExistsException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectExistsException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectExistsException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,43 +1,47 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-\r\n-/**\r\n- * Exception type reserved for conflicts with existing objects.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public class ObjectExistsException extends StoreException {\r\n-\r\n-    private static final transient Localizer _loc = Localizer.forPackage\r\n-        (ObjectExistsException.class);\r\n-\r\n-    public ObjectExistsException() {\r\n-    }\r\n-\r\n-    public ObjectExistsException(String msg) {\r\n-        super(msg);\r\n-    }\r\n-\r\n-    public ObjectExistsException(Object failed) {\r\n-        super(_loc.get(\"obj-exists\", Exceptions.toString(failed)));\r\n-        setFailedObject(failed);\r\n-    }\r\n-\r\n-    public int getSubtype() {\r\n-        return OBJECT_EXISTS;\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+/**\n+ * <p>Exception type reserved for conflicts with existing objects.</p>\n+ *\n+ * @author Abe White\n+ */\n+public class ObjectExistsException\n+    extends StoreException {\n+\n+    private static final transient Localizer _loc = Localizer.forPackage\n+        (ObjectExistsException.class);\n+\n+    public ObjectExistsException() {\n+    }\n+\n+    public ObjectExistsException(String msg) {\n+        super(msg);\n+    }\n+\n+    public ObjectExistsException(Object failed) {\n+        super(_loc.get(\"obj-exists\", Exceptions.toString(failed)));\n+        setFailedObject(failed);\n+    }\n+\n+    public int getSubtype() {\n+        return OBJECT_EXISTS;\n+    }\n+}\n+"},{"sha":"84e7782c6eee57f669ee777e27861fee67b9bfb4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectId.java","status":"modified","additions":66,"deletions":61,"changes":127,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectId.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectId.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,61 +1,66 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-\r\n-/**\r\n- * Identity type appropriate for object primary key fields and shared\r\n- * id classes.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public final class ObjectId extends OpenJPAId {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage(ObjectId.class);\r\n-    private Object _key;\r\n-\r\n-    public ObjectId(Class cls, Object key) {\r\n-        super(cls);\r\n-        _key = key;\r\n-    }\r\n-\r\n-    public ObjectId(Class cls, Object key, boolean subs) {\r\n-        super(cls, subs);\r\n-        _key = key;\r\n-    }\r\n-\r\n-    public Object getId() {\r\n-        return _key;\r\n-    }\r\n-\r\n-    /**\r\n-     * Allow utilities in this package to mutate id.\r\n-     */\r\n-    void setId(Object id) {\r\n-        _key = id;\r\n-    }\r\n-\r\n-    public Object getIdObject() {\r\n-        return _key;\r\n-    }\r\n-\r\n-    protected int idHash() {\r\n-        return (_key == null) ? 0 : _key.hashCode();\r\n-    }\r\n-\r\n-    protected boolean idEquals(OpenJPAId o) {\r\n-        Object key = ((ObjectId) o)._key;\r\n-        return (_key == null) ? key == null : _key.equals(key);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+/**\n+ * <p>Identity type appropriate for object primary key fields and shared\n+ * id classes.</p>\n+ *\n+ * @author Abe White\n+ */\n+public final class ObjectId\n+    extends OpenJPAId {\n+\n+    private static final Localizer _loc = Localizer.forPackage(ObjectId.class);\n+\n+    private Object _key;\n+\n+    public ObjectId(Class cls, Object key) {\n+        super(cls);\n+        _key = key;\n+    }\n+\n+    public ObjectId(Class cls, Object key, boolean subs) {\n+        super(cls, subs);\n+        _key = key;\n+    }\n+\n+    public Object getId() {\n+        return _key;\n+    }\n+\n+    /**\n+     * Allow utilities in this package to mutate id.\n+     */\n+    void setId(Object id) {\n+        _key = id;\n+    }\n+\n+    public Object getIdObject() {\n+        return _key;\n+    }\n+\n+    protected int idHash() {\n+        return (_key == null) ? 0 : _key.hashCode();\n+    }\n+\n+    protected boolean idEquals(OpenJPAId o) {\n+        Object key = ((ObjectId) o)._key;\n+        return (_key == null) ? key == null : _key.equals(key);\n+    }\n+}"},{"sha":"5042d1cbf3d6796f73b38a39c89361750026fabb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectNotFoundException.java","status":"modified","additions":54,"deletions":50,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectNotFoundException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectNotFoundException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectNotFoundException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,50 +1,54 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.util.Collection;\r\n-\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-\r\n-/**\r\n- * Exception type reserved for failed object lookups.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public class ObjectNotFoundException extends StoreException {\r\n-\r\n-    private static final transient Localizer _loc = Localizer.forPackage\r\n-        (ObjectNotFoundException.class);\r\n-\r\n-    public ObjectNotFoundException() {\r\n-    }\r\n-\r\n-    public ObjectNotFoundException(String msg) {\r\n-        super(msg);\r\n-    }\r\n-\r\n-    public ObjectNotFoundException(Object failed) {\r\n-        super(_loc.get(\"not-found\", Exceptions.toString(failed)));\r\n-        setFailedObject(failed);\r\n-    }\r\n-\r\n-    public ObjectNotFoundException(Collection failed, Throwable[] nested) {\r\n-        super(_loc.get(\"not-found-multi\", Exceptions.toString(failed)));\r\n-        setNestedThrowables(nested);\r\n-    }\r\n-\r\n-    public int getSubtype() {\r\n-        return OBJECT_NOT_FOUND;\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.util.Collection;\n+\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+/**\n+ * <p>Exception type reserved for failed object lookups.</p>\n+ *\n+ * @author Abe White\n+ */\n+public class ObjectNotFoundException\n+    extends StoreException {\n+\n+    private static final transient Localizer _loc = Localizer.forPackage\n+        (ObjectNotFoundException.class);\n+\n+    public ObjectNotFoundException() {\n+    }\n+\n+    public ObjectNotFoundException(String msg) {\n+        super(msg);\n+    }\n+\n+    public ObjectNotFoundException(Object failed) {\n+        super(_loc.get(\"not-found\", Exceptions.toString(failed)));\n+        setFailedObject(failed);\n+    }\n+\n+    public ObjectNotFoundException(Collection failed, Throwable[] nested) {\n+        super(_loc.get(\"not-found-multi\", Exceptions.toString(failed)));\n+        setNestedThrowables(nested);\n+    }\n+\n+    public int getSubtype() {\n+        return OBJECT_NOT_FOUND;\n+    }\n+}\n+"},{"sha":"eda12d8bf005c62affe8aebf9a89d57658328e31","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAException.java","status":"modified","additions":182,"deletions":176,"changes":358,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,176 +1,182 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ObjectOutputStream;\r\n-import java.io.PrintStream;\r\n-import java.io.PrintWriter;\r\n-import java.io.Serializable;\r\n-\r\n-/**\r\n- * Exception type for all OpenJPA exceptions. Meant to be easily\r\n- * transformed into an appropriate exception at the API layer, since most APIs\r\n- * define their own exception types.\r\n- *\r\n- * @author Abe White\r\n- * @since 4.0\r\n- */\r\n-public abstract class OpenJPAException extends RuntimeException\r\n-    implements Serializable, ExceptionInfo {\r\n-\r\n-    private transient boolean _fatal = false;\r\n-    private transient Object _failed = null;\r\n-    private transient Throwable[] _nested = null;\r\n-\r\n-    /**\r\n-     * Default constructor.\r\n-     */\r\n-    public OpenJPAException() {\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructor; supply message.\r\n-     */\r\n-    public OpenJPAException(String msg) {\r\n-        super(msg);\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct with cause.\r\n-     */\r\n-    public OpenJPAException(Throwable cause) {\r\n-        this(cause.getMessage(), cause);\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct with message and cause.\r\n-     */\r\n-    public OpenJPAException(String msg, Throwable cause) {\r\n-        super(msg);\r\n-        setCause(cause);\r\n-    }\r\n-\r\n-    /**\r\n-     * Exception type.\r\n-     */\r\n-    public abstract int getType();\r\n-\r\n-    /**\r\n-     * Exception subtype.\r\n-     */\r\n-    public int getSubtype() {\r\n-        return 0;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether this error is fatal.\r\n-     */\r\n-    public boolean isFatal() {\r\n-        return _fatal;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether this error is fatal.\r\n-     */\r\n-    public OpenJPAException setFatal(boolean fatal) {\r\n-        _fatal = fatal;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the first {@link Throwable} from {@link #getNestedThrowables}\r\n-     * in order to conform to {@link Throwable#getCause} in Java 1.4+.\r\n-     *\r\n-     * @see Throwable#getCause\r\n-     */\r\n-    public Throwable getCause() {\r\n-        if (_nested == null || _nested.length == 0)\r\n-            return null;\r\n-        else return _nested[0];\r\n-    }\r\n-\r\n-    /**\r\n-     * The first nested throwable.\r\n-     */\r\n-    public OpenJPAException setCause(Throwable nested) {\r\n-        if (_nested != null)\r\n-            throw new IllegalStateException();\r\n-        if (nested != null)\r\n-            _nested = new Throwable[]{ nested };\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * The nested throwables.\r\n-     */\r\n-    public Throwable[] getNestedThrowables() {\r\n-        return (_nested == null) ? Exceptions.EMPTY_THROWABLES : _nested;\r\n-    }\r\n-\r\n-    /**\r\n-     * The nested throwables.\r\n-     */\r\n-    public OpenJPAException setNestedThrowables(Throwable[] nested) {\r\n-        _nested = nested;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * The failed object.\r\n-     */\r\n-    public Object getFailedObject() {\r\n-        return _failed;\r\n-    }\r\n-\r\n-    /**\r\n-     * The failed object.\r\n-     */\r\n-    public OpenJPAException setFailedObject(Object failed) {\r\n-        _failed = failed;\r\n-        return this;\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return Exceptions.toString(this);\r\n-    }\r\n-\r\n-    public void printStackTrace() {\r\n-        printStackTrace(System.err);\r\n-    }\r\n-\r\n-    public void printStackTrace(PrintStream out) {\r\n-        super.printStackTrace(out);\r\n-        Exceptions.printNestedThrowables(this, out);\r\n-    }\r\n-\r\n-    public void printStackTrace(PrintWriter out) {\r\n-        super.printStackTrace(out);\r\n-        Exceptions.printNestedThrowables(this, out);\r\n-    }\r\n-\r\n-    private void writeObject(ObjectOutputStream out) throws IOException {\r\n-        out.writeBoolean(_fatal);\r\n-        out.writeObject(Exceptions.replaceFailedObject(_failed));\r\n-        out.writeObject(Exceptions.replaceNestedThrowables(_nested));\r\n-    }\r\n-\r\n-    private void readObject(ObjectInputStream in)\r\n-        throws IOException, ClassNotFoundException {\r\n-        _fatal = in.readBoolean();\r\n-        _failed = in.readObject();\r\n-        _nested = (Throwable[]) in.readObject();\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+\n+/**\n+ * <p>Exception type for all OpenJPA exceptions.  Meant to be easily\n+ * transformed into an appropriate exception at the API layer, since most APIs\n+ * define their own exception types.</p>\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+public abstract class OpenJPAException\n+    extends RuntimeException\n+    implements Serializable, ExceptionInfo {\n+\n+    private transient boolean _fatal = false;\n+    private transient Object _failed = null;\n+    private transient Throwable[] _nested = null;\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public OpenJPAException() {\n+    }\n+\n+    /**\n+     * Constructor; supply message.\n+     */\n+    public OpenJPAException(String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * Construct with cause.\n+     */\n+    public OpenJPAException(Throwable cause) {\n+        this(cause.getMessage(), cause);\n+    }\n+\n+    /**\n+     * Construct with message and cause.\n+     */\n+    public OpenJPAException(String msg, Throwable cause) {\n+        super(msg);\n+        setCause(cause);\n+    }\n+\n+    /**\n+     * Exception type.\n+     */\n+    public abstract int getType();\n+\n+    /**\n+     * Exception subtype.\n+     */\n+    public int getSubtype() {\n+        return 0;\n+    }\n+\n+    /**\n+     * Whether this error is fatal.\n+     */\n+    public boolean isFatal() {\n+        return _fatal;\n+    }\n+\n+    /**\n+     * Whether this error is fatal.\n+     */\n+    public OpenJPAException setFatal(boolean fatal) {\n+        _fatal = fatal;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the first {@link Throwable} from {@link #getNestedThrowables}\n+     * in order to conform to {@link Throwable#getCause} in Java 1.4+.\n+     *\n+     * @see Throwable#getCause\n+     */\n+    public Throwable getCause() {\n+        if (_nested == null || _nested.length == 0)\n+            return null;\n+        else\n+            return _nested[0];\n+    }\n+\n+    /**\n+     * The first nested throwable.\n+     */\n+    public OpenJPAException setCause(Throwable nested) {\n+        if (_nested != null)\n+            throw new IllegalStateException();\n+        if (nested != null)\n+            _nested = new Throwable[]{ nested };\n+        return this;\n+    }\n+\n+    /**\n+     * The nested throwables.\n+     */\n+    public Throwable[] getNestedThrowables() {\n+        return (_nested == null) ? Exceptions.EMPTY_THROWABLES : _nested;\n+    }\n+\n+    /**\n+     * The nested throwables.\n+     */\n+    public OpenJPAException setNestedThrowables(Throwable[] nested) {\n+        _nested = nested;\n+        return this;\n+    }\n+\n+    /**\n+     * The failed object.\n+     */\n+    public Object getFailedObject() {\n+        return _failed;\n+    }\n+\n+    /**\n+     * The failed object.\n+     */\n+    public OpenJPAException setFailedObject(Object failed) {\n+        _failed = failed;\n+        return this;\n+    }\n+\n+    public String toString() {\n+        return Exceptions.toString(this);\n+    }\n+\n+    public void printStackTrace() {\n+        printStackTrace(System.err);\n+    }\n+\n+    public void printStackTrace(PrintStream out) {\n+        super.printStackTrace(out);\n+        Exceptions.printNestedThrowables(this, out);\n+    }\n+\n+    public void printStackTrace(PrintWriter out) {\n+        super.printStackTrace(out);\n+        Exceptions.printNestedThrowables(this, out);\n+    }\n+\n+    private void writeObject(ObjectOutputStream out)\n+        throws IOException {\n+        out.writeBoolean(_fatal);\n+        out.writeObject(Exceptions.replaceFailedObject(_failed));\n+        out.writeObject(Exceptions.replaceNestedThrowables(_nested));\n+    }\n+\n+    private void readObject(ObjectInputStream in)\n+        throws IOException, ClassNotFoundException {\n+        _fatal = in.readBoolean();\n+        _failed = in.readObject();\n+        _nested = (Throwable[]) in.readObject ();\n+\t}\n+}\n+"},{"sha":"9ab42e56091d3046d58fe4dab58d41721c8d7a8d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","status":"modified","additions":119,"deletions":113,"changes":232,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,113 +1,119 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.Serializable;\r\n-\r\n-/**\r\n- * Identity class extended by builtin OpenJPA identity objects.\r\n- *\r\n- * @author Steve Kim\r\n- */\r\n-public abstract class OpenJPAId implements Comparable, Serializable {\r\n-\r\n-    protected Class type;\r\n-    protected boolean subs = true;\r\n-    // type has his based on the least-derived non-object class so that\r\n-    // user-given ids with non-exact types match ids with exact types\r\n-    private transient int _typeHash = 0;\r\n-\r\n-    protected OpenJPAId() {\r\n-    }\r\n-\r\n-    protected OpenJPAId(Class type) {\r\n-        this.type = type;\r\n-    }\r\n-\r\n-    protected OpenJPAId(Class type, boolean subs) {\r\n-        this.type = type;\r\n-        this.subs = subs;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the persitent class which this id instance represents.\r\n-     */\r\n-    public Class getType() {\r\n-        return type;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether this oid might be for a subclass of the given type.\r\n-     * Defaults to true.\r\n-     */\r\n-    public boolean hasSubclasses() {\r\n-        return subs;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set the exact type of the described instance once it is known.\r\n-     */\r\n-    public void setManagedInstanceType(Class type) {\r\n-        this.type = type;\r\n-        this.subs = false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the identity value as an object.\r\n-     */\r\n-    public abstract Object getIdObject();\r\n-\r\n-    /**\r\n-     * Return the id's hash code.\r\n-     */\r\n-    protected abstract int idHash();\r\n-\r\n-    /**\r\n-     * Compare the id to the id of the given instance.\r\n-     */\r\n-    protected abstract boolean idEquals(OpenJPAId other);\r\n-\r\n-    public int hashCode() {\r\n-        if (_typeHash == 0) {\r\n-            Class base = type;\r\n-            while (base.getSuperclass() != null\r\n-                && base.getSuperclass() != Object.class)\r\n-                base = base.getSuperclass();\r\n-            _typeHash = base.hashCode();\r\n-        }\r\n-        return _typeHash ^ idHash();\r\n-    }\r\n-\r\n-    public boolean equals(Object o) {\r\n-        if (o == this)\r\n-            return true;\r\n-        if (o == null || getClass() != o.getClass())\r\n-            return false;\r\n-        OpenJPAId id = (OpenJPAId) o;\r\n-        return idEquals(id) && (id.type.isAssignableFrom(type)\r\n-            || (subs && type.isAssignableFrom(id.type)));\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return type.getName() + \"-\" + getIdObject();\r\n-    }\r\n-\r\n-    public int compareTo(Object other) {\r\n-        if (other == this)\r\n-            return 0;\r\n-        if (other == null)\r\n-            return 1;\r\n-        return ((Comparable) getIdObject()).compareTo(((OpenJPAId) other).\r\n-            getIdObject());\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p>Identity class extended by builtin OpenJPA identity objects.</p>\n+ *\n+ * @author Steve Kim\n+ */\n+public abstract class OpenJPAId\n+    implements Comparable, Serializable {\n+\n+    protected Class type;\n+    protected boolean subs = true;\n+\n+    // type has his based on the least-derived non-object class so that\n+    // user-given ids with non-exact types match ids with exact types\n+    private transient int _typeHash = 0;\n+\n+    protected OpenJPAId() {\n+    }\n+\n+    protected OpenJPAId(Class type) {\n+        this.type = type;\n+    }\n+\n+    protected OpenJPAId(Class type, boolean subs) {\n+        this.type = type;\n+        this.subs = subs;\n+    }\n+\n+    /**\n+     * Return the persitent class which this id instance represents.\n+     */\n+    public Class getType() {\n+        return type;\n+    }\n+\n+    /**\n+     * Whether this oid might be for a subclass of the given type.\n+     * Defaults to true.\n+     */\n+    public boolean hasSubclasses() {\n+        return subs;\n+    }\n+\n+    /**\n+     * Set the exact type of the described instance once it is known.\n+     */\n+    public void setManagedInstanceType(Class type) {\n+        this.type = type;\n+        this.subs = false;\n+    }\n+\n+    /**\n+     * Return the identity value as an object.\n+     */\n+    public abstract Object getIdObject();\n+\n+    /**\n+     * Return the id's hash code.\n+     */\n+    protected abstract int idHash();\n+\n+    /**\n+     * Compare the id to the id of the given instance.\n+     */\n+    protected abstract boolean idEquals(OpenJPAId other);\n+\n+    public int hashCode() {\n+        if (_typeHash == 0) {\n+            Class base = type;\n+            while (base.getSuperclass() != null\n+                && base.getSuperclass() != Object.class)\n+                base = base.getSuperclass();\n+            _typeHash = base.hashCode();\n+        }\n+        return _typeHash ^ idHash();\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == this)\n+            return true;\n+        if (o == null || getClass() != o.getClass())\n+            return false;\n+\n+        OpenJPAId id = (OpenJPAId) o;\n+        return idEquals(id) && (id.type.isAssignableFrom(type)\n+            || (subs && type.isAssignableFrom(id.type)));\n+    }\n+\n+    public String toString() {\n+        return type.getName() + \"-\" + getIdObject();\n+    }\n+\n+    public int compareTo(Object other) {\n+        if (other == this)\n+            return 0;\n+        if (other == null)\n+            return 1;\n+        return ((Comparable) getIdObject()).compareTo(((OpenJPAId) other).\n+            getIdObject ());\n+\t}\n+}"},{"sha":"54ccd1717a2788b50adcebeb75c2946dd7c36d82","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/OptimisticException.java","status":"modified","additions":60,"deletions":56,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/OptimisticException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/OptimisticException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/OptimisticException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,56 +1,60 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.util.Collection;\r\n-\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-\r\n-/**\r\n- * Exception type for optimistic concurrency violations.\r\n- *\r\n- * @author Marc Prud'hommeaux\r\n- * @nojavadoc\r\n- * @since 2.5\r\n- */\r\n-public class OptimisticException extends StoreException {\r\n-\r\n-    private static final transient Localizer _loc = Localizer.forPackage\r\n-        (OptimisticException.class);\r\n-\r\n-    public OptimisticException() {\r\n-    }\r\n-\r\n-    public OptimisticException(String msg) {\r\n-        super(msg);\r\n-    }\r\n-\r\n-    public OptimisticException(Object failed) {\r\n-        this(_loc.get(\"opt-lock\", Exceptions.toString(failed)));\r\n-        setFailedObject(failed);\r\n-    }\r\n-\r\n-    public OptimisticException(Throwable[] nested) {\r\n-        this(_loc.get(\"opt-lock-nested\"));\r\n-        setNestedThrowables(nested);\r\n-    }\r\n-\r\n-    public OptimisticException(Collection failed, Throwable[] nested) {\r\n-        this(_loc.get(\"opt-lock-multi\", Exceptions.toString(failed)));\r\n-        setNestedThrowables(nested);\r\n-    }\r\n-\r\n-    public int getSubtype() {\r\n-        return OPTIMISTIC;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.util.Collection;\n+\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+/**\n+ * Exception type for optimistic concurrency violations.\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @since 2.5\n+ * @nojavadoc\n+ */\n+public class OptimisticException\n+    extends StoreException {\n+\n+    private static final transient Localizer _loc = Localizer.forPackage\n+        (OptimisticException.class);\n+\n+    public OptimisticException() {\n+    }\n+\n+    public OptimisticException(String msg) {\n+        super(msg);\n+    }\n+\n+    public OptimisticException(Object failed) {\n+        this(_loc.get(\"opt-lock\", Exceptions.toString(failed)));\n+        setFailedObject(failed);\n+    }\n+\n+    public OptimisticException(Throwable[] nested) {\n+        this(_loc.get(\"opt-lock-nested\"));\n+        setNestedThrowables(nested);\n+    }\n+\n+    public OptimisticException(Collection failed, Throwable[] nested) {\n+        this(_loc.get(\"opt-lock-multi\", Exceptions.toString(failed)));\n+        setNestedThrowables(nested);\n+    }\n+\n+    public int getSubtype() {\n+        return OPTIMISTIC;\n+    }\n+}"},{"sha":"042e6bc5a9bd38e6e38be1590928931716830055","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxies.java","status":"modified","additions":251,"deletions":241,"changes":492,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxies.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxies.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxies.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,241 +1,251 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.util.AbstractSet;\r\n-import java.util.Iterator;\r\n-import java.util.ListIterator;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-\r\n-/**\r\n- * Utility methods for managing proxies.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public class Proxies {\r\n-\r\n-    public static final int MODE_ENTRY = 0;\r\n-    public static final int MODE_KEY = 1;\r\n-    public static final int MODE_VALUE = 2;\r\n-    private static final Localizer _loc = Localizer.forPackage(Proxies.class);\r\n-\r\n-    /**\r\n-     * Used by proxy types to check if the given owners and field names\r\n-     * are equivalent.\r\n-     */\r\n-    public static boolean isOwner(Proxy proxy, OpenJPAStateManager sm,\r\n-        int field) {\r\n-        return proxy.getOwner() == sm && proxy.getOwnerField() == field;\r\n-    }\r\n-\r\n-    /**\r\n-     * Used by proxy types to check that an attempt to add a new value is legal.\r\n-     */\r\n-    public static void assertAllowedType(Object value, Class allowed) {\r\n-        if (value != null && allowed != null && !allowed.isInstance(value)) {\r\n-            throw new UserException(_loc.get(\"bad-elem-type\", new Object[]{\r\n-                allowed.getClassLoader(), allowed,\r\n-                value.getClass().getClassLoader(), value.getClass()\r\n-            }));\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Used by proxy types to dirty their owner.\r\n-     */\r\n-    public static void dirty(Proxy proxy) {\r\n-        if (proxy.getOwner() != null)\r\n-            proxy.getOwner().dirty(proxy.getOwnerField());\r\n-    }\r\n-\r\n-    /**\r\n-     * Used by proxy types to notify their owner that an element has been\r\n-     * removed.\r\n-     */\r\n-    public static void removed(Proxy proxy, Object removed, boolean key) {\r\n-        if (proxy.getOwner() != null && removed != null)\r\n-            proxy.getOwner().removed(proxy.getOwnerField(), removed, key);\r\n-    }\r\n-\r\n-    /**\r\n-     * Return an iterator that dirties its owner on calls to remove. This\r\n-     * iterator assumes that the given proxy collection uses a\r\n-     * {@link CollectionChangeTracker}.\r\n-     */\r\n-    public static Iterator iterator(final ProxyCollection proxy,\r\n-        final Iterator itr) {\r\n-        return new Iterator() {\r\n-            private Object _last = null;\r\n-\r\n-            public boolean hasNext() {\r\n-                return itr.hasNext();\r\n-            }\r\n-\r\n-            public Object next() {\r\n-                _last = itr.next();\r\n-                return _last;\r\n-            }\r\n-\r\n-            public void remove() {\r\n-                dirty(proxy);\r\n-                itr.remove();\r\n-                if (proxy.getChangeTracker() != null)\r\n-                    ((CollectionChangeTracker) proxy.getChangeTracker()).\r\n-                        removed(_last);\r\n-                removed(proxy, _last, false);\r\n-            }\r\n-        };\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a proxy iterator that dirties its owner on remove, set, and\r\n-     * add. This iterator assumes that the given proxy collection uses a\r\n-     * {@link CollectionChangeTracker}.\r\n-     */\r\n-    public static ListIterator listIterator(final ProxyCollection proxy,\r\n-        final ListIterator itr, final Class allowed) {\r\n-        return new ListIterator() {\r\n-            private Object _last = null;\r\n-\r\n-            public boolean hasNext() {\r\n-                return itr.hasNext();\r\n-            }\r\n-\r\n-            public int nextIndex() {\r\n-                return itr.nextIndex();\r\n-            }\r\n-\r\n-            public Object next() {\r\n-                _last = itr.next();\r\n-                return _last;\r\n-            }\r\n-\r\n-            public boolean hasPrevious() {\r\n-                return itr.hasPrevious();\r\n-            }\r\n-\r\n-            public int previousIndex() {\r\n-                return itr.previousIndex();\r\n-            }\r\n-\r\n-            public Object previous() {\r\n-                _last = itr.previous();\r\n-                return _last;\r\n-            }\r\n-\r\n-            public void set(Object o) {\r\n-                assertAllowedType(o, allowed);\r\n-                dirty(proxy);\r\n-                itr.set(o);\r\n-                if (proxy.getChangeTracker() != null)\r\n-                    proxy.getChangeTracker().stopTracking();\r\n-                removed(proxy, _last, false);\r\n-                _last = o;\r\n-            }\r\n-\r\n-            public void add(Object o) {\r\n-                assertAllowedType(o, allowed);\r\n-                dirty(proxy);\r\n-                itr.add(o);\r\n-                if (proxy.getChangeTracker() != null) {\r\n-                    if (hasNext())\r\n-                        proxy.getChangeTracker().stopTracking();\r\n-                    else ((CollectionChangeTracker) proxy.getChangeTracker()).\r\n-                        added(o);\r\n-                }\r\n-                _last = o;\r\n-            }\r\n-\r\n-            public void remove() {\r\n-                dirty(proxy);\r\n-                itr.remove();\r\n-                if (proxy.getChangeTracker() != null)\r\n-                    ((CollectionChangeTracker) proxy.getChangeTracker()).\r\n-                        removed(_last);\r\n-                removed(proxy, _last, false);\r\n-            }\r\n-        };\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a proxy for the given map key or entry set.\r\n-     */\r\n-    public static Set entrySet(final ProxyMap proxy, final Set set,\r\n-        final int mode) {\r\n-        return new AbstractSet() {\r\n-            public int size() {\r\n-                return set.size();\r\n-            }\r\n-\r\n-            public boolean remove(Object o) {\r\n-                if (mode != MODE_KEY)\r\n-                    throw new UnsupportedOperationException();\r\n-                Map map = (Map) proxy;\r\n-                if (!map.containsKey(o))\r\n-                    return false;\r\n-                map.remove(o);\r\n-                return true;\r\n-            }\r\n-\r\n-            public Iterator iterator() {\r\n-                final Iterator itr = set.iterator();\r\n-                return new Iterator() {\r\n-                    private Map.Entry _last = null;\r\n-\r\n-                    public boolean hasNext() {\r\n-                        return itr.hasNext();\r\n-                    }\r\n-\r\n-                    public Object next() {\r\n-                        _last = (Map.Entry) itr.next();\r\n-                        switch (mode) {\r\n-                            case MODE_KEY:\r\n-                                return _last.getKey();\r\n-                            case MODE_VALUE:\r\n-                                return _last.getValue();\r\n-                            default:\r\n-                                return _last;\r\n-                        }\r\n-                    }\r\n-\r\n-                    public void remove() {\r\n-                        dirty(proxy);\r\n-                        itr.remove();\r\n-                        if (proxy.getChangeTracker() != null)\r\n-                            ((MapChangeTracker) proxy.getChangeTracker()).\r\n-                                removed(_last.getKey(), _last.getValue());\r\n-                        removed(proxy, _last.getKey(), true);\r\n-                        removed(proxy, _last.getValue(), false);\r\n-                    }\r\n-                };\r\n-            }\r\n-\r\n-            protected Object writeReplace() throws ObjectStreamException {\r\n-                switch (mode) {\r\n-                    case MODE_KEY:\r\n-                        return ((Map) proxy).keySet();\r\n-                    case MODE_VALUE:\r\n-                        return ((Map) proxy).values();\r\n-                    default:\r\n-                        return ((Map) proxy).entrySet();\r\n-                }\r\n-            }\r\n-        };\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.ObjectStreamException;\n+import java.util.AbstractSet;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+/**\n+ * <p>Utility methods for managing proxies.</p>\n+ *\n+ * @author Abe White\n+ */\n+public class Proxies {\n+\n+    public static final int MODE_ENTRY = 0;\n+    public static final int MODE_KEY = 1;\n+    public static final int MODE_VALUE = 2;\n+\n+    private static final Localizer _loc = Localizer.forPackage(Proxies.class);\n+\n+    /**\n+     * Used by proxy types to check if the given owners and field names\n+     * are equivalent.\n+     */\n+    public static boolean isOwner(Proxy proxy, OpenJPAStateManager sm,\n+        int field) {\n+        return proxy.getOwner() == sm && proxy.getOwnerField() == field;\n+    }\n+\n+    /**\n+     * Used by proxy types to check that an attempt to add a new value\n+     * is legal.\n+     */\n+    public static void assertAllowedType(Object value, Class allowed) {\n+        if (value != null && allowed != null && !allowed.isInstance(value)) {\n+            throw new UserException(_loc.get(\"bad-elem-type\", new Object[]{\n+                allowed.getClassLoader(),\n+                allowed,\n+                value.getClass().getClassLoader(),\n+                value.getClass()\n+            }));\n+        }\n+    }\n+\n+    /**\n+     * Used by proxy types to dirty their owner.\n+     */\n+    public static void dirty(Proxy proxy) {\n+        if (proxy.getOwner() != null)\n+            proxy.getOwner().dirty(proxy.getOwnerField());\n+    }\n+\n+    /**\n+     * Used by proxy types to notify their owner that an element has been\n+     * removed.\n+     */\n+    public static void removed(Proxy proxy, Object removed, boolean key) {\n+        if (proxy.getOwner() != null && removed != null)\n+            proxy.getOwner().removed(proxy.getOwnerField(), removed, key);\n+    }\n+\n+    /**\n+     * Return an iterator that dirties its owner on calls to remove.  This\n+     * iterator assumes that the given proxy collection uses a\n+     * {@link CollectionChangeTracker}.\n+     */\n+    public static Iterator iterator(final ProxyCollection proxy,\n+        final Iterator itr) {\n+        return new Iterator() {\n+            private Object _last = null;\n+\n+            public boolean hasNext() {\n+                return itr.hasNext();\n+            }\n+\n+            public Object next() {\n+                _last = itr.next();\n+                return _last;\n+            }\n+\n+            public void remove() {\n+                dirty(proxy);\n+                itr.remove();\n+                if (proxy.getChangeTracker() != null)\n+                    ((CollectionChangeTracker) proxy.getChangeTracker()).\n+                        removed(_last);\n+                removed(proxy, _last, false);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Return a proxy iterator that dirties its owner on remove, set, and\n+     * add.  This iterator assumes that the given proxy collection uses a\n+     * {@link CollectionChangeTracker}.\n+     */\n+    public static ListIterator listIterator(final ProxyCollection proxy,\n+        final ListIterator itr, final Class allowed) {\n+        return new ListIterator() {\n+            private Object _last = null;\n+\n+            public boolean hasNext() {\n+                return itr.hasNext();\n+            }\n+\n+            public int nextIndex() {\n+                return itr.nextIndex();\n+            }\n+\n+            public Object next() {\n+                _last = itr.next();\n+                return _last;\n+            }\n+\n+            public boolean hasPrevious() {\n+                return itr.hasPrevious();\n+            }\n+\n+            public int previousIndex() {\n+                return itr.previousIndex();\n+            }\n+\n+            public Object previous() {\n+                _last = itr.previous();\n+                return _last;\n+            }\n+\n+            public void set(Object o) {\n+                assertAllowedType(o, allowed);\n+                dirty(proxy);\n+                itr.set(o);\n+                if (proxy.getChangeTracker() != null)\n+                    proxy.getChangeTracker().stopTracking();\n+                removed(proxy, _last, false);\n+                _last = o;\n+            }\n+\n+            public void add(Object o) {\n+                assertAllowedType(o, allowed);\n+                dirty(proxy);\n+                itr.add(o);\n+                if (proxy.getChangeTracker() != null) {\n+                    if (hasNext())\n+                        proxy.getChangeTracker().stopTracking();\n+                    else\n+                        ((CollectionChangeTracker) proxy.getChangeTracker()).\n+                            added(o);\n+                }\n+                _last = o;\n+            }\n+\n+            public void remove() {\n+                dirty(proxy);\n+                itr.remove();\n+                if (proxy.getChangeTracker() != null)\n+                    ((CollectionChangeTracker) proxy.getChangeTracker()).\n+                        removed(_last);\n+                removed(proxy, _last, false);\n+            }\n+        };\n+    }\n+\n+    /**\n+     *\tReturn a proxy for the given map key or entry set.\n+     */\n+    public static Set entrySet(final ProxyMap proxy, final Set set,\n+        final int mode) {\n+        return new AbstractSet() {\n+            public int size() {\n+                return set.size();\n+            }\n+\n+            public boolean remove(Object o) {\n+                if (mode != MODE_KEY)\n+                    throw new UnsupportedOperationException();\n+\n+                Map map = (Map) proxy;\n+                if (!map.containsKey(o))\n+                    return false;\n+                map.remove(o);\n+                return true;\n+            }\n+\n+            public Iterator iterator() {\n+                final Iterator itr = set.iterator();\n+                return new Iterator() {\n+                    private Map.Entry _last = null;\n+\n+                    public boolean hasNext() {\n+                        return itr.hasNext();\n+                    }\n+\n+                    public Object next() {\n+                        _last = (Map.Entry) itr.next();\n+                        switch (mode) {\n+                            case MODE_KEY:\n+                                return _last.getKey();\n+                            case MODE_VALUE:\n+                                return _last.getValue();\n+                            default:\n+                                return _last;\n+                        }\n+                    }\n+\n+                    public void remove() {\n+                        dirty(proxy);\n+                        itr.remove();\n+                        if (proxy.getChangeTracker() != null)\n+                            ((MapChangeTracker) proxy.getChangeTracker()).\n+                                removed(_last.getKey(), _last.getValue());\n+                        removed(proxy, _last.getKey(), true);\n+                        removed(proxy, _last.getValue(), false);\n+                    }\n+                };\n+            }\n+\n+            protected Object writeReplace()\n+                throws ObjectStreamException {\n+                switch (mode) {\n+                    case MODE_KEY:\n+                        return ((Map) proxy).keySet();\n+                    case MODE_VALUE:\n+                        return ((Map) proxy).values();\n+                    default:\n+                        return ((Map) proxy).entrySet();\n+                }\n+\t\t\t}\n+\t\t};\n+\t}\n+}\n+"},{"sha":"2c1000ba0b4e14b05f7e862fd55c9f66c690950d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxy.java","status":"modified","additions":59,"deletions":55,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxy.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxy.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,55 +1,59 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-\r\n-/**\r\n- * Interface implemented by all proxy types to allow setting and nulling\r\n- * of their owning instance.\r\n- * All concrete proxy classes should be public and have publc no-args\r\n- * constructors so that tools that work via reflection on persistent instances\r\n- * can manipulate them.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public interface Proxy {\r\n-\r\n-    /**\r\n-     * Reset the state of the proxy, and set the owning instance of the\r\n-     * proxy and the name of the field it is assigned to. Set to null to\r\n-     * indicate that the proxy is no longer managed.\r\n-     */\r\n-    public void setOwner(OpenJPAStateManager sm, int field);\r\n-\r\n-    /**\r\n-     * Return the owning object.\r\n-     */\r\n-    public OpenJPAStateManager getOwner();\r\n-\r\n-    /**\r\n-     * Return the owning field index.\r\n-     */\r\n-    public int getOwnerField();\r\n-\r\n-    /**\r\n-     * Return the change tracker for this proxy, or null if none.\r\n-     */\r\n-    public ChangeTracker getChangeTracker();\r\n-\r\n-    /**\r\n-     * Return an unproxied copy of the given instance. This method is used\r\n-     * by proxy managers to create backup values for use in rollback.\r\n-     */\r\n-    public Object copy(Object orig);\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * <p>Interface implemented by all proxy types to allow setting and nulling\n+ * of their owning instance.</p>\n+ * <p/>\n+ * <p>All concrete proxy classes should be public and have publc no-args\n+ * constructors so that tools that work via reflection on persistent instances\n+ * can manipulate them.</p>\n+ *\n+ * @author Abe White\n+ */\n+public interface Proxy {\n+\n+    /**\n+     * Reset the state of the proxy, and set the owning instance of the\n+     * proxy and the name of the field it is assigned to.  Set to null to\n+     * indicate that the proxy is no longer managed.\n+     */\n+    public void setOwner(OpenJPAStateManager sm, int field);\n+\n+    /**\n+     * Return the owning object.\n+     */\n+    public OpenJPAStateManager getOwner();\n+\n+    /**\n+     * Return the owning field index.\n+     */\n+    public int getOwnerField();\n+\n+    /**\n+     * Return the change tracker for this proxy, or null if none.\n+     */\n+    public ChangeTracker getChangeTracker();\n+\n+    /**\n+     *\tReturn an unproxied copy of the given instance.  This method is used\n+     *\tby proxy managers to create backup values for use in rollback.\n+     */\n+    public Object copy(Object orig);\n+}"},{"sha":"2331029a089cd05e8be547dd24e78f93ed99c7cc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyArrayList.java","status":"modified","additions":192,"deletions":186,"changes":378,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyArrayList.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyArrayList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyArrayList.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,186 +1,192 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.Comparator;\r\n-import java.util.Iterator;\r\n-import java.util.ListIterator;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-\r\n-/**\r\n- * Extension of the {@link ArrayList} type that dirties the\r\n- * persistent/transactional field it is assigned to on modification.\r\n- * The need to dirty the field on <b>any</b> modification mandates that\r\n- * this class must override all mutator methods of the base type.\r\n- * This may lead to multiple calls to <code>dirty</code> for one state\r\n- * change if one mutator method of the base type calls another.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class ProxyArrayList extends ArrayList implements ProxyCollection {\r\n-\r\n-    private transient Class _elementType = null;\r\n-    private transient OpenJPAStateManager _sm = null;\r\n-    private transient int _field = -1;\r\n-    private transient CollectionChangeTracker _ct = null;\r\n-\r\n-    public ProxyArrayList() {\r\n-    }\r\n-\r\n-    public ProxyArrayList(Class elementType, boolean trackChanges,\r\n-        OpenJPAConfiguration conf) {\r\n-        _elementType = elementType;\r\n-        if (trackChanges)\r\n-            _ct = new CollectionChangeTrackerImpl(this, true, true, conf);\r\n-    }\r\n-\r\n-    public void setOwner(OpenJPAStateManager sm, int field) {\r\n-        _sm = sm;\r\n-        _field = field;\r\n-    }\r\n-\r\n-    public OpenJPAStateManager getOwner() {\r\n-        return _sm;\r\n-    }\r\n-\r\n-    public int getOwnerField() {\r\n-        return _field;\r\n-    }\r\n-\r\n-    public ChangeTracker getChangeTracker() {\r\n-        return _ct;\r\n-    }\r\n-\r\n-    public Object copy(Object orig) {\r\n-        return new ArrayList((Collection) orig);\r\n-    }\r\n-\r\n-    public ProxyCollection newInstance(Class elementType, Comparator compare,\r\n-        boolean trackChanges, OpenJPAConfiguration conf) {\r\n-        return new ProxyArrayList(elementType, trackChanges, conf);\r\n-    }\r\n-\r\n-    public void add(int index, Object value) {\r\n-        Proxies.assertAllowedType(value, _elementType);\r\n-        Proxies.dirty(this);\r\n-        if (_ct != null)\r\n-            _ct.stopTracking();\r\n-        super.add(index, value);\r\n-    }\r\n-\r\n-    public boolean add(Object value) {\r\n-        Proxies.assertAllowedType(value, _elementType);\r\n-        Proxies.dirty(this);\r\n-        if (super.add(value)) {\r\n-            if (_ct != null)\r\n-                _ct.added(value);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean addAll(int index, Collection values) {\r\n-        ensureCapacity(size() + values.size());\r\n-        for (Iterator itr = values.iterator(); itr.hasNext(); index++)\r\n-            add(index, itr.next());\r\n-        return values.size() > 0;\r\n-    }\r\n-\r\n-    public boolean addAll(Collection values) {\r\n-        ensureCapacity(size() + values.size());\r\n-        boolean added = false;\r\n-        for (Iterator itr = values.iterator(); itr.hasNext();)\r\n-            added = add(itr.next()) || added;\r\n-        return added;\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        Proxies.dirty(this);\r\n-        if (_ct != null)\r\n-            _ct.stopTracking();\r\n-        for (int i = 0; i < size(); i++)\r\n-            Proxies.removed(this, get(i), false);\r\n-        super.clear();\r\n-    }\r\n-\r\n-    public Iterator iterator() {\r\n-        return Proxies.iterator(this, super.iterator());\r\n-    }\r\n-\r\n-    public ListIterator listIterator() {\r\n-        return Proxies.listIterator(this, super.listIterator(), _elementType);\r\n-    }\r\n-\r\n-    public ListIterator listIterator(int index) {\r\n-        return Proxies.listIterator(this, super.listIterator(index),\r\n-            _elementType);\r\n-    }\r\n-\r\n-    public Object remove(int index) {\r\n-        Proxies.dirty(this);\r\n-        Object rem = super.remove(index);\r\n-        if (_ct != null)\r\n-            _ct.removed(rem);\r\n-        Proxies.removed(this, rem, false);\r\n-        return rem;\r\n-    }\r\n-\r\n-    public boolean remove(Object o) {\r\n-        Proxies.dirty(this);\r\n-        if (super.remove(o)) {\r\n-            if (_ct != null)\r\n-                _ct.removed(o);\r\n-            Proxies.removed(this, o, false);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean removeAll(Collection c) {\r\n-        boolean removed = false;\r\n-        for (Iterator itr = c.iterator(); itr.hasNext();)\r\n-            removed = remove(itr.next()) || removed;\r\n-        return removed;\r\n-    }\r\n-\r\n-    public boolean retainAll(Collection c) {\r\n-        int size = size();\r\n-        for (Iterator itr = iterator(); itr.hasNext();)\r\n-            if (!c.contains(itr.next()))\r\n-                itr.remove();\r\n-        return size() < size;\r\n-    }\r\n-\r\n-    public Object set(int index, Object element) {\r\n-        Proxies.assertAllowedType(element, _elementType);\r\n-        Proxies.dirty(this);\r\n-        if (_ct != null)\r\n-            _ct.stopTracking();\r\n-        Object rem = super.set(index, element);\r\n-        if (rem != element)\r\n-            Proxies.removed(this, rem, false);\r\n-        return rem;\r\n-    }\r\n-\r\n-    protected Object writeReplace() throws ObjectStreamException {\r\n-        if (_sm != null && _sm.isDetached())\r\n-            return this;\r\n-        return copy(this);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.ObjectStreamException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * <p>Extension of the {@link ArrayList} type that dirties the\n+ * persistent/transactional field it is assigned to on modification.\n+ * The need to dirty the field on <b>any</b> modification mandates that\n+ * this class must override all mutator methods of the base type.\n+ * This may lead to multiple calls to <code>dirty</code> for one state\n+ * change if one mutator method of the base type calls another.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ProxyArrayList\n+    extends ArrayList\n+    implements ProxyCollection {\n+\n+    private transient Class _elementType = null;\n+    private transient OpenJPAStateManager _sm = null;\n+    private transient int _field = -1;\n+    private transient CollectionChangeTracker _ct = null;\n+\n+    public ProxyArrayList() {\n+    }\n+\n+    public ProxyArrayList(Class elementType, boolean trackChanges,\n+        OpenJPAConfiguration conf) {\n+        _elementType = elementType;\n+        if (trackChanges)\n+            _ct = new CollectionChangeTrackerImpl(this, true, true, conf);\n+    }\n+\n+    public void setOwner(OpenJPAStateManager sm, int field) {\n+        _sm = sm;\n+        _field = field;\n+    }\n+\n+    public OpenJPAStateManager getOwner() {\n+        return _sm;\n+    }\n+\n+    public int getOwnerField() {\n+        return _field;\n+    }\n+\n+    public ChangeTracker getChangeTracker() {\n+        return _ct;\n+    }\n+\n+    public Object copy(Object orig) {\n+        return new ArrayList((Collection) orig);\n+    }\n+\n+    public ProxyCollection newInstance(Class elementType, Comparator compare,\n+        boolean trackChanges, OpenJPAConfiguration conf) {\n+        return new ProxyArrayList(elementType, trackChanges, conf);\n+    }\n+\n+    public void add(int index, Object value) {\n+        Proxies.assertAllowedType(value, _elementType);\n+        Proxies.dirty(this);\n+        if (_ct != null)\n+            _ct.stopTracking();\n+        super.add(index, value);\n+    }\n+\n+    public boolean add(Object value) {\n+        Proxies.assertAllowedType(value, _elementType);\n+        Proxies.dirty(this);\n+        if (super.add(value)) {\n+            if (_ct != null)\n+                _ct.added(value);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean addAll(int index, Collection values) {\n+        ensureCapacity(size() + values.size());\n+        for (Iterator itr = values.iterator(); itr.hasNext(); index++)\n+            add(index, itr.next());\n+        return values.size() > 0;\n+    }\n+\n+    public boolean addAll(Collection values) {\n+        ensureCapacity(size() + values.size());\n+        boolean added = false;\n+        for (Iterator itr = values.iterator(); itr.hasNext();)\n+            added = add(itr.next()) || added;\n+        return added;\n+    }\n+\n+    public void clear() {\n+        Proxies.dirty(this);\n+        if (_ct != null)\n+            _ct.stopTracking();\n+        for (int i = 0; i < size(); i++)\n+            Proxies.removed(this, get(i), false);\n+        super.clear();\n+    }\n+\n+    public Iterator iterator() {\n+        return Proxies.iterator(this, super.iterator());\n+    }\n+\n+    public ListIterator listIterator() {\n+        return Proxies.listIterator(this, super.listIterator(), _elementType);\n+    }\n+\n+    public ListIterator listIterator(int index) {\n+        return Proxies.listIterator(this, super.listIterator(index),\n+            _elementType);\n+    }\n+\n+    public Object remove(int index) {\n+        Proxies.dirty(this);\n+        Object rem = super.remove(index);\n+        if (_ct != null)\n+            _ct.removed(rem);\n+        Proxies.removed(this, rem, false);\n+        return rem;\n+    }\n+\n+    public boolean remove(Object o) {\n+        Proxies.dirty(this);\n+        if (super.remove(o)) {\n+            if (_ct != null)\n+                _ct.removed(o);\n+            Proxies.removed(this, o, false);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean removeAll(Collection c) {\n+        boolean removed = false;\n+        for (Iterator itr = c.iterator(); itr.hasNext();)\n+            removed = remove(itr.next()) || removed;\n+        return removed;\n+    }\n+\n+    public boolean retainAll(Collection c) {\n+        int size = size();\n+        for (Iterator itr = iterator(); itr.hasNext();)\n+            if (!c.contains(itr.next()))\n+                itr.remove();\n+        return size() < size;\n+    }\n+\n+    public Object set(int index, Object element) {\n+        Proxies.assertAllowedType(element, _elementType);\n+        Proxies.dirty(this);\n+        if (_ct != null)\n+            _ct.stopTracking();\n+        Object rem = super.set(index, element);\n+        if (rem != element)\n+            Proxies.removed(this, rem, false);\n+        return rem;\n+    }\n+\n+    protected Object writeReplace()\n+        throws ObjectStreamException {\n+        if (_sm != null && _sm.isDetached())\n+            return this;\n+        return copy(this);\n+    }\n+}"},{"sha":"9422d8712c01fefec4542904e42508aa49a4b3ca","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCalendar.java","status":"modified","additions":34,"deletions":30,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCalendar.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCalendar.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCalendar.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,30 +1,34 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.util.TimeZone;\r\n-\r\n-/**\r\n- * Interface implemented by all built-in proxies on\r\n- * {@link java.util.Calendar} types.\r\n- *\r\n- * @author Marc Prud'hommeaux\r\n- */\r\n-public interface ProxyCalendar extends Proxy {\r\n-\r\n-    /**\r\n-     * Return a new instance of this calendar type.\r\n-     */\r\n-    public ProxyCalendar newInstance(TimeZone timeZone);\r\n-}\r\n-\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.util.TimeZone;\n+\n+/**\n+ * <p>Interface implemented by all built-in proxies on\n+ * {@link java.util.Calendar} types.</p>\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+public interface ProxyCalendar\n+    extends Proxy {\n+\n+    /**\n+     * Return a new instance of this calendar type.\n+     */\n+    public ProxyCalendar newInstance(TimeZone timeZone);\n+}\n+"},{"sha":"3b4567f1ad6469068e9ef86442fd170ed9601872","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCollection.java","status":"modified","additions":41,"deletions":36,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCollection.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCollection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCollection.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,36 +1,41 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.Comparator;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-\r\n-/**\r\n- * Interface implemented by all built-in proxies on {@link Collection} types.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public interface ProxyCollection extends Proxy {\r\n-\r\n-    /**\r\n-     * This method should return a new proxy of the same concrete type as the\r\n-     * implementing class. Used by the {@link ProxyManager} factories: one\r\n-     * template instance of each type is created for the purpose of producing\r\n-     * new instances via this method. Overcomes the performance penalties of\r\n-     * reflection.\r\n-     */\r\n-    public ProxyCollection newInstance(Class elementType, Comparator compare,\r\n-        boolean trackChanges, OpenJPAConfiguration conf);\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.util.Collection;\n+import java.util.Comparator;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+\n+/**\n+ * <p>Interface implemented by all built-in proxies on {@link Collection}\n+ * types.</p>\n+ *\n+ * @author Abe White\n+ */\n+public interface ProxyCollection\n+    extends Proxy {\n+\n+    /**\n+     * This method should return a new proxy of the same concrete type as the\n+     * implementing class.  Used by the {@link ProxyManager} factories: one\n+     * template instance of each type is created for the purpose of producing\n+     * new instances via this method.  Overcomes the performance penalties of\n+     * reflection.\n+     */\n+    public ProxyCollection newInstance(Class elementType, Comparator compare,\n+        boolean trackChanges, OpenJPAConfiguration conf);\n+}"},{"sha":"cf262f47aa1dc97030f3fef5d98734aeeb6cf46c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyDate.java","status":"modified","additions":31,"deletions":27,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyDate.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyDate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyDate.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,27 +1,31 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-/**\r\n- * Interface implemented by all built-in proxies on {@link java.util.Date}\r\n- * types.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public interface ProxyDate extends Proxy {\r\n-\r\n-    /**\r\n-     * Return a new instance of this date type.\r\n-     */\r\n-    public ProxyDate newInstance();\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+/**\n+ * <p>Interface implemented by all built-in proxies on {@link java.util.Date}\n+ * types.</p>\n+ *\n+ * @author Abe White\n+ */\n+public interface ProxyDate\n+    extends Proxy {\n+\n+    /**\n+     * Return a new instance of this date type.\n+     */\n+    public ProxyDate newInstance();\n+}"},{"sha":"c702fbd42c6ddfec8673545ed0f0fb33be3a8620","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyGregorianCalendar.java","status":"modified","additions":181,"deletions":172,"changes":353,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyGregorianCalendar.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyGregorianCalendar.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyGregorianCalendar.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,172 +1,181 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.util.Calendar;\r\n-import java.util.GregorianCalendar;\r\n-import java.util.Locale;\r\n-import java.util.TimeZone;\r\n-\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-\r\n-/**\r\n- * Extension of the {@link Calendar} type that calls the <code>dirty</code>\r\n- * method on its owning persistence capable instance on modification. This\r\n- * class does not support modification via any deprecated method of the\r\n- * date class.\r\n- *\r\n- * @author Marc Prud'hommeaux\r\n- * @nojavadoc\r\n- */\r\n-public class ProxyGregorianCalendar extends GregorianCalendar\r\n-    implements ProxyCalendar {\r\n-\r\n-    private transient OpenJPAStateManager _sm = null;\r\n-    private transient int _field = -1;\r\n-\r\n-    public ProxyGregorianCalendar() {\r\n-        super();\r\n-    }\r\n-\r\n-    public ProxyGregorianCalendar(int year, int month, int dayOfMonth) {\r\n-        super(year, month, dayOfMonth);\r\n-    }\r\n-\r\n-    public ProxyGregorianCalendar(int year, int month, int dayOfMonth,\r\n-        int hourOfDay, int minute) {\r\n-        super(year, month, dayOfMonth, hourOfDay, minute);\r\n-    }\r\n-\r\n-    public ProxyGregorianCalendar(int year, int month, int dayOfMonth,\r\n-        int hourOfDay, int minute, int second) {\r\n-        super(year, month, dayOfMonth, hourOfDay, minute, second);\r\n-    }\r\n-\r\n-    public ProxyGregorianCalendar(Locale aLocale) {\r\n-        super(aLocale);\r\n-    }\r\n-\r\n-    public ProxyGregorianCalendar(TimeZone zone) {\r\n-        super(zone);\r\n-    }\r\n-\r\n-    public ProxyGregorianCalendar(TimeZone zone, Locale aLocale) {\r\n-        super(zone, aLocale);\r\n-    }\r\n-\r\n-    public ProxyCalendar newInstance(TimeZone timeZone) {\r\n-        if (timeZone == null)\r\n-            return new ProxyGregorianCalendar();\r\n-        else return new ProxyGregorianCalendar(timeZone);\r\n-    }\r\n-\r\n-    public void setOwner(OpenJPAStateManager sm, int field) {\r\n-        _sm = sm;\r\n-        _field = field;\r\n-    }\r\n-\r\n-    public OpenJPAStateManager getOwner() {\r\n-        return _sm;\r\n-    }\r\n-\r\n-    public int getOwnerField() {\r\n-        return _field;\r\n-    }\r\n-\r\n-    public ChangeTracker getChangeTracker() {\r\n-        return null;\r\n-    }\r\n-\r\n-    public Object copy(Object orig) {\r\n-        Calendar origCal = (Calendar) orig;\r\n-        GregorianCalendar cal = new GregorianCalendar(origCal.getTimeZone());\r\n-        cal.setTime(origCal.getTime());\r\n-        return cal;\r\n-    }\r\n-\r\n-    protected Object writeReplace() throws ObjectStreamException {\r\n-        if (_sm != null && _sm.isDetached())\r\n-            return this;\r\n-        return copy(this);\r\n-    }\r\n-\r\n-    protected void computeFields() {\r\n-        // Calendar.computeFields() is called whenever a mutation\r\n-        // occurs in order to recalculate all the fields\r\n-        Proxies.dirty(this);\r\n-        super.computeFields();\r\n-    }\r\n-\r\n-    public void setTimeInMillis(long millis) {\r\n-        if (millis != getTimeInMillis()) {\r\n-            Proxies.dirty(this);\r\n-            super.setTimeInMillis(millis);\r\n-        }\r\n-    }\r\n-\r\n-    /* This is \"final\" in JDK 1.3 (not in 1.4 or 1.5)\r\n- public void set(int field, int value)\r\n- {\r\n- if (get(field) != value)\r\n- {\r\n- Proxies.dirty(this);\r\n- super.set(field, value);\r\n- }\r\n- }\r\n-    */\r\n-    public void add(int field, int amount) {\r\n-        if (amount != 0) {\r\n-            Proxies.dirty(this);\r\n-            super.add(field, amount);\r\n-        }\r\n-    }\r\n-\r\n-    public void roll(int field, boolean up) {\r\n-        Proxies.dirty(this);\r\n-        super.roll(field, up);\r\n-    }\r\n-\r\n-    public void roll(int field, int amount) {\r\n-        if (amount != 0) {\r\n-            Proxies.dirty(this);\r\n-            super.roll(field, amount);\r\n-        }\r\n-    }\r\n-\r\n-    public void setTimeZone(TimeZone value) {\r\n-        Proxies.dirty(this);\r\n-        super.setTimeZone(value);\r\n-    }\r\n-\r\n-    public void setLenient(boolean lenient) {\r\n-        if (isLenient() != lenient) {\r\n-            Proxies.dirty(this);\r\n-            super.setLenient(lenient);\r\n-        }\r\n-    }\r\n-\r\n-    public void setFirstDayOfWeek(int value) {\r\n-        if (getFirstDayOfWeek() != value) {\r\n-            Proxies.dirty(this);\r\n-            super.setFirstDayOfWeek(value);\r\n-        }\r\n-    }\r\n-\r\n-    public void setMinimalDaysInFirstWeek(int value) {\r\n-        if (getMinimalDaysInFirstWeek() != value) {\r\n-            Proxies.dirty(this);\r\n-            super.setMinimalDaysInFirstWeek(value);\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.ObjectStreamException;\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * <p>Extension of the {@link Calendar} type that calls the <code>dirty</code>\n+ * method on its owning persistence capable instance on modification.  This\n+ * class does not support modification via any deprecated method of the\n+ * date class.</p>\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @nojavadoc\n+ */\n+public class ProxyGregorianCalendar\n+    extends GregorianCalendar\n+    implements ProxyCalendar {\n+\n+    private transient OpenJPAStateManager _sm = null;\n+    private transient int _field = -1;\n+\n+    public ProxyGregorianCalendar() {\n+        super();\n+    }\n+\n+    public ProxyGregorianCalendar(int year, int month, int dayOfMonth) {\n+        super(year, month, dayOfMonth);\n+    }\n+\n+    public ProxyGregorianCalendar(int year, int month, int dayOfMonth,\n+        int hourOfDay, int minute) {\n+        super(year, month, dayOfMonth, hourOfDay, minute);\n+    }\n+\n+    public ProxyGregorianCalendar(int year, int month, int dayOfMonth,\n+        int hourOfDay, int minute, int second) {\n+        super(year, month, dayOfMonth, hourOfDay, minute, second);\n+    }\n+\n+    public ProxyGregorianCalendar(Locale aLocale) {\n+        super(aLocale);\n+    }\n+\n+    public ProxyGregorianCalendar(TimeZone zone) {\n+        super(zone);\n+    }\n+\n+    public ProxyGregorianCalendar(TimeZone zone, Locale aLocale) {\n+        super(zone, aLocale);\n+    }\n+\n+    public ProxyCalendar newInstance(TimeZone timeZone) {\n+        if (timeZone == null)\n+            return new ProxyGregorianCalendar();\n+        else\n+            return new ProxyGregorianCalendar(timeZone);\n+    }\n+\n+    public void setOwner(OpenJPAStateManager sm, int field) {\n+        _sm = sm;\n+        _field = field;\n+    }\n+\n+    public OpenJPAStateManager getOwner() {\n+        return _sm;\n+    }\n+\n+    public int getOwnerField() {\n+        return _field;\n+    }\n+\n+    public ChangeTracker getChangeTracker() {\n+        return null;\n+    }\n+\n+    public Object copy(Object orig) {\n+        Calendar origCal = (Calendar) orig;\n+\n+        GregorianCalendar cal = new GregorianCalendar(origCal.getTimeZone());\n+        cal.setTime(origCal.getTime());\n+\n+        return cal;\n+    }\n+\n+    protected Object writeReplace()\n+        throws ObjectStreamException {\n+        if (_sm != null && _sm.isDetached())\n+            return this;\n+        return copy(this);\n+    }\n+\n+    protected void computeFields() {\n+        // Calendar.computeFields() is called whenever a mutation\n+        // occurs in order to recalculate all the fields\n+        Proxies.dirty(this);\n+        super.computeFields();\n+    }\n+\n+    public void setTimeInMillis(long millis) {\n+        if (millis != getTimeInMillis()) {\n+            Proxies.dirty(this);\n+            super.setTimeInMillis(millis);\n+        }\n+    }\n+\n+    /* This is \"final\" in JDK 1.3 (not in 1.4 or 1.5)\n+     public void set (int field, int value)\n+     {\n+         if (get (field) != value)\n+         {\n+             Proxies.dirty (this);\n+             super.set (field, value);\n+         }\n+     }\n+     */\n+\n+    public void add(int field, int amount) {\n+        if (amount != 0) {\n+            Proxies.dirty(this);\n+            super.add(field, amount);\n+        }\n+    }\n+\n+    public void roll(int field, boolean up) {\n+        Proxies.dirty(this);\n+        super.roll(field, up);\n+    }\n+\n+    public void roll(int field, int amount) {\n+        if (amount != 0) {\n+            Proxies.dirty(this);\n+            super.roll(field, amount);\n+        }\n+    }\n+\n+    public void setTimeZone(TimeZone value) {\n+        Proxies.dirty(this);\n+        super.setTimeZone(value);\n+    }\n+\n+    public void setLenient(boolean lenient) {\n+        if (isLenient() != lenient) {\n+            Proxies.dirty(this);\n+            super.setLenient(lenient);\n+        }\n+    }\n+\n+    public void setFirstDayOfWeek(int value) {\n+        if (getFirstDayOfWeek() != value) {\n+            Proxies.dirty(this);\n+            super.setFirstDayOfWeek(value);\n+        }\n+    }\n+\n+    public void setMinimalDaysInFirstWeek(int value) {\n+        if (getMinimalDaysInFirstWeek() != value) {\n+            Proxies.dirty(this);\n+            super.setMinimalDaysInFirstWeek(value);\n+        }\n+    }\n+}"},{"sha":"a82e0431bd6242ca744180fd7dc663e7e6b8618e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyHashMap.java","status":"modified","additions":154,"deletions":148,"changes":302,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyHashMap.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,148 +1,154 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.util.Collection;\r\n-import java.util.Comparator;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-\r\n-/**\r\n- * Extension of the {@link HashMap} type that dirties the\r\n- * persistent/transactional field it is assigned to on modification.\r\n- * The need to dirty the field on <b>any</b> modification mandates that\r\n- * this class must override all mutator methods of the base type.\r\n- * This may lead to multiple calls to <code>dirty</code> for one state\r\n- * change if one mutator method of the base type calls another.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class ProxyHashMap extends HashMap implements ProxyMap {\r\n-\r\n-    private transient Class _keyType = null;\r\n-    private transient Class _valueType = null;\r\n-    private transient OpenJPAStateManager _sm = null;\r\n-    private transient int _field = -1;\r\n-    private transient MapChangeTracker _ct = null;\r\n-\r\n-    public ProxyHashMap() {\r\n-    }\r\n-\r\n-    public ProxyHashMap(Class keyType, Class valueType, boolean trackChanges,\r\n-        OpenJPAConfiguration conf) {\r\n-        _keyType = keyType;\r\n-        _valueType = valueType;\r\n-        if (trackChanges)\r\n-            _ct = new MapChangeTrackerImpl(this, conf);\r\n-    }\r\n-\r\n-    public void setOwner(OpenJPAStateManager sm, int field) {\r\n-        _sm = sm;\r\n-        _field = field;\r\n-    }\r\n-\r\n-    public OpenJPAStateManager getOwner() {\r\n-        return _sm;\r\n-    }\r\n-\r\n-    public int getOwnerField() {\r\n-        return _field;\r\n-    }\r\n-\r\n-    public ChangeTracker getChangeTracker() {\r\n-        return _ct;\r\n-    }\r\n-\r\n-    public Object copy(Object orig) {\r\n-        return new HashMap((Map) orig);\r\n-    }\r\n-\r\n-    public ProxyMap newInstance(Class keyType, Class valueType,\r\n-        Comparator compare, boolean trackChanges, OpenJPAConfiguration conf) {\r\n-        return new ProxyHashMap(keyType, valueType, trackChanges, conf);\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        Proxies.dirty(this);\r\n-        if (_ct != null)\r\n-            _ct.stopTracking();\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = super.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            Proxies.removed(this, entry.getKey(), true);\r\n-            Proxies.removed(this, entry.getValue(), false);\r\n-        }\r\n-        super.clear();\r\n-    }\r\n-\r\n-    public Set keySet() {\r\n-        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_KEY);\r\n-    }\r\n-\r\n-    public Collection values() {\r\n-        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_VALUE);\r\n-    }\r\n-\r\n-    public Set entrySet() {\r\n-        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_ENTRY);\r\n-    }\r\n-\r\n-    public Object put(Object key, Object value) {\r\n-        Proxies.assertAllowedType(key, _keyType);\r\n-        Proxies.assertAllowedType(value, _valueType);\r\n-        Proxies.dirty(this);\r\n-        boolean had = containsKey(key);\r\n-        Object old = super.put(key, value);\r\n-        if (had) {\r\n-            if (_ct != null)\r\n-                _ct.changed(key, old, value);\r\n-            Proxies.removed(this, old, false);\r\n-        } else if (_ct != null)\r\n-            _ct.added(key, value);\r\n-        return old;\r\n-    }\r\n-\r\n-    public void putAll(Map m) {\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = m.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            put(entry.getKey(), entry.getValue());\r\n-        }\r\n-    }\r\n-\r\n-    public Object remove(Object key) {\r\n-        Proxies.dirty(this);\r\n-        boolean had = containsKey(key);\r\n-        Object old = super.remove(key);\r\n-        if (had) {\r\n-            if (_ct != null)\r\n-                _ct.removed(key, old);\r\n-            Proxies.removed(this, key, true);\r\n-            Proxies.removed(this, old, false);\r\n-        }\r\n-        return old;\r\n-    }\r\n-\r\n-    protected Object writeReplace() throws ObjectStreamException {\r\n-        if (_sm != null && _sm.isDetached())\r\n-            return this;\r\n-        return copy(this);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.ObjectStreamException;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * <p>Extension of the {@link HashMap} type that dirties the\n+ * persistent/transactional field it is assigned to on modification.\n+ * The need to dirty the field on <b>any</b> modification mandates that\n+ * this class must override all mutator methods of the base type.\n+ * This may lead to multiple calls to <code>dirty</code> for one state\n+ * change if one mutator method of the base type calls another.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ProxyHashMap\n+    extends HashMap\n+    implements ProxyMap {\n+\n+    private transient Class _keyType = null;\n+    private transient Class _valueType = null;\n+    private transient OpenJPAStateManager _sm = null;\n+    private transient int _field = -1;\n+    private transient MapChangeTracker _ct = null;\n+\n+    public ProxyHashMap() {\n+    }\n+\n+    public ProxyHashMap(Class keyType, Class valueType, boolean trackChanges,\n+        OpenJPAConfiguration conf) {\n+        _keyType = keyType;\n+        _valueType = valueType;\n+        if (trackChanges)\n+            _ct = new MapChangeTrackerImpl(this, conf);\n+    }\n+\n+    public void setOwner(OpenJPAStateManager sm, int field) {\n+        _sm = sm;\n+        _field = field;\n+    }\n+\n+    public OpenJPAStateManager getOwner() {\n+        return _sm;\n+    }\n+\n+    public int getOwnerField() {\n+        return _field;\n+    }\n+\n+    public ChangeTracker getChangeTracker() {\n+        return _ct;\n+    }\n+\n+    public Object copy(Object orig) {\n+        return new HashMap((Map) orig);\n+    }\n+\n+    public ProxyMap newInstance(Class keyType, Class valueType,\n+        Comparator compare, boolean trackChanges, OpenJPAConfiguration conf) {\n+        return new ProxyHashMap(keyType, valueType, trackChanges, conf);\n+    }\n+\n+    public void clear() {\n+        Proxies.dirty(this);\n+        if (_ct != null)\n+            _ct.stopTracking();\n+        Map.Entry entry;\n+        for (Iterator itr = super.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            Proxies.removed(this, entry.getKey(), true);\n+            Proxies.removed(this, entry.getValue(), false);\n+        }\n+        super.clear();\n+    }\n+\n+    public Set keySet() {\n+        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_KEY);\n+    }\n+\n+    public Collection values() {\n+        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_VALUE);\n+    }\n+\n+    public Set entrySet() {\n+        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_ENTRY);\n+    }\n+\n+    public Object put(Object key, Object value) {\n+        Proxies.assertAllowedType(key, _keyType);\n+        Proxies.assertAllowedType(value, _valueType);\n+        Proxies.dirty(this);\n+        boolean had = containsKey(key);\n+        Object old = super.put(key, value);\n+        if (had) {\n+            if (_ct != null)\n+                _ct.changed(key, old, value);\n+            Proxies.removed(this, old, false);\n+        } else if (_ct != null)\n+            _ct.added(key, value);\n+        return old;\n+    }\n+\n+    public void putAll(Map m) {\n+        Map.Entry entry;\n+        for (Iterator itr = m.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    public Object remove(Object key) {\n+        Proxies.dirty(this);\n+        boolean had = containsKey(key);\n+        Object old = super.remove(key);\n+        if (had) {\n+            if (_ct != null)\n+                _ct.removed(key, old);\n+            Proxies.removed(this, key, true);\n+            Proxies.removed(this, old, false);\n+        }\n+        return old;\n+    }\n+\n+    protected Object writeReplace()\n+        throws ObjectStreamException {\n+        if (_sm != null && _sm.isDetached())\n+            return this;\n+        return copy(this);\n+    }\n+}"},{"sha":"3d3322601780a04a04b53777c6c8b0225c893fd8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyHashSet.java","status":"modified","additions":146,"deletions":140,"changes":286,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyHashSet.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyHashSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyHashSet.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,140 +1,146 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.util.Collection;\r\n-import java.util.Comparator;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-\r\n-/**\r\n- * Extension of the {@link HashSet} type that dirties the\r\n- * persistent/transactional field it is assigned to on modification.\r\n- * The need to dirty the field on <b>any</b> modification mandates that\r\n- * this class must override all mutator methods of the base type.\r\n- * This may lead to multiple calls to <code>dirty</code> for one state\r\n- * change if one mutator method of the base type calls another.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class ProxyHashSet extends HashSet implements ProxyCollection {\r\n-\r\n-    private transient Class _elementType = null;\r\n-    private transient OpenJPAStateManager _sm = null;\r\n-    private transient int _field = -1;\r\n-    private transient CollectionChangeTracker _ct = null;\r\n-\r\n-    public ProxyHashSet() {\r\n-    }\r\n-\r\n-    public ProxyHashSet(Class elementType, boolean trackChanges,\r\n-        OpenJPAConfiguration conf) {\r\n-        _elementType = elementType;\r\n-        if (trackChanges)\r\n-            _ct = new CollectionChangeTrackerImpl(this, false, false, conf);\r\n-    }\r\n-\r\n-    public void setOwner(OpenJPAStateManager sm, int field) {\r\n-        _sm = sm;\r\n-        _field = field;\r\n-    }\r\n-\r\n-    public OpenJPAStateManager getOwner() {\r\n-        return _sm;\r\n-    }\r\n-\r\n-    public int getOwnerField() {\r\n-        return _field;\r\n-    }\r\n-\r\n-    public ChangeTracker getChangeTracker() {\r\n-        return _ct;\r\n-    }\r\n-\r\n-    public Object copy(Object orig) {\r\n-        return new HashSet((Collection) orig);\r\n-    }\r\n-\r\n-    public ProxyCollection newInstance(Class elementType, Comparator compare,\r\n-        boolean trackChanges, OpenJPAConfiguration conf) {\r\n-        return new ProxyHashSet(elementType, trackChanges, conf);\r\n-    }\r\n-\r\n-    public boolean add(Object value) {\r\n-        Proxies.assertAllowedType(value, _elementType);\r\n-        Proxies.dirty(this);\r\n-        if (super.add(value)) {\r\n-            if (_ct != null)\r\n-                _ct.added(value);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean addAll(Collection values) {\r\n-        boolean added = false;\r\n-        for (Iterator itr = values.iterator(); itr.hasNext();)\r\n-            added = add(itr.next()) || added;\r\n-        return added;\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        Proxies.dirty(this);\r\n-        if (_ct != null)\r\n-            _ct.stopTracking();\r\n-        for (Iterator itr = super.iterator(); itr.hasNext();)\r\n-            Proxies.removed(this, itr.next(), false);\r\n-        super.clear();\r\n-    }\r\n-\r\n-    public Iterator iterator() {\r\n-        return Proxies.iterator(this, super.iterator());\r\n-    }\r\n-\r\n-    public boolean remove(Object o) {\r\n-        Proxies.dirty(this);\r\n-        if (super.remove(o)) {\r\n-            if (_ct != null)\r\n-                _ct.removed(o);\r\n-            Proxies.removed(this, o, false);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean removeAll(Collection c) {\r\n-        boolean removed = false;\r\n-        for (Iterator itr = c.iterator(); itr.hasNext();)\r\n-            removed = remove(itr.next()) || removed;\r\n-        return removed;\r\n-    }\r\n-\r\n-    public boolean retainAll(Collection c) {\r\n-        int size = size();\r\n-        for (Iterator itr = iterator(); itr.hasNext();)\r\n-            if (!c.contains(itr.next()))\r\n-                itr.remove();\r\n-        return size() < size;\r\n-    }\r\n-\r\n-    protected Object writeReplace() throws ObjectStreamException {\r\n-        if (_sm != null && _sm.isDetached())\r\n-            return this;\r\n-        return copy(this);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.ObjectStreamException;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * <p>Extension of the {@link HashSet} type that dirties the\n+ * persistent/transactional field it is assigned to on modification.\n+ * The need to dirty the field on <b>any</b> modification mandates that\n+ * this class must override all mutator methods of the base type.\n+ * This may lead to multiple calls to <code>dirty</code> for one state\n+ * change if one mutator method of the base type calls another.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ProxyHashSet\n+    extends HashSet\n+    implements ProxyCollection {\n+\n+    private transient Class _elementType = null;\n+    private transient OpenJPAStateManager _sm = null;\n+    private transient int _field = -1;\n+    private transient CollectionChangeTracker _ct = null;\n+\n+    public ProxyHashSet() {\n+    }\n+\n+    public ProxyHashSet(Class elementType, boolean trackChanges,\n+        OpenJPAConfiguration conf) {\n+        _elementType = elementType;\n+        if (trackChanges)\n+            _ct = new CollectionChangeTrackerImpl(this, false, false, conf);\n+    }\n+\n+    public void setOwner(OpenJPAStateManager sm, int field) {\n+        _sm = sm;\n+        _field = field;\n+    }\n+\n+    public OpenJPAStateManager getOwner() {\n+        return _sm;\n+    }\n+\n+    public int getOwnerField() {\n+        return _field;\n+    }\n+\n+    public ChangeTracker getChangeTracker() {\n+        return _ct;\n+    }\n+\n+    public Object copy(Object orig) {\n+        return new HashSet((Collection) orig);\n+    }\n+\n+    public ProxyCollection newInstance(Class elementType, Comparator compare,\n+        boolean trackChanges, OpenJPAConfiguration conf) {\n+        return new ProxyHashSet(elementType, trackChanges, conf);\n+    }\n+\n+    public boolean add(Object value) {\n+        Proxies.assertAllowedType(value, _elementType);\n+        Proxies.dirty(this);\n+        if (super.add(value)) {\n+            if (_ct != null)\n+                _ct.added(value);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean addAll(Collection values) {\n+        boolean added = false;\n+        for (Iterator itr = values.iterator(); itr.hasNext();)\n+            added = add(itr.next()) || added;\n+        return added;\n+    }\n+\n+    public void clear() {\n+        Proxies.dirty(this);\n+        if (_ct != null)\n+            _ct.stopTracking();\n+        for (Iterator itr = super.iterator(); itr.hasNext();)\n+            Proxies.removed(this, itr.next(), false);\n+        super.clear();\n+    }\n+\n+    public Iterator iterator() {\n+        return Proxies.iterator(this, super.iterator());\n+    }\n+\n+    public boolean remove(Object o) {\n+        Proxies.dirty(this);\n+        if (super.remove(o)) {\n+            if (_ct != null)\n+                _ct.removed(o);\n+            Proxies.removed(this, o, false);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean removeAll(Collection c) {\n+        boolean removed = false;\n+        for (Iterator itr = c.iterator(); itr.hasNext();)\n+            removed = remove(itr.next()) || removed;\n+        return removed;\n+    }\n+\n+    public boolean retainAll(Collection c) {\n+        int size = size();\n+        for (Iterator itr = iterator(); itr.hasNext();)\n+            if (!c.contains(itr.next()))\n+                itr.remove();\n+        return size() < size;\n+    }\n+\n+    protected Object writeReplace()\n+        throws ObjectStreamException {\n+        if (_sm != null && _sm.isDetached())\n+            return this;\n+        return copy(this);\n+    }\n+}"},{"sha":"4168afef58237d236b538b378786b2ede7b6c81a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyHashtable.java","status":"modified","additions":154,"deletions":148,"changes":302,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyHashtable.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyHashtable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyHashtable.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,148 +1,154 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.util.Collection;\r\n-import java.util.Comparator;\r\n-import java.util.Hashtable;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-\r\n-/**\r\n- * Extension of the {@link Hashtable} type that dirties the\r\n- * persistent/transactional field it is assigned to on modification.\r\n- * The need to dirty the field on <b>any</b> modification mandates that\r\n- * this class must override all mutator methods of the base type.\r\n- * This may lead to multiple calls to <code>dirty</code> for one state\r\n- * change if one mutator method of the base type calls another.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class ProxyHashtable extends Hashtable implements ProxyMap {\r\n-\r\n-    private transient Class _keyType = null;\r\n-    private transient Class _valueType = null;\r\n-    private transient OpenJPAStateManager _sm = null;\r\n-    private transient int _field = -1;\r\n-    private transient MapChangeTracker _ct = null;\r\n-\r\n-    public ProxyHashtable() {\r\n-    }\r\n-\r\n-    public ProxyHashtable(Class keyType, Class valueType, boolean trackChanges,\r\n-        OpenJPAConfiguration conf) {\r\n-        _keyType = keyType;\r\n-        _valueType = valueType;\r\n-        if (trackChanges)\r\n-            _ct = new MapChangeTrackerImpl(this, conf);\r\n-    }\r\n-\r\n-    public void setOwner(OpenJPAStateManager sm, int field) {\r\n-        _sm = sm;\r\n-        _field = field;\r\n-    }\r\n-\r\n-    public OpenJPAStateManager getOwner() {\r\n-        return _sm;\r\n-    }\r\n-\r\n-    public int getOwnerField() {\r\n-        return _field;\r\n-    }\r\n-\r\n-    public ChangeTracker getChangeTracker() {\r\n-        return _ct;\r\n-    }\r\n-\r\n-    public Object copy(Object orig) {\r\n-        return new Hashtable((Map) orig);\r\n-    }\r\n-\r\n-    public ProxyMap newInstance(Class keyType, Class valueType,\r\n-        Comparator compare, boolean trackChanges, OpenJPAConfiguration conf) {\r\n-        return new ProxyHashtable(keyType, valueType, trackChanges, conf);\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        Proxies.dirty(this);\r\n-        if (_ct != null)\r\n-            _ct.stopTracking();\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = super.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            Proxies.removed(this, entry.getKey(), true);\r\n-            Proxies.removed(this, entry.getValue(), false);\r\n-        }\r\n-        super.clear();\r\n-    }\r\n-\r\n-    public Set keySet() {\r\n-        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_KEY);\r\n-    }\r\n-\r\n-    public Collection values() {\r\n-        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_VALUE);\r\n-    }\r\n-\r\n-    public Set entrySet() {\r\n-        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_ENTRY);\r\n-    }\r\n-\r\n-    public Object put(Object key, Object value) {\r\n-        Proxies.assertAllowedType(key, _keyType);\r\n-        Proxies.assertAllowedType(value, _valueType);\r\n-        Proxies.dirty(this);\r\n-        boolean had = containsKey(key);\r\n-        Object old = super.put(key, value);\r\n-        if (had) {\r\n-            if (_ct != null)\r\n-                _ct.changed(key, old, value);\r\n-            Proxies.removed(this, old, false);\r\n-        } else if (_ct != null)\r\n-            _ct.added(key, value);\r\n-        return old;\r\n-    }\r\n-\r\n-    public void putAll(Map m) {\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = m.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            put(entry.getKey(), entry.getValue());\r\n-        }\r\n-    }\r\n-\r\n-    public Object remove(Object key) {\r\n-        Proxies.dirty(this);\r\n-        boolean had = containsKey(key);\r\n-        Object old = super.remove(key);\r\n-        if (had) {\r\n-            if (_ct != null)\r\n-                _ct.removed(key, old);\r\n-            Proxies.removed(this, key, true);\r\n-            Proxies.removed(this, old, false);\r\n-        }\r\n-        return old;\r\n-    }\r\n-\r\n-    protected Object writeReplace() throws ObjectStreamException {\r\n-        if (_sm != null && _sm.isDetached())\r\n-            return this;\r\n-        return copy(this);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.ObjectStreamException;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * <p>Extension of the {@link Hashtable} type that dirties the\n+ * persistent/transactional field it is assigned to on modification.\n+ * The need to dirty the field on <b>any</b> modification mandates that\n+ * this class must override all mutator methods of the base type.\n+ * This may lead to multiple calls to <code>dirty</code> for one state\n+ * change if one mutator method of the base type calls another.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ProxyHashtable\n+    extends Hashtable\n+    implements ProxyMap {\n+\n+    private transient Class _keyType = null;\n+    private transient Class _valueType = null;\n+    private transient OpenJPAStateManager _sm = null;\n+    private transient int _field = -1;\n+    private transient MapChangeTracker _ct = null;\n+\n+    public ProxyHashtable() {\n+    }\n+\n+    public ProxyHashtable(Class keyType, Class valueType, boolean trackChanges,\n+        OpenJPAConfiguration conf) {\n+        _keyType = keyType;\n+        _valueType = valueType;\n+        if (trackChanges)\n+            _ct = new MapChangeTrackerImpl(this, conf);\n+    }\n+\n+    public void setOwner(OpenJPAStateManager sm, int field) {\n+        _sm = sm;\n+        _field = field;\n+    }\n+\n+    public OpenJPAStateManager getOwner() {\n+        return _sm;\n+    }\n+\n+    public int getOwnerField() {\n+        return _field;\n+    }\n+\n+    public ChangeTracker getChangeTracker() {\n+        return _ct;\n+    }\n+\n+    public Object copy(Object orig) {\n+        return new Hashtable((Map) orig);\n+    }\n+\n+    public ProxyMap newInstance(Class keyType, Class valueType,\n+        Comparator compare, boolean trackChanges, OpenJPAConfiguration conf) {\n+        return new ProxyHashtable(keyType, valueType, trackChanges, conf);\n+    }\n+\n+    public void clear() {\n+        Proxies.dirty(this);\n+        if (_ct != null)\n+            _ct.stopTracking();\n+        Map.Entry entry;\n+        for (Iterator itr = super.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            Proxies.removed(this, entry.getKey(), true);\n+            Proxies.removed(this, entry.getValue(), false);\n+        }\n+        super.clear();\n+    }\n+\n+    public Set keySet() {\n+        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_KEY);\n+    }\n+\n+    public Collection values() {\n+        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_VALUE);\n+    }\n+\n+    public Set entrySet() {\n+        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_ENTRY);\n+    }\n+\n+    public Object put(Object key, Object value) {\n+        Proxies.assertAllowedType(key, _keyType);\n+        Proxies.assertAllowedType(value, _valueType);\n+        Proxies.dirty(this);\n+        boolean had = containsKey(key);\n+        Object old = super.put(key, value);\n+        if (had) {\n+            if (_ct != null)\n+                _ct.changed(key, old, value);\n+            Proxies.removed(this, old, false);\n+        } else if (_ct != null)\n+            _ct.added(key, value);\n+        return old;\n+    }\n+\n+    public void putAll(Map m) {\n+        Map.Entry entry;\n+        for (Iterator itr = m.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    public Object remove(Object key) {\n+        Proxies.dirty(this);\n+        boolean had = containsKey(key);\n+        Object old = super.remove(key);\n+        if (had) {\n+            if (_ct != null)\n+                _ct.removed(key, old);\n+            Proxies.removed(this, key, true);\n+            Proxies.removed(this, old, false);\n+        }\n+        return old;\n+    }\n+\n+    protected Object writeReplace()\n+        throws ObjectStreamException {\n+        if (_sm != null && _sm.isDetached())\n+            return this;\n+        return copy(this);\n+    }\n+}"},{"sha":"e8688db9dc5f85d54c074f5a9145cd8b7d133fe3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyLinkedList.java","status":"modified","additions":224,"deletions":218,"changes":442,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyLinkedList.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyLinkedList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyLinkedList.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,218 +1,224 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.util.Collection;\r\n-import java.util.Comparator;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.ListIterator;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-\r\n-/**\r\n- * Extension of the {@link LinkedList} type that dirties the\r\n- * persistent/transactional field it is assigned to on modification.\r\n- * The need to dirty the field on <b>any</b> modification mandates that\r\n- * this class must override all mutator methods of the base type.\r\n- * This may lead to multiple calls to <code>dirty</code> for one state\r\n- * change if one mutator method of the base type calls another.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class ProxyLinkedList extends LinkedList implements ProxyCollection {\r\n-\r\n-    private transient Class _elementType = null;\r\n-    private transient OpenJPAStateManager _sm = null;\r\n-    private transient int _field = -1;\r\n-    private transient CollectionChangeTracker _ct = null;\r\n-\r\n-    public ProxyLinkedList() {\r\n-    }\r\n-\r\n-    public ProxyLinkedList(Class elementType, boolean trackChanges,\r\n-        OpenJPAConfiguration conf) {\r\n-        _elementType = elementType;\r\n-        if (trackChanges)\r\n-            _ct = new CollectionChangeTrackerImpl(this, true, true, conf);\r\n-    }\r\n-\r\n-    public void setOwner(OpenJPAStateManager sm, int field) {\r\n-        _sm = sm;\r\n-        _field = field;\r\n-    }\r\n-\r\n-    public OpenJPAStateManager getOwner() {\r\n-        return _sm;\r\n-    }\r\n-\r\n-    public int getOwnerField() {\r\n-        return _field;\r\n-    }\r\n-\r\n-    public ChangeTracker getChangeTracker() {\r\n-        return _ct;\r\n-    }\r\n-\r\n-    public Object copy(Object orig) {\r\n-        return new LinkedList((Collection) orig);\r\n-    }\r\n-\r\n-    public ProxyCollection newInstance(Class elementType, Comparator compare,\r\n-        boolean trackChanges, OpenJPAConfiguration conf) {\r\n-        return new ProxyLinkedList(elementType, trackChanges, conf);\r\n-    }\r\n-\r\n-    public void add(int index, Object value) {\r\n-        Proxies.assertAllowedType(value, _elementType);\r\n-        Proxies.dirty(this);\r\n-        if (_ct != null)\r\n-            _ct.stopTracking();\r\n-        super.add(index, value);\r\n-    }\r\n-\r\n-    public boolean add(Object value) {\r\n-        Proxies.assertAllowedType(value, _elementType);\r\n-        Proxies.dirty(this);\r\n-        if (super.add(value)) {\r\n-            if (_ct != null)\r\n-                _ct.added(value);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public void addFirst(Object value) {\r\n-        Proxies.assertAllowedType(value, _elementType);\r\n-        Proxies.dirty(this);\r\n-        super.addFirst(value);\r\n-        if (_ct != null)\r\n-            _ct.stopTracking();\r\n-    }\r\n-\r\n-    public void addLast(Object value) {\r\n-        Proxies.assertAllowedType(value, _elementType);\r\n-        Proxies.dirty(this);\r\n-        super.addLast(value);\r\n-        if (_ct != null)\r\n-            _ct.added(value);\r\n-    }\r\n-\r\n-    public boolean addAll(int index, Collection values) {\r\n-        for (Iterator itr = values.iterator(); itr.hasNext(); index++)\r\n-            add(index, itr.next());\r\n-        return values.size() > 0;\r\n-    }\r\n-\r\n-    public boolean addAll(Collection values) {\r\n-        boolean added = false;\r\n-        for (Iterator itr = values.iterator(); itr.hasNext();)\r\n-            added = add(itr.next()) || added;\r\n-        return added;\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        Proxies.dirty(this);\r\n-        if (_ct != null)\r\n-            _ct.stopTracking();\r\n-        for (Iterator itr = super.iterator(); itr.hasNext();)\r\n-            Proxies.removed(this, itr.next(), false);\r\n-        super.clear();\r\n-    }\r\n-\r\n-    public Iterator iterator() {\r\n-        return Proxies.iterator(this, super.iterator());\r\n-    }\r\n-\r\n-    public ListIterator listIterator() {\r\n-        return Proxies.listIterator(this, super.listIterator(), _elementType);\r\n-    }\r\n-\r\n-    public ListIterator listIterator(int index) {\r\n-        return Proxies.listIterator(this, super.listIterator(index),\r\n-            _elementType);\r\n-    }\r\n-\r\n-    public Object remove(int index) {\r\n-        Proxies.dirty(this);\r\n-        Object rem = super.remove(index);\r\n-        if (_ct != null)\r\n-            _ct.removed(rem);\r\n-        Proxies.removed(this, rem, false);\r\n-        return rem;\r\n-    }\r\n-\r\n-    public boolean remove(Object o) {\r\n-        Proxies.dirty(this);\r\n-        if (super.remove(o)) {\r\n-            if (_ct != null)\r\n-                _ct.removed(o);\r\n-            Proxies.removed(this, o, false);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Object removeFirst() {\r\n-        Proxies.dirty(this);\r\n-        Object rem = super.removeFirst();\r\n-        if (_ct != null)\r\n-            _ct.removed(rem);\r\n-        Proxies.removed(this, rem, false);\r\n-        return rem;\r\n-    }\r\n-\r\n-    public Object removeLast() {\r\n-        Proxies.dirty(this);\r\n-        Object rem = super.removeLast();\r\n-        if (_ct != null)\r\n-            _ct.removed(rem);\r\n-        Proxies.removed(this, rem, false);\r\n-        return rem;\r\n-    }\r\n-\r\n-    public boolean removeAll(Collection c) {\r\n-        boolean removed = false;\r\n-        for (Iterator itr = c.iterator(); itr.hasNext();)\r\n-            removed = remove(itr.next()) || removed;\r\n-        return removed;\r\n-    }\r\n-\r\n-    public boolean retainAll(Collection c) {\r\n-        int size = size();\r\n-        for (Iterator itr = iterator(); itr.hasNext();)\r\n-            if (!c.contains(itr.next()))\r\n-                itr.remove();\r\n-        return size() < size;\r\n-    }\r\n-\r\n-    public Object set(int index, Object element) {\r\n-        Proxies.assertAllowedType(element, _elementType);\r\n-        Proxies.dirty(this);\r\n-        if (_ct != null)\r\n-            _ct.stopTracking();\r\n-        Object rem = super.set(index, element);\r\n-        if (rem != element)\r\n-            Proxies.removed(this, rem, false);\r\n-        return rem;\r\n-    }\r\n-\r\n-    protected Object writeReplace() throws ObjectStreamException {\r\n-        if (_sm != null && _sm.isDetached())\r\n-            return this;\r\n-        return copy(this);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.ObjectStreamException;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.ListIterator;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * <p>Extension of the {@link LinkedList} type that dirties the\n+ * persistent/transactional field it is assigned to on modification.\n+ * The need to dirty the field on <b>any</b> modification mandates that\n+ * this class must override all mutator methods of the base type.\n+ * This may lead to multiple calls to <code>dirty</code> for one state\n+ * change if one mutator method of the base type calls another.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ProxyLinkedList\n+    extends LinkedList\n+    implements ProxyCollection {\n+\n+    private transient Class _elementType = null;\n+    private transient OpenJPAStateManager _sm = null;\n+    private transient int _field = -1;\n+    private transient CollectionChangeTracker _ct = null;\n+\n+    public ProxyLinkedList() {\n+    }\n+\n+    public ProxyLinkedList(Class elementType, boolean trackChanges,\n+        OpenJPAConfiguration conf) {\n+        _elementType = elementType;\n+        if (trackChanges)\n+            _ct = new CollectionChangeTrackerImpl(this, true, true, conf);\n+    }\n+\n+    public void setOwner(OpenJPAStateManager sm, int field) {\n+        _sm = sm;\n+        _field = field;\n+    }\n+\n+    public OpenJPAStateManager getOwner() {\n+        return _sm;\n+    }\n+\n+    public int getOwnerField() {\n+        return _field;\n+    }\n+\n+    public ChangeTracker getChangeTracker() {\n+        return _ct;\n+    }\n+\n+    public Object copy(Object orig) {\n+        return new LinkedList((Collection) orig);\n+    }\n+\n+    public ProxyCollection newInstance(Class elementType, Comparator compare,\n+        boolean trackChanges, OpenJPAConfiguration conf) {\n+        return new ProxyLinkedList(elementType, trackChanges, conf);\n+    }\n+\n+    public void add(int index, Object value) {\n+        Proxies.assertAllowedType(value, _elementType);\n+        Proxies.dirty(this);\n+        if (_ct != null)\n+            _ct.stopTracking();\n+        super.add(index, value);\n+    }\n+\n+    public boolean add(Object value) {\n+        Proxies.assertAllowedType(value, _elementType);\n+        Proxies.dirty(this);\n+        if (super.add(value)) {\n+            if (_ct != null)\n+                _ct.added(value);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public void addFirst(Object value) {\n+        Proxies.assertAllowedType(value, _elementType);\n+        Proxies.dirty(this);\n+        super.addFirst(value);\n+        if (_ct != null)\n+            _ct.stopTracking();\n+    }\n+\n+    public void addLast(Object value) {\n+        Proxies.assertAllowedType(value, _elementType);\n+        Proxies.dirty(this);\n+        super.addLast(value);\n+        if (_ct != null)\n+            _ct.added(value);\n+    }\n+\n+    public boolean addAll(int index, Collection values) {\n+        for (Iterator itr = values.iterator(); itr.hasNext(); index++)\n+            add(index, itr.next());\n+        return values.size() > 0;\n+    }\n+\n+    public boolean addAll(Collection values) {\n+        boolean added = false;\n+        for (Iterator itr = values.iterator(); itr.hasNext();)\n+            added = add(itr.next()) || added;\n+        return added;\n+    }\n+\n+    public void clear() {\n+        Proxies.dirty(this);\n+        if (_ct != null)\n+            _ct.stopTracking();\n+        for (Iterator itr = super.iterator(); itr.hasNext();)\n+            Proxies.removed(this, itr.next(), false);\n+        super.clear();\n+    }\n+\n+    public Iterator iterator() {\n+        return Proxies.iterator(this, super.iterator());\n+    }\n+\n+    public ListIterator listIterator() {\n+        return Proxies.listIterator(this, super.listIterator(), _elementType);\n+    }\n+\n+    public ListIterator listIterator(int index) {\n+        return Proxies.listIterator(this, super.listIterator(index),\n+            _elementType);\n+    }\n+\n+    public Object remove(int index) {\n+        Proxies.dirty(this);\n+        Object rem = super.remove(index);\n+        if (_ct != null)\n+            _ct.removed(rem);\n+        Proxies.removed(this, rem, false);\n+        return rem;\n+    }\n+\n+    public boolean remove(Object o) {\n+        Proxies.dirty(this);\n+        if (super.remove(o)) {\n+            if (_ct != null)\n+                _ct.removed(o);\n+            Proxies.removed(this, o, false);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public Object removeFirst() {\n+        Proxies.dirty(this);\n+        Object rem = super.removeFirst();\n+        if (_ct != null)\n+            _ct.removed(rem);\n+        Proxies.removed(this, rem, false);\n+        return rem;\n+    }\n+\n+    public Object removeLast() {\n+        Proxies.dirty(this);\n+        Object rem = super.removeLast();\n+        if (_ct != null)\n+            _ct.removed(rem);\n+        Proxies.removed(this, rem, false);\n+        return rem;\n+    }\n+\n+    public boolean removeAll(Collection c) {\n+        boolean removed = false;\n+        for (Iterator itr = c.iterator(); itr.hasNext();)\n+            removed = remove(itr.next()) || removed;\n+        return removed;\n+    }\n+\n+    public boolean retainAll(Collection c) {\n+        int size = size();\n+        for (Iterator itr = iterator(); itr.hasNext();)\n+            if (!c.contains(itr.next()))\n+                itr.remove();\n+        return size() < size;\n+    }\n+\n+    public Object set(int index, Object element) {\n+        Proxies.assertAllowedType(element, _elementType);\n+        Proxies.dirty(this);\n+        if (_ct != null)\n+            _ct.stopTracking();\n+        Object rem = super.set(index, element);\n+        if (rem != element)\n+            Proxies.removed(this, rem, false);\n+        return rem;\n+    }\n+\n+    protected Object writeReplace()\n+        throws ObjectStreamException {\n+        if (_sm != null && _sm.isDetached())\n+            return this;\n+        return copy(this);\n+    }\n+}"},{"sha":"0824985e2d3460feac71db474da76f0b5bc141c1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManager.java","status":"modified","additions":119,"deletions":116,"changes":235,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,116 +1,119 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.util.Calendar;\r\n-import java.util.Collection;\r\n-import java.util.Comparator;\r\n-import java.util.Date;\r\n-import java.util.Map;\r\n-import java.util.TimeZone;\r\n-\r\n-/**\r\n- * Manager for copying and proxying second class objects. Second class\r\n- * objects are those that are often used as fields of persistent or\r\n- * transactional instances, and which can themselves be modified without\r\n- * resetting the owning class' field. Because these types can change without\r\n- * an explicit call to the owning persistence capable instance, special care\r\n- * must be taken to ensure that their state is managed correctly.\r\n- * Specifically, they must be copied when saving state for rollback, and they\r\n- * must be proxied for any instance whose state is managed by a state manager,\r\n- * where proxying involves creating a second class object that automaticlly\r\n- * notifies its owning instance whenever it is modified. Generally, this\r\n- * factory is only used by the implementation; second class object handling\r\n- * is transparent to client code.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public interface ProxyManager {\r\n-\r\n-    /**\r\n-     * Return a copy of the given date with the same information.\r\n-     */\r\n-    public Date copyDate(Date orig);\r\n-\r\n-    /**\r\n-     * Return a copy of the given Calendar with the same information.\r\n-     */\r\n-    public Calendar copyCalendar(Calendar orig);\r\n-\r\n-    /**\r\n-     * Return a new collection of the same type as the given one\r\n-     * with a copy of all contained elements.\r\n-     * If the given owner is non-null, the returned value should be a proxy\r\n-     * for the given owner, otherwise it should not be a proxy.\r\n-     */\r\n-    public Collection copyCollection(Collection orig);\r\n-\r\n-    /**\r\n-     * Return a new map of the same type as the given one\r\n-     * with a copy of all contained key/value pairs.\r\n-     * If the given owner is non-null, the returned value should be a proxy\r\n-     * for the given owner, otherwise it should not be a proxy.\r\n-     */\r\n-    public Map copyMap(Map orig);\r\n-\r\n-    /**\r\n-     * Return a new array of the same component type as the given array\r\n-     * and containing the same elements. Works for both primitive and\r\n-     * object array types.\r\n-     */\r\n-    public Object copyArray(Object orig);\r\n-\r\n-    /**\r\n-     * Return a copy of the given object with the same\r\n-     * information. If this manager cannot proxy the given type, return null.\r\n-     * If the given owner is non-null, the returned value should be a proxy\r\n-     * for the given owner, otherwise it should not be a proxy.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public Object copyCustom(Object orig);\r\n-\r\n-    /**\r\n-     * Return a new date proxy.\r\n-     */\r\n-    public Proxy newDateProxy(Class type);\r\n-\r\n-    /**\r\n-     * Return a new calendar proxy.\r\n-     */\r\n-    public Proxy newCalendarProxy(Class type, TimeZone timeZone);\r\n-\r\n-    /**\r\n-     * Return a proxy for the given collection type. The returned collection\r\n-     * will allow only addition of elements assignable from the given\r\n-     * element type and will use the given comparator, if it is not null.\r\n-     */\r\n-    public Proxy newCollectionProxy(Class type, Class elementType,\r\n-        Comparator compare);\r\n-\r\n-    /**\r\n-     * Return a proxy for the given map type. The returned map will\r\n-     * allow only addition of keys/values assignable from the given\r\n-     * keyType/valueType, and will use the given comparator, if it is not null.\r\n-     */\r\n-    public Proxy newMapProxy(Class type, Class keyType, Class valueType,\r\n-        Comparator compare);\r\n-\r\n-    /**\r\n-     * Return a proxy for the given object, or null if this manager cannot\r\n-     * proxy the object.\r\n-     *\r\n-     * @since 2.5\r\n-     */\r\n-    public Proxy newCustomProxy(Object obj);\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.TimeZone;\n+\n+/**\n+ * <p>Manager for copying and proxying second class objects.  Second class\n+ * objects are those that are often used as fields of persistent or\n+ * transactional instances, and which can themselves be modified without\n+ * resetting the owning class' field.  Because these types can change without\n+ * an explicit call to the owning persistence capable instance, special care\n+ * must be taken to ensure that their state is managed correctly.\n+ * Specifically, they must be copied when saving state for rollback, and they\n+ * must be proxied for any instance whose state is managed by a state manager,\n+ * where proxying involves creating a second class object that automaticlly\n+ * notifies its owning instance whenever it is modified.  Generally, this\n+ * factory is only used by the implementation; second class object handling\n+ * is transparent to client code.</p>\n+ *\n+ * @author Abe White\n+ */\n+public interface ProxyManager {\n+\n+    /**\n+     * Return a copy of the given date with the same information.\n+     */\n+    public Date copyDate(Date orig);\n+\n+    /**\n+     * Return a copy of the given Calendar with the same information.\n+     */\n+    public Calendar copyCalendar(Calendar orig);\n+\n+    /**\n+     * Return a new collection of the same type as the given one\n+     * with a copy of all contained elements.\n+     * If the given owner is non-null, the returned value should be a proxy\n+     * for the given owner, otherwise it should not be a proxy.\n+     */\n+    public Collection copyCollection(Collection orig);\n+\n+    /**\n+     * Return a new map of the same type as the given one\n+     * with a copy of all contained key/value pairs.\n+     * If the given owner is non-null, the returned value should be a proxy\n+     * for the given owner, otherwise it should not be a proxy.\n+     */\n+    public Map copyMap(Map orig);\n+\n+    /**\n+     * Return a new array of the same component type as the given array\n+     * and containing the same elements.  Works for both primitive and\n+     * object array types.\n+     */\n+    public Object copyArray(Object orig);\n+\n+    /**\n+     * Return a copy of the given object with the same\n+     * information. If this manager cannot proxy the given type, return null.\n+     * If the given owner is non-null, the returned value should be a proxy\n+     * for the given owner, otherwise it should not be a proxy.\n+     *\n+     * @since 2.5\n+     */\n+    public Object copyCustom(Object orig);\n+\n+    /**\n+     * Return a new date proxy.\n+     */\n+    public Proxy newDateProxy(Class type);\n+\n+    /**\n+     * Return a new calendar proxy.\n+     */\n+    public Proxy newCalendarProxy(Class type, TimeZone timeZone);\n+\n+    /**\n+     * Return a proxy for the given collection type.  The returned collection\n+     * will allow only addition of elements assignable from the given\n+     * element type and will use the given comparator, if it is not null.\n+     */\n+    public Proxy newCollectionProxy(Class type, Class elementType,\n+        Comparator compare);\n+\n+    /**\n+     * Return a proxy for the given map type.  The returned map will\n+     * allow only addition of keys/values assignable from the given\n+     * keyType/valueType, and will use the given comparator, if it is not null.\n+     */\n+    public Proxy newMapProxy(Class type, Class keyType, Class valueType,\n+        Comparator compare);\n+\n+    /**\n+     *\tReturn a proxy for the given object, or null if this manager cannot\n+     *\tproxy the object.\n+     *\n+     *\t@since 2.5\n+     */\n+    public Proxy newCustomProxy (Object obj);\n+}"},{"sha":"bc28564537d6c404d77740f244ccf558fdf4c2fb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","status":"modified","additions":298,"deletions":282,"changes":580,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,282 +1,298 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.lang.reflect.Array;\r\n-import java.util.ArrayList;\r\n-import java.util.Calendar;\r\n-import java.util.Collection;\r\n-import java.util.Comparator;\r\n-import java.util.Date;\r\n-import java.util.GregorianCalendar;\r\n-import java.util.HashMap;\r\n-import java.util.HashSet;\r\n-import java.util.Hashtable;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Properties;\r\n-import java.util.Set;\r\n-import java.util.SortedMap;\r\n-import java.util.SortedSet;\r\n-import java.util.TimeZone;\r\n-import java.util.TreeMap;\r\n-import java.util.TreeSet;\r\n-import java.util.Vector;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.util.JavaVersions;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\r\n-\r\n-/**\r\n- * Default implementation of the {@link ProxyManager} interface.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public class ProxyManagerImpl implements ProxyManager, Configurable {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (ProxyManagerImpl.class);\r\n-    // date proxy cache\r\n-    private static final Map _dates = new HashMap();\r\n-\r\n-    static {\r\n-        _dates.put(Date.class, new ProxyUtilDate());\r\n-        _dates.put(java.sql.Date.class, new ProxySQLDate());\r\n-        _dates.put(java.sql.Timestamp.class, new ProxyTimestamp());\r\n-        _dates.put(java.sql.Time.class, new ProxyTime());\r\n-    }\r\n-\r\n-    // calendar proxy cache\r\n-    private static final Map _calendars = new HashMap();\r\n-\r\n-    static {\r\n-        ProxyGregorianCalendar cal = new ProxyGregorianCalendar();\r\n-        try {\r\n-            cal = (ProxyGregorianCalendar) JavaVersions.\r\n-                getVersionSpecificClass(ProxyGregorianCalendar.class).\r\n-                newInstance();\r\n-        } catch (Exception e) {\r\n-        }\r\n-        _calendars.put(Calendar.class, cal);\r\n-        _calendars.put(GregorianCalendar.class, cal);\r\n-    }\r\n-\r\n-    // standard collection proxy cache\r\n-    private static final Map _stdCollections = new HashMap();\r\n-\r\n-    static {\r\n-        ProxyArrayList listTempl = new ProxyArrayList();\r\n-        ProxyHashSet setTempl = new ProxyHashSet();\r\n-        ProxyTreeSet sortedSetTempl = new ProxyTreeSet();\r\n-        _stdCollections.put(Collection.class, listTempl);\r\n-        _stdCollections.put(Set.class, setTempl);\r\n-        _stdCollections.put(SortedSet.class, sortedSetTempl);\r\n-        _stdCollections.put(List.class, listTempl);\r\n-        _stdCollections.put(ArrayList.class, listTempl);\r\n-        _stdCollections.put(LinkedList.class, new ProxyLinkedList());\r\n-        _stdCollections.put(Vector.class, new ProxyVector());\r\n-        _stdCollections.put(HashSet.class, setTempl);\r\n-        _stdCollections.put(TreeSet.class, sortedSetTempl);\r\n-    }\r\n-\r\n-    // standard map proxy cache\r\n-    private static final Map _stdMaps = new HashMap();\r\n-\r\n-    static {\r\n-        ProxyHashMap mapTempl = new ProxyHashMap();\r\n-        ProxyTreeMap sortedMapTempl = new ProxyTreeMap();\r\n-        _stdMaps.put(Map.class, mapTempl);\r\n-        _stdMaps.put(SortedMap.class, sortedMapTempl);\r\n-        _stdMaps.put(HashMap.class, mapTempl);\r\n-        _stdMaps.put(TreeMap.class, sortedMapTempl);\r\n-        _stdMaps.put(Hashtable.class, new ProxyHashtable());\r\n-        _stdMaps.put(Properties.class, new ProxyProperties());\r\n-    }\r\n-\r\n-    // allow subclasses to manipulate collection and map templates\r\n-    private final Map _collections = new ConcurrentHashMap(_stdCollections);\r\n-    private final Map _maps = new ConcurrentHashMap(_stdMaps);\r\n-    protected OpenJPAConfiguration conf = null;\r\n-    private boolean _trackChanges = true;\r\n-    private boolean _assertType = false;\r\n-\r\n-    /**\r\n-     * Whether proxies produced by this factory will use {@link ChangeTracker}s\r\n-     * to try to cut down on data store operations at the cost of some extra\r\n-     * bookkeeping overhead. Defaults to true.\r\n-     */\r\n-    public boolean getTrackChanges() {\r\n-        return _trackChanges;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether proxies produced by this factory will use {@link ChangeTracker}s\r\n-     * to try to cut down on data store operations at the cost of some extra\r\n-     * bookkeeping overhead. Defaults to true.\r\n-     */\r\n-    public void setTrackChanges(boolean track) {\r\n-        _trackChanges = track;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to perform runtime checks to ensure that all elements\r\n-     * added to collection and map proxies are the proper element/key/value\r\n-     * type as defined by the metadata. Defaults to false.\r\n-     */\r\n-    public boolean getAssertAllowedType() {\r\n-        return _assertType;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether to perform runtime checks to ensure that all elements\r\n-     * added to collection and map proxies are the proper element/key/value\r\n-     * type as defined by the metadata. Defaults to false.\r\n-     */\r\n-    public void setAssertAllowedType(boolean assertType) {\r\n-        _assertType = assertType;\r\n-    }\r\n-\r\n-    public Date copyDate(Date orig) {\r\n-        return (Date) copy(orig, _dates);\r\n-    }\r\n-\r\n-    public Calendar copyCalendar(Calendar orig) {\r\n-        return (Calendar) copy(orig, _calendars);\r\n-    }\r\n-\r\n-    public Collection copyCollection(Collection orig) {\r\n-        return (Collection) copy(orig, _collections);\r\n-    }\r\n-\r\n-    public Map copyMap(Map orig) {\r\n-        return (Map) copy(orig, _maps);\r\n-    }\r\n-\r\n-    /**\r\n-     * Internal helper to copy value.\r\n-     */\r\n-    private static Object copy(Object orig, Map proxies) {\r\n-        if (orig == null)\r\n-            return null;\r\n-        if (orig instanceof Proxy)\r\n-            return ((Proxy) orig).copy(orig);\r\n-        Class type = orig.getClass();\r\n-        Proxy proxy = (Proxy) proxies.get(type);\r\n-        if (proxy == null)\r\n-            throw new UnsupportedException(_loc.get(\"bad-proxy\", type));\r\n-        return proxy.copy(orig);\r\n-    }\r\n-\r\n-    public Object copyArray(Object orig) {\r\n-        if (orig == null)\r\n-            return null;\r\n-        try {\r\n-            int length = Array.getLength(orig);\r\n-            Object array = Array.newInstance(orig.getClass().\r\n-                getComponentType(), length);\r\n-            System.arraycopy(orig, 0, array, 0, length);\r\n-            return array;\r\n-        } catch (Exception e) {\r\n-            throw new UnsupportedException(_loc.get(\"bad-array\",\r\n-                e.getMessage()), e);\r\n-        }\r\n-    }\r\n-\r\n-    public Object copyCustom(Object orig) {\r\n-        if (!(orig instanceof Proxy))\r\n-            return null;\r\n-        return ((Proxy) orig).copy(orig);\r\n-    }\r\n-\r\n-    public Proxy newDateProxy(Class type) {\r\n-        ProxyDate pd = (ProxyDate) findProxy(type, ProxyDate.class, _dates);\r\n-        return pd.newInstance();\r\n-    }\r\n-\r\n-    public Proxy newCalendarProxy(Class type, TimeZone timeZone) {\r\n-        ProxyCalendar pc = (ProxyCalendar) findProxy(type,\r\n-            ProxyCalendar.class, _calendars);\r\n-        return pc.newInstance(timeZone);\r\n-    }\r\n-\r\n-    public Proxy newCollectionProxy(Class type, Class elementType,\r\n-        Comparator compare) {\r\n-        ProxyCollection pc = (ProxyCollection) findProxy(type,\r\n-            ProxyCollection.class, _collections);\r\n-        if (!_assertType)\r\n-            elementType = null;\r\n-        return pc.newInstance(elementType, compare, _trackChanges, conf);\r\n-    }\r\n-\r\n-    public Proxy newMapProxy(Class type, Class keyType, Class valueType,\r\n-        Comparator compare) {\r\n-        ProxyMap pm = (ProxyMap) findProxy(type, ProxyMap.class, _maps);\r\n-        if (!_assertType) {\r\n-            keyType = null;\r\n-            valueType = null;\r\n-        }\r\n-        return pm.newInstance(keyType, valueType, compare, _trackChanges, conf);\r\n-    }\r\n-\r\n-    /**\r\n-     * Helper method to find an existing proxy for the given type.\r\n-     */\r\n-    private static Proxy findProxy(Class type, Class proxyType, Map proxies) {\r\n-        Proxy p = (Proxy) proxies.get(type);\r\n-        if (p == null) {\r\n-            // check for custom proxy\r\n-            if (proxyType.isAssignableFrom(type)) {\r\n-                try {\r\n-                    p = (Proxy) type.newInstance();\r\n-                    proxies.put(type, p);\r\n-                } catch (Exception e) {\r\n-                    throw new UnsupportedException(_loc.get(\"no-proxy-cons\",\r\n-                        type), e);\r\n-                }\r\n-            } else throw new UnsupportedException(_loc.get(\"bad-proxy\", type));\r\n-        }\r\n-        return p;\r\n-    }\r\n-\r\n-    public Proxy newCustomProxy(Object obj) {\r\n-        return (obj instanceof Proxy) ? (Proxy) obj : null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Add a supported proxy collection type.\r\n-     */\r\n-    protected void setProxyTemplate(Class collType, ProxyCollection proxy) {\r\n-        _collections.put(collType, proxy);\r\n-    }\r\n-\r\n-    /**\r\n-     * Add a supported proxy map type.\r\n-     */\r\n-    protected void setProxyTemplate(Class mapType, ProxyMap proxy) {\r\n-        _maps.put(mapType, proxy);\r\n-    }\r\n-\r\n-    public void setConfiguration(Configuration conf) {\r\n-        this.conf = (OpenJPAConfiguration) conf;\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TimeZone;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.Vector;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.util.JavaVersions;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * <p>Default implementation of the {@link ProxyManager} interface.</p>\n+ *\n+ * @author Abe White\n+ */\n+public class ProxyManagerImpl\n+    implements ProxyManager, Configurable {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ProxyManagerImpl.class);\n+\n+    // date proxy cache\n+    private static final Map _dates = new HashMap();\n+\n+    static {\n+        _dates.put(Date.class, new ProxyUtilDate());\n+        _dates.put(java.sql.Date.class, new ProxySQLDate());\n+        _dates.put(java.sql.Timestamp.class, new ProxyTimestamp());\n+        _dates.put(java.sql.Time.class, new ProxyTime());\n+    }\n+\n+    // calendar proxy cache\n+    private static final Map _calendars = new HashMap();\n+\n+    static {\n+        ProxyGregorianCalendar cal = new ProxyGregorianCalendar();\n+        try {\n+            cal = (ProxyGregorianCalendar) JavaVersions.\n+                getVersionSpecificClass(ProxyGregorianCalendar.class).\n+                newInstance();\n+        }\n+        catch (Exception e) {\n+        }\n+\n+        _calendars.put(Calendar.class, cal);\n+        _calendars.put(GregorianCalendar.class, cal);\n+    }\n+\n+    // standard collection proxy cache\n+    private static final Map _stdCollections = new HashMap();\n+\n+    static {\n+        ProxyArrayList listTempl = new ProxyArrayList();\n+        ProxyHashSet setTempl = new ProxyHashSet();\n+        ProxyTreeSet sortedSetTempl = new ProxyTreeSet();\n+        _stdCollections.put(Collection.class, listTempl);\n+        _stdCollections.put(Set.class, setTempl);\n+        _stdCollections.put(SortedSet.class, sortedSetTempl);\n+        _stdCollections.put(List.class, listTempl);\n+        _stdCollections.put(ArrayList.class, listTempl);\n+        _stdCollections.put(LinkedList.class, new ProxyLinkedList());\n+        _stdCollections.put(Vector.class, new ProxyVector());\n+        _stdCollections.put(HashSet.class, setTempl);\n+        _stdCollections.put(TreeSet.class, sortedSetTempl);\n+    }\n+\n+    // standard map proxy cache\n+    private static final Map _stdMaps = new HashMap();\n+\n+    static {\n+        ProxyHashMap mapTempl = new ProxyHashMap();\n+        ProxyTreeMap sortedMapTempl = new ProxyTreeMap();\n+        _stdMaps.put(Map.class, mapTempl);\n+        _stdMaps.put(SortedMap.class, sortedMapTempl);\n+        _stdMaps.put(HashMap.class, mapTempl);\n+        _stdMaps.put(TreeMap.class, sortedMapTempl);\n+        _stdMaps.put(Hashtable.class, new ProxyHashtable());\n+        _stdMaps.put(Properties.class, new ProxyProperties());\n+    }\n+\n+    // allow subclasses to manipulate collection and map templates\n+    private final Map _collections = new ConcurrentHashMap(_stdCollections);\n+    private final Map _maps = new ConcurrentHashMap(_stdMaps);\n+\n+    protected OpenJPAConfiguration conf = null;\n+    private boolean _trackChanges = true;\n+    private boolean _assertType = false;\n+\n+    /**\n+     * Whether proxies produced by this factory will use {@link ChangeTracker}s\n+     * to try to cut down on data store operations at the cost of some extra\n+     * bookkeeping overhead.  Defaults to true.\n+     */\n+    public boolean getTrackChanges() {\n+        return _trackChanges;\n+    }\n+\n+    /**\n+     * Whether proxies produced by this factory will use {@link ChangeTracker}s\n+     * to try to cut down on data store operations at the cost of some extra\n+     * bookkeeping overhead.  Defaults to true.\n+     */\n+    public void setTrackChanges(boolean track) {\n+        _trackChanges = track;\n+    }\n+\n+    /**\n+     * Whether to perform runtime checks to ensure that all elements\n+     * added to collection and map proxies are the proper element/key/value\n+     * type as defined by the metadata.  Defaults to false.\n+     */\n+    public boolean getAssertAllowedType() {\n+        return _assertType;\n+    }\n+\n+    /**\n+     * Whether to perform runtime checks to ensure that all elements\n+     * added to collection and map proxies are the proper element/key/value\n+     * type as defined by the metadata.  Defaults to false.\n+     */\n+    public void setAssertAllowedType(boolean assertType) {\n+        _assertType = assertType;\n+    }\n+\n+    public Date copyDate(Date orig) {\n+        return (Date) copy(orig, _dates);\n+    }\n+\n+    public Calendar copyCalendar(Calendar orig) {\n+        return (Calendar) copy(orig, _calendars);\n+    }\n+\n+    public Collection copyCollection(Collection orig) {\n+        return (Collection) copy(orig, _collections);\n+    }\n+\n+    public Map copyMap(Map orig) {\n+        return (Map) copy(orig, _maps);\n+    }\n+\n+    /**\n+     * Internal helper to copy value.\n+     */\n+    private static Object copy(Object orig, Map proxies) {\n+        if (orig == null)\n+            return null;\n+        if (orig instanceof Proxy)\n+            return ((Proxy) orig).copy(orig);\n+\n+        Class type = orig.getClass();\n+        Proxy proxy = (Proxy) proxies.get(type);\n+        if (proxy == null)\n+            throw new UnsupportedException(_loc.get(\"bad-proxy\", type));\n+        return proxy.copy(orig);\n+    }\n+\n+    public Object copyArray(Object orig) {\n+        if (orig == null)\n+            return null;\n+\n+        try {\n+            int length = Array.getLength(orig);\n+            Object array = Array.newInstance(orig.getClass().\n+                getComponentType(), length);\n+\n+            System.arraycopy(orig, 0, array, 0, length);\n+            return array;\n+        }\n+        catch (Exception e) {\n+            throw new UnsupportedException(_loc.get(\"bad-array\",\n+                e.getMessage()), e);\n+        }\n+    }\n+\n+    public Object copyCustom(Object orig) {\n+        if (!(orig instanceof Proxy))\n+            return null;\n+        return ((Proxy) orig).copy(orig);\n+    }\n+\n+    public Proxy newDateProxy(Class type) {\n+        ProxyDate pd = (ProxyDate) findProxy(type, ProxyDate.class, _dates);\n+        return pd.newInstance();\n+    }\n+\n+    public Proxy newCalendarProxy(Class type, TimeZone timeZone) {\n+        ProxyCalendar pc = (ProxyCalendar) findProxy(type,\n+            ProxyCalendar.class, _calendars);\n+        return pc.newInstance(timeZone);\n+    }\n+\n+    public Proxy newCollectionProxy(Class type, Class elementType,\n+        Comparator compare) {\n+        ProxyCollection pc = (ProxyCollection) findProxy(type,\n+            ProxyCollection.class, _collections);\n+        if (!_assertType)\n+            elementType = null;\n+        return pc.newInstance(elementType, compare, _trackChanges, conf);\n+    }\n+\n+    public Proxy newMapProxy(Class type, Class keyType, Class valueType,\n+        Comparator compare) {\n+        ProxyMap pm = (ProxyMap) findProxy(type, ProxyMap.class, _maps);\n+        if (!_assertType) {\n+            keyType = null;\n+            valueType = null;\n+        }\n+        return pm.newInstance(keyType, valueType, compare, _trackChanges, conf);\n+    }\n+\n+    /**\n+     * Helper method to find an existing proxy for the given type.\n+     */\n+    private static Proxy findProxy(Class type, Class proxyType, Map proxies) {\n+        Proxy p = (Proxy) proxies.get(type);\n+\n+        if (p == null) {\n+            // check for custom proxy\n+            if (proxyType.isAssignableFrom(type)) {\n+                try {\n+                    p = (Proxy) type.newInstance();\n+                    proxies.put(type, p);\n+                }\n+                catch (Exception e) {\n+                    throw new UnsupportedException(_loc.get(\"no-proxy-cons\",\n+                        type), e);\n+                }\n+            } else\n+                throw new UnsupportedException(_loc.get(\"bad-proxy\", type));\n+        }\n+        return p;\n+    }\n+\n+    public Proxy newCustomProxy(Object obj) {\n+        return (obj instanceof Proxy) ? (Proxy) obj : null;\n+    }\n+\n+    /**\n+     * Add a supported proxy collection type.\n+     */\n+    protected void setProxyTemplate(Class collType, ProxyCollection proxy) {\n+        _collections.put(collType, proxy);\n+    }\n+\n+    /**\n+     * Add a supported proxy map type.\n+     */\n+    protected void setProxyTemplate(Class mapType, ProxyMap proxy) {\n+        _maps.put(mapType, proxy);\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+        this.conf = (OpenJPAConfiguration) conf;\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration ()\n+\t{\n+\t}\n+}"},{"sha":"622e97e8e9190ee8a70024da70f4ff564466d47f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyMap.java","status":"modified","additions":40,"deletions":36,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyMap.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyMap.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,36 +1,40 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.util.Comparator;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-\r\n-/**\r\n- * Interface implemented by all built-in proxies on {@link Map} types.\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public interface ProxyMap extends Proxy {\r\n-\r\n-    /**\r\n-     * This method should return a new proxy of the same concrete type as the\r\n-     * implementing class. Used by the {@link ProxyManager} factories: one\r\n-     * template instance of each type is created for the purpose of producing\r\n-     * new instances via this method. Overcomes the performance\r\n-     * penalties of reflection.\r\n-     */\r\n-    public ProxyMap newInstance(Class keyType, Class valueType,\r\n-        Comparator compare, boolean trackChanges, OpenJPAConfiguration conf);\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.util.Comparator;\n+import java.util.Map;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+\n+/**\n+ * <p>Interface implemented by all built-in proxies on {@link Map} types.</p>\n+ *\n+ * @author Abe White\n+ */\n+public interface ProxyMap\n+    extends Proxy {\n+\n+    /**\n+     * This method should return a new proxy of the same concrete type as the\n+     * implementing class.  Used by the {@link ProxyManager} factories: one\n+     * template instance of each type is created for the purpose of producing\n+     * new instances via this method.  Overcomes the performance\n+     * penalties of reflection.\n+     */\n+    public ProxyMap newInstance(Class keyType, Class valueType,\n+        Comparator compare, boolean trackChanges, OpenJPAConfiguration conf);\n+}"},{"sha":"ad1bab4c0f7ce9ef347180a378f015b856bc129a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyProperties.java","status":"modified","additions":162,"deletions":155,"changes":317,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyProperties.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyProperties.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyProperties.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,155 +1,162 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.ObjectStreamException;\r\n-import java.util.Collection;\r\n-import java.util.Comparator;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-import java.util.Properties;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-\r\n-/**\r\n- * Extension of the {@link Properties} type that dirties the\r\n- * persistent/transactional field it is assigned to on modification.\r\n- * The need to dirty the field on <b>any</b> modification mandates that\r\n- * this class must override all mutator methods of the base type.\r\n- * This may lead to multiple calls to <code>dirty</code> for one state\r\n- * change if one mutator method of the base type calls another.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class ProxyProperties extends Properties implements ProxyMap {\r\n-\r\n-    private transient OpenJPAStateManager _sm = null;\r\n-    private transient int _field = -1;\r\n-    private transient MapChangeTracker _ct = null;\r\n-\r\n-    public ProxyProperties() {\r\n-    }\r\n-\r\n-    public ProxyProperties(boolean trackChanges, OpenJPAConfiguration conf) {\r\n-        if (trackChanges)\r\n-            _ct = new MapChangeTrackerImpl(this, conf);\r\n-    }\r\n-\r\n-    public void setOwner(OpenJPAStateManager sm, int field) {\r\n-        _sm = sm;\r\n-        _field = field;\r\n-    }\r\n-\r\n-    public OpenJPAStateManager getOwner() {\r\n-        return _sm;\r\n-    }\r\n-\r\n-    public int getOwnerField() {\r\n-        return _field;\r\n-    }\r\n-\r\n-    public ChangeTracker getChangeTracker() {\r\n-        return _ct;\r\n-    }\r\n-\r\n-    public Object copy(Object orig) {\r\n-        Properties props = new Properties();\r\n-        props.putAll((Map) orig);\r\n-        return props;\r\n-    }\r\n-\r\n-    public ProxyMap newInstance(Class keyType, Class valueType,\r\n-        Comparator compare, boolean trackChanges, OpenJPAConfiguration conf) {\r\n-        return new ProxyProperties(trackChanges, conf);\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        Proxies.dirty(this);\r\n-        if (_ct != null)\r\n-            _ct.stopTracking();\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = super.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            Proxies.removed(this, entry.getKey(), true);\r\n-            Proxies.removed(this, entry.getValue(), false);\r\n-        }\r\n-        super.clear();\r\n-    }\r\n-\r\n-    public Set keySet() {\r\n-        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_KEY);\r\n-    }\r\n-\r\n-    public Collection values() {\r\n-        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_VALUE);\r\n-    }\r\n-\r\n-    public Set entrySet() {\r\n-        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_ENTRY);\r\n-    }\r\n-\r\n-    public Object put(Object key, Object value) {\r\n-        Proxies.dirty(this);\r\n-        boolean had = containsKey(key);\r\n-        Object old = super.put(key, value);\r\n-        if (had) {\r\n-            if (_ct != null)\r\n-                _ct.changed(key, old, value);\r\n-            Proxies.removed(this, old, false);\r\n-        } else if (_ct != null)\r\n-            _ct.added(key, value);\r\n-        return old;\r\n-    }\r\n-\r\n-    public void putAll(Map m) {\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = m.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            put(entry.getKey(), entry.getValue());\r\n-        }\r\n-    }\r\n-\r\n-    public Object remove(Object key) {\r\n-        Proxies.dirty(this);\r\n-        boolean had = containsKey(key);\r\n-        Object old = super.remove(key);\r\n-        if (had) {\r\n-            if (_ct != null)\r\n-                _ct.removed(key, old);\r\n-            Proxies.removed(this, key, true);\r\n-            Proxies.removed(this, old, false);\r\n-        }\r\n-        return old;\r\n-    }\r\n-\r\n-    public Object setProperty(String key, String value) {\r\n-        return put(key, value);\r\n-    }\r\n-\r\n-    public void load(InputStream in) throws IOException {\r\n-        if (_ct != null)\r\n-            _ct.stopTracking();\r\n-        super.load(in);\r\n-    }\r\n-\r\n-    protected Object writeReplace() throws ObjectStreamException {\r\n-        if (_sm != null && _sm.isDetached())\r\n-            return this;\r\n-        return copy(this);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectStreamException;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * <p>Extension of the {@link Properties} type that dirties the\n+ * persistent/transactional field it is assigned to on modification.\n+ * The need to dirty the field on <b>any</b> modification mandates that\n+ * this class must override all mutator methods of the base type.\n+ * This may lead to multiple calls to <code>dirty</code> for one state\n+ * change if one mutator method of the base type calls another.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ProxyProperties\n+    extends Properties\n+    implements ProxyMap {\n+\n+    private transient OpenJPAStateManager _sm = null;\n+    private transient int _field = -1;\n+    private transient MapChangeTracker _ct = null;\n+\n+    public ProxyProperties() {\n+    }\n+\n+    public ProxyProperties(boolean trackChanges, OpenJPAConfiguration conf) {\n+        if (trackChanges)\n+            _ct = new MapChangeTrackerImpl(this, conf);\n+    }\n+\n+    public void setOwner(OpenJPAStateManager sm, int field) {\n+        _sm = sm;\n+        _field = field;\n+    }\n+\n+    public OpenJPAStateManager getOwner() {\n+        return _sm;\n+    }\n+\n+    public int getOwnerField() {\n+        return _field;\n+    }\n+\n+    public ChangeTracker getChangeTracker() {\n+        return _ct;\n+    }\n+\n+    public Object copy(Object orig) {\n+        Properties props = new Properties();\n+        props.putAll((Map) orig);\n+        return props;\n+    }\n+\n+    public ProxyMap newInstance(Class keyType, Class valueType,\n+        Comparator compare, boolean trackChanges, OpenJPAConfiguration conf) {\n+        return new ProxyProperties(trackChanges, conf);\n+    }\n+\n+    public void clear() {\n+        Proxies.dirty(this);\n+        if (_ct != null)\n+            _ct.stopTracking();\n+        Map.Entry entry;\n+        for (Iterator itr = super.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            Proxies.removed(this, entry.getKey(), true);\n+            Proxies.removed(this, entry.getValue(), false);\n+        }\n+        super.clear();\n+    }\n+\n+    public Set keySet() {\n+        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_KEY);\n+    }\n+\n+    public Collection values() {\n+        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_VALUE);\n+    }\n+\n+    public Set entrySet() {\n+        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_ENTRY);\n+    }\n+\n+    public Object put(Object key, Object value) {\n+        Proxies.dirty(this);\n+        boolean had = containsKey(key);\n+        Object old = super.put(key, value);\n+        if (had) {\n+            if (_ct != null)\n+                _ct.changed(key, old, value);\n+            Proxies.removed(this, old, false);\n+        } else if (_ct != null)\n+            _ct.added(key, value);\n+        return old;\n+    }\n+\n+    public void putAll(Map m) {\n+        Map.Entry entry;\n+        for (Iterator itr = m.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    public Object remove(Object key) {\n+        Proxies.dirty(this);\n+        boolean had = containsKey(key);\n+        Object old = super.remove(key);\n+        if (had) {\n+            if (_ct != null)\n+                _ct.removed(key, old);\n+            Proxies.removed(this, key, true);\n+            Proxies.removed(this, old, false);\n+        }\n+        return old;\n+    }\n+\n+    public Object setProperty(String key, String value) {\n+        return put(key, value);\n+    }\n+\n+    public void load(InputStream in)\n+        throws IOException {\n+        if (_ct != null)\n+            _ct.stopTracking();\n+        super.load(in);\n+    }\n+\n+    protected Object writeReplace()\n+        throws ObjectStreamException {\n+        if (_sm != null && _sm.isDetached())\n+            return this;\n+        return copy(this);\n+    }\n+}"},{"sha":"3eb5d0da7549fb6ddad0ed7d6d1d90e864fa63c5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxySQLDate.java","status":"modified","additions":113,"deletions":107,"changes":220,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxySQLDate.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxySQLDate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxySQLDate.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,107 +1,113 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.sql.Date;\r\n-\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-\r\n-/**\r\n- * Extension of the {@link Date} type that calls the <code>dirty</code>\r\n- * method on its owning persistence capable instance on modification. This\r\n- * class does not support modification via any deprecated method of the\r\n- * date class.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class ProxySQLDate extends Date implements ProxyDate {\r\n-\r\n-    private transient OpenJPAStateManager _sm = null;\r\n-    private transient int _field = -1;\r\n-\r\n-    public ProxySQLDate() {\r\n-        super(System.currentTimeMillis());\r\n-    }\r\n-\r\n-    public ProxySQLDate(long time) {\r\n-        super(time);\r\n-    }\r\n-\r\n-    public ProxyDate newInstance() {\r\n-        return new ProxySQLDate();\r\n-    }\r\n-\r\n-    public void setOwner(OpenJPAStateManager sm, int field) {\r\n-        _sm = sm;\r\n-        _field = field;\r\n-    }\r\n-\r\n-    public OpenJPAStateManager getOwner() {\r\n-        return _sm;\r\n-    }\r\n-\r\n-    public int getOwnerField() {\r\n-        return _field;\r\n-    }\r\n-\r\n-    public ChangeTracker getChangeTracker() {\r\n-        return null;\r\n-    }\r\n-\r\n-    public Object copy(Object orig) {\r\n-        return new Date(((Date) orig).getTime());\r\n-    }\r\n-\r\n-    public void setYear(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setYear(val);\r\n-    }\r\n-\r\n-    public void setMonth(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setMonth(val);\r\n-    }\r\n-\r\n-    public void setDate(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setDate(val);\r\n-    }\r\n-\r\n-    public void setHours(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setHours(val);\r\n-    }\r\n-\r\n-    public void setMinutes(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setMinutes(val);\r\n-    }\r\n-\r\n-    public void setSeconds(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setSeconds(val);\r\n-    }\r\n-\r\n-    public void setTime(long millis) {\r\n-        Proxies.dirty(this);\r\n-        super.setTime(millis);\r\n-    }\r\n-\r\n-    protected Object writeReplace() throws ObjectStreamException {\r\n-        if (_sm != null && _sm.isDetached())\r\n-            return this;\r\n-        return new Date(getTime());\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.ObjectStreamException;\n+import java.sql.Date;\n+\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * <p>Extension of the {@link Date} type that calls the <code>dirty</code>\n+ * method on its owning persistence capable instance on modification.  This\n+ * class does not support modification via any deprecated method of the\n+ * date class.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ProxySQLDate\n+    extends Date\n+    implements ProxyDate {\n+\n+    private transient OpenJPAStateManager _sm = null;\n+    private transient int _field = -1;\n+\n+    public ProxySQLDate() {\n+        super(System.currentTimeMillis());\n+    }\n+\n+    public ProxySQLDate(long time) {\n+        super(time);\n+    }\n+\n+    public ProxyDate newInstance() {\n+        return new ProxySQLDate();\n+    }\n+\n+    public void setOwner(OpenJPAStateManager sm, int field) {\n+        _sm = sm;\n+        _field = field;\n+    }\n+\n+    public OpenJPAStateManager getOwner() {\n+        return _sm;\n+    }\n+\n+    public int getOwnerField() {\n+        return _field;\n+    }\n+\n+    public ChangeTracker getChangeTracker() {\n+        return null;\n+    }\n+\n+    public Object copy(Object orig) {\n+        return new Date(((Date) orig).getTime());\n+    }\n+\n+    public void setYear(int val) {\n+        Proxies.dirty(this);\n+        super.setYear(val);\n+    }\n+\n+    public void setMonth(int val) {\n+        Proxies.dirty(this);\n+        super.setMonth(val);\n+    }\n+\n+    public void setDate(int val) {\n+        Proxies.dirty(this);\n+        super.setDate(val);\n+    }\n+\n+    public void setHours(int val) {\n+        Proxies.dirty(this);\n+        super.setHours(val);\n+    }\n+\n+    public void setMinutes(int val) {\n+        Proxies.dirty(this);\n+        super.setMinutes(val);\n+    }\n+\n+    public void setSeconds(int val) {\n+        Proxies.dirty(this);\n+        super.setSeconds(val);\n+    }\n+\n+    public void setTime(long millis) {\n+        Proxies.dirty(this);\n+        super.setTime(millis);\n+    }\n+\n+    protected Object writeReplace()\n+        throws ObjectStreamException {\n+        if (_sm != null && _sm.isDetached())\n+            return this;\n+        return new Date(getTime());\n+    }\n+}"},{"sha":"22938aba86308a73a0f4a54f261776c5ecfbea90","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTime.java","status":"modified","additions":113,"deletions":107,"changes":220,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTime.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTime.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,107 +1,113 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.sql.Time;\r\n-\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-\r\n-/**\r\n- * Extension of the {@link Time} type that calls the <code>dirty</code>\r\n- * method on its owning persistence capable instance on modification. This\r\n- * class does not support modification via any deprecated method of the\r\n- * date class.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class ProxyTime extends Time implements ProxyDate {\r\n-\r\n-    private transient OpenJPAStateManager _sm = null;\r\n-    private transient int _field = -1;\r\n-\r\n-    public ProxyTime() {\r\n-        super(System.currentTimeMillis());\r\n-    }\r\n-\r\n-    public ProxyTime(long time) {\r\n-        super(time);\r\n-    }\r\n-\r\n-    public ProxyDate newInstance() {\r\n-        return new ProxyTime();\r\n-    }\r\n-\r\n-    public void setOwner(OpenJPAStateManager sm, int field) {\r\n-        _sm = sm;\r\n-        _field = field;\r\n-    }\r\n-\r\n-    public OpenJPAStateManager getOwner() {\r\n-        return _sm;\r\n-    }\r\n-\r\n-    public int getOwnerField() {\r\n-        return _field;\r\n-    }\r\n-\r\n-    public ChangeTracker getChangeTracker() {\r\n-        return null;\r\n-    }\r\n-\r\n-    public Object copy(Object orig) {\r\n-        return new Time(((Time) orig).getTime());\r\n-    }\r\n-\r\n-    public void setYear(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setYear(val);\r\n-    }\r\n-\r\n-    public void setMonth(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setMonth(val);\r\n-    }\r\n-\r\n-    public void setDate(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setDate(val);\r\n-    }\r\n-\r\n-    public void setHours(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setHours(val);\r\n-    }\r\n-\r\n-    public void setMinutes(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setMinutes(val);\r\n-    }\r\n-\r\n-    public void setSeconds(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setSeconds(val);\r\n-    }\r\n-\r\n-    public void setTime(long millis) {\r\n-        Proxies.dirty(this);\r\n-        super.setTime(millis);\r\n-    }\r\n-\r\n-    protected Object writeReplace() throws ObjectStreamException {\r\n-        if (_sm != null && _sm.isDetached())\r\n-            return this;\r\n-        return new Time(getTime());\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.ObjectStreamException;\n+import java.sql.Time;\n+\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * <p>Extension of the {@link Time} type that calls the <code>dirty</code>\n+ * method on its owning persistence capable instance on modification.  This\n+ * class does not support modification via any deprecated method of the\n+ * date class.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ProxyTime\n+    extends Time\n+    implements ProxyDate {\n+\n+    private transient OpenJPAStateManager _sm = null;\n+    private transient int _field = -1;\n+\n+    public ProxyTime() {\n+        super(System.currentTimeMillis());\n+    }\n+\n+    public ProxyTime(long time) {\n+        super(time);\n+    }\n+\n+    public ProxyDate newInstance() {\n+        return new ProxyTime();\n+    }\n+\n+    public void setOwner(OpenJPAStateManager sm, int field) {\n+        _sm = sm;\n+        _field = field;\n+    }\n+\n+    public OpenJPAStateManager getOwner() {\n+        return _sm;\n+    }\n+\n+    public int getOwnerField() {\n+        return _field;\n+    }\n+\n+    public ChangeTracker getChangeTracker() {\n+        return null;\n+    }\n+\n+    public Object copy(Object orig) {\n+        return new Time(((Time) orig).getTime());\n+    }\n+\n+    public void setYear(int val) {\n+        Proxies.dirty(this);\n+        super.setYear(val);\n+    }\n+\n+    public void setMonth(int val) {\n+        Proxies.dirty(this);\n+        super.setMonth(val);\n+    }\n+\n+    public void setDate(int val) {\n+        Proxies.dirty(this);\n+        super.setDate(val);\n+    }\n+\n+    public void setHours(int val) {\n+        Proxies.dirty(this);\n+        super.setHours(val);\n+    }\n+\n+    public void setMinutes(int val) {\n+        Proxies.dirty(this);\n+        super.setMinutes(val);\n+    }\n+\n+    public void setSeconds(int val) {\n+        Proxies.dirty(this);\n+        super.setSeconds(val);\n+    }\n+\n+    public void setTime(long millis) {\n+        Proxies.dirty(this);\n+        super.setTime(millis);\n+    }\n+\n+    protected Object writeReplace()\n+        throws ObjectStreamException {\n+        if (_sm != null && _sm.isDetached())\n+            return this;\n+        return new Time(getTime());\n+    }\n+}"},{"sha":"d8a45abf18352fc34d02b0d04f1c48f2e97aa7dc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTimestamp.java","status":"modified","additions":120,"deletions":114,"changes":234,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTimestamp.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTimestamp.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTimestamp.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,114 +1,120 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.sql.Timestamp;\r\n-\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-\r\n-/**\r\n- * Extension of the {@link Timestamp} type that calls the <code>dirty</code>\r\n- * method on its owning persistence capable instance on modification. This\r\n- * class does not support modification via any deprecated method of the\r\n- * date class.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class ProxyTimestamp extends Timestamp implements ProxyDate {\r\n-\r\n-    private transient OpenJPAStateManager _sm = null;\r\n-    private transient int _field = -1;\r\n-\r\n-    public ProxyTimestamp() {\r\n-        super(System.currentTimeMillis());\r\n-    }\r\n-\r\n-    public ProxyTimestamp(long time) {\r\n-        super(time);\r\n-    }\r\n-\r\n-    public ProxyDate newInstance() {\r\n-        return new ProxyTimestamp();\r\n-    }\r\n-\r\n-    public void setOwner(OpenJPAStateManager sm, int field) {\r\n-        _sm = sm;\r\n-        _field = field;\r\n-    }\r\n-\r\n-    public OpenJPAStateManager getOwner() {\r\n-        return _sm;\r\n-    }\r\n-\r\n-    public int getOwnerField() {\r\n-        return _field;\r\n-    }\r\n-\r\n-    public ChangeTracker getChangeTracker() {\r\n-        return null;\r\n-    }\r\n-\r\n-    public Object copy(Object orig) {\r\n-        return new Timestamp(((Timestamp) orig).getTime());\r\n-    }\r\n-\r\n-    public void setYear(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setYear(val);\r\n-    }\r\n-\r\n-    public void setMonth(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setMonth(val);\r\n-    }\r\n-\r\n-    public void setDate(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setDate(val);\r\n-    }\r\n-\r\n-    public void setHours(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setHours(val);\r\n-    }\r\n-\r\n-    public void setMinutes(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setMinutes(val);\r\n-    }\r\n-\r\n-    public void setSeconds(int val) {\r\n-        Proxies.dirty(this);\r\n-        super.setSeconds(val);\r\n-    }\r\n-\r\n-    public void setTime(long millis) {\r\n-        Proxies.dirty(this);\r\n-        super.setTime(millis);\r\n-    }\r\n-\r\n-    public void setNanos(int nanos) {\r\n-        Proxies.dirty(this);\r\n-        super.setNanos(nanos);\r\n-    }\r\n-\r\n-    protected Object writeReplace() throws ObjectStreamException {\r\n-        if (_sm != null && _sm.isDetached())\r\n-            return this;\r\n-        Timestamp t = new Timestamp(getTime());\r\n-        t.setNanos(getNanos());\r\n-        return t;\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.ObjectStreamException;\n+import java.sql.Timestamp;\n+\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * <p>Extension of the {@link Timestamp} type that calls the <code>dirty</code>\n+ * method on its owning persistence capable instance on modification.  This\n+ * class does not support modification via any deprecated method of the\n+ * date class.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ProxyTimestamp\n+    extends Timestamp\n+    implements ProxyDate {\n+\n+    private transient OpenJPAStateManager _sm = null;\n+    private transient int _field = -1;\n+\n+    public ProxyTimestamp() {\n+        super(System.currentTimeMillis());\n+    }\n+\n+    public ProxyTimestamp(long time) {\n+        super(time);\n+    }\n+\n+    public ProxyDate newInstance() {\n+        return new ProxyTimestamp();\n+    }\n+\n+    public void setOwner(OpenJPAStateManager sm, int field) {\n+        _sm = sm;\n+        _field = field;\n+    }\n+\n+    public OpenJPAStateManager getOwner() {\n+        return _sm;\n+    }\n+\n+    public int getOwnerField() {\n+        return _field;\n+    }\n+\n+    public ChangeTracker getChangeTracker() {\n+        return null;\n+    }\n+\n+    public Object copy(Object orig) {\n+        return new Timestamp(((Timestamp) orig).getTime());\n+    }\n+\n+    public void setYear(int val) {\n+        Proxies.dirty(this);\n+        super.setYear(val);\n+    }\n+\n+    public void setMonth(int val) {\n+        Proxies.dirty(this);\n+        super.setMonth(val);\n+    }\n+\n+    public void setDate(int val) {\n+        Proxies.dirty(this);\n+        super.setDate(val);\n+    }\n+\n+    public void setHours(int val) {\n+        Proxies.dirty(this);\n+        super.setHours(val);\n+    }\n+\n+    public void setMinutes(int val) {\n+        Proxies.dirty(this);\n+        super.setMinutes(val);\n+    }\n+\n+    public void setSeconds(int val) {\n+        Proxies.dirty(this);\n+        super.setSeconds(val);\n+    }\n+\n+    public void setTime(long millis) {\n+        Proxies.dirty(this);\n+        super.setTime(millis);\n+    }\n+\n+    public void setNanos(int nanos) {\n+        Proxies.dirty(this);\n+        super.setNanos(nanos);\n+    }\n+\n+    protected Object writeReplace()\n+        throws ObjectStreamException {\n+        if (_sm != null && _sm.isDetached())\n+            return this;\n+        Timestamp t = new Timestamp(getTime());\n+        t.setNanos(getNanos());\n+        return t;\n+    }\n+}"},{"sha":"a011233321a50490a19960f60f423377da97d0c3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTreeMap.java","status":"modified","additions":169,"deletions":163,"changes":332,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTreeMap.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTreeMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTreeMap.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,163 +1,169 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.util.Collection;\r\n-import java.util.Comparator;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-import java.util.SortedMap;\r\n-import java.util.TreeMap;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-\r\n-/**\r\n- * Extension of the {@link TreeMap} type that dirties the\r\n- * persistent/transactional field it is assigned to on modification.\r\n- * The need to dirty the field on <b>any</b> modification mandates that\r\n- * this class must override all mutator methods of the base type.\r\n- * This may lead to multiple calls to <code>dirty</code> for one state\r\n- * change if one mutator method of the base type calls another.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class ProxyTreeMap extends TreeMap implements ProxyMap {\r\n-\r\n-    private transient Class _keyType = null;\r\n-    private transient Class _valueType = null;\r\n-    private transient OpenJPAStateManager _sm = null;\r\n-    private transient int _field = -1;\r\n-    private transient MapChangeTracker _ct = null;\r\n-\r\n-    public ProxyTreeMap() {\r\n-    }\r\n-\r\n-    public ProxyTreeMap(Class keyType, Class valueType, boolean trackChanges,\r\n-        OpenJPAConfiguration conf) {\r\n-        _keyType = keyType;\r\n-        _valueType = valueType;\r\n-        if (trackChanges)\r\n-            _ct = new MapChangeTrackerImpl(this, conf);\r\n-    }\r\n-\r\n-    public ProxyTreeMap(Class keyType, Class valueType, Comparator compare,\r\n-        boolean trackChanges, OpenJPAConfiguration conf) {\r\n-        super(compare);\r\n-        _keyType = keyType;\r\n-        _valueType = valueType;\r\n-        if (trackChanges)\r\n-            _ct = new MapChangeTrackerImpl(this, conf);\r\n-    }\r\n-\r\n-    public void setOwner(OpenJPAStateManager sm, int field) {\r\n-        _sm = sm;\r\n-        _field = field;\r\n-    }\r\n-\r\n-    public OpenJPAStateManager getOwner() {\r\n-        return _sm;\r\n-    }\r\n-\r\n-    public int getOwnerField() {\r\n-        return _field;\r\n-    }\r\n-\r\n-    public ChangeTracker getChangeTracker() {\r\n-        return _ct;\r\n-    }\r\n-\r\n-    public Object copy(Object orig) {\r\n-        if (orig instanceof SortedMap)\r\n-            return new TreeMap((SortedMap) orig);\r\n-        return new TreeMap((Map) orig);\r\n-    }\r\n-\r\n-    public ProxyMap newInstance(Class keyType, Class valueType,\r\n-        Comparator compare, boolean trackChanges, OpenJPAConfiguration conf) {\r\n-        if (compare == null)\r\n-            return new ProxyTreeMap(keyType, valueType, trackChanges, conf);\r\n-        return new ProxyTreeMap(keyType, valueType, compare, trackChanges,\r\n-            conf);\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        Proxies.dirty(this);\r\n-        if (_ct != null)\r\n-            _ct.stopTracking();\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = super.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            Proxies.removed(this, entry.getKey(), true);\r\n-            Proxies.removed(this, entry.getValue(), false);\r\n-        }\r\n-        super.clear();\r\n-    }\r\n-\r\n-    public Set keySet() {\r\n-        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_KEY);\r\n-    }\r\n-\r\n-    public Collection values() {\r\n-        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_VALUE);\r\n-    }\r\n-\r\n-    public Set entrySet() {\r\n-        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_ENTRY);\r\n-    }\r\n-\r\n-    public Object put(Object key, Object value) {\r\n-        Proxies.assertAllowedType(key, _keyType);\r\n-        Proxies.assertAllowedType(value, _valueType);\r\n-        Proxies.dirty(this);\r\n-        boolean had = containsKey(key);\r\n-        Object old = super.put(key, value);\r\n-        if (had) {\r\n-            if (_ct != null)\r\n-                _ct.changed(key, old, value);\r\n-            Proxies.removed(this, old, false);\r\n-        } else if (_ct != null)\r\n-            _ct.added(key, value);\r\n-        return old;\r\n-    }\r\n-\r\n-    public void putAll(Map m) {\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = m.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            put(entry.getKey(), entry.getValue());\r\n-        }\r\n-    }\r\n-\r\n-    public Object remove(Object key) {\r\n-        Proxies.dirty(this);\r\n-        boolean had = containsKey(key);\r\n-        Object old = super.remove(key);\r\n-        if (had) {\r\n-            if (_ct != null)\r\n-                _ct.removed(key, old);\r\n-            Proxies.removed(this, key, true);\r\n-            Proxies.removed(this, old, false);\r\n-        }\r\n-        return old;\r\n-    }\r\n-\r\n-    protected Object writeReplace() throws ObjectStreamException {\r\n-        if (_sm != null && _sm.isDetached())\r\n-            return this;\r\n-        return copy(this);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.ObjectStreamException;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * <p>Extension of the {@link TreeMap} type that dirties the\n+ * persistent/transactional field it is assigned to on modification.\n+ * The need to dirty the field on <b>any</b> modification mandates that\n+ * this class must override all mutator methods of the base type.\n+ * This may lead to multiple calls to <code>dirty</code> for one state\n+ * change if one mutator method of the base type calls another.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ProxyTreeMap\n+    extends TreeMap\n+    implements ProxyMap {\n+\n+    private transient Class _keyType = null;\n+    private transient Class _valueType = null;\n+    private transient OpenJPAStateManager _sm = null;\n+    private transient int _field = -1;\n+    private transient MapChangeTracker _ct = null;\n+\n+    public ProxyTreeMap() {\n+    }\n+\n+    public ProxyTreeMap(Class keyType, Class valueType, boolean trackChanges,\n+        OpenJPAConfiguration conf) {\n+        _keyType = keyType;\n+        _valueType = valueType;\n+        if (trackChanges)\n+            _ct = new MapChangeTrackerImpl(this, conf);\n+    }\n+\n+    public ProxyTreeMap(Class keyType, Class valueType, Comparator compare,\n+        boolean trackChanges, OpenJPAConfiguration conf) {\n+        super(compare);\n+        _keyType = keyType;\n+        _valueType = valueType;\n+        if (trackChanges)\n+            _ct = new MapChangeTrackerImpl(this, conf);\n+    }\n+\n+    public void setOwner(OpenJPAStateManager sm, int field) {\n+        _sm = sm;\n+        _field = field;\n+    }\n+\n+    public OpenJPAStateManager getOwner() {\n+        return _sm;\n+    }\n+\n+    public int getOwnerField() {\n+        return _field;\n+    }\n+\n+    public ChangeTracker getChangeTracker() {\n+        return _ct;\n+    }\n+\n+    public Object copy(Object orig) {\n+        if (orig instanceof SortedMap)\n+            return new TreeMap((SortedMap) orig);\n+        return new TreeMap((Map) orig);\n+    }\n+\n+    public ProxyMap newInstance(Class keyType, Class valueType,\n+        Comparator compare, boolean trackChanges, OpenJPAConfiguration conf) {\n+        if (compare == null)\n+            return new ProxyTreeMap(keyType, valueType, trackChanges, conf);\n+        return new ProxyTreeMap(keyType, valueType, compare, trackChanges,\n+            conf);\n+    }\n+\n+    public void clear() {\n+        Proxies.dirty(this);\n+        if (_ct != null)\n+            _ct.stopTracking();\n+        Map.Entry entry;\n+        for (Iterator itr = super.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            Proxies.removed(this, entry.getKey(), true);\n+            Proxies.removed(this, entry.getValue(), false);\n+        }\n+        super.clear();\n+    }\n+\n+    public Set keySet() {\n+        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_KEY);\n+    }\n+\n+    public Collection values() {\n+        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_VALUE);\n+    }\n+\n+    public Set entrySet() {\n+        return Proxies.entrySet(this, super.entrySet(), Proxies.MODE_ENTRY);\n+    }\n+\n+    public Object put(Object key, Object value) {\n+        Proxies.assertAllowedType(key, _keyType);\n+        Proxies.assertAllowedType(value, _valueType);\n+        Proxies.dirty(this);\n+        boolean had = containsKey(key);\n+        Object old = super.put(key, value);\n+        if (had) {\n+            if (_ct != null)\n+                _ct.changed(key, old, value);\n+            Proxies.removed(this, old, false);\n+        } else if (_ct != null)\n+            _ct.added(key, value);\n+        return old;\n+    }\n+\n+    public void putAll(Map m) {\n+        Map.Entry entry;\n+        for (Iterator itr = m.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    public Object remove(Object key) {\n+        Proxies.dirty(this);\n+        boolean had = containsKey(key);\n+        Object old = super.remove(key);\n+        if (had) {\n+            if (_ct != null)\n+                _ct.removed(key, old);\n+            Proxies.removed(this, key, true);\n+            Proxies.removed(this, old, false);\n+        }\n+        return old;\n+    }\n+\n+    protected Object writeReplace()\n+        throws ObjectStreamException {\n+        if (_sm != null && _sm.isDetached())\n+            return this;\n+        return copy(this);\n+    }\n+}"},{"sha":"0a28e866b032d5a7f40aeee9efe311021615c4ad","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTreeSet.java","status":"modified","additions":159,"deletions":153,"changes":312,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTreeSet.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTreeSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyTreeSet.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539","patch":"@@ -1,153 +1,159 @@\n-/*\r\n- * Copyright 2006 The Apache Software Foundation.\r\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *  http://www.apache.org/licenses/LICENSE-2.0\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.util.Collection;\r\n-import java.util.Comparator;\r\n-import java.util.Iterator;\r\n-import java.util.SortedSet;\r\n-import java.util.TreeSet;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-\r\n-/**\r\n- * Extension of the {@link TreeSet} type that dirties the\r\n- * persistent/transactional field it is assigned to on modification.\r\n- * The need to dirty the field on <b>any</b> modification mandates that\r\n- * this class must override all mutator methods of the base type.\r\n- * This may lead to multiple calls to <code>dirty</code> for one state\r\n- * change if one mutator method of the base type calls another.\r\n- *\r\n- * @author Abe White\r\n- * @nojavadoc\r\n- */\r\n-public class ProxyTreeSet extends TreeSet implements ProxyCollection {\r\n-\r\n-    private transient Class _elementType = null;\r\n-    private transient OpenJPAStateManager _sm = null;\r\n-    private transient int _field = -1;\r\n-    private transient CollectionChangeTracker _ct = null;\r\n-\r\n-    public ProxyTreeSet() {\r\n-    }\r\n-\r\n-    public ProxyTreeSet(Class elementType, boolean trackChanges,\r\n-        OpenJPAConfiguration conf) {\r\n-        _elementType = elementType;\r\n-        if (trackChanges)\r\n-            _ct = new CollectionChangeTrackerImpl(this, false, false, conf);\r\n-    }\r\n-\r\n-    public ProxyTreeSet(Class elementType, Comparator compare,\r\n-        boolean trackChanges, OpenJPAConfiguration conf) {\r\n-        super(compare);\r\n-        _elementType = elementType;\r\n-        if (trackChanges)\r\n-            _ct = new CollectionChangeTrackerImpl(this, false, false, conf);\r\n-    }\r\n-\r\n-    public void setOwner(OpenJPAStateManager sm, int field) {\r\n-        _sm = sm;\r\n-        _field = field;\r\n-    }\r\n-\r\n-    public OpenJPAStateManager getOwner() {\r\n-        return _sm;\r\n-    }\r\n-\r\n-    public int getOwnerField() {\r\n-        return _field;\r\n-    }\r\n-\r\n-    public ChangeTracker getChangeTracker() {\r\n-        return _ct;\r\n-    }\r\n-\r\n-    public Object copy(Object orig) {\r\n-        if (orig instanceof SortedSet)\r\n-            return new TreeSet((SortedSet) orig);\r\n-        return new TreeSet((Collection) orig);\r\n-    }\r\n-\r\n-    public ProxyCollection newInstance(Class elementType, Comparator compare,\r\n-        boolean trackChanges, OpenJPAConfiguration conf) {\r\n-        if (compare == null)\r\n-            return new ProxyTreeSet(elementType, trackChanges, conf);\r\n-        return new ProxyTreeSet(elementType, compare, trackChanges, conf);\r\n-    }\r\n-\r\n-    public boolean add(Object value) {\r\n-        Proxies.assertAllowedType(value, _elementType);\r\n-        Proxies.dirty(this);\r\n-        if (super.add(value)) {\r\n-            if (_ct != null)\r\n-                _ct.added(value);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean addAll(Collection values) {\r\n-        boolean added = false;\r\n-        for (Iterator itr = values.iterator(); itr.hasNext();)\r\n-            added = add(itr.next()) || added;\r\n-        return added;\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        Proxies.dirty(this);\r\n-        if (_ct != null)\r\n-            _ct.stopTracking();\r\n-        for (Iterator itr = super.iterator(); itr.hasNext();)\r\n-            Proxies.removed(this, itr.next(), false);\r\n-        super.clear();\r\n-    }\r\n-\r\n-    public Iterator iterator() {\r\n-        return Proxies.iterator(this, super.iterator());\r\n-    }\r\n-\r\n-    public boolean remove(Object o) {\r\n-        Proxies.dirty(this);\r\n-        if (super.remove(o)) {\r\n-            if (_ct != null)\r\n-                _ct.removed(o);\r\n-            Proxies.removed(this, o, false);\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean removeAll(Collection c) {\r\n-        boolean removed = false;\r\n-        for (Iterator itr = c.iterator(); itr.hasNext();)\r\n-            removed = remove(itr.next()) || removed;\r\n-        return removed;\r\n-    }\r\n-\r\n-    public boolean retainAll(Collection c) {\r\n-        int size = size();\r\n-        for (Iterator itr = iterator(); itr.hasNext();)\r\n-            if (!c.contains(itr.next()))\r\n-                itr.remove();\r\n-        return size() < size;\r\n-    }\r\n-\r\n-    protected Object writeReplace() throws ObjectStreamException {\r\n-        if (_sm != null && _sm.isDetached())\r\n-            return this;\r\n-        return copy(this);\r\n-    }\r\n-}\r\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.io.ObjectStreamException;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * <p>Extension of the {@link TreeSet} type that dirties the\n+ * persistent/transactional field it is assigned to on modification.\n+ * The need to dirty the field on <b>any</b> modification mandates that\n+ * this class must override all mutator methods of the base type.\n+ * This may lead to multiple calls to <code>dirty</code> for one state\n+ * change if one mutator method of the base type calls another.</p>\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class ProxyTreeSet\n+    extends TreeSet\n+    implements ProxyCollection {\n+\n+    private transient Class _elementType = null;\n+    private transient OpenJPAStateManager _sm = null;\n+    private transient int _field = -1;\n+    private transient CollectionChangeTracker _ct = null;\n+\n+    public ProxyTreeSet() {\n+    }\n+\n+    public ProxyTreeSet(Class elementType, boolean trackChanges,\n+        OpenJPAConfiguration conf) {\n+        _elementType = elementType;\n+        if (trackChanges)\n+            _ct = new CollectionChangeTrackerImpl(this, false, false, conf);\n+    }\n+\n+    public ProxyTreeSet(Class elementType, Comparator compare,\n+        boolean trackChanges, OpenJPAConfiguration conf) {\n+        super(compare);\n+        _elementType = elementType;\n+        if (trackChanges)\n+            _ct = new CollectionChangeTrackerImpl(this, false, false, conf);\n+    }\n+\n+    public void setOwner(OpenJPAStateManager sm, int field) {\n+        _sm = sm;\n+        _field = field;\n+    }\n+\n+    public OpenJPAStateManager getOwner() {\n+        return _sm;\n+    }\n+\n+    public int getOwnerField() {\n+        return _field;\n+    }\n+\n+    public ChangeTracker getChangeTracker() {\n+        return _ct;\n+    }\n+\n+    public Object copy(Object orig) {\n+        if (orig instanceof SortedSet)\n+            return new TreeSet((SortedSet) orig);\n+        return new TreeSet((Collection) orig);\n+    }\n+\n+    public ProxyCollection newInstance(Class elementType, Comparator compare,\n+        boolean trackChanges, OpenJPAConfiguration conf) {\n+        if (compare == null)\n+            return new ProxyTreeSet(elementType, trackChanges, conf);\n+        return new ProxyTreeSet(elementType, compare, trackChanges, conf);\n+    }\n+\n+    public boolean add(Object value) {\n+        Proxies.assertAllowedType(value, _elementType);\n+        Proxies.dirty(this);\n+        if (super.add(value)) {\n+            if (_ct != null)\n+                _ct.added(value);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean addAll(Collection values) {\n+        boolean added = false;\n+        for (Iterator itr = values.iterator(); itr.hasNext();)\n+            added = add(itr.next()) || added;\n+        return added;\n+    }\n+\n+    public void clear() {\n+        Proxies.dirty(this);\n+        if (_ct != null)\n+            _ct.stopTracking();\n+        for (Iterator itr = super.iterator(); itr.hasNext();)\n+            Proxies.removed(this, itr.next(), false);\n+        super.clear();\n+    }\n+\n+    public Iterator iterator() {\n+        return Proxies.iterator(this, super.iterator());\n+    }\n+\n+    public boolean remove(Object o) {\n+        Proxies.dirty(this);\n+        if (super.remove(o)) {\n+            if (_ct != null)\n+                _ct.removed(o);\n+            Proxies.removed(this, o, false);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean removeAll(Collection c) {\n+        boolean removed = false;\n+        for (Iterator itr = c.iterator(); itr.hasNext();)\n+            removed = remove(itr.next()) || removed;\n+        return removed;\n+    }\n+\n+    public boolean retainAll(Collection c) {\n+        int size = size();\n+        for (Iterator itr = iterator(); itr.hasNext();)\n+            if (!c.contains(itr.next()))\n+                itr.remove();\n+        return size() < size;\n+    }\n+\n+    protected Object writeReplace()\n+        throws ObjectStreamException {\n+        if (_sm != null && _sm.isDetached())\n+            return this;\n+        return copy(this);\n+    }\n+}"},{"sha":"69111728eea7f3062fed9ea91139168ecb658579","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyUtilDate.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyUtilDate.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyUtilDate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyUtilDate.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"07ff76d4ad0da4c93e6cf84dce15d8c9dd5127d0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyVector.java","status":"modified","additions":246,"deletions":240,"changes":486,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyVector.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyVector.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyVector.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b7ed209a0d3d1e65eb5e7d7460f0dc5762502260","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ReferentialIntegrityException.java","status":"modified","additions":94,"deletions":87,"changes":181,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ReferentialIntegrityException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ReferentialIntegrityException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ReferentialIntegrityException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b94218c62430ea1beb5038d4bb837b23cc23b987","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/RuntimeExceptionTranslator.java","status":"modified","additions":33,"deletions":29,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/RuntimeExceptionTranslator.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/RuntimeExceptionTranslator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/RuntimeExceptionTranslator.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"985a857cef7fb844aa8440018956e4250d1e1f58","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/Serialization.java","status":"modified","additions":165,"deletions":154,"changes":319,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/Serialization.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/Serialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/Serialization.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"56086cdc4e1970e1f0f10a7f5988a96837abd6d4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ShortId.java","status":"modified","additions":64,"deletions":61,"changes":125,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ShortId.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/ShortId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ShortId.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"757a1f1e1f9bbe61e732b6c79bbec72c82539c6e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreException.java","status":"modified","additions":51,"deletions":47,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"187723208db5089dd2f11f1ebafa935b3af73b49","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/StringId.java","status":"modified","additions":56,"deletions":53,"changes":109,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/StringId.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/StringId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/StringId.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"2cb986dfa5c33fb50b27658a7a75005864c28e2e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/UnsupportedException.java","status":"modified","additions":49,"deletions":45,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/UnsupportedException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/UnsupportedException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/UnsupportedException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"e6728971ee29b4b9f3401bc673dc98b12c65f7a8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/UserException.java","status":"modified","additions":50,"deletions":46,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/UserException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-kernel/src/main/java/org/apache/openjpa/util/UserException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/UserException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"fe7ba16d060940cf343b3245f5a7a5e7bcef042e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"3d33982757e849abd71db5f5c1307de2202bd0f0","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b96455a24e4160202ef5cefd28ed12129dc79e6e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"09008ae2c65818864f3a56ec8d70325b62733fd7","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"0bbd9c411555d2778ef41ddb4b863319e82293cf","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"90eed687f1d44209612b7d09b0308166c55e4101","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a200707e83f9d630cba923118219d60d2fc77d4f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"d2c9aa06f5e3eaee34f6c87e1afb43190a24a757","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/AbstractLog.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/AbstractLog.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/AbstractLog.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/AbstractLog.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b7ad6980597d6697822fb9634b60b2b137fe7ed3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogOutputStream.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogOutputStream.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogOutputStream.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogOutputStream.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"cf136973a7a7c56cb3f095d8975f2c9e8ebda8c9","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"c6b0bbe042a917e296e83ad9d072a7def33cd4de","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataParser.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataParser.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"165e7f704420cc10f749c6f7786aa357467a0aa0","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataSerializer.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/MetaDataSerializer.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"68f1956e1d0655fffe579f1b9cab18059a794aff","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SourceTrackers.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SourceTrackers.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SourceTrackers.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/SourceTrackers.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b021c7598c4d14bc60fd388bec95d076088caaf8","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/MergedResultObjectProvider.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/MergedResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/MergedResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/MergedResultObjectProvider.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"35b30c48b32f8650ade5870c708b3926f727190f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/RangeResultObjectProvider.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/RangeResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/RangeResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/RangeResultObjectProvider.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"49294763b04ba8a7951abbf0853bddcc1b412be9","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Files.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Files.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Files.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Files.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"9a4c68ea4c45db5655b913ecdc7e5b4cd16a0107","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"e3cb65742e0c5b0673a19f82acbedd77982f9b7f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"dbfae71709cbd47d3e18744b629c418dddd1c714","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Options.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Options.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Options.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Options.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"6d14beab6008934155dc58e63e4c28fda4932577","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Services.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Services.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Services.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Services.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"19001ce9159c687f20d3437d7d8d0e13349e3124","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StringDistance.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StringDistance.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StringDistance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StringDistance.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"0077950bfcc7a75711c57a11954cb78a13a93139","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractQueue.java","status":"modified","additions":16,"deletions":16,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractQueue.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractQueue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractQueue.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"4f6d45f91bc8932a8e604091e51cf3b59c2ece10","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"c81aed600bb71d26b56b82dc27866262c2259576","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentLinkedQueue.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentLinkedQueue.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentLinkedQueue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentLinkedQueue.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b093810658d9d0f2499ead8e130d3c33736fff68","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap.java","status":"modified","additions":10,"deletions":10,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashMap.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ba18d934849b4c272d00950105d776f07d017337","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Condition.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Condition.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Condition.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Condition.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"10776c8620687e75edcc2ebc3e0b83f1181894d8","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArraySet.java","status":"modified","additions":12,"deletions":12,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArraySet.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArraySet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArraySet.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"0ae4b923bfc0a3b176a0d2b23fd872967adb0dda","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Lock.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Lock.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Lock.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Lock.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"867458f53f3184fd353c060e4b536fd41ea7e6bb","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Queue.java","status":"modified","additions":12,"deletions":12,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Queue.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Queue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Queue.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"eaa6828f02a21e2df962e299fff0364663023eaf","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java","status":"modified","additions":11,"deletions":11,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b10ca967435fc250160cc22beadd1e672d3cee79","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/TimeUnit.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/TimeUnit.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/TimeUnit.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/TimeUnit.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b88be1e5a94c7bae763685cc066d80f59b6d27a0","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Utils.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Utils.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Utils.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Utils.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a676cc5c034bf09142c54558cd82ec39a6b1f936","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","status":"modified","additions":22,"deletions":22,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"582fe47898d48f1d8496a870f9a7ee4f4cc99e72","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"af5bdabd239aee1324e68102dd7307e6a52b2665","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","status":"modified","additions":1619,"deletions":1502,"changes":3121,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"f15846338a35cc4f34059acea3587e193833dc67","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ArgumentException.java","status":"modified","additions":107,"deletions":102,"changes":209,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ArgumentException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ArgumentException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ArgumentException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a80e287a8fa52ca83f7ec53ed13b5bbee2129456","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ConfigurationProviderImpl.java","status":"modified","additions":371,"deletions":340,"changes":711,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ConfigurationProviderImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ConfigurationProviderImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ConfigurationProviderImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"95ad9475a7961256dfd85184a44cd18b8f0bb3a9","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DataCache.java","status":"modified","additions":38,"deletions":35,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DataCache.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DataCache.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"9979287b58a35152966b90f469f98f014cba3d7a","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DataStoreId.java","status":"modified","additions":37,"deletions":34,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DataStoreId.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DataStoreId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DataStoreId.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"848a133ba989a602dcce156be44618d8ac90d64b","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Dependent.java","status":"modified","additions":35,"deletions":32,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Dependent.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Dependent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Dependent.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"7456824a413e9236c1153ba806bccb7c5949f18a","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DetachedState.java","status":"modified","additions":37,"deletions":34,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DetachedState.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DetachedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DetachedState.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"dfdac2bf3535b623aca1c668c3ae3ef006817784","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ElementDependent.java","status":"modified","additions":35,"deletions":32,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ElementDependent.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ElementDependent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ElementDependent.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b391a1c359628d84373a4cba2793e2b7b8f0c502","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ElementType.java","status":"modified","additions":36,"deletions":33,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ElementType.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ElementType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ElementType.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"339a4b35436792208839bd3652837f06e24d05a6","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityExistsException.java","status":"modified","additions":108,"deletions":104,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityExistsException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityExistsException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityExistsException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"e912da778dd9a6f4e0e6d40e4e3368e64bb959e4","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java","status":"modified","additions":305,"deletions":283,"changes":588,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ec38d18e49462928234d52ddd63b9bc418f2f1a2","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","status":"modified","additions":993,"deletions":969,"changes":1962,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"cc9ed13d7b8f1324624d3ff4c0765558f6b947b4","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityNotFoundException.java","status":"modified","additions":108,"deletions":104,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityNotFoundException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityNotFoundException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityNotFoundException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"53ce6e185cd7349d1022cda53a4cfd7bfbd3a3d6","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java","status":"modified","additions":137,"deletions":133,"changes":270,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"e61b471092852cbbf421fb72593e1ee2cf472ae5","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ExternalValues.java","status":"modified","additions":37,"deletions":34,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ExternalValues.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ExternalValues.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ExternalValues.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"7eedaad08e6b98a7ee737dd6541c486b2ff798b6","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Externalizer.java","status":"modified","additions":36,"deletions":33,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Externalizer.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Externalizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Externalizer.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"e78291ab3987d7af8113ab96147e8bd3bfad4ec5","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Factory.java","status":"modified","additions":36,"deletions":33,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Factory.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Factory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Factory.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"575c86376475b62822565204e459bf77621ebfa4","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchAttribute.java","status":"modified","additions":35,"deletions":32,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchAttribute.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchAttribute.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchAttribute.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"da9189bbc6432747bb4fcf1017c416e38f52522a","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroup.java","status":"modified","additions":36,"deletions":33,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroup.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroup.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroup.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"156848584e96b9e899dd58b902c67d90f509c9a3","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroups.java","status":"modified","additions":34,"deletions":31,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroups.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroups.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroups.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"3879514d7e4210b6bda8b302b076e570eb64fd29","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java","status":"modified","additions":463,"deletions":459,"changes":922,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"c2c8d15035cd79c8a5e5725fb71d6611e1ff51f9","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Generator.java","status":"modified","additions":99,"deletions":95,"changes":194,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Generator.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Generator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Generator.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a54cafdde8227292e79f3b27965d1d62b305930e","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InvalidStateException.java","status":"modified","additions":108,"deletions":103,"changes":211,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InvalidStateException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InvalidStateException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InvalidStateException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"4fdc0790686a099f1a4e5fbfe5cded2cb385625d","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InverseLogical.java","status":"modified","additions":35,"deletions":32,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InverseLogical.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InverseLogical.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InverseLogical.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"fba271c0734c814323b2521a876ec41e5c696ed5","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyDependent.java","status":"modified","additions":35,"deletions":32,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyDependent.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyDependent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyDependent.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"34d36142fb0d25f7aa69b94759ce1229a345e250","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyType.java","status":"modified","additions":36,"deletions":33,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyType.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyType.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ac0060563eee5435bd027d4c50a0207ec4956b15","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/LRS.java","status":"modified","additions":35,"deletions":32,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/LRS.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/LRS.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/LRS.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"d3d2cc541145ee2efb544d1f5da578586d0a5b2b","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MetaDataTag.java","status":"modified","additions":76,"deletions":72,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MetaDataTag.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MetaDataTag.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MetaDataTag.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"fdf824fc86cc08653a89d66019baa497c852702c","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NoResultException.java","status":"modified","additions":108,"deletions":103,"changes":211,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NoResultException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NoResultException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NoResultException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"9e8e17ffc6277ec9fc2505d471f7973484da80f2","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NonUniqueResultException.java","status":"modified","additions":108,"deletions":104,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NonUniqueResultException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NonUniqueResultException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NonUniqueResultException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"3d12bd55d1df7929551ed26910cf50dcd68a7936","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManager.java","status":"modified","additions":909,"deletions":891,"changes":1800,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"babd50ff04d85af952a32983ee54e9beecc33cc7","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerFactory.java","status":"modified","additions":105,"deletions":102,"changes":207,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerFactory.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"1ea26f760fb5811231a77a05a2c577bf245c51df","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java","status":"modified","additions":457,"deletions":424,"changes":881,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"2fc8c9d5fa8f3f981fd26e48f849b24640430156","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAQuery.java","status":"modified","additions":213,"deletions":208,"changes":421,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAQuery.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAQuery.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"662ce4ba61741724f7e6534e5d2a11aa36c436c0","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OptimisticLockException.java","status":"modified","additions":108,"deletions":104,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OptimisticLockException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OptimisticLockException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OptimisticLockException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ca719f260af03667a616807ed75b6a06db953fdf","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceException.java","status":"modified","additions":107,"deletions":103,"changes":210,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b91b9c51f10b82c79c2f3b7e5834385c898c971f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java","status":"modified","additions":247,"deletions":235,"changes":482,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"2def13e2936bb74f0e8449e58d0900f063191855","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceListenerAdapter.java","status":"modified","additions":110,"deletions":104,"changes":214,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceListenerAdapter.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceListenerAdapter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceListenerAdapter.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"deb1701809cd3950c542e483e8cdeb62e9195fab","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataDefaults.java","status":"modified","additions":253,"deletions":240,"changes":493,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataDefaults.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ca743625f799611a6eab7819a117af858e283321","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java","status":"modified","additions":400,"deletions":383,"changes":783,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"95314373058158d04d342e7bfe1ec1107c506653","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProductDerivation.java","status":"modified","additions":69,"deletions":63,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProductDerivation.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b263af5fbad9a2b91e44f79e967b01d7c1ecdbaf","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","status":"modified","additions":122,"deletions":112,"changes":234,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"f8e812c1ef31cc24f7310a8826e52257279e85b6","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceStrategy.java","status":"modified","additions":41,"deletions":36,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceStrategy.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a8e60711c982489fc4cf886b4bcd05468abf98f9","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceUnitInfoImpl.java","status":"modified","additions":456,"deletions":433,"changes":889,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceUnitInfoImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceUnitInfoImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceUnitInfoImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"5ca78ccd1128e26343b7896d6a03491dfdbc8bd2","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Persistent.java","status":"modified","additions":45,"deletions":42,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Persistent.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Persistent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Persistent.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"789fb3a91c1e2fc56c9eadf4fb27cb04fc89a9b8","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentCollection.java","status":"modified","additions":45,"deletions":42,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentCollection.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentCollection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentCollection.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"182372ba3b56d983ca0bbde1e40bb2d8d4408e72","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentMap.java","status":"modified","additions":49,"deletions":46,"changes":95,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentMap.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentMap.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"fc4f5f20554d4d538b24a0446a29b0dced0ef4e2","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","status":"modified","additions":523,"deletions":497,"changes":1020,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"5ce7418d627a034db8a8616140978ea3b3bd741d","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCache.java","status":"modified","additions":114,"deletions":111,"changes":225,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCache.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCache.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"ff85dd505c21174a9bb016f4839735161c6aeb56","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ReadOnly.java","status":"modified","additions":35,"deletions":32,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ReadOnly.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ReadOnly.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ReadOnly.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"13dc53960019daebaec329831eacb2a879d4fd87","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RollbackException.java","status":"modified","additions":98,"deletions":93,"changes":191,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RollbackException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RollbackException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RollbackException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"98e968c80badfc15509ae0af5af7a89a74ad8e42","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java","status":"modified","additions":197,"deletions":191,"changes":388,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"faed3d26a9b1bec97aadae6d2d13f82c0cd7b33b","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/TransactionRequiredException.java","status":"modified","additions":108,"deletions":104,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/TransactionRequiredException.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/TransactionRequiredException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/TransactionRequiredException.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"d0f13d28f40b9a5325457fd81e231b140e5ba049","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Type.java","status":"modified","additions":36,"deletions":33,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Type.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Type.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Type.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"54ae469b7df706e503c07a79cd4fdc6f34c6490d","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/UpdateAction.java","status":"modified","additions":27,"deletions":24,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/UpdateAction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/UpdateAction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/UpdateAction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"6b8a774931c793c6b4ff9e8a2ff2c22bf78e8684","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","status":"modified","additions":1638,"deletions":1524,"changes":3162,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"99daf86b966fc0d04aeefa9c5b9b5299fe74c67d","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataSerializer.java","status":"modified","additions":1413,"deletions":1341,"changes":2754,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataSerializer.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"a4b83fb847b05f22d14d9965d29dcbe7d687a733","filename":"openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/ObjectData.java","status":"modified","additions":392,"deletions":358,"changes":750,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/ObjectData.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/ObjectData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/ObjectData.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"9cad00be47eef8598e638fac8db84c4578ff18b5","filename":"openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLConfiguration.java","status":"modified","additions":73,"deletions":67,"changes":140,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLConfiguration.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"e3c3c141bba746410250a185124f3dd05067d4a6","filename":"openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLFileHandler.java","status":"modified","additions":668,"deletions":599,"changes":1267,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLFileHandler.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLFileHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLFileHandler.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"cdeab57181a38155f70226b4e1a87d4f45b188ca","filename":"openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStore.java","status":"modified","additions":160,"deletions":151,"changes":311,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStore.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStore.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStore.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"6b6ee667ba225d78f3c2796107a0fd8313ee0dfb","filename":"openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStoreManager.java","status":"modified","additions":293,"deletions":261,"changes":554,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStoreManager.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"4dbb01585ff17611f7d780c5dc18fdd455461b73","filename":"serp/src/main/java/serp/bytecode/BCClass.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCClass.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCClass.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"fe33dd0580d42a6da29d7cb081124c36b0bded55","filename":"serp/src/main/java/serp/bytecode/BCField.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCField.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCField.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCField.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"4d05719a8d05bbd344339dbf033efb6858f44db6","filename":"serp/src/main/java/serp/bytecode/BCMethod.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCMethod.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/BCMethod.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCMethod.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"51eed6f84ffd6cd1177a08fb4466b985a2a2af71","filename":"serp/src/main/java/serp/bytecode/Code.java","status":"modified","additions":13,"deletions":13,"changes":26,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Code.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Code.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Code.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"32c8d75b2160ab14ae395db7bf78458275c36a20","filename":"serp/src/main/java/serp/bytecode/FieldInstruction.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/FieldInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/FieldInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/FieldInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"e13992fcf9197188380d44770b68af237a46c25f","filename":"serp/src/main/java/serp/bytecode/InnerClasses.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/InnerClasses.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/InnerClasses.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/InnerClasses.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"5267604bc8560b320cdc805221d369a66b53bd13","filename":"serp/src/main/java/serp/bytecode/MethodInstruction.java","status":"modified","additions":15,"deletions":15,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/MethodInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/MethodInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MethodInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"fd2c1316b20eb48839b7dc9b3615bd4f1beaf7fc","filename":"serp/src/main/java/serp/bytecode/NameCache.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/NameCache.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/NameCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/NameCache.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"31059392abe992078e7dcc6ffd8f1e591179e30a","filename":"serp/src/main/java/serp/bytecode/Project.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Project.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/Project.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Project.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b453b70ed6d35fc7e2f2ab548f98dab22b367631","filename":"serp/src/main/java/serp/bytecode/TypedInstruction.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/TypedInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/TypedInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/TypedInstruction.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"2fef199b2fc0847d63b5dd01d8836207110d0222","filename":"serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"083eb9638c1accd149ddc3b6f287e2963a3458fe","filename":"serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"617196ab4f996e64e4cfb20f87a6810b12b2384d","filename":"serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java","status":"modified","additions":34,"deletions":34,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"6de2db13a6ea5c070a4b1a358939b612a0816738","filename":"serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"61ec943691e340e86ce522790f22001fd66aba00","filename":"serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"b436bf84c981a3816508545c111a708880e3f612","filename":"serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java","status":"modified","additions":32,"deletions":1,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"},{"sha":"8c223bacf75ccc0ae74c8aeae031d55811c6d911","filename":"serp/src/main/java/serp/util/Strings.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/util/Strings.java","raw_url":"https://github.com/apache/openjpa/raw/7a6d34e95f66e916e44b844b1ce6551ba8169539/serp/src/main/java/serp/util/Strings.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/util/Strings.java?ref=7a6d34e95f66e916e44b844b1ce6551ba8169539"}]}

