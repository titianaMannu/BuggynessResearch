{"sha":"7cece296b3e9183aae9dd49abfa235612ab26036","node_id":"MDY6Q29tbWl0MjA2MzY0OjdjZWNlMjk2YjNlOTE4M2FhZTlkZDQ5YWJmYTIzNTYxMmFiMjYwMzY=","commit":{"author":{"name":"A. Abram White","email":"awhite@apache.org","date":"2008-04-08T21:29:19Z"},"committer":{"name":"A. Abram White","email":"awhite@apache.org","date":"2008-04-08T21:29:19Z"},"message":"More efficient fix for OPENJPA-245.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.1.x@646082 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1d0735a725ac9a19ce215ed13dec55c5fc8f0c3e","url":"https://api.github.com/repos/apache/openjpa/git/trees/1d0735a725ac9a19ce215ed13dec55c5fc8f0c3e"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/7cece296b3e9183aae9dd49abfa235612ab26036","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/7cece296b3e9183aae9dd49abfa235612ab26036","html_url":"https://github.com/apache/openjpa/commit/7cece296b3e9183aae9dd49abfa235612ab26036","comments_url":"https://api.github.com/repos/apache/openjpa/commits/7cece296b3e9183aae9dd49abfa235612ab26036/comments","author":null,"committer":null,"parents":[{"sha":"a82b7332f1a42dfe96b2b81a1bb7a0cf66cb5a01","url":"https://api.github.com/repos/apache/openjpa/commits/a82b7332f1a42dfe96b2b81a1bb7a0cf66cb5a01","html_url":"https://github.com/apache/openjpa/commit/a82b7332f1a42dfe96b2b81a1bb7a0cf66cb5a01"}],"stats":{"total":219,"additions":167,"deletions":52},"files":[{"sha":"5b056f92864ff432639da4395de86ffa7504ae5d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","status":"modified","additions":86,"deletions":41,"changes":127,"blob_url":"https://github.com/apache/openjpa/blob/7cece296b3e9183aae9dd49abfa235612ab26036/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","raw_url":"https://github.com/apache/openjpa/raw/7cece296b3e9183aae9dd49abfa235612ab26036/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java?ref=7cece296b3e9183aae9dd49abfa235612ab26036","patch":"@@ -118,7 +118,10 @@\n     public static final int ENHANCE_INTERFACE = 2 << 1;\n     public static final int ENHANCE_PC = 2 << 2;\n \n-    private static final String PRE = \"pc\";\n+    public static final String PRE = \"pc\";\n+    public static final String ISDETACHEDSTATEDEFINITIVE = PRE \n+        + \"isDetachedStateDefinitive\";\n+\n     private static final Class PCTYPE = PersistenceCapable.class;\n     private static final String SM = PRE + \"StateManager\";\n     private static final Class SMTYPE = StateManager.class;\n@@ -2999,27 +3002,45 @@ private void modifyReadObjectMethod(BCMethod method, boolean full) {\n      */\n     private void addIsDetachedMethod()\n         throws NoSuchMethodException {\n-        // public boolean pcIsDetached ()\n+        // public boolean pcIsDetached()\n         BCMethod method = _pc.declareMethod(PRE + \"IsDetached\",\n             Boolean.class, null);\n         method.makePublic();\n         Code code = method.getCode(true);\n-        writeIsDetachedMethod(code);\n+        boolean needsDefinitiveMethod = writeIsDetachedMethod(code);\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+        if (!needsDefinitiveMethod) \n+            return;\n+\n+        // private boolean pcIsDetachedStateDefinitive()\n+        //   return false;\n+        // auxilliary enhancers may change the return value of this method\n+        // if their specs consider detached state definitive\n+        method = _pc.declareMethod(ISDETACHEDSTATEDEFINITIVE, boolean.class,\n+            null);\n+        method.makePrivate();\n+        code = method.getCode(true);\n+        code.constant().setValue(false);\n+        code.ireturn();\n         code.calculateMaxStack();\n         code.calculateMaxLocals();\n     }\n \n     /**\n      * Creates the body of the pcIsDetached() method to determine if an\n      * instance is detached.\n+     *\n+     * @return true if we need a pcIsDetachedStateDefinitive method, false\n+     * otherwise\n      */\n-    private void writeIsDetachedMethod(Code code)\n+    private boolean writeIsDetachedMethod(Code code)\n         throws NoSuchMethodException {\n         // not detachable: return Boolean.FALSE\n         if (!_meta.isDetachable()) {\n             code.getstatic().setField(Boolean.class, \"FALSE\", Boolean.class);\n             code.areturn();\n-            return;\n+            return false;\n         }\n \n         // if (sm != null)\n@@ -3067,7 +3088,7 @@ private void writeIsDetachedMethod(Code code)\n                 ifins.setTarget(target);\n                 notdeser.setTarget(target);\n                 code.areturn();\n-                return;\n+                return false;\n             }\n         }\n \n@@ -3077,9 +3098,9 @@ private void writeIsDetachedMethod(Code code)\n         if (notdeser != null)\n             notdeser.setTarget(target);\n \n-        // allow users with version fields to manually construct a \"detached\"\n-        // instance, so check version before taking into account non-existent\n-        // detached state\n+        // allow users with version or auto-assigned pk fields to manually \n+        // construct a \"detached\" instance, so check these before taking into \n+        // account non-existent detached state\n \n         // consider detached if version is non-default\n         FieldMetaData version = _meta.getVersionField();\n@@ -3094,41 +3115,13 @@ private void writeIsDetachedMethod(Code code)\n             ifins.setTarget(code.getstatic().setField(Boolean.class, \"FALSE\",\n                 Boolean.class));\n             code.areturn();\n-            return;\n-        }\n-\n-        // no detached state: if instance uses detached state and it's not\n-        // synthetic or the instance is not serializable or the state isn't\n-        // transient, must not be detached\n-        if (state == null\n-            && (!ClassMetaData.SYNTHETIC.equals(_meta.getDetachedState())\n-            || !Serializable.class.isAssignableFrom(_meta.getDescribedType())\n-            || !_repos.getConfiguration().getDetachStateInstance().\n-            isDetachedStateTransient())) {\n-            // return Boolean.FALSE\n-            code.getstatic().setField(Boolean.class, \"FALSE\", Boolean.class);\n-            code.areturn();\n-            return;\n-        }\n-\n-        // no detached state: if instance uses detached state (and must be\n-        // synthetic and transient in serializable instance at this point),\n-        // not detached if state not set to DESERIALIZED\n-        if (state == null) {\n-            // if (pcGetDetachedState () == null) // instead of DESERIALIZED\n-            //     return Boolean.FALSE;\n-            loadManagedInstance(code, false);\n-            code.invokevirtual().setMethod(PRE + \"GetDetachedState\",\n-                Object.class, null);\n-            ifins = code.ifnonnull();\n-            code.getstatic().setField(Boolean.class, \"FALSE\", Boolean.class);\n-            code.areturn();\n-            ifins.setTarget(code.nop());\n+            return false;\n         }\n \n         // consider detached if auto-genned primary keys are non-default\n         ifins = null;\n         JumpInstruction ifins2 = null;\n+        boolean hasAutoAssignedPK = false;\n         if (state != Boolean.TRUE\n             && _meta.getIdentityType() == ClassMetaData.ID_APPLICATION) {\n             // for each pk field:\n@@ -3162,13 +3155,65 @@ private void writeIsDetachedMethod(Code code)\n             }\n         }\n \n-        // give up; we just don't know\n-        target = code.constant().setNull();\n+        // create artificial target to simplify\n+        target = code.nop();\n         if (ifins != null)\n             ifins.setTarget(target);\n         if (ifins2 != null)\n             ifins2.setTarget(target);\n+\n+        // if has auto-assigned pk and we get to this point, must have default\n+        // value, so must be new instance\n+        if (hasAutoAssignedPK) {\n+            code.getstatic().setField(Boolean.class, \"FALSE\", Boolean.class);\n+            code.areturn();\n+            return false;\n+        }\n+\n+        // if detached state is not definitive, just give up now and return\n+        // null so that the runtime will perform a DB lookup to determine\n+        // whether we're detached or new\n+        code.aload().setThis();\n+        code.invokespecial().setMethod(ISDETACHEDSTATEDEFINITIVE, boolean.class,\n+            null);\n+        ifins = code.ifne();\n+        code.constant().setNull();\n         code.areturn();\n+        ifins.setTarget(code.nop());\n+\n+        // no detached state: if instance uses detached state and it's not\n+        // synthetic or the instance is not serializable or the state isn't\n+        // transient, must not be detached\n+        if (state == null\n+            && (!ClassMetaData.SYNTHETIC.equals(_meta.getDetachedState())\n+            || !Serializable.class.isAssignableFrom(_meta.getDescribedType())\n+            || !_repos.getConfiguration().getDetachStateInstance().\n+            isDetachedStateTransient())) {\n+            // return Boolean.FALSE\n+            code.getstatic().setField(Boolean.class, \"FALSE\", Boolean.class);\n+            code.areturn();\n+            return true;\n+        }\n+\n+        // no detached state: if instance uses detached state (and must be\n+        // synthetic and transient in serializable instance at this point),\n+        // not detached if state not set to DESERIALIZED\n+        if (state == null) {\n+            // if (pcGetDetachedState () == null) // instead of DESERIALIZED\n+            //     return Boolean.FALSE;\n+            loadManagedInstance(code, false);\n+            code.invokevirtual().setMethod(PRE + \"GetDetachedState\",\n+                Object.class, null);\n+            ifins = code.ifnonnull();\n+            code.getstatic().setField(Boolean.class, \"FALSE\", Boolean.class);\n+            code.areturn();\n+            ifins.setTarget(code.nop());\n+        }\n+\n+        // give up; we just don't know\n+        code.constant().setNull();\n+        code.areturn();\n+        return true;\n     }\n \n     /**"},{"sha":"c01dcb2fa9ea5ff0238e5b5b8d2f733fb27dba47","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","status":"modified","additions":1,"deletions":8,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7cece296b3e9183aae9dd49abfa235612ab26036/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7cece296b3e9183aae9dd49abfa235612ab26036/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java?ref=7cece296b3e9183aae9dd49abfa235612ab26036","patch":"@@ -69,19 +69,12 @@ protected void provideField(Object toAttach, StateManagerImpl sm,\n     public Object attach(AttachManager manager, Object toAttach,\n         ClassMetaData meta, PersistenceCapable into, OpenJPAStateManager owner,\n         ValueMetaData ownerMeta, boolean explicit) {\n-\n-        // VersionAttachStrategy is invoked in the case where no more\n-        // intelligent strategy could be found; let's be more lenient\n-        // about new vs. detached record determination.\n-        if (into == null)\n-            into = findFromDatabase(manager, toAttach);\n-\n         BrokerImpl broker = manager.getBroker();\n         PersistenceCapable pc = ImplHelper.toPersistenceCapable(toAttach,\n             meta.getRepository().getConfiguration());\n \n         boolean embedded = ownerMeta != null && ownerMeta.isEmbeddedPC();\n-        boolean isNew = !broker.isDetached(pc) && into == null;\n+        boolean isNew = !broker.isDetached(pc);\n         Object version = null;\n         StateManagerImpl sm;\n "},{"sha":"5c8d7373278ea5e45cc3a7cde5ed05b4498b9c5d","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","status":"modified","additions":4,"deletions":2,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7cece296b3e9183aae9dd49abfa235612ab26036/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/7cece296b3e9183aae9dd49abfa235612ab26036/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties?ref=7cece296b3e9183aae9dd49abfa235612ab26036","patch":"@@ -116,7 +116,9 @@ not-managed: The given instance \"{0}\" is not managed by this context.\n trans-not-managed: This broker is not configured to use managed transactions.\n bad-detached-op: You cannot perform operation {0} on detached object \"{1}\". \\\n \tThis operation only applies to managed objects.\n-persist-detached: Attempt to persist detached object \"{0}\".\n+persist-detached: Attempt to persist detached object \"{0}\".  If this is a new \\\n+  instance, make sure any versino and/or auto-generated primary key fields are \\\n+  null/default when persisting.\n null-value: The field \"{0}\" of instance \"{1}\" contained a null value; \\\n \tthe metadata for this field specifies that nulls are illegal.\n change-identity: Attempt to change a primary key field of an instance that \\\n@@ -396,4 +398,4 @@ cant-serialize-pessimistic-broker: Serialization not allowed for brokers with \\\n     an active datastore (pessimistic) transaction.\n cant-serialize-connected-broker: Serialization not allowed for brokers with \\\n     an active connection to the database.\n-no-interface-metadata: No metadata was found for managed interface {0}.\n\\ No newline at end of file\n+no-interface-metadata: No metadata was found for managed interface {0}."},{"sha":"1af43571a18b059746bd388ddb137f29d087e50c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/TestAttachConstructedCopy.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/7cece296b3e9183aae9dd49abfa235612ab26036/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/TestAttachConstructedCopy.java","raw_url":"https://github.com/apache/openjpa/raw/7cece296b3e9183aae9dd49abfa235612ab26036/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/TestAttachConstructedCopy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/TestAttachConstructedCopy.java?ref=7cece296b3e9183aae9dd49abfa235612ab26036","patch":"@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.detachment;\n+\n+import javax.persistence.EntityManager;\n+\n+import junit.textui.TestRunner;\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+/**\n+ * Test that manually constructing instances with existing primary key values\n+ * and attaching them works.\n+ *\n+ * @author Abe White\n+ */\n+public class TestAttachConstructedCopy\n+    extends SingleEMFTestCase {\n+\n+    public void setUp() {\n+        setUp(Record.class);\n+    }\n+\n+    public void testAttachConstructedCopyWithGeneratedPKAndNoVersion() {\n+        Record record = new Record();\n+        record.setContent(\"orig\");\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        em.persist(record);\n+        em.getTransaction().commit();\n+        em.close();\n+        int id = record.getId();\n+\n+        Record copy = new Record();\n+        copy.setId(id);\n+        copy.setContent(\"new\");\n+\n+        em = emf.createEntityManager();\n+        em.getTransaction().begin(); \n+        record = em.merge(copy);\n+        assertTrue(record != copy);\n+        assertEquals(\"new\", record.getContent());\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        em = emf.createEntityManager();\n+        record = em.find(Record.class, id);\n+        assertEquals(\"new\", record.getContent());\n+        em.close();\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(TestAttachConstructedCopy.class);\n+    }\n+}\n+"},{"sha":"0ed8ca61147bd7c389090d247336ea0509a6a65e","filename":"openjpa-project/src/doc/manual/ref_guide_remote.xml","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/7cece296b3e9183aae9dd49abfa235612ab26036/openjpa-project/src/doc/manual/ref_guide_remote.xml","raw_url":"https://github.com/apache/openjpa/raw/7cece296b3e9183aae9dd49abfa235612ab26036/openjpa-project/src/doc/manual/ref_guide_remote.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_remote.xml?ref=7cece296b3e9183aae9dd49abfa235612ab26036","patch":"@@ -173,7 +173,10 @@ attached instance's corresponding fields to null.\n                     <para>\n If the instance has a <literal>Version</literal> field,\n OpenJPA will consider the object detached if the version field has a non-default\n-value, and new otherwise.\n+value, and new otherwise.  Similarly, if the instance has \n+<literal>GeneratedValue</literal> primary key fields, OpenJPA will consider the\n+object detached if any of these fields have non-default values, and new \n+otherwise.\n                     </para>\n                     <para>\n When attaching null fields in these cases, OpenJPA cannot distinguish between a"}]}

