{"sha":"7d1c8fccafcd31919a79edf46969c5662e2704b5","node_id":"MDY6Q29tbWl0MjA2MzY0OjdkMWM4ZmNjYWZjZDMxOTE5YTc5ZWRmNDY5NjljNTY2MmUyNzA0YjU=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-19T21:34:44Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-19T21:34:44Z"},"message":"OpenJPA JDBC subsystem; reformatted some core OpenJPA code to move catch and finally blocks around.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@423615 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"be4d9e542f71a74f7c6aa343f8d6ec98f572240c","url":"https://api.github.com/repos/apache/openjpa/git/trees/be4d9e542f71a74f7c6aa343f8d6ec98f572240c"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/7d1c8fccafcd31919a79edf46969c5662e2704b5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/7d1c8fccafcd31919a79edf46969c5662e2704b5","html_url":"https://github.com/apache/openjpa/commit/7d1c8fccafcd31919a79edf46969c5662e2704b5","comments_url":"https://api.github.com/repos/apache/openjpa/commits/7d1c8fccafcd31919a79edf46969c5662e2704b5/comments","author":null,"committer":null,"parents":[{"sha":"f9eb746445e84c4d2fab223175ed54cdac45cede","url":"https://api.github.com/repos/apache/openjpa/commits/f9eb746445e84c4d2fab223175ed54cdac45cede","html_url":"https://github.com/apache/openjpa/commit/f9eb746445e84c4d2fab223175ed54cdac45cede"}],"stats":{"total":83470,"additions":81398,"deletions":2072},"files":[{"sha":"127feccf31708fa8542b94065cc2cea8a984b5e4","filename":"openjpa-jdbc-5/pom.xml","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc-5/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc-5/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc-5/pom.xml?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,51 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.apache.openjpa</groupId>\n+    <artifactId>openjpa-jdbc-5</artifactId>\n+    <packaging>jar</packaging>\n+\n+    <name>JDBC 1.5</name>\n+    <description>JDBC 1.5</description>\n+    <url>http://incubator.apache.org/projects/openjpa</url>\n+    <parent>\n+\n+        <groupId>org.apache.openjpa</groupId>\n+        <artifactId>openjpa</artifactId>\n+        <version>0.0.1</version>\n+\n+    </parent>\n+    <dependencies>\n+\n+        <dependency>\n+\n+            <groupId>org.apache.openjpa</groupId>\n+            <artifactId>openjpa-jdbc</artifactId>\n+            <version>0.0.1</version>\n+            <scope>compile</scope>\n+\n+        </dependency>\n+\n+    </dependencies>\n+    <build>\n+\n+        <plugins>\n+\n+            <plugin>\n+\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>1.5</source>\n+                    <target>1.5</target>\n+                </configuration>\n+\n+            </plugin>\n+\n+        </plugins>\n+\n+    </build>\n+\n+\n+</project>"},{"sha":"7b83c103c3910c2d56d823c97c08fb932412d6b2","filename":"openjpa-jdbc-5/src/main/java/org/apache/openjpa/jdbc/kernel/JDBC3SavepointManager.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc-5/src/main/java/org/apache/openjpa/jdbc/kernel/JDBC3SavepointManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc-5/src/main/java/org/apache/openjpa/jdbc/kernel/JDBC3SavepointManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc-5/src/main/java/org/apache/openjpa/jdbc/kernel/JDBC3SavepointManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Savepoint;\n+\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * {@link SavepointManager} implementation that uses JDBC 3 savepoints\n+ * to store state. This plugin has the side effect of triggering\n+ * a flush on the {@link Broker}.\n+ * \n+ * <b>Note that this plugin requires a database and JDBC driver which\n+ * supports JDBC 3 savepoints</b>\n+ *\n+ * @author Steve Kim\n+ * @since 3.4\n+ */\n+public class JDBC3SavepointManager\n+    extends AbstractJDBCSavepointManager {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (JDBC3SavepointManager.class);\n+\n+    protected void rollbackDataStore(ConnectionSavepoint savepoint) {\n+        try {\n+            Connection conn = savepoint.getConnection();\n+            conn.rollback((Savepoint) savepoint.getDataStoreSavepoint());\n+        } catch (SQLException sqe) {\n+            throw new UserException(_loc.get(\"error-rollback\",\n+                savepoint.getName()), sqe);\n+        }\n+    }\n+\n+    protected void setDataStore(ConnectionSavepoint savepoint) {\n+        try {\n+            Connection conn = savepoint.getConnection();\n+            savepoint.setDataStoreSavepoint(conn.setSavepoint\n+                (savepoint.getName()));\n+        } catch (SQLException sqe) {\n+            throw new UserException(_loc.get(\"error-save\",\n+                savepoint.getName()), sqe);\n+        }\n+    }\n+}"},{"sha":"286c93b027a17a9ca72c7f31e5289af625c77d64","filename":"openjpa-jdbc-5/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java","status":"added","additions":100,"deletions":0,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc-5/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc-5/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc-5/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.lang.reflect.Method;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ValueMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.MetaDataException;\n+\n+/**\n+ * Value handler for JDK1.5 enum field types.\n+ *\n+ * @nojavadoc\n+ */\n+public class EnumValueHandler\n+    extends AbstractValueHandler {\n+\n+    private Enum[] _vals = null;\n+    private boolean _ordinal = false;\n+\n+    /**\n+     * Whether to store the enum value as its ordinal.\n+     */\n+    public boolean getStoreOrdinal() {\n+        return _ordinal;\n+    }\n+\n+    /**\n+     * Whether to store the enum value as its ordinal.\n+     */\n+    public void setStoreOrdinal(boolean ordinal) {\n+        _ordinal = ordinal;\n+    }\n+\n+    public Column[] map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt) {\n+        // all enum classes have a static method called 'values()'\n+        // that returns an array of all the enum values\n+        try {\n+            Method m = vm.getType().getMethod(\"values\", (Class[]) null);\n+            _vals = (Enum[]) m.invoke(null, (Object[]) null);\n+        } catch (Exception e) {\n+            throw new MetaDataException().setCause(e);\n+        }\n+\n+        Column col = new Column();\n+        col.setName(name);\n+        if (_ordinal)\n+            col.setJavaType(JavaTypes.SHORT);\n+        else {\n+            // look for the longest enum value name; use 20 as min length to\n+            // leave room for future long names\n+            int len = 20;\n+            for (int i = 0; i < _vals.length; i++)\n+                len = Math.max(_vals[i].name().length(), len);\n+\n+            col.setJavaType(JavaTypes.STRING);\n+            col.setSize(len);\n+        }\n+        return new Column[]{ col };\n+    }\n+\n+    public boolean isVersionable() {\n+        return true;\n+    }\n+\n+    public Object toDataStoreValue(ValueMapping vm, Object val,\n+        JDBCStore store) {\n+        if (val == null)\n+            return null;\n+        if (_ordinal)\n+            return new Integer(((Enum) val).ordinal());\n+        return ((Enum) val).name();\n+    }\n+\n+    public Object toObjectValue(ValueMapping vm, Object val) {\n+        if (val == null)\n+            return null;\n+        if (_ordinal)\n+            return _vals[((Number) val).intValue()];\n+        return Enum.valueOf(vm.getType(), (String) val);\n+    }\n+}"},{"sha":"fd25a050b45eefc39b0d81a68b9b25be8c94a858","filename":"openjpa-jdbc/pom.xml","status":"added","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/pom.xml?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,59 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.apache.openjpa</groupId>\n+    <artifactId>openjpa-jdbc</artifactId>\n+    <packaging>jar</packaging>\n+\n+    <name>JDBC</name>\n+    <description>JDBC</description>\n+    <url>http://incubator.apache.org/projects/openjpa</url>\n+    <parent>\n+\n+        <groupId>org.apache.openjpa</groupId>\n+        <artifactId>openjpa</artifactId>\n+        <version>0.0.1</version>\n+\n+    </parent>\n+    <dependencies>\n+\n+        <dependency>\n+\n+            <groupId>org.apache.openjpa</groupId>\n+            <artifactId>openjpa-kernel</artifactId>\n+            <version>0.0.1</version>\n+            <scope>compile</scope>\n+\n+        </dependency>\n+        <dependency>\n+\n+            <groupId>hsqldb</groupId>\n+            <artifactId>hsqldb</artifactId>\n+            <version>1.8.0.1</version>\n+            <scope>compile</scope>\n+\n+        </dependency>\n+\n+    </dependencies>\n+    <build>\n+\n+        <plugins>\n+\n+            <plugin>\n+\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>1.3</source>\n+                    <target>1.3</target>\n+                </configuration>\n+\n+            </plugin>\n+\n+        </plugins>\n+\n+    </build>\n+\n+\n+</project>"},{"sha":"054a288e3d2b10c6deb987c1d839da4403f9e08d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/MappingToolTask.java","status":"added","additions":211,"deletions":0,"changes":211,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/MappingToolTask.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/MappingToolTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/MappingToolTask.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.ant;\n+\n+import org.apache.tools.ant.BuildException;\n+import org.apache.tools.ant.types.EnumeratedAttribute;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.jdbc.meta.MappingTool;\n+import org.apache.openjpa.jdbc.schema.SchemaTool;\n+import org.apache.openjpa.lib.ant.AbstractTask;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.util.Files;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.MultiLoaderClassResolver;\n+\n+/**\n+ * Executes the {@link MappingTool} on the specified files.\n+ * This task can take the following arguments:\n+ * <ul>\n+ * <li><code>action</code></li>\n+ * <li><code>meta</code></li>\n+ * <li><code>schemaAction</code></li>\n+ * <li><code>dropTables</code></li>\n+ * <li><code>ignoreErrors</code></li>\n+ * <li><code>readSchema</code></li>\n+ * <li><code>primaryKeys</code></li>\n+ * <li><code>foreignKeys</code></li>\n+ * <li><code>indexes</code></li>\n+ * <li><code>file</code></li>\n+ * <li><code>schemaFile</code></li>\n+ * <li><code>sqlFile</code></li>\n+ * </ul> Of these arguments, only <code>action</code> is required.\n+ */\n+public class MappingToolTask\n+    extends AbstractTask {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (MappingToolTask.class);\n+\n+    protected MappingTool.Flags flags = new MappingTool.Flags();\n+    protected String file = null;\n+    protected String schemaFile = null;\n+    protected String sqlFile = null;\n+\n+    /**\n+     * Set the enumerated MappingTool action type.\n+     */\n+    public void setAction(Action act) {\n+        flags.action = act.getValue();\n+    }\n+\n+    /**\n+     * Set the enumerated SchemaTool action type.\n+     */\n+    public void setSchemaAction(SchemaAction act) {\n+        flags.schemaAction = act.getValue();\n+    }\n+\n+    /**\n+     * Set whether the MappingTool should read the full schema.\n+     */\n+    public void setReadSchema(boolean readSchema) {\n+        flags.readSchema = readSchema;\n+    }\n+\n+    /**\n+     * Set whether we want the MappingTool to ignore SQL errors.\n+     */\n+    public void setIgnoreErrors(boolean ignoreErrors) {\n+        flags.ignoreErrors = ignoreErrors;\n+    }\n+\n+    /**\n+     * Set whether the MappingTool should drop tables.\n+     */\n+    public void setDropTables(boolean dropTables) {\n+        flags.dropTables = dropTables;\n+    }\n+\n+    /**\n+     * Set whether to drop OpenJPA tables.\n+     */\n+    public void setOpenJPATables(boolean openjpaTables) {\n+        flags.openjpaTables = openjpaTables;\n+    }\n+\n+    /**\n+     * Set whether the MappingTool should drop sequences.\n+     */\n+    public void setDropSequences(boolean dropSequences) {\n+        flags.dropSequences = dropSequences;\n+    }\n+\n+    /**\n+     * Set whether the MappingTool should manipulate sequences.\n+     */\n+    public void setSequences(boolean sequences) {\n+        flags.sequences = sequences;\n+    }\n+\n+    /**\n+     * Set whether to generate primary key information.\n+     */\n+    public void setPrimaryKeys(boolean pks) {\n+        flags.primaryKeys = pks;\n+    }\n+\n+    /**\n+     * Set whether to generate foreign key information.\n+     */\n+    public void setForeignKeys(boolean fks) {\n+        flags.foreignKeys = fks;\n+    }\n+\n+    /**\n+     * Set whether to generate index information.\n+     */\n+    public void setIndexes(boolean idxs) {\n+        flags.indexes = idxs;\n+    }\n+\n+    /**\n+     * Set the output file we want the MappingTool to write to.\n+     */\n+    public void setFile(String file) {\n+        this.file = file;\n+    }\n+\n+    /**\n+     * Set the output file for an XML representation of the planned schema.\n+     */\n+    public void setSchemaFile(String schemaFile) {\n+        this.schemaFile = schemaFile;\n+    }\n+\n+    /**\n+     * Set the output file we want the MappingTool to write a SQL script to.\n+     */\n+    public void setSQLFile(String sqlFile) {\n+        this.sqlFile = sqlFile;\n+    }\n+\n+    /**\n+     * Set whether this action applies to metadata as well as mappings.\n+     */\n+    public void setMeta(boolean meta) {\n+        flags.meta = meta;\n+    }\n+\n+    protected Configuration newConfiguration() {\n+        return new JDBCConfigurationImpl();\n+    }\n+\n+    protected void executeOn(String[] files)\n+        throws Exception {\n+        if (MappingTool.ACTION_IMPORT.equals(flags.action))\n+            assertFiles(files);\n+\n+        ClassLoader loader = getClassLoader();\n+        if (flags.meta && MappingTool.ACTION_ADD.equals(flags.action))\n+            flags.metaDataFile = Files.getFile(file, loader);\n+        else\n+            flags.mappingWriter = Files.getWriter(file, loader);\n+        flags.schemaWriter = Files.getWriter(schemaFile, loader);\n+        flags.sqlWriter = Files.getWriter(sqlFile, loader);\n+\n+        MultiLoaderClassResolver resolver = new MultiLoaderClassResolver();\n+        resolver.addClassLoader(loader);\n+        resolver.addClassLoader(MappingTool.class.getClassLoader());\n+        JDBCConfiguration conf = (JDBCConfiguration) getConfiguration();\n+        conf.setClassResolver(resolver);\n+\n+        if (!MappingTool.run(conf, files, flags, loader))\n+            throw new BuildException(_loc.get(\"bad-conf\", \"MappingToolTask\"));\n+    }\n+\n+    public static class Action\n+        extends EnumeratedAttribute {\n+\n+        public String[] getValues() {\n+            return MappingTool.ACTIONS;\n+        }\n+    }\n+\n+    public static class SchemaAction\n+        extends EnumeratedAttribute {\n+\n+        public String[] getValues() {\n+            String[] actions = new String[SchemaTool.ACTIONS.length + 1];\n+            System.arraycopy(SchemaTool.ACTIONS, 0, actions, 0,\n+                SchemaTool.ACTIONS.length);\n+            actions[actions.length - 1] = \"none\";\n+            return actions;\n+        }\n+    }\n+}\n+"},{"sha":"1904b3c61d42483ed017fa6255f28a461758d7a6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/ReverseMappingToolTask.java","status":"added","additions":257,"deletions":0,"changes":257,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/ReverseMappingToolTask.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/ReverseMappingToolTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/ReverseMappingToolTask.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,257 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.ant;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.Properties;\n+\n+import org.apache.tools.ant.types.EnumeratedAttribute;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.jdbc.meta.PropertiesReverseCustomizer;\n+import org.apache.openjpa.jdbc.meta.ReverseCustomizer;\n+import org.apache.openjpa.jdbc.meta.ReverseMappingTool;\n+import org.apache.openjpa.lib.ant.AbstractTask;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.util.CodeFormat;\n+import org.apache.openjpa.lib.util.Files;\n+\n+/**\n+ * Executes the {@link ReverseMappingTool} on the specified XML files.\n+ * This task can take the following arguments:\n+ * <ul>\n+ * <li><code>package</code></li>\n+ * <li><code>directory</code></li>\n+ * <li><code>useSchemaName</code></li>\n+ * <li><code>useForeignKeyName</code></li>\n+ * <li><code>nullableAsObject</code></li>\n+ * <li><code>blobAsObject</code></li>\n+ * <li><code>typeMap</code></li>\n+ * <li><code>primaryKeyOnJoin</code></li>\n+ * <li><code>useDatastoreIdentity</code></li>\n+ * <li><code>useBuiltinIdentityClass</code></li>\n+ * <li><code>detachable</code></li>\n+ * <li><code>inverseRelations</code></li>\n+ * <li><code>discriminatorStrategy</code></li>\n+ * <li><code>versionStrategy</code></li>\n+ * <li><code>innerIdentityClasses</code></li>\n+ * <li><code>identityClassSuffix</code></li>\n+ * <li><code>metadata</code></li>\n+ * <li><code>customizerClass</code></li>\n+ * <li><code>customizerProperties</code></li>\n+ * </ul> The task also accepts an embedded <code>codeFormat</code> element with\n+ * attributes for the bean properties of the {@link CodeFormat}.\n+ */\n+public class ReverseMappingToolTask\n+    extends AbstractTask {\n+\n+    protected ReverseMappingTool.Flags flags = new ReverseMappingTool.Flags();\n+    protected String dirName = null;\n+    protected String typeMap = null;\n+    protected String customizerProperties = null;\n+    protected String customizerClass =\n+        PropertiesReverseCustomizer.class.getName();\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public ReverseMappingToolTask() {\n+        flags.metaDataLevel = \"package\";\n+        flags.format = new CodeFormat();\n+    }\n+\n+    /**\n+     * Set the package name for the generated classes.\n+     */\n+    public void setPackage(String pkg) {\n+        flags.packageName = pkg;\n+    }\n+\n+    /**\n+     * Set the output directory for the generated classes.\n+     */\n+    public void setDirectory(String dirName) {\n+        this.dirName = dirName;\n+    }\n+\n+    /**\n+     * Set whether to use the schema name when naming the classes.\n+     */\n+    public void setUseSchemaName(boolean useSchemaName) {\n+        flags.useSchemaName = useSchemaName;\n+    }\n+\n+    /**\n+     * Set whether to use foreign key names to name relations.\n+     */\n+    public void setUseForeignKeyName(boolean useForeignKeyName) {\n+        flags.useForeignKeyName = useForeignKeyName;\n+    }\n+\n+    /**\n+     * Set whether to represent nullable columns as primitive wrappers.\n+     */\n+    public void setNullableAsObject(boolean nullableAsObject) {\n+        flags.nullableAsObject = nullableAsObject;\n+    }\n+\n+    /**\n+     * Set whether to represent blob columns as Java objects rather than\n+     * byte[] fields.\n+     */\n+    public void setBlobAsObject(boolean blobAsObject) {\n+        flags.blobAsObject = blobAsObject;\n+    }\n+\n+    /**\n+     * Set the SQL type map overrides.\n+     */\n+    public void setTypeMap(String typeMap) {\n+        this.typeMap = typeMap;\n+    }\n+\n+    /**\n+     * Set whether to allow primary keys on join tables.\n+     */\n+    public void setPrimaryKeyOnJoin(boolean primaryKeyOnJoin) {\n+        flags.primaryKeyOnJoin = primaryKeyOnJoin;\n+    }\n+\n+    /**\n+     * Set whether to use datastore identity by default.\n+     */\n+    public void setUseDataStoreIdentity(boolean useDataStoreIdentity) {\n+        flags.useDataStoreIdentity = useDataStoreIdentity;\n+    }\n+\n+    /**\n+     * Set whether to use single field identity where possible.\n+     */\n+    public void setUseBuiltinIdentityClass(boolean useBuiltinIdentityClass) {\n+        flags.useBuiltinIdentityClass = useBuiltinIdentityClass;\n+    }\n+\n+    /**\n+     * Set whether to generate inverse 1-many/1-1 relations for all many-1/1-1\n+     * relations.\n+     */\n+    public void setInverseRelations(boolean inverseRelations) {\n+        flags.inverseRelations = inverseRelations;\n+    }\n+\n+    /**\n+     * Set whether to make generated classes detachable.\n+     */\n+    public void setDetachable(boolean detachable) {\n+        flags.detachable = detachable;\n+    }\n+\n+    /**\n+     * Default discriminator strategy for base class mappings.\n+     */\n+    public void setDiscriminatorStrategy(String discStrat) {\n+        flags.discriminatorStrategy = discStrat;\n+    }\n+\n+    /**\n+     * Default version strategy for base class mappings.\n+     */\n+    public void setVersionStrategy(String versionStrat) {\n+        flags.versionStrategy = versionStrat;\n+    }\n+\n+    /**\n+     * Whether or not to generate application identity classes as inner classes.\n+     */\n+    public void setInnerIdentityClasses(boolean innerAppId) {\n+        flags.innerIdentityClasses = innerAppId;\n+    }\n+\n+    /**\n+     * The suffix to use to create the identity class name for a class, or\n+     * for inner classes, the name of the inner class.\n+     */\n+    public void setIdentityClassSuffix(String suffix) {\n+        flags.identityClassSuffix = suffix;\n+    }\n+\n+    /**\n+     * Set the level of the generated metadata.\n+     */\n+    public void setMetadata(Level level) {\n+        flags.metaDataLevel = level.getValue();\n+    }\n+\n+    /**\n+     * Set a customizer class to use.\n+     */\n+    public void setCustomizerClass(String customizerClass) {\n+        this.customizerClass = customizerClass;\n+    }\n+\n+    /**\n+     * Set a properties file to pass to the customizer class.\n+     */\n+    public void setCustomizerProperties(String customizerProperties) {\n+        this.customizerProperties = customizerProperties;\n+    }\n+\n+    public Object createCodeFormat() {\n+        return flags.format;\n+    }\n+\n+    protected Configuration newConfiguration() {\n+        return new JDBCConfigurationImpl();\n+    }\n+\n+    protected void executeOn(String[] files)\n+        throws Exception {\n+        ClassLoader loader = getClassLoader();\n+        if (dirName != null && dirName.length() > 0)\n+            flags.directory = Files.getFile(dirName, loader);\n+        if (typeMap != null && typeMap.length() > 0)\n+            flags.typeMap = Configurations.parseProperties(typeMap);\n+\n+        // load customizer properties\n+        Properties customProps = new Properties();\n+        File propsFile = Files.getFile(customizerProperties, loader);\n+        if (propsFile != null && propsFile.exists())\n+            customProps.load(new FileInputStream(propsFile));\n+\n+        // create and configure customizer\n+        JDBCConfiguration conf = (JDBCConfiguration) getConfiguration();\n+        flags.customizer = (ReverseCustomizer) Configurations.\n+            newInstance(customizerClass, conf, null,\n+                ReverseCustomizer.class.getClassLoader());\n+        if (flags.customizer != null)\n+            flags.customizer.setConfiguration(customProps);\n+\n+        ReverseMappingTool.run(conf, files, flags, loader);\n+    }\n+\n+    public static class Level\n+        extends EnumeratedAttribute {\n+\n+        public String[] getValues() {\n+            return new String[]{\n+                \"package\",\n+                \"class\",\n+            };\n+        }\n+    }\n+}"},{"sha":"b1e3c3e3674f0f8f70a002acfd78c18d0c2535a4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/SchemaToolTask.java","status":"added","additions":147,"deletions":0,"changes":147,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/SchemaToolTask.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/SchemaToolTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/SchemaToolTask.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.ant;\n+\n+import org.apache.tools.ant.BuildException;\n+import org.apache.tools.ant.types.EnumeratedAttribute;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.jdbc.schema.SchemaTool;\n+import org.apache.openjpa.lib.ant.AbstractTask;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.util.Files;\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+/**\n+ * Executes the {@link SchemaTool} on the specified XML schema definition\n+ * files. This task can take the following arguments:\n+ * <ul>\n+ * <li><code>action</code></li>\n+ * <li><code>ignoreErrors</code></li>\n+ * <li><code>dropTables</code></li>\n+ * <li><code>dropSequences</code></li>\n+ * <li><code>openjpaTables</code></li>\n+ * <li><code>primaryKeys</code></li>\n+ * <li><code>foreignKeys</code></li>\n+ * <li><code>indexes</code></li>\n+ * <li><code>sequences</code></li>\n+ * <li><code>record</code></li>\n+ * <li><code>file</code></li>\n+ * </ul> Of these arguments, only <code>action</code> is required.\n+ */\n+public class SchemaToolTask\n+    extends AbstractTask {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (SchemaToolTask.class);\n+\n+    protected SchemaTool.Flags flags = new SchemaTool.Flags();\n+    protected String file = null;\n+\n+    /**\n+     * Set the enumerated SchemaTool action type.\n+     */\n+    public void setAction(Action act) {\n+        flags.action = act.getValue();\n+    }\n+\n+    /**\n+     * Set whether we want the SchemaTool to ignore SQL errors.\n+     */\n+    public void setIgnoreErrors(boolean ignoreErrors) {\n+        flags.ignoreErrors = ignoreErrors;\n+    }\n+\n+    /**\n+     * Set whether to drop or reflect on OpenJPA tables.\n+     */\n+    public void setOpenJPATables(boolean openjpaTables) {\n+        flags.openjpaTables = openjpaTables;\n+    }\n+\n+    /**\n+     * Set whether the SchemaTool should drop sequences.\n+     */\n+    public void setDropSequences(boolean dropSequences) {\n+        flags.dropSequences = dropSequences;\n+    }\n+\n+    /**\n+     * Set whether the SchemaTool should manipulate sequences.\n+     */\n+    public void setSequences(boolean sequences) {\n+        flags.sequences = sequences;\n+    }\n+\n+    /**\n+     * Set whether to generate primary key information.\n+     */\n+    public void setPrimaryKeys(boolean pks) {\n+        flags.primaryKeys = pks;\n+    }\n+\n+    /**\n+     * Set whether to generate foreign key information.\n+     */\n+    public void setForeignKeys(boolean fks) {\n+        flags.foreignKeys = fks;\n+    }\n+\n+    /**\n+     * Set whether to generate index information.\n+     */\n+    public void setIndexes(boolean idxs) {\n+        flags.indexes = idxs;\n+    }\n+\n+    /**\n+     * Set whether the SchemaTool should record to the schema factory.\n+     */\n+    public void setRecord(boolean record) {\n+        flags.record = record;\n+    }\n+\n+    /**\n+     * Set the output file we want the SchemaTool to write to.\n+     */\n+    public void setFile(String file) {\n+        this.file = file;\n+    }\n+\n+    protected Configuration newConfiguration() {\n+        return new JDBCConfigurationImpl();\n+    }\n+\n+    protected void executeOn(String[] files)\n+        throws Exception {\n+        assertFiles(files);\n+\n+        ClassLoader loader = getClassLoader();\n+        flags.writer = Files.getWriter(file, loader);\n+        if (!SchemaTool.run((JDBCConfiguration) getConfiguration(), files,\n+            flags, loader))\n+            throw new BuildException(_loc.get(\"bad-conf\", \"SchemaToolTask\"));\n+    }\n+\n+    public static class Action\n+        extends EnumeratedAttribute {\n+\n+        public String[] getValues() {\n+            return SchemaTool.ACTIONS;\n+        }\n+    }\n+}\n+"},{"sha":"cf12d940452b658bf156c9b93058853cd7654732","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/package.html","status":"added","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/package.html","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/package.html?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,9 @@\n+<html>\n+<body>\n+<p><strong>OpenJPA-JDBC Ant Tasks</strong></p>\n+\n+<p>\n+    Ant tasks for JDBC OpenJPA tools.\n+</p>\n+</body>\n+</html>"},{"sha":"f6470cc630993c535b6edf1946ee6d21f08cd369","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/FetchModeValue.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/FetchModeValue.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/FetchModeValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/FetchModeValue.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.conf;\n+\n+import org.apache.openjpa.jdbc.kernel.EagerFetchModes;\n+import org.apache.openjpa.lib.conf.IntValue;\n+\n+/**\n+ * Value type used to represent fetch modes. This type is\n+ * defined separately so that it can be used both in the global configuration\n+ * and in class metadata with the same encapsulated configuration.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class FetchModeValue\n+    extends IntValue {\n+\n+    public static final String EAGER_NONE = \"none\";\n+    public static final String EAGER_JOIN = \"join\";\n+    public static final String EAGER_PARALLEL = \"parallel\";\n+\n+    private static String[] ALIASES = new String[]{\n+        EAGER_PARALLEL, String.valueOf(EagerFetchModes.EAGER_PARALLEL),\n+        EAGER_JOIN, String.valueOf(EagerFetchModes.EAGER_JOIN),\n+        EAGER_NONE, String.valueOf(EagerFetchModes.EAGER_NONE),\n+        // deprecated\n+        \"multiple\", String.valueOf(EagerFetchModes.EAGER_PARALLEL),\n+        \"single\", String.valueOf(EagerFetchModes.EAGER_JOIN),\n+    };\n+\n+    public FetchModeValue(String prop) {\n+        super(prop);\n+        setAliases(ALIASES);\n+    }\n+}"},{"sha":"575c81662064af9a6aa8fd6964d75a528a77f524","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfiguration.java","status":"added","additions":609,"deletions":0,"changes":609,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfiguration.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,609 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.conf;\n+\n+import javax.sql.DataSource;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.jdbc.kernel.EagerFetchModes;\n+import org.apache.openjpa.jdbc.kernel.LRSSizes;\n+import org.apache.openjpa.jdbc.kernel.UpdateManager;\n+import org.apache.openjpa.jdbc.meta.MappingDefaults;\n+import org.apache.openjpa.jdbc.meta.MappingRepository;\n+import org.apache.openjpa.jdbc.schema.DriverDataSource;\n+import org.apache.openjpa.jdbc.schema.SchemaFactory;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.SQLFactory;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.jdbc.ConnectionDecorator;\n+import org.apache.openjpa.lib.jdbc.JDBCEvent;\n+import org.apache.openjpa.lib.jdbc.JDBCListener;\n+import org.apache.openjpa.meta.MetaDataFactory;\n+\n+/**\n+ * Configuration that defines the properties necessary to configure\n+ * runtime and connect to a JDBC DataSource.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+public interface JDBCConfiguration\n+    extends OpenJPAConfiguration {\n+\n+    /**\n+     * Name of the logger for SQL execution messages:\n+     * <code>org.apache.openjpa.jdbc.SQL</code>.\n+     */\n+    public static final String LOG_SQL = \"org.apache.openjpa.jdbc.SQL\";\n+\n+    /**\n+     * Name of the logger for JDBC-related messages:\n+     * <code>org.apache.openjpa.jdbc.JDBC</code>.\n+     */\n+    public static final String LOG_JDBC = \"org.apache.openjpa.jdbc.JDBC\";\n+\n+    /**\n+     * Name of the logger for schema-related messages:\n+     * <code>org.apache.openjpa.jdbc.Schema</code>.\n+     */\n+    public static final String LOG_SCHEMA = \"org.apache.openjpa.jdbc.Schema\";\n+\n+    /**\n+     * Default schema for unqualified tables.\n+     */\n+    public String getSchema();\n+\n+    /**\n+     * Default schema for unqualified tables.\n+     */\n+    public void setSchema(String schema);\n+\n+    /**\n+     * Comma-separated list of modifiable schemas for persistent instances.\n+     */\n+    public String getSchemas();\n+\n+    /**\n+     * Comma-separated list of modifiable schemas for persistent instances.\n+     */\n+    public void setSchemas(String schemas);\n+\n+    /**\n+     * Modificable schema components.\n+     */\n+    public String[] getSchemasList();\n+\n+    /**\n+     * Modifiable schema components.\n+     */\n+    public void setSchemas(String[] schemas);\n+\n+    /**\n+     * The transaction isolation level to use at the database level.\n+     * Possible values are:\n+     * <ul>\n+     * <li><code>default</code>: The JDBC driver's default isolation level.</li>\n+     * <li><code>none</code>: The standard JDBC\n+     * {@link java.sql.Connection#TRANSACTION_NONE} level.</li>\n+     * <li><code>read-committed</code>: The standard JDBC\n+     * {@link java.sql.Connection#TRANSACTION_READ_COMMITTED} level.</li>\n+     * <li><code>read-uncommitted</code>: The standard JDBC\n+     * {@link java.sql.Connection#TRANSACTION_READ_UNCOMMITTED} level.</li>\n+     * <li><code>repeatable-read</code>: The standard JDBC\n+     * {@link java.sql.Connection#TRANSACTION_REPEATABLE_READ} level.</li>\n+     * <li><code>serializable</code>: The standard JDBC\n+     * {@link java.sql.Connection#TRANSACTION_SERIALIZABLE} level.</li>\n+     * </ul>\n+     */\n+    public String getTransactionIsolation();\n+\n+    /**\n+     * The transaction isolation level to use at the database level.\n+     * Possible values are:\n+     * <ul>\n+     * <li><code>default</code>: The JDBC driver's default isolation level.</li>\n+     * <li><code>none</code>: The standard JDBC\n+     * {@link java.sql.Connection#TRANSACTION_NONE} level.</li>\n+     * <li><code>read-committed</code>: The standard JDBC\n+     * {@link java.sql.Connection#TRANSACTION_READ_COMMITTED} level.</li>\n+     * <li><code>read-uncommitted</code>: The standard JDBC\n+     * {@link java.sql.Connection#TRANSACTION_READ_UNCOMMITTED} level.</li>\n+     * <li><code>repeatable-read</code>: The standard JDBC\n+     * {@link java.sql.Connection#TRANSACTION_REPEATABLE_READ} level.</li>\n+     * <li><code>serializable</code>: The standard JDBC\n+     * {@link java.sql.Connection#TRANSACTION_SERIALIZABLE} level.</li>\n+     * </ul>\n+     */\n+    public void setTransactionIsolation(String level);\n+\n+    /**\n+     * Return the proper transaction isolation level constant from\n+     * {@link java.sql.Connection}, or -1 for the default level.\n+     */\n+    public int getTransactionIsolationConstant();\n+\n+    /**\n+     * Set the proper transaction isolation level constant from\n+     * {@link java.sql.Connection}, or -1 for the default level.\n+     */\n+    public void setTransactionIsolation(int level);\n+\n+    /**\n+     * The JDBC result set type. Defaults to <code>forward-only</code>.\n+     * <ul>\n+     * <li><code>forward-only</code>: The standard JDBC\n+     * {@link java.sql.ResultSet#TYPE_FORWARD_ONLY} type.</li>\n+     * <li><code>scroll-sensitive</code>: The standard JDBC\n+     * {@link java.sql.ResultSet#TYPE_SCROLL_SENSITIVE} type.</li>\n+     * <li><code>scroll-insensitive</code>: The standard JDBC\n+     * {@link java.sql.ResultSet#TYPE_SCROLL_INSENSITIVE} type.</li>\n+     * </ul>\n+     */\n+    public String getResultSetType();\n+\n+    /**\n+     * Return the result set constant for the result set type.\n+     */\n+    public int getResultSetTypeConstant();\n+\n+    /**\n+     * The JDBC result set type. Defaults to <code>forward-only</code>.\n+     * <ul>\n+     * <li><code>forward-only</code>: The standard JDBC\n+     * {@link java.sql.ResultSet#TYPE_FORWARD_ONLY} type.</li>\n+     * <li><code>scroll-sensitive</code>: The standard JDBC\n+     * {@link java.sql.ResultSet#TYPE_SCROLL_SENSITIVE} type.</li>\n+     * <li><code>scroll-insensitive</code>: The standard JDBC\n+     * {@link java.sql.ResultSet#TYPE_SCROLL_INSENSITIVE} type.</li>\n+     * </ul>\n+     */\n+    public void setResultSetType(String type);\n+\n+    /**\n+     * Set the result set constant type.\n+     */\n+    public void setResultSetType(int type);\n+\n+    /**\n+     * The JDBC fetch direction. Defaults to <code>forward</code>.\n+     * <ul>\n+     * <li><code>forward</code>: The standard JDBC\n+     * {@link java.sql.ResultSet#FETCH_FORWARD} direction.</li>\n+     * <li><code>reverse</code>: The standard JDBC\n+     * {@link java.sql.ResultSet#FETCH_REVERSE} direction.</li>\n+     * <li><code>unknown</code>: The standard JDBC\n+     * {@link java.sql.ResultSet#FETCH_UNKNOWN} direction.</li>\n+     * </ul>\n+     */\n+    public String getFetchDirection();\n+\n+    /**\n+     * Return the result set constant for the fetch direction.\n+     */\n+    public int getFetchDirectionConstant();\n+\n+    /**\n+     * The JDBC fetch direction. Defaults to <code>forward</code>.\n+     * <ul>\n+     * <li><code>forward</code>: The standard JDBC\n+     * {@link java.sql.ResultSet#FETCH_FORWARD} direction.</li>\n+     * <li><code>reverse</code>: The standard JDBC\n+     * {@link java.sql.ResultSet#FETCH_REVERSE} direction.</li>\n+     * <li><code>unknown</code>: The standard JDBC\n+     * {@link java.sql.ResultSet#FETCH_UNKNOWN} direction.</li>\n+     * </ul>\n+     */\n+    public void setFetchDirection(String direction);\n+\n+    /**\n+     * Set the result set fetch direction constant.\n+     */\n+    public void setFetchDirection(int direction);\n+\n+    /**\n+     * Specifies the default eager fetch mode to use. Defaults to\n+     * <code>parallel</code> unless the query is by-oid. Possible values are:\n+     * <ul>\n+     * <li><code>none</code>: When querying for an object, do not try to\n+     * select for related objects at the same time.</li>\n+     * <li><code>join</code>: When querying for objects, also select for\n+     * 1-1 relations in the configured fetch groups using joins.</li>\n+     * <li><code>parallel</code>: When querying for objects, also select for\n+     * both 1-1 relations using joins and to-many relations using batched\n+     * selects.</li>\n+     * </li>\n+     * </ul>\n+     *\n+     * @since 3.0\n+     */\n+    public String getEagerFetchMode();\n+\n+    /**\n+     * Specifies the default eager fetch mode to use. Defaults to\n+     * <code>parallel</code> unless the query is by-oid. Possible values are:\n+     * <ul>\n+     * <li><code>none</code>: When querying for an object, do not try to\n+     * select for related objects at the same time.</li>\n+     * <li><code>join</code>: When querying for objects, also select for\n+     * 1-1 relations in the configured fetch groups using joins.</li>\n+     * <li><code>parallel</code>: When querying for objects, also select for\n+     * both 1-1 relations using joins and to-many relations using batched\n+     * selects.</li>\n+     * </li>\n+     * </ul>\n+     */\n+    public void setEagerFetchMode(String mode);\n+\n+    /**\n+     * Return the eager fetch mode as one of the following symbolic constants:\n+     * <ul>\n+     * <li>{@link EagerFetchModes#EAGER_NONE}</li>\n+     * <li>{@link EagerFetchModes#EAGER_JOIN}</li>\n+     * <li>{@link EagerFetchModes#EAGER_PARALLEL}</li>\n+     * </ul>\n+     *\n+     * @since 3.0\n+     */\n+    public int getEagerFetchModeConstant();\n+\n+    /**\n+     * Set the eager fetch mode as one of the following symbolic constants:\n+     * <ul>\n+     * <li>{@link EagerFetchModes#EAGER_NONE}</li>\n+     * <li>{@link EagerFetchModes#EAGER_JOIN}</li>\n+     * <li>{@link EagerFetchModes#EAGER_PARALLEL}</li>\n+     * </ul>\n+     *\n+     * @since 3.0\n+     */\n+    public void setEagerFetchMode(int eagerFetchMode);\n+\n+    /**\n+     * Specifies the default subclass fetch mode to use. Defaults to\n+     * <code>join</code> unless the query is by-oid. Possible values are:\n+     * <ul>\n+     * <li><code>none</code>: Only select base class data.</li>\n+     * <li><code>join</code>: Select both base class and all possible subclass\n+     * data using joins.</li>\n+     * <li><code>parallel</code>: Select for each possible subclass\n+     * separately.</li>\n+     * </ul>\n+     *\n+     * @since 3.2\n+     */\n+    public String getSubclassFetchMode();\n+\n+    /**\n+     * Specifies the default subclass fetch mode to use. Defaults to\n+     * <code>join</code> unless the query is by-oid. Possible values are:\n+     * <ul>\n+     * <li><code>none</code>: Only select base class data.</li>\n+     * <li><code>join</code>: Select both base class and all possible subclass\n+     * data using joins.</li>\n+     * <li><code>parallel</code>: Select for each possible subclass\n+     * separately.</li>\n+     * </ul>\n+     *\n+     * @since 3.2\n+     */\n+    public void setSubclassFetchMode(String mode);\n+\n+    /**\n+     * Return the subclass fetch mode as one of the following symbolic\n+     * constants:\n+     * <ul>\n+     * <li>{@link EagerFetchModes#EAGER_NONE}</li>\n+     * <li>{@link EagerFetchModes#EAGER_JOIN}</li>\n+     * <li>{@link EagerFetchModes#EAGER_PARALLEL}</li>\n+     * </ul>\n+     *\n+     * @since 3.2\n+     */\n+    public int getSubclassFetchModeConstant();\n+\n+    /**\n+     * Set the subclass fetch mode as one of the following symbolic constants:\n+     * <ul>\n+     * <li>{@link EagerFetchModes#EAGER_NONE}</li>\n+     * <li>{@link EagerFetchModes#EAGER_JOIN}</li>\n+     * <li>{@link EagerFetchModes#EAGER_PARALLEL}</li>\n+     * </ul>\n+     *\n+     * @since 3.2\n+     */\n+    public void setSubclassFetchMode(int subclassFetchMode);\n+\n+    /**\n+     * How to obtain the size of large result sets. Defaults to\n+     * <code>unknown</code>.\n+     * <ul>\n+     * <li><code>unknown</code>: Do not attempt to calculate the size of\n+     * large result sets; return {@link Integer#MAX_VALUE}.</li>\n+     * <li><code>last</code>: For result sets that support random access,\n+     * calculate the size using {@link java.sql.ResultSet#last}.</li>\n+     * <li><code>query</code>: Use a separate COUNT query to calculate the\n+     * size of the results.</li>\n+     * </ul>\n+     */\n+    public String getLRSSize();\n+\n+    /**\n+     * Return the {@link LRSSizes} constant for the large result set size\n+     * setting.\n+     */\n+    public int getLRSSizeConstant();\n+\n+    /**\n+     * How to obtain the size of large result sets. Defaults to\n+     * <code>unknown</code>.\n+     * <ul>\n+     * <li><code>unknown</code>: Do not attempt to calculate the size of\n+     * large result sets; return {@link Integer#MAX_VALUE}.</li>\n+     * <li><code>last</code>: For result sets that support random access,\n+     * calculate the size using {@link java.sql.ResultSet#last}.</li>\n+     * <li><code>query</code>: Use a separate COUNT query to calculate the\n+     * size of the results.</li>\n+     * </ul>\n+     */\n+    public void setLRSSize(String lrsSize);\n+\n+    /**\n+     * Set the fetch configuration large result set size constant.\n+     */\n+    public void setLRSSize(int size);\n+\n+    /**\n+     * Whether OpenJPA should try to automatically refresh O/R mapping\n+     * information and the database schema.\n+     */\n+    public String getSynchronizeMappings();\n+\n+    /**\n+     * Whether OpenJPA should try to automatically refresh O/R mapping\n+     * information and the database schema.\n+     */\n+    public void setSynchronizeMappings(String synchronizeMappings);\n+\n+    /**\n+     * A comma-separated list of the {@link JDBCListener} plugins for\n+     * listening to {@link JDBCEvent}s.\n+     */\n+    public String getJDBCListeners();\n+\n+    /**\n+     * A comma-separated list of the {@link JDBCListener} plugins for\n+     * listening to {@link JDBCEvent}s.\n+     */\n+    public void setJDBCListeners(String jdbcListeners);\n+\n+    /**\n+     * The {@link JDBCListener}s to use.\n+     */\n+    public JDBCListener[] getJDBCListenerInstances();\n+\n+    /**\n+     * The {@link JDBCListener}s to use.\n+     */\n+    public void setJDBCListeners(JDBCListener[] jdbcListeners);\n+\n+    /**\n+     * A comma-separated list of the {@link ConnectionDecorator} for adding\n+     * functionality to JDBC connections.\n+     */\n+    public String getConnectionDecorators();\n+\n+    /**\n+     * A comma-separated list of the {@link ConnectionDecorator} for\n+     * adding functionality to JDBC connections.\n+     */\n+    public void setConnectionDecorators(String decorators);\n+\n+    /**\n+     * The {@link ConnectionDecorator}s to use.\n+     */\n+    public ConnectionDecorator[] getConnectionDecoratorInstances();\n+\n+    /**\n+     * The {@link ConnectionDecorator}s to use.\n+     */\n+    public void setConnectionDecorators(ConnectionDecorator[] decorators);\n+\n+    /**\n+     * The {@link DBDictionary} to use to define the RDBMS SQL information.\n+     */\n+    public String getDBDictionary();\n+\n+    /**\n+     * The {@link DBDictionary} to use to define the RDBMS SQL information.\n+     */\n+    public void setDBDictionary(String dbdictionary);\n+\n+    /**\n+     * The {@link DBDictionary} to use.\n+     */\n+    public DBDictionary getDBDictionaryInstance();\n+\n+    /**\n+     * The {@link DBDictionary} to use.\n+     */\n+    public void setDBDictionary(DBDictionary dbdictionary);\n+\n+    /**\n+     * The {@link UpdateManager} to use for managing SQL updates.\n+     */\n+    public String getUpdateManager();\n+\n+    /**\n+     * The {@link UpdateManager} to use for managing SQL updates.\n+     */\n+    public void setUpdateManager(String updateManager);\n+\n+    /**\n+     * The {@link UpdateManager} for runtime data store interaction.\n+     */\n+    public UpdateManager getUpdateManagerInstance();\n+\n+    /**\n+     * The {@link UpdateManager} for runtime data store interaction.\n+     */\n+    public void setUpdateManager(UpdateManager updateManager);\n+\n+    /**\n+     * The {@link DriverDataSource} to use for creating a {@link DataSource}\n+     * from a JDBC {@link Driver}.\n+     */\n+    public String getDriverDataSource();\n+\n+    /**\n+     * The {@link DriverDataSource} to use for creating a {@link DataSource}\n+     * from a JDBC {@link Driver}.\n+     */\n+    public void setDriverDataSource(String driverDataSource);\n+\n+    /**\n+     * Create an instance of the {@link DriverDataSource} to use\n+     * for creating a {@link DataSource} from a JDBC {@link Driver}.\n+     */\n+    public DriverDataSource newDriverDataSourceInstance();\n+\n+    /**\n+     * The plugin string for the {@link SchemaFactory} to use to provide\n+     * schema information during system initialization.\n+     */\n+    public String getSchemaFactory();\n+\n+    /**\n+     * The plugin string for the {@link SchemaFactory} to use to provide\n+     * schema information during system initialization.\n+     */\n+    public void setSchemaFactory(String schemaFactory);\n+\n+    /**\n+     * The {@link SchemaFactory} to use for schema information.\n+     */\n+    public SchemaFactory getSchemaFactoryInstance();\n+\n+    /**\n+     * The {@link SchemaFactory} to use for schema information.\n+     */\n+    public void setSchemaFactory(SchemaFactory schemaFactory);\n+\n+    /**\n+     * The SQL factory to use for SQL constructs.\n+     */\n+    public String getSQLFactory();\n+\n+    /**\n+     * The SQL factory to use for SQL constructs.\n+     */\n+    public SQLFactory getSQLFactoryInstance();\n+\n+    /**\n+     * The SQL factory to use for SQL constructs.\n+     */\n+    public void setSQLFactory(String sqlFactory);\n+\n+    /**\n+     * The SQL factory to use for SQL constructs.\n+     */\n+    public void setSQLFactory(SQLFactory sqlFactory);\n+\n+    /**\n+     * A plugin string describing the {@link MetaDataFactory} to use for\n+     * loading and storing object-relational mapping data.\n+     */\n+    public String getMappingFactory();\n+\n+    /**\n+     * A plugin string describing the {@link MetaDataFactory} to use for\n+     * loading and storing object-relational mapping data.\n+     */\n+    public void setMappingFactory(String mappingFactory);\n+\n+    /**\n+     * A plugin string describing the {@link MappingDefaults} to use.\n+     *\n+     * @since 4.0\n+     */\n+    public String getMappingDefaults();\n+\n+    /**\n+     * A plugin string describing the {@link MappingDefaults} to use.\n+     *\n+     * @since 4.0\n+     */\n+    public void setMappingDefaults(String map);\n+\n+    /**\n+     * The {@link MappingDefaults} to use with a repository.\n+     *\n+     * @since 4.0\n+     */\n+    public MappingDefaults getMappingDefaultsInstance();\n+\n+    /**\n+     * The {@link MappingDefaults} to use with a repository.\n+     *\n+     * @since 4.0\n+     */\n+    public void setMappingDefaults(MappingDefaults map);\n+\n+    /**\n+     * Return the mapping repository. Convenience method to cast from\n+     * the internal metadata repository.\n+     */\n+    public MappingRepository getMappingRepository();\n+\n+    /**\n+     * Return a new mapping repository instance for this configuration.\n+     */\n+    public MappingRepository newMappingRepositoryInstance();\n+\n+    /**\n+     * Return a new mapping repository instance for this configuration with\n+     * the specified {@link MetaDataFactory} and {@link MappingDefaults}.\n+     */\n+    public MappingRepository newMappingRepositoryInstance(MetaDataFactory mdf,\n+        MappingDefaults mapDefaults);\n+\n+    /**\n+     * Return the primary data source to use. The data source will\n+     * automatically use the given context's user name and password on calls\n+     * to {@link DataSource#getConnection}. If the given context is null, the\n+     * data source will use the configuration's default connection user name\n+     * and password. If those too are null and the first context has been\n+     * obtained already, then the user name and password for that context\n+     * will be used, as we know they represent a valid combination. This\n+     * method avoids casting the result of\n+     * {@link OpenJPAConfiguration#getConnectionFactory}, and avoids having to\n+     * pass in the user name and password to obtain connections.\n+     */\n+    public DataSource getDataSource(StoreContext ctx);\n+\n+    /**\n+     * Return the non-enlisted data source to use. If there is a valid\n+     * non-xa connection factory configured, then it will be returned. Its\n+     * default user name and password on calls to\n+     * {@link DataSource#getConnection} will be the specificed connection 2\n+     * user name and password. If those are null and the given context is\n+     * non-null, its user name password will be used instead. If the context\n+     * is null too, then the user name and password used to retrieve the first\n+     * context will be used. If there is no second connection factory the\n+     * primary connection factory is used.\n+     *\n+     * @see #getDataSource\n+     */\n+    public DataSource getDataSource2(StoreContext ctx);\n+}"},{"sha":"80b60761d96eed80656115ebe96d67000557a8ab","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java","status":"added","additions":900,"deletions":0,"changes":900,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,900 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.conf;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import javax.sql.DataSource;\n+\n+import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\n+import org.apache.openjpa.conf.ProductDerivations;\n+import org.apache.openjpa.jdbc.kernel.EagerFetchModes;\n+import org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory;\n+import org.apache.openjpa.jdbc.kernel.LRSSizes;\n+import org.apache.openjpa.jdbc.kernel.PessimisticLockManager;\n+import org.apache.openjpa.jdbc.kernel.UpdateManager;\n+import org.apache.openjpa.jdbc.meta.MappingDefaults;\n+import org.apache.openjpa.jdbc.meta.MappingRepository;\n+import org.apache.openjpa.jdbc.schema.DataSourceFactory;\n+import org.apache.openjpa.jdbc.schema.DriverDataSource;\n+import org.apache.openjpa.jdbc.schema.SchemaFactory;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.DBDictionaryFactory;\n+import org.apache.openjpa.jdbc.sql.SQLFactory;\n+import org.apache.openjpa.kernel.BrokerImpl;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.conf.IntValue;\n+import org.apache.openjpa.lib.conf.ObjectValue;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.lib.conf.StringListValue;\n+import org.apache.openjpa.lib.conf.StringValue;\n+import org.apache.openjpa.lib.jdbc.ConnectionDecorator;\n+import org.apache.openjpa.lib.jdbc.DecoratingDataSource;\n+import org.apache.openjpa.lib.jdbc.JDBCListener;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.MetaDataFactory;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+\n+/**\n+ * Default implementation of the {@link JDBCConfiguration} interface.\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @author Abe White\n+ */\n+public class JDBCConfigurationImpl\n+    extends OpenJPAConfigurationImpl\n+    implements JDBCConfiguration {\n+\n+    public StringValue schema;\n+    public StringListValue schemas;\n+    public IntValue transactionIsolation;\n+    public IntValue resultSetType;\n+    public IntValue fetchDirection;\n+    public FetchModeValue eagerFetchMode;\n+    public FetchModeValue subclassFetchMode;\n+    public IntValue lrsSize;\n+    public StringValue synchronizeMappings;\n+    public ObjectValue jdbcListenerPlugins;\n+    public ObjectValue connectionDecoratorPlugins;\n+    public PluginValue dbdictionaryPlugin;\n+    public ObjectValue updateManagerPlugin;\n+    public ObjectValue schemaFactoryPlugin;\n+    public ObjectValue sqlFactoryPlugin;\n+    public ObjectValue mappingDefaultsPlugin;\n+    public PluginValue driverDataSourcePlugin;\n+    public MappingFactoryValue mappingFactoryPlugin;\n+    public MappingRepositoryValue mappingRepositoryPlugin;\n+\n+    // used internally\n+    private String firstUser = null;\n+    private String firstPass = null;\n+    private DecoratingDataSource dataSource = null;\n+    private DecoratingDataSource dataSource2 = null;\n+\n+    /**\n+     * Default constructor. Attempts to load default properties.\n+     */\n+    public JDBCConfigurationImpl() {\n+        this(true);\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param loadDefaults whether to attempt to load the default\n+     * <code>org.apache.openjpa.properties</code> resource\n+     */\n+    public JDBCConfigurationImpl(boolean loadDefaults) {\n+        this(true, loadDefaults);\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param derivations whether to apply product derivations\n+     * @param loadDefaults whether to attempt to load the default properties\n+     */\n+    public JDBCConfigurationImpl(boolean derivations, boolean loadDefaults) {\n+        super(false, false);\n+        String[] aliases;\n+\n+        schema = addString(\"jdbc.Schema\");\n+        schemas = addStringList(\"jdbc.Schemas\");\n+\n+        transactionIsolation = addInt(\"jdbc.TransactionIsolation\");\n+        aliases = new String[]{\n+            \"default\", String.valueOf(-1),\n+            \"none\", String.valueOf(Connection.TRANSACTION_NONE),\n+            \"read-committed\", String.valueOf\n+            (Connection.TRANSACTION_READ_COMMITTED),\n+            \"read-uncommitted\", String.valueOf\n+            (Connection.TRANSACTION_READ_UNCOMMITTED),\n+            \"repeatable-read\", String.valueOf\n+            (Connection.TRANSACTION_REPEATABLE_READ),\n+            \"serializable\", String.valueOf(Connection.TRANSACTION_SERIALIZABLE)\n+        };\n+        transactionIsolation.setAliases(aliases);\n+        transactionIsolation.setDefault(aliases[0]);\n+        transactionIsolation.set(-1);\n+\n+        resultSetType = addInt(\"jdbc.ResultSetType\");\n+        aliases = new String[]{\n+            \"forward-only\", String.valueOf(ResultSet.TYPE_FORWARD_ONLY),\n+            \"scroll-sensitive\", String.valueOf\n+            (ResultSet.TYPE_SCROLL_SENSITIVE),\n+            \"scroll-insensitive\", String.valueOf\n+            (ResultSet.TYPE_SCROLL_INSENSITIVE),\n+        };\n+        resultSetType.setAliases(aliases);\n+        resultSetType.setDefault(aliases[0]);\n+        resultSetType.set(ResultSet.TYPE_FORWARD_ONLY);\n+\n+        fetchDirection = addInt(\"jdbc.FetchDirection\");\n+        aliases = new String[]{\n+            \"forward\", String.valueOf(ResultSet.FETCH_FORWARD),\n+            \"reverse\", String.valueOf(ResultSet.FETCH_REVERSE),\n+            \"unknown\", String.valueOf(ResultSet.FETCH_UNKNOWN),\n+        };\n+        fetchDirection.setAliases(aliases);\n+        fetchDirection.setDefault(aliases[0]);\n+        fetchDirection.set(ResultSet.FETCH_FORWARD);\n+\n+        eagerFetchMode = new FetchModeValue(\"jdbc.EagerFetchMode\");\n+        eagerFetchMode.setDefault(FetchModeValue.EAGER_PARALLEL);\n+        eagerFetchMode.set(EagerFetchModes.EAGER_PARALLEL);\n+        addValue(eagerFetchMode);\n+\n+        subclassFetchMode = new FetchModeValue(\"jdbc.SubclassFetchMode\");\n+        subclassFetchMode.setDefault(FetchModeValue.EAGER_JOIN);\n+        subclassFetchMode.set(EagerFetchModes.EAGER_JOIN);\n+        addValue(subclassFetchMode);\n+\n+        lrsSize = addInt(\"jdbc.LRSSize\");\n+        aliases = new String[]{\n+            \"query\", String.valueOf(LRSSizes.SIZE_QUERY),\n+            \"unknown\", String.valueOf(LRSSizes.SIZE_UNKNOWN),\n+            \"last\", String.valueOf(LRSSizes.SIZE_LAST),\n+        };\n+        lrsSize.setAliases(aliases);\n+        lrsSize.setDefault(aliases[0]);\n+        lrsSize.set(LRSSizes.SIZE_QUERY);\n+\n+        synchronizeMappings = addString(\"jdbc.SynchronizeMappings\");\n+        aliases = new String[]{ \"false\", null };\n+        synchronizeMappings.setAliases(aliases);\n+        synchronizeMappings.setDefault(aliases[0]);\n+\n+        jdbcListenerPlugins = addPluginList(\"jdbc.JDBCListeners\");\n+        jdbcListenerPlugins.setInstantiatingGetter(\"getJDBCListenerInstances\");\n+\n+        connectionDecoratorPlugins = addPluginList\n+            (\"jdbc.ConnectionDecorators\");\n+        connectionDecoratorPlugins.setInstantiatingGetter\n+            (\"getConnectionDecoratorInstances\");\n+\n+        dbdictionaryPlugin = addPlugin(\"jdbc.DBDictionary\", true);\n+        aliases = new String[]{\n+            \"access\", \"org.apache.openjpa.jdbc.sql.AccessDictionary\",\n+            \"db2\", \"org.apache.openjpa.jdbc.sql.DB2Dictionary\",\n+            \"derby\", \"org.apache.openjpa.jdbc.sql.DerbyDictionary\",\n+            \"empress\", \"org.apache.openjpa.jdbc.sql.EmpressDictionary\",\n+            \"foxpro\", \"org.apache.openjpa.jdbc.sql.FoxProDictionary\",\n+            \"hsql\", \"org.apache.openjpa.jdbc.sql.HSQLDictionary\",\n+            \"informix\", \"org.apache.openjpa.jdbc.sql.InformixDictionary\",\n+            \"jdatastore\", \"org.apache.openjpa.jdbc.sql.JDataStoreDictionary\",\n+            \"mysql\", \"org.apache.openjpa.jdbc.sql.MySQLDictionary\",\n+            \"oracle\", \"org.apache.openjpa.jdbc.sql.OracleDictionary\",\n+            \"pointbase\", \"org.apache.openjpa.jdbc.sql.PointbaseDictionary\",\n+            \"postgres\", \"org.apache.openjpa.jdbc.sql.PostgresDictionary\",\n+            \"sqlserver\", \"org.apache.openjpa.jdbc.sql.SQLServerDictionary\",\n+            \"sybase\", \"org.apache.openjpa.jdbc.sql.SybaseDictionary\",\n+        };\n+        dbdictionaryPlugin.setAliases(aliases);\n+        dbdictionaryPlugin.setInstantiatingGetter(\"getDBDictionaryInstance\");\n+\n+        updateManagerPlugin = addPlugin(\"jdbc.UpdateManager\", true);\n+        aliases = new String[]{\n+            \"default\",\n+            \"org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager\",\n+            \"operation-order\",\n+            \"org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager\",\n+        };\n+        updateManagerPlugin.setAliases(aliases);\n+        updateManagerPlugin.setDefault(aliases[0]);\n+        updateManagerPlugin.setString(aliases[0]);\n+        updateManagerPlugin.setInstantiatingGetter(\"getUpdateManagerInstance\");\n+\n+        driverDataSourcePlugin = addPlugin(\"jdbc.DriverDataSource\",\n+            false);\n+        aliases = new String[]{\n+            \"simple\", \"org.apache.openjpa.jdbc.schema.SimpleDriverDataSource\",\n+        };\n+        driverDataSourcePlugin.setAliases(aliases);\n+        driverDataSourcePlugin.setDefault(aliases[0]);\n+        driverDataSourcePlugin.setString(aliases[0]);\n+\n+        schemaFactoryPlugin = addPlugin(\"jdbc.SchemaFactory\", true);\n+        aliases = new String[]{\n+            \"dynamic\", \"org.apache.openjpa.jdbc.schema.DynamicSchemaFactory\",\n+            \"native\", \"org.apache.openjpa.jdbc.schema.LazySchemaFactory\",\n+            \"file\", \"org.apache.openjpa.jdbc.schema.FileSchemaFactory\",\n+            \"table\", \"org.apache.openjpa.jdbc.schema.TableSchemaFactory\",\n+            // deprecated alias\n+            \"db\", \"org.apache.openjpa.jdbc.schema.TableSchemaFactory\",\n+        };\n+        schemaFactoryPlugin.setAliases(aliases);\n+        schemaFactoryPlugin.setDefault(aliases[0]);\n+        schemaFactoryPlugin.setString(aliases[0]);\n+        schemaFactoryPlugin.setInstantiatingGetter(\"getSchemaFactoryInstance\");\n+\n+        sqlFactoryPlugin = addPlugin(\"jdbc.SQLFactory\", true);\n+        aliases = new String[]{\n+            \"default\", \"org.apache.openjpa.jdbc.sql.SQLFactoryImpl\",\n+        };\n+        sqlFactoryPlugin.setAliases(aliases);\n+        sqlFactoryPlugin.setDefault(aliases[0]);\n+        sqlFactoryPlugin.setString(aliases[0]);\n+        sqlFactoryPlugin.setInstantiatingGetter(\"getSQLFactoryInstance\");\n+\n+        mappingFactoryPlugin = new MappingFactoryValue(\"jdbc.MappingFactory\");\n+        addValue(mappingFactoryPlugin);\n+\n+        mappingRepositoryPlugin = new MappingRepositoryValue\n+            (\"jdbc.MappingRepository\");\n+        addValue(mappingRepositoryPlugin);\n+        aliases = new String[]{\n+            \"default\", \"org.apache.openjpa.jdbc.meta.MappingRepository\",\n+        };\n+        mappingRepositoryPlugin.setAliases(aliases);\n+        mappingRepositoryPlugin.setDefault(aliases[0]);\n+        mappingRepositoryPlugin.setString(aliases[0]);\n+        mappingRepositoryPlugin.setInstantiatingGetter\n+            (\"getMappingRepository\");\n+\n+        mappingDefaultsPlugin = addPlugin(\"jdbc.MappingDefaults\", true);\n+        aliases = new String[]{\n+            \"default\", \"org.apache.openjpa.jdbc.meta.MappingDefaultsImpl\",\n+        };\n+        mappingDefaultsPlugin.setAliases(aliases);\n+        mappingDefaultsPlugin.setDefault(aliases[0]);\n+        mappingDefaultsPlugin.setString(aliases[0]);\n+        mappingDefaultsPlugin.setInstantiatingGetter\n+            (\"getMappingDefaultsInstance\");\n+\n+        // set up broker factory defaults\n+        brokerFactoryPlugin.setAlias(\"jdbc\",\n+            JDBCBrokerFactory.class.getName());\n+        brokerFactoryPlugin.setDefault(\"jdbc\");\n+        brokerFactoryPlugin.setString(\"jdbc\");\n+\n+        // set new default for lock manager\n+        lockManagerPlugin.setAlias(\"pessimistic\",\n+            PessimisticLockManager.class.getName());\n+        lockManagerPlugin.setDefault(\"pessimistic\");\n+        lockManagerPlugin.setString(\"pessimistic\");\n+\n+        // native savepoint manager options\n+        savepointManagerPlugin.setAlias(\"jdbc\",\n+            \"org.apache.openjpa.jdbc.kernel.JDBC3SavepointManager\");\n+        savepointManagerPlugin.setAlias(\"oracle\",\n+            \"org.apache.openjpa.jdbc.sql.OracleSavepointManager\");\n+\n+        // set new aliases and defaults for sequence\n+        seqPlugin.setAliases(JDBCSeqValue.ALIASES);\n+        seqPlugin.setDefault(JDBCSeqValue.ALIASES[0]);\n+        seqPlugin.setString(JDBCSeqValue.ALIASES[0]);\n+\n+        // this static initializer is to get past a weird\n+        // ClassCircularityError that happens only under IBM's\n+        // JDK 1.3.1 on Linux from within the JRun ClassLoader;\n+        // while exact causes are unknown, it is almost certainly\n+        // a bug in JRun, and we can get around it by forcing\n+        // Instruction.class to be loaded and initialized\n+        // before TypedInstruction.class\n+        try {\n+            serp.bytecode.lowlevel.Entry.class.getName();\n+        } catch (Throwable t) {\n+        }\n+        try {\n+            serp.bytecode.Instruction.class.getName();\n+        } catch (Throwable t) {\n+        }\n+\n+        supportedOptions().add(OPTION_QUERY_SQL);\n+        supportedOptions().add(OPTION_JDBC_CONNECTION);\n+        supportedOptions().remove(OPTION_VALUE_INCREMENT);\n+        supportedOptions().remove(OPTION_NULL_CONTAINER);\n+\n+        if (derivations)\n+            ProductDerivations.beforeConfigurationLoad(this);\n+        if (loadDefaults)\n+            loadDefaults();\n+    }\n+\n+    /**\n+     * Copy constructor\n+     */\n+    public JDBCConfigurationImpl(JDBCConfiguration conf) {\n+        this(true, false);\n+        if (conf != null)\n+            fromProperties(conf.toProperties(false));\n+    }\n+\n+    public void setSchema(String schema) {\n+        assertNotReadOnly();\n+        this.schema.setString(schema);\n+    }\n+\n+    public String getSchema() {\n+        return schema.getString();\n+    }\n+\n+    public void setSchemas(String schemas) {\n+        assertNotReadOnly();\n+        this.schemas.setString(schemas);\n+    }\n+\n+    public String getSchemas() {\n+        return schemas.getString();\n+    }\n+\n+    public void setSchemas(String[] schemas) {\n+        assertNotReadOnly();\n+        this.schemas.set(schemas);\n+    }\n+\n+    public String[] getSchemasList() {\n+        return schemas.get();\n+    }\n+\n+    public void setTransactionIsolation(String transactionIsolation) {\n+        assertNotReadOnly();\n+        this.transactionIsolation.setString(transactionIsolation);\n+    }\n+\n+    public String getTransactionIsolation() {\n+        return transactionIsolation.getString();\n+    }\n+\n+    public void setTransactionIsolation(int transactionIsolation) {\n+        assertNotReadOnly();\n+        this.transactionIsolation.set(transactionIsolation);\n+    }\n+\n+    public int getTransactionIsolationConstant() {\n+        return transactionIsolation.get();\n+    }\n+\n+    public void setResultSetType(String resultSetType) {\n+        assertNotReadOnly();\n+        this.resultSetType.setString(resultSetType);\n+    }\n+\n+    public String getResultSetType() {\n+        return resultSetType.getString();\n+    }\n+\n+    public void setResultSetType(int resultSetType) {\n+        assertNotReadOnly();\n+        this.resultSetType.set(resultSetType);\n+    }\n+\n+    public int getResultSetTypeConstant() {\n+        return resultSetType.get();\n+    }\n+\n+    public void setFetchDirection(String fetchDirection) {\n+        assertNotReadOnly();\n+        this.fetchDirection.setString(fetchDirection);\n+    }\n+\n+    public String getFetchDirection() {\n+        return fetchDirection.getString();\n+    }\n+\n+    public void setFetchDirection(int fetchDirection) {\n+        assertNotReadOnly();\n+        this.fetchDirection.set(fetchDirection);\n+    }\n+\n+    public int getFetchDirectionConstant() {\n+        return fetchDirection.get();\n+    }\n+\n+    public void setEagerFetchMode(String eagerFetchMode) {\n+        assertNotReadOnly();\n+        this.eagerFetchMode.setString(eagerFetchMode);\n+    }\n+\n+    public String getEagerFetchMode() {\n+        return eagerFetchMode.getString();\n+    }\n+\n+    public void setEagerFetchMode(int eagerFetchMode) {\n+        assertNotReadOnly();\n+        this.eagerFetchMode.set(eagerFetchMode);\n+    }\n+\n+    public int getEagerFetchModeConstant() {\n+        return eagerFetchMode.get();\n+    }\n+\n+    public void setSubclassFetchMode(String subclassFetchMode) {\n+        assertNotReadOnly();\n+        this.subclassFetchMode.setString(subclassFetchMode);\n+    }\n+\n+    public String getSubclassFetchMode() {\n+        return subclassFetchMode.getString();\n+    }\n+\n+    public void setSubclassFetchMode(int subclassFetchMode) {\n+        assertNotReadOnly();\n+        this.subclassFetchMode.set(subclassFetchMode);\n+    }\n+\n+    public int getSubclassFetchModeConstant() {\n+        return subclassFetchMode.get();\n+    }\n+\n+    public void setLRSSize(String lrsSize) {\n+        assertNotReadOnly();\n+        this.lrsSize.setString(lrsSize);\n+    }\n+\n+    public String getLRSSize() {\n+        return lrsSize.getString();\n+    }\n+\n+    public void setLRSSize(int lrsSize) {\n+        assertNotReadOnly();\n+        this.lrsSize.set(lrsSize);\n+    }\n+\n+    public int getLRSSizeConstant() {\n+        return lrsSize.get();\n+    }\n+\n+    public void setSynchronizeMappings(String synchronizeMappings) {\n+        assertNotReadOnly();\n+        this.synchronizeMappings.set(synchronizeMappings);\n+    }\n+\n+    public String getSynchronizeMappings() {\n+        return synchronizeMappings.get();\n+    }\n+\n+    public void setJDBCListeners(String jdbcListeners) {\n+        assertNotReadOnly();\n+        jdbcListenerPlugins.setString(jdbcListeners);\n+    }\n+\n+    public String getJDBCListeners() {\n+        return jdbcListenerPlugins.getString();\n+    }\n+\n+    public void setJDBCListeners(JDBCListener[] listeners) {\n+        assertNotReadOnly();\n+        jdbcListenerPlugins.set(listeners);\n+    }\n+\n+    public JDBCListener[] getJDBCListenerInstances() {\n+        if (jdbcListenerPlugins.get() == null)\n+            jdbcListenerPlugins.instantiate(JDBCListener.class, this);\n+        return (JDBCListener[]) jdbcListenerPlugins.get();\n+    }\n+\n+    public void setConnectionDecorators(String connectionDecorators) {\n+        assertNotReadOnly();\n+        connectionDecoratorPlugins.setString(connectionDecorators);\n+    }\n+\n+    public String getConnectionDecorators() {\n+        return connectionDecoratorPlugins.getString();\n+    }\n+\n+    public void setConnectionDecorators(ConnectionDecorator[] decorators) {\n+        assertNotReadOnly();\n+        connectionDecoratorPlugins.set(decorators);\n+    }\n+\n+    public ConnectionDecorator[] getConnectionDecoratorInstances() {\n+        if (connectionDecoratorPlugins.get() == null) {\n+            connectionDecoratorPlugins.instantiate\n+                (ConnectionDecorator.class, this);\n+        }\n+        return (ConnectionDecorator[]) connectionDecoratorPlugins.get();\n+    }\n+\n+    public void setDBDictionary(String dbdictionary) {\n+        assertNotReadOnly();\n+        dbdictionaryPlugin.setString(dbdictionary);\n+    }\n+\n+    public String getDBDictionary() {\n+        return dbdictionaryPlugin.getString();\n+    }\n+\n+    public void setDBDictionary(DBDictionary dbdictionary) {\n+        // we can't allow the dictionary to be set after the connection\n+        // factory, due to initialization issues\n+        if (connectionFactory.get() != null\n+            || connectionFactory2.get() != null)\n+            throw new IllegalStateException();\n+\n+        assertNotReadOnly();\n+        dbdictionaryPlugin.set(dbdictionary);\n+    }\n+\n+    public DBDictionary getDBDictionaryInstance() {\n+        // lock on connection factory name, since getting the connection\n+        // factory and getting the dictionary have to use the same locks to\n+        // prevent deadlock since they call each other\n+        DBDictionary dbdictionary = (DBDictionary) dbdictionaryPlugin.get();\n+        if (dbdictionary == null) {\n+            String clsName = dbdictionaryPlugin.getClassName();\n+            String props = dbdictionaryPlugin.getProperties();\n+            if (clsName != null && clsName.length() > 0) {\n+                dbdictionary = DBDictionaryFactory.newDBDictionary\n+                    (this, clsName, props);\n+            } else {\n+                // if the dictionary class isn't set, try to guess from\n+                // connection URL and driver name\n+                dbdictionary = DBDictionaryFactory.calculateDBDictionary\n+                    (this, getConnectionURL(), getConnectionDriverName(),\n+                        props);\n+\n+                // if the url and driver name aren't enough, connect to\n+                // the DB and use the connection metadata\n+                if (dbdictionary == null) {\n+                    Log log = getLog(LOG_JDBC);\n+                    if (log.isInfoEnabled()) {\n+                        Localizer loc = Localizer.forPackage\n+                            (JDBCConfigurationImpl.class);\n+                        log.info(loc.get(\"connecting-for-dictionary\"));\n+                    }\n+\n+                    // use the base connection factory rather than the\n+                    // configured data source b/c the data source relies\n+                    // on passing the connection through the dictionary,\n+                    // resulting in infinite loops\n+                    DataSource ds = createConnectionFactory();\n+                    dbdictionary = DBDictionaryFactory.newDBDictionary\n+                        (this, getDataSource(null, ds), props);\n+                }\n+            }\n+            dbdictionaryPlugin.set(dbdictionary, true);\n+        }\n+        return dbdictionary;\n+    }\n+\n+    public void setUpdateManager(String updateManager) {\n+        assertNotReadOnly();\n+        updateManagerPlugin.setString(updateManager);\n+    }\n+\n+    public String getUpdateManager() {\n+        return updateManagerPlugin.getString();\n+    }\n+\n+    public void setUpdateManager(UpdateManager updateManager) {\n+        assertNotReadOnly();\n+        updateManagerPlugin.set(updateManager);\n+    }\n+\n+    public UpdateManager getUpdateManagerInstance() {\n+        if (updateManagerPlugin.get() == null)\n+            updateManagerPlugin.instantiate(UpdateManager.class, this);\n+        return (UpdateManager) updateManagerPlugin.get();\n+    }\n+\n+    public void setDriverDataSource(String driverDataSource) {\n+        assertNotReadOnly();\n+        driverDataSourcePlugin.setString(driverDataSource);\n+    }\n+\n+    public String getDriverDataSource() {\n+        return driverDataSourcePlugin.getString();\n+    }\n+\n+    public DriverDataSource newDriverDataSourceInstance() {\n+        return (DriverDataSource) driverDataSourcePlugin.\n+            instantiate(DriverDataSource.class, this);\n+    }\n+\n+    public void setSchemaFactory(String schemaFactory) {\n+        assertNotReadOnly();\n+        schemaFactoryPlugin.setString(schemaFactory);\n+    }\n+\n+    public String getSchemaFactory() {\n+        return schemaFactoryPlugin.getString();\n+    }\n+\n+    public void setSchemaFactory(SchemaFactory schemaFactory) {\n+        assertNotReadOnly();\n+        schemaFactoryPlugin.set(schemaFactory);\n+    }\n+\n+    public SchemaFactory getSchemaFactoryInstance() {\n+        if (schemaFactoryPlugin.get() == null)\n+            schemaFactoryPlugin.instantiate(SchemaFactory.class, this);\n+        return (SchemaFactory) schemaFactoryPlugin.get();\n+    }\n+\n+    public void setSQLFactory(String sqlFactory) {\n+        assertNotReadOnly();\n+        sqlFactoryPlugin.setString(sqlFactory);\n+    }\n+\n+    public String getSQLFactory() {\n+        return sqlFactoryPlugin.getString();\n+    }\n+\n+    public void setSQLFactory(SQLFactory sqlFactory) {\n+        assertNotReadOnly();\n+        sqlFactoryPlugin.set(sqlFactory);\n+    }\n+\n+    public SQLFactory getSQLFactoryInstance() {\n+        if (sqlFactoryPlugin.get() == null)\n+            sqlFactoryPlugin.instantiate(SQLFactory.class, this);\n+        return (SQLFactory) sqlFactoryPlugin.get();\n+    }\n+\n+    public String getMappingFactory() {\n+        return mappingFactoryPlugin.getString();\n+    }\n+\n+    public void setMappingFactory(String mapping) {\n+        assertNotReadOnly();\n+        mappingFactoryPlugin.setString(mapping);\n+    }\n+\n+    public MetaDataFactory newMetaDataFactoryInstance() {\n+        return mappingFactoryPlugin.instantiateMetaDataFactory(this,\n+            metaFactoryPlugin, getMapping());\n+    }\n+\n+    public void setMappingDefaults(String mapping) {\n+        assertNotReadOnly();\n+        this.mappingDefaultsPlugin.setString(mapping);\n+    }\n+\n+    public String getMappingDefaults() {\n+        return mappingDefaultsPlugin.getString();\n+    }\n+\n+    public void setMappingDefaults(MappingDefaults mapping) {\n+        assertNotReadOnly();\n+        mappingDefaultsPlugin.set(mapping);\n+    }\n+\n+    public MappingDefaults getMappingDefaultsInstance() {\n+        if (mappingDefaultsPlugin.get() == null)\n+            mappingDefaultsPlugin.instantiate(MappingDefaults.class, this);\n+        return (MappingDefaults) mappingDefaultsPlugin.get();\n+    }\n+\n+    public MappingRepository getMappingRepository() {\n+        return (MappingRepository) getMetaDataRepository();\n+    }\n+\n+    public MappingRepository newMappingRepositoryInstance() {\n+        return (MappingRepository) getMappingRepository().newInstance();\n+    }\n+\n+    public MappingRepository newMappingRepositoryInstance(MetaDataFactory mdf,\n+        MappingDefaults mapDefaults) {\n+        return (MappingRepository) getMappingRepository().\n+            newInstance(mdf, mapDefaults);\n+    }\n+\n+    public MetaDataRepository getMetaDataRepository() {\n+        if (metaRepos == null) {\n+            mappingRepositoryPlugin.instantiate(MappingRepository.class, this);\n+            metaRepos = (MetaDataRepository) mappingRepositoryPlugin.get();\n+        }\n+        return metaRepos;\n+    }\n+\n+    public BrokerImpl newBrokerInstance(String user, String pass) {\n+        BrokerImpl broker = super.newBrokerInstance(user, pass);\n+\n+        // record first non-null broker user and pass in case no global settings\n+        if (broker != null && user != null && firstUser == null) {\n+            firstUser = user;\n+            firstPass = pass;\n+        }\n+        return broker;\n+    }\n+\n+    public Object getConnectionFactory() {\n+        // override to configure data source\n+        if (dataSource == null) {\n+            DecoratingDataSource ds = createConnectionFactory();\n+            dataSource = DataSourceFactory.installDBDictionary\n+                (getDBDictionaryInstance(), ds, this, false);\n+        }\n+        return dataSource;\n+    }\n+\n+    public void setConnectionFactory(Object factory) {\n+        // there's a lot of one-time initialization involved for\n+        // connection factories, so ignore resets\n+        if (factory == connectionFactory.get())\n+            return;\n+\n+        // override to configure data source\n+        assertNotReadOnly();\n+        if (factory != null) {\n+            // need to ensure it is decorated before we set the dict\n+            DecoratingDataSource ds =\n+                setupConnectionFactory((DataSource) factory, false);\n+            dataSource = DataSourceFactory.installDBDictionary\n+                (getDBDictionaryInstance(), ds, this, false);\n+        } else\n+            connectionFactory.set(null);\n+    }\n+\n+    /**\n+     * Ensure that the specified DataSource is decorated and set in the cache.\n+     */\n+    private DecoratingDataSource setupConnectionFactory(DataSource ds,\n+        boolean factory2) {\n+        if (ds == null)\n+            return null;\n+\n+        DecoratingDataSource dds;\n+        if (ds instanceof DecoratingDataSource)\n+            dds = (DecoratingDataSource) ds;\n+        else\n+            dds = DataSourceFactory.decorateDataSource(ds, this, factory2);\n+\n+        if (!factory2 && connectionFactory.get() != ds)\n+            connectionFactory.set(dds, true);\n+        else if (factory2 && connectionFactory2.get() != ds)\n+            connectionFactory2.set(dds, true);\n+\n+        return dds;\n+    }\n+\n+    public Object getConnectionFactory2() {\n+        // override to configure data source\n+        if (dataSource2 == null) {\n+            DataSource ds = (DataSource) connectionFactory2.get();\n+            if (ds == null) {\n+                // the driver name is always required, so if not specified,\n+                // then no connection factory 2\n+                String driver = getConnection2DriverName();\n+                if (driver != null && driver.length() > 0)\n+                    ds = DataSourceFactory.newDataSource(this, true);\n+            }\n+            if (ds != null) {\n+                DecoratingDataSource dds =\n+                    setupConnectionFactory(ds, true); // before dict\n+                dataSource2 = DataSourceFactory.installDBDictionary\n+                    (getDBDictionaryInstance(), dds, this, true);\n+            }\n+        }\n+        return dataSource2;\n+    }\n+\n+    public void setConnectionFactory2(Object factory) {\n+        if (factory == connectionFactory2.get())\n+            return;\n+\n+        // override to configure data source\n+        assertNotReadOnly();\n+        if (factory != null) {\n+            // need to ensure it is decorated before we set the dict\n+            DecoratingDataSource ds = setupConnectionFactory((DataSource)\n+                factory, true);\n+            dataSource2 = DataSourceFactory.installDBDictionary\n+                (getDBDictionaryInstance(), ds, this, true);\n+        } else\n+            connectionFactory2.set(null);\n+    }\n+\n+    /**\n+     * Create the connection factory if necessary.\n+     */\n+    private DecoratingDataSource createConnectionFactory() {\n+        DataSource ds = (DataSource) connectionFactory.get();\n+        if (ds != null)\n+            return setupConnectionFactory(ds, false);\n+\n+        ds = (DataSource) super.getConnectionFactory(); // JNDI lookup\n+        if (ds == null)\n+            ds = DataSourceFactory.newDataSource(this, false);\n+\n+        return setupConnectionFactory(ds, false);\n+    }\n+\n+    public DataSource getDataSource(StoreContext ctx) {\n+        return getDataSource(ctx, (DataSource) getConnectionFactory());\n+    }\n+\n+    public DataSource getDataSource2(StoreContext ctx) {\n+        // if there is no connection factory 2, use the primary factory\n+        DataSource ds = (DataSource) getConnectionFactory2();\n+        if (ds == null)\n+            return getDataSource(ctx);\n+\n+        // prefer the global connection 2 auth info if given\n+        String user = getConnection2UserName();\n+        String pass = getConnection2Password();\n+        if (user == null && pass == null) {\n+            // no global auth info; use the context if given, or the first\n+            // context if not\n+            if (ctx == null) {\n+                user = firstUser;\n+                pass = firstPass;\n+            } else {\n+                user = ctx.getConnectionUserName();\n+                pass = ctx.getConnectionPassword();\n+            }\n+        }\n+        return DataSourceFactory.defaultsDataSource(ds, user, pass);\n+    }\n+\n+    /**\n+     * This version allows us to pass in which data source to wrap internally;\n+     * useful during initialization before the connection factory is\n+     * completely configured.\n+     */\n+    private DataSource getDataSource(StoreContext ctx, DataSource ds) {\n+        String user, pass;\n+        if (ctx == null) {\n+            // if no context, default to the global auth info, or the auth info\n+            // of the first context if none\n+            user = getConnectionUserName();\n+            if (user == null)\n+                user = firstUser;\n+            pass = getConnectionPassword();\n+            if (pass == null)\n+                pass = firstPass;\n+        } else {\n+            // use the context's auth info\n+            user = ctx.getConnectionUserName();\n+            pass = ctx.getConnectionPassword();\n+        }\n+        return DataSourceFactory.defaultsDataSource(ds, user, pass);\n+    }\n+\n+    /**\n+     * Free the data sources.\n+     */\n+    public void close() {\n+        if (dataSource != null) {\n+            getDBDictionaryInstance().closeDataSource(dataSource);\n+            connectionFactory.set(null, true); // so super doesn't close it\n+        }\n+        if (dataSource2 != null) {\n+            getDBDictionaryInstance().closeDataSource(dataSource);\n+            connectionFactory2.set(null, true); // so super doesn't close it\n+        }\n+        super.close();\n+    }\n+\n+    protected boolean isInvalidProperty(String propName) {\n+        // handle openjpa.jdbc.SomeMisspelledProperty, but not\n+        // openjpa.someotherimplementation.SomeProperty\n+        return super.isInvalidProperty(propName)\n+            || propName.toLowerCase().startsWith(\"openjpa.jdbc\");\n+    }\n+}"},{"sha":"e62ce44a98538f04cb50a71fd495959cb4bb52ea","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCProductDerivation.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCProductDerivation.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.conf;\n+\n+import org.apache.openjpa.conf.BrokerFactoryValue;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.conf.ProductDerivation;\n+import org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory;\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\n+\n+/**\n+ * Sets JDBC as default store.\n+ */\n+public class JDBCProductDerivation\n+    implements ProductDerivation {\n+\n+    public int getType() {\n+        return TYPE_STORE;\n+    }\n+\n+    public void beforeConfigurationConstruct(ConfigurationProvider cp) {\n+        // default to JDBC when no broker factory set\n+        if (BrokerFactoryValue.getBrokerFactoryClassName(cp) == null) {\n+            cp.addProperty(BrokerFactoryValue.getBrokerFactoryProperty(cp),\n+                JDBCBrokerFactory.class.getName());\n+        }\n+    }\n+\n+    public void beforeConfigurationLoad(OpenJPAConfiguration c) {\n+    }\n+\n+    public void afterSpecificationSet(OpenJPAConfiguration c) {\n+    }\n+\n+    public void afterClose(OpenJPAConfiguration c) {\n+    }\n+}"},{"sha":"aff2ad5381ce410df57758fcddd343e2089f8063","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCSeqValue.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCSeqValue.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCSeqValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCSeqValue.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.conf;\n+\n+import org.apache.openjpa.conf.SeqValue;\n+import org.apache.openjpa.jdbc.kernel.ClassTableJDBCSeq;\n+import org.apache.openjpa.jdbc.kernel.NativeJDBCSeq;\n+import org.apache.openjpa.jdbc.kernel.TableJDBCSeq;\n+import org.apache.openjpa.jdbc.kernel.ValueTableJDBCSeq;\n+import org.apache.openjpa.jdbc.meta.SequenceMapping;\n+import org.apache.openjpa.kernel.TimeSeededSeq;\n+\n+/**\n+ * Adds additional aliases to base {@link SeqValue}. This subclass is\n+ * not added to the configuration object because it is not visible to it.\n+ * Therefore, this class should not attempt to alter sequence instantiation\n+ * behavior. The aliases defined by this subclass are added to the\n+ * configuration, however, and this subclass may also be instantiated by\n+ * other components for creation of sequences without manual alias setting.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class JDBCSeqValue\n+    extends SeqValue {\n+\n+    static final String[] ALIASES = new String[]{\n+        SequenceMapping.IMPL_TABLE, TableJDBCSeq.class.getName(),\n+        SequenceMapping.IMPL_VALUE_TABLE, ValueTableJDBCSeq.class.getName(),\n+        SequenceMapping.IMPL_CLASS_TABLE, ClassTableJDBCSeq.class.getName(),\n+        SequenceMapping.IMPL_NATIVE, NativeJDBCSeq.class.getName(),\n+        SequenceMapping.IMPL_TIME, TimeSeededSeq.class.getName(),\n+        // deprecated aliases\n+        \"db\", TableJDBCSeq.class.getName(),\n+        \"db-class\", ClassTableJDBCSeq.class.getName(),\n+        \"sjvm\", TimeSeededSeq.class.getName(),\n+    };\n+\n+    public JDBCSeqValue(String prop) {\n+        super(prop);\n+        setAliases(ALIASES);\n+        setDefault(ALIASES[0]);\n+        setClassName(ALIASES[1]);\n+    }\n+}"},{"sha":"84365bca33ed4254a071f21bbaa73109d4428059","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/MappingFactoryValue.java","status":"added","additions":158,"deletions":0,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/MappingFactoryValue.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/MappingFactoryValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/MappingFactoryValue.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,158 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.conf;\n+\n+import org.apache.openjpa.jdbc.meta.MetaDataPlusMappingFactory;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.MetaDataFactory;\n+\n+/**\n+ * Handles the complex logic of creating a {@link MetaDataFactory} for\n+ * combined metadata and mapping.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class MappingFactoryValue\n+    extends PluginValue {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (MappingFactoryValue.class);\n+\n+    private String[] _metaFactoryDefaults = null;\n+    private String[] _mappedMetaFactoryDefaults = null;\n+\n+    public MappingFactoryValue(String prop) {\n+        super(prop, false);\n+    }\n+\n+    /**\n+     * Default setting for a given <code>MetaDataFactory</code> alias setting.\n+     * If a <code>MappingFactory</code> value is not supplied, we check these\n+     * defaults against the <code>MetaDataFactory</code> setting. If the\n+     * <code>MetaDataFactory</code> does not have a default, we assume it\n+     * handles both metadata and mapping factory.\n+     */\n+    public void setMetaDataFactoryDefault(String metaAlias,\n+        String mappingAlias) {\n+        _metaFactoryDefaults = setAlias(metaAlias, mappingAlias,\n+            _metaFactoryDefaults);\n+    }\n+\n+    /**\n+     * If the <code>Mapping</code> property is set, we check these defaults\n+     * before checking metadata factory defaults.\n+     */\n+    public void setMappedMetaDataFactoryDefault(String metaAlias,\n+        String mappingAlias) {\n+        _mappedMetaFactoryDefaults = setAlias(metaAlias, mappingAlias,\n+            _mappedMetaFactoryDefaults);\n+    }\n+\n+    /**\n+     * Intantiate a {@link MetaDataFactory} responsible for both metadata and\n+     * mapping.\n+     */\n+    public MetaDataFactory instantiateMetaDataFactory(Configuration conf,\n+        PluginValue metaPlugin, String mapping) {\n+        return instantiateMetaDataFactory(conf, metaPlugin, mapping, true);\n+    }\n+\n+    /**\n+     * Intantiate a {@link MetaDataFactory} responsible for both metadata and\n+     * mapping.\n+     */\n+    public MetaDataFactory instantiateMetaDataFactory(Configuration conf,\n+        PluginValue metaPlugin, String mapping, boolean fatal) {\n+        String clsName = getClassName();\n+        String props = getProperties();\n+        String metaClsName = metaPlugin.getClassName();\n+        String metaProps = metaPlugin.getProperties();\n+\n+        // if no mapping factory set, check for default for this factory\n+        if (clsName == null || clsName.length() == 0) {\n+            String def;\n+            if (mapping != null) {\n+                def = unalias(metaPlugin.alias(metaClsName),\n+                    _mappedMetaFactoryDefaults, true);\n+                if (def != null)\n+                    clsName = unalias(def);\n+            }\n+            if (clsName == null) {\n+                def = unalias(metaPlugin.alias(metaClsName),\n+                    _metaFactoryDefaults, true);\n+                if (def != null)\n+                    clsName = unalias(def);\n+            }\n+        }\n+\n+        // if mapping factory and metadata factory the same, combine\n+        // into metadata factory\n+        if (clsName != null && clsName.equals(metaClsName)) {\n+            if (props != null && metaProps == null)\n+                metaProps = props;\n+            else if (props != null)\n+                metaProps += \",\" + props;\n+            clsName = null;\n+            props = null;\n+        }\n+\n+        // instantiate factories\n+        MetaDataFactory map = (MetaDataFactory) newInstance(clsName,\n+            MetaDataFactory.class, conf, fatal);\n+        MetaDataFactory meta;\n+        if (map != null\n+            && map.getClass().getName().indexOf(\"Deprecated\") != -1) {\n+            // deprecated mapping factories take over metadata too, so we have\n+            // to special-case them to treat them like metadata factory only\n+            meta = map;\n+            map = null;\n+        } else {\n+            meta = (MetaDataFactory) metaPlugin.newInstance\n+                (metaClsName, MetaDataFactory.class, conf, fatal);\n+        }\n+\n+        // configure factories.  if only meta factory, allow user to specify\n+        // its mapping properties in the mapping factory setting\n+        if (map == null && props != null) {\n+            if (metaProps == null)\n+                metaProps = props;\n+            else\n+                metaProps += \", \" + props;\n+        }\n+        Configurations.configureInstance(map, conf, props,\n+            (fatal) ? getProperty() : null);\n+        Configurations.configureInstance(meta, conf, metaProps,\n+            (fatal) ? metaPlugin.getProperty() : null);\n+\n+        Log log = conf.getLog(JDBCConfiguration.LOG_METADATA);\n+        if (log.isTraceEnabled()) {\n+            log.trace(_loc.get(\"meta-factory\", meta));\n+            if (map != null)\n+                log.trace(_loc.get(\"map-factory\", map));\n+        }\n+\n+        // if no mapping setting, return meta factory alone, assuming it handles\n+        // both metadata and mapping\n+        MetaDataFactory ret = (map == null) ? meta\n+            : new MetaDataPlusMappingFactory(meta, map);\n+        return ret;\n+    }\n+}"},{"sha":"e1d7a2fa5429395efba9826ee6348215628aeb8f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/MappingRepositoryValue.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/MappingRepositoryValue.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/MappingRepositoryValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/MappingRepositoryValue.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.conf;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import org.apache.openjpa.jdbc.meta.MappingRepository;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.lib.util.Localizer;\n+import serp.util.Strings;\n+\n+/**\n+ * Handles the complex logic of creating a {@link MappingRepository} for\n+ * a given configuration.\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @nojavadoc\n+ */\n+public class MappingRepositoryValue\n+    extends PluginValue {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (MappingRepositoryValue.class);\n+\n+    public MappingRepositoryValue(String prop) {\n+        super(prop, true);\n+    }\n+\n+    public Object newInstance(String clsName, Class type,\n+        Configuration conf, boolean fatal) {\n+        // since the MappingRepository takes a JDBConfiguration constructor,\n+        // we need to manually perform the instantiation\n+        try {\n+            Class cls = Strings.toClass(clsName, type.getClassLoader());\n+\n+            return cls.getConstructor(new Class[]{ JDBCConfiguration.class }).\n+                newInstance(new Object[]{ conf });\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (InvocationTargetException e) {\n+            if (e.getTargetException()instanceof RuntimeException)\n+                throw(RuntimeException) e.getTargetException();\n+\n+            // fall back to default behavior for better error reporting\n+            return super.newInstance(clsName, type, conf, fatal);\n+        } catch (Exception e) {\n+            // fall back to default behavior for better error reporting\n+            return super.newInstance(clsName, type, conf, fatal);\n+        }\n+    }\n+}"},{"sha":"f9f6059edbacaaa8b2e8da5001a0087130795dfa","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/package.html","status":"added","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/package.html","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/package.html?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,9 @@\n+<html>\n+<body>\n+<p><strong>OpenJPA-JDBC Configuration</strong></p>\n+\n+<p>\n+    This package provides JDBC configuration interfaces.\n+</p>\n+</body>\n+</html>"},{"sha":"7ea009f213970f3786dc0fc8873d6b30d62548a2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSavepointManager.java","status":"added","additions":135,"deletions":0,"changes":135,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSavepointManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSavepointManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSavepointManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.util.Collection;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.Broker;\n+import org.apache.openjpa.kernel.OpenJPASavepoint;\n+import org.apache.openjpa.kernel.RestoreState;\n+import org.apache.openjpa.kernel.SavepointManager;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+\n+/**\n+ * Abstract {@link SavepointManager} implementation that\n+ * delegates to the subclass for savepoint operations on the active\n+ * {@link Connection}. This implementation issues a flush and relies\n+ * on the driver/db to restore back to the flushed state.\n+ *\n+ * @author Steve Kim\n+ * @since 3.4\n+ */\n+public abstract class AbstractJDBCSavepointManager\n+    implements SavepointManager, Configurable {\n+\n+    private boolean _restore = false;\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+        _restore = ((OpenJPAConfiguration) conf).getRestoreStateConstant()\n+            != RestoreState.RESTORE_NONE;\n+    }\n+\n+    public void endConfiguration() {\n+    }\n+\n+    /**\n+     * Return whether to retain in-memory copies of field values for restore\n+     * on rollback. Defaults to {@link OpenJPAConfiguration#getRestoreState).\n+     */\n+    public boolean getRestoreFieldState() {\n+        return _restore;\n+    }\n+\n+    /**\n+     * Set whether to retain in-memory copies of field values for restore\n+     * on rollback. Defaults to {@link OpenJPAConfiguration#getRestoreState}.\n+     */\n+    public void setRestoreFieldState(boolean restore) {\n+        _restore = restore;\n+    }\n+\n+    public OpenJPASavepoint newSavepoint(String name, Broker broker) {\n+        // flush after creating savepoint b/c flush may add/change states\n+        OpenJPASavepoint save = new ConnectionSavepoint(broker, name, _restore);\n+        broker.flush();\n+        return save;\n+    }\n+\n+    public boolean supportsIncrementalFlush() {\n+        return true;\n+    }\n+\n+    /**\n+     * Rollback the datastore savepoint.\n+     */\n+    protected abstract void rollbackDataStore(ConnectionSavepoint savepoint);\n+\n+    /**\n+     * Set the datastore savepoint.\n+     */\n+    protected abstract void setDataStore(ConnectionSavepoint savepoint);\n+\n+    /**\n+     * A savepoint which provides access to the current transactional\n+     * connection.\n+     */\n+    protected class ConnectionSavepoint extends OpenJPASavepoint {\n+\n+        private Object _savepoint;\n+\n+        public ConnectionSavepoint(Broker broker, String name, boolean copy) {\n+            super(broker, name, copy);\n+        }\n+\n+        /**\n+         * Return the stored savepoint object\n+         */\n+        public Object getDataStoreSavepoint() {\n+            return _savepoint;\n+        }\n+\n+        /**\n+         * Set the implementation specific savepoint object\n+         */\n+        public void setDataStoreSavepoint(Object savepoint) {\n+            _savepoint = savepoint;\n+        }\n+\n+        /**\n+         * Return the current {@link Connection} for this savepoint.\n+         */\n+        public Connection getConnection() {\n+            return ((JDBCStoreManager) getBroker().getStoreManager().\n+                getInnermostDelegate()).getConnection();\n+        }\n+\n+        public Collection rollback(Collection previous) {\n+            AbstractJDBCSavepointManager.this.rollbackDataStore(this);\n+            return super.rollback(previous);\n+        }\n+\n+        public void save(Collection states) {\n+            AbstractJDBCSavepointManager.this.setDataStore(this);\n+            super.save(states);\n+        }\n+    }\n+}"},{"sha":"6ddf43014ea79e58e8c34bb679e1eac5e9ab5f06","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java","status":"added","additions":189,"deletions":0,"changes":189,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import javax.sql.DataSource;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.schema.SchemaGroup;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.StoreException;\n+\n+/**\n+ * Abstract sequence implementation. Handles obtaining the proper\n+ * connection to used based on whether the sequence is transactional and\n+ * whether a second datasource is configured.\n+ *\n+ * @author Abe White\n+ */\n+public abstract class AbstractJDBCSeq\n+    implements JDBCSeq {\n+\n+    protected int type = TYPE_DEFAULT;\n+    protected Object current = null;\n+\n+    // used to track current conn so that we can close it\n+    private Connection _conn = null;\n+    private boolean _commit = false;\n+\n+    /**\n+     * Records the sequence type.\n+     */\n+    public void setType(int type) {\n+        this.type = type;\n+    }\n+\n+    public synchronized Object next(StoreContext ctx, ClassMetaData meta) {\n+        JDBCStore store = getStore(ctx);\n+        try {\n+            current = nextInternal(store, (ClassMapping) meta);\n+            return current;\n+        } catch (OpenJPAException ke) {\n+            throw ke;\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, store.getDBDictionary());\n+        } catch (Exception e) {\n+            throw new StoreException(e);\n+        } finally {\n+            closeConnection();\n+        }\n+    }\n+\n+    public synchronized Object current(StoreContext ctx, ClassMetaData meta) {\n+        JDBCStore store = getStore(ctx);\n+        try {\n+            return currentInternal(store, (ClassMapping) meta);\n+        } catch (OpenJPAException ke) {\n+            throw ke;\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, store.getDBDictionary());\n+        } catch (Exception e) {\n+            throw new StoreException(e);\n+        } finally {\n+            closeConnection();\n+        }\n+    }\n+\n+    public synchronized void allocate(int additional, StoreContext ctx,\n+        ClassMetaData meta) {\n+        JDBCStore store = getStore(ctx);\n+        try {\n+            allocateInternal(additional, store, (ClassMapping) meta);\n+        } catch (OpenJPAException ke) {\n+            throw ke;\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, store.getDBDictionary());\n+        } catch (Exception e) {\n+            throw new StoreException(e);\n+        } finally {\n+            closeConnection();\n+        }\n+    }\n+\n+    /**\n+     * No-op.\n+     */\n+    public void addSchema(ClassMapping mapping, SchemaGroup group) {\n+    }\n+\n+    /**\n+     * No-op.\n+     */\n+    public void close() {\n+    }\n+\n+    /**\n+     * Return the next sequence object.\n+     */\n+    protected abstract Object nextInternal(JDBCStore store,\n+        ClassMapping mapping)\n+        throws Exception;\n+\n+    /**\n+     * Return the current sequence object. By default returns the last\n+     * sequence value used, or null if no sequence values have been requested\n+     * yet.\n+     */\n+    protected Object currentInternal(JDBCStore store, ClassMapping mapping)\n+        throws Exception {\n+        return current;\n+    }\n+\n+    /**\n+     * Allocate additional sequence values. Does nothing by default.\n+     */\n+    protected void allocateInternal(int additional, JDBCStore store,\n+        ClassMapping mapping)\n+        throws Exception {\n+    }\n+\n+    /**\n+     * Extract the store from the given context.\n+     */\n+    private JDBCStore getStore(StoreContext ctx) {\n+        return (JDBCStore) ctx.getStoreManager().getInnermostDelegate();\n+    }\n+\n+    /**\n+     * Return the connection to use based on the type of sequence. This\n+     * connection will automatically be closed; do not close it.\n+     */\n+    protected Connection getConnection(JDBCStore store)\n+        throws SQLException {\n+        // close previous connection if user is asking for another connection\n+        closeConnection();\n+\n+        if (type == TYPE_TRANSACTIONAL || type == TYPE_CONTIGUOUS)\n+            _conn = store.getConnection();\n+        else {\n+            JDBCConfiguration conf = store.getConfiguration();\n+            DataSource ds = conf.getDataSource2(store.getContext());\n+            _conn = ds.getConnection();\n+            if (_conn.getAutoCommit())\n+                _conn.setAutoCommit(false);\n+            _commit = true;\n+        }\n+        return _conn;\n+    }\n+\n+    /**\n+     * Close the current connection.\n+     */\n+    protected void closeConnection() {\n+        if (_conn == null)\n+            return;\n+\n+        try {\n+            if (_commit)\n+                _conn.commit();\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se);\n+        } finally {\n+            try {\n+                _conn.close();\n+            } catch (SQLException se) {\n+            }\n+            _conn = null;\n+            _commit = false;\n+        }\n+    }\n+}"},{"sha":"da28a0593d79093196e00fb84df367d4ff3c168e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractUpdateManager.java","status":"added","additions":384,"deletions":0,"changes":384,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractUpdateManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractUpdateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractUpdateManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.Discriminator;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.Strategy;\n+import org.apache.openjpa.jdbc.meta.Version;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.RowManager;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.PCState;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.OptimisticException;\n+\n+/**\n+ * Base update manager with common functionality.\n+ *\n+ * @author Abe White\n+ */\n+public abstract class AbstractUpdateManager\n+    implements UpdateManager, Configurable {\n+\n+    protected JDBCConfiguration conf = null;\n+    protected DBDictionary dict = null;\n+\n+    public void setConfiguration(Configuration conf) {\n+        this.conf = (JDBCConfiguration) conf;\n+        dict = this.conf.getDBDictionaryInstance();\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+    }\n+\n+    public Collection flush(Collection states, JDBCStore store) {\n+        Connection conn = store.getConnection();\n+        try {\n+            PreparedStatementManager psMgr = newPreparedStatementManager\n+                (store, conn);\n+            return flush(states, store, psMgr);\n+        } finally {\n+            try {\n+                conn.close();\n+            } catch (SQLException se) {\n+            }\n+        }\n+    }\n+\n+    private Collection flush(Collection states, JDBCStore store,\n+        PreparedStatementManager psMgr) {\n+        // run through all the states and update them as necessary\n+        RowManager rowMgr = newRowManager();\n+        Collection customs = new LinkedList();\n+        Collection exceps = null;\n+        for (Iterator itr = states.iterator(); itr.hasNext();)\n+            exceps =\n+                populateRowManager((OpenJPAStateManager) itr.next(), rowMgr,\n+                    store, exceps, customs);\n+\n+        // flush rows\n+        exceps = flush(rowMgr, psMgr, exceps);\n+\n+        // now do any custom mappings\n+        for (Iterator itr = customs.iterator(); itr.hasNext();) {\n+            try {\n+                ((CustomMapping) itr.next()).execute(store);\n+            } catch (SQLException se) {\n+                exceps = addException(exceps, SQLExceptions.getStore(se,\n+                    dict));\n+            } catch (OpenJPAException ke) {\n+                exceps = addException(exceps, ke);\n+            }\n+        }\n+\n+        // return all exceptions\n+        Collection psExceps = psMgr.getExceptions();\n+        if (exceps == null)\n+            return psExceps;\n+        if (psExceps == null)\n+            return exceps;\n+        exceps.addAll(psExceps);\n+        return exceps;\n+    }\n+\n+    /**\n+     * Return a new {@link RowManager}.\n+     */\n+    protected abstract RowManager newRowManager();\n+\n+    /**\n+     * Return a new {@link PreparedStatementManager}.\n+     */\n+    protected abstract PreparedStatementManager newPreparedStatementManager\n+        (JDBCStore store, Connection conn);\n+\n+    /**\n+     * Flush all rows of the given row manager. Add exceptions to\n+     * <code>exceps</code> (which may start as null) using\n+     * {@link #addException}. Return <code>exceps</code>.\n+     */\n+    protected abstract Collection flush(RowManager rowMgr,\n+        PreparedStatementManager psMgr, Collection exceps);\n+\n+    /**\n+     * Populate the row manager with rows to be flushed for the given state.\n+     *\n+     * @param exceps exceptions encountered when flushing will be added to\n+     * this list and returned; the list may be null initially\n+     * @param customs buffer custom mappings\n+     * @return the exceptions list\n+     */\n+    private Collection populateRowManager(OpenJPAStateManager sm,\n+        RowManager rowMgr, JDBCStore store, Collection exceps,\n+        Collection customs) {\n+        try {\n+            if (sm.getPCState() == PCState.PNEW && !sm.isFlushed()) {\n+                insert(sm, (ClassMapping) sm.getMetaData(), rowMgr,\n+                    store, customs);\n+            } else if (sm.getPCState() == PCState.PNEWFLUSHEDDELETED\n+                || sm.getPCState() == PCState.PDELETED) {\n+                delete(sm, (ClassMapping) sm.getMetaData(), rowMgr,\n+                    store, customs);\n+            } else if ((sm.getPCState() == PCState.PDIRTY\n+                && (!sm.isFlushed() || sm.isFlushedDirty()))\n+                || (sm.getPCState() == PCState.PNEW\n+                && sm.isFlushedDirty())) {\n+                BitSet dirty = sm.getDirty();\n+                if (sm.isFlushed()) {\n+                    dirty = (BitSet) dirty.clone();\n+                    dirty.andNot(sm.getFlushed());\n+                }\n+\n+                if (dirty.length() > 0)\n+                    update(sm, dirty, (ClassMapping) sm.getMetaData(),\n+                        rowMgr, store, customs);\n+            } else if (sm.isVersionUpdateRequired()) {\n+                updateIndicators(sm, (ClassMapping) sm.getMetaData(),\n+                    rowMgr, store, customs, true);\n+            } else if (sm.isVersionCheckRequired()) {\n+                if (!((ClassMapping) sm.getMetaData()).getVersion().\n+                    checkVersion(sm, store, false))\n+                    exceps = addException(exceps, new OptimisticException\n+                        (sm.getManagedInstance()));\n+            }\n+        }\n+        catch (SQLException se) {\n+            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\n+        } catch (OpenJPAException ke) {\n+            exceps = addException(exceps, ke);\n+        }\n+        return exceps;\n+    }\n+\n+    /**\n+     * Add the given exception to the given list, which may start out as null.\n+     */\n+    protected Collection addException(Collection exceps, Exception err) {\n+        if (exceps == null)\n+            exceps = new LinkedList();\n+        exceps.add(err);\n+        return exceps;\n+    }\n+\n+    /**\n+     * Recursive method to insert the given instance, base class first.\n+     */\n+    private void insert(OpenJPAStateManager sm, ClassMapping mapping,\n+        RowManager rowMgr, JDBCStore store, Collection customs)\n+        throws SQLException {\n+        Boolean custom = mapping.isCustomInsert(sm, store);\n+        if (!Boolean.FALSE.equals(custom))\n+            mapping.customInsert(sm, store);\n+        if (custom.equals(Boolean.TRUE))\n+            return;\n+\n+        ClassMapping sup = mapping.getJoinablePCSuperclassMapping();\n+        if (sup != null)\n+            insert(sm, sup, rowMgr, store, customs);\n+\n+        mapping.insert(sm, store, rowMgr);\n+        FieldMapping[] fields = mapping.getDefinedFieldMappings();\n+        BitSet dirty = sm.getDirty();\n+        for (int i = 0; i < fields.length; i++) {\n+            if (dirty.get(fields[i].getIndex())\n+                && !bufferCustomInsert(fields[i], sm, store, customs))\n+                fields[i].insert(sm, store, rowMgr);\n+        }\n+        if (sup == null) {\n+            Version vers = mapping.getVersion();\n+            if (!bufferCustomInsert(vers, sm, store, customs))\n+                vers.insert(sm, store, rowMgr);\n+            Discriminator dsc = mapping.getDiscriminator();\n+            if (!bufferCustomInsert(dsc, sm, store, customs))\n+                dsc.insert(sm, store, rowMgr);\n+        }\n+    }\n+\n+    /**\n+     * If the given mapping uses a custom insert, places a\n+     * {@link CustomMapping} struct for it in the given collection and\n+     * returns true, else returns false.\n+     */\n+    private boolean bufferCustomInsert(Strategy strat, OpenJPAStateManager sm,\n+        JDBCStore store, Collection customs) {\n+        Boolean custom = strat.isCustomInsert(sm, store);\n+        if (!Boolean.FALSE.equals(custom))\n+            customs.add(new CustomMapping(CustomMapping.INSERT, sm, strat));\n+        return Boolean.TRUE.equals(custom);\n+    }\n+\n+    /**\n+     * Recursive method to delete the given instance, base class last.\n+     */\n+    private void delete(OpenJPAStateManager sm, ClassMapping mapping,\n+        RowManager rowMgr, JDBCStore store, Collection customs)\n+        throws SQLException {\n+        Boolean custom = mapping.isCustomDelete(sm, store);\n+        if (!Boolean.FALSE.equals(custom))\n+            mapping.customDelete(sm, store);\n+        if (Boolean.TRUE.equals(custom))\n+            return;\n+\n+        FieldMapping[] fields = mapping.getDefinedFieldMappings();\n+        for (int i = 0; i < fields.length; i++)\n+            if (!bufferCustomDelete(fields[i], sm, store, customs))\n+                fields[i].delete(sm, store, rowMgr);\n+\n+        ClassMapping sup = mapping.getJoinablePCSuperclassMapping();\n+        if (sup == null) {\n+            Version vers = mapping.getVersion();\n+            if (!bufferCustomDelete(vers, sm, store, customs))\n+                vers.delete(sm, store, rowMgr);\n+            Discriminator dsc = mapping.getDiscriminator();\n+            if (!bufferCustomDelete(dsc, sm, store, customs))\n+                dsc.delete(sm, store, rowMgr);\n+        }\n+        mapping.delete(sm, store, rowMgr);\n+\n+        if (sup != null)\n+            delete(sm, sup, rowMgr, store, customs);\n+    }\n+\n+    /**\n+     * @see #bufferCustomInsert\n+     */\n+    private boolean bufferCustomDelete(Strategy strat, OpenJPAStateManager sm,\n+        JDBCStore store, Collection customs) {\n+        Boolean custom = strat.isCustomDelete(sm, store);\n+        if (!Boolean.FALSE.equals(custom))\n+            customs.add(new CustomMapping(CustomMapping.DELETE, sm, strat));\n+        return Boolean.TRUE.equals(custom);\n+    }\n+\n+    /**\n+     * Recursive method to update the given instance.\n+     */\n+    private void update(OpenJPAStateManager sm, BitSet dirty,\n+        ClassMapping mapping, RowManager rowMgr, JDBCStore store,\n+        Collection customs)\n+        throws SQLException {\n+        Boolean custom = mapping.isCustomUpdate(sm, store);\n+        if (!Boolean.FALSE.equals(custom))\n+            mapping.customUpdate(sm, store);\n+        if (Boolean.TRUE.equals(custom))\n+            return;\n+\n+        // update all fields before all mappings so that the mappings can\n+        // detect whether any fields in their rows have been modified\n+        FieldMapping[] fields = mapping.getDefinedFieldMappings();\n+        for (int i = 0; i < fields.length; i++) {\n+            if (dirty.get(fields[i].getIndex())\n+                && !bufferCustomUpdate(fields[i], sm, store, customs))\n+                fields[i].update(sm, store, rowMgr);\n+        }\n+\n+        ClassMapping sup = mapping.getJoinablePCSuperclassMapping();\n+        if (sup == null)\n+            updateIndicators(sm, mapping, rowMgr, store, customs, false);\n+        else\n+            update(sm, dirty, sup, rowMgr, store, customs);\n+        mapping.update(sm, store, rowMgr);\n+    }\n+\n+    /**\n+     * Update version and discriminator indicators.\n+     */\n+    private void updateIndicators(OpenJPAStateManager sm, ClassMapping mapping,\n+        RowManager rowMgr, JDBCStore store, Collection customs,\n+        boolean versionUpdateOnly)\n+        throws SQLException {\n+        while (mapping.getJoinablePCSuperclassMapping() != null)\n+            mapping = mapping.getJoinablePCSuperclassMapping();\n+\n+        Version vers = mapping.getVersion();\n+        if (!bufferCustomUpdate(vers, sm, store, customs))\n+            vers.update(sm, store, rowMgr);\n+\n+        if (versionUpdateOnly) {\n+            // if we are only updating the version column, we need to add\n+            // in the primary key select\n+            mapping.update(sm, store, rowMgr);\n+        } else {\n+            // otherwise we need to make sure we update the discriminator too\n+            Discriminator dsc = mapping.getDiscriminator();\n+            if (!bufferCustomUpdate(dsc, sm, store, customs))\n+                dsc.update(sm, store, rowMgr);\n+        }\n+    }\n+\n+    /**\n+     * @see #bufferCustomInsert\n+     */\n+    private boolean bufferCustomUpdate(Strategy strat, OpenJPAStateManager sm,\n+        JDBCStore store, Collection customs) {\n+        Boolean custom = strat.isCustomUpdate(sm, store);\n+        if (!Boolean.FALSE.equals(custom))\n+            customs.add(new CustomMapping(CustomMapping.UPDATE, sm, strat));\n+        return Boolean.TRUE.equals(custom);\n+    }\n+\n+    /**\n+     * Executes customized mapping updates.\n+     */\n+    private static class CustomMapping {\n+\n+        public static final int INSERT = 0;\n+        public static final int UPDATE = 1;\n+        public static final int DELETE = 3;\n+\n+        private final int _action;\n+        private final OpenJPAStateManager _sm;\n+        private final Strategy _strat;\n+\n+        public CustomMapping(int action, OpenJPAStateManager sm,\n+            Strategy strat) {\n+            _action = action;\n+            _sm = sm;\n+            _strat = strat;\n+        }\n+\n+        public void execute(JDBCStore store)\n+            throws SQLException {\n+            switch (_action) {\n+                case INSERT:\n+                    _strat.customInsert(_sm, store);\n+                    break;\n+                case UPDATE:\n+                    _strat.customUpdate(_sm, store);\n+                    break;\n+                case DELETE:\n+                    _strat.customDelete(_sm, store);\n+                    break;\n+            }\n+        }\n+    }\n+}"},{"sha":"c65bc2fa487de7065ddd255aed3a8b4513e710ce","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java","status":"added","additions":262,"deletions":0,"changes":262,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.MappingRepository;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.meta.ClassArgParser;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Options;\n+import org.apache.openjpa.meta.JavaTypes;\n+\n+/**\n+ * Specialization of the {@link TableJDBCSeq} that maintains a\n+ * separate sequence count per-class. Table name defaults to\n+ * <code>OPENJPA_SEQUENCES_TABLE</code>.\n+ *\n+ * @author Abe White\n+ */\n+public class ClassTableJDBCSeq\n+    extends TableJDBCSeq {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ClassTableJDBCSeq.class);\n+\n+    private final Map _stats = new HashMap();\n+    private boolean _ignore = false;\n+    private boolean _aliases = false;\n+\n+    public ClassTableJDBCSeq() {\n+        setTable(\"OPENJPA_SEQUENCES_TABLE\");\n+    }\n+\n+    /**\n+     * Whether unmapped classes should be ignored as possible primary\n+     * key values in the table. Defaults to false.\n+     */\n+    public boolean getIgnoreUnmapped() {\n+        return _ignore;\n+    }\n+\n+    /**\n+     * Whether unmapped classes should be ignored as possible primary\n+     * key values in the table. Defaults to false.\n+     */\n+    public void setIgnoreUnmapped(boolean ignore) {\n+        _ignore = ignore;\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #setIgnoreUnmapped}. Retained for\n+     * backwards-compatibility for auto-configuration.\n+     */\n+    public void setIgnoreVirtual(boolean ignore) {\n+        setIgnoreUnmapped(ignore);\n+    }\n+\n+    /**\n+     * Whether to use type alises for primary key values in place of class\n+     * names. Defaults to false.\n+     */\n+    public boolean getUseAliases() {\n+        return _aliases;\n+    }\n+\n+    /**\n+     * Whether to use type alises for primary key values in place of class\n+     * names. Defaults to false.\n+     */\n+    public void setUseAliases(boolean aliases) {\n+        _aliases = aliases;\n+    }\n+\n+    protected Status getStatus(ClassMapping mapping) {\n+        if (mapping == null)\n+            return null;\n+        String key = getKey(mapping, false);\n+        Status stat = (Status) _stats.get(key);\n+        if (stat == null) {\n+            stat = new Status();\n+            _stats.put(key, stat);\n+        }\n+        return stat;\n+    }\n+\n+    protected Column addPrimaryKeyColumn(Table table) {\n+        DBDictionary dict = getConfiguration().getDBDictionaryInstance();\n+        Column pkColumn = table.addColumn(dict.getValidColumnName\n+            (getPrimaryKeyColumn(), table));\n+        pkColumn.setType(dict.getPreferredType(Types.VARCHAR));\n+        pkColumn.setJavaType(JavaTypes.STRING);\n+        pkColumn.setSize(dict.characterColumnSize);\n+        return pkColumn;\n+    }\n+\n+    protected Object getPrimaryKey(ClassMapping mapping) {\n+        if (mapping == null)\n+            return null;\n+        return getKey(mapping, true);\n+    }\n+\n+    private String getKey(ClassMapping mapping, boolean db) {\n+        if (_ignore) {\n+            while (mapping.getMappedPCSuperclassMapping() != null)\n+                mapping = mapping.getMappedPCSuperclassMapping();\n+        } else {\n+            while (mapping.getPCSuperclass() != null)\n+                mapping = mapping.getPCSuperclassMapping();\n+        }\n+        if (_aliases)\n+            return mapping.getTypeAlias();\n+        return mapping.getDescribedType().getName();\n+    }\n+\n+    /////////\n+    // Main\n+    /////////\n+\n+    /**\n+     * Usage: java org.apache.openjpa.jdbc.kernel.ClassTableJDBCSeq [option]*\n+     * -action/-a &lt;add | drop | get | set&gt;\n+     * [class name | .java file | .class file | .jdo file] [value]\n+     *  Where the following options are recognized.\n+     * <ul>\n+     * <li><i>-properties/-p &lt;properties file or resource&gt;</i>: The\n+     * path or resource name of a OpenJPA properties file containing\n+     * information such as connection data as\n+     * outlined in {@link JDBCConfiguration}. Optional.</li>\n+     * <li><i>-&lt;property name&gt; &lt;property value&gt;</i>: All bean\n+     * properties of the OpenJPA {@link JDBCConfiguration} can be set by\n+     * using their\tnames and supplying a value.</li>\n+     * </ul>\n+     *  The various actions are as follows.\n+     * <ul>\n+     * <li><i>add</i>: Create the sequence table.</li>\n+     * <li><i>drop</i>: Drop the sequence table.</li>\n+     * <li><i>get</i>: Print the current sequence value for the given\n+     * class.</li>\n+     * <li><i>set</i>: Set the sequence value for the given class.</li>\n+     * </ul>\n+     */\n+    public static void main(String[] args)\n+        throws Exception {\n+        Options opts = new Options();\n+        args = opts.setFromCmdLine(args);\n+        JDBCConfiguration conf = new JDBCConfigurationImpl();\n+        try {\n+            if (!run(conf, args, opts))\n+                System.out.println(_loc.get(\"clstable-seq-usage\"));\n+        } finally {\n+            conf.close();\n+        }\n+    }\n+\n+    /**\n+     * Run the tool. Returns false if invalid options were given.\n+     */\n+    public static boolean run(JDBCConfiguration conf, String[] args,\n+        Options opts)\n+        throws Exception {\n+        if (opts.containsKey(\"help\") || opts.containsKey(\"-help\"))\n+            return false;\n+\n+        String action = opts.removeProperty(\"action\", \"a\", null);\n+        Configurations.populateConfiguration(conf, opts);\n+        return run(conf, args, action, null, null);\n+    }\n+\n+    /**\n+     * Run the tool. Return false if an invalid option was given.\n+     */\n+    public static boolean run(JDBCConfiguration conf, String[] args,\n+        String action, MappingRepository repos, ClassLoader loader)\n+        throws Exception {\n+        ClassTableJDBCSeq seq = new ClassTableJDBCSeq();\n+        String props = Configurations.getProperties(conf.getSequence());\n+        Configurations.configureInstance(seq, conf, props);\n+\n+        if (ACTION_DROP.equals(action)) {\n+            if (args.length != 0)\n+                return false;\n+            seq.dropTable();\n+        } else if (ACTION_ADD.equals(action)) {\n+            if (args.length != 0)\n+                return false;\n+            seq.refreshTable();\n+        } else if (ACTION_GET.equals(action) || ACTION_SET.equals(action)) {\n+            if (args.length == 0)\n+                return false;\n+\n+            if (loader == null)\n+                loader = conf.getClassResolverInstance().\n+                    getClassLoader(ClassTableJDBCSeq.class, null);\n+\n+            ClassArgParser cap = conf.getMetaDataRepository().\n+                getMetaDataFactory().newClassArgParser();\n+            cap.setClassLoader(loader);\n+            Class cls = cap.parseTypes(args[0])[0];\n+\n+            if (repos == null)\n+                repos = conf.getMappingRepository();\n+            ClassMapping mapping = repos.getMapping(cls, null, true);\n+\n+            Connection conn = conf.getDataSource2(null).getConnection();\n+            try {\n+                long cur = seq.getSequence(mapping, conn);\n+                if (ACTION_GET.equals(action))\n+                    System.out.println(mapping + \": \" + cur);\n+                else {\n+                    long set;\n+                    if (args.length > 1)\n+                        set = Long.parseLong(args[1]);\n+                    else\n+                        set = cur + seq.getAllocate();\n+                    if (set < cur)\n+                        set = cur;\n+                    else {\n+                        Status stat = seq.getStatus(mapping);\n+                        seq.setSequence(null, stat, (int) (set - cur), true,\n+                            conn);\n+                        set = stat.seq;\n+                    }\n+                    System.err.println(mapping + \": \" + set);\n+                }\n+            }\n+            catch (NumberFormatException nfe) {\n+                return false;\n+            } finally {\n+                try {\n+                    conn.close();\n+                } catch (SQLException se) {\n+                }\n+            }\n+        } else\n+            return false;\n+        return true;\n+    }\n+}"},{"sha":"66037dd179643fb9a823020363b0dc548bdc20d5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConnectionInfo.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConnectionInfo.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConnectionInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConnectionInfo.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * Struct to hold data about the current connection state.\n+ *\n+ * @author Abe White\n+ */\n+public class ConnectionInfo {\n+\n+    public Result result = null;\n+    public OpenJPAStateManager sm = null;\n+    public ClassMapping mapping = null;\n+}"},{"sha":"356a42b35bbeb2377b4134f0f50cde0339f28bca","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/DelegatingJDBCFetchConfiguration.java","status":"added","additions":233,"deletions":0,"changes":233,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/DelegatingJDBCFetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/DelegatingJDBCFetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/DelegatingJDBCFetchConfiguration.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,233 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.util.Collection;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.kernel.DelegatingFetchConfiguration;\n+import org.apache.openjpa.util.RuntimeExceptionTranslator;\n+\n+///////////////////////////////////////////////////////////////\n+// NOTE: when adding a public API method, be sure to add it to \n+// JDO and JPA facades!\n+///////////////////////////////////////////////////////////////\n+\n+/**\n+ * Delegating fetch configuration that can also perform exception\n+ * transation for use in facades.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ * @since 4.0\n+ */\n+public class DelegatingJDBCFetchConfiguration\n+    extends DelegatingFetchConfiguration\n+    implements JDBCFetchConfiguration {\n+\n+    /**\n+     * Constructor; supply delegate.\n+     */\n+    public DelegatingJDBCFetchConfiguration(JDBCFetchConfiguration delegate) {\n+        super(delegate);\n+    }\n+\n+    /**\n+     * Constructor; supply delegate and exception translator.\n+     */\n+    public DelegatingJDBCFetchConfiguration(JDBCFetchConfiguration delegate,\n+        RuntimeExceptionTranslator trans) {\n+        super(delegate, trans);\n+    }\n+\n+    /**\n+     * Return the JDBC delegate.\n+     */\n+    public JDBCFetchConfiguration getJDBCDelegate() {\n+        return (JDBCFetchConfiguration) getDelegate();\n+    }\n+\n+    public int getEagerFetchMode() {\n+        try {\n+            return getJDBCDelegate().getEagerFetchMode();\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public JDBCFetchConfiguration setEagerFetchMode(int mode) {\n+        try {\n+            getJDBCDelegate().setEagerFetchMode(mode);\n+            return this;\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public int getSubclassFetchMode() {\n+        try {\n+            return getJDBCDelegate().getSubclassFetchMode();\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public int getSubclassFetchMode(ClassMapping cls) {\n+        try {\n+            return getJDBCDelegate().getSubclassFetchMode(cls);\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public JDBCFetchConfiguration setSubclassFetchMode(int mode) {\n+        try {\n+            getJDBCDelegate().setSubclassFetchMode(mode);\n+            return this;\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public int getResultSetType() {\n+        try {\n+            return getJDBCDelegate().getResultSetType();\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public JDBCFetchConfiguration setResultSetType(int type) {\n+        try {\n+            getJDBCDelegate().setResultSetType(type);\n+            return this;\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public int getFetchDirection() {\n+        try {\n+            return getJDBCDelegate().getFetchDirection();\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public JDBCFetchConfiguration setFetchDirection(int direction) {\n+        try {\n+            getJDBCDelegate().setFetchDirection(direction);\n+            return this;\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public int getLRSSize() {\n+        try {\n+            return getJDBCDelegate().getLRSSize();\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public JDBCFetchConfiguration setLRSSize(int lrsSize) {\n+        try {\n+            getJDBCDelegate().setLRSSize(lrsSize);\n+            return this;\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public int getJoinSyntax() {\n+        try {\n+            return getJDBCDelegate().getJoinSyntax();\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public JDBCFetchConfiguration setJoinSyntax(int syntax) {\n+        try {\n+            getJDBCDelegate().setJoinSyntax(syntax);\n+            return this;\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public String[] getJoins() {\n+        try {\n+            return getJDBCDelegate().getJoins();\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public boolean hasJoin(String field) {\n+        try {\n+            return getJDBCDelegate().hasJoin(field);\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public JDBCFetchConfiguration addJoin(String field) {\n+        try {\n+            getJDBCDelegate().addJoin(field);\n+            return this;\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public JDBCFetchConfiguration addJoins(Collection fields) {\n+        try {\n+            getJDBCDelegate().addJoins(fields);\n+            return this;\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public JDBCFetchConfiguration removeJoin(String field) {\n+        try {\n+            getJDBCDelegate().removeJoin(field);\n+            return this;\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public JDBCFetchConfiguration removeJoins(Collection fields) {\n+        try {\n+            getJDBCDelegate().removeJoins(fields);\n+            return this;\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public JDBCFetchConfiguration clearJoins() {\n+        try {\n+            getJDBCDelegate().clearJoins();\n+            return this;\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+}"},{"sha":"43447a46276b5812c4a50e2bd3f7af0fcb33544d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/EagerFetchModes.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/EagerFetchModes.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/EagerFetchModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/EagerFetchModes.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+/**\n+ * Eager fetch mode constants.\n+ *\n+ * @author Abe White\n+ */\n+public interface EagerFetchModes {\n+\n+    /**\n+     * Constant indicating not to try to load subclass data and related\n+     * objects when querying for an object.\n+     */\n+    public static final int EAGER_NONE = 0;\n+\n+    /**\n+     * Constant indicating to load relations and subclass data if possible\n+     * without separate queries.\n+     */\n+    public static final int EAGER_JOIN = 1;\n+\n+    /**\n+     * Constant indicating to load relations and subclass data if possible\n+     * using either joins or parallel queries.\n+     */\n+    public static final int EAGER_PARALLEL = 2;\n+}"},{"sha":"d3d82b3e81296ecb999d355f8ba8a247a5ca6fa2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/GenericResultObjectProvider.java","status":"added","additions":127,"deletions":0,"changes":127,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/GenericResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/GenericResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/GenericResultObjectProvider.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.util.StoreException;\n+import org.apache.openjpa.util.UnsupportedException;\n+\n+/**\n+ * Object provider implementation wrapped around a generic {@link Result}.\n+ *\n+ * @author Abe White\n+ */\n+public class GenericResultObjectProvider\n+    implements ResultObjectProvider {\n+\n+    private final ClassMapping _mapping;\n+    private final JDBCStore _store;\n+    private final JDBCFetchConfiguration _fetch;\n+    private final Result _res;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param pcClass the base class of the result objects\n+     * @param store the store manager to delegate loading to\n+     * @param fetch the fetch configuration, or null for default\n+     * @param res the result containing the data\n+     */\n+    public GenericResultObjectProvider(Class pcClass,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Result res) {\n+        this(store.getConfiguration().getMappingRepository().getMapping\n+            (pcClass, store.getContext().getClassLoader(), true),\n+            store, fetch, res);\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param mapping the mapping for the base class of the result objects\n+     * @param store the store manager to delegate loading to\n+     * @param fetch the fetch configuration, or null for default\n+     * @param res the result containing the data\n+     */\n+    public GenericResultObjectProvider(ClassMapping mapping,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Result res) {\n+        _mapping = mapping;\n+        _store = store;\n+        if (fetch == null)\n+            _fetch = store.getFetchConfiguration();\n+        else\n+            _fetch = fetch;\n+        _res = res;\n+    }\n+\n+    public boolean supportsRandomAccess() {\n+        try {\n+            return _res.supportsRandomAccess();\n+        } catch (Throwable t) {\n+            return false;\n+        }\n+    }\n+\n+    public void open() {\n+    }\n+\n+    public Object getResultObject()\n+        throws SQLException {\n+        // rather than use the standard result.load(), we go direct to\n+        // the store manager so we can tell it not to load anything additional\n+        return ((JDBCStoreManager) _store).load(_mapping,\n+            (JDBCFetchState) _fetch.newFetchState(), StoreContext.EXCLUDE_ALL,\n+            _res);\n+    }\n+\n+    public boolean next()\n+        throws SQLException {\n+        return _res.next();\n+    }\n+\n+    public boolean absolute(int pos)\n+        throws SQLException {\n+        return _res.absolute(pos);\n+    }\n+\n+    public int size()\n+        throws SQLException {\n+        if (_fetch.getLRSSize() == LRSSizes.SIZE_UNKNOWN\n+            || !supportsRandomAccess())\n+            return Integer.MAX_VALUE;\n+        return _res.size();\n+    }\n+\n+    public void reset() {\n+        throw new UnsupportedException();\n+    }\n+\n+    public void close() {\n+        _res.close();\n+    }\n+\n+    public void handleCheckedException(Exception e) {\n+        if (e instanceof SQLException)\n+            throw SQLExceptions.getStore((SQLException) e,\n+                _store.getDBDictionary());\n+        throw new StoreException(e);\n+    }\n+}"},{"sha":"1693386dd72d55f8ddd2e280e7888eb87f192e3e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/InstanceResultObjectProvider.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/InstanceResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/InstanceResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/InstanceResultObjectProvider.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.jdbc.sql.SelectExecutor;\n+\n+/**\n+ * Object provider implementation wrapped around a {@link Select}.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class InstanceResultObjectProvider\n+    extends SelectResultObjectProvider {\n+\n+    private final ClassMapping _mapping;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param sel the select to execute\n+     * @param mapping the mapping for the base class of the result objects\n+     * @param store the store to delegate loading to\n+     * @param fetch the fetch configuration, or null for default\n+     */\n+    public InstanceResultObjectProvider(SelectExecutor sel,\n+        ClassMapping mapping, JDBCStore store, JDBCFetchState fetchState) {\n+        super(sel, store, fetchState);\n+        _mapping = mapping;\n+    }\n+\n+    public Object getResultObject()\n+        throws SQLException {\n+        Result res = getResult();\n+        ClassMapping mapping = res.getBaseMapping();\n+        if (mapping == null)\n+            mapping = _mapping;\n+        return res.load(mapping, getStore(), (JDBCFetchState) getFetchState());\n+    }\n+}"},{"sha":"cf7ad53e8590b08a8a9d86f9ff6b2d977e3373a4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCBrokerFactory.java","status":"added","additions":168,"deletions":0,"changes":168,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCBrokerFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Properties;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.jdbc.meta.MappingTool;\n+import org.apache.openjpa.kernel.AbstractBrokerFactory;\n+import org.apache.openjpa.kernel.Bootstrap;\n+import org.apache.openjpa.kernel.BrokerImpl;\n+import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * BrokerFactory type for use with the JDBC runtime.\n+ *\n+ * @author Abe White\n+ * @author Marc Prud'hommeaux\n+ */\n+public class JDBCBrokerFactory\n+    extends AbstractBrokerFactory {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (JDBCBrokerFactory.class);\n+\n+    private boolean _synchronizedMappings = false;\n+\n+    /**\n+     * Factory method for constructing a factory from properties. Invoked from\n+     * {@link Bootstrap#newBrokerFactory}.\n+     */\n+    public static JDBCBrokerFactory newInstance(ConfigurationProvider cp) {\n+        JDBCConfigurationImpl conf = new JDBCConfigurationImpl();\n+        cp.setInto(conf);\n+        return new JDBCBrokerFactory(conf);\n+    }\n+\n+    /**\n+     * Factory method for obtaining a possibly-pooled factory from properties.\n+     * Invoked from {@link Bootstrap#getBrokerFactory}.\n+     */\n+    public static JDBCBrokerFactory getInstance(ConfigurationProvider cp) {\n+        JDBCBrokerFactory factory = (JDBCBrokerFactory) getPooledFactory\n+            (cp.getProperties());\n+        if (factory != null)\n+            return factory;\n+\n+        factory = newInstance(cp);\n+        factory.pool();\n+        return factory;\n+    }\n+\n+    /**\n+     * Factory method for constructing a factory from a configuration.\n+     */\n+    public static synchronized JDBCBrokerFactory getInstance\n+        (JDBCConfiguration conf) {\n+        JDBCBrokerFactory factory = (JDBCBrokerFactory) getPooledFactory\n+            (conf.toProperties(false));\n+        if (factory != null)\n+            return factory;\n+\n+        factory = new JDBCBrokerFactory(conf);\n+        factory.pool();\n+        return factory;\n+    }\n+\n+    /**\n+     * Construct the factory with the given option settings; however, the\n+     * factory construction methods are recommended.\n+     */\n+    public JDBCBrokerFactory(JDBCConfiguration conf) {\n+        super(conf);\n+    }\n+\n+    public Properties getProperties() {\n+        // add platform property\n+        Properties props = super.getProperties();\n+        String db = \"Unknown\";\n+        try {\n+            JDBCConfiguration conf = (JDBCConfiguration) getConfiguration();\n+            db = conf.getDBDictionaryInstance().platform;\n+        } catch (RuntimeException re) {\n+        }\n+        props.setProperty(\"Platform\",\n+            \"OpenJPA JDBC Edition: \" + db + \" Database\");\n+\n+        return props;\n+    }\n+\n+    protected StoreManager newStoreManager() {\n+        return new JDBCStoreManager();\n+    }\n+\n+    protected BrokerImpl newBrokerImpl(String user, String pass) {\n+        BrokerImpl broker = super.newBrokerImpl(user, pass);\n+\n+        lock();\n+        try {\n+            // synchronize mappings; we wait until now to do this so that\n+            // we can use the first broker user/pass for connection if no\n+            // global login is given\n+            if (!_synchronizedMappings) {\n+                _synchronizedMappings = true;\n+                synchronizeMappings(broker.getClassLoader());\n+            }\n+\n+            return broker;\n+        } finally {\n+            unlock();\n+        }\n+    }\n+\n+    /**\n+     * Synchronize the mappings of the classes listed in the configuration.\n+     */\n+    private void synchronizeMappings(ClassLoader loader) {\n+        JDBCConfiguration conf = (JDBCConfiguration) getConfiguration();\n+        String action = conf.getSynchronizeMappings();\n+        if (action == null || action.length() == 0)\n+            return;\n+\n+        Collection classes = conf.getMetaDataRepository().\n+            loadPersistentTypes(false, loader);\n+        if (classes.isEmpty())\n+            return;\n+\n+        String props = Configurations.getProperties(action);\n+        action = Configurations.getClassName(action);\n+        MappingTool tool = new MappingTool(conf, action, false);\n+        Configurations.configureInstance(tool, conf, props,\n+            \"SynchronizeMappings\");\n+\n+        // initialize the schema\n+        Class cls;\n+        for (Iterator itr = classes.iterator(); itr.hasNext();) {\n+            cls = (Class) itr.next();\n+            try {\n+                tool.run(cls);\n+            } catch (IllegalArgumentException iae) {\n+                throw new UserException(_loc.get(\"bad-synch-mappings\",\n+                    action, Arrays.asList(MappingTool.ACTIONS)));\n+            }\n+        }\n+        tool.record();\n+    }\n+}"},{"sha":"68a5d3956d4a0910a43f438717883ccc97780469","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfiguration.java","status":"added","additions":164,"deletions":0,"changes":164,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfiguration.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.ResultSet;\n+import java.util.Collection;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.JoinSyntaxes;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+\n+/**\n+ * JDBC extensions to OpenJPA's {@link FetchConfiguration}.\n+ *\n+ * @author Abe White\n+ * @since 3.0\n+ */\n+public interface JDBCFetchConfiguration\n+    extends FetchConfiguration, EagerFetchModes, LRSSizes, JoinSyntaxes {\n+\n+    /**\n+     * Return the eager fetch mode. Defaults to the\n+     * <code>openjpa.jdbc.EagerFetchMode</code> setting.\n+     */\n+    public int getEagerFetchMode();\n+\n+    /**\n+     * Set the eager fetch mode. Defaults to the\n+     * <code>openjpa.jdbc.EagerFetchMode</code> setting.\n+     */\n+    public JDBCFetchConfiguration setEagerFetchMode(int mode);\n+\n+    /**\n+     * Return the subclass fetch mode. Defaults to the\n+     * <code>openjpa.jdbc.SubclassFetchMode</code> setting.\n+     */\n+    public int getSubclassFetchMode();\n+\n+    /**\n+     * Return the effective subclass fetch mode for the given type.\n+     */\n+    public int getSubclassFetchMode(ClassMapping cls);\n+\n+    /**\n+     * Set the subclass fetch mode. Defaults to the\n+     * <code>openjpa.jdbc.SubclassFetchMode</code> setting.\n+     */\n+    public JDBCFetchConfiguration setSubclassFetchMode(int mode);\n+\n+    /**\n+     * The result set type to use as a constant from {@link ResultSet}.\n+     * Defaults to the <code>openjpa.jdbc.ResultSetType</code> setting.\n+     */\n+    public int getResultSetType();\n+\n+    /**\n+     * The result set type to use as a constant from {@link ResultSet}.\n+     * Defaults to the <code>openjpa.jdbc.ResultSetType</code> setting.\n+     */\n+    public JDBCFetchConfiguration setResultSetType(int type);\n+\n+    /**\n+     * The fetch direction to use as a constant from {@link ResultSet}.\n+     * Defaults to the <code>openjpa.jdbc.FetchDirection</code> setting.\n+     */\n+    public int getFetchDirection();\n+\n+    /**\n+     * The fetch direction to use as a constant from {@link ResultSet}.\n+     * Defaults to the <code>openjpa.jdbc.FetchDirection</code> setting.\n+     */\n+    public JDBCFetchConfiguration setFetchDirection(int direction);\n+\n+    /**\n+     * The large result set size mode to use.\n+     * Defaults to the <code>openjpa.jdbc.LRSSize</code> setting.\n+     */\n+    public int getLRSSize();\n+\n+    /**\n+     * The large result set size mode to use.\n+     * Defaults to the <code>openjpa.jdbc.LRSSize</code> setting.\n+     */\n+    public JDBCFetchConfiguration setLRSSize(int lrsSize);\n+\n+    /**\n+     * The join syntax to use.\n+     */\n+    public int getJoinSyntax();\n+\n+    /**\n+     * The join syntax to use.\n+     */\n+    public JDBCFetchConfiguration setJoinSyntax(int syntax);\n+\n+    /**\n+     * Returns the names of the joins that this component will use\n+     * when loading objects. Defaults to the empty set.\n+     *\n+     * @since 4.0.0\n+     */\n+    public String[] getJoins();\n+\n+    /**\n+     * Return true if the given fully-qualified join has been added.\n+     *\n+     * @since 4.0.0\n+     */\n+    public boolean hasJoin(String field);\n+\n+    /**\n+     * Adds <code>field</code> to the set of fully-qualified field names to\n+     * eagerly join when loading objects. Each class can have at most\n+     * one to-many eagerly joined fields.\n+     *\n+     * @since 4.0.0\n+     */\n+    public JDBCFetchConfiguration addJoin(String field);\n+\n+    /**\n+     * Adds <code>fields</code> to the set of fully-qualified field names to\n+     * eagerly join when loading objects. Each class can have at most\n+     * one to-many eagerly joined fields.\n+     *\n+     * @since 4.0.0\n+     */\n+    public JDBCFetchConfiguration addJoins(Collection fields);\n+\n+    /**\n+     * Removes <code>field</code> to the set of fully-qualified field names to\n+     * eagerly join when loading objects.\n+     *\n+     * @since 4.0.0\n+     */\n+    public JDBCFetchConfiguration removeJoin(String field);\n+\n+    /**\n+     * Removes <code>fields</code> from the set of fully-qualified\n+     * field names to eagerly join when loading objects.\n+     *\n+     * @since 4.0.0\n+     */\n+    public JDBCFetchConfiguration removeJoins(Collection fields);\n+\n+    /**\n+     * Clears the set of field names to join when loading data.\n+     *\n+     * @since 4.0.0\n+     */\n+    public JDBCFetchConfiguration clearJoins();\n+}"},{"sha":"779cd575cae2b77fce2386263fc49e4a4b43aa57","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfigurationImpl.java","status":"added","additions":285,"deletions":0,"changes":285,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfigurationImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,285 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.ResultSet;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.FetchConfigurationImpl;\n+import org.apache.openjpa.kernel.FetchState;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.rop.EagerResultList;\n+import org.apache.openjpa.lib.rop.ListResultObjectProvider;\n+import org.apache.openjpa.lib.rop.ResultList;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.lib.rop.SimpleResultList;\n+import org.apache.openjpa.lib.rop.SoftRandomAccessResultList;\n+import org.apache.openjpa.lib.rop.WindowResultList;\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+/**\n+ * JDBC extensions to OpenJPA's {@link FetchConfiguration}.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class JDBCFetchConfigurationImpl\n+    extends FetchConfigurationImpl\n+    implements JDBCFetchConfiguration {\n+\n+    private static final String[] EMPTY_STRINGS = new String[0];\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (JDBCFetchConfigurationImpl.class);\n+\n+    private int _eagerMode = 0;\n+    private int _subclassMode = 0;\n+    private int _type = 0;\n+    private int _direction = 0;\n+    private int _size = 0;\n+    private int _syntax = 0;\n+\n+    private Set _joins = null;\n+\n+    public void setContext(StoreContext ctx) {\n+        super.setContext(ctx);\n+        JDBCConfiguration conf = getJDBCConfiguration();\n+        if (conf == null)\n+            return;\n+\n+        setEagerFetchMode(conf.getEagerFetchModeConstant());\n+        setSubclassFetchMode(conf.getSubclassFetchModeConstant());\n+        setResultSetType(conf.getResultSetTypeConstant());\n+        setFetchDirection(conf.getFetchDirectionConstant());\n+        setLRSSize(conf.getLRSSizeConstant());\n+        setJoinSyntax(conf.getDBDictionaryInstance().joinSyntax);\n+    }\n+\n+    protected FetchConfigurationImpl newInstance() {\n+        JDBCFetchConfigurationImpl fetch = new JDBCFetchConfigurationImpl();\n+        return fetch;\n+    }\n+\n+    public void copy(FetchConfiguration fetch) {\n+        super.copy(fetch);\n+        JDBCFetchConfiguration jf = (JDBCFetchConfiguration) fetch;\n+        setEagerFetchMode(jf.getEagerFetchMode());\n+        setSubclassFetchMode(jf.getSubclassFetchMode());\n+        setResultSetType(jf.getResultSetType());\n+        setFetchDirection(jf.getFetchDirection());\n+        setLRSSize(jf.getLRSSize());\n+        setJoinSyntax(jf.getJoinSyntax());\n+        addJoins(Arrays.asList(jf.getJoins()));\n+    }\n+\n+    public int getEagerFetchMode() {\n+        return _eagerMode;\n+    }\n+\n+    public JDBCFetchConfiguration setEagerFetchMode(int mode) {\n+        if (mode == DEFAULT) {\n+            JDBCConfiguration conf = getJDBCConfiguration();\n+            if (conf != null)\n+                mode = conf.getEagerFetchModeConstant();\n+        }\n+        if (mode != DEFAULT)\n+            _eagerMode = mode;\n+        return this;\n+    }\n+\n+    public int getSubclassFetchMode() {\n+        return _subclassMode;\n+    }\n+\n+    public int getSubclassFetchMode(ClassMapping cls) {\n+        if (cls == null)\n+            return _subclassMode;\n+        int mode = cls.getSubclassFetchMode();\n+        if (mode == DEFAULT)\n+            return _subclassMode;\n+        return Math.min(mode, _subclassMode);\n+    }\n+\n+    public JDBCFetchConfiguration setSubclassFetchMode(int mode) {\n+        if (mode == DEFAULT) {\n+            JDBCConfiguration conf = getJDBCConfiguration();\n+            if (conf != null)\n+                mode = conf.getSubclassFetchModeConstant();\n+        }\n+        if (mode != DEFAULT)\n+            _subclassMode = mode;\n+        return this;\n+    }\n+\n+    public int getResultSetType() {\n+        return _type;\n+    }\n+\n+    public JDBCFetchConfiguration setResultSetType(int type) {\n+        if (type == DEFAULT) {\n+            JDBCConfiguration conf = getJDBCConfiguration();\n+            if (conf != null)\n+                _type = conf.getResultSetTypeConstant();\n+        } else\n+            _type = type;\n+        return this;\n+    }\n+\n+    public int getFetchDirection() {\n+        return _direction;\n+    }\n+\n+    public JDBCFetchConfiguration setFetchDirection(int direction) {\n+        if (direction == DEFAULT) {\n+            JDBCConfiguration conf = getJDBCConfiguration();\n+            if (conf != null)\n+                _direction = conf.getFetchDirectionConstant();\n+        } else\n+            _direction = direction;\n+        return this;\n+    }\n+\n+    public int getLRSSize() {\n+        return _size;\n+    }\n+\n+    public JDBCFetchConfiguration setLRSSize(int size) {\n+        if (size == DEFAULT) {\n+            JDBCConfiguration conf = getJDBCConfiguration();\n+            if (conf != null)\n+                _size = conf.getLRSSizeConstant();\n+        } else\n+            _size = size;\n+        return this;\n+    }\n+\n+    public int getJoinSyntax() {\n+        return _syntax;\n+    }\n+\n+    public JDBCFetchConfiguration setJoinSyntax(int syntax) {\n+        if (syntax == DEFAULT) {\n+            JDBCConfiguration conf = getJDBCConfiguration();\n+            if (conf != null)\n+                _syntax = conf.getDBDictionaryInstance().joinSyntax;\n+        } else\n+            _syntax = syntax;\n+        return this;\n+    }\n+\n+    public ResultList newResultList(ResultObjectProvider rop) {\n+        // if built around a list, just use a simple wrapper\n+        if (rop instanceof ListResultObjectProvider)\n+            return new SimpleResultList(rop);\n+\n+        // if built around a paging list, use a window provider with the\n+        // same window size\n+        if (rop instanceof PagingResultObjectProvider)\n+            return new WindowResultList(rop, ((PagingResultObjectProvider)\n+                rop).getPageSize());\n+\n+        // if fetch size < 0 just read in all results immediately\n+        if (getFetchBatchSize() < 0)\n+            return new EagerResultList(rop);\n+\n+        // if foward only or forward direction use a forward window\n+        if (_type == ResultSet.TYPE_FORWARD_ONLY\n+            || _direction == ResultSet.FETCH_FORWARD\n+            || !rop.supportsRandomAccess()) {\n+            if (getFetchBatchSize() > 0 && getFetchBatchSize() <= 50)\n+                return new WindowResultList(rop, getFetchBatchSize());\n+            return new WindowResultList(rop, 50);\n+        }\n+\n+        // if skipping around use a caching random access list\n+        if (_direction == ResultSet.FETCH_UNKNOWN)\n+            return new SoftRandomAccessResultList(rop);\n+\n+        // scrolling reverse... just use non-caching simple result list\n+        return new SimpleResultList(rop);\n+    }\n+\n+    /**\n+     * Access JDBC configuration information. May return null if not a\n+     * JDBC back-end (possible to get a JDBCFetchConfiguration on non-JDBC\n+     * back end in remote client).\n+     */\n+    private JDBCConfiguration getJDBCConfiguration() {\n+        StoreContext ctx = getContext();\n+        if (ctx == null)\n+            return null;\n+\n+        OpenJPAConfiguration conf = ctx.getConfiguration();\n+        if (!(conf instanceof JDBCConfiguration))\n+            return null;\n+        return (JDBCConfiguration) conf;\n+    }\n+\n+    public synchronized String[] getJoins() {\n+        if (_joins == null || _joins.isEmpty())\n+            return EMPTY_STRINGS;\n+        return (String[]) _joins.toArray(new String[_joins.size()]);\n+    }\n+\n+    public synchronized boolean hasJoin(String field) {\n+        return _joins != null && field != null && _joins.contains(field);\n+    }\n+\n+    public synchronized JDBCFetchConfiguration addJoin(String field) {\n+        if (_joins == null)\n+            _joins = new HashSet();\n+        _joins.add(field);\n+        return this;\n+    }\n+\n+    public synchronized JDBCFetchConfiguration addJoins(Collection fields) {\n+        if (fields.isEmpty())\n+            return this;\n+        if (_joins == null)\n+            _joins = new HashSet();\n+        _joins.addAll(fields);\n+        return this;\n+    }\n+\n+    public synchronized JDBCFetchConfiguration removeJoin(String field) {\n+        if (_joins != null)\n+            _joins.remove(field);\n+        return this;\n+    }\n+\n+    public synchronized JDBCFetchConfiguration removeJoins(Collection fields) {\n+        if (_joins != null)\n+            _joins.removeAll(fields);\n+        return this;\n+    }\n+\n+    public synchronized JDBCFetchConfiguration clearJoins() {\n+        if (_joins != null)\n+            _joins.clear();\n+        return this;\n+    }\n+\n+    public FetchState newFetchState() {\n+        return new JDBCFetchStateImpl(this);\n+    }\n+}"},{"sha":"75ccf3be94b121740942dfdc3c36c42558fba73a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchState.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchState.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchState.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import org.apache.openjpa.kernel.FetchState;\n+\n+/**\n+ * Store-specific extension of {@link org.apache.openjpa.kernel.FetchState FetchState}.\n+ *\n+ * @author <A HREF=\"mailto:pinaki.poddar@gmail.com>Pinaki Poddar</A>\n+ */\n+public interface JDBCFetchState\n+    extends FetchState {\n+\n+    /**\n+     * Returns store-specific fetch configuration.\n+     */\n+    public JDBCFetchConfiguration getJDBCFetchConfiguration();\n+}"},{"sha":"6c5fcedfcc74cc3eb4eb58da935ef2af9094aa60","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchStateImpl.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchStateImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchStateImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchStateImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import org.apache.openjpa.kernel.FetchStateImpl;\n+\n+/**\n+ * JDBC-specific implementation of fetch state.\n+ *\n+ * @author <A HREF=\"mailto:pinaki.poddar@gmail.com>Pinaki Poddar</A>\n+ * @nojavadoc\n+ */\n+class JDBCFetchStateImpl\n+    extends FetchStateImpl\n+    implements JDBCFetchState {\n+\n+    /**\n+     * Supply immutable configuration.\n+     *\n+     * @param fc\n+     */\n+    JDBCFetchStateImpl(JDBCFetchConfiguration fc) {\n+        super(fc);\n+    }\n+\n+    public JDBCFetchConfiguration getJDBCFetchConfiguration() {\n+        return (JDBCFetchConfiguration) super.getFetchConfiguration();\n+    }\n+}"},{"sha":"accd7a04e9d6337e571e8d4e54838378142d0b19","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCLockManager.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCLockManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.LockManager;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * Extension of the {@link LockManager} interface with methods for\n+ * datastore locking during the select and load process. Implementors of\n+ * this interface can also take advantage of the fact that in the\n+ * {@link LockManager#lock} and {@link LockManager#lockAll} methods, the\n+ * given <code>conn</code> parameter, if any, will be an instance of\n+ * {@link ConnectionInfo}.\n+ *\n+ * @author Abe White\n+ */\n+public interface JDBCLockManager\n+    extends LockManager {\n+\n+    /**\n+     * Return whether to issue the given select FOR UPDATE, depending on\n+     * the capabilities of the dictionary and the fetch configuration.\n+     */\n+    public boolean selectForUpdate(Select sel, int lockLevel);\n+\n+    /**\n+     * Notification that the given instance was loaded via a result set\n+     * produced by a FOR UPDATE select.\n+     */\n+    public void loadedForUpdate(OpenJPAStateManager sm);\n+}"},{"sha":"7c9beb08b28523db5560b3abe002d36feca53b52","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCSeq.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCSeq.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.schema.SchemaGroup;\n+import org.apache.openjpa.kernel.Seq;\n+\n+/**\n+ * Specialization of the the {@link Seq} interface to provide information\n+ * on the schema needed by this sequence. Only sequences that require special\n+ * tables that must be created by OpenJPA tools need to implement this\n+ * interface.\n+ *\n+ * @author Abe White\n+ */\n+public interface JDBCSeq\n+    extends Seq {\n+\n+    /**\n+     * Add any tables, etc needed by this factory for the given mapping\n+     * to the given schema group, if they do not exist already.\n+     */\n+    public void addSchema(ClassMapping mapping, SchemaGroup group);\n+}"},{"sha":"af933c520ee2141d82825e202c065a9cfeecdcfa","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStore.java","status":"added","additions":106,"deletions":0,"changes":106,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStore.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStore.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStore.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.ValueMapping;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLFactory;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.util.Id;\n+\n+/**\n+ * Represents the JDBC store.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+public interface JDBCStore {\n+\n+    /**\n+     * Current persistence context.\n+     */\n+    public StoreContext getContext();\n+\n+    /**\n+     * Return the configuration for this runtime.\n+     */\n+    public JDBCConfiguration getConfiguration();\n+\n+    /**\n+     * Return the dictionary in use.\n+     */\n+    public DBDictionary getDBDictionary();\n+\n+    /**\n+     * Return the SQL factory for this runtime.\n+     */\n+    public SQLFactory getSQLFactory();\n+\n+    /**\n+     * If the lock manager in use is a {@link JDBCLockManager}, return it.\n+     */\n+    public JDBCLockManager getLockManager();\n+\n+    /**\n+     * Return a SQL connection to the database.\n+     * The <code>close</code> method should always be called on the connection\n+     * to free any resources it is using. When appropriate, the close\n+     * method is implemented as a no-op.\n+     */\n+    public Connection getConnection();\n+\n+    /**\n+     * Return the current default fetch configuration.\n+     */\n+    public JDBCFetchConfiguration getFetchConfiguration();\n+\n+    /**\n+     * Create a new datastore identity object from the given id value and\n+     * mapping.\n+     */\n+    public Id newDataStoreId(long id, ClassMapping mapping, boolean subs);\n+\n+    /**\n+     * Find the object with the given oid. Convenience method on top of\n+     * the store's persistence context.\n+     *\n+     * @param vm the mapping holding this oid, or null if not applicable\n+     */\n+    public Object find(Object oid, ValueMapping vm,\n+        JDBCFetchState fetchState);\n+\n+    /**\n+     * Makes sure all subclasses of the given type are loaded in the JVM.\n+     * This is usually done automatically.\n+     */\n+    public void loadSubclasses(ClassMapping mapping);\n+\n+    /**\n+     * Add WHERE conditions to the given select limiting the returned results\n+     * to the given mapping type, possibly including subclasses.\n+     *\n+     * @return true if the mapping was joined down to its base class\n+     * in order to add the conditions\n+     */\n+    public boolean addClassConditions(Select sel, ClassMapping mapping,\n+        boolean subs, Joins joins);\n+}"},{"sha":"41ba7040bf0e452155b2ab422dc72178a4c535f4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","status":"added","additions":1458,"deletions":0,"changes":1458,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,1458 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+import javax.sql.DataSource;\n+\n+import org.apache.openjpa.event.OrphanedKeyAction;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.Discriminator;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.ValueMapping;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.JoinSyntaxes;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.jdbc.sql.SQLFactory;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.jdbc.sql.SelectExecutor;\n+import org.apache.openjpa.jdbc.sql.Union;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.FetchState;\n+import org.apache.openjpa.kernel.LockManager;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.PCState;\n+import org.apache.openjpa.kernel.QueryLanguages;\n+import org.apache.openjpa.kernel.Seq;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.kernel.exps.ExpressionParser;\n+import org.apache.openjpa.lib.jdbc.DelegatingConnection;\n+import org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement;\n+import org.apache.openjpa.lib.jdbc.DelegatingStatement;\n+import org.apache.openjpa.lib.rop.MergedResultObjectProvider;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.ValueStrategies;\n+import org.apache.openjpa.util.ApplicationIds;\n+import org.apache.openjpa.util.Id;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.util.InvalidStateException;\n+import org.apache.openjpa.util.OpenJPAId;\n+import org.apache.openjpa.util.StoreException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * StoreManager plugin that uses JDBC to store persistent data in a\n+ * relational data store.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class JDBCStoreManager\n+    implements StoreManager, JDBCStore {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (JDBCStoreManager.class);\n+\n+    private StoreContext _ctx = null;\n+    private JDBCConfiguration _conf = null;\n+    private DBDictionary _dict = null;\n+    private SQLFactory _sql = null;\n+    private JDBCLockManager _lm = null;\n+    private DataSource _ds = null;\n+    private RefCountConnection _conn = null;\n+    private boolean _active = false;\n+\n+    // track the pending statements so we can cancel them\n+    private Set _stmnts = Collections.synchronizedSet(new HashSet());\n+\n+    public StoreContext getContext() {\n+        return _ctx;\n+    }\n+\n+    public void setContext(StoreContext ctx) {\n+        _ctx = ctx;\n+        _conf = (JDBCConfiguration) ctx.getConfiguration();\n+        _dict = _conf.getDBDictionaryInstance();\n+        _sql = _conf.getSQLFactoryInstance();\n+\n+        LockManager lm = ctx.getLockManager();\n+        if (lm instanceof JDBCLockManager)\n+            _lm = (JDBCLockManager) lm;\n+\n+        if (!ctx.isManaged() && _conf.isConnectionFactoryModeManaged())\n+            _ds = _conf.getDataSource2(ctx);\n+        else\n+            _ds = _conf.getDataSource(ctx);\n+\n+        if (_conf.getUpdateManagerInstance().orderDirty())\n+            ctx.setOrderDirtyObjects(true);\n+    }\n+\n+    public JDBCConfiguration getConfiguration() {\n+        return _conf;\n+    }\n+\n+    public DBDictionary getDBDictionary() {\n+        return _dict;\n+    }\n+\n+    public SQLFactory getSQLFactory() {\n+        return _sql;\n+    }\n+\n+    public JDBCLockManager getLockManager() {\n+        return _lm;\n+    }\n+\n+    public JDBCFetchConfiguration getFetchConfiguration() {\n+        return (JDBCFetchConfiguration) _ctx.getFetchConfiguration();\n+    }\n+\n+    private JDBCFetchConfiguration getFetchConfiguration\n+        (JDBCFetchState fetchState) {\n+        return (fetchState == null) ? getFetchConfiguration()\n+            : fetchState.getJDBCFetchConfiguration();\n+    }\n+\n+    public void beginOptimistic() {\n+    }\n+\n+    public void rollbackOptimistic() {\n+    }\n+\n+    public void begin() {\n+        _active = true;\n+        try {\n+            if ((!_ctx.isManaged() || !_conf.isConnectionFactoryModeManaged())\n+                && _conn.getAutoCommit())\n+                _conn.setAutoCommit(false);\n+        } catch (SQLException se) {\n+            _active = false;\n+            throw SQLExceptions.getStore(se, _dict);\n+        }\n+    }\n+\n+    public void commit() {\n+        try {\n+            if (!_ctx.isManaged() || !_conf.isConnectionFactoryModeManaged())\n+                _conn.commit();\n+        } catch (SQLException se) {\n+            try {\n+                _conn.rollback();\n+            } catch (SQLException se2) {\n+            }\n+            throw SQLExceptions.getStore(se, _dict);\n+        } finally {\n+            _active = false;\n+        }\n+    }\n+\n+    public void rollback() {\n+        // already rolled back ourselves?\n+        if (!_active)\n+            return;\n+\n+        try {\n+            if (_conn != null && (!_ctx.isManaged()\n+                || !_conf.isConnectionFactoryModeManaged()))\n+                _conn.rollback();\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, _dict);\n+        } finally {\n+            _active = false;\n+        }\n+    }\n+\n+    public void retainConnection() {\n+        connect(false);\n+        _conn.setRetain(true);\n+    }\n+\n+    public void releaseConnection() {\n+        if (_conn != null)\n+            _conn.setRetain(false);\n+    }\n+\n+    public Object getClientConnection() {\n+        return new ClientConnection(getConnection());\n+    }\n+\n+    public Connection getConnection() {\n+        connect(true);\n+        return _conn;\n+    }\n+\n+    public boolean exists(OpenJPAStateManager sm, Object context) {\n+        // add where conditions on base class to avoid joins if subclass\n+        // doesn't use oid as identifier\n+        ClassMapping mapping = (ClassMapping) sm.getMetaData();\n+        return exists(mapping, sm.getObjectId(), context);\n+    }\n+\n+    private boolean exists(ClassMapping mapping, Object oid, Object context) {\n+        // add where conditions on base class to avoid joins if subclass\n+        // doesn't use oid as identifier\n+        Select sel = _sql.newSelect();\n+        while (mapping.getJoinablePCSuperclassMapping() != null)\n+            mapping = mapping.getJoinablePCSuperclassMapping();\n+\n+        sel.wherePrimaryKey(oid, mapping, this);\n+        try {\n+            return sel.getCount(this) != 0;\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, _dict);\n+        }\n+    }\n+\n+    public boolean syncVersion(OpenJPAStateManager sm, Object context) {\n+        ClassMapping mapping = (ClassMapping) sm.getMetaData();\n+        try {\n+            return mapping.getVersion().checkVersion(sm, this, true);\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, _dict);\n+        }\n+    }\n+\n+    public int compareVersion(OpenJPAStateManager state, Object v1, Object v2) {\n+        ClassMapping mapping = (ClassMapping) state.getMetaData();\n+        return mapping.getVersion().compareVersion(v1, v2);\n+    }\n+\n+    public boolean initialize(OpenJPAStateManager sm, PCState state,\n+        FetchState fetchState, Object context) {\n+        ConnectionInfo info = (ConnectionInfo) context;\n+        try {\n+            return initializeState(sm, state, (JDBCFetchState) fetchState,\n+                info);\n+        } catch (ClassNotFoundException cnfe) {\n+            throw new UserException(cnfe);\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, _dict);\n+        }\n+    }\n+\n+    /**\n+     * Initialize a newly-loaded instance.\n+     */\n+    private boolean initializeState(OpenJPAStateManager sm, PCState state,\n+        JDBCFetchState fetchState, ConnectionInfo info)\n+        throws ClassNotFoundException, SQLException {\n+        Object oid = sm.getObjectId();\n+        ClassMapping mapping = (ClassMapping) sm.getMetaData();\n+        JDBCFetchConfiguration jfetch = getFetchConfiguration(fetchState);\n+        Result res = null;\n+        if (info != null && info.result != null) {\n+            res = info.result;\n+            info.sm = sm;\n+            if (info.mapping == null)\n+                info.mapping = mapping;\n+            mapping = info.mapping;\n+        } else\n+        if (oid instanceof OpenJPAId && !((OpenJPAId) oid).hasSubclasses()) {\n+            Boolean custom = customLoad(sm, mapping, state, jfetch);\n+            if (custom != null)\n+                return custom.booleanValue();\n+            res = getInitializeStateResult(sm, mapping, fetchState,\n+                Select.SUBS_EXACT);\n+            if (res == null && !selectPrimaryKey(sm, mapping, jfetch))\n+                return false;\n+            if (res != null && !res.next())\n+                return false;\n+        } else {\n+            ClassMapping[] mappings = mapping.\n+                getIndependentAssignableMappings();\n+            if (mappings.length == 1) {\n+                mapping = mappings[0];\n+                Boolean custom = customLoad(sm, mapping, state, jfetch);\n+                if (custom != null)\n+                    return custom.booleanValue();\n+                res = getInitializeStateResult(sm, mapping, fetchState,\n+                    Select.SUBS_ANY_JOINABLE);\n+                if (res == null && !selectPrimaryKey(sm, mapping, jfetch))\n+                    return false;\n+            } else\n+                res = getInitializeStateUnionResult(sm, mapping, mappings,\n+                    fetchState);\n+            if (res != null && !res.next())\n+                return false;\n+        }\n+\n+        try {\n+            // figure out what type of object this is; the state manager\n+            // only guarantees to provide a base class\n+            Class type;\n+            if (res == null)\n+                type = mapping.getDescribedType();\n+            else {\n+                if (res.getBaseMapping() != null)\n+                    mapping = res.getBaseMapping();\n+                res.startDataRequest(mapping.getDiscriminator());\n+                try {\n+                    type = mapping.getDiscriminator().getClass(this, mapping,\n+                        res);\n+                } finally {\n+                    res.endDataRequest();\n+                }\n+            }\n+\n+            // initialize the state manager; this may change the mapping\n+            // and the object id instance if the type as determined\n+            // from the indicator is a subclass of expected type\n+            sm.initialize(type, state);\n+\n+            // load the selected mappings into the given state manager\n+            if (res != null) {\n+                // re-get the mapping in case the instance was a subclass\n+                mapping = (ClassMapping) sm.getMetaData();\n+\n+                load(mapping, sm, fetchState, res);\n+                mapping.getVersion().afterLoad(sm, this);\n+            }\n+            return true;\n+        } finally {\n+            if (res != null && (info == null || res != info.result))\n+                res.close();\n+        }\n+    }\n+\n+    /**\n+     * Allow the mapping to custom load data. Return null if the mapping\n+     * does not use custom loading.\n+     */\n+    private Boolean customLoad(OpenJPAStateManager sm, ClassMapping mapping,\n+        PCState state, JDBCFetchConfiguration jfetch)\n+        throws ClassNotFoundException, SQLException {\n+        // check to see if the mapping takes care of initialization\n+        if (!mapping.customLoad(sm, this, state, jfetch))\n+            return null;\n+        if (sm.getManagedInstance() != null) {\n+            mapping.getVersion().afterLoad(sm, this);\n+            return Boolean.TRUE;\n+        }\n+        return Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Select the data for the given instance and return the result. Return\n+     * null if there is no data in the current fetch groups to select.\n+     */\n+    private Result getInitializeStateResult(OpenJPAStateManager sm,\n+        ClassMapping mapping, JDBCFetchState fetchState, int subs)\n+        throws SQLException {\n+        Select sel = _sql.newSelect();\n+        if (!select(sel, mapping, subs, sm, null, fetchState,\n+            JDBCFetchConfiguration.EAGER_JOIN, true))\n+            return null;\n+\n+        sel.wherePrimaryKey(sm.getObjectId(), mapping, this);\n+        return sel.execute(this, getFetchConfiguration(fetchState));\n+    }\n+\n+    /**\n+     * Select a union of the data for the given instance from possible concrete\n+     * mappings and return the result.\n+     */\n+    private Result getInitializeStateUnionResult(final OpenJPAStateManager sm,\n+        ClassMapping mapping, final ClassMapping[] mappings,\n+        final JDBCFetchState fetchState)\n+        throws SQLException {\n+        final JDBCStoreManager store = this;\n+        JDBCFetchConfiguration jfetch = getFetchConfiguration(fetchState);\n+        final int eager = Math.min(jfetch.getEagerFetchMode(),\n+            JDBCFetchConfiguration.EAGER_JOIN);\n+\n+        Union union = _sql.newUnion(mappings.length);\n+        union.setSingleResult(true);\n+        if (jfetch.getSubclassFetchMode(mapping) != jfetch.EAGER_JOIN)\n+            union.abortUnion();\n+        union.select(new Union.Selector() {\n+            public void select(Select sel, int i) {\n+                sel.select(mappings[i], Select.SUBS_ANY_JOINABLE, store,\n+                    fetchState, eager);\n+                sel.wherePrimaryKey(sm.getObjectId(), mappings[i], store);\n+            }\n+        });\n+        return union.execute(this, jfetch);\n+    }\n+\n+    /**\n+     * Select primary key data to make sure the given instance exists, locking\n+     * if needed.\n+     */\n+    private boolean selectPrimaryKey(OpenJPAStateManager sm,\n+        ClassMapping mapping,\n+        JDBCFetchConfiguration jfetch)\n+        throws SQLException {\n+        // select pks from base class record to ensure it exists and lock\n+        // it if needed\n+        ClassMapping base = mapping;\n+        while (base.getJoinablePCSuperclassMapping() != null)\n+            base = base.getJoinablePCSuperclassMapping();\n+\n+        Select sel = _sql.newSelect();\n+        sel.select(base.getPrimaryKeyColumns());\n+        sel.wherePrimaryKey(sm.getObjectId(), base, this);\n+        Result exists = sel.execute(this, jfetch);\n+        try {\n+            if (!exists.next())\n+                return false;\n+\n+            // record locked?\n+            if (_active && _lm != null && exists.isLocking())\n+                _lm.loadedForUpdate(sm);\n+            return true;\n+        } finally {\n+            exists.close();\n+        }\n+    }\n+\n+    public boolean load(OpenJPAStateManager sm, BitSet fields,\n+        FetchState fetchState, int lockLevel, Object context) {\n+        JDBCFetchState jfetchState = (fetchState == null)\n+            ? (JDBCFetchState) getFetchConfiguration().newFetchState()\n+            : (JDBCFetchState) fetchState;\n+\n+        JDBCFetchConfiguration jfetch = getFetchConfiguration(jfetchState);\n+\n+        // get a connection, or reuse current one\n+        ConnectionInfo info = (ConnectionInfo) context;\n+        Result res = null;\n+        if (info != null) {\n+            // if initialize() fails to load required fields, then this method\n+            // is called; make sure not to try to use the given result if it's\n+            // the same one we just failed to completely initialize() with\n+            if (info.sm != sm)\n+                res = info.result;\n+            info.sm = null;\n+        }\n+        try {\n+            // if there's an existing result, load all we can from it\n+            ClassMapping mapping = (ClassMapping) sm.getMetaData();\n+            if (res != null) {\n+                load(mapping, sm, jfetchState, res);\n+                removeLoadedFields(sm, fields);\n+            }\n+\n+            // if the instance is hollow and there's a customized\n+            // get by id method, use it\n+            if (sm.getLoaded().length() == 0)\n+                if (mapping.customLoad(sm, this, null, jfetch))\n+                    removeLoadedFields(sm, fields);\n+\n+            //### select is kind of a big object, and in some cases we don't\n+            //### use it... would it be worth it to have a small shell select\n+            //### object that only creates a real select when actually used?\n+\n+            Select sel = _sql.newSelect();\n+            if (select(sel, mapping, sel.SUBS_EXACT, sm, fields, jfetchState,\n+                jfetch.EAGER_JOIN, true)) {\n+                sel.wherePrimaryKey(sm.getObjectId(), mapping, this);\n+                res = sel.execute(this, jfetch, lockLevel);\n+                try {\n+                    if (!res.next())\n+                        return false;\n+                    load(mapping, sm, jfetchState, res);\n+                } finally {\n+                    res.close();\n+                }\n+            }\n+\n+            // now allow the fields to load themselves individually too\n+            for (int i = 0, len = fields.length(); i < len; i++)\n+                if (fields.get(i) && !sm.getLoaded().get(i))\n+                    mapping.getFieldMapping(i).load(sm, this, jfetchState);\n+\n+            mapping.getVersion().afterLoad(sm, this);\n+            return true;\n+        } catch (ClassNotFoundException cnfe) {\n+            throw new StoreException(cnfe);\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, _dict);\n+        }\n+    }\n+\n+    /**\n+     * Return a list formed by removing all loaded fields from the given one.\n+     */\n+    private void removeLoadedFields(OpenJPAStateManager sm, BitSet fields) {\n+        for (int i = 0, len = fields.length(); i < len; i++)\n+            if (fields.get(i) && sm.getLoaded().get(i))\n+                fields.clear(i);\n+    }\n+\n+    public Collection loadAll(Collection sms, PCState state, int load,\n+        FetchState fetchState, Object context) {\n+        return ImplHelper.loadAll(sms, this, state, load, fetchState, context);\n+    }\n+\n+    public void beforeStateChange(OpenJPAStateManager sm, PCState fromState,\n+        PCState toState) {\n+    }\n+\n+    public Collection flush(Collection sms) {\n+        return _conf.getUpdateManagerInstance().flush(sms, this);\n+    }\n+\n+    public boolean cancelAll() {\n+        // note that this method does not lock the context, since\n+        // we want to allow a different thread to be able to cancel the\n+        // outstanding statement on a different context\n+\n+        Collection stmnts;\n+        synchronized (_stmnts) {\n+            if (_stmnts.isEmpty())\n+                return false;\n+            stmnts = new ArrayList(_stmnts);\n+        }\n+\n+        try {\n+            for (Iterator itr = stmnts.iterator(); itr.hasNext();)\n+                ((Statement) itr.next()).cancel();\n+            return true;\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, _dict);\n+        }\n+    }\n+\n+    public boolean assignObjectId(OpenJPAStateManager sm, boolean preFlush) {\n+        ClassMetaData meta = sm.getMetaData();\n+        if (meta.getIdentityType() == ClassMetaData.ID_APPLICATION)\n+            return ApplicationIds.assign(sm, this, preFlush);\n+\n+        // datastore identity\n+        Object val = ImplHelper.generateIdentityValue(_ctx, meta,\n+            JavaTypes.LONG);\n+        if (val == null && meta.getIdentityStrategy() != ValueStrategies.NATIVE)\n+            return false;\n+        if (val == null)\n+            val = getDataStoreIdSequence(meta).next(_ctx, meta);\n+        sm.setObjectId(newDataStoreId(val, meta));\n+        return true;\n+    }\n+\n+    public boolean assignField(OpenJPAStateManager sm, int field,\n+        boolean preFlush) {\n+        FieldMetaData fmd = sm.getMetaData().getField(field);\n+        Object val = ImplHelper.generateFieldValue(_ctx, fmd);\n+        if (val == null)\n+            return false;\n+        sm.store(field, val);\n+        return true;\n+    }\n+\n+    public Class getManagedType(Object oid) {\n+        if (oid instanceof Id)\n+            return ((Id) oid).getType();\n+        return null;\n+    }\n+\n+    public Class getDataStoreIdType(ClassMetaData meta) {\n+        return Id.class;\n+    }\n+\n+    public Object copyDataStoreId(Object oid, ClassMetaData meta) {\n+        Id id = (Id) oid;\n+        return new Id(meta.getDescribedType(), id.getId(),\n+            id.hasSubclasses());\n+    }\n+\n+    public Object newDataStoreId(Object val, ClassMetaData meta) {\n+        return Id.newInstance(meta.getDescribedType(), val);\n+    }\n+\n+    public Id newDataStoreId(long id, ClassMapping mapping, boolean subs) {\n+        return new Id(mapping.getDescribedType(), id, subs);\n+    }\n+\n+    public ResultObjectProvider executeExtent(ClassMetaData meta,\n+        final boolean subclasses, FetchConfiguration fetch) {\n+        ClassMapping mapping = (ClassMapping) meta;\n+        final ClassMapping[] mappings;\n+        if (subclasses)\n+            mappings = mapping.getIndependentAssignableMappings();\n+        else\n+            mappings = new ClassMapping[]{ mapping };\n+\n+        ResultObjectProvider[] rops = null;\n+        final JDBCFetchConfiguration jfetch = (JDBCFetchConfiguration) fetch;\n+        final JDBCFetchState jfetchState = (JDBCFetchState)\n+            jfetch.newFetchState();\n+        if (jfetch.getSubclassFetchMode(mapping) != jfetch.EAGER_JOIN)\n+            rops = new ResultObjectProvider[mappings.length];\n+\n+        try {\n+            // check for custom loads\n+            ResultObjectProvider rop;\n+            for (int i = 0; i < mappings.length; i++) {\n+                rop = mappings[i].customLoad(this, subclasses, jfetch, 0,\n+                    Long.MAX_VALUE);\n+                if (rop != null) {\n+                    if (rops == null)\n+                        rops = new ResultObjectProvider[mappings.length];\n+                    rops[i] = rop;\n+                }\n+            }\n+\n+            // if we're selecting independent mappings separately or have\n+            // custom loads, do individual selects for each class\n+            rop = null;\n+            if (rops != null) {\n+                for (int i = 0; i < mappings.length; i++) {\n+                    if (rops[i] != null)\n+                        continue;\n+\n+                    Select sel = _sql.newSelect();\n+                    sel.setLRS(true);\n+                    BitSet paged = selectExtent(sel, mappings[i], jfetchState,\n+                        subclasses);\n+                    if (paged == null)\n+                        rops[i] = new InstanceResultObjectProvider(sel,\n+                            mappings[i], this, jfetchState);\n+                    else\n+                        rops[i] = new PagingResultObjectProvider(sel,\n+                            mappings[i], this, jfetchState, paged,\n+                            Long.MAX_VALUE);\n+                }\n+                if (rops.length == 1)\n+                    return rops[0];\n+                return new MergedResultObjectProvider(rops);\n+            }\n+\n+            // perform a union on all independent classes\n+            Union union = _sql.newUnion(mappings.length);\n+            union.setLRS(true);\n+            final BitSet[] paged = new BitSet[mappings.length];\n+            union.select(new Union.Selector() {\n+                public void select(Select sel, int idx) {\n+                    paged[idx] = selectExtent(sel, mappings[idx], jfetchState,\n+                        subclasses);\n+                }\n+            });\n+\n+            // using paging rop if any union element has paged fields\n+            for (int i = 0; i < paged.length; i++) {\n+                if (paged[i] != null)\n+                    return new PagingResultObjectProvider(union, mappings,\n+                        JDBCStoreManager.this, jfetchState, paged,\n+                        Long.MAX_VALUE);\n+            }\n+            return new InstanceResultObjectProvider(union, mappings[0],\n+                this, jfetchState);\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, _dict);\n+        }\n+    }\n+\n+    /**\n+     * Select the given mapping for use in an extent, returning paged fields.\n+     */\n+    private BitSet selectExtent(Select sel, ClassMapping mapping,\n+        JDBCFetchState jfetchState, boolean subclasses) {\n+        int subs = (subclasses) ? Select.SUBS_JOINABLE : Select.SUBS_NONE;\n+        // decide between paging and standard iteration\n+        BitSet paged = PagingResultObjectProvider.getPagedFields(sel,\n+            mapping, this, jfetchState, JDBCFetchConfiguration.EAGER_PARALLEL,\n+            Long.MAX_VALUE);\n+        if (paged == null)\n+            sel.selectIdentifier(mapping, subs, this, jfetchState,\n+                JDBCFetchConfiguration.EAGER_PARALLEL);\n+        else\n+            sel.selectIdentifier(mapping, subs, this, jfetchState,\n+                JDBCFetchConfiguration.EAGER_JOIN);\n+        return paged;\n+    }\n+\n+    public StoreQuery newQuery(String language) {\n+        ExpressionParser ep = QueryLanguages.parserForLanguage(language);\n+        if (ep != null)\n+            return new JDBCStoreQuery(this, ep);\n+        if (QueryLanguages.LANG_SQL.equals(language))\n+            return new SQLStoreQuery(this);\n+        return null;\n+    }\n+\n+    public FetchConfiguration newFetchConfiguration() {\n+        return new JDBCFetchConfigurationImpl();\n+    }\n+\n+    public Seq getDataStoreIdSequence(ClassMetaData meta) {\n+        if (meta.getIdentityStrategy() == ValueStrategies.NATIVE\n+            || meta.getIdentityStrategy() == ValueStrategies.NONE)\n+            return _conf.getSequenceInstance();\n+        return null;\n+    }\n+\n+    public Seq getValueSequence(FieldMetaData fmd) {\n+        return null;\n+    }\n+\n+    public void close() {\n+        if (_conn != null)\n+            _conn.free();\n+    }\n+\n+    /////////////\n+    // Utilities\n+    /////////////\n+\n+    /**\n+     * Connect to the db.\n+     */\n+    private void connect(boolean ref) {\n+        _ctx.lock();\n+        try {\n+            // connect if the connection is currently null, or if\n+            // the connection has been closed out from under us\n+            if (_conn == null)\n+                _conn = connectInternal();\n+            if (ref)\n+                _conn.ref();\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, _dict);\n+        } finally {\n+            _ctx.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Connect to the database. This method is separated out so that it\n+     * can be profiled.\n+     */\n+    private RefCountConnection connectInternal()\n+        throws SQLException {\n+        return new RefCountConnection(_ds.getConnection());\n+    }\n+\n+    /**\n+     * Find the object with the given oid.\n+     */\n+    public Object find(Object oid, ValueMapping vm,\n+        JDBCFetchState fetchState) {\n+        if (oid == null)\n+            return null;\n+        Object pc = _ctx.find(oid, fetchState, null, null, 0);\n+        if (pc == null && vm != null) {\n+            OrphanedKeyAction action = _conf.getOrphanedKeyActionInstance();\n+            pc = action.orphan(oid, null, vm);\n+        }\n+        return pc;\n+    }\n+\n+    /**\n+     * Load the object in the current row of the given result.\n+     */\n+    public Object load(ClassMapping mapping, JDBCFetchState fetchState,\n+        BitSet exclude, Result result)\n+        throws SQLException {\n+        if (!mapping.isMapped())\n+            throw new InvalidStateException(_loc.get(\"virtual-mapping\",\n+                mapping));\n+\n+        // get the object id for the row; base class selects pk columns\n+        ClassMapping base = mapping;\n+        while (base.getJoinablePCSuperclassMapping() != null)\n+            base = base.getJoinablePCSuperclassMapping();\n+        Object oid = base.getObjectId(this, result, null, true, null);\n+        if (oid == null)\n+            return null;\n+\n+        ConnectionInfo info = new ConnectionInfo();\n+        info.result = result;\n+        info.mapping = mapping;\n+        return _ctx.find(oid, fetchState, exclude, info, 0);\n+    }\n+\n+    /**\n+     * Load the given state manager with data from the result set. Only\n+     * mappings originally selected will be loaded.\n+     */\n+    private void load(ClassMapping mapping, OpenJPAStateManager sm,\n+        JDBCFetchState fetchState, Result res)\n+        throws SQLException {\n+        FieldMapping eagerToMany = load(mapping, sm, fetchState, res, null);\n+        if (eagerToMany != null)\n+            eagerToMany.loadEagerJoin(sm, this, fetchState, res);\n+        if (_active && _lm != null && res.isLocking())\n+            _lm.loadedForUpdate(sm);\n+    }\n+\n+    /**\n+     * Load the fields of the given mapping. Return any to-many eager field\n+     * without loading it.\n+     */\n+    private FieldMapping load(ClassMapping mapping, OpenJPAStateManager sm,\n+        JDBCFetchState fetchState, Result res, FieldMapping eagerToMany)\n+        throws SQLException {\n+        JDBCFetchConfiguration fetch = getFetchConfiguration(fetchState);\n+        if (mapping.customLoad(sm, this, fetch, res))\n+            return eagerToMany;\n+\n+        // load superclass data; base class loads version\n+        ClassMapping parent = mapping.getJoinablePCSuperclassMapping();\n+        if (parent != null)\n+            eagerToMany = load(parent, sm, fetchState, res, eagerToMany);\n+        else if (sm.getVersion() == null)\n+            mapping.getVersion().load(sm, this, res);\n+\n+        // load unloaded fields\n+        FieldMapping[] fms = mapping.getDefinedFieldMappings();\n+        Object eres, processed;\n+        for (int i = 0; i < fms.length; i++) {\n+            if (fms[i].isPrimaryKey()\n+                || sm.getLoaded().get(fms[i].getIndex()))\n+                continue;\n+\n+            // check for eager result, and if not present do standard load\n+            eres = res.getEager(fms[i]);\n+            res.startDataRequest(fms[i]);\n+            try {\n+                if (eres == res) {\n+                    if (eagerToMany == null && fms[i].isEagerSelectToMany())\n+                        eagerToMany = fms[i];\n+                    else\n+                        fms[i].loadEagerJoin(sm, this, fetchState, res);\n+                } else if (eres != null) {\n+                    processed = fms[i].loadEagerParallel(sm, this, fetchState,\n+                        eres);\n+                    if (processed != eres)\n+                        res.putEager(fms[i], processed);\n+                } else\n+                    fms[i].load(sm, this, fetchState, res);\n+            } finally {\n+                res.endDataRequest();\n+            }\n+        }\n+        return eagerToMany;\n+    }\n+\n+    /**\n+     * For implementation use only.\n+     * Return a select for the proper mappings. Return null if no select is\n+     * needed. The method is designed to be complementary to the load methods.\n+     *\n+     * @param sel select to build on\n+     * @param mapping the mapping for the base type to select for\n+     * @param subs whether the select might include subclasses of the\n+     * given mapping\n+     * @param sm state manager if an instance is being loaded or\n+     * initialized, else null\n+     * @param fields if a state manager is being loaded, the set of\n+     * fields that must be loaded in order, else null\n+     * @param fetchState the fetch configuration; used if no specific fields\n+     * must be loaded, and used when selecting relations\n+     * @param eager eager fetch mode to use\n+     * @param ident whether to select primary key columns as distinct\n+     * identifiers\n+     * @return true if the select is required, false otherwise\n+     */\n+    public boolean select(Select sel, ClassMapping mapping, int subs,\n+        OpenJPAStateManager sm, BitSet fields, JDBCFetchState fetchState,\n+        int eager, boolean ident) {\n+        // add class conditions so that they're cloned for any batched selects\n+        boolean joinedSupers = false;\n+        if ((sm == null || sm.getPCState() == PCState.TRANSIENT)\n+            && (subs == sel.SUBS_JOINABLE || subs == sel.SUBS_NONE))\n+            joinedSupers = addClassConditions(sel, mapping,\n+                subs == sel.SUBS_JOINABLE, null);\n+\n+        // create all our eager selects so that those fields are reserved\n+        // and cannot be reused during the actual eager select process,\n+        // preventing infinite recursion\n+        JDBCFetchConfiguration fetch = getFetchConfiguration(fetchState);\n+        eager = Math.min(eager, fetch.getEagerFetchMode());\n+        FieldMapping eagerToMany = createEagerSelects(sel, mapping, sm,\n+            fields, fetchState, eager);\n+\n+        // select all base class mappings; do this after batching so that\n+        // the joins needed by these selects don't get in the WHERE clause\n+        // of the batched selects\n+        int seld = selectBaseMappings(sel, mapping, mapping, sm, fields,\n+            fetchState, eager, eagerToMany, ident, joinedSupers);\n+\n+        // select eager to-many relations last because during load they\n+        // advance the result set and could exhaust it, so no other mappings\n+        // can load afterwords\n+        if (eagerToMany != null)\n+            eagerToMany.selectEagerJoin(sel, sm, this, fetchState, eager);\n+\n+        // optionally select subclass mappings\n+        if (subs == sel.SUBS_JOINABLE || subs == sel.SUBS_ANY_JOINABLE)\n+            selectSubclassMappings(sel, mapping, sm, fetchState);\n+        if (sm != null)\n+            sel.setDistinct(false);\n+        return seld > 0;\n+    }\n+\n+    /**\n+     * Mark the fields of this mapping as reserved so that eager fetches can't\n+     * get into infinite recursive situations.\n+     */\n+    private FieldMapping createEagerSelects(Select sel, ClassMapping mapping,\n+        OpenJPAStateManager sm, BitSet fields, JDBCFetchState fetchState,\n+        int eager) {\n+        if (mapping == null || eager == JDBCFetchConfiguration.EAGER_NONE)\n+            return null;\n+\n+        JDBCFetchConfiguration fetch = getFetchConfiguration(fetchState);\n+        FieldMapping eagerToMany = createEagerSelects(sel, mapping.\n+            getJoinablePCSuperclassMapping(), sm, fields, fetchState, eager);\n+\n+        FieldMapping[] fms = mapping.getDefinedFieldMappings();\n+        boolean inEagerJoin = sel.hasEagerJoin(false);\n+        int sels;\n+        int jtype;\n+        int mode;\n+        for (int i = 0; i < fms.length; i++) {\n+            if (!requiresSelect(fms[i], sm, fields, fetchState))\n+                continue;\n+            mode = fms[i].getEagerFetchMode();\n+            if (mode == fetch.EAGER_NONE)\n+                continue;\n+\n+            // try to select with join first\n+            jtype = (fms[i].getNullValue() == fms[i].NULL_EXCEPTION)\n+                ? sel.EAGER_INNER : sel.EAGER_OUTER;\n+            if (mode != fetch.EAGER_PARALLEL\n+                && !fms[i].isEagerSelectToMany()\n+                && fms[i].supportsSelect(sel, jtype, sm, this, fetch) > 0\n+                && sel.eagerClone(fms[i], jtype, false, 1) != null)\n+                continue;\n+\n+            boolean hasJoin = fetch.hasJoin(fms[i].getFullName());\n+\n+            // if the field declares a preferred select mode of join or does not\n+            // have a preferred mode and we're doing a by-id lookup, try\n+            // to use a to-many join also.  currently we limit eager\n+            // outer joins to non-LRS, non-ranged selects that don't already\n+            // have an eager to-many join\n+            if ((hasJoin || mode == fetch.EAGER_JOIN\n+                || (mode == fetch.DEFAULT && sm != null))\n+                && fms[i].isEagerSelectToMany()\n+                && !inEagerJoin && !sel.hasEagerJoin(true)\n+                && (!sel.getAutoDistinct() || (!sel.isLRS()\n+                && sel.getStartIndex() == 0\n+                && sel.getEndIndex() == Long.MAX_VALUE))\n+                && fms[i].supportsSelect(sel, jtype, sm, this, fetch) > 0) {\n+                if (sel.eagerClone(fms[i], jtype, true, 1) != null)\n+                    eagerToMany = fms[i];\n+                else\n+                    continue;\n+            }\n+\n+            // finally, try parallel\n+            if (eager == fetch.EAGER_PARALLEL && (sels = fms[i].\n+                supportsSelect(sel, sel.EAGER_PARALLEL, sm, this, fetch)) != 0)\n+                sel.eagerClone(fms[i], Select.EAGER_PARALLEL,\n+                    fms[i].isEagerSelectToMany(), sels);\n+        }\n+        return eagerToMany;\n+    }\n+\n+    /**\n+     * Determine if the given field needs to be selected.\n+     */\n+    private static boolean requiresSelect(FieldMapping fm,\n+        OpenJPAStateManager sm,\n+        BitSet fields, JDBCFetchState fetchState) {\n+        if (fields != null)\n+            return fields.get(fm.getIndex());\n+        if (sm != null && sm.getPCState() != PCState.TRANSIENT\n+            && sm.getLoaded().get(fm.getIndex()))\n+            return false;\n+        return fetchState.requiresSelect(fm, true);\n+    }\n+\n+    /**\n+     * Select the field mappings of the given class and all its superclasses.\n+     *\n+     * @param sel the select to use\n+     * @param mapping the most-derived type to select for\n+     * @param orig the original mapping type selected\n+     * @param sm the instance being selected for, or null if none\n+     * @param fields the fields to load\n+     * @param fetch fetch configuration to use for loading relations\n+     * @param eager the eager fetch mode to use\n+     * @param joined whether the class has already been joined down to\n+     * its base class\n+     * @return &gt; 0 if the select is required, 0 if data was\n+     * selected but is not required, and &lt; 0 if nothing was selected\n+     */\n+    private int selectBaseMappings(Select sel, ClassMapping mapping,\n+        ClassMapping orig, OpenJPAStateManager sm, BitSet fields,\n+        JDBCFetchState fetchState, int eager, FieldMapping eagerToMany,\n+        boolean ident, boolean joined) {\n+        JDBCFetchConfiguration fetch = getFetchConfiguration(fetchState);\n+        ClassMapping parent = mapping.getJoinablePCSuperclassMapping();\n+        if (parent == null && !mapping.isMapped())\n+            throw new InvalidStateException(_loc.get(\"virtual-mapping\",\n+                mapping.getDescribedType()));\n+\n+        int seld = -1;\n+        int pseld = -1;\n+\n+        // base class selects pks, etc\n+        if (parent == null) {\n+            // if no instance, select pks\n+            if (sm == null) {\n+                if (ident)\n+                    sel.selectIdentifier(mapping.getPrimaryKeyColumns());\n+                else\n+                    sel.select(mapping.getPrimaryKeyColumns());\n+                seld = 1;\n+            }\n+\n+            // if no instance or not initialized and not exact oid, select type\n+            if ((sm == null || (sm.getPCState() == PCState.TRANSIENT\n+                && (!(sm.getObjectId()instanceof OpenJPAId)\n+                || ((OpenJPAId) sm.getObjectId()).hasSubclasses())))\n+                && mapping.getDiscriminator().select(sel, orig))\n+                seld = 1;\n+\n+            // if no instance or no version, select version\n+            if ((sm == null || sm.getVersion() == null)\n+                && mapping.getVersion().select(sel, orig))\n+                seld = 1;\n+        } else {\n+            // recurse on parent\n+            pseld = selectBaseMappings(sel, parent, orig, sm, fields,\n+                fetchState, eager, eagerToMany, ident, joined);\n+        }\n+\n+        // select the mappings in the given fields set, or based on fetch\n+        // configuration if no fields given\n+        FieldMapping[] fms = mapping.getDefinedFieldMappings();\n+        SelectExecutor esel;\n+        int fseld;\n+        for (int i = 0; i < fms.length; i++) {\n+            // skip eager to-many select; we do that separately in calling\n+            // method\n+            if (fms[i] == eagerToMany)\n+                continue;\n+\n+            // check for eager select\n+            esel = sel.getEager(fms[i]);\n+            if (esel != null) {\n+                if (esel == sel)\n+                    fms[i].selectEagerJoin(sel, sm, this, fetchState, eager);\n+                else\n+                    fms[i].selectEagerParallel(esel, sm, this, fetchState,\n+                        eager);\n+                seld = Math.max(0, seld);\n+            } else if (requiresSelect(fms[i], sm, fields, fetchState)) {\n+                fseld = fms[i].select(sel, sm, this, fetchState, eager);\n+                seld = Math.max(fseld, seld);\n+            } else if (optSelect(fms[i], sel, sm, fetchState)) {\n+                fseld = fms[i].select(sel, sm, this, fetchState,\n+                    fetch.EAGER_NONE);\n+\n+                // don't upgrade seld to > 0 based on these fields, since\n+                // they're not in the calculated field set\n+                if (fseld >= 0 && seld < 0)\n+                    seld = 0;\n+            }\n+        }\n+\n+        // join to parent table if the parent / any ancestors have selected\n+        // anything\n+        if (!joined && pseld >= 0 && parent.getTable() != mapping.getTable())\n+            sel.where(mapping.joinSuperclass(sel.newJoins(), false));\n+\n+        // return the highest value\n+        return Math.max(pseld, seld);\n+    }\n+\n+    /**\n+     * When selecting fieldes, a special case is made for mappings that use\n+     * 2-part selects that aren't explicitly *not* in the dfg so that they\n+     * can get their primary table data. This method tests for that special\n+     * case as an optimization.\n+     */\n+    private boolean optSelect(FieldMapping fm, Select sel,\n+        OpenJPAStateManager sm,\n+        JDBCFetchState fetchState) {\n+        return !fm.isDefaultFetchGroupExplicit()\n+            && (sm == null || sm.getPCState() == PCState.TRANSIENT\n+            || !sm.getLoaded().get(fm.getIndex()))\n+            && fm.supportsSelect(sel, sel.TYPE_TWO_PART, sm, this,\n+            getFetchConfiguration(fetchState)) > 0\n+            && fetchState.requiresSelect(fm, true);\n+    }\n+\n+    /**\n+     * Select field mappings that match the given fetch configuration for\n+     * subclasses of the given type.\n+     *\n+     * @param sel the select to use\n+     * @param mapping the type whose subclasses to select\n+     * @param sm the instance being selected for, or null if none\n+     * @param fetch the fetch configuration\n+     */\n+    private void selectSubclassMappings(Select sel, ClassMapping mapping,\n+        OpenJPAStateManager sm, JDBCFetchState fetchState) {\n+        loadSubclasses(mapping);\n+        JDBCFetchConfiguration fetch = getFetchConfiguration(fetchState);\n+        ClassMapping[] subMappings = mapping.getJoinablePCSubclassMappings();\n+        if (subMappings.length == 0)\n+            return;\n+\n+        // select all subclass mappings that match the fetch configuration\n+        // and whose table is in the list of those selected so far; this\n+        // way we select the max possible without selecting any tables that\n+        // aren't present in all possible query matches; a special case\n+        // is made for mappings that use 2-part selects that aren't\n+        // explicitly *not* in the default so that they can get their\n+        // primary table data\n+        FieldMapping[] fms;\n+        boolean joined;\n+        boolean canJoin = _dict.joinSyntax != JoinSyntaxes.SYNTAX_TRADITIONAL\n+            && fetch.getSubclassFetchMode(mapping) != fetch.EAGER_NONE;\n+        for (int i = 0; i < subMappings.length; i++) {\n+            if (!subMappings[i].supportsEagerSelect(sel, sm, this, mapping,\n+                fetch))\n+                continue;\n+\n+            // initialize so that if we can't join, we pretend we already have\n+            joined = !canJoin;\n+            fms = subMappings[i].getDefinedFieldMappings();\n+            for (int j = 0; j < fms.length; j++) {\n+                // make sure in one of configured fetch groups\n+                if (!fms[j].isInDefaultFetchGroup()\n+                    && !fetch.hasFetchGroup(fms[j].getFetchGroups())\n+                    && !fetch.hasField(fms[j].getFullName())\n+                    && (fms[j].isDefaultFetchGroupExplicit()\n+                    || fms[j].supportsSelect(sel, sel.TYPE_TWO_PART, sm,\n+                    this, fetch) <= 0))\n+                    continue;\n+\n+                // if we can join to the subclass, do so; much better chance\n+                // that the field will be able to select itself without joins\n+                if (!joined) {\n+                    // mark joined whether or not we join, so we don't have to\n+                    // test conditions again for this subclass\n+                    joined = true;\n+                    sel.where(joinSubclass(sel, mapping, subMappings[i],\n+                        null));\n+                }\n+\n+                // if can select with tables already selected, do it\n+                if (fms[j].supportsSelect(sel, sel.TYPE_JOINLESS, sm,\n+                    this, fetch) > 0)\n+                    fms[j].select(sel, null, this, fetchState,\n+                        fetch.EAGER_NONE);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Helper method to join from class to its subclass. Recursive to allow\n+     * for multiple hops, starting from the base class.\n+     */\n+    private static Joins joinSubclass(Select sel, ClassMapping base,\n+        ClassMapping sub, Joins joins) {\n+        if (sub == base || sub.getTable() == base.getTable()\n+            || sel.isSelected(sub.getTable()))\n+            return null;\n+\n+        // recurse first so we go least->most derived\n+        ClassMapping sup = sub.getJoinablePCSuperclassMapping();\n+        joins = joinSubclass(sel, base, sup, joins);\n+        if (joins == null)\n+            joins = sel.newJoins();\n+        return sub.joinSuperclass(joins, true);\n+    }\n+\n+    /**\n+     * Makes sure all subclasses of the given type are loaded in the JVM.\n+     * This is usually done automatically.\n+     */\n+    public void loadSubclasses(ClassMapping mapping) {\n+        Discriminator dsc = mapping.getDiscriminator();\n+        if (dsc.getSubclassesLoaded())\n+            return;\n+\n+        // if the subclass list is set, no need to load subs\n+        if (mapping.getRepository().getPersistentTypeNames(false,\n+            _ctx.getClassLoader()) != null) {\n+            dsc.setSubclassesLoaded(true);\n+            return;\n+        }\n+\n+        try {\n+            dsc.loadSubclasses(this);\n+        } catch (ClassNotFoundException cnfe) {\n+            throw new StoreException(cnfe);\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, _dict);\n+        }\n+    }\n+\n+    /**\n+     * Add WHERE conditions to the given select limiting the returned results\n+     * to the given mapping type, possibly including subclasses.\n+     *\n+     * @return true if the mapping was joined down to its base class\n+     * in order to add the conditions\n+     */\n+    public boolean addClassConditions(Select sel, ClassMapping mapping,\n+        boolean subs, Joins joins) {\n+        loadSubclasses(mapping);\n+        if (mapping.getJoinablePCSuperclassMapping() == null\n+            && mapping.getJoinablePCSubclassMappings().length == 0)\n+            return false;\n+\n+        // join down to base class where the conditions will be added\n+        ClassMapping from = mapping;\n+        ClassMapping sup = mapping.getJoinablePCSuperclassMapping();\n+        for (; sup != null; from = sup,\n+            sup = from.getJoinablePCSuperclassMapping()) {\n+            if (from.getTable() != sup.getTable()) {\n+                if (joins == null)\n+                    joins = sel.newJoins();\n+                joins = from.joinSuperclass(joins, false);\n+            }\n+        }\n+\n+        Discriminator dsc = mapping.getDiscriminator();\n+        SQLBuffer buf = dsc.getClassConditions(this, sel, joins, mapping, subs);\n+        if (buf != null) {\n+            sel.where(buf, joins);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Make the statement a candidate for cancellation.\n+     */\n+    private void beforeExecuteStatement(Statement stmnt) {\n+        _stmnts.add(stmnt);\n+    }\n+\n+    /**\n+     * Remove the statement from the cancellable set.\n+     */\n+    private void afterExecuteStatement(Statement stmnt) {\n+        _stmnts.remove(stmnt);\n+    }\n+\n+    /**\n+     * Connection returned to client code. Makes sure its wrapped connection\n+     * ref count is decremented on finalize.\n+     */\n+    private static class ClientConnection\n+        extends DelegatingConnection {\n+\n+        private boolean _closed = false;\n+\n+        public ClientConnection(Connection conn) {\n+            super(conn);\n+        }\n+\n+        public void close()\n+            throws SQLException {\n+            _closed = true;\n+            super.close();\n+        }\n+\n+        protected void finalize()\n+            throws SQLException {\n+            if (!_closed)\n+                close();\n+        }\n+    }\n+\n+    /**\n+     * Connection wrapper that keeps an internal ref count so that it knows\n+     * when to really close.\n+     */\n+    private class RefCountConnection\n+        extends DelegatingConnection {\n+\n+        private boolean _retain = false;\n+        private int _refs = 0;\n+        private boolean _freed = false;\n+\n+        public RefCountConnection(Connection conn) {\n+            super(conn);\n+        }\n+\n+        public boolean getRetain() {\n+            return _retain;\n+        }\n+\n+        public void setRetain(boolean retain) {\n+            if (_retain && !retain && _refs <= 0)\n+                free();\n+            _retain = retain;\n+        }\n+\n+        public void ref() {\n+            // don't have to lock; called from connect(), which is locked\n+            _refs++;\n+        }\n+\n+        public void close()\n+            throws SQLException {\n+            // lock at broker level to avoid deadlocks\n+            _ctx.lock();\n+            try {\n+                _refs--;\n+                if (_refs <= 0 && !_retain)\n+                    free();\n+            } finally {\n+                _ctx.unlock();\n+            }\n+        }\n+\n+        public void free() {\n+            // ensure that we do not close the underlying connection\n+            // multiple times; this could happen if someone (e.g., an\n+            // Extent) holds a RefConnection, and then closes it (e.g., in\n+            // the finalizer) after the StoreManager has already been closed.\n+            if (_freed)\n+                return;\n+\n+            try {\n+                getDelegate().close();\n+            } catch (SQLException se) {\n+            }\n+            _freed = true;\n+            _conn = null;\n+        }\n+\n+        protected Statement createStatement(boolean wrap)\n+            throws SQLException {\n+            return new CancelStatement(super.createStatement(false),\n+                RefCountConnection.this);\n+        }\n+\n+        protected Statement createStatement(int rsType, int rsConcur,\n+            boolean wrap)\n+            throws SQLException {\n+            return new CancelStatement(super.createStatement(rsType,\n+                rsConcur, false), RefCountConnection.this);\n+        }\n+\n+        protected PreparedStatement prepareStatement(String sql, boolean wrap)\n+            throws SQLException {\n+            return new CancelPreparedStatement(super.prepareStatement\n+                (sql, false), RefCountConnection.this);\n+        }\n+\n+        protected PreparedStatement prepareStatement(String sql, int rsType,\n+            int rsConcur, boolean wrap)\n+            throws SQLException {\n+            return new CancelPreparedStatement(super.prepareStatement\n+                (sql, rsType, rsConcur, false), RefCountConnection.this);\n+        }\n+    }\n+\n+    /**\n+     * Statement type that adds and removes itself from the set of active\n+     * statements so that it can be canceled.\n+     */\n+    private class CancelStatement\n+        extends DelegatingStatement {\n+\n+        public CancelStatement(Statement stmnt, Connection conn) {\n+            super(stmnt, conn);\n+        }\n+\n+        public int executeUpdate(String sql)\n+            throws SQLException {\n+            beforeExecuteStatement(this);\n+            try {\n+                return super.executeUpdate(sql);\n+            } finally {\n+                afterExecuteStatement(this);\n+            }\n+        }\n+\n+        protected ResultSet executeQuery(String sql, boolean wrap)\n+            throws SQLException {\n+            beforeExecuteStatement(this);\n+            try {\n+                return super.executeQuery(sql, wrap);\n+            } finally {\n+                afterExecuteStatement(this);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Statement type that adds and removes itself from the set of active\n+     * statements so that it can be canceled.\n+     */\n+    private class CancelPreparedStatement\n+        extends DelegatingPreparedStatement {\n+\n+        public CancelPreparedStatement(PreparedStatement stmnt,\n+            Connection conn) {\n+            super(stmnt, conn);\n+        }\n+\n+        public int executeUpdate()\n+            throws SQLException {\n+            beforeExecuteStatement(this);\n+            try {\n+                return super.executeUpdate();\n+            } finally {\n+                afterExecuteStatement(this);\n+            }\n+        }\n+\n+        protected ResultSet executeQuery(boolean wrap)\n+            throws SQLException {\n+            beforeExecuteStatement(this);\n+            try {\n+                return super.executeQuery(wrap);\n+            } finally {\n+                afterExecuteStatement(this);\n+            }\n+        }\n+\n+        public int[] executeBatch()\n+            throws SQLException {\n+            beforeExecuteStatement(this);\n+            try {\n+                return super.executeBatch();\n+            } finally {\n+                afterExecuteStatement(this);\n+            }\n+        }\n+    }\n+}"},{"sha":"6e012e4e11e5dc7440e2e8c27c9aa256d3cc425b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","status":"added","additions":636,"deletions":0,"changes":636,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,636 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.openjpa.event.LifecycleEventManager;\n+import org.apache.openjpa.jdbc.kernel.exps.GetColumn;\n+import org.apache.openjpa.jdbc.kernel.exps.JDBCExpressionFactory;\n+import org.apache.openjpa.jdbc.kernel.exps.JDBCStringContains;\n+import org.apache.openjpa.jdbc.kernel.exps.JDBCWildcardMatch;\n+import org.apache.openjpa.jdbc.kernel.exps.SQLEmbed;\n+import org.apache.openjpa.jdbc.kernel.exps.SQLExpression;\n+import org.apache.openjpa.jdbc.kernel.exps.SQLValue;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.strats.VerticalClassStrategy;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.jdbc.sql.Union;\n+import org.apache.openjpa.kernel.ExpressionStoreQuery;\n+import org.apache.openjpa.kernel.OrderingMergedResultObjectProvider;\n+import org.apache.openjpa.kernel.exps.ExpressionFactory;\n+import org.apache.openjpa.kernel.exps.ExpressionParser;\n+import org.apache.openjpa.kernel.exps.FilterListener;\n+import org.apache.openjpa.kernel.exps.QueryExpressions;\n+import org.apache.openjpa.lib.rop.MergedResultObjectProvider;\n+import org.apache.openjpa.lib.rop.RangeResultObjectProvider;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.ValueMetaData;\n+import org.apache.openjpa.util.UserException;\n+import serp.util.Numbers;\n+\n+/**\n+ * JDBC query implementation.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class JDBCStoreQuery\n+    extends ExpressionStoreQuery {\n+\n+    private static final Table INVALID = new Table();\n+\n+    // add all standard filter and aggregate listeners to these maps\n+    private static final Map _listeners = new HashMap();\n+\n+    static {\n+        // deprecated extensions\n+        _listeners.put(JDBCStringContains.TAG, new JDBCStringContains());\n+        _listeners.put(JDBCWildcardMatch.TAG, new JDBCWildcardMatch());\n+        _listeners.put(SQLExpression.TAG, new SQLExpression());\n+        _listeners.put(SQLValue.TAG, new SQLValue());\n+\n+        // jdbc-specific extensions\n+        _listeners.put(GetColumn.TAG, new GetColumn());\n+        _listeners.put(SQLEmbed.TAG, new SQLEmbed());\n+    }\n+\n+    private final transient JDBCStore _store;\n+\n+    /**\n+     * Constructor. Supply store manager.\n+     */\n+    public JDBCStoreQuery(JDBCStore store, ExpressionParser parser) {\n+        super(parser);\n+        _store = store;\n+    }\n+\n+    /**\n+     * Return the store.\n+     */\n+    public JDBCStore getStore() {\n+        return _store;\n+    }\n+\n+    public FilterListener getFilterListener(String tag) {\n+        return (FilterListener) _listeners.get(tag);\n+    }\n+\n+    public Object newCompilationKey() {\n+        JDBCFetchConfiguration fetch = (JDBCFetchConfiguration)\n+            ctx.getFetchConfiguration();\n+        return Numbers.valueOf(fetch.getJoinSyntax());\n+    }\n+\n+    public boolean supportsDataStoreExecution() {\n+        return true;\n+    }\n+\n+    protected ClassMetaData[] getIndependentExpressionCandidates\n+        (ClassMetaData meta, boolean subclasses) {\n+        if (!subclasses)\n+            return new ClassMapping[]{ (ClassMapping) meta };\n+        return ((ClassMapping) meta).getIndependentAssignableMappings();\n+    }\n+\n+    protected ExpressionFactory getExpressionFactory(ClassMetaData meta) {\n+        return new JDBCExpressionFactory((ClassMapping) meta);\n+    }\n+\n+    protected ResultObjectProvider executeQuery(Executor ex,\n+        ClassMetaData base, ClassMetaData[] metas, boolean subclasses,\n+        ExpressionFactory[] facts, QueryExpressions[] exps, Object[] params,\n+        boolean lrs, long startIdx, long endIdx) {\n+        if (metas.length > 1 && exps[0].aggregate)\n+            throw new UserException(Localizer.forPackage(JDBCStoreQuery.class).\n+                get(\"mult-mapping-aggregate\", Arrays.asList(metas)));\n+\n+        ClassMapping[] mappings = (ClassMapping[]) metas;\n+        JDBCFetchConfiguration fetch = (JDBCFetchConfiguration)\n+            ctx.getFetchConfiguration();\n+        JDBCFetchState fetchState = (JDBCFetchState) fetch.newFetchState();\n+        if (exps[0].fetchPaths != null) {\n+            fetch.addFields(Arrays.asList(exps[0].fetchPaths));\n+            fetch.addJoins(Arrays.asList(exps[0].fetchPaths));\n+        }\n+\n+        int eager = calculateEagerMode(exps[0], startIdx, endIdx);\n+        int subclassMode = fetch.getSubclassFetchMode((ClassMapping) base);\n+        DBDictionary dict = _store.getDBDictionary();\n+        long start = (mappings.length == 1 && dict.supportsSelectStartIndex)\n+            ? startIdx : 0L;\n+        long end = (dict.supportsSelectEndIndex) ? endIdx : Long.MAX_VALUE;\n+\n+        // add selects with populate WHERE conditions to list\n+        List sels = new ArrayList(mappings.length);\n+        List selMappings = new ArrayList(mappings.length);\n+        BitSet subclassBits = new BitSet();\n+        BitSet nextBits = new BitSet();\n+        boolean unionable = createWhereSelects(sels, mappings, selMappings,\n+            subclasses, subclassBits, nextBits, facts, exps, params, fetchState,\n+            subclassMode)\n+            && subclassMode == JDBCFetchConfiguration.EAGER_JOIN\n+            && start == 0 && end == Long.MAX_VALUE;\n+\n+        // we might want to use lrs settings if we can't use the range\n+        if (sels.size() > 1)\n+            start = 0L;\n+        lrs = lrs || (fetch.getFetchBatchSize() >= 0\n+            && (start != startIdx || end != endIdx));\n+\n+        ResultObjectProvider[] rops = null;\n+        ResultObjectProvider rop = null;\n+        if (unionable) {\n+            Union union = _store.getSQLFactory().newUnion((Select[])\n+                sels.toArray(new Select[sels.size()]));\n+            BitSet[] paged = populateUnion(union, mappings, subclasses,\n+                facts, exps, params, fetchState, lrs, eager, start, end);\n+            union.setLRS(lrs);\n+            rop = executeUnion(union, mappings, exps, paged, fetchState);\n+        } else {\n+            if (sels.size() > 1)\n+                rops = new ResultObjectProvider[sels.size()];\n+\n+            Select sel;\n+            BitSet paged;\n+            for (int i = 0, idx = 0; i < sels.size(); i++) {\n+                sel = (Select) sels.get(i);\n+                paged = populateSelect(sel, (ClassMapping) selMappings.get(i),\n+                    subclassBits.get(i), (JDBCExpressionFactory) facts[idx],\n+                    exps[idx], params, fetchState, lrs, eager, start, end);\n+\n+                rop = executeSelect(sel, (ClassMapping) selMappings.get(i),\n+                    exps[idx], paged, fetchState, start, end);\n+                if (rops != null)\n+                    rops[i] = rop;\n+\n+                if (nextBits.get(i))\n+                    idx++;\n+            }\n+        }\n+\n+        if (rops != null) {\n+            if (exps[0].ascending.length == 0)\n+                rop = new MergedResultObjectProvider(rops);\n+            else {\n+                rop = new OrderingMergedResultObjectProvider(rops,\n+                    exps[0].ascending, ex, this, params);\n+            }\n+        }\n+\n+        // need to fake result range?\n+        if ((rops != null && endIdx != Long.MAX_VALUE)\n+            || start != startIdx || end != endIdx)\n+            rop = new RangeResultObjectProvider(rop, startIdx, endIdx);\n+        return rop;\n+    }\n+\n+    /**\n+     * Select data for the given union, returning paged fields.\n+     */\n+    private BitSet[] populateUnion(Union union, final ClassMapping[] mappings,\n+        final boolean subclasses, final ExpressionFactory[] facts,\n+        final QueryExpressions[] exps, final Object[] params,\n+        final JDBCFetchState fetchState, final boolean lrs, final int eager,\n+        final long start, final long end) {\n+        final BitSet[] paged = (exps[0].projections.length > 0) ? null\n+            : new BitSet[mappings.length];\n+        union.select(new Union.Selector() {\n+            public void select(Select sel, int idx) {\n+                BitSet bits = populateSelect(sel, mappings[idx], subclasses,\n+                    (JDBCExpressionFactory) facts[idx], exps[idx], params,\n+                    fetchState, lrs, eager, start, end);\n+                if (paged != null)\n+                    paged[idx] = bits;\n+            }\n+        });\n+        return paged;\n+    }\n+\n+    /**\n+     * Select data for the given select, returning paged fields.\n+     */\n+    private BitSet populateSelect(Select sel, ClassMapping mapping,\n+        boolean subclasses, JDBCExpressionFactory fact, QueryExpressions exps,\n+        Object[] params, JDBCFetchState fetchState, boolean lrs, int eager,\n+        long start, long end) {\n+        sel.setLRS(lrs);\n+        sel.setRange(start, end);\n+\n+        BitSet paged = null;\n+        if (exps.projections.length == 0) {\n+            paged = PagingResultObjectProvider.getPagedFields(sel, mapping,\n+                _store, fetchState, eager, end - start);\n+            if (paged != null)\n+                eager = JDBCFetchConfiguration.EAGER_JOIN;\n+        }\n+\n+        fact.select(this, mapping, subclasses, sel, exps, params, fetchState,\n+            eager);\n+        return paged;\n+    }\n+\n+    /**\n+     * Execute the given union.\n+     */\n+    private ResultObjectProvider executeUnion(Union union,\n+        ClassMapping[] mappings, QueryExpressions[] exps, BitSet[] paged,\n+        JDBCFetchState fetchState) {\n+        if (exps[0].projections.length > 0)\n+            return new ProjectionResultObjectProvider(union, _store, fetchState,\n+                exps);\n+\n+        if (paged != null)\n+            for (int i = 0; i < paged.length; i++)\n+                if (paged[i] != null)\n+                    return new PagingResultObjectProvider(union, mappings,\n+                        _store, fetchState, paged, Long.MAX_VALUE);\n+\n+        return new InstanceResultObjectProvider(union, mappings[0], _store,\n+            fetchState);\n+    }\n+\n+    /**\n+     * Execute the given select.\n+     */\n+    private ResultObjectProvider executeSelect(Select sel,\n+        ClassMapping mapping, QueryExpressions exps, BitSet paged,\n+        JDBCFetchState fetchState, long start, long end) {\n+        if (exps.projections.length > 0)\n+            return new ProjectionResultObjectProvider(sel, _store, fetchState,\n+                exps);\n+        if (paged != null)\n+            return new PagingResultObjectProvider(sel, mapping, _store,\n+                fetchState, paged, end - start);\n+        return new InstanceResultObjectProvider(sel, mapping, _store,\n+            fetchState);\n+    }\n+\n+    /**\n+     * Generate the selects with WHERE conditions needed to execute the query\n+     * for the given mappings.\n+     */\n+    private boolean createWhereSelects(List sels, ClassMapping[] mappings,\n+        List selMappings, boolean subclasses, BitSet subclassBits,\n+        BitSet nextBits, ExpressionFactory[] facts, QueryExpressions[] exps,\n+        Object[] params, JDBCFetchState fetchState, int subclassMode) {\n+        Select sel;\n+        ClassMapping[] verts;\n+        boolean unionable = true;\n+        for (int i = 0; i < mappings.length; i++) {\n+            // determine vertical mappings to select separately\n+            verts = getVerticalMappings(mappings[i], subclasses, exps[i],\n+                subclassMode);\n+            if (verts.length == 1 && subclasses)\n+                subclassBits.set(sels.size());\n+\n+            // create criteria select and clone for each vert mapping\n+            sel = ((JDBCExpressionFactory) facts[i]).evaluate(this, fetchState,\n+                exps[i], params);\n+            for (int j = 0; j < verts.length; j++) {\n+                selMappings.add(verts[j]);\n+                if (j == verts.length - 1) {\n+                    nextBits.set(sels.size());\n+                    sels.add(sel);\n+                } else\n+                    sels.add(sel.fullClone(1));\n+            }\n+\n+            // turn off unioning if a given independent mapping requires\n+            // multiple selects, or if we're using FROM selects\n+            if (verts.length > 1 || sel.getFromSelect() != null)\n+                unionable = false;\n+        }\n+        return unionable;\n+    }\n+\n+    /**\n+     * Return all the vertical mappings to select separately. Depends on\n+     * subclass fetch mode and the type of query.\n+     */\n+    private ClassMapping[] getVerticalMappings(ClassMapping mapping,\n+        boolean subclasses, QueryExpressions exps, int subclassMode) {\n+        if (!subclasses || exps.projections.length > 0)\n+            return new ClassMapping[]{ mapping };\n+\n+        if (subclassMode != JDBCFetchConfiguration.EAGER_PARALLEL\n+            || !hasVerticalSubclasses(mapping))\n+            return new ClassMapping[]{ mapping };\n+\n+        List subs = new ArrayList(4);\n+        addSubclasses(mapping, subs);\n+        return (ClassMapping[]) subs.toArray(new ClassMapping[subs.size()]);\n+    }\n+\n+    /**\n+     * Recursive helper to add mappings for subclasses to the given list.\n+     */\n+    private void addSubclasses(ClassMapping mapping, Collection subs) {\n+        // possible future optimizations:\n+        // - if no fields in meta or its subclasses (and not in an\n+        //   already-selected table) are in the current fetch\n+        //   configuration, stop creating new executors\n+        // - allow an executor to select a range of subclasses, rather\n+        //   than just all subclasses / no subclasses; this would\n+        //   allow us to do just one query per actual vertically-mapped\n+        //   subclass, rather than one per mapped subclass, as is happening now\n+\n+        subs.add(mapping);\n+        if (!hasVerticalSubclasses(mapping))\n+            return;\n+\n+        // recurse on immediate subclasses\n+        ClassMapping[] subMappings = mapping.getJoinablePCSubclassMappings();\n+        for (int i = 0; i < subMappings.length; i++)\n+            if (subMappings[i].getJoinablePCSuperclassMapping() == mapping)\n+                addSubclasses(subMappings[i], subs);\n+    }\n+\n+    /**\n+     * Return whether the given class has any vertical subclasses.\n+     */\n+    private static boolean hasVerticalSubclasses(ClassMapping mapping) {\n+        ClassMapping[] subs = mapping.getJoinablePCSubclassMappings();\n+        for (int i = 0; i < subs.length; i++)\n+            if (subs[i].getStrategy()instanceof VerticalClassStrategy)\n+                return true;\n+        return false;\n+    }\n+\n+    /**\n+     * The eager mode depends on the unique setting and range. If the range\n+     * produces 0 results, use eager setting of none. If it produces 1 result\n+     * or the query is unique, use an eager setting of single. Otherwise use\n+     * an eager mode of multiple.\n+     */\n+    private int calculateEagerMode(QueryExpressions exps, long startIdx,\n+        long endIdx) {\n+        if (exps.projections.length > 0 || startIdx >= endIdx)\n+            return EagerFetchModes.EAGER_NONE;\n+        if (endIdx - startIdx == 1 || ctx.isUnique())\n+            return EagerFetchModes.EAGER_JOIN;\n+        return EagerFetchModes.EAGER_PARALLEL;\n+    }\n+\n+    protected Number executeDelete(Executor ex, ClassMetaData base,\n+        ClassMetaData[] metas, boolean subclasses, ExpressionFactory[] facts,\n+        QueryExpressions[] exps, Object[] params) {\n+        return executeBulkOperation(ex, base, metas, subclasses, facts,\n+            exps, params, null);\n+    }\n+\n+    protected Number executeUpdate(Executor ex, ClassMetaData base,\n+        ClassMetaData[] metas, boolean subclasses, ExpressionFactory[] facts,\n+        QueryExpressions[] exps, Object[] params) {\n+        return executeBulkOperation(ex, base, metas, subclasses, facts,\n+            exps, params, exps[0].updates);\n+    }\n+\n+    private Number executeBulkOperation(Executor ex, ClassMetaData base,\n+        ClassMetaData[] metas, boolean subclasses, ExpressionFactory[] facts,\n+        QueryExpressions[] exps, Object[] params, Map updates) {\n+        // we cannot execute a bulk delete statement when have mappings in\n+        // multiple tables, so indicate we want to use in-memory with null\n+        ClassMapping[] mappings = (ClassMapping[]) metas;\n+        boolean isUpdate = updates != null && updates.size() > 0;\n+        for (int i = 0; i < mappings.length; i++) {\n+            if (!isSingleTableMapping(mappings[i], subclasses) && !isUpdate)\n+                return null;\n+\n+            if (!isUpdate) {\n+                // if there are any delete callbacks, we need to\n+                // execute in-memory so the callbacks are invoked\n+                LifecycleEventManager mgr = ctx.getStoreContext().getBroker().\n+                    getLifecycleEventManager();\n+                if (mgr.hasDeleteListeners(null, mappings[i]))\n+                    return null;\n+            }\n+        }\n+\n+        JDBCFetchConfiguration fetch = (JDBCFetchConfiguration)\n+            ctx.getFetchConfiguration();\n+        DBDictionary dict = _store.getDBDictionary();\n+        int subs = (subclasses) ? Select.SUBS_JOINABLE : Select.SUBS_NONE;\n+\n+        SQLBuffer[] sql = new SQLBuffer[mappings.length];\n+        JDBCExpressionFactory jdbcFactory;\n+        Select sel;\n+        for (int i = 0; i < mappings.length; i++) {\n+            jdbcFactory = (JDBCExpressionFactory) facts[i];\n+            JDBCFetchState fetchState = (JDBCFetchState) fetch.newFetchState();\n+            sel = jdbcFactory.evaluate(this, fetchState, exps[i], params);\n+            jdbcFactory.select(this, mappings[i], subclasses, sel,\n+                exps[i], params, fetchState, JDBCFetchConfiguration.EAGER_NONE);\n+\n+            // specification of the \"udpates\" map indicates that this is\n+            // an update query; otherwise, this is a delete statement\n+            // The bulk operation will return null to indicate that the database\n+            // does not support the request bulk delete operation; in\n+            // this case, we need to perform the query in-memory and\n+            // manually delete the instances\n+            if (updates == null)\n+                sql[i] = dict.toDelete(mappings[i], sel, _store, params);\n+            else\n+                sql[i] = dict.toUpdate(mappings[i], sel, _store, params,\n+                    updates);\n+\n+            if (sql[i] == null)\n+                return null;\n+        }\n+\n+        // we need to make sure we have an active store connection\n+        ctx.getStoreContext().beginStore();\n+\n+        Connection conn = _store.getConnection();\n+        long count = 0;\n+        try {\n+            PreparedStatement stmnt;\n+            for (int i = 0; i < sql.length; i++) {\n+                stmnt = null;\n+                try {\n+                    stmnt = sql[i].prepareStatement(conn);\n+                    count += stmnt.executeUpdate();\n+                } finally {\n+                    if (stmnt != null)\n+                        try {\n+                            stmnt.close();\n+                        } catch (SQLException se) {\n+                        }\n+                }\n+            }\n+        }\n+        catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, ctx, _store.getDBDictionary());\n+        } finally {\n+            try {\n+                conn.close();\n+            } catch (SQLException se) {\n+            }\n+        }\n+        return Numbers.valueOf(count);\n+    }\n+\n+    /**\n+     * Whether the given mapping occupies only one table.\n+     */\n+    private boolean isSingleTableMapping(ClassMapping mapping,\n+        boolean subclasses) {\n+        ClassMapping root = mapping;\n+        while (root.getJoinablePCSuperclassMapping() != null)\n+            root = root.getJoinablePCSuperclassMapping();\n+        if (hasVerticalSubclasses(root))\n+            return false;\n+\n+        // we cannot execute a bulk delete if any of the\n+        // field mappings for the candidates have columns\n+        // in any other table, since bulk deleting just from the\n+        // class will leave dangling relations; we might be able\n+        // to issue bulk deletes separately for the joins (possibly\n+        // using a temporary table to select the primary keys for\n+        // all the related tables and then issing a delete against those\n+        // keys), but that logic is not currently implemented\n+        Table table = getTable(mapping.getFieldMappings(), null);\n+        if (table == INVALID)\n+            return false;\n+\n+        if (subclasses) {\n+            // if we are including subclasses, we also need to gather\n+            // all the mappings for all known subclasses\n+            ClassMapping[] subs = mapping.getJoinablePCSubclassMappings();\n+            for (int i = 0; subs != null && i < subs.length; i++) {\n+                table = getTable(subs[i].getDefinedFieldMappings(), table);\n+                if (table == INVALID)\n+                    return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Return the single table for the given fields, or INVALID if they\n+     * use multiple tables.\n+     */\n+    private Table getTable(FieldMapping[] fields, Table table) {\n+        for (int i = 0; i < fields.length; i++) {\n+            table = getTable(fields[i], table);\n+            if (table == INVALID)\n+                break;\n+        }\n+        return table;\n+    }\n+\n+    /**\n+     * Return the table for the field if the given table hasn't been set\n+     * yet, or if the tables match. If the field uses a different table,\n+     * returns INVALID. Also returns INVALID if field is dependent.\n+     */\n+    private Table getTable(FieldMapping fm, Table table) {\n+        if (fm.getCascadeDelete() != ValueMetaData.CASCADE_NONE)\n+            return INVALID;\n+\n+        Column[] columns = fm.getColumns();\n+        for (int i = 0; columns != null && i < columns.length; i++) {\n+            if (table == null)\n+                table = columns[i].getTable();\n+            else if (table != columns[i].getTable())\n+                return INVALID;\n+        }\n+        return table;\n+    }\n+\n+    protected Number executeUpdate(ClassMetaData base, ClassMetaData[] metas,\n+        boolean subclasses, ExpressionFactory[] facts,\n+        QueryExpressions[] parsed, Object[] params) {\n+        return null;\n+    }\n+\n+    protected String[] getDataStoreActions(ClassMetaData base,\n+        ClassMetaData[] metas, boolean subclasses, ExpressionFactory[] facts,\n+        QueryExpressions[] exps, Object[] params, long startIdx, long endIdx) {\n+        ClassMapping[] mappings = (ClassMapping[]) metas;\n+        JDBCFetchConfiguration fetch = (JDBCFetchConfiguration)\n+            ctx.getFetchConfiguration();\n+        JDBCFetchState fetchState = (JDBCFetchState) fetch.newFetchState();\n+        if (exps[0].fetchPaths != null) {\n+            fetch.addFields(Arrays.asList(exps[0].fetchPaths));\n+            fetch.addJoins(Arrays.asList(exps[0].fetchPaths));\n+        }\n+\n+        int eager = calculateEagerMode(exps[0], startIdx, endIdx);\n+        eager = Math.min(eager, JDBCFetchConfiguration.EAGER_JOIN);\n+        int subclassMode = fetch.getSubclassFetchMode((ClassMapping) base);\n+        DBDictionary dict = _store.getDBDictionary();\n+        long start = (mappings.length == 1 && dict.supportsSelectStartIndex)\n+            ? startIdx : 0L;\n+        long end = (dict.supportsSelectEndIndex) ? endIdx : Long.MAX_VALUE;\n+\n+        // add selects with populate WHERE conditions to list\n+        List sels = new ArrayList(mappings.length);\n+        List selMappings = new ArrayList(mappings.length);\n+        BitSet subclassBits = new BitSet();\n+        BitSet nextBits = new BitSet();\n+        boolean unionable = createWhereSelects(sels, mappings, selMappings,\n+            subclasses, subclassBits, nextBits, facts, exps, params, fetchState,\n+            subclassMode)\n+            && subclassMode == JDBCFetchConfiguration.EAGER_JOIN;\n+        if (sels.size() > 1)\n+            start = 0L;\n+\n+        if (unionable) {\n+            Union union = _store.getSQLFactory().newUnion((Select[])\n+                sels.toArray(new Select[sels.size()]));\n+            populateUnion(union, mappings, subclasses, facts, exps, params,\n+                fetchState, false, eager, start, end);\n+            if (union.isUnion())\n+                return new String[]{ union.toSelect(false, fetch).\n+                    getSQL(true) };\n+            sels = Arrays.asList(union.getSelects());\n+        } else {\n+            Select sel;\n+            for (int i = 0, idx = 0; i < sels.size(); i++) {\n+                sel = (Select) sels.get(i);\n+                populateSelect(sel, (ClassMapping) selMappings.get(i),\n+                    subclassBits.get(i), (JDBCExpressionFactory) facts[idx],\n+                    exps[idx], params, fetchState, false, eager, start, end);\n+                if (nextBits.get(i))\n+                    idx++;\n+            }\n+        }\n+\n+        String[] sql = new String[sels.size()];\n+        for (int i = 0; i < sels.size(); i++)\n+            sql[i] = ((Select) sels.get(i)).toSelect(false, fetch).\n+                getSQL(true);\n+        return sql;\n+    }\n+}"},{"sha":"5a88952c31273744c08a1d386e979dace3fdd324","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/LRSSizes.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/LRSSizes.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/LRSSizes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/LRSSizes.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.ResultSet;\n+\n+/**\n+ * Ways of calculating the size of large result sets.\n+ *\n+ * @author Abe White\n+ */\n+public interface LRSSizes {\n+\n+    /**\n+     * Mode for returning {@link Integer#MAX_VALUE} for the size of\n+     * large result sets.\n+     */\n+    public static final int SIZE_UNKNOWN = 0;\n+\n+    /**\n+     * Mode for using {@link ResultSet#last} to calcualte the size of\n+     * large result sets.\n+     */\n+    public static final int SIZE_LAST = 1;\n+\n+    /**\n+     * Mode for using a query to calculate the size of large result sets.\n+     */\n+    public static final int SIZE_QUERY = 2;\n+}"},{"sha":"c0e45f2eb930b548508cbc2c524f28f7c37c2d52","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/MappedQueryResultObjectProvider.java","status":"added","additions":457,"deletions":0,"changes":457,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/MappedQueryResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/MappedQueryResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/MappedQueryResultObjectProvider.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,457 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Ref;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Stack;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.meta.QueryResultMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.sql.AbstractResult;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.util.StoreException;\n+import org.apache.openjpa.util.UnsupportedException;\n+\n+/**\n+ * Provides the data from query result mapped by a {@link QueryResultMapping}.\n+ *\n+ * @author Pinaki Poddar\n+ * @author Abe White\n+ */\n+class MappedQueryResultObjectProvider\n+    implements ResultObjectProvider {\n+\n+    private final QueryResultMapping _map;\n+    private final JDBCStore _store;\n+    private final JDBCFetchConfiguration _fetch;\n+    private final MappingResult _mres;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param res the result data\n+     */\n+    public MappedQueryResultObjectProvider(QueryResultMapping map,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Result res) {\n+        _map = map;\n+        _store = store;\n+        _fetch = (fetch == null) ? store.getFetchConfiguration() : fetch;\n+        _mres = new MappingResult(res);\n+    }\n+\n+    public boolean supportsRandomAccess() {\n+        try {\n+            return _mres.supportsRandomAccess();\n+        } catch (Throwable t) {\n+            return false;\n+        }\n+    }\n+\n+    public void open() {\n+    }\n+\n+    public Object getResultObject()\n+        throws SQLException {\n+        QueryResultMapping.PCResult[] pcs = _map.getPCResults();\n+        Object[] cols = _map.getColumnResults();\n+\n+        // single object cases\n+        if (pcs.length == 0 && cols.length == 1)\n+            return _mres.getObject(cols[0], JavaSQLTypes.JDBC_DEFAULT, null);\n+        if (pcs.length == 1 && cols.length == 0)\n+            return _mres.load(pcs[0], _store,\n+                (JDBCFetchState) _fetch.newFetchState());\n+\n+        // multiple objects\n+        Object[] ret = new Object[pcs.length + cols.length];\n+        for (int i = 0; i < pcs.length; i++)\n+            ret[i] = _mres.load(pcs[i], _store,\n+                (JDBCFetchState) _fetch.newFetchState());\n+        for (int i = 0; i < cols.length; i++)\n+            ret[pcs.length + i] = _mres.getObject(cols[i],\n+                JavaSQLTypes.JDBC_DEFAULT, null);\n+        return ret;\n+    }\n+\n+    public boolean next()\n+        throws SQLException {\n+        return _mres.next();\n+    }\n+\n+    public boolean absolute(int pos)\n+        throws SQLException {\n+        return _mres.absolute(pos);\n+    }\n+\n+    public int size()\n+        throws SQLException {\n+        if (_fetch.getLRSSize() == LRSSizes.SIZE_UNKNOWN\n+            || !supportsRandomAccess())\n+            return Integer.MAX_VALUE;\n+        return _mres.size();\n+    }\n+\n+    public void reset() {\n+        throw new UnsupportedException();\n+    }\n+\n+    public void close() {\n+        _mres.close();\n+    }\n+\n+    public void handleCheckedException(Exception e) {\n+        if (e instanceof SQLException)\n+            throw SQLExceptions.getStore((SQLException) e,\n+                _store.getDBDictionary());\n+        throw new StoreException(e);\n+    }\n+\n+    /**\n+     * Result type that maps requests using a given\n+     * {@link QueryResultMapping.PCResult}.\n+     */\n+    private static class MappingResult\n+        extends AbstractResult {\n+\n+        private final Result _res;\n+        private final Stack _requests = new Stack();\n+        private QueryResultMapping.PCResult _pc = null;\n+\n+        /**\n+         * Supply delegate on construction.\n+         */\n+        public MappingResult(Result res) {\n+            _res = res;\n+        }\n+\n+        /**\n+         * Load an instance of the given type. Should be used in place of\n+         * {@link Result#load}.\n+         */\n+        public Object load(QueryResultMapping.PCResult pc, JDBCStore store,\n+            JDBCFetchState fetchState)\n+            throws SQLException {\n+            _pc = pc;\n+            try {\n+                return load(pc.getCandidateTypeMapping(), store, fetchState);\n+            } finally {\n+                _pc = null;\n+            }\n+        }\n+\n+        public Object load(ClassMapping mapping, JDBCStore store,\n+            JDBCFetchState fetchState)\n+            throws SQLException {\n+            return load(mapping, store, fetchState, null);\n+        }\n+\n+        public Object load(ClassMapping mapping, JDBCStore store,\n+            JDBCFetchState fetchState, Joins joins)\n+            throws SQLException {\n+            if (_pc == null)\n+                return super.load(mapping, store, fetchState, joins);\n+\n+            // we go direct to the store manager so we can tell it not to load\n+            // anything additional\n+            return ((JDBCStoreManager) store).load(mapping, fetchState,\n+                _pc.getExcludes(_requests), this);\n+        }\n+\n+        public Object getEager(FieldMapping key) {\n+            Object ret = _res.getEager(key);\n+            if (_pc == null || ret != null)\n+                return ret;\n+            return (_pc.hasEager(_requests, key)) ? this : null;\n+        }\n+\n+        public void putEager(FieldMapping key, Object res) {\n+            _res.putEager(key, res);\n+        }\n+\n+        public void close() {\n+            _res.close();\n+        }\n+\n+        public Joins newJoins() {\n+            return _res.newJoins();\n+        }\n+\n+        public boolean supportsRandomAccess()\n+            throws SQLException {\n+            return _res.supportsRandomAccess();\n+        }\n+\n+        public ClassMapping getBaseMapping() {\n+            return _res.getBaseMapping();\n+        }\n+\n+        public int size()\n+            throws SQLException {\n+            return _res.size();\n+        }\n+\n+        public void startDataRequest(Object mapping) {\n+            _requests.push(mapping);\n+        }\n+\n+        public void endDataRequest() {\n+            _requests.pop();\n+        }\n+\n+        public boolean wasNull()\n+            throws SQLException {\n+            return _res.wasNull();\n+        }\n+\n+        protected Object translate(Object obj, Joins joins) {\n+            return (_pc == null) ? obj : _pc.map(_requests, obj, joins);\n+        }\n+\n+        protected boolean absoluteInternal(int row)\n+            throws SQLException {\n+            return _res.absolute(row);\n+        }\n+\n+        protected boolean nextInternal()\n+            throws SQLException {\n+            return _res.next();\n+        }\n+\n+        protected boolean containsInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            return _res.contains(translate(obj, joins));\n+        }\n+\n+        protected Array getArrayInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getArray((Column) obj, joins);\n+            return _res.getArray(obj);\n+        }\n+\n+        protected InputStream getAsciiStreamInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getAsciiStream((Column) obj, joins);\n+            return _res.getAsciiStream(obj);\n+        }\n+\n+        protected BigDecimal getBigDecimalInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getBigDecimal((Column) obj, joins);\n+            return _res.getBigDecimal(obj);\n+        }\n+\n+        protected Number getNumberInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getNumber((Column) obj, joins);\n+            return _res.getNumber(obj);\n+        }\n+\n+        protected BigInteger getBigIntegerInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getBigInteger((Column) obj, joins);\n+            return _res.getBigInteger(obj);\n+        }\n+\n+        protected InputStream getBinaryStreamInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getBinaryStream((Column) obj, joins);\n+            return _res.getBinaryStream(obj);\n+        }\n+\n+        protected Blob getBlobInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getBlob((Column) obj, joins);\n+            return _res.getBlob(obj);\n+        }\n+\n+        protected boolean getBooleanInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getBoolean((Column) obj, joins);\n+            return _res.getBoolean(obj);\n+        }\n+\n+        protected byte getByteInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getByte((Column) obj, joins);\n+            return _res.getByte(obj);\n+        }\n+\n+        protected byte[] getBytesInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getBytes((Column) obj, joins);\n+            return _res.getBytes(obj);\n+        }\n+\n+        protected Calendar getCalendarInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getCalendar((Column) obj, joins);\n+            return _res.getCalendar(obj);\n+        }\n+\n+        protected char getCharInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getChar((Column) obj, joins);\n+            return _res.getChar(obj);\n+        }\n+\n+        protected Reader getCharacterStreamInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getCharacterStream((Column) obj, joins);\n+            return _res.getCharacterStream(obj);\n+        }\n+\n+        protected Clob getClobInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getClob((Column) obj, joins);\n+            return _res.getClob(obj);\n+        }\n+\n+        protected Date getDateInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getDate((Column) obj, joins);\n+            return _res.getDate(obj);\n+        }\n+\n+        protected java.sql.Date getDateInternal(Object obj, Calendar cal,\n+            Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getDate((Column) obj, cal, joins);\n+            return _res.getDate(obj, cal);\n+        }\n+\n+        protected double getDoubleInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getDouble((Column) obj, joins);\n+            return _res.getDouble(obj);\n+        }\n+\n+        protected float getFloatInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getFloat((Column) obj, joins);\n+            return _res.getFloat(obj);\n+        }\n+\n+        protected int getIntInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getInt((Column) obj, joins);\n+            return _res.getInt(obj);\n+        }\n+\n+        protected Locale getLocaleInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getLocale((Column) obj, joins);\n+            return _res.getLocale(obj);\n+        }\n+\n+        protected long getLongInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getLong((Column) obj, joins);\n+            return _res.getLong(obj);\n+        }\n+\n+        protected Object getObjectInternal(Object obj, int metaTypeCode,\n+            Object arg, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getObject((Column) obj, arg, joins);\n+            return _res.getObject(obj, metaTypeCode, arg);\n+        }\n+\n+        protected Object getSQLObjectInternal(Object obj, Map map, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getSQLObject((Column) obj, map, joins);\n+            return _res.getSQLObject(obj, map);\n+        }\n+\n+        protected Ref getRefInternal(Object obj, Map map, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getRef((Column) obj, map, joins);\n+            return _res.getRef(obj, map);\n+        }\n+\n+        protected short getShortInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getShort((Column) obj, joins);\n+            return _res.getShort(obj);\n+        }\n+\n+        protected String getStringInternal(Object obj, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getString((Column) obj, joins);\n+            return _res.getString(obj);\n+        }\n+\n+        protected Time getTimeInternal(Object obj, Calendar cal, Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getTime((Column) obj, cal, joins);\n+            return _res.getTime(obj, cal);\n+        }\n+\n+        protected Timestamp getTimestampInternal(Object obj, Calendar cal,\n+            Joins joins)\n+            throws SQLException {\n+            if (obj instanceof Column)\n+                return _res.getTimestamp((Column) obj, cal, joins);\n+            return _res.getTimestamp(obj, cal);\n+        }\n+    }\n+}"},{"sha":"4f7fa81b962e1e51b0f2996924d169056f161ab0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","status":"added","additions":369,"deletions":0,"changes":369,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.text.MessageFormat;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.schema.Schema;\n+import org.apache.openjpa.jdbc.schema.SchemaGroup;\n+import org.apache.openjpa.jdbc.schema.SchemaTool;\n+import org.apache.openjpa.jdbc.schema.Schemas;\n+import org.apache.openjpa.jdbc.schema.Sequence;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Options;\n+import org.apache.openjpa.util.MetaDataException;\n+import org.apache.openjpa.util.UserException;\n+import serp.util.Numbers;\n+import serp.util.Strings;\n+\n+////////////////////////////////////////////////////////////\n+// NOTE: Do not change property names; see SequenceMetaData\n+// and SequenceMapping for standard property names.\n+////////////////////////////////////////////////////////////\n+\n+/**\n+ * {@link JDBCSeq} implementation that uses a database sequences\n+ * to generate numbers.\n+ *\n+ * @see JDBCSeq\n+ * @see AbstractJDBCSeq\n+ */\n+public class NativeJDBCSeq\n+    extends AbstractJDBCSeq\n+    implements Configurable {\n+\n+    public static final String ACTION_DROP = \"drop\";\n+    public static final String ACTION_ADD = \"add\";\n+    public static final String ACTION_GET = \"get\";\n+\n+    private static Localizer _loc = Localizer.forPackage(NativeJDBCSeq.class);\n+\n+    private JDBCConfiguration _conf = null;\n+    private String _seqName = \"OPENJPA_SEQUENCE\";\n+    private int _increment = 1;\n+    private int _initial = 1;\n+    private int _allocate = 0;\n+    private Sequence _seq = null;\n+    private String _select = null;\n+\n+    // for deprecated auto-configuration support\n+    private String _format = null;\n+    private String _tableName = \"DUAL\";\n+    private boolean _subTable = false;\n+\n+    /**\n+     * The sequence name. Defaults to <code>OPENJPA_SEQUENCE</code>.\n+     */\n+    public String getSequence() {\n+        return _seqName;\n+    }\n+\n+    /**\n+     * The sequence name. Defaults to <code>OPENJPA_SEQUENCE</code>.\n+     */\n+    public void setSequence(String seqName) {\n+        _seqName = seqName;\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #setSequence}. Retained for\n+     * backwards-compatibility for auto-configuration.\n+     */\n+    public void setSequenceName(String seqName) {\n+        setSequence(seqName);\n+    }\n+\n+    /**\n+     * @see Sequence#getInitialValue\n+     */\n+    public int getInitialValue() {\n+        return _initial;\n+    }\n+\n+    /**\n+     * @see Sequence#setInitialValue\n+     */\n+    public void setInitialValue(int initial) {\n+        _initial = initial;\n+    }\n+\n+    /**\n+     * @see Sequence#getAllocate\n+     */\n+    public int getAllocate() {\n+        return _allocate;\n+    }\n+\n+    /**\n+     * @see Sequence#setAllocate\n+     */\n+    public void setAllocate(int allocate) {\n+        _allocate = allocate;\n+    }\n+\n+    /**\n+     * @see Sequence#getIncrement\n+     */\n+    public int getIncrement() {\n+        return _increment;\n+    }\n+\n+    /**\n+     * @see Sequence#setIncrement\n+     */\n+    public void setIncrement(int increment) {\n+        _increment = increment;\n+    }\n+\n+    /**\n+     * @deprecated Retained for backwards-compatibility for auto-configuration.\n+     */\n+    public void setTableName(String table) {\n+        _tableName = table;\n+    }\n+\n+    /**\n+     * @deprecated Retained for backwards-compatibility for auto-configuration.\n+     */\n+    public void setFormat(String format) {\n+        _format = format;\n+        _subTable = true;\n+    }\n+\n+    public void addSchema(ClassMapping mapping, SchemaGroup group) {\n+        // sequence already exists?\n+        if (group.isKnownSequence(_seqName))\n+            return;\n+\n+        String schemaName = Strings.getPackageName(_seqName);\n+        if (schemaName.length() == 0)\n+            schemaName = Schemas.getNewTableSchema(_conf);\n+\n+        // create table in this group\n+        Schema schema = group.getSchema(schemaName);\n+        if (schema == null)\n+            schema = group.addSchema(schemaName);\n+        schema.importSequence(_seq);\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+        _conf = (JDBCConfiguration) conf;\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+        buildSequence();\n+\n+        DBDictionary dict = _conf.getDBDictionaryInstance();\n+        if (_format == null) {\n+            _format = dict.nextSequenceQuery;\n+            if (_format == null)\n+                throw new MetaDataException(_loc.get(\"no-seq-sql\", _seqName));\n+        }\n+        if (_tableName == null)\n+            _tableName = \"DUAL\";\n+\n+        String name = dict.getFullName(_seq);\n+        Object[] subs = (_subTable) ? new Object[]{ name, _tableName }\n+            : new Object[]{ name };\n+        _select = MessageFormat.format(_format, subs);\n+    }\n+\n+    protected Object nextInternal(JDBCStore store, ClassMapping mapping)\n+        throws SQLException {\n+        long next = getSequence(getConnection(store));\n+        return Numbers.valueOf(next);\n+    }\n+\n+    /**\n+     * Creates the sequence object.\n+     */\n+    private void buildSequence() {\n+        String seqName = Strings.getClassName(_seqName);\n+        String schemaName = Strings.getPackageName(_seqName);\n+        if (schemaName.length() == 0)\n+            schemaName = Schemas.getNewTableSchema(_conf);\n+\n+        // build the sequence in one of the designated schemas\n+        SchemaGroup group = new SchemaGroup();\n+        Schema schema = group.addSchema(schemaName);\n+\n+        _seq = schema.addSequence(seqName);\n+        _seq.setInitialValue(_initial);\n+        _seq.setIncrement(_increment);\n+        _seq.setAllocate(_allocate);\n+    }\n+\n+    /**\n+     * Creates the sequence in the DB.\n+     */\n+    public void refreshSequence()\n+        throws SQLException {\n+        Log log = _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\n+        if (log.isInfoEnabled())\n+            log.info(_loc.get(\"make-native-seq\"));\n+\n+        // create the sequence\n+        SchemaTool tool = new SchemaTool(_conf);\n+        tool.setIgnoreErrors(true);\n+        tool.createSequence(_seq);\n+    }\n+\n+    /**\n+     * Drops the sequence in the DB.\n+     */\n+    public void dropSequence()\n+        throws SQLException {\n+        Log log = _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\n+        if (log.isInfoEnabled())\n+            log.info(_loc.get(\"drop-native-seq\"));\n+\n+        // drop the table\n+        SchemaTool tool = new SchemaTool(_conf);\n+        tool.setIgnoreErrors(true);\n+        tool.dropSequence(_seq);\n+    }\n+\n+    /**\n+     * Return the next sequence value.\n+     */\n+    private long getSequence(Connection conn)\n+        throws SQLException {\n+        PreparedStatement stmnt = null;\n+        ResultSet rs = null;\n+        try {\n+            stmnt = conn.prepareStatement(_select);\n+            rs = stmnt.executeQuery();\n+            if (rs.next())\n+                return rs.getLong(1);\n+\n+            // no row !?\n+            throw new UserException(_loc.get(\"invalid-seq-sql\", _select));\n+        } finally {\n+            // clean up our resources\n+            if (rs != null)\n+                try {\n+                    rs.close();\n+                } catch (SQLException se) {\n+                }\n+            if (stmnt != null)\n+                try {\n+                    stmnt.close();\n+                } catch (SQLException se) {\n+                }\n+        }\n+    }\n+\n+    /////////\n+    // Main\n+    /////////\n+\n+    /**\n+     * Usage: java org.apache.openjpa.jdbc.schema.NativeJDBCSequence [option]*\n+     * -action/-a &lt;add | drop | get&gt;\n+     *  Where the following options are recognized.\n+     * <ul>\n+     * <li><i>-properties/-p &lt;properties file or resource&gt;</i>: The\n+     * path or resource name of a OpenJPA properties file containing\n+     * information such as the license key\tand connection data as\n+     * outlined in {@link JDBCConfiguration}. Optional.</li>\n+     * <li><i>-&lt;property name&gt; &lt;property value&gt;</i>: All bean\n+     * properties of the OpenJPA {@link JDBCConfiguration} can be set by\n+     * using their\tnames and supplying a value. For example:\n+     * <code>-licenseKey adslfja83r3lkadf</code></li>\n+     * </ul>\n+     *  The various actions are as follows.\n+     * <ul>\n+     * <li><i>add</i>: Create the sequence.</li>\n+     * <li><i>drop</i>: Drop the sequence.</li>\n+     * <li><i>get</i>: Print the next sequence value.</li>\n+     * </ul>\n+     */\n+    public static void main(String[] args)\n+        throws Exception {\n+        Options opts = new Options();\n+        args = opts.setFromCmdLine(args);\n+        JDBCConfiguration conf = new JDBCConfigurationImpl();\n+        try {\n+            if (!run(conf, args, opts))\n+                System.out.println(_loc.get(\"native-seq-usage\"));\n+        } finally {\n+            conf.close();\n+        }\n+    }\n+\n+    /**\n+     * Run the tool. Returns false if invalid options were given.\n+     */\n+    public static boolean run(JDBCConfiguration conf, String[] args,\n+        Options opts)\n+        throws Exception {\n+        if (opts.containsKey(\"help\") || opts.containsKey(\"-help\"))\n+            return false;\n+\n+        String action = opts.removeProperty(\"action\", \"a\", null);\n+        Configurations.populateConfiguration(conf, opts);\n+        return run(conf, args, action);\n+    }\n+\n+    /**\n+     * Run the tool. Return false if an invalid option was given.\n+     */\n+    public static boolean run(JDBCConfiguration conf, String[] args,\n+        String action)\n+        throws Exception {\n+        if (args.length != 0)\n+            return false;\n+\n+        NativeJDBCSeq seq = new NativeJDBCSeq();\n+        String props = Configurations.getProperties(conf.getSequence());\n+        Configurations.configureInstance(seq, conf, props);\n+\n+        if (ACTION_DROP.equals(action))\n+            seq.dropSequence();\n+        else if (ACTION_ADD.equals(action))\n+            seq.refreshSequence();\n+        else if (ACTION_GET.equals(action)) {\n+            Connection conn = conf.getDataSource2(null).getConnection();\n+            try {\n+                long cur = seq.getSequence(conn);\n+                System.out.println(cur);\n+            } finally {\n+                try {\n+                    conn.close();\n+                } catch (SQLException se) {\n+                }\n+            }\n+        } else\n+            return false;\n+        return true;\n+    }\n+}"},{"sha":"e4965579ee916a8d7e44fc1be9deab2597f1fc4e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/OperationOrderUpdateManager.java","status":"added","additions":217,"deletions":0,"changes":217,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/OperationOrderUpdateManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/OperationOrderUpdateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/OperationOrderUpdateManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.sql.PrimaryRow;\n+import org.apache.openjpa.jdbc.sql.Row;\n+import org.apache.openjpa.jdbc.sql.RowImpl;\n+import org.apache.openjpa.jdbc.sql.RowManager;\n+import org.apache.openjpa.jdbc.sql.RowManagerImpl;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * Update manager that writes SQL in object-level operation order.\n+ *\n+ * @author Abe White\n+ */\n+public class OperationOrderUpdateManager\n+    extends AbstractUpdateManager {\n+\n+    public boolean orderDirty() {\n+        return true;\n+    }\n+\n+    protected RowManager newRowManager() {\n+        return new RowManagerImpl(true);\n+    }\n+\n+    protected PreparedStatementManager newPreparedStatementManager\n+        (JDBCStore store, Connection conn) {\n+        return new PreparedStatementManagerImpl(store, conn);\n+    }\n+\n+    protected Collection flush(RowManager rowMgr,\n+        PreparedStatementManager psMgr, Collection exceps) {\n+        RowManagerImpl rmimpl = (RowManagerImpl) rowMgr;\n+\n+        // first take care of all secondary table deletes and 'all row' deletes\n+        // (which are probably secondary table deletes), since no foreign\n+        // keys ever rely on secondary table pks\n+        flush(rmimpl.getAllRowDeletes(), psMgr);\n+        flush(rmimpl.getSecondaryDeletes(), psMgr);\n+\n+        // now do any 'all row' updates, which typically null keys\n+        flush(rmimpl.getAllRowUpdates(), psMgr);\n+\n+        // gather any updates we need to avoid fk constraints on deletes\n+        Collection constraintUpdates = null;\n+        for (Iterator itr = rmimpl.getDeletes().iterator(); itr.hasNext();) {\n+            try {\n+                constraintUpdates = analyzeDeleteConstraints(rmimpl,\n+                    (PrimaryRow) itr.next(), constraintUpdates);\n+            } catch (SQLException se) {\n+                exceps = addException(exceps, SQLExceptions.getStore\n+                    (se, dict));\n+            }\n+        }\n+        if (constraintUpdates != null) {\n+            flush(constraintUpdates, psMgr);\n+            constraintUpdates.clear();\n+        }\n+\n+        // flush primary rows in order\n+        for (Iterator itr = rmimpl.getOrdered().iterator(); itr.hasNext();) {\n+            try {\n+                constraintUpdates = flushPrimaryRow(rmimpl, (PrimaryRow)\n+                    itr.next(), psMgr, constraintUpdates);\n+            } catch (SQLException se) {\n+                exceps = addException(exceps, SQLExceptions.getStore\n+                    (se, dict));\n+            }\n+        }\n+        if (constraintUpdates != null)\n+            flush(constraintUpdates, psMgr);\n+\n+        // take care of all secondary table inserts and updates last, since\n+        // they may rely on previous inserts or updates, but nothing relies\n+        // on them\n+        flush(rmimpl.getSecondaryUpdates(), psMgr);\n+\n+        // flush any left over prepared statements\n+        psMgr.flush();\n+        return exceps;\n+    }\n+\n+    /**\n+     * Analyze the delete constraints on the given row, gathering necessary\n+     * updates to null fks before deleting.\n+     */\n+    private Collection analyzeDeleteConstraints(RowManagerImpl rowMgr,\n+        PrimaryRow row, Collection updates)\n+        throws SQLException {\n+        if (!row.isValid())\n+            return updates;\n+\n+        ForeignKey[] fks = row.getTable().getForeignKeys();\n+        OpenJPAStateManager sm;\n+        PrimaryRow rel;\n+        RowImpl update;\n+        for (int i = 0; i < fks.length; i++) {\n+            // when deleting ref fks we set the where value instead\n+            sm = row.getForeignKeySet(fks[i]);\n+            if (sm == null)\n+                sm = row.getForeignKeyWhere(fks[i]);\n+            if (sm == null)\n+                continue;\n+\n+            // only need an update if we have an fk to a row that's being\n+            // deleted before we are\n+            rel = (PrimaryRow) rowMgr.getRow(fks[i].getPrimaryKeyTable(),\n+                Row.ACTION_DELETE, sm, false);\n+            if (rel == null || !rel.isValid()\n+                || rel.getIndex() >= row.getIndex())\n+                continue;\n+\n+            // create an update to null the offending fk before deleting\n+            update = new RowImpl(row.getTable(), Row.ACTION_UPDATE);\n+            row.copyInto(update, true);\n+            update.setForeignKey(fks[i], row.getForeignKeyIO(fks[i]), null);\n+            if (updates == null)\n+                updates = new ArrayList();\n+            updates.add(update);\n+        }\n+        return updates;\n+    }\n+\n+    /**\n+     * Flush the given row, creating deferred updates for dependencies.\n+     */\n+    private Collection flushPrimaryRow(RowManagerImpl rowMgr, PrimaryRow row,\n+        PreparedStatementManager psMgr, Collection updates)\n+        throws SQLException {\n+        if (!row.isValid())\n+            return updates;\n+\n+        // already analyzed deletes\n+        if (row.getAction() == Row.ACTION_DELETE) {\n+            psMgr.flush(row);\n+            return updates;\n+        }\n+\n+        ForeignKey[] fks = row.getTable().getForeignKeys();\n+        OpenJPAStateManager sm;\n+        PrimaryRow rel;\n+        PrimaryRow update;\n+        for (int i = 0; i < fks.length; i++) {\n+            sm = row.getForeignKeySet(fks[i]);\n+            if (sm == null)\n+                continue;\n+\n+            // only need an update if we have an fk to a row that's being\n+            // inserted after we are; if row is dependent on itself and no\n+            // fk, must be an auto-inc because otherwise we wouldn't have\n+            // recorded it\n+            rel = (PrimaryRow) rowMgr.getRow(fks[i].getPrimaryKeyTable(),\n+                Row.ACTION_INSERT, sm, false);\n+            if (rel == null || !rel.isValid()\n+                || rel.getIndex() < row.getIndex()\n+                || (rel == row && !fks[i].isDeferred() && !fks[i].isLogical()))\n+                continue;\n+\n+            // don't insert or update with the given fk; create a deferred\n+            // update for after the rel row has been inserted; use a primary row\n+            // to prevent setting values until after flush to get auto-inc\n+            update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\n+            if (row.getAction() == Row.ACTION_INSERT)\n+                update.wherePrimaryKey(row.getPrimaryKey());\n+            else\n+                row.copyInto(update, true);\n+            update.setForeignKey(fks[i], row.getForeignKeyIO(fks[i]), sm);\n+            row.clearForeignKey(fks[i]);\n+\n+            if (updates == null)\n+                updates = new ArrayList();\n+            updates.add(update);\n+        }\n+\n+        if (row.isValid()) // if update, maybe no longer needed\n+            psMgr.flush(row);\n+        return updates;\n+    }\n+\n+    /**\n+     * Flush the given collection of secondary rows.\n+     */\n+    protected void flush(Collection rows, PreparedStatementManager psMgr) {\n+        if (rows.isEmpty())\n+            return;\n+\n+        RowImpl row;\n+        for (Iterator itr = rows.iterator(); itr.hasNext();) {\n+            row = (RowImpl) itr.next();\n+            if (row.isValid())\n+                psMgr.flush(row);\n+        }\n+    }\n+}"},{"sha":"bf566331d5c3c74982ee580d389fd0d38df15bdc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PagingResultObjectProvider.java","status":"added","additions":445,"deletions":0,"changes":445,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PagingResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PagingResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PagingResultObjectProvider.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,445 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.jdbc.sql.SelectExecutor;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.util.Closeable;\n+import org.apache.openjpa.util.InternalException;\n+\n+/**\n+ * Object provider implementation that fetches one page of results at a\n+ * a time as it scrolls. If the {@link #getPagedFields} method returns a\n+ * non-null bit set, this this provider is a good fit for your configuration.\n+ * The method tests the following conditions:\n+ * <ul>\n+ * <li>The eager fetch mode is <code>parallel</code>.</li>\n+ * <li>The select's result should be treated as a large result set.</li>\n+ * <li>The mapping being selected has fields that use parallel selects\n+ * under the current fetch configuration.</li>\n+ * </ul>\n+ *  To use this provider, select the candidate mapping with eager fetch\n+ * mode set to <code>join</code>. This provider will take care of performing\n+ * <code>parallel</code> mode batch selects for each page it reads.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class PagingResultObjectProvider\n+    extends SelectResultObjectProvider {\n+\n+    private final ClassMapping[] _mappings;\n+    private final Object[] _page;\n+    private final int[] _idxs;\n+    private final BitSet[] _paged;\n+    private int _pos = -1; // logical pos\n+    private int _pagePos = -1; // pos of page start\n+\n+    /**\n+     * Return a bit set representing batch select fields that will be paged,\n+     * or null if no fields need paging, which indicates that this provider\n+     * should not be used.\n+     *\n+     * @see #PagingResultObjectProvider\n+     */\n+    public static BitSet getPagedFields(Select sel, ClassMapping mapping,\n+        JDBCStore store, JDBCFetchState fetchState, int eagerMode,\n+        long size) {\n+        JDBCFetchConfiguration fetch = fetchState.getJDBCFetchConfiguration();\n+        // if we have a range then we always use paging if there are any\n+        // eager select fields; otherwise it depends on lrs and fetch settings\n+        if (size == Long.MAX_VALUE || !sel.getAutoDistinct()) {\n+            // not lrs?\n+            if (!sel.isLRS())\n+                return null;\n+\n+            // not configured for lazy loading?\n+            if (fetch.getFetchBatchSize() < 0)\n+                return null;\n+        }\n+\n+        // not configured for eager selects?\n+        eagerMode = Math.min(eagerMode, fetch.getEagerFetchMode());\n+        if (eagerMode != fetch.EAGER_PARALLEL)\n+            return null;\n+\n+        // are there any mappings that require batched selects?\n+        FieldMapping[] fms = mapping.getDefinedFieldMappings();\n+        BitSet paged = null;\n+        for (int i = 0; i < fms.length; i++) {\n+            if (fetchState != null\n+                && !fetchState.requiresSelect(fms[i], false))\n+                continue;\n+\n+            if (fms[i].supportsSelect(sel, sel.EAGER_PARALLEL, null, store,\n+                fetch) > 0 && (fms[i].isEagerSelectToMany() || fms[i].\n+                supportsSelect(sel, sel.EAGER_OUTER, null, store, fetch) == 0))\n+            {\n+                if (paged == null)\n+                    paged = new BitSet();\n+                paged.set(fms[i].getIndex());\n+            }\n+        }\n+        return paged;\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param sel the select to execute\n+     * @param mapping the mapping of the result objects\n+     * @param store the store manager to delegate loading to\n+     * @param fetch the fetch configuration, or null for default\n+     * @param paged the bit set returned from {@link #getPagedFields}\n+     * @param size the known maximum size of the result, or\n+     * {@link Long#MAX_VALUE} for no known limit\n+     */\n+    public PagingResultObjectProvider(SelectExecutor sel,\n+        ClassMapping mapping, JDBCStore store, JDBCFetchState fetchState,\n+        BitSet paged, long size) {\n+        this(sel, new ClassMapping[]{ mapping }, store, fetchState,\n+            new BitSet[]{ paged }, size);\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param sel the select to execute\n+     * @param mappings the mappings for the independent classes of the\n+     * result objects\n+     * @param store the store manager to delegate loading to\n+     * @param fetch the fetch configuration, or null for default\n+     * @param paged the bit sets returned from {@link #getPagedFields}\n+     * for each select in the possible union\n+     * @param size the known maximum size of the result, or\n+     * {@link Long#MAX_VALUE} for no known limit\n+     */\n+    public PagingResultObjectProvider(SelectExecutor sel,\n+        ClassMapping[] mappings, JDBCStore store, JDBCFetchState fetchState,\n+        BitSet[] paged, long size) {\n+        super(sel, store, fetchState);\n+        _mappings = mappings;\n+        _paged = paged;\n+\n+        // don't let system construct this type of rop for stupid sizes\n+        if (size <= 1)\n+            throw new InternalException(\"size=\" + size);\n+\n+        // try to find a good page size.  if the known size < batch size, use\n+        // it.  if the batch size is set, then use that; if it's sorta close\n+        // to the size, then use the size / 2 to get two full pages rather\n+        // than a possible big one and small one.  cap everything at 50.\n+        int batch = getFetchConfiguration().getFetchBatchSize();\n+        int pageSize;\n+        if (size <= batch && size <= 50)\n+            pageSize = (int) size;\n+        else if (batch > 0 && batch <= 50) {\n+            if (size <= batch * 2) {\n+                if (size % 2 == 0)\n+                    pageSize = (int) (size / 2);\n+                else\n+                    pageSize = (int) (size / 2 + 1);\n+            } else\n+                pageSize = batch;\n+        } else if (size <= 50)\n+            pageSize = (int) size;\n+        else if (size <= 100) {\n+            if (size % 2 == 0)\n+                pageSize = (int) (size / 2);\n+            else\n+                pageSize = (int) (size / 2 + 1);\n+        } else\n+            pageSize = 50;\n+\n+        _page = new Object[pageSize];\n+        if (_paged.length > 1)\n+            _idxs = new int[pageSize];\n+        else\n+            _idxs = null;\n+    }\n+\n+    /**\n+     * Return the page size in use.\n+     */\n+    public int getPageSize() {\n+        return _page.length;\n+    }\n+\n+    public void open()\n+        throws SQLException {\n+        super.open();\n+        _pos = -1;\n+    }\n+\n+    public boolean next()\n+        throws SQLException {\n+        _pos++;\n+        if (inPage())\n+            return _page[_pos - _pagePos] != null;\n+        if (!super.next()) {\n+            setSize(_pos);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public boolean absolute(int pos)\n+        throws SQLException {\n+        _pos = pos;\n+        if (inPage())\n+            return _page[_pos - _pagePos] != null;\n+        return super.absolute(pos);\n+    }\n+\n+    public Object getResultObject()\n+        throws SQLException {\n+        if (!inPage())\n+            fillPage();\n+        return _page[_pos - _pagePos];\n+    }\n+\n+    /**\n+     * Test whether our current position is within the cached page of results.\n+     */\n+    private boolean inPage() {\n+        return _pagePos != -1 && _pos >= _pagePos\n+            && _pos < _pagePos + _page.length;\n+    }\n+\n+    /**\n+     * Start a new page at the present position.\n+     */\n+    private void fillPage()\n+        throws SQLException {\n+        // clear page\n+        Arrays.fill(_page, null);\n+\n+        // cache result objects\n+        JDBCStoreManager storeMgr = (JDBCStoreManager) getStore();\n+        ClassMapping mapping;\n+        Result res;\n+        int idx;\n+        for (int i = 0; i < _page.length; i++) {\n+            res = getResult();\n+            idx = res.indexOf();\n+            if (_idxs != null)\n+                _idxs[i] = idx;\n+            mapping = res.getBaseMapping();\n+            if (mapping == null)\n+                mapping = _mappings[idx];\n+\n+            // rather than use the standard result.load(), we go direct to\n+            // the store manager so we can pass in our eager-fetched fields as\n+            // fields to exclude from the initial load of the objects\n+            _page[i] = storeMgr.load(mapping, getFetchState(),\n+                _paged[idx], res);\n+            if (i != _page.length - 1 && !getResult().next()) {\n+                setSize(_pos + i + 1);\n+                break;\n+            }\n+        }\n+\n+        // load data for eager fields\n+        _pagePos = _pos;\n+        if (_page[0] != null) {\n+            if (_page.length > 1 && _page[1] == null)\n+                loadEagerFields();\n+            else\n+                executeEagerSelects();\n+        }\n+    }\n+\n+    /**\n+     * When there is only one instance in a page, load fields as normal.\n+     */\n+    private void loadEagerFields()\n+        throws SQLException {\n+        int idx = (_idxs == null) ? 0 : _idxs[0];\n+        if (_paged[idx] == null)\n+            return;\n+\n+        JDBCStore store = getStore();\n+        OpenJPAStateManager sm = store.getContext().getStateManager(_page[0]);\n+        for (int i = 0, len = _paged[idx].length(); i < len; i++) {\n+            if (_paged[idx].get(i)) {\n+                _mappings[idx].getFieldMapping(i).load(sm, store,\n+                    getFetchState());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Load eager batch selects for current page of results.\n+     */\n+    private void executeEagerSelects()\n+        throws SQLException {\n+        if (_idxs == null) {\n+            executeEagerSelects(_mappings[0], _paged[0], 0, _page.length);\n+            return;\n+        }\n+\n+        int start = 0;\n+        int idx = _idxs[0];\n+        int pos = 0;\n+        for (; pos < _page.length && _page[pos] != null; pos++) {\n+            if (idx != _idxs[pos]) {\n+                if (_paged[idx] != null)\n+                    executeEagerSelects(_mappings[idx], _paged[idx], start,\n+                        pos);\n+                start = pos;\n+                idx = _idxs[pos];\n+            }\n+        }\n+        if (start < pos && _paged[idx] != null) // cleanup remainder\n+            executeEagerSelects(_mappings[idx], _paged[idx], start, pos);\n+    }\n+\n+    /**\n+     * Load eager batch selects for the given mapping and its superclasses.\n+     */\n+    private void executeEagerSelects(ClassMapping mapping, BitSet paged,\n+        int start, int end)\n+        throws SQLException {\n+        // base case\n+        if (mapping == null)\n+            return;\n+\n+        // recurse on superclass\n+        executeEagerSelects(mapping.getJoinablePCSuperclassMapping(), paged,\n+            start, end);\n+\n+        // figure out how many batch selects to do on this mapping\n+        FieldMapping[] fms = mapping.getDefinedFieldMappings();\n+        int sels = 0;\n+        for (int i = 0; i < fms.length; i++)\n+            if (paged.get(fms[i].getIndex()))\n+                sels++;\n+        if (sels == 0)\n+            return;\n+\n+        // create where condition limiting instances to this page\n+        JDBCStore store = getStore();\n+        Select sel = store.getSQLFactory().newSelect();\n+        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n+        Column[] pks = mapping.getPrimaryKeyColumns();\n+        if (pks.length == 1)\n+            inContains(sel, buf, mapping, pks, start, end);\n+        else\n+            orContains(sel, buf, mapping, pks, start, end);\n+        sel.where(buf);\n+\n+        StoreContext ctx = store.getContext();\n+        JDBCFetchConfiguration fetch = getFetchConfiguration();\n+        JDBCFetchState fetchState = (JDBCFetchState) fetch.newFetchState();\n+        // do each batch select\n+        Object res;\n+        int esels = 0;\n+        SelectExecutor esel;\n+        int unions;\n+        for (int i = 0; i < fms.length; i++) {\n+            if (!paged.get(fms[i].getIndex()))\n+                continue;\n+\n+            unions = fms[i].supportsSelect(sel, Select.EAGER_PARALLEL, null,\n+                store, fetch);\n+            if (unions == 0)\n+                continue;\n+\n+            // we don't need to clone if this is the last select\n+            esels++;\n+            if (esels < sels || unions > 1)\n+                esel = sel.whereClone(unions);\n+            else\n+                esel = sel;\n+\n+            // get result\n+            fms[i].selectEagerParallel(esel, null, store, fetchState,\n+                JDBCFetchConfiguration.EAGER_PARALLEL);\n+            res = esel.execute(store, fetch);\n+            try {\n+                // and load result into paged instances\n+                for (int j = start; j < end && _page[j] != null; j++)\n+                    res = fms[i].loadEagerParallel(ctx.getStateManager\n+                        (_page[j]), store, fetchState, res);\n+            } finally {\n+                if (res instanceof Closeable)\n+                    try {\n+                        ((Closeable) res).close();\n+                    } catch (Exception e) {\n+                    }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create an IN clause limiting the results to the current page.\n+     */\n+    private void inContains(Select sel, SQLBuffer buf, ClassMapping mapping,\n+        Column[] pks, int start, int end) {\n+        buf.append(sel.getColumnAlias(pks[0])).append(\" IN (\");\n+        for (int i = start; i < end && _page[i] != null; i++) {\n+            if (i > start)\n+                buf.append(\", \");\n+            buf.appendValue(mapping.toDataStoreValue(_page[i], pks,\n+                getStore()), pks[0]);\n+        }\n+        buf.append(\")\");\n+    }\n+\n+    /**\n+     * Create OR conditions limiting the results to the curent page.\n+     */\n+    private void orContains(Select sel, SQLBuffer buf, ClassMapping mapping,\n+        Column[] pks, int start, int end) {\n+        String[] aliases = new String[pks.length];\n+        for (int i = 0; i < pks.length; i++)\n+            aliases[i] = sel.getColumnAlias(pks[i]);\n+\n+        Object[] vals;\n+        buf.append(\"(\");\n+        for (int i = start; i < end && _page[i] != null; i++) {\n+            if (i > start)\n+                buf.append(\" OR \");\n+\n+            vals = (Object[]) mapping.toDataStoreValue(_page[i], pks,\n+                getStore());\n+            buf.append(\"(\");\n+            for (int j = 0; j < vals.length; j++) {\n+                if (j > 0)\n+                    buf.append(\" AND \");\n+                buf.append(aliases[j]);\n+                if (vals[j] == null)\n+                    buf.append(\" IS \");\n+                else\n+                    buf.append(\" = \");\n+                buf.appendValue(vals[j], pks[j]);\n+            }\n+            buf.append(\")\");\n+        }\n+        buf.append(\")\");\n+    }\n+}"},{"sha":"44e664bcfdfa8108eaa9284612ad58603c5645d4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","status":"added","additions":177,"deletions":0,"changes":177,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,177 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.kernel.VersionLockManager;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.LockException;\n+\n+/**\n+ * Lock manager that uses exclusive database locks.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+public class PessimisticLockManager\n+    extends VersionLockManager\n+    implements JDBCLockManager {\n+\n+    public static final int LOCK_DATASTORE_ONLY = 1;\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (PessimisticLockManager.class);\n+\n+    private JDBCStore _store;\n+\n+    public PessimisticLockManager() {\n+        setVersionCheckOnReadLock(false);\n+        setVersionUpdateOnWriteLock(false);\n+    }\n+\n+    public void setContext(StoreContext ctx) {\n+        super.setContext(ctx);\n+        _store = (JDBCStore) ctx.getStoreManager().getInnermostDelegate();\n+    }\n+\n+    public boolean selectForUpdate(Select sel, int lockLevel) {\n+        if (lockLevel == LOCK_NONE)\n+            return false;\n+\n+        DBDictionary dict = _store.getDBDictionary();\n+        if (dict.simulateLocking)\n+            return false;\n+        dict.assertSupport(dict.supportsSelectForUpdate,\n+            \"SupportsSelectForUpdate\");\n+\n+        if (!sel.supportsLocking()) {\n+            if (log.isInfoEnabled())\n+                log.info(_loc.get(\"cant-lock-on-load\",\n+                    sel.toSelect(false, null).getSQL()));\n+            return false;\n+        }\n+\n+        ensureStoreManagerTransaction();\n+        return true;\n+    }\n+\n+    public void loadedForUpdate(OpenJPAStateManager sm) {\n+        // we set a low lock level to indicate that we don't need datastore\n+        // locking, but we don't necessarily have a read or write lock\n+        // according to our superclass\n+        if (getLockLevel(sm) == LOCK_NONE)\n+            setLockLevel(sm, LOCK_DATASTORE_ONLY);\n+    }\n+\n+    protected void lockInternal(OpenJPAStateManager sm, int level, int timeout,\n+        Object sdata) {\n+        // we can skip any already-locked instance regardless of level because\n+        // we treat all locks the same (though super doesn't)\n+        if (getLockLevel(sm) == LOCK_NONE) {\n+            // only need to lock if not loaded from locking result\n+            ConnectionInfo info = (ConnectionInfo) sdata;\n+            if (info == null || info.result == null || !info.result.isLocking())\n+                lockRow(sm, timeout);\n+        }\n+        super.lockInternal(sm, level, timeout, sdata);\n+    }\n+\n+    /**\n+     * Lock the specified instance row by issuing a \"SELECT ... FOR UPDATE\"\n+     * statement.\n+     */\n+    private void lockRow(OpenJPAStateManager sm, int timeout) {\n+        // assert that the dictionary supports the \"SELECT ... FOR UPDATE\"\n+        // construct; if not, and we the assertion does not throw an\n+        // exception, then just return without locking\n+        DBDictionary dict = _store.getDBDictionary();\n+        if (dict.simulateLocking)\n+            return;\n+        dict.assertSupport(dict.supportsSelectForUpdate,\n+            \"SupportsSelectForUpdate\");\n+\n+        Object id = sm.getObjectId();\n+        ClassMapping mapping = (ClassMapping) sm.getMetaData();\n+        while (mapping.getJoinablePCSuperclassMapping() != null)\n+            mapping = mapping.getJoinablePCSuperclassMapping();\n+\n+        // select only the PK columns, since we just want to lock\n+        Select select = _store.getSQLFactory().newSelect();\n+        select.select(mapping.getPrimaryKeyColumns());\n+        select.wherePrimaryKey(id, mapping, _store);\n+        SQLBuffer sql = select.toSelect(true, _store.getFetchConfiguration());\n+\n+        ensureStoreManagerTransaction();\n+        Connection conn = _store.getConnection();\n+        PreparedStatement stmnt = null;\n+        ResultSet rs = null;\n+        try {\n+            stmnt = sql.prepareStatement(conn);\n+            if (timeout >= 0 && dict.supportsQueryTimeout) {\n+                if (timeout < 1000) {\n+                    timeout = 1000;\n+                    if (log.isWarnEnabled())\n+                        log.warn(_loc.get(\"millis-query-timeout\"));\n+                }\n+                stmnt.setQueryTimeout(timeout / 1000);\n+            }\n+            rs = stmnt.executeQuery();\n+            if (!rs.next())\n+                throw new LockException(sm.getManagedInstance());\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, dict);\n+        } finally {\n+            if (stmnt != null)\n+                try {\n+                    stmnt.close();\n+                } catch (SQLException se) {\n+                }\n+            if (rs != null)\n+                try {\n+                    rs.close();\n+                } catch (SQLException se) {\n+                }\n+            try {\n+                conn.close();\n+            } catch (SQLException se) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Enforce that we have an actual transaction in progress so that we can\n+     * start locking. The transaction should already be begun when using a\n+     * datastore transaction; this will just be used if we are locking in\n+     * optimistic mode.\n+     */\n+    private void ensureStoreManagerTransaction() {\n+        if (!_store.getContext().isStoreActive()) {\n+            _store.getContext().beginStore();\n+            if (log.isInfoEnabled())\n+                log.info(_loc.get(\"start-trans-for-lock\"));\n+        }\n+    }\n+}"},{"sha":"51c91af507080fe261ff900c30e403383fc6a60a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManager.java","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.util.Collection;\n+\n+import org.apache.openjpa.jdbc.sql.RowImpl;\n+\n+/**\n+ * Manages prepared statement execution.\n+ *\n+ * @author Abe White\n+ */\n+public interface PreparedStatementManager {\n+\n+    /**\n+     * Return the exceptions encountered during all flushes.\n+     */\n+    public Collection getExceptions();\n+\n+    /**\n+     * Flush the given row.\n+     */\n+    public void flush(RowImpl row);\n+\n+    /**\n+     * This method must be called after the last row has been\n+     * flushed, to flush any remaining statements.\n+     */\n+    public void flush();\n+}"},{"sha":"dfe1ca954382093f0a2ef733605d9b37389f36b7","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java","status":"added","additions":129,"deletions":0,"changes":129,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.Row;\n+import org.apache.openjpa.jdbc.sql.RowImpl;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.OptimisticException;\n+\n+/**\n+ * Basic prepared statement manager implementation.\n+ *\n+ * @author Abe White\n+ */\n+class PreparedStatementManagerImpl\n+    implements PreparedStatementManager {\n+\n+    private final static Localizer _loc = Localizer.forPackage\n+        (PreparedStatementManagerImpl.class);\n+\n+    private final JDBCStore _store;\n+    private final Connection _conn;\n+    private final DBDictionary _dict;\n+\n+    // track exceptions\n+    private final Collection _exceptions = new LinkedList();\n+\n+    /**\n+     * Constructor. Supply connection.\n+     */\n+    public PreparedStatementManagerImpl(JDBCStore store, Connection conn) {\n+        _store = store;\n+        _dict = store.getDBDictionary();\n+        _conn = conn;\n+    }\n+\n+    public Collection getExceptions() {\n+        return _exceptions;\n+    }\n+\n+    public void flush(RowImpl row) {\n+        try {\n+            flushInternal(row);\n+        } catch (SQLException se) {\n+            _exceptions.add(SQLExceptions.getStore(se, _dict));\n+        } catch (OpenJPAException ke) {\n+            _exceptions.add(ke);\n+        }\n+    }\n+\n+    /**\n+     * Flush the given row.\n+     */\n+    private void flushInternal(RowImpl row)\n+        throws SQLException {\n+        // can't batch rows with auto-inc columns\n+        Column[] autoAssign = null;\n+        if (row.getAction() == Row.ACTION_INSERT)\n+            autoAssign = row.getTable().getAutoAssignedColumns();\n+\n+        // prepare statement\n+        String sql = row.getSQL(_dict);\n+        PreparedStatement stmnt = _conn.prepareStatement(sql);\n+\n+        // setup parameters and execute statement\n+        row.flush(stmnt, _dict, _store);\n+        try {\n+            int count = stmnt.executeUpdate();\n+            if (count != 1) {\n+                Object failed = row.getFailedObject();\n+                if (failed != null)\n+                    _exceptions.add(new OptimisticException(failed));\n+                else if (row.getAction() == Row.ACTION_INSERT)\n+                    throw new SQLException(_loc.get\n+                        (\"update-failed-no-failed-obj\", String.valueOf(count),\n+                            sql));\n+            }\n+        }\n+        catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, row.getFailedObject(), _dict);\n+        } finally {\n+            try {\n+                stmnt.close();\n+            } catch (SQLException se) {\n+            }\n+        }\n+\n+        // set auto assign values\n+        if (autoAssign != null && autoAssign.length > 0\n+            && row.getPrimaryKey() != null) {\n+            OpenJPAStateManager sm = row.getPrimaryKey();\n+            ClassMapping mapping = (ClassMapping) sm.getMetaData();\n+            Object val;\n+            for (int i = 0; i < autoAssign.length; i++) {\n+                val = _dict.getGeneratedKey(autoAssign[i], _conn);\n+                mapping.assertJoinable(autoAssign[i]).setAutoAssignedValue\n+                    (sm, _store, autoAssign[i], val);\n+            }\n+        }\n+    }\n+\n+    public void flush() {\n+    }\n+}"},{"sha":"dac2a40906997fabc6f6eb039940b9769cbdcc2f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ProjectionResultObjectProvider.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ProjectionResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ProjectionResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ProjectionResultObjectProvider.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import org.apache.openjpa.jdbc.kernel.exps.Val;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SelectExecutor;\n+import org.apache.openjpa.kernel.exps.QueryExpressions;\n+\n+/**\n+ * Object provider implementation wrapped around a projection select.\n+ *\n+ * @author Abe White\n+ */\n+class ProjectionResultObjectProvider\n+    extends SelectResultObjectProvider {\n+\n+    private final QueryExpressions[] _exps;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param sel the select to execute\n+     * @param store the store manager to delegate loading to\n+     * @param fetch the fetch configuration\n+     * @param exps the query expressions\n+     */\n+    public ProjectionResultObjectProvider(SelectExecutor sel, JDBCStore store,\n+        JDBCFetchState fetchState, QueryExpressions exps) {\n+        this(sel, store, fetchState, new QueryExpressions[]{ exps });\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param sel the select to execute\n+     * @param store the store manager to delegate loading to\n+     * @param fetch the fetch configuration\n+     * @param exps the query expressions\n+     */\n+    public ProjectionResultObjectProvider(SelectExecutor sel, JDBCStore store,\n+        JDBCFetchState fetchState, QueryExpressions[] exps) {\n+        super(sel, store, fetchState);\n+        _exps = exps;\n+    }\n+\n+    public Object getResultObject()\n+        throws Exception {\n+        Result res = getResult();\n+        int idx = res.indexOf();\n+        Object[] arr = new Object[_exps[idx].projections.length];\n+        for (int i = 0; i < _exps[idx].projections.length; i++)\n+            arr[i] = ((Val) _exps[idx].projections[i]).load(res, getStore(),\n+                getFetchState());\n+        return arr;\n+    }\n+}"},{"sha":"ca326ce992ec30ba5c73191e4e82771a0ff7b9f5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLProjectionResultObjectProvider.java","status":"added","additions":129,"deletions":0,"changes":129,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLProjectionResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLProjectionResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLProjectionResultObjectProvider.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.sql.ResultSetResult;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.kernel.ResultPacker;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.util.StoreException;\n+import org.apache.openjpa.util.UnsupportedException;\n+import serp.util.Numbers;\n+\n+/**\n+ * Provides all column data in a {@link ResultSet}.\n+ *\n+ * @author Abe White\n+ */\n+class SQLProjectionResultObjectProvider\n+    implements ResultObjectProvider {\n+\n+    private final JDBCStore _store;\n+    private final JDBCFetchConfiguration _fetch;\n+    private final ResultSetResult _res;\n+    private final ResultPacker _packer;\n+    private final int _cols;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param res the result data\n+     * @param cls the result class; may be null for the default\n+     */\n+    public SQLProjectionResultObjectProvider(JDBCStore store,\n+        JDBCFetchConfiguration fetch, ResultSetResult res, Class cls)\n+        throws SQLException {\n+        _store = store;\n+        _fetch = fetch;\n+\n+        ResultSetMetaData meta = res.getResultSet().getMetaData();\n+        _res = res;\n+        _cols = meta.getColumnCount();\n+\n+        if (cls != null) {\n+            String[] aliases = new String[_cols];\n+            for (int i = 0; i < _cols; i++)\n+                aliases[i] = meta.getColumnLabel(i + 1);\n+            _packer = new ResultPacker(null, aliases, cls);\n+        } else\n+            _packer = null;\n+    }\n+\n+    public boolean supportsRandomAccess() {\n+        try {\n+            return _res.supportsRandomAccess();\n+        } catch (Throwable t) {\n+            return false;\n+        }\n+    }\n+\n+    public void open() {\n+    }\n+\n+    public Object getResultObject()\n+        throws SQLException {\n+        if (_cols == 1) {\n+            Object val = _res.getObject(Numbers.valueOf(1),\n+                JavaSQLTypes.JDBC_DEFAULT, null);\n+            return (_packer == null) ? val : _packer.pack(val);\n+        }\n+\n+        Object[] vals = new Object[_cols];\n+        Integer index;\n+        for (int i = 0; i < vals.length; i++)\n+            vals[i] = _res.getObject(Numbers.valueOf(i + 1),\n+                JavaSQLTypes.JDBC_DEFAULT, null);\n+        return (_packer == null) ? vals : _packer.pack(vals);\n+    }\n+\n+    public boolean next()\n+        throws SQLException {\n+        return _res.next();\n+    }\n+\n+    public boolean absolute(int pos)\n+        throws SQLException {\n+        return _res.absolute(pos);\n+    }\n+\n+    public int size()\n+        throws SQLException {\n+        if (_fetch.getLRSSize() == LRSSizes.SIZE_UNKNOWN\n+            || !supportsRandomAccess())\n+            return Integer.MAX_VALUE;\n+        return _res.size();\n+    }\n+\n+    public void reset() {\n+        throw new UnsupportedException();\n+    }\n+\n+    public void close() {\n+        _res.close();\n+    }\n+\n+    public void handleCheckedException(Exception e) {\n+        if (e instanceof SQLException)\n+            throw SQLExceptions.getStore((SQLException) e,\n+                _store.getDBDictionary());\n+        throw new StoreException(e);\n+    }\n+}"},{"sha":"bbc0e523a5c02c4c50c75261b9e2bfd28b30981b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java","status":"added","additions":263,"deletions":0,"changes":263,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.io.IOException;\n+import java.io.StreamTokenizer;\n+import java.io.StringReader;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.MappingRepository;\n+import org.apache.openjpa.jdbc.meta.QueryResultMapping;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.ResultSetResult;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.kernel.AbstractStoreQuery;\n+import org.apache.openjpa.kernel.QueryContext;\n+import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.lib.rop.RangeResultObjectProvider;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * A SQL query.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class SQLStoreQuery\n+    extends AbstractStoreQuery {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (SQLStoreQuery.class);\n+\n+    private transient final JDBCStore _store;\n+\n+    /**\n+     * Construct a query managed by the given context.\n+     */\n+    public SQLStoreQuery(JDBCStore store) {\n+        _store = store;\n+    }\n+\n+    public JDBCStore getStore() {\n+        return _store;\n+    }\n+\n+    /**\n+     * Utility method to substitute '?num' for parameters in the given SQL\n+     * statement, and re-order the <code>params</code> array to match\n+     * the order of the specified parameters.\n+     */\n+    private static String substituteParams(String sql, List params)\n+        throws IOException {\n+        // if there's no \"?1\" positional parameter, then we don't need to\n+        // perform the parsing process\n+        if (sql.indexOf(\"?1\") == -1)\n+            return sql;\n+\n+        List paramOrder = new ArrayList();\n+        StreamTokenizer tok = new StreamTokenizer(new StringReader(sql));\n+        tok.resetSyntax();\n+        tok.quoteChar('\\'');\n+        tok.wordChars('0', '9');\n+        tok.wordChars('?', '?');\n+\n+        StringBuffer buf = new StringBuffer(sql.length());\n+        for (int ttype; (ttype = tok.nextToken()) != StreamTokenizer.TT_EOF;) {\n+            switch (ttype) {\n+                case StreamTokenizer.TT_WORD:\n+                    // a token is a positional parameter if it starts with\n+                    // a \"?\" and the rest of the token are all numbers\n+                    if (tok.sval.startsWith(\"?\") && tok.sval.length() > 1 &&\n+                        tok.sval.substring(1).indexOf(\"?\") == -1) {\n+                        buf.append(\"?\");\n+                        paramOrder.add(Integer.valueOf(tok.sval.substring(1)));\n+                    } else\n+                        buf.append(tok.sval);\n+                    break;\n+                case'\\'':\n+                    buf.append('\\'');\n+                    if (tok.sval != null) {\n+                        buf.append(tok.sval);\n+                        buf.append('\\'');\n+                    }\n+                    break;\n+                default:\n+                    buf.append((char) ttype);\n+            }\n+        }\n+\n+        // now go through the paramOrder list and re-order the params array\n+        List translated = new ArrayList();\n+        for (Iterator i = paramOrder.iterator(); i.hasNext();) {\n+            int index = ((Number) i.next()).intValue() - 1;\n+            if (index >= params.size())\n+                throw new UserException(_loc.get(\"sqlquery-missing-params\",\n+                    sql, String.valueOf(index), params));\n+            translated.add(params.get(index));\n+        }\n+\n+        // transfer the translated list into the original params list\n+        params.clear();\n+        params.addAll(translated);\n+        return buf.toString();\n+    }\n+\n+    public boolean supportsParameterDeclarations() {\n+        return false;\n+    }\n+\n+    public boolean supportsDataStoreExecution() {\n+        return true;\n+    }\n+\n+    public Executor newDataStoreExecutor(ClassMetaData meta,\n+        boolean subclasses) {\n+        return new SQLExecutor(this, meta);\n+    }\n+\n+    public boolean requiresCandidateType() {\n+        return false;\n+    }\n+\n+    public boolean requiresParameterDeclarations() {\n+        return false;\n+    }\n+\n+    /**\n+     * Executes the filter as a SQL query.\n+     */\n+    private static class SQLExecutor\n+        extends AbstractExecutor {\n+\n+        private final ClassMetaData _meta;\n+        private final boolean _select;\n+        private final QueryResultMapping _resultMapping;\n+\n+        public SQLExecutor(SQLStoreQuery q, ClassMetaData candidate) {\n+            QueryContext ctx = q.getContext();\n+            String resultMapping = ctx.getResultMappingName();\n+            if (resultMapping == null)\n+                _resultMapping = null;\n+            else {\n+                ClassLoader envLoader = ctx.getStoreContext().getClassLoader();\n+                MappingRepository repos = q.getStore().getConfiguration().\n+                    getMappingRepository();\n+                _resultMapping = repos.getQueryResultMapping\n+                    (ctx.getResultMappingScope(), resultMapping, envLoader,\n+                        true);\n+            }\n+            _meta = candidate;\n+\n+            String sql = ctx.getQueryString();\n+            if (sql != null)\n+                sql = sql.trim();\n+            if (sql == null || sql.length() == 0)\n+                throw new UserException(_loc.get(\"no-sql\"));\n+            _select = sql.length() > 6\n+                && sql.substring(0, 6).equalsIgnoreCase(\"select\");\n+        }\n+\n+        public ResultObjectProvider executeQuery(StoreQuery q,\n+            Object[] params, boolean lrs, long startIdx, long endIdx) {\n+            JDBCStore store = ((SQLStoreQuery) q).getStore();\n+            DBDictionary dict = store.getDBDictionary();\n+            String sql = q.getContext().getQueryString();\n+\n+            List paramList;\n+            if (params.length > 0) {\n+                paramList = new ArrayList(Arrays.asList(params));\n+                try {\n+                    sql = substituteParams(sql, paramList);\n+                } catch (IOException ioe) {\n+                    throw new UserException(ioe);\n+                }\n+            } else\n+                paramList = Collections.EMPTY_LIST;\n+\n+            SQLBuffer buf = new SQLBuffer(dict).append(sql);\n+            Connection conn = store.getConnection();\n+            JDBCFetchConfiguration fetch = (JDBCFetchConfiguration)\n+                q.getContext().getFetchConfiguration();\n+\n+            ResultObjectProvider rop;\n+            PreparedStatement stmnt = null;\n+            try {\n+                // use the right method depending on sel vs. proc, lrs setting\n+                if (_select && !lrs)\n+                    stmnt = buf.prepareStatement(conn);\n+                else if (_select)\n+                    stmnt = buf.prepareStatement(conn, fetch, -1, -1);\n+                else if (!lrs)\n+                    stmnt = buf.prepareCall(conn);\n+                else\n+                    stmnt = buf.prepareCall(conn, fetch, -1, -1);\n+\n+                int index = 0;\n+                for (Iterator i = paramList.iterator(); i.hasNext();)\n+                    dict.setUnknown(stmnt, ++index, i.next(), null);\n+\n+                ResultSetResult res = new ResultSetResult(conn, stmnt,\n+                    stmnt.executeQuery(), store);\n+                if (_resultMapping != null)\n+                    rop = new MappedQueryResultObjectProvider(_resultMapping,\n+                        store, fetch, res);\n+                else if (q.getContext().getCandidateType() != null)\n+                    rop = new GenericResultObjectProvider((ClassMapping) _meta,\n+                        store, fetch, res);\n+                else\n+                    rop = new SQLProjectionResultObjectProvider(store, fetch,\n+                        res, q.getContext().getResultType());\n+            } catch (SQLException se) {\n+                if (stmnt != null)\n+                    try {\n+                        stmnt.close();\n+                    } catch (SQLException se2) {\n+                    }\n+                try {\n+                    conn.close();\n+                } catch (SQLException se2) {\n+                }\n+                throw SQLExceptions.getStore(se, dict);\n+            }\n+\n+            if (startIdx != 0 || endIdx != Long.MAX_VALUE)\n+                rop = new RangeResultObjectProvider(rop, startIdx, endIdx);\n+            return rop;\n+        }\n+\n+        public String[] getDataStoreActions(StoreQuery q, Object[] params,\n+            long startIdx, long endIdx) {\n+            return new String[]{ q.getContext().getQueryString() };\n+        }\n+\n+        public boolean isPacking(StoreQuery q) {\n+            return q.getContext().getCandidateType() == null;\n+        }\n+    }\n+}"},{"sha":"284804d9f8ccd87d545df7f7c28a95a34de5ab4b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SelectResultObjectProvider.java","status":"added","additions":166,"deletions":0,"changes":166,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SelectResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SelectResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SelectResultObjectProvider.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.jdbc.sql.SelectExecutor;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.util.StoreException;\n+\n+/**\n+ * Abstract provider implementation wrapped around a {@link Select}.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public abstract class SelectResultObjectProvider\n+    implements ResultObjectProvider {\n+\n+    private final SelectExecutor _sel;\n+    private final JDBCStore _store;\n+    private final JDBCFetchConfiguration _fetch;\n+    private final JDBCFetchState _fetchState;\n+    private Result _res = null;\n+    private int _size = -1;\n+    private Boolean _ra = null;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param sel the select to execute\n+     * @param store the store to delegate loading to\n+     * @param fetch the fetch configuration, or null for the default\n+     */\n+    public SelectResultObjectProvider(SelectExecutor sel, JDBCStore store,\n+        JDBCFetchState fetchState) {\n+        _sel = sel;\n+        _store = store;\n+//\t\tif (fetch == null)\n+//\t\t\t_fetch = store.getFetchConfiguration ();\n+//\t\telse\n+//\t\t\t_fetch = fetch;\n+        _fetchState = fetchState;\n+        _fetch = fetchState.getJDBCFetchConfiguration();\n+    }\n+\n+    public SelectExecutor getSelect() {\n+        return _sel;\n+    }\n+\n+    public JDBCStore getStore() {\n+        return _store;\n+    }\n+\n+    public JDBCFetchConfiguration getFetchConfiguration() {\n+        return _fetch;\n+    }\n+\n+    public JDBCFetchState getFetchState() {\n+        return _fetchState;\n+    }\n+\n+    public Result getResult() {\n+        return _res;\n+    }\n+\n+    public boolean supportsRandomAccess() {\n+        if (_ra == null) {\n+            boolean ra;\n+            if (_res != null) {\n+                try {\n+                    ra = _res.supportsRandomAccess();\n+                } catch (SQLException se) {\n+                    throw SQLExceptions.getStore(se, _store.getDBDictionary());\n+                }\n+            } else\n+                ra = _sel.supportsRandomAccess(_fetch.getReadLockLevel() > 0);\n+            _ra = (ra) ? Boolean.TRUE : Boolean.FALSE;\n+        }\n+        return _ra.booleanValue();\n+    }\n+\n+    public void open()\n+        throws SQLException {\n+        _res = _sel.execute(_store, _fetch);\n+    }\n+\n+    public boolean next()\n+        throws SQLException {\n+        return _res.next();\n+    }\n+\n+    public boolean absolute(int pos)\n+        throws SQLException {\n+        return _res.absolute(pos);\n+    }\n+\n+    public int size()\n+        throws SQLException {\n+        if (_size == -1) {\n+            // if res is null, don't cache size\n+            if (_res == null)\n+                return Integer.MAX_VALUE;\n+\n+            switch (_fetch.getLRSSize()) {\n+                case LRSSizes.SIZE_UNKNOWN:\n+                    _size = Integer.MAX_VALUE;\n+                    break;\n+                case LRSSizes.SIZE_LAST:\n+                    if (supportsRandomAccess())\n+                        _size = _res.size();\n+                    else\n+                        _size = Integer.MAX_VALUE;\n+                    break;\n+                default: // query\n+                    _size = _sel.getCount(_store);\n+            }\n+        }\n+        return _size;\n+    }\n+\n+    /**\n+     * Allow subclasses that know the size to set it; otherwise we calculate\n+     * it internally.\n+     */\n+    protected void setSize(int size) {\n+        if (_size == -1)\n+            _size = size;\n+    }\n+\n+    public void reset()\n+        throws SQLException {\n+        close();\n+        open();\n+    }\n+\n+    public void close() {\n+        if (_res != null) {\n+            _res.close();\n+            _res = null;\n+        }\n+    }\n+\n+    public void handleCheckedException(Exception e) {\n+        if (e instanceof SQLException)\n+            throw SQLExceptions.getStore((SQLException) e,\n+                _store.getDBDictionary());\n+        throw new StoreException(e);\n+    }\n+}"},{"sha":"043dbc9b25e22797d4a28feee1a4581a759945b9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java","status":"added","additions":625,"deletions":0,"changes":625,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,625 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.PrimaryKey;\n+import org.apache.openjpa.jdbc.schema.Schema;\n+import org.apache.openjpa.jdbc.schema.SchemaGroup;\n+import org.apache.openjpa.jdbc.schema.SchemaTool;\n+import org.apache.openjpa.jdbc.schema.Schemas;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Options;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.InvalidStateException;\n+import serp.util.Numbers;\n+import serp.util.Strings;\n+\n+////////////////////////////////////////////////////////////\n+// NOTE: Do not change property names; see SequenceMetaData\n+// and SequenceMapping for standard property names.\n+////////////////////////////////////////////////////////////\n+\n+/**\n+ * {@link JDBCSeq} implementation that uses a database table\n+ * for sequence number generation. This base implementation uses a single\n+ * row for a global sequence number.\n+ *\n+ * @author Abe White\n+ */\n+public class TableJDBCSeq\n+    extends AbstractJDBCSeq\n+    implements Configurable {\n+\n+    public static final String ACTION_DROP = \"drop\";\n+    public static final String ACTION_ADD = \"add\";\n+    public static final String ACTION_GET = \"get\";\n+    public static final String ACTION_SET = \"set\";\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (TableJDBCSeq.class);\n+\n+    private JDBCConfiguration _conf = null;\n+    private Log _log = null;\n+    private int _alloc = 50;\n+    private final Status _stat = new Status();\n+\n+    private String _table = \"OPENJPA_SEQUENCE_TABLE\";\n+    private String _seqColumnName = \"SEQUENCE_VALUE\";\n+    private String _pkColumnName = \"ID\";\n+\n+    private Column _seqColumn = null;\n+    private Column _pkColumn = null;\n+\n+    /**\n+     * The sequence table name. Defaults to <code>OPENJPA_SEQUENCE_TABLE</code>.\n+     * By default, the table will be placed in the first schema listed in your\n+     * <code>org.apache.openjpa.jdbc.Schemas</code> property, or in the default schema if\n+     * the property is not given. If you specify a table name in the form\n+     * <code>&lt;schema&gt;.&lt;table&gt;</code>, then the given schema\n+     * will be used.\n+     */\n+    public String getTable() {\n+        return _table;\n+    }\n+\n+    /**\n+     * The sequence table name. Defaults to <code>OPENJPA_SEQUENCE_TABLE</code>.\n+     * By default, the table will be placed in the first schema listed in your\n+     * <code>org.apache.openjpa.jdbc.Schemas</code> property, or in the default schema if\n+     * the property is not given. If you specify a table name in the form\n+     * <code>&lt;schema&gt;.&lt;table&gt;</code>, then the given schema\n+     * will be used.\n+     */\n+    public void setTable(String name) {\n+        _table = name;\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #setTable}. Retained for\n+     * backwards-compatibility\twith auto-configuration.\n+     */\n+    public void setTableName(String name) {\n+        setTable(name);\n+    }\n+\n+    /**\n+     * The name of the column that holds the sequence value. Defaults\n+     * to <code>SEQUENCE_VALUE</code>.\n+     */\n+    public String getSequenceColumn() {\n+        return _seqColumnName;\n+    }\n+\n+    /**\n+     * The name of the column that holds the sequence value. Defaults\n+     * to <code>SEQUENCE_VALUE</code>.\n+     */\n+    public void setSequenceColumn(String sequenceColumn) {\n+        _seqColumnName = sequenceColumn;\n+    }\n+\n+    /**\n+     * The name of the table's primary key column. Defaults to\n+     * <code>ID</code>.\n+     */\n+    public String getPrimaryKeyColumn() {\n+        return _pkColumnName;\n+    }\n+\n+    /**\n+     * The name of the table's primary key column. Defaults to\n+     * <code>ID</code>.\n+     */\n+    public void setPrimaryKeyColumn(String primaryKeyColumn) {\n+        _pkColumnName = primaryKeyColumn;\n+    }\n+\n+    /**\n+     * Return the number of sequences to allocate for each update of the\n+     * sequence table. Sequence numbers will be grabbed in blocks of this\n+     * value to reduce the number of transactions that must be performed on\n+     * the sequence table.\n+     */\n+    public int getAllocate() {\n+        return _alloc;\n+    }\n+\n+    /**\n+     * Return the number of sequences to allocate for each update of the\n+     * sequence table. Sequence numbers will be grabbed in blocks of this\n+     * value to reduce the number of transactions that must be performed on\n+     * the sequence table.\n+     */\n+    public void setAllocate(int alloc) {\n+        _alloc = alloc;\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #setAllocate}. Retained for backwards\n+     * compatibility of auto-configuration.\n+     */\n+    public void setIncrement(int inc) {\n+        setAllocate(inc);\n+    }\n+\n+    public JDBCConfiguration getConfiguration() {\n+        return _conf;\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+        _conf = (JDBCConfiguration) conf;\n+        _log = _conf.getLog(JDBCConfiguration.LOG_RUNTIME);\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+        buildTable();\n+    }\n+\n+    public void addSchema(ClassMapping mapping, SchemaGroup group) {\n+        // table already exists?\n+        if (group.isKnownTable(_table))\n+            return;\n+\n+        String schemaName = Strings.getPackageName(_table);\n+        if (schemaName.length() == 0)\n+            schemaName = Schemas.getNewTableSchema(_conf);\n+\n+        // create table in this group\n+        Schema schema = group.getSchema(schemaName);\n+        if (schema == null)\n+            schema = group.addSchema(schemaName);\n+        schema.importTable(_pkColumn.getTable());\n+    }\n+\n+    protected Object nextInternal(JDBCStore store, ClassMapping mapping)\n+        throws Exception {\n+        // if needed, grab the next handful of ids\n+        Status stat = getStatus(mapping);\n+        if (stat == null)\n+            throw new InvalidStateException(_loc.get(\"bad-seq-type\",\n+                getClass(), mapping));\n+\n+        // make sure seq is at least 1, since autoassigned ids of 0 can\n+        // conflict with uninitialized values\n+        stat.seq = Math.max(stat.seq, 1);\n+        if (stat.seq >= stat.max)\n+            allocateSequence(store, mapping, stat, _alloc, true);\n+        return Numbers.valueOf(stat.seq++);\n+    }\n+\n+    protected Object currentInternal(JDBCStore store, ClassMapping mapping)\n+        throws Exception {\n+        if (current == null) {\n+            long cur = getSequence(mapping, getConnection(store));\n+            if (cur != -1)\n+                current = Numbers.valueOf(cur);\n+        }\n+        return super.currentInternal(store, mapping);\n+    }\n+\n+    protected void allocateInternal(int count, JDBCStore store,\n+        ClassMapping mapping)\n+        throws SQLException {\n+        Status stat = getStatus(mapping);\n+        if (stat != null && stat.max - stat.seq < count)\n+            allocateSequence(store, mapping, stat,\n+                count - (int) (stat.max - stat.seq), false);\n+    }\n+\n+    /**\n+     * Return the appropriate status object for the given class, or null\n+     * if cannot handle the given class. The mapping may be null.\n+     */\n+    protected Status getStatus(ClassMapping mapping) {\n+        return _stat;\n+    }\n+\n+    /**\n+     * Add the primary key column to the given table and return it.\n+     */\n+    protected Column addPrimaryKeyColumn(Table table) {\n+        DBDictionary dict = _conf.getDBDictionaryInstance();\n+        Column pkColumn = table.addColumn(dict.getValidColumnName\n+            (getPrimaryKeyColumn(), table));\n+        pkColumn.setType(dict.getPreferredType(Types.TINYINT));\n+        pkColumn.setJavaType(JavaTypes.INT);\n+        return pkColumn;\n+    }\n+\n+    /**\n+     * Return the primary key value for the given class.\n+     */\n+    protected Object getPrimaryKey(ClassMapping mapping) {\n+        return Numbers.valueOf(0);\n+    }\n+\n+    /**\n+     * Creates the object-level representation of the sequence table.\n+     */\n+    private void buildTable() {\n+        String tableName = Strings.getClassName(_table);\n+        String schemaName = Strings.getPackageName(_table);\n+        if (schemaName.length() == 0)\n+            schemaName = Schemas.getNewTableSchema(_conf);\n+\n+        SchemaGroup group = new SchemaGroup();\n+        Schema schema = group.addSchema(schemaName);\n+\n+        Table table = schema.addTable(tableName);\n+        _pkColumn = addPrimaryKeyColumn(table);\n+        PrimaryKey pk = table.addPrimaryKey();\n+        pk.addColumn(_pkColumn);\n+\n+        DBDictionary dict = _conf.getDBDictionaryInstance();\n+        _seqColumn = table.addColumn(dict.getValidColumnName\n+            (_seqColumnName, table));\n+        _seqColumn.setType(dict.getPreferredType(Types.BIGINT));\n+        _seqColumn.setJavaType(JavaTypes.LONG);\n+    }\n+\n+    /**\n+     * Updates the max available sequence value.\n+     */\n+    private void allocateSequence(JDBCStore store, ClassMapping mapping,\n+        Status stat, int alloc, boolean updateStatSeq) {\n+        try {\n+            // if the update fails, probably because row doesn't exist yet\n+            if (!setSequence(mapping, stat, alloc, updateStatSeq,\n+                getConnection(store))) {\n+                closeConnection();\n+\n+                // possible that we might get errors when inserting if\n+                // another thread/process is inserting same pk at same time\n+                SQLException err = null;\n+                Connection conn = _conf.getDataSource2(store.getContext()).\n+                    getConnection();\n+                try {\n+                    insertSequence(mapping, conn);\n+                } catch (SQLException se) {\n+                    err = se;\n+                } finally {\n+                    try {\n+                        conn.close();\n+                    } catch (SQLException se) {\n+                    }\n+                }\n+\n+                // now we should be able to update...\n+                if (!setSequence(mapping, stat, alloc, updateStatSeq,\n+                    getConnection(store)))\n+                    throw(err != null) ? err : new SQLException(_loc.get\n+                        (\"no-seq-row\", mapping, _table));\n+            }\n+        }\n+        catch (SQLException se2) {\n+            throw SQLExceptions.getStore(_loc.get(\"bad-seq-up\", _table),\n+                se2, _conf.getDBDictionaryInstance());\n+        }\n+    }\n+\n+    /**\n+     * Inserts the initial sequence information into the database, if any.\n+     */\n+    private void insertSequence(ClassMapping mapping, Connection conn)\n+        throws SQLException {\n+        if (_log.isTraceEnabled())\n+            _log.trace(_loc.get(\"insert-seq\"));\n+\n+        Object pk = getPrimaryKey(mapping);\n+        if (pk == null)\n+            throw new InvalidStateException(_loc.get(\"bad-seq-type\",\n+                getClass(), mapping));\n+\n+        DBDictionary dict = _conf.getDBDictionaryInstance();\n+        SQLBuffer insert = new SQLBuffer(dict).append(\"INSERT INTO \").\n+            append(_pkColumn.getTable()).append(\" (\").\n+            append(_pkColumn).append(\", \").append(_seqColumn).\n+            append(\") VALUES (\").\n+            appendValue(pk, _pkColumn).append(\", \").\n+            appendValue(Numbers.valueOf(1), _seqColumn).append(\")\");\n+\n+        boolean wasAuto = conn.getAutoCommit();\n+        if (!wasAuto)\n+            conn.setAutoCommit(true);\n+\n+        PreparedStatement stmnt = null;\n+        try {\n+            stmnt = insert.prepareStatement(conn);\n+            stmnt.executeUpdate();\n+        } finally {\n+            if (stmnt != null)\n+                try {\n+                    stmnt.close();\n+                } catch (SQLException se) {\n+                }\n+            if (!wasAuto)\n+                conn.setAutoCommit(false);\n+        }\n+    }\n+\n+    /**\n+     * Return the current sequence value, or -1 if unattainable.\n+     */\n+    protected long getSequence(ClassMapping mapping, Connection conn)\n+        throws SQLException {\n+        if (_log.isTraceEnabled())\n+            _log.trace(_loc.get(\"get-seq\"));\n+\n+        Object pk = getPrimaryKey(mapping);\n+        if (pk == null)\n+            return -1;\n+\n+        DBDictionary dict = _conf.getDBDictionaryInstance();\n+        SQLBuffer sel = new SQLBuffer(dict).append(_seqColumn);\n+        SQLBuffer where = new SQLBuffer(dict).append(_pkColumn).append(\" = \").\n+            appendValue(pk, _pkColumn);\n+        SQLBuffer tables = new SQLBuffer(dict).append(_seqColumn.getTable());\n+\n+        SQLBuffer select = dict.toSelect(sel, null, tables, where, null,\n+            null, null, false, dict.supportsSelectForUpdate, 0, Long.MAX_VALUE);\n+\n+        PreparedStatement stmnt = select.prepareStatement(conn);\n+        ResultSet rs = null;\n+        try {\n+            rs = stmnt.executeQuery();\n+            if (!rs.next())\n+                return -1;\n+            return dict.getLong(rs, 1);\n+        } finally {\n+            if (rs != null)\n+                try {\n+                    rs.close();\n+                } catch (SQLException se) {\n+                }\n+            try {\n+                stmnt.close();\n+            } catch (SQLException se) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Grabs the next handful of sequence numbers.\n+     *\n+     * @return true if the sequence was updated, false if no sequence\n+     * row existed for this mapping\n+     */\n+    protected boolean setSequence(ClassMapping mapping, Status stat, int inc,\n+        boolean updateStatSeq, Connection conn)\n+        throws SQLException {\n+        if (_log.isTraceEnabled())\n+            _log.trace(_loc.get(\"update-seq\"));\n+\n+        Object pk = getPrimaryKey(mapping);\n+        if (pk == null)\n+            throw new InvalidStateException(_loc.get(\"bad-seq-type\",\n+                getClass(), mapping));\n+\n+        DBDictionary dict = _conf.getDBDictionaryInstance();\n+        SQLBuffer where = new SQLBuffer(dict).append(_pkColumn).append(\" = \").\n+            appendValue(pk, _pkColumn);\n+\n+        // not all databases support locking, so loop until we have a\n+        // successful atomic select/update sequence\n+        long cur = 0;\n+        PreparedStatement stmnt;\n+        ResultSet rs;\n+        SQLBuffer upd;\n+        for (int updates = 0; updates == 0;) {\n+            stmnt = null;\n+            rs = null;\n+            try {\n+                cur = getSequence(mapping, conn);\n+                if (cur == -1)\n+                    return false;\n+\n+                // update the value\n+                upd = new SQLBuffer(dict);\n+                upd.append(\"UPDATE \").append(_seqColumn.getTable()).\n+                    append(\" SET \").append(_seqColumn).append(\" = \").\n+                    appendValue(Numbers.valueOf(cur + inc), _seqColumn).\n+                    append(\" WHERE \").append(where).append(\" AND \").\n+                    append(_seqColumn).append(\" = \").\n+                    appendValue(Numbers.valueOf(cur), _seqColumn);\n+\n+                stmnt = upd.prepareStatement(conn);\n+                updates = stmnt.executeUpdate();\n+            } finally {\n+                if (rs != null)\n+                    try {\n+                        rs.close();\n+                    } catch (SQLException se) {\n+                    }\n+                if (stmnt != null)\n+                    try {\n+                        stmnt.close();\n+                    } catch (SQLException se) {\n+                    }\n+            }\n+        }\n+\n+        // setup new sequence range\n+        if (updateStatSeq)\n+            stat.seq = cur;\n+        stat.max = cur + inc;\n+        return true;\n+    }\n+\n+    /**\n+     * Creates the sequence table in the DB.\n+     */\n+    public void refreshTable()\n+        throws SQLException {\n+        if (_log.isInfoEnabled())\n+            _log.info(_loc.get(\"make-seq-table\"));\n+\n+        // create the table\n+        SchemaTool tool = new SchemaTool(_conf);\n+        tool.setIgnoreErrors(true);\n+        tool.createTable(_pkColumn.getTable());\n+    }\n+\n+    /**\n+     * Drops the sequence table in the DB.\n+     */\n+    public void dropTable()\n+        throws SQLException {\n+        if (_log.isInfoEnabled())\n+            _log.info(_loc.get(\"drop-seq-table\"));\n+\n+        // drop the table\n+        SchemaTool tool = new SchemaTool(_conf);\n+        tool.setIgnoreErrors(true);\n+        tool.dropTable(_pkColumn.getTable());\n+    }\n+\n+    /////////\n+    // Main\n+    /////////\n+\n+    /**\n+     * Usage: java org.apache.openjpa.jdbc.schema.TableJDBCSequence [option]*\n+     * -action/-a &lt;add | drop | get | set&gt; [value]\n+     *  Where the following options are recognized.\n+     * <ul>\n+     * <li><i>-properties/-p &lt;properties file or resource&gt;</i>: The\n+     * path or resource name of a OpenJPA properties file containing\n+     * information such as the license key\tand connection data as\n+     * outlined in {@link JDBCConfiguration}. Optional.</li>\n+     * <li><i>-&lt;property name&gt; &lt;property value&gt;</i>: All bean\n+     * properties of the OpenJPA {@link JDBCConfiguration} can be set by\n+     * using their\tnames and supplying a value. For example:\n+     * <code>-licenseKey adslfja83r3lkadf</code></li>\n+     * </ul>\n+     *  The various actions are as follows.\n+     * <ul>\n+     * <li><i>add</i>: Create the sequence table.</li>\n+     * <li><i>drop</i>: Drop the sequence table.</li>\n+     * <li><i>get</i>: Print the current sequence value.</li>\n+     * <li><i>set</i>: Set the sequence value.</li>\n+     * </ul>\n+     */\n+    public static void main(String[] args)\n+        throws Exception {\n+        Options opts = new Options();\n+        args = opts.setFromCmdLine(args);\n+        JDBCConfiguration conf = new JDBCConfigurationImpl();\n+        try {\n+            if (!run(conf, args, opts))\n+                System.out.println(_loc.get(\"seq-usage\"));\n+        } finally {\n+            conf.close();\n+        }\n+    }\n+\n+    /**\n+     * Run the tool. Returns false if invalid options were given.\n+     */\n+    public static boolean run(JDBCConfiguration conf, String[] args,\n+        Options opts)\n+        throws Exception {\n+        if (opts.containsKey(\"help\") || opts.containsKey(\"-help\"))\n+            return false;\n+\n+        String action = opts.removeProperty(\"action\", \"a\", null);\n+        Configurations.populateConfiguration(conf, opts);\n+        return run(conf, args, action);\n+    }\n+\n+    /**\n+     * Run the tool. Return false if an invalid option was given.\n+     */\n+    public static boolean run(JDBCConfiguration conf, String[] args,\n+        String action)\n+        throws Exception {\n+        if (args.length > 1 || (args.length != 0\n+            && !ACTION_SET.equals(action)))\n+            return false;\n+\n+        TableJDBCSeq seq = new TableJDBCSeq();\n+        String props = Configurations.getProperties(conf.getSequence());\n+        Configurations.configureInstance(seq, conf, props);\n+\n+        if (ACTION_DROP.equals(action))\n+            seq.dropTable();\n+        else if (ACTION_ADD.equals(action))\n+            seq.refreshTable();\n+        else if (ACTION_GET.equals(action) || ACTION_SET.equals(action)) {\n+            Connection conn = conf.getDataSource2(null).getConnection();\n+            try {\n+                long cur = seq.getSequence(null, conn);\n+                if (ACTION_GET.equals(action))\n+                    System.out.println(cur);\n+                else {\n+                    long set;\n+                    if (args.length > 0)\n+                        set = Long.parseLong(args[0]);\n+                    else\n+                        set = cur + seq.getAllocate();\n+                    if (set < cur)\n+                        set = cur;\n+                    else {\n+                        Status stat = seq.getStatus(null);\n+                        seq.setSequence(null, stat, (int) (set - cur), true,\n+                            conn);\n+                        set = stat.seq;\n+                    }\n+                    System.err.println(set);\n+                }\n+            }\n+            catch (NumberFormatException nfe) {\n+                return false;\n+            } finally {\n+                try {\n+                    conn.close();\n+                } catch (SQLException se) {\n+                }\n+            }\n+        } else\n+            return false;\n+        return true;\n+    }\n+\n+    /**\n+     * Helper struct to hold status information.\n+     */\n+    protected static class Status {\n+\n+        public long seq = 1L;\n+        public long max = 0L;\n+    }\n+}"},{"sha":"92526c7986f92ffe26db117c813f8a53b60eff79","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/UpdateManager.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/UpdateManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/UpdateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/UpdateManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.util.Collection;\n+\n+/**\n+ * This interface is used to customize the way that updates are made to\n+ * database records.\n+ *\n+ * @author Abe White\n+ */\n+public interface UpdateManager {\n+\n+    /**\n+     * Whether the store context should maintain the order in which instances\n+     * are dirtied.\n+     */\n+    public boolean orderDirty();\n+\n+    /**\n+     * Flush the given instances to the data store.\n+     *\n+     * @see org.apache.openjpa.kernel.StoreManager#flush\n+     */\n+    public Collection flush(Collection states, JDBCStore store);\n+}"},{"sha":"3155e7c96a51d48d7425632de2a9696cac23cf2c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ValueTableJDBCSeq.java","status":"added","additions":200,"deletions":0,"changes":200,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ValueTableJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ValueTableJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ValueTableJDBCSeq.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.MappingRepository;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Options;\n+import org.apache.openjpa.meta.JavaTypes;\n+\n+////////////////////////////////////////////////////////////\n+// NOTE: Do not change property names; see SequenceMetaData\n+// and SequenceMapping for standard property names.\n+////////////////////////////////////////////////////////////\n+\n+/**\n+ * Specialization of the {@link TableJDBCSeq} that maintains multiple\n+ * sequence counts. Each instance of this class represents one row with\n+ * a known string primary key value, more or less. The table name defaults\n+ * to <code>OPENJPA_SEQUENCES_TABLE</code>.\n+ *\n+ * @author Abe White\n+ */\n+public class ValueTableJDBCSeq\n+    extends TableJDBCSeq {\n+\n+    public static final String PK_VALUE = \"PrimaryKeyValue\";\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ValueTableJDBCSeq.class);\n+\n+    private String _value = \"DEFAULT\";\n+\n+    public ValueTableJDBCSeq() {\n+        setTable(\"OPENJPA_SEQUENCES_TABLE\");\n+    }\n+\n+    /**\n+     * The primary key value for this row. Defaults to <code>DEFAULT</code>.\n+     */\n+    public String getPrimaryKeyValue() {\n+        return _value;\n+    }\n+\n+    /**\n+     * The primary key value for this row. Defaults to <code>DEFAULT</code>.\n+     */\n+    public void setPrimaryKeyValue(String value) {\n+        _value = value;\n+    }\n+\n+    protected Column addPrimaryKeyColumn(Table table) {\n+        DBDictionary dict = getConfiguration().getDBDictionaryInstance();\n+        Column pkColumn = table.addColumn(dict.getValidColumnName\n+            (getPrimaryKeyColumn(), table));\n+        pkColumn.setType(dict.getPreferredType(Types.VARCHAR));\n+        pkColumn.setJavaType(JavaTypes.STRING);\n+        pkColumn.setSize(dict.characterColumnSize);\n+        return pkColumn;\n+    }\n+\n+    protected Object getPrimaryKey(ClassMapping mapping) {\n+        return _value;\n+    }\n+\n+    /////////\n+    // Main\n+    /////////\n+\n+    /**\n+     * Usage: java org.apache.openjpa.jdbc.kernel.ValueTableJDBCSeq [option]*\n+     * -action/-a &lt;add | drop | get | set&gt; [primary key value] [value]\n+     *  Where the following options are recognized.\n+     * <ul>\n+     * <li><i>-properties/-p &lt;properties file or resource&gt;</i>: The\n+     * path or resource name of a OpenJPA properties file containing\n+     * information such as the license key\tand connection data as\n+     * outlined in {@link JDBCConfiguration}. Optional.</li>\n+     * <li><i>-&lt;property name&gt; &lt;property value&gt;</i>: All bean\n+     * properties of the OpenJPA {@link JDBCConfiguration} can be set by\n+     * using their\tnames and supplying a value. For example:\n+     * <code>-licenseKey adslfja83r3lkadf</code></li>\n+     * </ul>\n+     *  The various actions are as follows.\n+     * <ul>\n+     * <li><i>add</i>: Create the sequence table.</li>\n+     * <li><i>drop</i>: Drop the sequence table.</li>\n+     * <li><i>get</i>: Print the current sequence value for the given\n+     * primary key value.</li>\n+     * <li><i>set</i>: Set the sequence value for the given primary key\n+     * value.</li>\n+     * </ul>\n+     */\n+    public static void main(String[] args)\n+        throws Exception {\n+        Options opts = new Options();\n+        args = opts.setFromCmdLine(args);\n+        JDBCConfiguration conf = new JDBCConfigurationImpl();\n+        try {\n+            if (!run(conf, args, opts))\n+                System.out.println(_loc.get(\"clstable-seq-usage\"));\n+        } finally {\n+            conf.close();\n+        }\n+    }\n+\n+    /**\n+     * Run the tool. Returns false if invalid options were given.\n+     */\n+    public static boolean run(JDBCConfiguration conf, String[] args,\n+        Options opts)\n+        throws Exception {\n+        if (opts.containsKey(\"help\") || opts.containsKey(\"-help\"))\n+            return false;\n+\n+        String action = opts.removeProperty(\"action\", \"a\", null);\n+        Configurations.populateConfiguration(conf, opts);\n+        return run(conf, args, action, null, null);\n+    }\n+\n+    /**\n+     * Run the tool. Return false if an invalid option was given.\n+     */\n+    public static boolean run(JDBCConfiguration conf, String[] args,\n+        String action, MappingRepository repos, ClassLoader loader)\n+        throws Exception {\n+        ValueTableJDBCSeq seq = new ValueTableJDBCSeq();\n+        String props = Configurations.getProperties(conf.getSequence());\n+        Configurations.configureInstance(seq, conf, props);\n+\n+        if (ACTION_DROP.equals(action)) {\n+            if (args.length != 0)\n+                return false;\n+            seq.dropTable();\n+        } else if (ACTION_ADD.equals(action)) {\n+            if (args.length != 0)\n+                return false;\n+            seq.refreshTable();\n+        } else if (ACTION_GET.equals(action) || ACTION_SET.equals(action)) {\n+            if (args.length > 0)\n+                seq.setPrimaryKeyValue(args[0]);\n+\n+            Connection conn = conf.getDataSource2(null).getConnection();\n+            try {\n+                long cur = seq.getSequence(null, conn);\n+                if (ACTION_GET.equals(action))\n+                    System.out.println(seq.getPrimaryKeyValue() + \": \" + cur);\n+                else {\n+                    long set;\n+                    if (args.length > 1)\n+                        set = Long.parseLong(args[1]);\n+                    else\n+                        set = cur + seq.getAllocate();\n+                    if (set < cur)\n+                        set = cur;\n+                    else {\n+                        Status stat = seq.getStatus(null);\n+                        seq.setSequence(null, stat, (int) (set - cur), true,\n+                            conn);\n+                        set = stat.seq;\n+                    }\n+                    System.err.println(seq.getPrimaryKeyValue() + \": \" + set);\n+                }\n+            }\n+            catch (NumberFormatException nfe) {\n+                return false;\n+            } finally {\n+                try {\n+                    conn.close();\n+                } catch (SQLException se) {\n+                }\n+            }\n+        } else\n+            return false;\n+        return true;\n+    }\n+}"},{"sha":"ff06a1a0a0cb0af7f45c5b614d828a84740e5991","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Abs.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Abs.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Abs.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Abs.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import org.apache.openjpa.kernel.Filters;\n+\n+/**\n+ * Absolute value.\n+ *\n+ * @author Abe White\n+ */\n+class Abs\n+    extends UnaryOp {\n+\n+    /**\n+     * Constructor. Provide the value to operate on.\n+     */\n+    public Abs(Val val) {\n+        super(val);\n+    }\n+\n+    protected Class getType(Class c) {\n+        Class wrap = Filters.wrap(c);\n+        if (wrap == Integer.class\n+            || wrap == Float.class\n+            || wrap == Double.class\n+            || wrap == Long.class\n+            || wrap == BigDecimal.class\n+            || wrap == BigInteger.class)\n+            return c;\n+        return int.class;\n+    }\n+\n+    protected String getOperator() {\n+        return \"ABS\";\n+    }\n+}\n+"},{"sha":"eeefde3553f1ad18687b57c77ab1376ec057ee30","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Aggregate listener that evaluates to a value.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+abstract class AbstractVal\n+    implements Val {\n+\n+    private static final String TRUE = \"1 = 1\";\n+    private static final String FALSE = \"1 <> 1\";\n+\n+    public void appendIsEmpty(SQLBuffer sql, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        sql.append(FALSE);\n+    }\n+\n+    public void appendIsNotEmpty(SQLBuffer sql, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        sql.append(TRUE);\n+    }\n+\n+    public void appendIsNull(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        appendTo(sql, 0, sel, store, params, fetchState);\n+        sql.append(\" IS \").appendValue(null);\n+    }\n+\n+    public void appendIsNotNull(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        appendTo(sql, 0, sel, store, params, fetchState);\n+        sql.append(\" IS NOT \").appendValue(null);\n+    }\n+\n+    public void appendSize(SQLBuffer sql, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        sql.append(\"1\");\n+    }\n+}\n+"},{"sha":"b24b9fe8ac00e2302cf0129e2b84c1dc86ee5698","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Aggregate.java","status":"added","additions":192,"deletions":0,"changes":192,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Aggregate.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Aggregate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Aggregate.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Aggregate listener that evaluates to a value.\n+ *\n+ * @author Abe White\n+ */\n+class Aggregate\n+    extends AbstractVal\n+    implements Val {\n+\n+    private final JDBCAggregateListener _listener;\n+    private final Val _arg;\n+    private final ClassMapping _candidate;\n+    private Joins _joins = null;\n+    private ClassMetaData _meta = null;\n+    private Class _cast = null;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public Aggregate(JDBCAggregateListener listener, Val arg,\n+        ClassMapping candidate) {\n+        _listener = listener;\n+        _arg = arg;\n+        _candidate = candidate;\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+    }\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    public Class getType() {\n+        if (_cast != null)\n+            return _cast;\n+        return _listener.getType(getArgTypes());\n+    }\n+\n+    private Class[] getArgTypes() {\n+        if (_arg == null)\n+            return null;\n+        if (_arg instanceof Args)\n+            return ((Args) _arg).getTypes();\n+        return new Class[]{ _arg.getType() };\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _cast = type;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        // note that we tell targets and args to extensions that are sql\n+        // paths to go ahead and join to their related object (if any),\n+        // because we assume that, unlike most operations, if a relation\n+        // field like a 1-1 is given as the target of an extension, then\n+        // the extension probably acts on some field or column in the\n+        // related object, not the 1-1 field itself\n+        if (_arg != null) {\n+            _arg.initialize(sel, store, false);\n+            if (_arg instanceof PCPath)\n+                ((PCPath) _arg).joinRelation();\n+            _joins = _arg.getJoins();\n+        }\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return val;\n+    }\n+\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+        sel.select(newSQLBuffer(sel, store, params, fetchState), this);\n+        sel.setAggregate(true);\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+        if (_arg != null)\n+            _arg.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState) {\n+        sel.groupBy(newSQLBuffer(sel, store, params, fetchState), false);\n+    }\n+\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState) {\n+        sel.orderBy(newSQLBuffer(sel, store, params, fetchState), asc, false);\n+    }\n+\n+    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        calculateValue(sel, store, params, null, fetchState);\n+        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n+        appendTo(buf, 0, sel, store, params, fetchState);\n+        clearParameters();\n+        return buf;\n+    }\n+\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState)\n+        throws SQLException {\n+        return Filters.convert(res.getObject(this,\n+            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        if (_arg != null)\n+            return _arg.hasVariable(var);\n+        return false;\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        if (_arg != null)\n+            _arg.calculateValue(sel, store, params, null, fetchState);\n+    }\n+\n+    public void clearParameters() {\n+        if (_arg != null)\n+            _arg.clearParameters();\n+    }\n+\n+    public int length() {\n+        return 1;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        _listener.appendTo(sql, getArgs(sel, store, params, fetchState),\n+            _candidate, store);\n+        sel.append(sql, _joins);\n+    }\n+\n+    private FilterValue[] getArgs(Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        if (_arg == null)\n+            return null;\n+        if (_arg instanceof Args) {\n+            Val[] vals = ((Args) _arg).getVals();\n+            FilterValue[] filts = new FilterValue[vals.length];\n+            for (int i = 0; i < vals.length; i++)\n+                filts[i] = new FilterValueImpl(vals[i], sel, store, params,\n+                    fetchState);\n+            return filts;\n+        }\n+        return new FilterValue[]{\n+            new FilterValueImpl(_arg, sel, store, params, fetchState)\n+        };\n+    }\n+}"},{"sha":"7eb37d496782aa2c6ae7195ed573377a1e9b7947","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/All.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/All.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/All.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/All.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+/**\n+ * All.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class All\n+    extends UnaryOp {\n+\n+    public All(Val val) {\n+        super(val);\n+    }\n+\n+    protected String getOperator() {\n+        return \"ALL\";\n+    }\n+}\n+"},{"sha":"1f3e704dcfee4a2ce28de698d699e24654c93885","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AndExpression.java","status":"added","additions":91,"deletions":0,"changes":91,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AndExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AndExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AndExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Combines two expressions.\n+ *\n+ * @author Abe White\n+ */\n+class AndExpression\n+    implements Exp {\n+\n+    private final Exp _exp1;\n+    private final Exp _exp2;\n+    private Joins _joins = null;\n+    private boolean _paren1 = false;\n+    private boolean _paren2 = false;\n+\n+    /**\n+     * Constructor. Supply the expressions to combine.\n+     */\n+    public AndExpression(Exp exp1, Exp exp2) {\n+        _exp1 = exp1;\n+        _exp2 = exp2;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        _exp1.initialize(sel, store, params, contains);\n+        _exp2.initialize(sel, store, params, contains);\n+        _joins = sel.and(_exp1.getJoins(), _exp2.getJoins());\n+\n+        _paren1 = _exp1 instanceof OrExpression;\n+        _paren2 = _exp2 instanceof OrExpression;\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        if (_paren1)\n+            buf.append(\"(\");\n+        _exp1.appendTo(buf, sel, store, params, fetchState);\n+        if (_paren1)\n+            buf.append(\")\");\n+        buf.append(\" AND \");\n+        if (_paren2)\n+            buf.append(\"(\");\n+        _exp2.appendTo(buf, sel, store, params, fetchState);\n+        if (_paren2)\n+            buf.append(\")\");\n+        sel.append(buf, _joins);\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _exp1.selectColumns(sel, store, params, pks, fetchState);\n+        _exp2.selectColumns(sel, store, params, pks, fetchState);\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return _exp1.hasContainsExpression() || _exp2.hasContainsExpression();\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _exp1.hasVariable(var) || _exp2.hasVariable(var);\n+    }\n+}"},{"sha":"9aeb7def4ece269bc2eb2a41db38553fcd7298b8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Any.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Any.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Any.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Any.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+/**\n+ * Any.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class Any\n+    extends UnaryOp {\n+\n+    public Any(Val val) {\n+        super(val);\n+    }\n+\n+    protected String getOperator() {\n+        return \"ANY\";\n+    }\n+}\n+"},{"sha":"8afb7f8d1bdfcc3e95c59401c67813b8f8dffbae","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Args.java","status":"added","additions":178,"deletions":0,"changes":178,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Args.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Args.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Args.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.exps.Arguments;\n+import org.apache.openjpa.kernel.exps.Value;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * A list of arguments to a multi-argument function.\n+ *\n+ * @author Abe White\n+ */\n+public class Args\n+    implements Val, Arguments {\n+\n+    private final Val[] _args;\n+    private Joins _joins = null;\n+    private ClassMetaData _meta = null;\n+\n+    /**\n+     * Constructor. Supply values being combined.\n+     */\n+    public Args(Val val1, Val val2) {\n+        int len1 = (val1 instanceof Args) ? ((Args) val1)._args.length : 1;\n+        int len2 = (val2 instanceof Args) ? ((Args) val2)._args.length : 1;\n+\n+        _args = new Val[len1 + len2];\n+        if (val1 instanceof Args)\n+            System.arraycopy(((Args) val1)._args, 0, _args, 0, len1);\n+        else\n+            _args[0] = val1;\n+        if (val2 instanceof Args)\n+            System.arraycopy(((Args) val2)._args, 0, _args, len1, len2);\n+        else\n+            _args[len1] = val2;\n+    }\n+\n+    public Value[] getValues() {\n+        return _args;\n+    }\n+\n+    public Val[] getVals() {\n+        return _args;\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+    }\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    public Class getType() {\n+        return Object[].class;\n+    }\n+\n+    public Class[] getTypes() {\n+        Class[] c = new Class[_args.length];\n+        for (int i = 0; i < _args.length; i++)\n+            c[i] = _args[i].getType();\n+        return c;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        for (int i = 0; i < _args.length; i++) {\n+            _args[i].initialize(sel, store, nullTest);\n+            if (_joins == null)\n+                _joins = _args[i].getJoins();\n+            else\n+                _joins = sel.and(_joins, _args[i].getJoins());\n+        }\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return val;\n+    }\n+\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        for (int i = 0; i < _args.length; i++)\n+            _args[i].selectColumns(sel, store, params, pks, fetchState);\n+    }\n+\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState) {\n+    }\n+\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState) {\n+    }\n+\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState) {\n+        return null;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        for (int i = 0; i < _args.length; i++)\n+            if (_args[i].hasVariable(var))\n+                return true;\n+        return false;\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        for (int i = 0; i < _args.length; i++)\n+            _args[i].calculateValue(sel, store, params, null, fetchState);\n+    }\n+\n+    public void clearParameters() {\n+        for (int i = 0; i < _args.length; i++)\n+            _args[i].clearParameters();\n+    }\n+\n+    public int length() {\n+        return 0;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+    }\n+\n+    public void appendIsEmpty(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+    }\n+\n+    public void appendIsNotEmpty(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+    }\n+\n+    public void appendSize(SQLBuffer sql, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+    }\n+\n+    public void appendIsNull(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+    }\n+\n+    public void appendIsNotNull(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+    }\n+}"},{"sha":"5fd3d013cfb54ff46c5ee1954aa3021720185324","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Avg.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Avg.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Avg.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Avg.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+/**\n+ * Average.\n+ *\n+ * @author Abe White\n+ */\n+class Avg\n+    extends UnaryOp {\n+\n+    /**\n+     * Constructor. Provide the value to operate on.\n+     */\n+    public Avg(Val val) {\n+        super(val);\n+    }\n+\n+    protected String getOperator() {\n+        return \"AVG\";\n+    }\n+\n+    protected boolean isAggregate() {\n+        return true;\n+    }\n+}\n+"},{"sha":"fbbdbb496d06ac16ecb43689298dbecfe564a3a3","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableAndExpression.java","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableAndExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableAndExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableAndExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Combines a bind variable expression with another.\n+ *\n+ * @author Abe White\n+ */\n+class BindVariableAndExpression\n+    implements Exp {\n+\n+    private final BindVariableExpression _bind;\n+    private final Exp _exp;\n+    private Joins _joins = null;\n+\n+    /**\n+     * Constructor. Supply the two combined expressions.\n+     */\n+    public BindVariableAndExpression(BindVariableExpression bind, Exp exp) {\n+        _bind = bind;\n+        _exp = exp;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        _bind.initialize(sel, store, params, contains);\n+        _exp.initialize(sel, store, params, contains);\n+        _joins = sel.and(_bind.getJoins(), _exp.getJoins());\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        boolean or = _exp instanceof OrExpression;\n+        if (or)\n+            buf.append(\"(\");\n+        _exp.appendTo(buf, sel, store, params, fetchState);\n+        if (or)\n+            buf.append(\")\");\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _exp.selectColumns(sel, store, params, pks, fetchState);\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return true;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _exp.hasVariable(var);\n+    }\n+}"},{"sha":"c07ccbcfaa726e056647a83a8cb02874b6287a16","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableExpression.java","status":"added","additions":81,"deletions":0,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Binds a variable to a value. Typically, the {@link #initialize} and\n+ * {@link #getJoins} methods of this expression are not called. They are\n+ * only called if the variable being bound is otherwise unused in the filter,\n+ * in which case we must at least make the joins to the variable because the\n+ * act of binding a variable should at least guarantee that an instance\n+ * represting the variable could exist (i.e. the binding collection is not\n+ * empty).\n+ *\n+ * @author Abe White\n+ */\n+class BindVariableExpression\n+    extends EmptyExpression {\n+\n+    private final Variable _var;\n+\n+    /**\n+     * Constructor. Supply values.\n+     */\n+    public BindVariableExpression(Variable var, PCPath val, boolean key) {\n+        if (key)\n+            val.getKey();\n+        var.setPCPath(val);\n+        _var = var;\n+    }\n+\n+    public Variable getVariable() {\n+        return _var;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        _var.initialize(sel, store, false);\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        buf.append(\"1 = 1\");\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+    }\n+\n+    public Joins getJoins() {\n+        return _var.getJoins();\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return false;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _var == var;\n+    }\n+}"},{"sha":"3122af04d0fd76820161a7fb4205a8cae6a19edd","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareEqualExpression.java","status":"added","additions":134,"deletions":0,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareEqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareEqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareEqualExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Compares two values for equality.\n+ *\n+ * @author Abe White\n+ */\n+abstract class CompareEqualExpression\n+    implements Exp {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (CompareEqualExpression.class);\n+\n+    private final Val _val1;\n+    private final Val _val2;\n+    private Joins _joins = null;\n+\n+    /**\n+     * Constructor. Supply values to compare.\n+     */\n+    public CompareEqualExpression(Val val1, Val val2) {\n+        _val1 = val1;\n+        _val2 = val2;\n+    }\n+\n+    public Val getValue1() {\n+        return _val1;\n+    }\n+\n+    public Val getValue2() {\n+        return _val2;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        boolean direct = isDirectComparison();\n+        _val1.initialize(sel, store, direct && isNull(_val2, params));\n+        _val2.initialize(sel, store, direct && isNull(_val1, params));\n+        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n+    }\n+\n+    /**\n+     * Return whether the given value is null.\n+     */\n+    private boolean isNull(Val val, Object[] params) {\n+        if (val instanceof Null)\n+            return true;\n+        if (!(val instanceof Param))\n+            return false;\n+\n+        Param param = (Param) val;\n+        return params[param.getIndex()] == null;\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        _val1.calculateValue(sel, store, params, _val2, fetchState);\n+        _val2.calculateValue(sel, store, params, _val1, fetchState);\n+        if (!Filters.canConvert(_val1.getType(), _val2.getType(), false)\n+            && !Filters.canConvert(_val2.getType(), _val1.getType(), false))\n+            throw new UserException(_loc.get(\"cant-convert\", _val1.getType(),\n+                _val2.getType()));\n+\n+        boolean val1Null = _val1 instanceof Const\n+            && ((Const) _val1).isSQLValueNull();\n+        boolean val2Null = _val2 instanceof Const\n+            && ((Const) _val2).isSQLValueNull();\n+        appendTo(buf, sel, store, params, fetchState, val1Null, val2Null);\n+        sel.append(buf, _joins);\n+\n+        _val1.clearParameters();\n+        _val2.clearParameters();\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val1.selectColumns(sel, store, params, true, fetchState);\n+        _val2.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return false;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _val1.hasVariable(var) || _val2.hasVariable(var);\n+    }\n+\n+    /**\n+     * Append the SQL for the comparison.\n+     */\n+    protected abstract void appendTo(SQLBuffer buf, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState,\n+        boolean val1Null, boolean val2Null);\n+\n+    /**\n+     * Subclasses can override this method if, when they compare to another,\n+     * value, the comparison is indirect. For example, field.contains (x)\n+     * should compare element values to null, not the field itself.\n+     */\n+    protected boolean isDirectComparison() {\n+        return true;\n+    }\n+}"},{"sha":"ed0eca9f7ac7355a392cee95fb62fbe0ed6bd20c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareExpression.java","status":"added","additions":101,"deletions":0,"changes":101,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Compares two values.\n+ *\n+ * @author Abe White\n+ */\n+class CompareExpression\n+    implements Exp {\n+\n+    public static final String LESS = \"<\";\n+    public static final String GREATER = \">\";\n+    public static final String LESS_EQUAL = \"<=\";\n+    public static final String GREATER_EQUAL = \">=\";\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (CompareExpression.class);\n+\n+    private final Val _val1;\n+    private final Val _val2;\n+    private final String _op;\n+    private Joins _joins = null;\n+\n+    /**\n+     * Constructor. Supply values and operator.\n+     */\n+    public CompareExpression(Val val1, Val val2, String op) {\n+        _val1 = val1;\n+        _val2 = val2;\n+        _op = op;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        _val1.initialize(sel, store, false);\n+        _val2.initialize(sel, store, false);\n+        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        _val1.calculateValue(sel, store, params, _val2, fetchState);\n+        _val2.calculateValue(sel, store, params, _val1, fetchState);\n+        if (!Filters.canConvert(_val1.getType(), _val2.getType(), false)\n+            && !Filters.canConvert(_val2.getType(), _val1.getType(), false))\n+            throw new UserException(_loc.get(\"cant-convert\", _val1.getType(),\n+                _val2.getType()));\n+\n+        store.getDBDictionary().comparison(buf, _op,\n+            new FilterValueImpl(_val1, sel, store, params, fetchState),\n+            new FilterValueImpl(_val2, sel, store, params, fetchState));\n+        sel.append(buf, _joins);\n+\n+        _val1.clearParameters();\n+        _val2.clearParameters();\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val1.selectColumns(sel, store, params, true, fetchState);\n+        _val2.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return false;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _val1.hasVariable(var) || _val2.hasVariable(var);\n+    }\n+}"},{"sha":"dc3415570efb7a256829eb88d28b6c9b8af8c123","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Concat.java","status":"added","additions":171,"deletions":0,"changes":171,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Concat.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Concat.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Concat.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.lang.Math;\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Concatenate one string with another.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class Concat\n+    extends AbstractVal\n+    implements Val {\n+\n+    private final Val _val1;\n+    private final Val _val2;\n+    private Joins _joins = null;\n+    private ClassMetaData _meta = null;\n+    private String _part1;\n+    private String _part2;\n+    private String _part3;\n+\n+    /**\n+     * Constructor. Provide the strings to operate on.\n+     */\n+    public Concat(Val val1, Val val2) {\n+        _val1 = val1;\n+        _val2 = val2;\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+    }\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    public Class getType() {\n+        return String.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        _val1.initialize(sel, store, false);\n+        _val2.initialize(sel, store, false);\n+        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n+\n+        DBDictionary dict = store.getDBDictionary();\n+        String func = dict.concatenateFunction;\n+\n+        dict.assertSupport(func != null, \"ConcatenateFunction\");\n+\n+        int part1idx = func.indexOf(\"{0}\");\n+        int part2idx = func.indexOf(\"{1}\");\n+\n+        _part1 = func.substring(0, Math.min(part1idx, part2idx));\n+        _part2 = func.substring(Math.min(part1idx, part2idx) + 3,\n+            Math.max(part1idx, part2idx));\n+        _part3 = func.substring(Math.max(part1idx, part2idx) + 3);\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return val;\n+    }\n+\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+        sel.select(newSQLBuffer(sel, store, params, fetchState), this);\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val1.selectColumns(sel, store, params, true, fetchState);\n+        _val2.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState) {\n+        sel.groupBy(newSQLBuffer(sel, store, params, fetchState), false);\n+    }\n+\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState) {\n+        sel.orderBy(newSQLBuffer(sel, store, params, fetchState), asc, false);\n+    }\n+\n+    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        calculateValue(sel, store, params, null, fetchState);\n+        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n+        appendTo(buf, 0, sel, store, params, fetchState);\n+        clearParameters();\n+        return buf;\n+    }\n+\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState)\n+        throws SQLException {\n+        return Filters.convert(res.getObject(this,\n+            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _val1.hasVariable(var) || _val2.hasVariable(var);\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        _val1.calculateValue(sel, store, params, null, fetchState);\n+        _val2.calculateValue(sel, store, params, null, fetchState);\n+    }\n+\n+    public void clearParameters() {\n+        _val1.clearParameters();\n+        _val2.clearParameters();\n+    }\n+\n+    public int length() {\n+        return 1;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        _val1.calculateValue(sel, store, params, _val2, fetchState);\n+        _val2.calculateValue(sel, store, params, _val1, fetchState);\n+\n+        sql.append(_part1);\n+        _val1.appendTo(sql, 0, sel, store, params, fetchState);\n+        sql.append(_part2);\n+        _val2.appendTo(sql, 0, sel, store, params, fetchState);\n+        sql.append(_part3);\n+    }\n+}\n+"},{"sha":"de9399620cc3cae4be3dc44e5447d475cd7829b2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Const.java","status":"added","additions":211,"deletions":0,"changes":211,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Const.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Const.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Const.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.exps.Constant;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+\n+/**\n+ * A literal or parameter in the filter.\n+ *\n+ * @author Abe White\n+ */\n+abstract class Const\n+    implements Val, Constant {\n+\n+    private ClassMetaData _meta = null;\n+    private Column[] _cols = null;\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+    }\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    /**\n+     * Return the column for the value at the specified index, or null.\n+     */\n+    public Column getColumn(int index) {\n+        return (_cols != null && _cols.length > index) ? _cols[index] : null;\n+    }\n+\n+    /**\n+     * Return the value of this constant.\n+     */\n+    public abstract Object getValue();\n+\n+    public Object getValue(Object[] parameters) {\n+        return getValue();\n+    }\n+\n+    /**\n+     * Return the SQL value of this constant.\n+     */\n+    public Object getSQLValue() {\n+        return getValue();\n+    }\n+\n+    /**\n+     * Return true if this constant's SQL value is equivalent to NULL.\n+     */\n+    public boolean isSQLValueNull() {\n+        Object val = getSQLValue();\n+        if (val == null)\n+            return true;\n+        if (!(val instanceof Object[]))\n+            return false;\n+\n+        // all-null array is considered null\n+        Object[] arr = (Object[]) val;\n+        for (int i = 0; i < arr.length; i++)\n+            if (arr[i] != null)\n+                return false;\n+        return true;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+    }\n+\n+    public Joins getJoins() {\n+        return null;\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        if (other instanceof PCPath)\n+            _cols = ((PCPath) other).getColumns();\n+        else\n+            _cols = null;\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return val;\n+    }\n+\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+        sel.select(newSQLBuffer(sel, store, params, fetchState), this);\n+    }\n+\n+    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        calculateValue(sel, store, params, null, fetchState);\n+        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n+        appendTo(buf, 0, sel, store, params, fetchState);\n+        clearParameters();\n+        return buf;\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+    }\n+\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState) {\n+        sel.groupBy(newSQLBuffer(sel, store, params, fetchState), false);\n+    }\n+\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState) {\n+        sel.orderBy(newSQLBuffer(sel, store, params, fetchState), asc, false);\n+    }\n+\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState)\n+        throws SQLException {\n+        int code = JavaTypes.getTypeCode(getType());\n+        if (code == JavaTypes.OBJECT)\n+            code = JavaSQLTypes.JDBC_DEFAULT;\n+        return Filters.convert(res.getObject(this, code, null), getType());\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return false;\n+    }\n+\n+    public int length() {\n+        return 1;\n+    }\n+\n+    public void appendIsEmpty(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        Object obj = getValue();\n+        if (obj instanceof Collection && ((Collection) obj).isEmpty())\n+            sql.append(\"1 = 1\");\n+        else if (obj instanceof Map && ((Map) obj).isEmpty())\n+            sql.append(\"1 = 1\");\n+        else\n+            sql.append(\"1 <> 1\");\n+    }\n+\n+    public void appendIsNotEmpty(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        Object obj = getValue();\n+        if (obj instanceof Collection && ((Collection) obj).isEmpty())\n+            sql.append(\"1 <> 1\");\n+        else if (obj instanceof Map && ((Map) obj).isEmpty())\n+            sql.append(\"1 <> 1\");\n+        else\n+            sql.append(\"1 = 1\");\n+    }\n+\n+    public void appendSize(SQLBuffer sql, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        Object obj = getValue();\n+        if (obj instanceof Collection)\n+            sql.appendValue(((Collection) obj).size());\n+        else if (obj instanceof Map)\n+            sql.appendValue(((Map) obj).size());\n+        else\n+            sql.append(\"1\");\n+    }\n+\n+    public void appendIsNull(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        if (getSQLValue() == null)\n+            sql.append(\"1 = 1\");\n+        else\n+            sql.append(\"1 <> 1\");\n+    }\n+\n+    public void appendIsNotNull(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        if (getSQLValue() != null)\n+            sql.append(\"1 = 1\");\n+        else\n+            sql.append(\"1 <> 1\");\n+    }\n+}"},{"sha":"31d70bee57659cb4afd1abed6bdfb003a984ed0f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstGetObjectId.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstGetObjectId.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstGetObjectId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstGetObjectId.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Obtaining the object id of a constant.\n+ *\n+ * @author Abe White\n+ */\n+class ConstGetObjectId\n+    extends Const {\n+\n+    private final Const _constant;\n+    private Object _val = null;\n+    private Object _sqlVal = null;\n+    private int _otherLen = 0;\n+\n+    /**\n+     * Constructor. Supply constant to traverse.\n+     */\n+    public ConstGetObjectId(Const constant) {\n+        _constant = constant;\n+    }\n+\n+    public Class getType() {\n+        return Object.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    public Object getValue() {\n+        return _val;\n+    }\n+\n+    public Object getSQLValue() {\n+        return _sqlVal;\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        super.calculateValue(sel, store, params, other, fetchState);\n+        _constant.calculateValue(sel, store, params, null, fetchState);\n+        _val = store.getContext().getObjectId(_constant.getValue());\n+        if (other != null) {\n+            _sqlVal = other.toDataStoreValue(_val, store);\n+            _otherLen = other.length();\n+        } else\n+            _sqlVal = _val;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        if (_otherLen > 1)\n+            sql.appendValue(((Object[]) _sqlVal)[index], getColumn(index));\n+        else\n+            sql.appendValue(_sqlVal, getColumn(index));\n+    }\n+\n+    public void clearParameters() {\n+        _constant.clearParameters();\n+        _val = null;\n+        _sqlVal = null;\n+    }\n+}"},{"sha":"1b765297c02b55ea5680aad6cdcdf24c0228fccf","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstInstanceofExpression.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstInstanceofExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstInstanceofExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstInstanceofExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+\n+/**\n+ * Tests whether a value is an instance of a class.\n+ *\n+ * @author Abe White\n+ */\n+class ConstInstanceofExpression\n+    implements Exp {\n+\n+    private final Const _const;\n+    private final Class _cls;\n+\n+    /**\n+     * Constructor. Supply the constant to test and the class.\n+     */\n+    public ConstInstanceofExpression(Const val, Class cls) {\n+        _const = val;\n+        _cls = Filters.wrap(cls);\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        _const.initialize(sel, store, false);\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        _const.calculateValue(sel, store, params, null, fetchState);\n+        if (_cls.isInstance(_const.getValue()))\n+            buf.append(\"1 = 1\");\n+        else\n+            buf.append(\"1 <> 1\");\n+        _const.clearParameters();\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _const.selectColumns(sel, store, params, pks, fetchState);\n+    }\n+\n+    public Joins getJoins() {\n+        return _const.getJoins();\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return false;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _const.hasVariable(var);\n+    }\n+}"},{"sha":"4cdf44a4958b96047c28f4739399c2a19bd89eae","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java","status":"added","additions":178,"deletions":0,"changes":178,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.ListIterator;\n+\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Broker;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+\n+/**\n+ * A field traversal starting with a constant filter parameter.\n+ *\n+ * @author Abe White\n+ */\n+class ConstPath\n+    extends Const\n+    implements JDBCPath {\n+\n+    private final Const _constant;\n+    private final LinkedList _actions = new LinkedList();\n+    private Object _val = null;\n+    private Object _sqlVal = null;\n+    private int _otherLen = 0;\n+\n+    /**\n+     * Constructor. Supply constant to traverse.\n+     */\n+    public ConstPath(Const constant) {\n+        _constant = constant;\n+    }\n+\n+    public Class getType() {\n+        if (_actions.isEmpty()) {\n+            ClassMetaData meta = getMetaData();\n+            if (meta == null)\n+                return Object.class;\n+            return meta.getDescribedType();\n+        }\n+\n+        Object last = _actions.getLast();\n+        if (last instanceof Class)\n+            return (Class) last;\n+        FieldMetaData fmd = (FieldMetaData) last;\n+        return fmd.getDeclaredType();\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _actions.add(type);\n+    }\n+\n+    public void get(FieldMetaData field, boolean nullTraversal) {\n+        _actions.add(field);\n+    }\n+\n+    public void getKey() {\n+    }\n+\n+    public FieldMetaData last() {\n+        ListIterator itr = _actions.listIterator(_actions.size());\n+        Object prev;\n+        while (itr.hasPrevious()) {\n+            prev = itr.previous();\n+            if (prev instanceof FieldMetaData)\n+                return (FieldMetaData) prev;\n+        }\n+        return null;\n+    }\n+\n+    public Object getValue() {\n+        return _val;\n+    }\n+\n+    public Object getSQLValue() {\n+        return _sqlVal;\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        super.calculateValue(sel, store, params, other, fetchState);\n+        _constant.calculateValue(sel, store, params, null, fetchState);\n+        _val = _constant.getValue();\n+        boolean failed = false;\n+\n+        // copied from org.apache.openjpa.query.InMemoryPath\n+        Object action;\n+        OpenJPAStateManager sm;\n+        Broker tmpBroker = null;\n+        for (Iterator itr = _actions.iterator(); itr.hasNext();) {\n+            // fail on null value\n+            if (_val == null) {\n+                failed = true;\n+                break;\n+            }\n+\n+            action = itr.next();\n+            if (action instanceof Class) {\n+                try {\n+                    _val = Filters.convert(_val, (Class) action);\n+                    continue;\n+                } catch (ClassCastException cce) {\n+                    failed = true;\n+                    break;\n+                }\n+            }\n+\n+            // make sure we can access the instance; even non-pc vals might\n+            // be proxyable\n+            sm = null;\n+            tmpBroker = null;\n+            if (_val instanceof PersistenceCapable)\n+                sm = (OpenJPAStateManager) ((PersistenceCapable) _val).\n+                    pcGetStateManager();\n+            if (sm == null) {\n+                tmpBroker = store.getContext().getBroker();\n+                tmpBroker.transactional(_val, false, null);\n+                sm = tmpBroker.getStateManager(_val);\n+            }\n+\n+            try {\n+                // get the specified field value and switch candidate\n+                _val = sm.fetchField(((FieldMetaData) action).getIndex(),\n+                    true);\n+            } finally {\n+                // setTransactional does not clear the state, which is\n+                // important since tmpVal might be also managed by\n+                // another broker if it's a proxied non-pc instance\n+                if (tmpBroker != null)\n+                    tmpBroker.nontransactional(sm.getManagedInstance(), null);\n+            }\n+        }\n+\n+        if (failed)\n+            _val = null;\n+\n+        if (other != null) {\n+            _sqlVal = other.toDataStoreValue(_val, store);\n+            _otherLen = other.length();\n+        } else\n+            _sqlVal = _val;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        if (_otherLen > 1)\n+            sql.appendValue(((Object[]) _sqlVal)[index], getColumn(index));\n+        else\n+            sql.appendValue(_sqlVal, getColumn(index));\n+    }\n+\n+    public void clearParameters() {\n+        _constant.clearParameters();\n+        _val = null;\n+        _sqlVal = null;\n+    }\n+}"},{"sha":"3e611d58acafc66b665134043c05090c6f5f773b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsExpression.java","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import serp.util.Numbers;\n+\n+/**\n+ * Tests whether one value contains another.\n+ *\n+ * @author Abe White\n+ */\n+class ContainsExpression\n+    extends EqualExpression {\n+\n+    /**\n+     * Constructor. Supply values to test.\n+     */\n+    public ContainsExpression(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        Val val1 = getValue1();\n+        if (contains != null && val1 instanceof PCPath) {\n+            PCPath sql = (PCPath) val1;\n+            String path = sql.getPath();\n+\n+            // update the count for this path\n+            Integer count = (Integer) contains.get(path);\n+            if (count == null)\n+                count = Numbers.valueOf(0);\n+            else\n+                count = Numbers.valueOf(count.intValue() + 1);\n+            contains.put(path, count);\n+\n+            sql.setContainsId(count.toString());\n+        }\n+        super.initialize(sel, store, params, contains);\n+    }\n+\n+    protected boolean isDirectComparison() {\n+        return false;\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return true;\n+    }\n+}"},{"sha":"1b1f5daa20efb4f10fa61a8c0b5f33fbed20b29b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsKeyExpression.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsKeyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsKeyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsKeyExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Tests whether a map value contains a key.\n+ *\n+ * @author Abe White\n+ */\n+class ContainsKeyExpression\n+    extends ContainsExpression {\n+\n+    /**\n+     * Constructor. Supply values to test.\n+     */\n+    public ContainsKeyExpression(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        Val val1 = getValue1();\n+        if (val1 instanceof PCPath)\n+            ((PCPath) val1).getKey();\n+\n+        super.initialize(sel, store, params, contains);\n+    }\n+}"},{"sha":"01b307c80ff0febac5bf9ec5943c71ea8a1b525e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Count.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Count.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Count.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Count.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Count non-null values.\n+ *\n+ * @author Abe White\n+ */\n+class Count\n+    extends UnaryOp {\n+\n+    /**\n+     * Constructor. Provide the value to operate on.\n+     */\n+    public Count(Val val) {\n+        super(val);\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        super.initialize(sel, store, nullTest);\n+\n+        // join into related object if present\n+        if (getVal()instanceof PCPath)\n+            ((PCPath) getVal()).joinRelation();\n+    }\n+\n+    protected Class getType(Class c) {\n+        return long.class;\n+    }\n+\n+    protected String getOperator() {\n+        return \"COUNT\";\n+    }\n+\n+    protected boolean isAggregate() {\n+        return true;\n+    }\n+}\n+"},{"sha":"5cbc026af91be11aa28d4c9222d37ae50b0193b2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CurrentDate.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CurrentDate.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CurrentDate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CurrentDate.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Date;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * A literal current DATE/TIME/TIMESTAMP value in a filter.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class CurrentDate\n+    extends Const {\n+\n+    static final int DATE = 1;\n+    static final int TIME = 2;\n+    static final int TIMESTAMP = 3;\n+\n+    private final int _type;\n+\n+    CurrentDate(int type) {\n+        _type = type;\n+    }\n+\n+    public Class getType() {\n+        return Date.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    public Object getValue() {\n+        return new Date();\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        if (_type == DATE)\n+            sql.append(store.getDBDictionary().currentDateFunction);\n+        else if (_type == TIME)\n+            sql.append(store.getDBDictionary().currentTimeFunction);\n+        else if (_type == TIMESTAMP)\n+            sql.append(store.getDBDictionary().currentTimestampFunction);\n+    }\n+\n+    public void clearParameters() {\n+    }\n+}"},{"sha":"60a19e67f9ff959e9de48f9ff9894d98ed510502","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Distinct.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Distinct.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Distinct.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Distinct.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Distinct the specified path.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class Distinct\n+    extends UnaryOp {\n+\n+    public Distinct(Val val) {\n+        super(val);\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        super.initialize(sel, store, nullTest);\n+\n+        // join into related object if present\n+        if (getVal()instanceof PCPath)\n+            ((PCPath) getVal()).joinRelation();\n+    }\n+\n+    protected String getOperator() {\n+        return \"DISTINCT\";\n+    }\n+\n+    protected boolean isAggregate() {\n+        return false;\n+    }\n+}\n+"},{"sha":"dc525e833eed4973f3611624fe3a122a369b69b2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EmptyExpression.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EmptyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EmptyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EmptyExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * An empty expression.\n+ *\n+ * @author Abe White\n+ */\n+class EmptyExpression\n+    implements Exp {\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+    }\n+\n+    public Joins getJoins() {\n+        return null;\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return false;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return false;\n+    }\n+}"},{"sha":"8723ff3933a2dd05dd05b281cdf0bab6f2147fe1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EndsWithExpression.java","status":"added","additions":202,"deletions":0,"changes":202,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EndsWithExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EndsWithExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EndsWithExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Test if one string ends with another.\n+ *\n+ * @author Abe White\n+ */\n+class EndsWithExpression\n+    implements Exp {\n+\n+    private final Val _val1;\n+    private final Val _val2;\n+    private Joins _joins = null;\n+    private String _pre = null;\n+    private String _post = null;\n+\n+    /**\n+     * Constructor. Supply values.\n+     */\n+    public EndsWithExpression(Val val1, Val val2) {\n+        _val1 = val1;\n+        _val2 = val2;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        _val1.initialize(sel, store, false);\n+        _val2.initialize(sel, store, false);\n+        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n+\n+        DBDictionary dict = store.getDBDictionary();\n+        String func = dict.stringLengthFunction;\n+        if (func != null) {\n+            int idx = func.indexOf(\"{0}\");\n+            _pre = func.substring(0, idx);\n+            _post = func.substring(idx + 3);\n+        }\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        _val1.calculateValue(sel, store, params, _val2, fetchState);\n+        _val2.calculateValue(sel, store, params, _val1, fetchState);\n+\n+        if (_val1 instanceof Const && ((Const) _val1).getValue() == null)\n+            buf.append(\"1 <> 1\");\n+        else if (_val2 instanceof Const) {\n+            Object o = ((Const) _val2).getValue();\n+            if (o == null)\n+                buf.append(\"1 <> 1\");\n+            else {\n+                Column col = null;\n+                if (_val1 instanceof PCPath) {\n+                    Column[] cols = ((PCPath) _val1).getColumns();\n+                    if (cols.length == 1)\n+                        col = cols[0];\n+                }\n+\n+                _val1.appendTo(buf, 0, sel, store, params, fetchState);\n+                buf.append(\" LIKE \");\n+                buf.appendValue(\"%\" + o.toString(), col);\n+            }\n+        } else {\n+            // if we can't use LIKE, we have to take the substring of the\n+            // first value and compare it to the second\n+            DBDictionary dict = store.getDBDictionary();\n+            dict.assertSupport(_pre != null, \"StringLengthFunction\");\n+            dict.substring(buf,\n+                new FilterValueImpl(_val1, sel, store, params, fetchState),\n+                new StringLengthDifferenceFilterValue(sel, store, params,\n+                    fetchState), null);\n+            buf.append(\" = \");\n+            _val2.appendTo(buf, 0, sel, store, params, fetchState);\n+        }\n+\n+        sel.append(buf, _joins);\n+        _val1.clearParameters();\n+        _val2.clearParameters();\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val1.selectColumns(sel, store, params, true, fetchState);\n+        _val2.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return false;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _val1.hasVariable(var) || _val2.hasVariable(var);\n+    }\n+\n+    /**\n+     * Evaluates to the length of a given value.\n+     */\n+    private class StringLengthDifferenceFilterValue\n+        implements FilterValue {\n+\n+        private final Select _sel;\n+        private final JDBCStore _store;\n+        private final Object[] _params;\n+        private final JDBCFetchState _fetchState;\n+\n+        public StringLengthDifferenceFilterValue(Select sel,\n+            JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+            _sel = sel;\n+            _store = store;\n+            _params = params;\n+            _fetchState = fetchState;\n+        }\n+\n+        public Class getType() {\n+            return int.class;\n+        }\n+\n+        public int length() {\n+            return 1;\n+        }\n+\n+        public void appendTo(SQLBuffer buf) {\n+            appendTo(buf, 0);\n+        }\n+\n+        public void appendTo(SQLBuffer buf, int index) {\n+            buf.append(_pre);\n+            _val1.appendTo(buf, index, _sel, _store, _params, _fetchState);\n+            buf.append(_post).append(\" - \").append(_pre);\n+            _val2.appendTo(buf, index, _sel, _store, _params, _fetchState);\n+            buf.append(_post);\n+        }\n+\n+        public String getColumnAlias(Column col) {\n+            return _sel.getColumnAlias(col, _joins);\n+        }\n+\n+        public String getColumnAlias(String col, Table table) {\n+            return _sel.getColumnAlias(col, table, _joins);\n+        }\n+\n+        public Object toDataStoreValue(Object val) {\n+            return val;\n+        }\n+\n+        public boolean isConstant() {\n+            return false;\n+        }\n+\n+        public Object getValue() {\n+            return null;\n+        }\n+\n+        public Object getSQLValue() {\n+            return null;\n+        }\n+\n+        public boolean isPath() {\n+            return false;\n+        }\n+\n+        public ClassMapping getClassMapping() {\n+            return null;\n+        }\n+\n+        public FieldMapping getFieldMapping() {\n+            return null;\n+        }\n+    }\n+}"},{"sha":"47d0a3dc3f740001927249d5e9b07fb5f914f9bc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EqualExpression.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EqualExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Compares two values.\n+ *\n+ * @author Abe White\n+ */\n+class EqualExpression\n+    extends CompareEqualExpression {\n+\n+    /**\n+     * Constructor. Supply values to compare.\n+     */\n+    public EqualExpression(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState,\n+        boolean val1Null, boolean val2Null) {\n+        if (val1Null && val2Null)\n+            buf.appendValue(null).append(\" IS \").appendValue(null);\n+        else if (val1Null || val2Null) {\n+            Val val = (val1Null) ? getValue2() : getValue1();\n+            if (!isDirectComparison()) {\n+                int len = val.length();\n+                for (int i = 0; i < len; i++) {\n+                    if (i > 0)\n+                        buf.append(\" AND \");\n+                    val.appendTo(buf, i, sel, store, params, fetchState);\n+                    buf.append(\" IS \").appendValue(null);\n+                }\n+            } else\n+                val.appendIsNull(buf, sel, store, params, fetchState);\n+        } else {\n+            Val val1 = getValue1();\n+            Val val2 = getValue2();\n+            if (val1.length() == 1 && val2.length() == 1) {\n+                store.getDBDictionary().comparison(buf, \"=\",\n+                    new FilterValueImpl(val1, sel, store, params, fetchState),\n+                    new FilterValueImpl(val2, sel, store, params, fetchState));\n+            } else {\n+                int len = java.lang.Math.max(val1.length(), val2.length());\n+                for (int i = 0; i < len; i++) {\n+                    if (i > 0)\n+                        buf.append(\" AND \");\n+\n+                    val1.appendTo(buf, i, sel, store, params, fetchState);\n+                    buf.append(\" = \");\n+                    val2.appendTo(buf, i, sel, store, params, fetchState);\n+                }\n+            }\n+        }\n+    }\n+}"},{"sha":"8b88885ddc7e88cac31db1bc0f8f656b78301451","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Exp.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Exp.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Exp.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Exp.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.exps.Expression;\n+\n+/**\n+ * An Expression represents a query ready for execution. Generally, it is\n+ * a set of conditions that must be met for the query to be true.\n+ *\n+ * @author Abe White\n+ */\n+interface Exp\n+    extends Expression {\n+\n+    /**\n+     * Initialize the expression. This method should recursively\n+     * initialize any sub-expressions or values. It should also cache\n+     * the {@link Joins} instance containing the joins for this expression.\n+     *\n+     * @param params the parameter values; the initialization process\n+     * should not rely on exact values, but may need\n+     * to see if parameter values are null\n+     * @param contains map of relation paths to the number of times\n+     * the paths appear in a contains() expression;\n+     * used to ensure paths used for contains() within\n+     * the same AND expression used different aliases\n+     */\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains);\n+\n+    /**\n+     * Append the SQL for this expression to the given buffer. The SQL\n+     * should optionally include any joins this expression needs.\n+     */\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState);\n+\n+    /**\n+     * Select just the columns for this value.\n+     */\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState);\n+\n+    /**\n+     * Return the joins for this expression. These joins should be created\n+     * and cached during the {@link #initialize} method. The parent\n+     * expression might modify these joins during its own initialization so\n+     * that common joins are moved up the expression tree.\n+     */\n+    public Joins getJoins();\n+\n+    /**\n+     * Return true if this expression is or is made up of a contains expression.\n+     */\n+    public boolean hasContainsExpression();\n+\n+    /**\n+     * Return true if the expression or any subexpression uses the given\n+     * variable.\n+     */\n+    public boolean hasVariable(Variable var);\n+}"},{"sha":"a3e5f79718e5a966fad130e9a029a8d80ebbc7fc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Extension.java","status":"added","additions":232,"deletions":0,"changes":232,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Extension.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Extension.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Extension.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.sql.SQLException;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Filter listener that evaluates to a value.\n+ *\n+ * @author Abe White\n+ */\n+class Extension\n+    extends AbstractVal\n+    implements Val, Exp {\n+\n+    private final JDBCFilterListener _listener;\n+    private final Val _target;\n+    private final Val _arg;\n+    private final ClassMapping _candidate;\n+    private Joins _joins = null;\n+    private ClassMetaData _meta = null;\n+    private Class _cast = null;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public Extension(JDBCFilterListener listener, Val target,\n+        Val arg, ClassMapping candidate) {\n+        _listener = listener;\n+        _target = target;\n+        _arg = arg;\n+        _candidate = candidate;\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+    }\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    public Class getType() {\n+        if (_cast != null)\n+            return _cast;\n+        Class targetClass = (_target == null) ? null : _target.getType();\n+        return _listener.getType(targetClass, getArgTypes());\n+    }\n+\n+    private Class[] getArgTypes() {\n+        if (_arg == null)\n+            return null;\n+        if (_arg instanceof Args)\n+            return ((Args) _arg).getTypes();\n+        return new Class[]{ _arg.getType() };\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _cast = type;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        // note that we tell targets and args to extensions that are sql\n+        // paths to go ahead and join to their related object (if any),\n+        // because we assume that, unlike most operations, if a relation\n+        // field like a 1-1 is given as the target of an extension, then\n+        // the extension probably acts on some field or column in the\n+        // related object, not the 1-1 field itself\n+        Joins j1 = null;\n+        Joins j2 = null;\n+        if (_target != null) {\n+            _target.initialize(sel, store, false);\n+            if (_target instanceof PCPath)\n+                ((PCPath) _target).joinRelation();\n+            j1 = _target.getJoins();\n+        }\n+        if (_arg != null) {\n+            _arg.initialize(sel, store, false);\n+            if (_arg instanceof PCPath)\n+                ((PCPath) _arg).joinRelation();\n+            j2 = _arg.getJoins();\n+        }\n+        _joins = sel.and(j1, j2);\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return val;\n+    }\n+\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+        sel.select(newSQLBuffer(sel, store, params, fetchState), this);\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        if (_target != null)\n+            _target.selectColumns(sel, store, params, true, fetchState);\n+        if (_arg != null)\n+            _arg.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState) {\n+        sel.groupBy(newSQLBuffer(sel, store, params, fetchState), false);\n+    }\n+\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState) {\n+        sel.orderBy(newSQLBuffer(sel, store, params, fetchState), asc, false);\n+    }\n+\n+    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        calculateValue(sel, store, params, null, fetchState);\n+        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n+        appendTo(buf, 0, sel, store, params, fetchState);\n+        clearParameters();\n+        return buf;\n+    }\n+\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState)\n+        throws SQLException {\n+        return Filters.convert(res.getObject(this,\n+            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return (_target != null && _target.hasVariable(var))\n+            || (_arg != null && _arg.hasVariable(var));\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        if (_target != null)\n+            _target.calculateValue(sel, store, params, null, fetchState);\n+        if (_arg != null)\n+            _arg.calculateValue(sel, store, params, null, fetchState);\n+    }\n+\n+    public void clearParameters() {\n+        if (_target != null)\n+            _target.clearParameters();\n+        if (_arg != null)\n+            _arg.clearParameters();\n+    }\n+\n+    public int length() {\n+        return 1;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        FilterValue target = (_target == null) ? null\n+            : new FilterValueImpl(_target, sel, store, params, fetchState);\n+        _listener.appendTo(sql, target, getArgs(sel, store, params,\n+            fetchState), _candidate, store);\n+        sel.append(sql, _joins);\n+    }\n+\n+    private FilterValue[] getArgs(Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        if (_arg == null)\n+            return null;\n+        if (_arg instanceof Args) {\n+            Val[] vals = ((Args) _arg).getVals();\n+            FilterValue[] filts = new FilterValue[vals.length];\n+            for (int i = 0; i < vals.length; i++)\n+                filts[i] = new FilterValueImpl(vals[i], sel, store, params,\n+                    fetchState);\n+            return filts;\n+        }\n+        return new FilterValue[]{\n+            new FilterValueImpl(_arg, sel, store, params, fetchState)\n+        };\n+    }\n+\n+    //////////////////////\n+    // Exp implementation\n+    //////////////////////\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        initialize(sel, store, false);\n+    }\n+\n+    public void appendTo(SQLBuffer sql, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        calculateValue(sel, store, params, null, fetchState);\n+        appendTo(sql, 0, sel, store, params, fetchState);\n+        sel.append(sql, getJoins());\n+        clearParameters();\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return false;\n+    }\n+}"},{"sha":"51d79fc2455a8941c6cd43459868aaed08f9cb3c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValue.java","status":"added","additions":103,"deletions":0,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValue.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValue.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+\n+/**\n+ * The simplified public view of any non-operator in a query filter,\n+ * including constants, variables, and object fields.\n+ *\n+ * @author Abe White\n+ */\n+public interface FilterValue {\n+\n+    /**\n+     * Return the expected type of this value.\n+     */\n+    public Class getType();\n+\n+    /**\n+     * Return the number of SQL elements in this value. Usually 1.\n+     */\n+    public int length();\n+\n+    /**\n+     * Append the first SQL element for this value to the given buffer.\n+     */\n+    public void appendTo(SQLBuffer buf);\n+\n+    /**\n+     * Append the <code>index</code>th SQL element for this value to the\n+     * given buffer.\n+     */\n+    public void appendTo(SQLBuffer buf, int index);\n+\n+    /**\n+     * Return the alias to use for the given column (this includes the table\n+     * alias prefix, if any).\n+     */\n+    public String getColumnAlias(Column col);\n+\n+    /**\n+     * Return the alias to use for the given column (this includes the table\n+     * alias prefix, if any).\n+     */\n+    public String getColumnAlias(String col, Table table);\n+\n+    /**\n+     * Transform the given value into its datastore equivalent.\n+     */\n+    public Object toDataStoreValue(Object val);\n+\n+    /**\n+     * Return true if this value represents a literal or parameter.\n+     */\n+    public boolean isConstant();\n+\n+    /**\n+     * If this is a constant, return its value, else return null.\n+     */\n+    public Object getValue();\n+\n+    /**\n+     * If this is a constant, returns its value as it would be represented\n+     * in the database in this context, else return null.\n+     */\n+    public Object getSQLValue();\n+\n+    /**\n+     * Return true if this value represents a persistent field traversal,\n+     * such as 'this', 'address.street', or 'projectVariable.title'.\n+     */\n+    public boolean isPath();\n+\n+    /**\n+     * If this is a path to a persistent object, return its class mapping,\n+     * else return null.\n+     */\n+    public ClassMapping getClassMapping();\n+\n+    /**\n+     * If this is a path to a persistent field, return its mapping, else\n+     * return null.\n+     */\n+    public FieldMapping getFieldMapping();\n+}"},{"sha":"fc33a1291600ba28dbd5051d960ed157cb7be41a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java","status":"added","additions":101,"deletions":0,"changes":101,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Implementation of {@link FilterValue} that wraps a {@link Val}.\n+ *\n+ * @author Abe White\n+ */\n+class FilterValueImpl\n+    implements FilterValue {\n+\n+    private final Val _val;\n+    private final Select _sel;\n+    private final JDBCStore _store;\n+    private final Object[] _params;\n+    private final JDBCFetchState _fetchState;\n+\n+    public FilterValueImpl(Val val, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        _val = val;\n+        _sel = sel;\n+        _store = store;\n+        _params = params;\n+        _fetchState = fetchState;\n+    }\n+\n+    public Class getType() {\n+        return _val.getType();\n+    }\n+\n+    public int length() {\n+        return _val.length();\n+    }\n+\n+    public void appendTo(SQLBuffer buf) {\n+        appendTo(buf, 0);\n+    }\n+\n+    public void appendTo(SQLBuffer buf, int index) {\n+        _val.appendTo(buf, index, _sel, _store, _params, _fetchState);\n+    }\n+\n+    public String getColumnAlias(Column col) {\n+        return _sel.getColumnAlias(col, _val.getJoins());\n+    }\n+\n+    public String getColumnAlias(String col, Table table) {\n+        return _sel.getColumnAlias(col, table, _val.getJoins());\n+    }\n+\n+    public Object toDataStoreValue(Object val) {\n+        return _val.toDataStoreValue(val, _store);\n+    }\n+\n+    public boolean isConstant() {\n+        return _val instanceof Const;\n+    }\n+\n+    public Object getValue() {\n+        return (isConstant()) ? ((Const) _val).getValue() : null;\n+    }\n+\n+    public Object getSQLValue() {\n+        return (isConstant()) ? ((Const) _val).getSQLValue() : null;\n+    }\n+\n+    public boolean isPath() {\n+        return _val instanceof PCPath;\n+    }\n+\n+    public ClassMapping getClassMapping() {\n+        return (isPath()) ? ((PCPath) _val).getClassMapping() : null;\n+    }\n+\n+    public FieldMapping getFieldMapping() {\n+        return (isPath()) ? ((PCPath) _val).getFieldMapping() : null;\n+    }\n+}"},{"sha":"45ce6f92e912a1641ecb1e6533fd9533d1996eaa","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetColumn.java","status":"added","additions":80,"deletions":0,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetColumn.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetColumn.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UnsupportedException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Returns the SQL alias of the named column for use in a query. Note that\n+ * to retrieve columns in the table of the candidate object, you must\n+ * explicitly qualify the extension with <code>this</code>, as demonstrated\n+ * in the second example below.\n+ *  Examples:<br />\n+ * <code> \"company.address.ext:getColumn (\\\"ID\\\") == 5\"<br />\n+ * \"this.ext:getColumn (\\\"CLS\\\") == \\\"org.apache.openjpa.example.Person\\\"\"\n+ * </code>\n+ *\n+ * @nojavadoc\n+ */\n+public class GetColumn\n+    implements JDBCFilterListener {\n+\n+    public static final String TAG = \"getColumn\";\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (GetColumn.class);\n+\n+    public String getTag() {\n+        return TAG;\n+    }\n+\n+    public boolean expectsArguments() {\n+        return true;\n+    }\n+\n+    public boolean expectsTarget() {\n+        return true;\n+    }\n+\n+    public Object evaluate(Object target, Class targetClass, Object[] args,\n+        Class[] argClasses, Object candidate, StoreContext ctx) {\n+        throw new UnsupportedException(_loc.get(\"no-in-mem\", TAG));\n+    }\n+\n+    public void appendTo(SQLBuffer buf, FilterValue target,\n+        FilterValue[] args, ClassMapping type, JDBCStore store) {\n+        if (!args[0].isConstant())\n+            throw new UserException(_loc.get(\"const-only\", TAG));\n+        if (!target.isPath())\n+            throw new UserException(_loc.get(\"path-only\", TAG));\n+\n+        // alias the column using the target's context, so that the\n+        // correct relation path to the target is used\n+        ClassMapping mapping = target.getClassMapping();\n+        String colName = args[0].getValue().toString();\n+        buf.append(target.getColumnAlias(colName, mapping.getTable()));\n+    }\n+\n+    public Class getType(Class targetClass, Class[] argClasses) {\n+        return Object.class;\n+    }\n+}"},{"sha":"e3905ec06c4f8574c61bd8dea6387faf473004a2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetObjectId.java","status":"added","additions":184,"deletions":0,"changes":184,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetObjectId.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetObjectId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetObjectId.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.Joinable;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.util.ApplicationIds;\n+import org.apache.openjpa.util.Id;\n+import org.apache.openjpa.util.OpenJPAId;\n+import org.apache.openjpa.util.UserException;\n+import serp.util.Numbers;\n+\n+/**\n+ * Select the oid value of an object; typically used in projections.\n+ *\n+ * @author Abe White\n+ */\n+class GetObjectId\n+    extends AbstractVal\n+    implements Val {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (GetObjectId.class);\n+\n+    private final PCPath _path;\n+    private ClassMetaData _meta = null;\n+\n+    /**\n+     * Constructor. Provide the value whose oid to extract.\n+     */\n+    public GetObjectId(PCPath path) {\n+        _path = path;\n+    }\n+\n+    public Column[] getColumns() {\n+        return _path.getClassMapping().getPrimaryKeyColumns();\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+    }\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    public Class getType() {\n+        return Object.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        _path.initialize(sel, store, false);\n+        _path.joinRelation();\n+\n+        // it's difficult to get calls on non-pc fields to always return null\n+        // without screwing up the SQL, to just don't let users call it on\n+        // non-pc fields at all\n+        if (_path.getClassMapping() == null\n+            || _path.getClassMapping().getEmbeddingMapping() != null)\n+            throw new UserException(_loc.get(\"bad-getobjectid\",\n+                _path.getFieldMapping()));\n+    }\n+\n+    public Joins getJoins() {\n+        return _path.getJoins();\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        // if datastore identity, try to convert to a long value\n+        ClassMapping mapping = _path.getClassMapping();\n+        if (mapping.getIdentityType() == mapping.ID_DATASTORE) {\n+            if (val instanceof Id)\n+                return Numbers.valueOf(((Id) val).getId());\n+            return Filters.convert(val, long.class);\n+        }\n+\n+        // if unknown identity, can't do much\n+        if (mapping.getIdentityType() == mapping.ID_UNKNOWN)\n+            return (val instanceof OpenJPAId) ?\n+                ((OpenJPAId) val).getIdObject() : val;\n+\n+        // application identity; convert to pk values in the same order as\n+        // the mapping's primary key columns will be returned\n+        Object[] pks = ApplicationIds.toPKValues(val, mapping);\n+        if (pks.length == 1)\n+            return pks[0];\n+        if (val == null)\n+            return pks;\n+        while (!mapping.isPrimaryKeyObjectId(false))\n+            mapping = mapping.getJoinablePCSuperclassMapping();\n+\n+        // relies on single-column primary key field mappings\n+        Column[] cols = mapping.getPrimaryKeyColumns();\n+        Object[] ordered = new Object[cols.length];\n+        Joinable join;\n+        for (int i = 0; i < cols.length; i++) {\n+            join = mapping.assertJoinable(cols[i]);\n+            ordered[i] = pks[mapping.getField(join.getFieldIndex()).\n+                getPrimaryKeyIndex()];\n+        }\n+        return ordered;\n+    }\n+\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+        selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _path.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState) {\n+        _path.groupBy(sel, store, params, fetchState);\n+    }\n+\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState) {\n+        _path.orderBy(sel, store, params, asc, fetchState);\n+    }\n+\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState)\n+        throws SQLException {\n+        return _path.load(res, store, true, fetchState);\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _path.hasVariable(var);\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        _path.calculateValue(sel, store, params, null, fetchState);\n+    }\n+\n+    public void clearParameters() {\n+        _path.clearParameters();\n+    }\n+\n+    public int length() {\n+        return _path.length();\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        _path.appendTo(sql, index, sel, store, params, fetchState);\n+    }\n+}\n+"},{"sha":"511e6472b20d33762a9d227aa15ac5af42dd984c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InExpression.java","status":"added","additions":176,"deletions":0,"changes":176,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Tests whether a value is IN a collection.\n+ *\n+ * @author Abe White\n+ */\n+class InExpression\n+    implements Exp {\n+\n+    private final Val _val;\n+    private final Const _const;\n+\n+    /**\n+     * Constructor. Supply the value to test and the constant to obtain\n+     * the parameters from.\n+     */\n+    public InExpression(Val val, Const constant) {\n+        _val = val;\n+        _const = constant;\n+    }\n+\n+    public Const getConst() {\n+        return _const;\n+    }\n+\n+    public Val getValue() {\n+        return _val;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        _val.initialize(sel, store, false);\n+        _const.initialize(sel, store, false);\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        _val.calculateValue(sel, store, params, null, fetchState);\n+        _const.calculateValue(sel, store, params, null, fetchState);\n+\n+        Collection coll = getCollection();\n+        if (coll != null) {\n+            Collection ds = new ArrayList(coll.size());\n+            for (Iterator itr = coll.iterator(); itr.hasNext();)\n+                ds.add(_val.toDataStoreValue(itr.next(), store));\n+            coll = ds;\n+        }\n+\n+        Column[] cols = null;\n+        if (_val instanceof PCPath)\n+            cols = ((PCPath) _val).getColumns();\n+        else if (_val instanceof GetObjectId)\n+            cols = ((GetObjectId) _val).getColumns();\n+\n+        if (coll == null || coll.isEmpty())\n+            buf.append(\"1 <> 1\");\n+        else if (_val.length() == 1)\n+            inContains(buf, sel, store, params, fetchState, coll, cols);\n+        else\n+            orContains(buf, sel, store, params, fetchState, coll, cols);\n+        sel.append(buf, _val.getJoins());\n+\n+        _val.clearParameters();\n+        _const.clearParameters();\n+    }\n+\n+    /**\n+     * Construct an IN clause with the value of the given collection.\n+     */\n+    private void inContains(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState,\n+        Collection coll, Column[] cols) {\n+        _val.appendTo(buf, 0, sel, store, params, fetchState);\n+        buf.append(\" IN (\");\n+\n+        Column col = (cols != null && cols.length == 1) ? cols[0] : null;\n+        for (Iterator itr = coll.iterator(); itr.hasNext();) {\n+            buf.appendValue(itr.next(), col);\n+            if (itr.hasNext())\n+                buf.append(\", \");\n+        }\n+        buf.append(\")\");\n+    }\n+\n+    /**\n+     * If the value to test is a compound key, we can't use IN,\n+     * so create a clause like '(a = b AND c = d) OR (e = f AND g = h) ...'\n+     */\n+    private void orContains(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState, Collection coll,\n+        Column[] cols) {\n+        if (coll.size() > 1)\n+            buf.append(\"(\");\n+\n+        Object[] vals;\n+        int len;\n+        Column col;\n+        for (Iterator itr = coll.iterator(); itr.hasNext();) {\n+            vals = (Object[]) itr.next();\n+\n+            buf.append(\"(\");\n+            for (int i = 0; i < vals.length; i++) {\n+                col = (cols != null && cols.length == vals.length)\n+                    ? cols[i] : null;\n+                if (i > 0)\n+                    buf.append(\" AND \");\n+\n+                _val.appendTo(buf, i, sel, store, params, fetchState);\n+                if (vals[i] == null)\n+                    buf.append(\" IS \");\n+                else\n+                    buf.append(\" = \");\n+                buf.appendValue(vals[i], col);\n+            }\n+            buf.append(\")\");\n+\n+            if (itr.hasNext())\n+                buf.append(\" OR \");\n+        }\n+        if (coll.size() > 1)\n+            buf.append(\")\");\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val.selectColumns(sel, store, params, true, fetchState);\n+        _const.selectColumns(sel, store, params, pks, fetchState);\n+    }\n+\n+    public Joins getJoins() {\n+        return _val.getJoins();\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return false;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _const.hasVariable(var) || _val.hasVariable(var);\n+    }\n+\n+    /**\n+     * Return the collection to test for containment with.\n+     */\n+    protected Collection getCollection() {\n+        return (Collection) _const.getValue();\n+    }\n+}"},{"sha":"39cec1b375826ceb8d98b7e0288754b6981057aa","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InKeyExpression.java","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InKeyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InKeyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InKeyExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+/**\n+ * Tests whether a value is IN a map key set.\n+ *\n+ * @author Abe White\n+ */\n+class InKeyExpression\n+    extends InExpression {\n+\n+    /**\n+     * Constructor. Supply the value to test and the constant to obtain\n+     * the parameters from.\n+     */\n+    public InKeyExpression(Val val, Const constant) {\n+        super(val, constant);\n+    }\n+\n+    /**\n+     * Return the collection to test for containment with.\n+     */\n+    protected Collection getCollection() {\n+        Map map = (Map) getConst().getValue();\n+        return (map == null) ? null : map.keySet();\n+    }\n+}"},{"sha":"49f6a20b258efcaad186430e3a95b6bf17539ab1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InSubQExpression.java","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InSubQExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InSubQExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InSubQExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Tests whether a value is IN a subquery.\n+ *\n+ * @author Abe White\n+ */\n+class InSubQExpression\n+    implements Exp {\n+\n+    private final Val _val;\n+    private final SubQ _sub;\n+\n+    /**\n+     * Constructor. Supply the value to test and the subquery.\n+     */\n+    public InSubQExpression(Val val, SubQ sub) {\n+        _val = val;\n+        _sub = sub;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        _val.initialize(sel, store, false);\n+        _sub.initialize(sel, store, false);\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        _val.calculateValue(sel, store, params, null, fetchState);\n+        _sub.calculateValue(sel, store, params, null, fetchState);\n+        _val.appendTo(buf, 0, sel, store, params, fetchState);\n+        buf.append(\" IN \");\n+        _sub.appendTo(buf, 0, sel, store, params, fetchState);\n+        _val.clearParameters();\n+        _sub.clearParameters();\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val.selectColumns(sel, store, params, true, fetchState);\n+        _sub.selectColumns(sel, store, params, pks, fetchState);\n+    }\n+\n+    public Joins getJoins() {\n+        return _val.getJoins();\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return false;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _val.hasVariable(var) || _sub.hasVariable(var);\n+    }\n+}"},{"sha":"d9f0d94653dd8a10c13a380b90e7bc7ad9ef3b80","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InValueExpression.java","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InValueExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InValueExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InValueExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+/**\n+ * Tests whether a value is IN a map value collection.\n+ *\n+ * @author Abe White\n+ */\n+class InValueExpression\n+    extends InExpression {\n+\n+    /**\n+     * Constructor. Supply the value to test and the constant to obtain\n+     * the parameters from.\n+     */\n+    public InValueExpression(Val val, Const constant) {\n+        super(val, constant);\n+    }\n+\n+    /**\n+     * Return the collection to test for containment with.\n+     */\n+    protected Collection getCollection() {\n+        Map map = (Map) getConst().getValue();\n+        return (map == null) ? null : map.values();\n+    }\n+}"},{"sha":"391be34676994dd22cf798f11375a6c3311736c2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IndexOf.java","status":"added","additions":163,"deletions":0,"changes":163,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IndexOf.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IndexOf.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IndexOf.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Find the index of one string within another.\n+ *\n+ * @author Abe White\n+ */\n+class IndexOf\n+    extends AbstractVal\n+    implements Val {\n+\n+    private final Val _val1;\n+    private final Val _val2;\n+    private Joins _joins = null;\n+    private ClassMetaData _meta = null;\n+    private Class _cast = null;\n+\n+    /**\n+     * Constructor. Provide the strings to operate on.\n+     */\n+    public IndexOf(Val val1, Val val2) {\n+        _val1 = val1;\n+        _val2 = val2;\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+    }\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    public Class getType() {\n+        if (_cast != null)\n+            return _cast;\n+        return int.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _cast = type;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        _val1.initialize(sel, store, false);\n+        _val2.initialize(sel, store, false);\n+        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return val;\n+    }\n+\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+        sel.select(newSQLBuffer(sel, store, params, fetchState), this);\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val1.selectColumns(sel, store, params, true, fetchState);\n+        _val2.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState) {\n+        sel.groupBy(newSQLBuffer(sel, store, params, fetchState), false);\n+    }\n+\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState) {\n+        sel.orderBy(newSQLBuffer(sel, store, params, fetchState), asc, false);\n+    }\n+\n+    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        calculateValue(sel, store, params, null, fetchState);\n+        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n+        appendTo(buf, 0, sel, store, params, fetchState);\n+        clearParameters();\n+        return buf;\n+    }\n+\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState)\n+        throws SQLException {\n+        return Filters.convert(res.getObject(this,\n+            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _val1.hasVariable(var) || _val2.hasVariable(var);\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        _val1.calculateValue(sel, store, params, null, fetchState);\n+        _val2.calculateValue(sel, store, params, null, fetchState);\n+    }\n+\n+    public void clearParameters() {\n+        _val1.clearParameters();\n+        _val2.clearParameters();\n+    }\n+\n+    public int length() {\n+        return 1;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        FilterValue str = new FilterValueImpl(_val1, sel, store, params,\n+            fetchState);\n+        FilterValue search;\n+        FilterValue start = null;\n+        if (_val2 instanceof Args) {\n+            Val[] args = ((Args) _val2).getVals();\n+            search =\n+                new FilterValueImpl(args[0], sel, store, params, fetchState);\n+            start =\n+                new FilterValueImpl(args[1], sel, store, params, fetchState);\n+        } else\n+            search = new FilterValueImpl(_val2, sel, store, params, fetchState);\n+\n+        store.getDBDictionary().indexOf(sql, str, search, start);\n+    }\n+}\n+"},{"sha":"ee6d4caec2e2f16da419e6b0bd390ee66351396c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InstanceofExpression.java","status":"added","additions":154,"deletions":0,"changes":154,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InstanceofExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InstanceofExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InstanceofExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.Discriminator;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.MappingRepository;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.meta.JavaTypes;\n+\n+/**\n+ * Tests whether the given path is an instance of the given class.\n+ *\n+ * @author Abe White\n+ */\n+class InstanceofExpression\n+    implements Exp {\n+\n+    private final PCPath _path;\n+    private final Class _cls;\n+    private Joins _joins = null;\n+    private Discriminator _dsc = null;\n+    private Class _relCls = null;\n+    private ClassMapping _mapping = null;\n+\n+    /**\n+     * Constructor. Supply path and class to test for.\n+     */\n+    public InstanceofExpression(PCPath path, Class cls) {\n+        _path = path;\n+        _cls = cls;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        // note that we tell the path to go ahead and join to its related\n+        // object (if any) in order to access its class indicator\n+        _path.initialize(sel, store, false);\n+        _path.joinRelation();\n+        _joins = _path.getJoins();\n+\n+        // does this path represent a relation?  if not, what class\n+        // is the field?\n+        ClassMapping rel = _path.getClassMapping();\n+        if (rel == null) {\n+            FieldMapping field = _path.getFieldMapping();\n+            switch (field.getTypeCode()) {\n+                case JavaTypes.MAP:\n+                    if (_path.isKey())\n+                        _relCls = field.getKey().getDeclaredType();\n+                    // no break\n+                case JavaTypes.ARRAY:\n+                case JavaTypes.COLLECTION:\n+                    _relCls = field.getElement().getDeclaredType();\n+                    break;\n+                default:\n+                    _relCls = field.getDeclaredType();\n+            }\n+        } else\n+            _relCls = rel.getDescribedType();\n+\n+        // if the path represents a relation, get its class indicator and\n+        // make sure it's joined down to its base type\n+        _dsc = (rel == null || !rel.getDescribedType().isAssignableFrom(_cls))\n+            ? null : rel.getDiscriminator();\n+        if (_dsc != null) {\n+            // cache mapping for cast\n+            MappingRepository repos = store.getConfiguration().\n+                getMappingRepository();\n+            _mapping = repos.getMapping(_cls, store.getContext().\n+                getClassLoader(), false);\n+\n+            // if not looking for a PC, don't bother with indicator\n+            if (_mapping == null)\n+                _dsc = null;\n+            else {\n+                ClassMapping owner = _dsc.getClassMapping();\n+                ClassMapping from, to;\n+                if (rel.getDescribedType().isAssignableFrom\n+                    (owner.getDescribedType())) {\n+                    from = owner;\n+                    to = rel;\n+                } else {\n+                    from = rel;\n+                    to = owner;\n+                }\n+\n+                for (; from != null && from != to;\n+                    from = from.getJoinablePCSuperclassMapping())\n+                    _joins = from.joinSuperclass(_joins, false);\n+            }\n+        }\n+    }\n+\n+    public void appendTo(SQLBuffer sql, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        // if no class indicator or a final class, just append true or false\n+        // depending on whether the cast matches the expected type\n+        if (_dsc == null) {\n+            if (_cls.isAssignableFrom(_relCls))\n+                sql.append(\"1 = 1\");\n+            else\n+                sql.append(\"1 <> 1\");\n+        } else {\n+            store.loadSubclasses(_dsc.getClassMapping());\n+            SQLBuffer buf = _dsc.getClassConditions(store, sel, _joins,\n+                _mapping, true);\n+            if (buf == null)\n+                sql.append(\"1 = 1\");\n+            else\n+                sql.append(buf);\n+        }\n+        sel.append(sql, _joins);\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        if (_dsc != null)\n+            sel.select(_dsc.getColumns(), _joins);\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return false;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _path.hasVariable(var);\n+    }\n+}\n+"},{"sha":"556fc4dcb05ecfdaa197b95ba59da44b527fa5ab","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsEmptyExpression.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsEmptyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsEmptyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsEmptyExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Tests whether the given value is empty.\n+ *\n+ * @author Abe White\n+ */\n+class IsEmptyExpression\n+    implements Exp {\n+\n+    private final Val _val;\n+\n+    /**\n+     * Constructor. Supply value to test.\n+     */\n+    public IsEmptyExpression(Val val) {\n+        _val = val;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        _val.initialize(sel, store, true);\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        _val.calculateValue(sel, store, params, null, fetchState);\n+        _val.appendIsEmpty(buf, sel, store, params, fetchState);\n+        sel.append(buf, _val.getJoins());\n+        _val.clearParameters();\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public Joins getJoins() {\n+        return _val.getJoins();\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return false;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _val.hasVariable(var);\n+    }\n+}"},{"sha":"48a90f4ade64182b68840e092a09458371be07e9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsNotEmptyExpression.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsNotEmptyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsNotEmptyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsNotEmptyExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Tests whether the given value is not empty.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class IsNotEmptyExpression\n+    implements Exp {\n+\n+    private final Val _val;\n+\n+    /**\n+     * Constructor. Supply value to test.\n+     */\n+    public IsNotEmptyExpression(Val val) {\n+        _val = val;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        _val.initialize(sel, store, true);\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        _val.calculateValue(sel, store, params, null, fetchState);\n+        _val.appendIsNotEmpty(buf, sel, store, params, fetchState);\n+        sel.append(buf, _val.getJoins());\n+        _val.clearParameters();\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public Joins getJoins() {\n+        return _val.getJoins();\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return false;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _val.hasVariable(var);\n+    }\n+}"},{"sha":"2a6af2e7aeecc50ce74693b15605aefbb3a8e5af","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCAggregateListener.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCAggregateListener.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCAggregateListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCAggregateListener.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.kernel.exps.AggregateListener;\n+\n+/**\n+ * JDBC extension to the {@link AggregateListener}.\n+ *\n+ * @author Abe White\n+ */\n+public interface JDBCAggregateListener\n+    extends AggregateListener {\n+\n+    /**\n+     * Append the SQL for this aggregate.\n+     *\n+     * @param buf the SQL buffer to append to\n+     * @param args the values of the arguments given in the filter, or\n+     * null if this listener doesn't expect arguments\n+     * @param mapping the class mapping for the query's candidate class\n+     * @param store the store that owns the query\n+     */\n+    public void appendTo(SQLBuffer buf, FilterValue[] args,\n+        ClassMapping mapping, JDBCStore store);\n+}"},{"sha":"92d92228cf88f1116e26e4d71ae7e41328e5a789","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","status":"added","additions":450,"deletions":0,"changes":450,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,450 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.commons.collections.map.LinkedMap;\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStoreQuery;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.exps.AggregateListener;\n+import org.apache.openjpa.kernel.exps.Arguments;\n+import org.apache.openjpa.kernel.exps.Expression;\n+import org.apache.openjpa.kernel.exps.ExpressionFactory;\n+import org.apache.openjpa.kernel.exps.FilterListener;\n+import org.apache.openjpa.kernel.exps.Literal;\n+import org.apache.openjpa.kernel.exps.Parameter;\n+import org.apache.openjpa.kernel.exps.Path;\n+import org.apache.openjpa.kernel.exps.QueryExpressions;\n+import org.apache.openjpa.kernel.exps.Subquery;\n+import org.apache.openjpa.kernel.exps.Value;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Expression factory implementation that can be used to execute queries\n+ * via SQL.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class JDBCExpressionFactory\n+    implements ExpressionFactory {\n+\n+    private static final int CACHE_NULL = 0;\n+    private static final int CACHE_JOINS = 1;\n+    private static final int CACHE_FULL = 2;\n+\n+    private static final Val NULL = new Null();\n+    private static final Val CURRENT_DATE =\n+        new CurrentDate(CurrentDate.DATE);\n+    private static final Val CURRENT_TIME =\n+        new CurrentDate(CurrentDate.TIME);\n+    private static final Val CURRENT_TIMESTAMP =\n+        new CurrentDate(CurrentDate.TIMESTAMP);\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (JDBCExpressionFactory.class);\n+\n+    private final ClassMapping _type;\n+    private final SelectConstructor _cons = new SelectConstructor();\n+\n+    /**\n+     * Constructor. Supply the type we're querying against.\n+     */\n+    public JDBCExpressionFactory(ClassMapping type) {\n+        _type = type;\n+    }\n+\n+    /**\n+     * Evaluate the expression, returning a SQL select with the proper\n+     * conditions. Use {@link #select} to then select the data.\n+     * This method returns null if there is no query criteria. It is\n+     * synchronized because factories may be cached and used by multiple\n+     * queries at the same time.\n+     */\n+    public synchronized Select evaluate(JDBCStoreQuery q,\n+        JDBCFetchState fetchState, QueryExpressions exps, Object[] params) {\n+        // figure out proper cache level based on parameters\n+        int level = getCacheLevel(q, params);\n+        return _cons.evaluate(q.getStore(), null, null, exps, params,\n+            level, fetchState);\n+    }\n+\n+    /**\n+     * Return the cache level for this query. The level depends on whether\n+     * the query uses any params, as well as the types and values of those\n+     * params.\n+     */\n+    private int getCacheLevel(JDBCStoreQuery q, Object[] params) {\n+        // if there are no parameters, we can cache the full SQL\n+        if (params.length == 0)\n+            return SelectConstructor.CACHE_FULL;\n+\n+        // if there is a null PC parameter, we have to cache differently\n+        // since it affects joins\n+        LinkedMap types = null;\n+        Class type;\n+        for (int i = 0; i < params.length; i++) {\n+            if (params[i] != null)\n+                continue;\n+\n+            if (types == null)\n+                types = q.getContext().getParameterTypes();\n+\n+            type = (Class) types.getValue(i);\n+            if (type != null && ImplHelper.isManagedType(type))\n+                return SelectConstructor.CACHE_NULL;\n+        }\n+        return SelectConstructor.CACHE_JOINS;\n+    }\n+\n+    /**\n+     * Select the data for this query.\n+     */\n+    public void select(JDBCStoreQuery q, ClassMapping mapping,\n+        boolean subclasses, Select sel, QueryExpressions exps,\n+        Object[] params, JDBCFetchState fetchState, int eager) {\n+        _cons.select(q.getStore(), mapping, subclasses, sel, exps,\n+            params, fetchState, eager);\n+    }\n+\n+    public Expression emptyExpression() {\n+        return new EmptyExpression();\n+    }\n+\n+    public Expression asExpression(Value v) {\n+        return equal(v, newLiteral(Boolean.TRUE, Literal.TYPE_BOOLEAN));\n+    }\n+\n+    public Expression equal(Value v1, Value v2) {\n+        // if we're comparing an unaccessed bound variable, like in:\n+        // coll.contains (var) && var == x, then translate into:\n+        // coll.contains (x)\n+        if (v1 instanceof PCPath && ((PCPath) v1).isUnaccessedVariable())\n+            return contains(v1, v2);\n+        if (v2 instanceof PCPath && ((PCPath) v2).isUnaccessedVariable())\n+            return contains(v2, v1);\n+        return new EqualExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression notEqual(Value v1, Value v2) {\n+        return new NotEqualExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression lessThan(Value v1, Value v2) {\n+        return new CompareExpression((Val) v1, (Val) v2,\n+            CompareExpression.LESS);\n+    }\n+\n+    public Expression greaterThan(Value v1, Value v2) {\n+        return new CompareExpression((Val) v1, (Val) v2,\n+            CompareExpression.GREATER);\n+    }\n+\n+    public Expression lessThanEqual(Value v1, Value v2) {\n+        return new CompareExpression((Val) v1, (Val) v2,\n+            CompareExpression.LESS_EQUAL);\n+    }\n+\n+    public Expression greaterThanEqual(Value v1, Value v2) {\n+        return new CompareExpression((Val) v1, (Val) v2,\n+            CompareExpression.GREATER_EQUAL);\n+    }\n+\n+    public Expression isEmpty(Value val) {\n+        return new IsEmptyExpression((Val) val);\n+    }\n+\n+    public Expression isNotEmpty(Value val) {\n+        return new IsNotEmptyExpression((Val) val);\n+    }\n+\n+    public Expression contains(Value v1, Value v2) {\n+        if (v1 instanceof Const)\n+            return new InExpression((Val) v2, (Const) v1);\n+        if (v1 instanceof SubQ)\n+            return new InSubQExpression((Val) v2, (SubQ) v1);\n+        return new ContainsExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression containsKey(Value v1, Value v2) {\n+        if (v1 instanceof Const)\n+            return new InKeyExpression((Val) v2, (Const) v1);\n+        return new ContainsKeyExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression containsValue(Value v1, Value v2) {\n+        if (v1 instanceof Const)\n+            return new InValueExpression((Val) v2, (Const) v1);\n+        return new ContainsExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression isInstance(Value val, Class c) {\n+        if (val instanceof Const)\n+            return new ConstInstanceofExpression((Const) val, c);\n+        return new InstanceofExpression((PCPath) val, c);\n+    }\n+\n+    public Expression and(Expression exp1, Expression exp2) {\n+        if (exp1 instanceof BindVariableExpression)\n+            return new BindVariableAndExpression((BindVariableExpression) exp1,\n+                (Exp) exp2);\n+        if (exp2 instanceof BindVariableExpression)\n+            return new BindVariableAndExpression((BindVariableExpression) exp2,\n+                (Exp) exp1);\n+        return new AndExpression((Exp) exp1, (Exp) exp2);\n+    }\n+\n+    public Expression or(Expression exp1, Expression exp2) {\n+        return new OrExpression((Exp) exp1, (Exp) exp2);\n+    }\n+\n+    public Expression not(Expression exp) {\n+        Exp e = (Exp) exp;\n+        if (e.hasContainsExpression())\n+            return new NotContainsExpression(e);\n+        return new NotExpression(e);\n+    }\n+\n+    public Expression bindVariable(Value var, Value val) {\n+        // handle the strange case of using a constant path to bind a\n+        // variable; in these cases the variable acts like an unbound\n+        // variable that we limit by using an IN clause on the constant\n+        // value collection\n+        if (val instanceof Const) {\n+            PCPath path = new PCPath(_type, (Variable) var);\n+            path.setMetaData(var.getMetaData());\n+            return new InExpression(path, (Const) val);\n+        }\n+        return new BindVariableExpression((Variable) var, (PCPath) val, false);\n+    }\n+\n+    public Expression bindKeyVariable(Value var, Value val) {\n+        // handle the strange case of using a constant path to bind a\n+        // variable; in these cases the variable acts like an unbound\n+        // variable that we limit by using an IN clause on the constant\n+        // value collection\n+        if (val instanceof Const) {\n+            PCPath path = new PCPath(_type, (Variable) var);\n+            path.setMetaData(var.getMetaData());\n+            return new InKeyExpression(path, (Const) val);\n+        }\n+        return new BindVariableExpression((Variable) var, (PCPath) val, true);\n+    }\n+\n+    public Expression bindValueVariable(Value var, Value val) {\n+        return bindVariable(var, val);\n+    }\n+\n+    public Expression startsWith(Value v1, Value v2) {\n+        return new StartsWithExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression endsWith(Value v1, Value v2) {\n+        return new EndsWithExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression notMatches(Value v1, Value v2,\n+        String single, String multi, String esc) {\n+        return not(matches(v1, v2, single, multi, esc));\n+    }\n+\n+    public Expression matches(Value v1, Value v2,\n+        String single, String multi, String esc) {\n+        if (!(v2 instanceof Const))\n+            throw new UserException(_loc.get(\"const-only\", \"matches\"));\n+        return new MatchesExpression((Val) v1, (Const) v2, single, multi,\n+            esc != null ? esc : _type.getMappingRepository().\n+                getDBDictionary().searchStringEscape);\n+    }\n+\n+    public Subquery newSubquery(ClassMetaData candidate, boolean subs,\n+        String alias) {\n+        DBDictionary dict = _type.getMappingRepository().getDBDictionary();\n+        dict.assertSupport(dict.supportsSubselect, \"SupportsSubselect\");\n+        return new SubQ((ClassMapping) candidate, subs, alias);\n+    }\n+\n+    public Path newPath() {\n+        return new PCPath(_type);\n+    }\n+\n+    public Path newPath(Value val) {\n+        if (val instanceof Const)\n+            return new ConstPath((Const) val);\n+        if (val instanceof SubQ)\n+            return new PCPath((SubQ) val);\n+        return new PCPath(_type, (Variable) val);\n+    }\n+\n+    public Literal newLiteral(Object val, int ptype) {\n+        return new Lit(val, ptype);\n+    }\n+\n+    public Value getThis() {\n+        return new PCPath(_type);\n+    }\n+\n+    public Value getNull() {\n+        return NULL;\n+    }\n+\n+    public Value getCurrentDate() {\n+        return CURRENT_DATE;\n+    }\n+\n+    public Value getCurrentTime() {\n+        return CURRENT_TIME;\n+    }\n+\n+    public Value getCurrentTimestamp() {\n+        return CURRENT_TIMESTAMP;\n+    }\n+\n+    public Parameter newParameter(String name, Class type) {\n+        return new Param(name, type);\n+    }\n+\n+    public Value newExtension(FilterListener listener, Value target,\n+        Value arg) {\n+        return new Extension((JDBCFilterListener) listener,\n+            (Val) target, (Val) arg, _type);\n+    }\n+\n+    public Value newAggregate(AggregateListener listener, Value arg) {\n+        return new Aggregate((JDBCAggregateListener) listener,\n+            (Val) arg, _type);\n+    }\n+\n+    public Arguments newArgumentList(Value v1, Value v2) {\n+        return new Args((Val) v1, (Val) v2);\n+    }\n+\n+    public Value newUnboundVariable(String name, Class type) {\n+        return new Variable(name, type);\n+    }\n+\n+    public Value newBoundVariable(String name, Class type) {\n+        return newUnboundVariable(name, type);\n+    }\n+\n+    public Value cast(Value val, Class cls) {\n+        val.setImplicitType(cls);\n+        return val;\n+    }\n+\n+    public Value add(Value v1, Value v2) {\n+        return new Math((Val) v1, (Val) v2, Math.ADD);\n+    }\n+\n+    public Value subtract(Value v1, Value v2) {\n+        return new Math((Val) v1, (Val) v2, Math.SUBTRACT);\n+    }\n+\n+    public Value multiply(Value v1, Value v2) {\n+        return new Math((Val) v1, (Val) v2, Math.MULTIPLY);\n+    }\n+\n+    public Value divide(Value v1, Value v2) {\n+        return new Math((Val) v1, (Val) v2, Math.DIVIDE);\n+    }\n+\n+    public Value mod(Value v1, Value v2) {\n+        return new Math((Val) v1, (Val) v2, Math.MOD);\n+    }\n+\n+    public Value abs(Value val) {\n+        return new Abs((Val) val);\n+    }\n+\n+    public Value indexOf(Value v1, Value v2) {\n+        return new IndexOf((Val) v1, (Val) v2);\n+    }\n+\n+    public Value concat(Value v1, Value v2) {\n+        return new Concat((Val) v1, (Val) v2);\n+    }\n+\n+    public Value stringLength(Value str) {\n+        return new StringLength((Val) str);\n+    }\n+\n+    public Value trim(Value str, Value trimChar, Boolean where) {\n+        return new Trim((Val) str, (Val) trimChar, where);\n+    }\n+\n+    public Value sqrt(Value val) {\n+        return new Sqrt((Val) val);\n+    }\n+\n+    public Value substring(Value v1, Value v2) {\n+        return new Substring((Val) v1, (Val) v2);\n+    }\n+\n+    public Value toUpperCase(Value val) {\n+        return new ToUpperCase((Val) val);\n+    }\n+\n+    public Value toLowerCase(Value val) {\n+        return new ToLowerCase((Val) val);\n+    }\n+\n+    public Value avg(Value val) {\n+        return new Avg((Val) val);\n+    }\n+\n+    public Value count(Value val) {\n+        return new Count((Val) val);\n+    }\n+\n+    public Value distinct(Value val) {\n+        return new Distinct((Val) val);\n+    }\n+\n+    public Value max(Value val) {\n+        return new Max((Val) val);\n+    }\n+\n+    public Value min(Value val) {\n+        return new Min((Val) val);\n+    }\n+\n+    public Value sum(Value val) {\n+        return new Sum((Val) val);\n+    }\n+\n+    public Value any(Value val) {\n+        return new Any((Val) val);\n+    }\n+\n+    public Value all(Value val) {\n+        return new All((Val) val);\n+    }\n+\n+    public Value size(Value val) {\n+        return new Size((Val) val);\n+    }\n+\n+    public Value getObjectId(Value val) {\n+        if (val instanceof Const)\n+            return new ConstGetObjectId((Const) val);\n+        return new GetObjectId((PCPath) val);\n+    }\n+}"},{"sha":"938e28e6e8d1addd32454899c50e11bb64243a9f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCFilterListener.java","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCFilterListener.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCFilterListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCFilterListener.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.kernel.exps.FilterListener;\n+\n+/**\n+ * JDBC extension to the {@link FilterListener}.\n+ *\n+ * @author Abe White\n+ */\n+public interface JDBCFilterListener\n+    extends FilterListener {\n+\n+    /**\n+     * Append the SQL for this expression or value.\n+     *\n+     * @param buf the SQL buffer to append to\n+     * @param target the target to act on, or null if the listener\n+     * doesn't expect a target\n+     * @param args the values of the arguments given in the filter, or\n+     * null if this listener doesn't expect arguments\n+     * @param mapping the class mapping for the query's candidate class\n+     * @param store the store that owns the query\n+     */\n+    public void appendTo(SQLBuffer buf, FilterValue target, FilterValue[] args,\n+        ClassMapping mapping, JDBCStore store);\n+}"},{"sha":"8fdd458a953117589a34df5a6fda56bfbf12eaa4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCPath.java","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCPath.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCPath.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,29 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.kernel.exps.Path;\n+\n+/**\n+ * A path represents a traversal into fields of a candidate object.\n+ *\n+ * @author Abe White\n+ */\n+interface JDBCPath\n+    extends Path, Val {\n+\n+    public void getKey();\n+}"},{"sha":"4534656e1783b5224abafc0bbbd0e9eace20de2e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCStringContains.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCStringContains.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCStringContains.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCStringContains.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.kernel.exps.StringContains;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Tests if the target contains the given argument. The argument must be\n+ * a constant.\n+ *  Examples:<br />\n+ * <code> \"address.street.ext:stringContains (\\\"main\\\")\"\n+ * </code>\n+ *\n+ * @nojavadoc\n+ * @deprecated Use <code>matches()</code> instead.\n+ */\n+public class JDBCStringContains\n+    extends StringContains\n+    implements JDBCFilterListener {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (JDBCStringContains.class);\n+\n+    public void appendTo(SQLBuffer buf, FilterValue target, FilterValue[] args,\n+        ClassMapping type, JDBCStore store) {\n+        if (!args[0].isConstant())\n+            throw new UserException(_loc.get(\"const-only\", TAG));\n+\n+        Object val = args[0].getValue();\n+        target.appendTo(buf);\n+        if (val == null)\n+            buf.append(\" IS \").appendValue(null);\n+        else\n+            buf.append(\" LIKE \").appendValue(\"%\" + val + \"%\");\n+    }\n+}"},{"sha":"377f352587e39bf5932b7c896a73e3c3362f0ede","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCWildcardMatch.java","status":"added","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCWildcardMatch.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCWildcardMatch.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCWildcardMatch.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.kernel.exps.WildcardMatch;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Tests if the target matches the wildcard expression given in the\n+ * argument. The wildcard '?' is used to represent any single character,\n+ * while '*' is used to represent any series of 0 or more characters.\n+ *  Examples:<br />\n+ * <code> \"address.street.ext:wildcardMatch (\\\"?ain*reet\\\")\"\n+ * </code>\n+ *\n+ * @nojavadoc\n+ * @deprecated Use <code>matches()</code> instead.\n+ */\n+public class JDBCWildcardMatch\n+    extends WildcardMatch\n+    implements JDBCFilterListener {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (JDBCWildcardMatch.class);\n+\n+    public void appendTo(SQLBuffer sql, FilterValue target, FilterValue[] args,\n+        ClassMapping type, JDBCStore store) {\n+        if (!args[0].isConstant())\n+            throw new UserException(_loc.get(\"const-only\", TAG));\n+\n+        Object val = args[0].getValue();\n+        target.appendTo(sql);\n+        if (val == null)\n+            sql.append(\" IS \").appendValue(null);\n+        else {\n+            // create a DB wildcard string by replacing '*' with '%' and\n+            // '?' with '_'\n+            String wild = val.toString().replace('*', '%').replace('?', '_');\n+            sql.append(\" LIKE \").appendValue(wild);\n+        }\n+    }\n+}"},{"sha":"7a2e07d20f5360fb5ca9a08d93b2fc21303b2dde","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.exps.Literal;\n+\n+/**\n+ * A literal value in a filter.\n+ *\n+ * @author Abe White\n+ */\n+class Lit\n+    extends Const\n+    implements Literal {\n+\n+    private Object _val;\n+    private int _ptype;\n+    private Object _sqlVal = null;\n+    private int _otherLen = 0;\n+\n+    /**\n+     * Constructor. Supply literal value.\n+     */\n+    public Lit(Object val, int ptype) {\n+        _val = val;\n+        _ptype = ptype;\n+    }\n+\n+    public Class getType() {\n+        return (_val == null) ? Object.class : _val.getClass();\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _val = Filters.convert(_val, type);\n+    }\n+\n+    public int getParseType() {\n+        return _ptype;\n+    }\n+\n+    public Object getValue() {\n+        return _val;\n+    }\n+\n+    public void setValue(Object val) {\n+        _val = val;\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        super.calculateValue(sel, store, params, other, fetchState);\n+        if (other != null) {\n+            _sqlVal = other.toDataStoreValue(_val, store);\n+            _otherLen = other.length();\n+        } else\n+            _sqlVal = _val;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        if (_otherLen > 1)\n+            sql.appendValue(((Object[]) _sqlVal)[index], getColumn(index));\n+        else\n+            sql.appendValue(_sqlVal, getColumn(index));\n+    }\n+\n+    public void clearParameters() {\n+    }\n+}"},{"sha":"dc7c8fd38dd3d47c6942a3a3f598c414d1d720c6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MatchesExpression.java","status":"added","additions":133,"deletions":0,"changes":133,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MatchesExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MatchesExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MatchesExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,133 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import serp.util.Strings;\n+\n+/**\n+ * Test if a string matches a regexp.\n+ *\n+ * @author Abe White\n+ */\n+class MatchesExpression\n+    implements Exp {\n+\n+    private final Val _val;\n+    private final Const _const;\n+    private final String _single;\n+    private final String _multi;\n+    private final String _escape;\n+    private Joins _joins = null;\n+\n+    /**\n+     * Constructor. Supply values.\n+     */\n+    public MatchesExpression(Val val, Const con,\n+        String single, String multi, String escape) {\n+        _val = val;\n+        _const = con;\n+        _single = single;\n+        _multi = multi;\n+        _escape = escape;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        _val.initialize(sel, store, false);\n+        _const.initialize(sel, store, false);\n+        _joins = sel.and(_val.getJoins(), _const.getJoins());\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        _val.calculateValue(sel, store, params, _const, fetchState);\n+        _const.calculateValue(sel, store, params, _val, fetchState);\n+\n+        Column col = null;\n+        if (_val instanceof PCPath) {\n+            Column[] cols = ((PCPath) _val).getColumns();\n+            if (cols.length == 1)\n+                col = cols[0];\n+        }\n+\n+        Object o = _const.getValue();\n+        if (o == null)\n+            buf.append(\"1 <> 1\");\n+        else {\n+            // look for ignore case flag and strip it out if present\n+            boolean ignoreCase = false;\n+            String str = o.toString();\n+            int idx = str.indexOf(\"(?i)\");\n+            if (idx != -1) {\n+                ignoreCase = true;\n+                if (idx + 4 < str.length())\n+                    str = str.substring(0, idx) + str.substring(idx + 4);\n+                else\n+                    str = str.substring(0, idx);\n+                str = str.toLowerCase();\n+            }\n+\n+            // append target\n+            if (ignoreCase)\n+                buf.append(\"LOWER(\");\n+            _val.appendTo(buf, 0, sel, store, params, fetchState);\n+            if (ignoreCase)\n+                buf.append(\")\");\n+\n+            // create a DB wildcard string by replacing the\n+            // multi token (e.g., '.*') and the single token (e.g., \".\")\n+            // with '%' and '.' with '_'\n+            str = Strings.replace(str, _multi, \"%\");\n+            str = Strings.replace(str, _single, \"_\");\n+\n+            buf.append(\" LIKE \").appendValue(str, col);\n+\n+            // escape out characters by using the database's escape sequence\n+            if (_escape != null)\n+                buf.append(\" ESCAPE '\").append(_escape).append(\"'\");\n+        }\n+        sel.append(buf, _joins);\n+\n+        _val.clearParameters();\n+        _const.clearParameters();\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val.selectColumns(sel, store, params, true, fetchState);\n+        _const.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return false;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _val.hasVariable(var) || _const.hasVariable(var);\n+    }\n+}"},{"sha":"8d9e600dad49ccd9e5d3ca20e75c7e76073ba3f8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java","status":"added","additions":163,"deletions":0,"changes":163,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Value produced by a mathematical operation on two values.\n+ *\n+ * @author Abe White\n+ */\n+class Math\n+    extends AbstractVal\n+    implements Val {\n+\n+    public static final String ADD = \"+\";\n+    public static final String SUBTRACT = \"-\";\n+    public static final String MULTIPLY = \"*\";\n+    public static final String DIVIDE = \"/\";\n+    public static final String MOD = \"MOD\";\n+\n+    private final Val _val1;\n+    private final Val _val2;\n+    private final String _op;\n+    private Joins _joins = null;\n+    private ClassMetaData _meta = null;\n+    private Class _cast = null;\n+\n+    /**\n+     * Constructor. Provide the values to operate on, and the operator.\n+     */\n+    public Math(Val val1, Val val2, String op) {\n+        _val1 = val1;\n+        _val2 = val2;\n+        _op = op;\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+    }\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    public Class getType() {\n+        if (_cast != null)\n+            return _cast;\n+        Class c1 = _val1.getType();\n+        Class c2 = _val2.getType();\n+        return Filters.promote(c1, c2);\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _cast = type;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        boolean nullTest) {\n+        _val1.initialize(sel, store, false);\n+        _val2.initialize(sel, store, false);\n+        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return val;\n+    }\n+\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+        sel.select(newSQLBuffer(sel, store, params, fetchState), this);\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val1.selectColumns(sel, store, params, true, fetchState);\n+        _val2.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState) {\n+        sel.groupBy(newSQLBuffer(sel, store, params, fetchState), false);\n+    }\n+\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState) {\n+        sel.orderBy(newSQLBuffer(sel, store, params, fetchState), asc, false);\n+    }\n+\n+    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        calculateValue(sel, store, params, null, fetchState);\n+        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n+        appendTo(buf, 0, sel, store, params, fetchState);\n+        clearParameters();\n+        return buf;\n+    }\n+\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState)\n+        throws SQLException {\n+        return Filters.convert(res.getObject(this,\n+            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _val1.hasVariable(var) || _val2.hasVariable(var);\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        _val1.calculateValue(sel, store, params, _val2, fetchState);\n+        _val2.calculateValue(sel, store, params, _val1, fetchState);\n+    }\n+\n+    public void clearParameters() {\n+        _val1.clearParameters();\n+        _val2.clearParameters();\n+    }\n+\n+    public int length() {\n+        return 1;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        store.getDBDictionary().mathFunction(sql, _op,\n+            new FilterValueImpl(_val1, sel, store, params, fetchState),\n+            new FilterValueImpl(_val2, sel, store, params, fetchState));\n+    }\n+}\n+"},{"sha":"b7e73a40080f93a66fb123c5aba806d968d1baa3","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Max.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Max.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Max.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Max.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+/**\n+ * Maximum.\n+ *\n+ * @author Abe White\n+ */\n+class Max\n+    extends UnaryOp {\n+\n+    /**\n+     * Constructor. Provide the value to operate on.\n+     */\n+    public Max(Val val) {\n+        super(val);\n+    }\n+\n+    protected String getOperator() {\n+        return \"MAX\";\n+    }\n+\n+    protected boolean isAggregate() {\n+        return true;\n+    }\n+}\n+"},{"sha":"29747e8a88073f07d6524cc739ff0fd963170651","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Min.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Min.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Min.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Min.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+/**\n+ * Minimum.\n+ *\n+ * @author Abe White\n+ */\n+class Min\n+    extends UnaryOp {\n+\n+    /**\n+     * Constructor. Provide the value to operate on.\n+     */\n+    public Min(Val val) {\n+        super(val);\n+    }\n+\n+    protected String getOperator() {\n+        return \"MIN\";\n+    }\n+\n+    protected boolean isAggregate() {\n+        return true;\n+    }\n+}\n+"},{"sha":"dd007626b95f30f80dd05ee280fcfbdb86e4dc36","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Negates a contains expression using a subselect to make sure no\n+ * elements meet the criteria.\n+ *\n+ * @author Abe White\n+ */\n+class NotContainsExpression\n+    implements Exp {\n+\n+    private final Exp _exp;\n+    private Map _contains = null;\n+\n+    /**\n+     * Constructor. Supply the expression to negate.\n+     */\n+    public NotContainsExpression(Exp exp) {\n+        _exp = exp;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        _contains = contains;\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        DBDictionary dict = store.getDBDictionary();\n+        dict.assertSupport(dict.supportsSubselect, \"SupportsSubselect\");\n+\n+        Select sub = store.getSQLFactory().newSelect();\n+        sub.setParent(sel, null);\n+        _exp.initialize(sub, store, params, _contains);\n+        sub.where(sub.and(null, _exp.getJoins()));\n+\n+        SQLBuffer where = new SQLBuffer(dict).append(\"(\");\n+        _exp.appendTo(where, sub, store, params, fetchState);\n+        if (where.getSQL().length() > 1)\n+            sub.where(where.append(\")\"));\n+\n+        buf.append(\"0 = \");\n+        buf.appendCount(sub, fetchState.getJDBCFetchConfiguration());\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _exp.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public Joins getJoins() {\n+        return null;\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return false;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _exp.hasVariable(var);\n+    }\n+}"},{"sha":"2c2caafa3900f0e4a9bb39348fd29bb938be5e74","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotEqualExpression.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotEqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotEqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotEqualExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Compares two values.\n+ *\n+ * @author Abe White\n+ */\n+class NotEqualExpression\n+    extends CompareEqualExpression {\n+\n+    /**\n+     * Constructor. Supply values to compare.\n+     */\n+    public NotEqualExpression(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState, boolean val1Null,\n+        boolean val2Null) {\n+        if (val1Null && val2Null)\n+            buf.appendValue(null).append(\" IS NOT \").appendValue(null);\n+        else if (val1Null || val2Null) {\n+            Val val = (val1Null) ? getValue2() : getValue1();\n+            if (!isDirectComparison()) {\n+                int len = val.length();\n+                for (int i = 0; i < len; i++) {\n+                    if (i > 0)\n+                        buf.append(\" AND \");\n+                    val.appendTo(buf, i, sel, store, params, fetchState);\n+                    buf.append(\" IS NOT \").appendValue(null);\n+                }\n+            } else\n+                val.appendIsNotNull(buf, sel, store, params, fetchState);\n+        } else {\n+            Val val1 = getValue1();\n+            Val val2 = getValue2();\n+            if (val1.length() == 1 && val2.length() == 1) {\n+                store.getDBDictionary().comparison(buf, \"<>\",\n+                    new FilterValueImpl(val1, sel, store, params, fetchState),\n+                    new FilterValueImpl(val2, sel, store, params, fetchState));\n+            } else {\n+                int len = java.lang.Math.max(val1.length(), val2.length());\n+                buf.append(\"(\");\n+                for (int i = 0; i < len; i++) {\n+                    if (i > 0)\n+                        buf.append(\" OR \");\n+                    val1.appendTo(buf, i, sel, store, params, fetchState);\n+                    buf.append(\" <> \");\n+                    val2.appendTo(buf, i, sel, store, params, fetchState);\n+                }\n+                buf.append(\")\");\n+            }\n+        }\n+    }\n+}"},{"sha":"746fb5470178bc0e7f428ddabd510e5bf7ec51f0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotExpression.java","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Negates an expression.\n+ *\n+ * @author Abe White\n+ */\n+class NotExpression\n+    implements Exp {\n+\n+    private final Exp _exp;\n+    private Joins _joins = null;\n+\n+    /**\n+     * Constructor. Supply the expression to negate.\n+     */\n+    public NotExpression(Exp exp) {\n+        _exp = exp;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        _exp.initialize(sel, store, params, contains);\n+        _joins = sel.or(_exp.getJoins(), null);\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        buf.append(\"NOT (\");\n+        _exp.appendTo(buf, sel, store, params, fetchState);\n+        buf.append(\")\");\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _exp.selectColumns(sel, store, params, pks, fetchState);\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return _exp.hasContainsExpression();\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _exp.hasVariable(var);\n+    }\n+}"},{"sha":"6f3691e535de206336af11f19528118a5789aed1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Null.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Null.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Null.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Null.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * A literal null value in a filter.\n+ *\n+ * @author Abe White\n+ */\n+class Null\n+    extends Const {\n+\n+    public Class getType() {\n+        return Object.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    public Object getValue() {\n+        return null;\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        sql.appendValue(null);\n+    }\n+\n+    public void clearParameters() {\n+    }\n+}"},{"sha":"42c4910b98bf2076b9e428ad784e2bced5e5e422","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/OrExpression.java","status":"added","additions":107,"deletions":0,"changes":107,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/OrExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/OrExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/OrExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Combines two expressions.\n+ *\n+ * @author Abe White\n+ */\n+class OrExpression\n+    implements Exp {\n+\n+    private final Exp _exp1;\n+    private final Exp _exp2;\n+    private Joins _joins = null;\n+\n+    /**\n+     * Constructor. Supply the expressions to combine.\n+     */\n+    public OrExpression(Exp exp1, Exp exp2) {\n+        _exp1 = exp1;\n+        _exp2 = exp2;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        // when OR'ing expressions each expression gets its own copy of the\n+        // contains counts, cause it's OK for each to use the same aliases\n+        Map contains2 = null;\n+        if (contains != null)\n+            contains2 = new HashMap(contains);\n+\n+        _exp1.initialize(sel, store, params, contains);\n+        _exp2.initialize(sel, store, params, contains2);\n+        _joins = sel.or(_exp1.getJoins(), _exp2.getJoins());\n+        if (contains == null)\n+            return;\n+\n+        // combine the contains counts from the copy into the main map\n+        Map.Entry entry;\n+        Integer val1, val2;\n+        for (Iterator itr = contains2.entrySet().iterator();\n+            itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            val2 = (Integer) entry.getValue();\n+            val1 = (Integer) contains.get(entry.getKey());\n+            if (val1 == null || val2.intValue() > val1.intValue())\n+                contains.put(entry.getKey(), val2);\n+        }\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        boolean paren = _joins != null && !_joins.isEmpty();\n+        if (paren)\n+            buf.append(\"(\");\n+\n+        _exp1.appendTo(buf, sel, store, params, fetchState);\n+        buf.append(\" OR \");\n+        _exp2.appendTo(buf, sel, store, params, fetchState);\n+\n+        if (paren)\n+            buf.append(\")\");\n+        sel.append(buf, _joins);\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _exp1.selectColumns(sel, store, params, pks, fetchState);\n+        _exp2.selectColumns(sel, store, params, pks, fetchState);\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return _exp1.hasContainsExpression() || _exp2.hasContainsExpression();\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _exp1.hasVariable(var) || _exp2.hasVariable(var);\n+    }\n+}"},{"sha":"96d21fe9694705d87e96f8059551ead0749c09f0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","status":"added","additions":633,"deletions":0,"changes":633,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,633 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.ListIterator;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.ValueMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Schemas;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * A path represents a traversal into fields of a candidate object.\n+ *\n+ * @author Abe White\n+ */\n+class PCPath\n+    implements JDBCPath {\n+\n+    private static final int PATH = 0;\n+    private static final int BOUND_VAR = 1;\n+    private static final int UNBOUND_VAR = 2;\n+    private static final int UNACCESSED_VAR = 3;\n+\n+    private static final Localizer _loc = Localizer.forPackage(PCPath.class);\n+\n+    private final ClassMapping _candidate;\n+    private LinkedList _actions = null;\n+    private Joins _joins = null;\n+    private boolean _forceOuter = false;\n+    private ClassMapping _class = null;\n+    private FieldMapping _field = null;\n+    private boolean _key = false;\n+    private boolean _joinedRel = false;\n+    private int _type = PATH;\n+    private String _varName = null;\n+    private Column[] _cols = null;\n+    private Class _cast = null;\n+\n+    /**\n+     * Return a path starting with the 'this' ptr.\n+     */\n+    public PCPath(ClassMapping type) {\n+        _candidate = type;\n+    }\n+\n+    /**\n+     * Return a path starting from the given variable.\n+     */\n+    public PCPath(ClassMapping candidate, Variable var) {\n+        _candidate = candidate;\n+        _actions = new LinkedList();\n+\n+        PCPath other = var.getPCPath();\n+        Action action = new Action();\n+        if (other == null) {\n+            _type = UNBOUND_VAR;\n+            action.op = Action.UNBOUND_VAR;\n+            action.data = var;\n+        } else {\n+            // bound variable; copy path\n+            _type = UNACCESSED_VAR;\n+            _actions.addAll(other._actions);\n+\n+            action.op = Action.VAR;\n+            action.data = var.getName();\n+        }\n+        _actions.add(action);\n+        _cast = var.getType(); // initial type is var type\n+    }\n+\n+    /**\n+     * Return a path starting from the given subquery.\n+     */\n+    public PCPath(SubQ sub) {\n+        _candidate = sub.getCandidate();\n+        _actions = new LinkedList();\n+\n+        Action action = new Action();\n+        action.op = Action.SUBQUERY;\n+        action.data = sub.getCandidateAlias();\n+        _actions.add(action);\n+        _cast = sub.getType(); // initial type is subquery type\n+        _varName = sub.getCandidateAlias();\n+    }\n+\n+    /**\n+     * Set the path as a binding of the given variable.\n+     */\n+    public void addVariableAction(Variable var) {\n+        _varName = var.getName();\n+    }\n+\n+    /**\n+     * Return true if this is a bound variable that has not been accessed\n+     * after binding. Useful for filters like\n+     * \"coll.contains (var) &amp;&amp; var == null\", which should really\n+     * just act like \"coll.contains (null)\".\n+     */\n+    public boolean isUnaccessedVariable() {\n+        return _type == UNACCESSED_VAR;\n+    }\n+\n+    /**\n+     * If this path is part of a contains clause, then alias it to the\n+     * proper contains id before initialization.\n+     */\n+    public void setContainsId(String id) {\n+        // treat it just like a unique variable\n+        Action action = new Action();\n+        action.op = Action.VAR;\n+        action.data = id;\n+        if (_actions == null)\n+            _actions = new LinkedList();\n+        _actions.add(action);\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _class;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _class = (ClassMapping) meta;\n+    }\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    public ClassMapping getClassMapping() {\n+        if (_field == null)\n+            return _class;\n+        if (_key) {\n+            if (_field.getKey().getTypeCode() == JavaTypes.PC)\n+                return _field.getKeyMapping().getTypeMapping();\n+            return null;\n+        }\n+        if (_field.getElement().getTypeCode() == JavaTypes.PC)\n+            return _field.getElementMapping().getTypeMapping();\n+        if (_field.getTypeCode() == JavaTypes.PC)\n+            return _field.getTypeMapping();\n+        return null;\n+    }\n+\n+    public FieldMapping getFieldMapping() {\n+        return _field;\n+    }\n+\n+    public boolean isKey() {\n+        return _key;\n+    }\n+\n+    public String getPath() {\n+        if (_actions == null)\n+            return (_varName == null) ? \"\" : _varName + \".\";\n+\n+        StringBuffer path = new StringBuffer();\n+        Action action;\n+        for (Iterator itr = _actions.iterator(); itr.hasNext();) {\n+            action = (Action) itr.next();\n+            if (action.op == Action.VAR || action.op == Action.SUBQUERY)\n+                path.append(action.data);\n+            else if (action.op == Action.UNBOUND_VAR)\n+                path.append(((Variable) action.data).getName());\n+            else\n+                path.append(((FieldMapping) action.data).getName());\n+            path.append('.');\n+        }\n+        if (_varName != null)\n+            path.append(_varName).append('.');\n+        return path.toString();\n+    }\n+\n+    public Column[] getColumns() {\n+        if (_cols == null)\n+            _cols = calculateColumns();\n+        return _cols;\n+    }\n+\n+    /**\n+     * The columns used by this path.\n+     */\n+    private Column[] calculateColumns() {\n+        if (_key) {\n+            if (!_joinedRel && _field.getKey().getValueMappedBy() != null)\n+                joinRelation();\n+            else if (_joinedRel\n+                && _field.getKey().getTypeCode() == JavaTypes.PC)\n+                return _field.getKeyMapping().getTypeMapping().\n+                    getPrimaryKeyColumns();\n+            return _field.getKeyMapping().getColumns();\n+        }\n+        if (_field != null) {\n+            switch (_field.getTypeCode()) {\n+                case JavaTypes.MAP:\n+                case JavaTypes.ARRAY:\n+                case JavaTypes.COLLECTION:\n+                    ValueMapping elem = _field.getElementMapping();\n+                    if (_joinedRel && elem.getTypeCode() == JavaTypes.PC)\n+                        return elem.getTypeMapping().getPrimaryKeyColumns();\n+                    if (elem.getColumns().length > 0)\n+                        return elem.getColumns();\n+                    return _field.getColumns();\n+                case JavaTypes.PC:\n+                    if (_joinedRel)\n+                        return _field.getTypeMapping().getPrimaryKeyColumns();\n+                    return _field.getColumns();\n+                default:\n+                    return _field.getColumns();\n+            }\n+        }\n+        return (_class == null) ? Schemas.EMPTY_COLUMNS\n+            : _class.getPrimaryKeyColumns();\n+    }\n+\n+    public void get(FieldMetaData field, boolean nullTraversal) {\n+        if (_actions == null)\n+            _actions = new LinkedList();\n+        Action action = new Action();\n+        action.op = (nullTraversal) ? Action.GET_OUTER : Action.GET;\n+        action.data = field;\n+        _actions.add(action);\n+        if (_type == UNACCESSED_VAR)\n+            _type = BOUND_VAR;\n+        _cast = null;\n+    }\n+\n+    public void getKey() {\n+        // change the last action to a get key\n+        Action action = (Action) _actions.getLast();\n+        action.op = Action.GET_KEY;\n+        _cast = null;\n+    }\n+\n+    public FieldMetaData last() {\n+        Action act = lastFieldAction();\n+        return (act == null) ? null : (FieldMetaData) act.data;\n+    }\n+\n+    /**\n+     * Return the last action that gets a field.\n+     */\n+    private Action lastFieldAction() {\n+        if (_actions == null)\n+            return null;\n+\n+        ListIterator itr = _actions.listIterator(_actions.size());\n+        Action prev;\n+        while (itr.hasPrevious()) {\n+            prev = (Action) itr.previous();\n+            if (prev.op == Action.GET || prev.op == Action.GET_OUTER\n+                || prev.op == Action.GET_KEY)\n+                return prev;\n+\n+            // break if we're getting to path portions that we copied from\n+            // our variable\n+            if (prev.op == Action.VAR || prev.op == Action.UNBOUND_VAR\n+                || prev.op == Action.SUBQUERY)\n+                break;\n+        }\n+        return null;\n+    }\n+\n+    public Class getType() {\n+        if (_cast != null)\n+            return _cast;\n+        FieldMetaData fld;\n+        boolean key;\n+        if (_field != null) {\n+            fld = _field;\n+            key = _key;\n+        } else {\n+            Action act = lastFieldAction();\n+            fld = (act == null) ? null : (FieldMetaData) act.data;\n+            key = act != null && act.op == Action.GET_KEY;\n+        }\n+\n+        if (fld != null) {\n+            switch (fld.getDeclaredTypeCode()) {\n+                case JavaTypes.MAP:\n+                    if (key)\n+                        return fld.getKey().getDeclaredType();\n+                    // no break\n+                case JavaTypes.ARRAY:\n+                case JavaTypes.COLLECTION:\n+                    return fld.getElement().getDeclaredType();\n+                default:\n+                    return fld.getDeclaredType();\n+            }\n+        }\n+        if (_class != null)\n+            return _class.getDescribedType();\n+        return Object.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _cast = type;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        // initialize can be called more than once, so reset\n+        _field = null;\n+        _key = false;\n+        _forceOuter = false;\n+        _joinedRel = false;\n+        _joins = sel.newJoins();\n+\n+        // iterate to the final field\n+        ClassMapping rel = _candidate;\n+        ClassMapping owner;\n+        ClassMapping from, to;\n+        Action action;\n+        Variable var;\n+        Iterator itr = (_actions == null) ? null : _actions.iterator();\n+        while (itr != null && itr.hasNext()) {\n+            action = (Action) itr.next();\n+\n+            // treat subqueries like variables for alias generation purposes\n+            if (action.op == Action.VAR)\n+                _joins = _joins.setVariable((String) action.data);\n+            else if (action.op == Action.SUBQUERY)\n+                _joins = _joins.setSubselect((String) action.data);\n+            else if (action.op == Action.UNBOUND_VAR) {\n+                // unbound vars are cross-joined to the candidate table\n+                var = (Variable) action.data;\n+                rel = (ClassMapping) var.getMetaData();\n+                _joins = _joins.setVariable(var.getName());\n+                _joins = _joins.crossJoin(_candidate.getTable(),\n+                    rel.getTable());\n+            } else {\n+                // move past the previous field, if any\n+                if (_field != null)\n+                    rel = traverseField(false);\n+\n+                // mark if the next traversal should go through\n+                // the key rather than value\n+                _key = action.op == Action.GET_KEY;\n+                _forceOuter |= action.op == Action.GET_OUTER;\n+\n+                // get mapping for the current field\n+                _field = (FieldMapping) action.data;\n+                owner = _field.getDefiningMapping();\n+                if (_field.getManagement() != FieldMapping.MANAGE_PERSISTENT)\n+                    throw new UserException(_loc.get(\"non-pers-field\",\n+                        _field));\n+\n+                // find the most-derived type between the declared relation\n+                // type and the field's owner, and join from that type to\n+                // the lesser derived type\n+                if (rel != owner && rel != null) {\n+                    if (rel.getDescribedType().isAssignableFrom\n+                        (owner.getDescribedType())) {\n+                        from = owner;\n+                        to = rel;\n+                    } else {\n+                        from = rel;\n+                        to = owner;\n+                    }\n+\n+                    for (; from != null && from != to;\n+                        from = from.getJoinablePCSuperclassMapping())\n+                        _joins = from.joinSuperclass(_joins, false);\n+                }\n+            }\n+        }\n+        if (_varName != null)\n+            _joins = _joins.setVariable(_varName);\n+\n+        // if we're not comparing to null or doing an isEmpty, then\n+        // join into the data on the final field; obviously we can't do these\n+        // joins when comparing to null b/c the whole purpose is to see\n+        // whether the joins even exist\n+        if (!nullTest)\n+            traverseField(true);\n+\n+        // note that we haven't yet joined to the relation of the last field yet\n+        _joinedRel = false;\n+    }\n+\n+    /**\n+     * Traverse into the previous field of a relation path.\n+     *\n+     * @param last whether this is the last field in the path\n+     * @return the mapping of the related type, or null\n+     */\n+    private ClassMapping traverseField(boolean last) {\n+        if (_field == null)\n+            return null;\n+\n+        // traverse into field value\n+        if (_key)\n+            _joins = _field.joinKey(_joins, _forceOuter);\n+        else\n+            _joins = _field.join(_joins, _forceOuter);\n+\n+        // if this isn't the last field, traverse into the relation\n+        if (!last)\n+            joinRelation(true);\n+\n+        // return the maping of the related type, if any\n+        if (_key)\n+            return _field.getKeyMapping().getTypeMapping();\n+        if (_field.getElement().getTypeCode() == JavaTypes.PC)\n+            return _field.getElementMapping().getTypeMapping();\n+        return _field.getTypeMapping();\n+    }\n+\n+    /**\n+     * Join into the relation represented by the current field, if any.\n+     */\n+    void joinRelation() {\n+        joinRelation(false);\n+    }\n+\n+    private void joinRelation(boolean traverse) {\n+        if (_field == null)\n+            return;\n+        if (_key)\n+            _joins = _field.joinKeyRelation(_joins, _forceOuter, traverse);\n+        else\n+            _joins = _field.joinRelation(_joins, _forceOuter, traverse);\n+        _joinedRel = true;\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        if (_field != null) {\n+            if (_key)\n+                return _field.toKeyDataStoreValue(val, store);\n+            if (_field.getElement().getDeclaredTypeCode() != JavaTypes.OBJECT)\n+                return _field.toDataStoreValue(val, store);\n+\n+            val = _field.getExternalValue(val, store.getContext());\n+            return _field.toDataStoreValue(val, store);\n+        }\n+        return _class.toDataStoreValue(val, _class.getPrimaryKeyColumns(),\n+            store);\n+    }\n+\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+        selectColumns(sel, store, params, pks, fetchState);\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        ClassMapping mapping = getClassMapping();\n+        if (mapping == null || !_joinedRel)\n+            sel.select(getColumns(), _joins);\n+        else if (pks)\n+            sel.select(mapping.getPrimaryKeyColumns(), _joins);\n+        else {\n+            // select the mapping; allow any subs because we know this must\n+            // be either a relation, in which case it will already be\n+            // constrained by the joins, or 'this', in which case the\n+            // JDBCExpressionFactory takes care of adding class conditions for\n+            // the candidate class on the select\n+            int subs = (_type == UNBOUND_VAR) ? sel.SUBS_JOINABLE\n+                : sel.SUBS_ANY_JOINABLE;\n+            sel.select(mapping, subs, store, fetchState,\n+                JDBCFetchConfiguration.EAGER_NONE, sel.outer(_joins));\n+        }\n+    }\n+\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState) {\n+        sel.groupBy(getColumns(), sel.outer(_joins), false);\n+    }\n+\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState) {\n+        sel.orderBy(getColumns(), asc, sel.outer(_joins), false);\n+    }\n+\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState)\n+        throws SQLException {\n+        return load(res, store, false, fetchState);\n+    }\n+\n+    Object load(Result res, JDBCStore store, boolean pks,\n+        JDBCFetchState fetchState)\n+        throws SQLException {\n+        ClassMapping mapping = getClassMapping();\n+        if (mapping != null && (_field == null || !_field.isEmbedded())) {\n+            if (pks)\n+                return mapping.getObjectId(store, res, null, true, _joins);\n+            return res.load(mapping, store, fetchState, _joins);\n+        }\n+\n+        Object ret;\n+        if (_key)\n+            ret = _field.loadKeyProjection(store, fetchState, res, _joins);\n+        else\n+            ret = _field.loadProjection(store, fetchState, res, _joins);\n+        if (_cast != null)\n+            ret = Filters.convert(ret, _cast);\n+        return ret;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        if (_actions == null)\n+            return false;\n+\n+        Action action;\n+        for (Iterator itr = _actions.iterator(); itr.hasNext();) {\n+            action = (Action) itr.next();\n+            if (action.op == Action.VAR && action.data.equals(var.getName()))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        // we don't create the SQL b/c it forces the Select to cache aliases\n+        // for the tables we use, and these aliases might not ever be used if\n+        // we eventually call appendIsEmpty or appendIsNull rather than appendTo\n+    }\n+\n+    public void clearParameters() {\n+    }\n+\n+    public int length() {\n+        return getColumns().length;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        Column col = getColumns()[index];\n+\n+        // if select is null, it means we are not aliasing columns\n+        // (e.g., during a bulk update)\n+        if (sel == null)\n+            sql.append(col.getName());\n+        else\n+            sql.append(sel.getColumnAlias(col, _joins));\n+    }\n+\n+    public void appendIsEmpty(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        if (_field == null)\n+            sql.append(\"1 <> 1\");\n+        else\n+            _field.appendIsEmpty(sql, sel, _joins);\n+    }\n+\n+    public void appendIsNotEmpty(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        if (_field == null)\n+            sql.append(\"1 <> 1\");\n+        else\n+            _field.appendIsNotEmpty(sql, sel, _joins);\n+    }\n+\n+    public void appendSize(SQLBuffer sql, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        if (_field == null)\n+            sql.append(\"1\");\n+        else\n+            _field.appendSize(sql, sel, _joins);\n+    }\n+\n+    public void appendIsNull(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        if (_field == null)\n+            sql.append(\"1 <> 1\");\n+        else\n+            _field.appendIsNull(sql, sel, _joins);\n+    }\n+\n+    public void appendIsNotNull(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        if (_field == null)\n+            sql.append(\"1 = 1\");\n+        else\n+            _field.appendIsNotNull(sql, sel, _joins);\n+    }\n+\n+    /**\n+     * Helper class representing an action.\n+     */\n+    private static class Action {\n+\n+        public static final int GET = 0;\n+        public static final int GET_OUTER = 1;\n+        public static final int GET_KEY = 2;\n+        public static final int VAR = 3;\n+        public static final int SUBQUERY = 4;\n+        public static final int UNBOUND_VAR = 5;\n+        public static final int CAST = 6;\n+\n+        public int op = -1;\n+        public Object data = null;\n+\n+        public String toString() {\n+            return op + \"|\" + data;\n+        }\n+    }\n+}"},{"sha":"1fa371cfc627faa2cc85a1933ea878afb64f3029","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java","status":"added","additions":117,"deletions":0,"changes":117,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,117 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.exps.Parameter;\n+import org.apache.openjpa.util.ImplHelper;\n+\n+/**\n+ * A parameter in a filter.\n+ *\n+ * @author Abe White\n+ */\n+class Param\n+    extends Const\n+    implements Parameter {\n+\n+    private final String _name;\n+    private Class _type = null;\n+    private int _idx = -1;\n+    private boolean _container = false;\n+    private Object _val = null;\n+    private Object _sqlVal = null;\n+    private int _otherLen = 0;\n+\n+    /**\n+     * Constructor. Supply parameter name and type.\n+     */\n+    public Param(String name, Class type) {\n+        _name = name;\n+        setImplicitType(type);\n+    }\n+\n+    public String getName() {\n+        return _name;\n+    }\n+\n+    public String getParameterName() {\n+        return getName();\n+    }\n+\n+    public Class getType() {\n+        return _type;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _type = type;\n+        _container = (getMetaData() == null ||\n+            !ImplHelper.isManagedType(type))\n+            && (Collection.class.isAssignableFrom(type)\n+            || Map.class.isAssignableFrom(type));\n+    }\n+\n+    public int getIndex() {\n+        return _idx;\n+    }\n+\n+    public void setIndex(int idx) {\n+        _idx = idx;\n+    }\n+\n+    public Object getValue() {\n+        return _val;\n+    }\n+\n+    public Object getSQLValue() {\n+        return _sqlVal;\n+    }\n+\n+    public Object getValue(Object[] params) {\n+        return params[_idx];\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        super.calculateValue(sel, store, params, other, fetchState);\n+        _val = Filters.convert(params[_idx], getType());\n+        if (other != null && !_container) {\n+            _sqlVal = other.toDataStoreValue(_val, store);\n+            _otherLen = other.length();\n+        } else\n+            _sqlVal = _val;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        if (_otherLen > 1)\n+            sql.appendValue(((Object[]) _sqlVal)[index], getColumn(index));\n+        else\n+            sql.appendValue(_sqlVal, getColumn(index));\n+    }\n+\n+    public void clearParameters() {\n+        _val = null;\n+        _sqlVal = null;\n+    }\n+}"},{"sha":"29e9992581f3b301abdea36dddec369f851a7eb4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLEmbed.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLEmbed.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLEmbed.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLEmbed.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UnsupportedException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Simple listener which embeds its SQL argument into the query. Listens\n+ * on <code>sql</code>.\n+ *  Example:<br />\n+ * <code> \"price &lt; sql(\\\"(SELECT AVG (PRICE) FROM PRODUCT_TABLE)\\\")\"\n+ * </code>\n+ *\n+ * @nojavadoc\n+ */\n+public class SQLEmbed\n+    implements JDBCFilterListener {\n+\n+    public static String TAG = \"sql\";\n+\n+    private static final Localizer _loc = Localizer.forPackage(SQLEmbed.class);\n+\n+    public String getTag() {\n+        return TAG;\n+    }\n+\n+    public boolean expectsArguments() {\n+        return true;\n+    }\n+\n+    public boolean expectsTarget() {\n+        return false;\n+    }\n+\n+    public Object evaluate(Object target, Class targetClass, Object[] args,\n+        Class[] argClasses, Object candidate, StoreContext ctx) {\n+        throw new UnsupportedException(_loc.get(\"no-in-mem\", TAG));\n+    }\n+\n+    public void appendTo(SQLBuffer buf, FilterValue target, FilterValue[] args,\n+        ClassMapping type, JDBCStore store) {\n+        if (!args[0].isConstant())\n+            throw new UserException(_loc.get(\"const-only\", TAG));\n+        buf.append(args[0].getValue().toString());\n+    }\n+\n+    public Class getType(Class targetClass, Class[] argClasses) {\n+        return Object.class;\n+    }\n+}"},{"sha":"e8dd65761ff5ffb753f78084b6790fb7bfba49d2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLExpression.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+/**\n+ * Simple listener which embeds the argument as an expression into the\n+ * where clause generated by the query. Listens on \"ext:sqlExp\".\n+ *  Example:<br />\n+ * <code>\n+ * \"price &lt; 10 || ext:sqlExp (\\\"(SELECT AVG (PRICE) FROM PRODUCT_TABLE)\n+ * &gt; 100\\\")\"\n+ * </code>\n+ *\n+ * @nojavadoc\n+ * @deprecated Use {@link SQLEmbed} directly\n+ */\n+public class SQLExpression\n+    extends SQLEmbed {\n+\n+    public static final String TAG = \"sqlExp\";\n+\n+    public String getTag() {\n+        return TAG;\n+    }\n+}"},{"sha":"8e41d0c6994e5aa78781a0e4309be75291f22506","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLValue.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLValue.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLValue.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+/**\n+ * Simple listener which embeds the argument as a value into the where\n+ * clause generated by the query. Listens on \"ext:sqlVal\".\n+ *  Example:<br />\n+ * <code> \"price &lt; ext:sqlVal (\\\"(SELECT AVG (PRICE) FROM PRODUCT_TABLE)\\\")\"\n+ * </code>\n+ *\n+ * @nojavadoc\n+ * @deprecated Use {@link SQLEmbed} directly\n+ */\n+public class SQLValue\n+    extends SQLEmbed {\n+\n+    public static final String TAG = \"sqlVal\";\n+\n+    public String getTag() {\n+        return TAG;\n+    }\n+}"},{"sha":"d7ad7e05a273f2be005778f50005a5c5c1152c59","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java","status":"added","additions":352,"deletions":0,"changes":352,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,352 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.exps.Expression;\n+import org.apache.openjpa.kernel.exps.QueryExpressions;\n+\n+/**\n+ * Turns parsed queries into selects.\n+ *\n+ * @author Abe White\n+ */\n+class SelectConstructor {\n+\n+    public static final int CACHE_NULL = 0;\n+    public static final int CACHE_JOINS = 1;\n+    public static final int CACHE_FULL = 2;\n+\n+    // cache as much as we can for multiple executions of the same query\n+    private Select _template = null;\n+    private boolean _extent = false;\n+    private int _cacheLevel = -1;\n+\n+    /**\n+     * Return true if we know the select to have on criteria; to be an extent.\n+     * Note that even if this method returns false, {@link #evaluate} may still\n+     * return null if we haven't cached whether the query is an extent yet.\n+     */\n+    public boolean isExtent() {\n+        return _extent;\n+    }\n+\n+    /**\n+     * Evaluate the expression, returning a SQL select with the proper\n+     * conditions. Use {@link #select} to then select the data.\n+     */\n+    public Select evaluate(JDBCStore store, Select parent, String alias,\n+        QueryExpressions exps, Object[] params, int level,\n+        JDBCFetchState fetchState) {\n+        // already know that this query is equivalent to an extent?\n+        Select sel;\n+        if (_extent) {\n+            sel = store.getSQLFactory().newSelect();\n+            sel.setAutoDistinct((exps.distinct & exps.DISTINCT_AUTO) != 0);\n+            return sel;\n+        }\n+\n+        // already cached some SQL? if we're changing our cache level, we\n+        // have to abandon any already-cached data because a change means\n+        // different joins\n+        if (level != _cacheLevel)\n+            _template = null;\n+        _cacheLevel = level;\n+\n+        if (_template != null && level == CACHE_FULL) {\n+            sel = (Select) _template.fullClone(1);\n+            sel.setParent(parent, alias);\n+        } else if (_template != null) {\n+            sel = (Select) _template.whereClone(1);\n+            sel.setParent(parent, alias);\n+        } else {\n+            // create a new select and initialize it with the joins needed for\n+            // the criteria of this query\n+            sel = newJoinsSelect(store, parent, alias, exps, params,\n+                fetchState);\n+        }\n+\n+        // if this select wasn't cloned from a full template,\n+        // build up sql conditions\n+        if (_template == null || level != CACHE_FULL) {\n+            // create where clause; if there are no where conditions and\n+            // no ordering or projections, we return null to signify that this\n+            // query should be treated like an extent\n+            Select inner = sel.getFromSelect();\n+            SQLBuffer where = buildWhere((inner != null) ? inner : sel,\n+                store, exps.filter, params, fetchState);\n+            if (where == null && exps.projections.length == 0\n+                && exps.ordering.length == 0\n+                && (sel.getJoins() == null || sel.getJoins().isEmpty())) {\n+                _extent = true;\n+                sel = store.getSQLFactory().newSelect();\n+                sel.setAutoDistinct((exps.distinct & exps.DISTINCT_AUTO) != 0);\n+                return sel;\n+            }\n+\n+            // if we're caching joins, do that now before we start setting sql.\n+            // we can't cache subselects because they are also held in the\n+            // where buffer\n+            if (_template == null && level == CACHE_JOINS\n+                && (inner == null || inner.getSubselects().isEmpty())\n+                && sel.getSubselects().isEmpty()) {\n+                _template = sel;\n+                sel = (Select) sel.whereClone(1);\n+                sel.setParent(parent, alias);\n+                inner = sel.getFromSelect();\n+            }\n+\n+            // now set sql criteria; it goes on the inner select if present\n+            if (inner != null)\n+                inner.where(where);\n+            else\n+                sel.where(where);\n+\n+            // apply grouping and having.  this does not select the grouping\n+            // columns, just builds the GROUP BY clauses.  we don't build the\n+            // ORDER BY clauses yet because if we decide to add this select\n+            // to a union, the ORDER BY values get aliased differently\n+            if (exps.having != null) {\n+                Exp havingExp = (Exp) exps.having;\n+                SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n+                havingExp.appendTo(buf, sel, store, params, fetchState);\n+                sel.having(buf);\n+            }\n+            for (int i = 0; i < exps.grouping.length; i++)\n+                ((Val) exps.grouping[i]).groupBy(sel, store, params,\n+                    fetchState);\n+\n+            // if template is still null at this point, must be a full cache\n+            if (_template == null && level == CACHE_FULL) {\n+                _template = sel;\n+                sel = (Select) _template.fullClone(1);\n+                sel.setParent(parent, alias);\n+            }\n+        }\n+        return sel;\n+    }\n+\n+    /**\n+     * Initialize the given select's joins.\n+     */\n+    private Select newJoinsSelect(JDBCStore store, Select parent,\n+        String alias, QueryExpressions exps, Object[] params,\n+        JDBCFetchState fetchState) {\n+        Select sel = store.getSQLFactory().newSelect();\n+        sel.setAutoDistinct((exps.distinct & exps.DISTINCT_AUTO) != 0);\n+        JDBCFetchConfiguration fetch = (fetchState == null)\n+            ?\n+            (JDBCFetchConfiguration) store.getContext().getFetchConfiguration()\n+            : fetchState.getJDBCFetchConfiguration();\n+        sel.setJoinSyntax(fetch.getJoinSyntax());\n+        sel.setParent(parent, alias);\n+        initializeJoins(sel, store, exps, params);\n+\n+        if (!sel.getAutoDistinct()) {\n+            if ((exps.distinct & exps.DISTINCT_TRUE) != 0)\n+                sel.setDistinct(true);\n+            else if ((exps.distinct & exps.DISTINCT_FALSE) != 0)\n+                sel.setDistinct(false);\n+        } else if (exps.projections.length > 0) {\n+            if (!sel.isDistinct() && (exps.distinct & exps.DISTINCT_TRUE) != 0)\n+            {\n+                // if the select is not distinct but the query is, force\n+                // the select to be distinct\n+                sel.setDistinct(true);\n+            } else if (sel.isDistinct()) {\n+                // when aggregating data or making a non-distinct projection\n+                // from a distinct select, we have to select from a tmp\n+                // table formed by a distinct subselect in the from clause;\n+                // this subselect selects the pks of the candidate (to\n+                // get unique candidate values) and needed field values and\n+                // applies the where conditions; the outer select applies\n+                // ordering, grouping, etc\n+                if (exps.aggregate || (exps.distinct & exps.DISTINCT_TRUE) == 0)\n+                {\n+                    DBDictionary dict = store.getDBDictionary();\n+                    dict.assertSupport(dict.supportsSubselect,\n+                        \"SupportsSubselect\");\n+\n+                    Select inner = sel;\n+                    sel = store.getSQLFactory().newSelect();\n+                    sel.setParent(parent, alias);\n+                    sel.setDistinct(exps.aggregate\n+                        && (exps.distinct & exps.DISTINCT_TRUE) != 0);\n+                    sel.setFromSelect(inner);\n+                }\n+            }\n+        }\n+        return sel;\n+    }\n+\n+    /**\n+     * Initialize the joins for all expressions. This only has to be done\n+     * once for the template select, since each factory is only used for a\n+     * single filter + projections + grouping + having + ordering combination.\n+     * By initializing the joins once, we speed up subsequent executions\n+     * because the relation traversal logic, etc is cached.\n+     */\n+    private void initializeJoins(Select sel, JDBCStore store,\n+        QueryExpressions exps, Object[] params) {\n+        Map contains = null;\n+        if (((Exp) exps.filter).hasContainsExpression()\n+            || (exps.having != null\n+            && ((Exp) exps.having).hasContainsExpression()))\n+            contains = new HashMap(7);\n+\n+        // initialize filter and having expressions\n+        Exp filterExp = (Exp) exps.filter;\n+        filterExp.initialize(sel, store, params, contains);\n+        Exp havingExp = (Exp) exps.having;\n+        if (havingExp != null)\n+            havingExp.initialize(sel, store, params, contains);\n+\n+        // get the top-level joins and null the expression's joins\n+        // at the same time so they aren't included in the where/having SQL\n+        Joins filterJoins = filterExp.getJoins();\n+        Joins havingJoins = (havingExp == null) ? null : havingExp.getJoins();\n+        Joins joins = sel.and(filterJoins, havingJoins);\n+\n+        // initialize result values\n+        Val resultVal;\n+        for (int i = 0; i < exps.projections.length; i++) {\n+            resultVal = (Val) exps.projections[i];\n+            resultVal.initialize(sel, store, false);\n+\n+            // have to join through to related type for pc object projections;\n+            // this ensures that we have all our joins cached\n+            if (resultVal instanceof PCPath)\n+                ((PCPath) resultVal).joinRelation();\n+\n+            joins = sel.and(joins, resultVal.getJoins());\n+        }\n+\n+        // initialize grouping\n+        Val groupVal;\n+        for (int i = 0; i < exps.grouping.length; i++) {\n+            groupVal = (Val) exps.grouping[i];\n+            groupVal.initialize(sel, store, false);\n+            joins = sel.and(joins, groupVal.getJoins());\n+        }\n+\n+        // initialize ordering\n+        Val orderVal;\n+        for (int i = 0; i < exps.ordering.length; i++) {\n+            orderVal = (Val) exps.ordering[i];\n+            orderVal.initialize(sel, store, false);\n+            joins = sel.and(joins, orderVal.getJoins());\n+        }\n+\n+        sel.where(joins);\n+    }\n+\n+    /**\n+     * Create the where sql.\n+     */\n+    private SQLBuffer buildWhere(Select sel, JDBCStore store,\n+        Expression filter, Object[] params, JDBCFetchState fetchState) {\n+        // create where buffer\n+        SQLBuffer where = new SQLBuffer(store.getDBDictionary());\n+        where.append(\"(\");\n+        Exp filterExp = (Exp) filter;\n+        filterExp.appendTo(where, sel, store, params, fetchState);\n+\n+        if (where.sqlEquals(\"(\") || where.sqlEquals(\"(1 = 1\"))\n+            return null;\n+        return where.append(\")\");\n+    }\n+\n+    /**\n+     * Select the data for this query.\n+     */\n+    public void select(JDBCStore store, ClassMapping mapping,\n+        boolean subclasses, Select sel, QueryExpressions exps,\n+        Object[] params, JDBCFetchState fetchState, int eager) {\n+        Select inner = sel.getFromSelect();\n+        Val val;\n+        Joins joins = null;\n+        if (sel.getSubselectPath() != null)\n+            joins = sel.newJoins().setSubselect(sel.getSubselectPath());\n+        JDBCFetchConfiguration fetch = fetchState.getJDBCFetchConfiguration();\n+        // build ordering clauses before select so that any eager join\n+        // ordering gets applied after query ordering\n+        for (int i = 0; i < exps.ordering.length; i++)\n+            ((Val) exps.ordering[i]).orderBy(sel, store, params,\n+                exps.ascending[i], fetchState);\n+\n+        // if no result string set, select matching objects like normal\n+        if (exps.projections.length == 0 && sel.getParent() == null) {\n+            int subs = (subclasses) ? sel.SUBS_JOINABLE : sel.SUBS_NONE;\n+            sel.selectIdentifier(mapping, subs, store, fetchState, eager);\n+        } else if (exps.projections.length == 0) {\n+            // subselect for objects; we really just need the primary key values\n+            sel.select(mapping.getPrimaryKeyColumns(), joins);\n+        } else {\n+            // if we have an inner select, we need to select the candidate\n+            // class' pk columns to guarantee unique instances\n+            if (inner != null)\n+                inner.select(mapping.getPrimaryKeyColumns(), joins);\n+\n+            // select each result value; no need to pass on the eager mode since\n+            // under projections we always use EAGER_NONE\n+            boolean pks = sel.getParent() != null;\n+            for (int i = 0; i < exps.projections.length; i++) {\n+                val = (Val) exps.projections[i];\n+                if (inner != null)\n+                    val.selectColumns(inner, store, params, pks, fetchState);\n+                val.select(sel, store, params, pks, fetchState);\n+            }\n+\n+            // make sure grouping and having columns are selected since it\n+            // is required by most DBs.  put them last so they don't affect\n+            // result processing\n+            if (exps.having != null && inner != null)\n+                ((Exp) exps.having).selectColumns(inner, store, params, true,\n+                    fetchState);\n+            for (int i = 0; i < exps.grouping.length; i++) {\n+                val = (Val) exps.grouping[i];\n+                if (inner != null)\n+                    val.selectColumns(inner, store, params, true, fetchState);\n+                val.select(sel, store, params, true, fetchState);\n+            }\n+        }\n+\n+        // select order data last so it doesn't affect result processing\n+        for (int i = 0; i < exps.ordering.length; i++) {\n+            val = (Val) exps.ordering[i];\n+            if (inner != null)\n+                val.selectColumns(inner, store, params, true, fetchState);\n+            val.select(sel, store, params, true, fetchState);\n+        }\n+\n+        // add conditions limiting the projections to the proper classes; if\n+        // this isn't a projection then they will already be added\n+        if (exps.projections.length > 0) {\n+            Select indSel = (inner == null) ? sel : inner;\n+            store.addClassConditions(indSel, mapping, subclasses, joins);\n+        }\n+    }\n+}"},{"sha":"0fa2e1a00a2f1881c0dc005fa849b3ad30f47409","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Size.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Size.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Size.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Size.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.util.InternalException;\n+\n+/**\n+ * Size.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class Size\n+    extends UnaryOp\n+    implements Val {\n+\n+    public Size(Val val) {\n+        super(val);\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        // initialize the value with a null test\n+        getVal().initialize(sel, store, true);\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        getVal().calculateValue(sel, store, params, null, fetchState);\n+        getVal().appendSize(sql, sel, store, params, fetchState);\n+        sel.append(sql, getVal().getJoins());\n+        getVal().clearParameters();\n+    }\n+\n+    protected Class getType(Class c) {\n+        return long.class;\n+    }\n+\n+    protected String getOperator() {\n+        // since we override appendTo(), this method should never be called\n+        throw new InternalException();\n+    }\n+}"},{"sha":"c740e2ba10ccb3715b6c7a069aaab93657e3e5a6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sqrt.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sqrt.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sqrt.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sqrt.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+/**\n+ * Square root.\n+ *\n+ * @author Abe White\n+ */\n+class Sqrt\n+    extends UnaryOp {\n+\n+    /**\n+     * Constructor. Provide the value to operate on.\n+     */\n+    public Sqrt(Val val) {\n+        super(val);\n+    }\n+\n+    protected Class getType(Class c) {\n+        return double.class;\n+    }\n+\n+    protected String getOperator() {\n+        return \"SQRT\";\n+    }\n+}\n+"},{"sha":"b6df39297f936df6f25e76634683709d8d8a1383","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java","status":"added","additions":266,"deletions":0,"changes":266,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import serp.util.Numbers;\n+\n+/**\n+ * Test if one string starts with another.\n+ *\n+ * @author Abe White\n+ */\n+class StartsWithExpression\n+    implements Exp {\n+\n+    private final Val _val1;\n+    private final Val _val2;\n+    private Joins _joins = null;\n+    private String _pre = null;\n+    private String _post = null;\n+\n+    /**\n+     * Constructor. Supply values.\n+     */\n+    public StartsWithExpression(Val val1, Val val2) {\n+        _val1 = val1;\n+        _val2 = val2;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store,\n+        Object[] params, Map contains) {\n+        _val1.initialize(sel, store, false);\n+        _val2.initialize(sel, store, false);\n+        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n+\n+        DBDictionary dict = store.getDBDictionary();\n+        String func = dict.stringLengthFunction;\n+        if (func != null) {\n+            int idx = func.indexOf(\"{0}\");\n+            _pre = func.substring(0, idx);\n+            _post = func.substring(idx + 3);\n+        }\n+    }\n+\n+    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        _val1.calculateValue(sel, store, params, _val2, fetchState);\n+        _val2.calculateValue(sel, store, params, _val1, fetchState);\n+\n+        if (_val1 instanceof Const && ((Const) _val1).getValue() == null)\n+            buf.append(\"1 <> 1\");\n+        else if (_val2 instanceof Const) {\n+            Object o = ((Const) _val2).getValue();\n+            if (o == null)\n+                buf.append(\"1 <> 1\");\n+            else {\n+                Column col = null;\n+                if (_val1 instanceof PCPath) {\n+                    Column[] cols = ((PCPath) _val1).getColumns();\n+                    if (cols.length == 1)\n+                        col = cols[0];\n+                }\n+\n+                _val1.appendTo(buf, 0, sel, store, params, fetchState);\n+                buf.append(\" LIKE \");\n+                buf.appendValue(o.toString() + \"%\", col);\n+            }\n+        } else {\n+            // if we can't use LIKE, we have to take the substring of the\n+            // first value and compare it to the second\n+            DBDictionary dict = store.getDBDictionary();\n+            dict.assertSupport(_pre != null, \"StringLengthFunction\");\n+            dict.substring(buf,\n+                new FilterValueImpl(_val1, sel, store, params, fetchState),\n+                new ZeroFilterValue(sel),\n+                new StringLengthFilterValue(sel, store, params, fetchState));\n+            buf.append(\" = \");\n+            _val2.appendTo(buf, 0, sel, store, params, fetchState);\n+        }\n+\n+        sel.append(buf, _joins);\n+        _val1.clearParameters();\n+        _val2.clearParameters();\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val1.selectColumns(sel, store, params, true, fetchState);\n+        _val2.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public boolean hasContainsExpression() {\n+        return false;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _val1.hasVariable(var) || _val2.hasVariable(var);\n+    }\n+\n+    /**\n+     * Evaluates to 0.\n+     */\n+    private class ZeroFilterValue\n+        implements FilterValue {\n+\n+        private final Select _sel;\n+\n+        public ZeroFilterValue(Select sel) {\n+            _sel = sel;\n+        }\n+\n+        public Class getType() {\n+            return int.class;\n+        }\n+\n+        public int length() {\n+            return 1;\n+        }\n+\n+        public void appendTo(SQLBuffer buf) {\n+            appendTo(buf, 0);\n+        }\n+\n+        public void appendTo(SQLBuffer buf, int index) {\n+            buf.appendValue(0);\n+        }\n+\n+        public String getColumnAlias(Column col) {\n+            return _sel.getColumnAlias(col, _joins);\n+        }\n+\n+        public String getColumnAlias(String col, Table table) {\n+            return _sel.getColumnAlias(col, table, _joins);\n+        }\n+\n+        public Object toDataStoreValue(Object val) {\n+            return val;\n+        }\n+\n+        public boolean isConstant() {\n+            return true;\n+        }\n+\n+        public Object getValue() {\n+            return Numbers.valueOf(0);\n+        }\n+\n+        public Object getSQLValue() {\n+            return Numbers.valueOf(0);\n+        }\n+\n+        public boolean isPath() {\n+            return false;\n+        }\n+\n+        public ClassMapping getClassMapping() {\n+            return null;\n+        }\n+\n+        public FieldMapping getFieldMapping() {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Evaluates to the length of a given value.\n+     */\n+    private class StringLengthFilterValue\n+        implements FilterValue {\n+\n+        private final Select _sel;\n+        private final JDBCStore _store;\n+        private final Object[] _params;\n+        private final JDBCFetchState _fetchState;\n+\n+        public StringLengthFilterValue(Select sel, JDBCStore store,\n+            Object[] params, JDBCFetchState fetchState) {\n+            _sel = sel;\n+            _store = store;\n+            _params = params;\n+            _fetchState = fetchState;\n+        }\n+\n+        public Class getType() {\n+            return int.class;\n+        }\n+\n+        public int length() {\n+            return 1;\n+        }\n+\n+        public void appendTo(SQLBuffer buf) {\n+            appendTo(buf, 0);\n+        }\n+\n+        public void appendTo(SQLBuffer buf, int index) {\n+            buf.append(_pre);\n+            _val2.appendTo(buf, index, _sel, _store, _params, _fetchState);\n+            buf.append(_post);\n+        }\n+\n+        public String getColumnAlias(Column col) {\n+            return _sel.getColumnAlias(col, _val2.getJoins());\n+        }\n+\n+        public String getColumnAlias(String col, Table table) {\n+            return _sel.getColumnAlias(col, table, _val2.getJoins());\n+        }\n+\n+        public Object toDataStoreValue(Object val) {\n+            return _val2.toDataStoreValue(val, _store);\n+        }\n+\n+        public boolean isConstant() {\n+            return false;\n+        }\n+\n+        public Object getValue() {\n+            return null;\n+        }\n+\n+        public Object getSQLValue() {\n+            return null;\n+        }\n+\n+        public boolean isPath() {\n+            return false;\n+        }\n+\n+        public ClassMapping getClassMapping() {\n+            return null;\n+        }\n+\n+        public FieldMapping getFieldMapping() {\n+            return null;\n+        }\n+    }\n+}"},{"sha":"eada06d9a8658654566cf5a48ad25e954be0fb82","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringFunction.java","status":"added","additions":138,"deletions":0,"changes":138,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringFunction.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringFunction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringFunction.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,138 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * A JDBC string function.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+abstract class StringFunction\n+    extends AbstractVal\n+    implements Val {\n+\n+    final Val _val;\n+    ClassMetaData _meta = null;\n+    String _pre = null;\n+    String _post = null;\n+\n+    /**\n+     * Constructor. Provide the string to operate on.\n+     */\n+    public StringFunction(Val val) {\n+        _val = val;\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+    }\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    public Class getType() {\n+        return String.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    public Joins getJoins() {\n+        return _val.getJoins();\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return val;\n+    }\n+\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+        sel.select(newSQLBuffer(sel, store, params, fetchState), this);\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState) {\n+        sel.groupBy(newSQLBuffer(sel, store, params, fetchState), false);\n+    }\n+\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState) {\n+        sel.orderBy(newSQLBuffer(sel, store, params, fetchState), asc, false);\n+    }\n+\n+    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        calculateValue(sel, store, params, null, fetchState);\n+        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n+        appendTo(buf, 0, sel, store, params, fetchState);\n+        clearParameters();\n+        return buf;\n+    }\n+\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState)\n+        throws SQLException {\n+        return Filters.convert(res.getObject(this,\n+            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _val.hasVariable(var);\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        _val.calculateValue(sel, store, params, null, fetchState);\n+    }\n+\n+    public void clearParameters() {\n+        _val.clearParameters();\n+    }\n+\n+    public int length() {\n+        return 1;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        sql.append(_pre);\n+        _val.appendTo(sql, 0, sel, store, params, fetchState);\n+        sql.append(_post);\n+    }\n+}\n+"},{"sha":"6a6899ce0838822131bb829361cb75ad906a1c2f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringLength.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringLength.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringLength.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringLength.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Returns the number of characters in a string.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class StringLength\n+    extends StringFunction {\n+\n+    private Class _cast = null;\n+\n+    /**\n+     * Constructor. Provide the string to operate on.\n+     */\n+    public StringLength(Val val) {\n+        super(val);\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        _val.initialize(sel, store, false);\n+\n+        DBDictionary dict = store.getConfiguration().getDBDictionaryInstance();\n+        String func = dict.stringLengthFunction;\n+        dict.assertSupport(func != null, \"StringLengthFunction\");\n+\n+        int idx = func.indexOf(\"{0}\");\n+        _pre = func.substring(0, idx);\n+        _post = func.substring(idx + 3);\n+    }\n+\n+    public Class getType() {\n+        if (_cast != null)\n+            return _cast;\n+        return int.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _cast = type;\n+    }\n+}\n+"},{"sha":"8f667adfc2067442ffacc5cf5600b7c3c90b7cf0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java","status":"added","additions":238,"deletions":0,"changes":238,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.exps.QueryExpressions;\n+import org.apache.openjpa.kernel.exps.Subquery;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * A subquery.\n+ *\n+ * @author Abe White\n+ */\n+class SubQ\n+    implements Val, Subquery {\n+\n+    private final ClassMapping _candidate;\n+    private final boolean _subs;\n+    private final String _alias;\n+    private final SelectConstructor _cons = new SelectConstructor();\n+\n+    private Class _type = null;\n+    private ClassMetaData _meta = null;\n+    private QueryExpressions _exps = null;\n+    private long _startIdx = 0;\n+    private long _endIdx = Long.MAX_VALUE;\n+\n+    /**\n+     * Constructor. Supply candidate, whether subclasses are included in\n+     * the query, and the query alias.\n+     */\n+    public SubQ(ClassMapping candidate, boolean subs, String alias) {\n+        _candidate = candidate;\n+        _subs = subs;\n+        _alias = alias;\n+    }\n+\n+    /**\n+     * Return the subquery candidate type.\n+     */\n+    public ClassMapping getCandidate() {\n+        return _candidate;\n+    }\n+\n+    public Class getType() {\n+        if (_exps != null) {\n+            if (_exps.projections.length == 0)\n+                return _candidate.getDescribedType();\n+            if (_exps.projections.length == 1)\n+                return _exps.projections[0].getType();\n+        }\n+        return _type;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        if (_exps != null && _exps.projections.length == 1)\n+            _exps.projections[0].setImplicitType(type);\n+        _type = type;\n+    }\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+    }\n+\n+    public String getCandidateAlias() {\n+        return _alias;\n+    }\n+\n+    public void setQueryExpressions(QueryExpressions query, long startIdx,\n+        long endIdx) {\n+        _exps = query;\n+        _startIdx = startIdx;\n+        _endIdx = endIdx;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+    }\n+\n+    public Joins getJoins() {\n+        return null;\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        if (_exps.projections.length == 0)\n+            return _candidate.toDataStoreValue(val,\n+                _candidate.getPrimaryKeyColumns(), store);\n+        if (_exps.projections.length == 1)\n+            return ((Val) _exps.projections[0]).toDataStoreValue(val, store);\n+        return val;\n+    }\n+\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+        selectColumns(sel, store, params, pks, fetchState);\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        sel.select(newSQLBuffer(sel, store, params, fetchState), this);\n+    }\n+\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState) {\n+        sel.groupBy(newSQLBuffer(sel, store, params, fetchState), false);\n+    }\n+\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState) {\n+        sel.orderBy(newSQLBuffer(sel, store, params, fetchState), asc, false);\n+    }\n+\n+    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n+        appendTo(buf, 0, sel, store, params, fetchState);\n+        return buf;\n+    }\n+\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState)\n+        throws SQLException {\n+        return Filters.convert(res.getObject(this,\n+            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        for (int i = 0; i < _exps.projections.length; i++)\n+            if (((Val) _exps.projections[i]).hasVariable(var))\n+                return true;\n+        if (_exps.filter != null)\n+            if (((Exp) _exps.filter).hasVariable(var))\n+                return true;\n+        for (int i = 0; i < _exps.grouping.length; i++)\n+            if (((Val) _exps.grouping[i]).hasVariable(var))\n+                return true;\n+        if (_exps.having != null)\n+            if (((Exp) _exps.having).hasVariable(var))\n+                return true;\n+        for (int i = 0; i < _exps.ordering.length; i++)\n+            if (((Val) _exps.ordering[i]).hasVariable(var))\n+                return true;\n+        return false;\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+    }\n+\n+    public void clearParameters() {\n+    }\n+\n+    public int length() {\n+        return 1;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        appendTo(sql, index, sel, store, params, fetchState, false);\n+    }\n+\n+    private void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState,\n+        boolean size) {\n+        JDBCFetchConfiguration fetch = fetchState.getJDBCFetchConfiguration();\n+        sel = _cons.evaluate(store, sel, _alias, _exps, params,\n+            _cons.CACHE_NULL, fetchState);\n+        _cons.select(store, _candidate, _subs, sel, _exps, params,\n+            fetchState, fetch.EAGER_NONE);\n+        sel.setRange(_startIdx, _endIdx);\n+\n+        if (size)\n+            sql.appendCount(sel, fetch);\n+        else\n+            sql.append(sel, fetch);\n+    }\n+\n+    public void appendIsEmpty(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        sql.append(\"NOT EXISTS \");\n+        appendTo(sql, 0, sel, store, params, fetchState);\n+    }\n+\n+    public void appendIsNotEmpty(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        sql.append(\"EXISTS \");\n+        appendTo(sql, 0, sel, store, params, fetchState);\n+    }\n+\n+    public void appendSize(SQLBuffer sql, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        appendTo(sql, 0, sel, store, params, fetchState, true);\n+    }\n+\n+    public void appendIsNull(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        appendTo(sql, 0, sel, store, params, fetchState);\n+        sql.append(\" IS NULL\");\n+    }\n+\n+    public void appendIsNotNull(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        appendTo(sql, 0, sel, store, params, fetchState);\n+        sql.append(\" IS NOT NULL\");\n+    }\n+}"},{"sha":"6fabba7d37f8bfa2d02735cf807e8c8c0a440f47","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Substring.java","status":"added","additions":158,"deletions":0,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Substring.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Substring.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Substring.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,158 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Take a substring of a string.\n+ *\n+ * @author Abe White\n+ */\n+class Substring\n+    extends AbstractVal\n+    implements Val {\n+\n+    private final Val _val1;\n+    private final Val _val2;\n+    private Joins _joins = null;\n+    private ClassMetaData _meta = null;\n+\n+    /**\n+     * Constructor. Provide the strings to operate on.\n+     */\n+    public Substring(Val val1, Val val2) {\n+        _val1 = val1;\n+        _val2 = val2;\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+    }\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    public Class getType() {\n+        return String.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        _val1.initialize(sel, store, false);\n+        _val2.initialize(sel, store, false);\n+        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return val;\n+    }\n+\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+        sel.select(newSQLBuffer(sel, store, params, fetchState), this);\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val1.selectColumns(sel, store, params, true, fetchState);\n+        _val2.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState) {\n+        sel.groupBy(newSQLBuffer(sel, store, params, fetchState), false);\n+    }\n+\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState) {\n+        sel.orderBy(newSQLBuffer(sel, store, params, fetchState), asc, false);\n+    }\n+\n+    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        calculateValue(sel, store, params, null, fetchState);\n+        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n+        appendTo(buf, 0, sel, store, params, fetchState);\n+        clearParameters();\n+        return buf;\n+    }\n+\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState)\n+        throws SQLException {\n+        return Filters.convert(res.getObject(this,\n+            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _val1.hasVariable(var) || _val2.hasVariable(var);\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        _val1.calculateValue(sel, store, params, null, fetchState);\n+        _val2.calculateValue(sel, store, params, null, fetchState);\n+    }\n+\n+    public void clearParameters() {\n+        _val1.clearParameters();\n+        _val2.clearParameters();\n+    }\n+\n+    public int length() {\n+        return 1;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        FilterValue str = new FilterValueImpl(_val1, sel, store, params,\n+            fetchState);\n+        FilterValue start;\n+        FilterValue end = null;\n+        if (_val2 instanceof Args) {\n+            Val[] args = ((Args) _val2).getVals();\n+            start =\n+                new FilterValueImpl(args[0], sel, store, params, fetchState);\n+            end = new FilterValueImpl(args[1], sel, store, params, fetchState);\n+        } else\n+            start = new FilterValueImpl(_val2, sel, store, params, fetchState);\n+\n+        store.getDBDictionary().substring(sql, str, start, end);\n+    }\n+}\n+"},{"sha":"8821ca4cfec5046530ff460ea7c6d404c7320a9e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sum.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sum.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sum.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sum.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.kernel.Filters;\n+\n+/**\n+ * Sum.\n+ *\n+ * @author Abe White\n+ */\n+class Sum\n+    extends UnaryOp {\n+\n+    /**\n+     * Constructor. Provide the value to operate on.\n+     */\n+    public Sum(Val val) {\n+        super(val);\n+    }\n+\n+    protected Class getType(Class c) {\n+        Class wrap = Filters.wrap(c);\n+        if (wrap == Integer.class\n+            || wrap == Short.class\n+            || wrap == Byte.class)\n+            return long.class;\n+        return c;\n+    }\n+\n+    protected String getOperator() {\n+        return \"SUM\";\n+    }\n+\n+    protected boolean isAggregate() {\n+        return true;\n+    }\n+}"},{"sha":"d54167d8ba688be603ac8300b259ca4252582ffd","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Lower-cases a string.\n+ *\n+ * @author Abe White\n+ */\n+class ToLowerCase\n+    extends StringFunction {\n+\n+    /**\n+     * Constructor. Provide the string to operate on.\n+     */\n+    public ToLowerCase(Val val) {\n+        super(val);\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        _val.initialize(sel, store, false);\n+\n+        DBDictionary dict = store.getDBDictionary();\n+        String func = dict.toLowerCaseFunction;\n+        dict.assertSupport(func != null, \"ToLowerCaseFunction\");\n+\n+        int idx = func.indexOf(\"{0}\");\n+        _pre = func.substring(0, idx);\n+        _post = func.substring(idx + 3);\n+    }\n+}\n+"},{"sha":"934f6b6bfc7ce26ba73744d5cd9ba2626093ebaf","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.Select;\n+\n+/**\n+ * Upper-cases a string.\n+ *\n+ * @author Abe White\n+ */\n+class ToUpperCase\n+    extends StringFunction {\n+\n+    /**\n+     * Constructor. Provide the string to operate on.\n+     */\n+    public ToUpperCase(Val val) {\n+        super(val);\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        _val.initialize(sel, store, false);\n+\n+        DBDictionary dict = store.getDBDictionary();\n+        String func = dict.toUpperCaseFunction;\n+        dict.assertSupport(func != null, \"ToUpperCaseFunction\");\n+\n+        int idx = func.indexOf(\"{0}\");\n+        _pre = func.substring(0, idx);\n+        _post = func.substring(idx + 3);\n+    }\n+}\n+"},{"sha":"cefaff0c26ee6032a067452e0e2da161ccffee8d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Trim.java","status":"added","additions":196,"deletions":0,"changes":196,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Trim.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Trim.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Trim.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.lang.Math;\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.exps.Literal;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Returns the number of characters in a string.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class Trim\n+    extends AbstractVal\n+    implements Val {\n+\n+    private final Val _val;\n+    private final Val _trimChar;\n+    private final Boolean _where;\n+    private ClassMetaData _meta = null;\n+    private String _func = null;\n+\n+    /**\n+     * Constructor. Provide the string to operate on.\n+     */\n+    public Trim(Val val, Val trimChar, Boolean where) {\n+        _val = val;\n+        _trimChar = trimChar;\n+        _where = where;\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+    }\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    public Class getType() {\n+        return String.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        _val.initialize(sel, store, false);\n+\n+        DBDictionary dict = store.getDBDictionary();\n+        if (_where == null) {\n+            _func = dict.trimBothFunction;\n+            dict.assertSupport(_func != null, \"TrimBothFunction\");\n+        } else if (_where.equals(Boolean.TRUE)) {\n+            _func = dict.trimLeadingFunction;\n+            dict.assertSupport(_func != null, \"TrimLeadingFunction\");\n+        } else if (_where.equals(Boolean.FALSE)) {\n+            _func = dict.trimTrailingFunction;\n+            dict.assertSupport(_func != null, \"TrimTrailingFunction\");\n+        }\n+    }\n+\n+    public Joins getJoins() {\n+        return _val.getJoins();\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return val;\n+    }\n+\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+        sel.select(newSQLBuffer(sel, store, params, fetchState), this);\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState) {\n+        sel.groupBy(newSQLBuffer(sel, store, params, fetchState), false);\n+    }\n+\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState) {\n+        sel.orderBy(newSQLBuffer(sel, store, params, fetchState), asc, false);\n+    }\n+\n+    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        calculateValue(sel, store, params, null, fetchState);\n+        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n+        appendTo(buf, 0, sel, store, params, fetchState);\n+        clearParameters();\n+        return buf;\n+    }\n+\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState)\n+        throws SQLException {\n+        return Filters.convert(res.getObject(this,\n+            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _val.hasVariable(var);\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        _val.calculateValue(sel, store, params, null, fetchState);\n+    }\n+\n+    public void clearParameters() {\n+        _val.clearParameters();\n+    }\n+\n+    public int length() {\n+        return 1;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        _val.calculateValue(sel, store, params, _trimChar, fetchState);\n+        _trimChar.calculateValue(sel, store, params, _val, fetchState);\n+\n+        int fromPart = _func.indexOf(\"{0}\");\n+        int charPart = _func.indexOf(\"{1}\");\n+\n+        if (charPart == -1)\n+            charPart = _func.length();\n+\n+        String part1 = _func.substring(0, Math.min(fromPart, charPart));\n+\n+        String part2 = _func.substring(Math.min(fromPart, charPart) + 3,\n+            Math.max(fromPart, charPart));\n+\n+        String part3 = null;\n+        if (charPart != _func.length())\n+            part3 = _func.substring(Math.max(fromPart, charPart) + 3);\n+\n+        sql.append(part1);\n+        (fromPart < charPart ? _val : _trimChar).\n+            appendTo(sql, 0, sel, store, params, fetchState);\n+        sql.append(part2);\n+\n+        if (charPart != _func.length()) {\n+            (fromPart > charPart ? _val : _trimChar).\n+                appendTo(sql, 0, sel, store, params, fetchState);\n+            sql.append(part3);\n+        } else {\n+            // since the trim statement did not specify the token for\n+            // where to specify the trim char (denoted by \"{1}\"),\n+            // we do not have the ability to trim off non-whitespace\n+            // characters; throw an exception when we attempt to do so\n+            if (!(_trimChar instanceof Literal)\n+                || String.valueOf(((Literal) _trimChar).getValue()).\n+                trim().length() != 0) {\n+                store.getDBDictionary().assertSupport(false,\n+                    \"TrimNonWhitespaceCharacters\");\n+            }\n+        }\n+    }\n+}\n+"},{"sha":"c59e4e503c4bf4dec679ff7a2d0d321ab819d194","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/UnaryOp.java","status":"added","additions":171,"deletions":0,"changes":171,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/UnaryOp.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/UnaryOp.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/UnaryOp.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Value produced by a unary operation on a value.\n+ *\n+ * @author Abe White\n+ */\n+abstract class UnaryOp\n+    extends AbstractVal\n+    implements Val {\n+\n+    private final Val _val;\n+    private ClassMetaData _meta = null;\n+    private Class _cast = null;\n+\n+    /**\n+     * Constructor. Provide the value to operate on.\n+     */\n+    public UnaryOp(Val val) {\n+        _val = val;\n+    }\n+\n+    protected Val getVal() {\n+        return _val;\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+    }\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    public Class getType() {\n+        if (_cast != null)\n+            return _cast;\n+        return getType(_val.getType());\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _cast = type;\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        _val.initialize(sel, store, false);\n+    }\n+\n+    public Joins getJoins() {\n+        return _val.getJoins();\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return val;\n+    }\n+\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+        sel.select(newSQLBuffer(sel, store, params, fetchState), this);\n+        if (isAggregate())\n+            sel.setAggregate(true);\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+        _val.selectColumns(sel, store, params, true, fetchState);\n+    }\n+\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState) {\n+        sel.groupBy(newSQLBuffer(sel, store, params, fetchState), false);\n+    }\n+\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState) {\n+        sel.orderBy(newSQLBuffer(sel, store, params, fetchState), asc, false);\n+    }\n+\n+    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState) {\n+        calculateValue(sel, store, params, null, fetchState);\n+        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n+        appendTo(buf, 0, sel, store, params, fetchState);\n+        clearParameters();\n+        return buf;\n+    }\n+\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState)\n+        throws SQLException {\n+        return Filters.convert(res.getObject(this,\n+            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return _val.hasVariable(var);\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        _val.calculateValue(sel, store, params, null, fetchState);\n+    }\n+\n+    public void clearParameters() {\n+        _val.clearParameters();\n+    }\n+\n+    public int length() {\n+        return 1;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+        sql.append(getOperator());\n+        sql.append(\"(\");\n+        _val.appendTo(sql, 0, sel, store, params, fetchState);\n+        sql.append(\")\");\n+    }\n+\n+    /**\n+     * Return whether this operator is an aggregate.\n+     */\n+    protected boolean isAggregate() {\n+        return false;\n+    }\n+\n+    /**\n+     * Return the type of this value based on the argument type. Returns\n+     * the argument type by default.\n+     */\n+    protected Class getType(Class c) {\n+        return c;\n+    }\n+\n+    /**\n+     * Return the name of this operator.\n+     */\n+    protected abstract String getOperator();\n+}\n+"},{"sha":"d0f059a5af2c351626cd774f21a08447feb646e6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Val.java","status":"added","additions":161,"deletions":0,"changes":161,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Val.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Val.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Val.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,161 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.exps.Value;\n+\n+/**\n+ * A Value represents any non-operator in a query filter, including\n+ * constants, variables, and object fields.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public interface Val\n+    extends Value {\n+\n+    /**\n+     * Initialize the value. This method should recursively initialize any\n+     * sub-values. It should also cache the {@link Joins} instance\n+     * containing the joins for this value. No additional joins should be\n+     * made after this call. The parent expression might modify these joins\n+     * during its own initialization so that common joins are moved up the\n+     * expression tree. These joins should not be included in the SQL\n+     * appended through any of the <code>append</code> methods.\n+     *\n+     * @param sel used to create {@link Joins} instances\n+     * @param store the store manager for the query\n+     * @param nullTest if true, then this value will be compared\n+     * to null or tested for emptiness\n+     */\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest);\n+\n+    /**\n+     * Return the joins for this value. These joins should be created\n+     * and cached during the {@link #initialize} method. The parent\n+     * expression might modify these joins during its own initialization so\n+     * that common joins are moved up the expression tree.\n+     */\n+    public Joins getJoins();\n+\n+    /**\n+     * Return the datastore value of the given object in the context of this\n+     * value.\n+     */\n+    public Object toDataStoreValue(Object val, JDBCStore store);\n+\n+    /**\n+     * Select the data for this value.\n+     */\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState);\n+\n+    /**\n+     * Select just the columns for this value.\n+     */\n+    public void selectColumns(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState);\n+\n+    /**\n+     * Group by this value.\n+     */\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState);\n+\n+    /**\n+     * Order by this value.\n+     */\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState);\n+\n+    /**\n+     * Load the data for this value.\n+     */\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState)\n+        throws SQLException;\n+\n+    /**\n+     * Return true if this value uses the given variable.\n+     */\n+    public boolean hasVariable(Variable var);\n+\n+    /**\n+     * Calculate and cache the SQL for this value. This method is called\n+     * before <code>length</code> or any <code>append</code> methods.\n+     *\n+     * @param other the value being compared to, or null if not a comparison\n+     */\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState);\n+\n+    /**\n+     * Clear parameter values held by this value or its subcomponents.\n+     * This method is called sometime after <code>calculateValue</code>.\n+     */\n+    public void clearParameters();\n+\n+    /**\n+     * Return the number of SQL elements in this value.\n+     */\n+    public int length();\n+\n+    /**\n+     * Append the <code>index</code>th SQL element to the given buffer.\n+     */\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState);\n+\n+    /**\n+     * Append the SQL testing whether this value is empty to the given buffer.\n+     */\n+    public void appendIsEmpty(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState);\n+\n+    /**\n+     * Append the SQL testing whether this value is not empty to\n+     * the given buffer.\n+     */\n+    public void appendIsNotEmpty(SQLBuffer sql, Select sel, JDBCStore store,\n+        Object[] params, JDBCFetchState fetchState);\n+\n+    /**\n+     * Append the SQL checking the size of this value.\n+     */\n+    public void appendSize(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState);\n+\n+    /**\n+     * Append the SQL testing whether this value is null to the given buffer.\n+     */\n+    public void appendIsNull(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState);\n+\n+    /**\n+     * Append the SQL testing whether this value is not null to the given\n+     * buffer.\n+     */\n+    public void appendIsNotNull(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState);\n+}"},{"sha":"2aecc5149528561759160d5ec6159719bfe9b754","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Variable.java","status":"added","additions":188,"deletions":0,"changes":188,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Variable.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Variable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Variable.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * A variable in a filter. Typically, the {@link #initialize} and\n+ * {@link #getJoins} methods of this value are not called. They are\n+ * only called if the variable is bound but otherwise unused in the filter,\n+ * in which case we must at least make the joins to the variable because the\n+ * act of binding a variable should at least guarantee that an instance\n+ * represting the variable could exist (i.e. the binding collection is not\n+ * empty).\n+ *\n+ * @author Abe White\n+ */\n+class Variable\n+    implements Val {\n+\n+    private final String _name;\n+    private final Class _type;\n+    private ClassMetaData _meta;\n+    private PCPath _path = null;\n+    private Class _cast = null;\n+\n+    /**\n+     * Constructor. Supply variable name and type.\n+     */\n+    public Variable(String name, Class type) {\n+        _name = name;\n+        _type = type;\n+    }\n+\n+    /**\n+     * Return the variable name.\n+     */\n+    public String getName() {\n+        return _name;\n+    }\n+\n+    /**\n+     * Return true if the variable is bound.\n+     */\n+    public boolean isBound() {\n+        return _path != null;\n+    }\n+\n+    /**\n+     * Return the path this variable is aliased to.\n+     */\n+    public PCPath getPCPath() {\n+        return _path;\n+    }\n+\n+    /**\n+     * Set the path this variable is aliased to.\n+     */\n+    public void setPCPath(PCPath path) {\n+        _path = path;\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+    }\n+\n+    public boolean isVariable() {\n+        return true;\n+    }\n+\n+    public Class getType() {\n+        if (_cast != null)\n+            return _cast;\n+        return _type;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _cast = type;\n+        if (_path != null)\n+            _path.setImplicitType(type);\n+    }\n+\n+    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+        if (_path != null) {\n+            _path.addVariableAction(this);\n+            _path.initialize(sel, store, nullTest);\n+            _path.joinRelation();\n+        }\n+    }\n+\n+    public Joins getJoins() {\n+        return (_path == null) ? null : _path.getJoins();\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return val;\n+    }\n+\n+    public void select(Select sel, JDBCStore store, Object[] params,\n+        boolean pks, JDBCFetchState fetchState) {\n+    }\n+\n+    public void selectColumns(Select sel, JDBCStore store,\n+        Object[] params, boolean pks, JDBCFetchState fetchState) {\n+    }\n+\n+    public void groupBy(Select sel, JDBCStore store, Object[] params,\n+        JDBCFetchState fetchState) {\n+    }\n+\n+    public void orderBy(Select sel, JDBCStore store, Object[] params,\n+        boolean asc, JDBCFetchState fetchState) {\n+    }\n+\n+    public Object load(Result res, JDBCStore store,\n+        JDBCFetchState fetchState)\n+        throws SQLException {\n+        return null;\n+    }\n+\n+    public boolean hasVariable(Variable var) {\n+        return this == var;\n+    }\n+\n+    public void calculateValue(Select sel, JDBCStore store,\n+        Object[] params, Val other, JDBCFetchState fetchState) {\n+        if (_path != null)\n+            _path.calculateValue(sel, store, params, other, fetchState);\n+    }\n+\n+    public void clearParameters() {\n+        if (_path != null)\n+            _path.clearParameters();\n+    }\n+\n+    public int length() {\n+        return 0;\n+    }\n+\n+    public void appendTo(SQLBuffer sql, int index, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+    }\n+\n+    public void appendIsEmpty(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+    }\n+\n+    public void appendIsNotEmpty(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+    }\n+\n+    public void appendSize(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+    }\n+\n+    public void appendIsNull(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+    }\n+\n+    public void appendIsNotNull(SQLBuffer sql, Select sel,\n+        JDBCStore store, Object[] params, JDBCFetchState fetchState) {\n+    }\n+}"},{"sha":"83d4cfe6db38a4dfe151139e423cb7335ba76865","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/package.html","status":"added","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/package.html","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/package.html?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,5 @@\n+<html>\n+<body>\n+<p><strong>OpenJPA-JDBC Expression Tree</strong></p>\n+</body>\n+</html>"},{"sha":"36dccd64acd8b6cb16bde15e0217d93638cedefe","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/package.html","status":"added","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/package.html","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/package.html?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,9 @@\n+<html>\n+<body>\n+<p><strong>OpenJPA-JDBC Runtime Kernel</strong></p>\n+\n+<p>\n+    Runtime services for the JDBC OpenJPA implementation.\n+</p>\n+</body>\n+</html>"},{"sha":"1ef36c290ae0f029b69edf134d3b2c9221f31bce","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"a17aa6289efa32aba69ebc29c4736e2e2a66d15f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMappingInfo.java","status":"added","additions":341,"deletions":0,"changes":341,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMappingInfo.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"4fda0450c93221cb4aebaf1e77f3319a179d2d26","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassStrategy.java","status":"added","additions":112,"deletions":0,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"462131a05728041824e8215479d741b76235fe43","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DelegatingJoinable.java","status":"added","additions":125,"deletions":0,"changes":125,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DelegatingJoinable.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DelegatingJoinable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DelegatingJoinable.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"07b9e56df26dc6933fab6e9031b5f145b5a05410","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Discriminator.java","status":"added","additions":383,"deletions":0,"changes":383,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Discriminator.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Discriminator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Discriminator.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"42a1749f80baec6ab2fe7aa5c14279633ff8b7d2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorMappingInfo.java","status":"added","additions":173,"deletions":0,"changes":173,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorMappingInfo.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"700cd6bf98ac16a63dd0f5f33dfe47b2fb19ea38","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorStrategy.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"a6af670769483c6d4b29a092f109094340bac432","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Embeddable.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Embeddable.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Embeddable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Embeddable.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"f4f74dfe053c2a2b6a7a6996311f41fadebcadd1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java","status":"added","additions":1013,"deletions":0,"changes":1013,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"9106e5fc32c34e55fb715ca0830671e911afe28e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java","status":"added","additions":329,"deletions":0,"changes":329,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"0034b870d4e0fa2b11b901f4799eab65d281f3ba","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldStrategy.java","status":"added","additions":245,"deletions":0,"changes":245,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"5845c11b29ad0d9742796c488f4f7cbda7524e3e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCColumnOrder.java","status":"added","additions":84,"deletions":0,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCColumnOrder.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCColumnOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCColumnOrder.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"4ba634047555bb3e603f1405d1580ecbdc4f8fe3","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCOrder.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCOrder.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCOrder.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"91b4a9ea75e2a29cafff200adea731de1140f6ec","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCRelatedFieldOrder.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCRelatedFieldOrder.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCRelatedFieldOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCRelatedFieldOrder.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"fca7146696263d31a0507a58f311cb57cb0501d1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCValueOrder.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCValueOrder.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCValueOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCValueOrder.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"04cab840cfb7ad1388bb01badb2d8308ade31de6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JavaSQLTypes.java","status":"added","additions":161,"deletions":0,"changes":161,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JavaSQLTypes.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JavaSQLTypes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JavaSQLTypes.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"49b47a21735fab0f02fb8c064c8d7eb95d119aad","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Joinable.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Joinable.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Joinable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Joinable.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"f6b28ae221447375178b3750f28cfa0ec023cf2d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaults.java","status":"added","additions":304,"deletions":0,"changes":304,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaults.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"0614ec26e93c672dd69b81a2ec92b289ed4a1436","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java","status":"added","additions":703,"deletions":0,"changes":703,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"6b648e28d4fa72385ed5fd8f489c0079716a7a10","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java","status":"added","additions":1748,"deletions":0,"changes":1748,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"91e211b1c699cfd38743cd76661d9585ba1d5cb6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","status":"added","additions":1135,"deletions":0,"changes":1135,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"5e92d6b54a2b32752ae33d7cb0b777ddb9305b6c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingStrategyInstaller.java","status":"added","additions":68,"deletions":0,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingStrategyInstaller.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingStrategyInstaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingStrategyInstaller.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"f424b16ef2e3afe102fc72279b4b57203a6c059d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingTool.java","status":"added","additions":1104,"deletions":0,"changes":1104,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingTool.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingTool.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"3d1e589e61d01913d035f598499deee4578a8ed6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MetaDataPlusMappingFactory.java","status":"added","additions":139,"deletions":0,"changes":139,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MetaDataPlusMappingFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MetaDataPlusMappingFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MetaDataPlusMappingFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"1830f01358abb12403ae261a190234d868ee6cfb","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneMappingDefaults.java","status":"added","additions":163,"deletions":0,"changes":163,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneMappingDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneMappingDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneMappingDefaults.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"86188e5187f7cc4afceb6d0bccc7dfbeeea99f86","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneStrategyInstaller.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneStrategyInstaller.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneStrategyInstaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneStrategyInstaller.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"e48f3518458daba1591354ca6ac695418129cd24","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/PropertiesReverseCustomizer.java","status":"added","additions":231,"deletions":0,"changes":231,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/PropertiesReverseCustomizer.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/PropertiesReverseCustomizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/PropertiesReverseCustomizer.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"9650c94d2e39a7f3f21f239b25993143bc802c4c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/QueryResultMapping.java","status":"added","additions":608,"deletions":0,"changes":608,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/QueryResultMapping.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/QueryResultMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/QueryResultMapping.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"427ddd68aca7a870293b4f2a0988f04246b357eb","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RefreshStrategyInstaller.java","status":"added","additions":135,"deletions":0,"changes":135,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RefreshStrategyInstaller.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RefreshStrategyInstaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RefreshStrategyInstaller.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"3fc514835550cdeff5356cb613bd876e4e3f305b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RelationId.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RelationId.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RelationId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RelationId.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"ff2c0f1aea4a038286efbeee4d362b87dbc0d9c2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseCustomizer.java","status":"added","additions":160,"deletions":0,"changes":160,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseCustomizer.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseCustomizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseCustomizer.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"a648a8c445729da54fa0cd3fa37dc2a308f0b3b6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java","status":"added","additions":2053,"deletions":0,"changes":2053,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"cde9ab2116a2d14fdc521d1c97dd8695a4f59118","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RuntimeStrategyInstaller.java","status":"added","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RuntimeStrategyInstaller.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RuntimeStrategyInstaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RuntimeStrategyInstaller.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"1443b54a119e9086a95b78af006d3664dd04d68b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/SequenceMapping.java","status":"added","additions":149,"deletions":0,"changes":149,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/SequenceMapping.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/SequenceMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/SequenceMapping.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"4b4ba62a196ed17d74b33f562cd86e1896db3c4e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Strategy.java","status":"added","additions":131,"deletions":0,"changes":131,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Strategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Strategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Strategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"5d06f9c649efea8607173abf40e7667ae48ce68c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/StrategyInstaller.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/StrategyInstaller.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/StrategyInstaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/StrategyInstaller.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"7140591111918dd5ddf2516af434e47d716eae67","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueHandler.java","status":"added","additions":99,"deletions":0,"changes":99,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueHandler.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"a018fce60d126827209b93db64157ec95b24037d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMapping.java","status":"added","additions":265,"deletions":0,"changes":265,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMapping.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMapping.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"6ae0433b664afc865776bdfb19667e4000f91bde","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingImpl.java","status":"added","additions":536,"deletions":0,"changes":536,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"49af05f8fcda6eb7a9339f5ba3cd4387ccf55f95","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java","status":"added","additions":318,"deletions":0,"changes":318,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"6ea4c57cfb2beffd2851a12e3901373dd40b3a4d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Version.java","status":"added","additions":365,"deletions":0,"changes":365,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Version.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Version.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Version.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"ed9de04a9b6a45012a9264af4d2bc00c3d7a2b17","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionMappingInfo.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionMappingInfo.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"6129a0ce60764c9cb7eda7a08acdcfdcea925fd9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionStrategy.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"0c4f732bbb4d9dad0f97f39458b12811c31e8b64","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/package.html","status":"added","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/package.html","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/package.html?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"098eaf1aa6afcc18abd22ac9eb0398f0563de059","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractClassStrategy.java","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractClassStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"af77115660eae6ef8cf3540ae0ac4f5f6a32b271","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractDiscriminatorStrategy.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractDiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractDiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractDiscriminatorStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"9e7c6984b12bf9cf8eb9bc51d2dc917cead594d8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractFieldStrategy.java","status":"added","additions":174,"deletions":0,"changes":174,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"23e7cc6d5ca8415783f1689b8c5795f659e64ef1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractStrategy.java","status":"added","additions":78,"deletions":0,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"b66b472781b694be0949352177907bac5e965943","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractValueHandler.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractValueHandler.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"dbb6c0552aab8843e2d52b212c3ba6dd4da81a8e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractVersionStrategy.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractVersionStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"3beb8b18b1fdfdb4bd254bdda20141e96663062d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/BlobValueHandler.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/BlobValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/BlobValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/BlobValueHandler.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"331f56ce23a14d3b2cef2e7cbcaabf2dea9400fa","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ByteArrayValueHandler.java","status":"added","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ByteArrayValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ByteArrayValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ByteArrayValueHandler.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"ff23e2d5d7a1d70f8a003a8a17fc26acb6b4bc81","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayStreamValueHandler.java","status":"added","additions":80,"deletions":0,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayStreamValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayStreamValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayStreamValueHandler.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"7d2a109c0f2e3387ec5fa1ff51f01f1465cc68a9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayValueHandler.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayValueHandler.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"31921aa5bba6a083468492e896c2c1868c4e663a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClassNameDiscriminatorStrategy.java","status":"added","additions":123,"deletions":0,"changes":123,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClassNameDiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClassNameDiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClassNameDiscriminatorStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"e2ac2911a2c4a0f8e6430fed9bf85aee98cd2cfe","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClobValueHandler.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClobValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClobValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClobValueHandler.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"1098b3987267a11a99bb3e1c51b91a15d730983d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java","status":"added","additions":262,"deletions":0,"changes":262,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"5c239e0538382ef9ece6d536882891ff9fea3be5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ContainerFieldStrategy.java","status":"added","additions":124,"deletions":0,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ContainerFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ContainerFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ContainerFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"8314c0cede318384dfeb33aca37c9598d6f566ee","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java","status":"added","additions":1573,"deletions":0,"changes":1573,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"6d473c3441da2af85103c5506586ba57ed685fe8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedValueHandler.java","status":"added","additions":169,"deletions":0,"changes":169,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedValueHandler.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"c23f97f89c1287bf0d645c072dfded402f660d8a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbeddedClassStrategy.java","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbeddedClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbeddedClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbeddedClassStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"1069c2ad7a76288905e032a5230b80c0ea259015","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FlatClassStrategy.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FlatClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FlatClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FlatClassStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"1b2635833b1a6b90562fa00697535c64c6279ba8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FullClassStrategy.java","status":"added","additions":133,"deletions":0,"changes":133,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FullClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FullClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FullClassStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"3e70db93143a74a168f85d830addef009a5da151","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerFieldStrategy.java","status":"added","additions":401,"deletions":0,"changes":401,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"1e9c8abc71a109e3c72dbfcc8ce1b9f3a9f55b9f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","status":"added","additions":255,"deletions":0,"changes":255,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"33ef0f648d543bd5c0e37b7d3d863d377652ff52","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerStrategies.java","status":"added","additions":258,"deletions":0,"changes":258,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerStrategies.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerStrategies.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerStrategies.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"f4ab065ac985de9522d795b1475e86e0f00472c9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/IdentityJoinable.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/IdentityJoinable.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/IdentityJoinable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/IdentityJoinable.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"00691c99ab0be6cd184b0e36aa6c6aaf6fcbd71d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ImmutableValueHandler.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ImmutableValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ImmutableValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ImmutableValueHandler.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"bb87893e017eb6f17204e437c131ccc9778b9473","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/InValueDiscriminatorStrategy.java","status":"added","additions":144,"deletions":0,"changes":144,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/InValueDiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/InValueDiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/InValueDiscriminatorStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"41d2051f69234285a9af88ab1ba15c22b4dace04","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSCollectionFieldStrategy.java","status":"added","additions":96,"deletions":0,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSCollectionFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSCollectionFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSCollectionFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"1d85d16bc6c0812d2d12a9566fb7972dd3e16f70","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSMapFieldStrategy.java","status":"added","additions":149,"deletions":0,"changes":149,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSMapFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSMapFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSMapFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"0428ddd3213dec764965e63c478f55958d6fbf58","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyCollection.java","status":"added","additions":234,"deletions":0,"changes":234,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyCollection.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyCollection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyCollection.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"694cc286abb7f929bce11aacdcf8efa8d4866ef5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyMap.java","status":"added","additions":430,"deletions":0,"changes":430,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyMap.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyMap.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"2c811e5604e1c65fad9ccf89bf5697cd7e84d5d5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","status":"added","additions":175,"deletions":0,"changes":175,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"79e880b62fba353b73d5df26222a5d005adbf82b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedBlobFieldStrategy.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedBlobFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedBlobFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedBlobFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"ef4e031d9e5e3a1e004b49ac00c2fff21307f333","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedByteArrayFieldStrategy.java","status":"added","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedByteArrayFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedByteArrayFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedByteArrayFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"4f423b8a3609ee22108b956e0ccd353aa6f1f37b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedCharArrayFieldStrategy.java","status":"added","additions":110,"deletions":0,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedCharArrayFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedCharArrayFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedCharArrayFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"5d98207e3eaf08a350dfc68d5264b12093a4f752","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedClobFieldStrategy.java","status":"added","additions":80,"deletions":0,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedClobFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedClobFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedClobFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"818ec30c80a5ff0746433215bc8e83a2b19a281e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedLobFieldStrategy.java","status":"added","additions":260,"deletions":0,"changes":260,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedLobFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedLobFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedLobFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"da9eb11a491ddfd7af9b06cfad681c1b2a29ab75","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneClassStrategy.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneClassStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"55c002a5793d50af7cbe7eb26a25d9b4ed8338ae","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneDiscriminatorStrategy.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneDiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneDiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneDiscriminatorStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"f209aab956885b553d6b73919f020c3a4f3c315a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneFieldStrategy.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"f2e6353aff39da309501d4dd72550773f8c9a523","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneVersionStrategy.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneVersionStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"4ca9129d8ce9d6dd5cb4068369f63dee0ed1fbde","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NumberVersionStrategy.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NumberVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NumberVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NumberVersionStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"63c0fc228c4ccc76404da84be8b86c4402bfb5d9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdClassStrategy.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdClassStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"0791f628d10c21cb47379136128849558e017a95","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdValueHandler.java","status":"added","additions":81,"deletions":0,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdValueHandler.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"a65c244d82e00e8193cb45287fedb9953e622238","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveFieldStrategy.java","status":"added","additions":400,"deletions":0,"changes":400,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"421c1fa89dffc16f4ef35dc969fe3e63002d0a31","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveWrapperArrays.java","status":"added","additions":85,"deletions":0,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveWrapperArrays.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveWrapperArrays.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveWrapperArrays.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"785ebb338aeb37e79f2f3ffabdfe2d7979efcf84","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionInverseKeyFieldStrategy.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionInverseKeyFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionInverseKeyFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionInverseKeyFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"3053081aa2c7a9338851f62f5f9555b9f695bb47","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionTableFieldStrategy.java","status":"added","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionTableFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"2ec79b9e7636ec9a96158d8ab90907727533baa0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","status":"added","additions":731,"deletions":0,"changes":731,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"90fcf054a667179629c479a9097c6e606b514f1f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapInverseKeyFieldStrategy.java","status":"added","additions":170,"deletions":0,"changes":170,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapInverseKeyFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapInverseKeyFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapInverseKeyFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"74b979796cbf53e71ca979e7e5e377c901aeee6b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapTableFieldStrategy.java","status":"added","additions":170,"deletions":0,"changes":170,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapTableFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"61a0eaf343073a9d0ad5c1c47f87223a08b08824","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationStrategies.java","status":"added","additions":207,"deletions":0,"changes":207,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationStrategies.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationStrategies.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationStrategies.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"17943b1967cb06200606a934f31b3a429a0bbc94","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java","status":"added","additions":309,"deletions":0,"changes":309,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"04b02e9105fbc56fe765b466f22216f9014aaa4a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyTableFieldStrategy.java","status":"added","additions":276,"deletions":0,"changes":276,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyTableFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"18d52d67fc2f69821346712ff3a62274f7090aa5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StateComparisonVersionStrategy.java","status":"added","additions":321,"deletions":0,"changes":321,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StateComparisonVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StateComparisonVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StateComparisonVersionStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"ea4f340b4558dd4929b9f17ea62422e2cf4dba9c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java","status":"added","additions":527,"deletions":0,"changes":527,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"0b7e687e78880556ddaf061886846aed21003be2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StringFieldStrategy.java","status":"added","additions":257,"deletions":0,"changes":257,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StringFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StringFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StringFieldStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"a62d52a9a3f4c7302f528f91944591a084283413","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SubclassJoinDiscriminatorStrategy.java","status":"added","additions":161,"deletions":0,"changes":161,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SubclassJoinDiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SubclassJoinDiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SubclassJoinDiscriminatorStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"6964a033ed1dd281107487e7ad3ae028902f2996","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassDiscriminatorStrategy.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassDiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassDiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassDiscriminatorStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"04d387a5011ee37a778f98b31cff3713e2fbc8b6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassVersionStrategy.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassVersionStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"1d9402ead48dceaa526b0e4205df27dfd777b3ec","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/TimestampVersionStrategy.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/TimestampVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/TimestampVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/TimestampVersionStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"52a0293df355fba823f084d91153d03f50da416c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java","status":"added","additions":119,"deletions":0,"changes":119,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"47fedc27489edb3968367f7ed51e1194cc37da15","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ValueMapDiscriminatorStrategy.java","status":"added","additions":129,"deletions":0,"changes":129,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ValueMapDiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ValueMapDiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ValueMapDiscriminatorStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"3887b522f2c52446b529530e59ba5ae56ba11bb5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/VerticalClassStrategy.java","status":"added","additions":151,"deletions":0,"changes":151,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/VerticalClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/VerticalClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/VerticalClassStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"9fb07498fe25784dfb0ab1826c30f699e5b9164b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/package.html","status":"added","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/package.html","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/package.html?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"14edac8b31d4c93192c968b64a1c8849a3a19f84","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Column.java","status":"added","additions":707,"deletions":0,"changes":707,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Column.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Column.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Column.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"114f41e210b64dd8107cf2cddc8526ddf9bf3992","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java","status":"added","additions":287,"deletions":0,"changes":287,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"85ee9433c4ce694f21bb77b83f0921e0cd416e5f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Constraint.java","status":"added","additions":185,"deletions":0,"changes":185,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Constraint.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Constraint.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Constraint.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"932226b5463c02bda52ca8bd69bad920f1aa17a1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DataSourceFactory.java","status":"added","additions":281,"deletions":0,"changes":281,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DataSourceFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DataSourceFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DataSourceFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"433892537f784870e22c0363881439195bc97e9d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DriverDataSource.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DriverDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DriverDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DriverDataSource.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"06765a1b7a17bb34678d388f37c6b360c44058fd","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DynamicSchemaFactory.java","status":"added","additions":143,"deletions":0,"changes":143,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DynamicSchemaFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DynamicSchemaFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DynamicSchemaFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"d807d5b5756bd4a79000c74e23852e23d3bac15e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/FileSchemaFactory.java","status":"added","additions":100,"deletions":0,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/FileSchemaFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/FileSchemaFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/FileSchemaFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"02c47c04db6a868ca40dc4faf04ff6b0d2b74ac1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","status":"added","additions":683,"deletions":0,"changes":683,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"c0bc65167505faf0b0555f2744b8106d84347664","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Index.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Index.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Index.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Index.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"5092f36c5fae313594ba5a679f9ad7dc4c526c12","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LazySchemaFactory.java","status":"added","additions":190,"deletions":0,"changes":190,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LazySchemaFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LazySchemaFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LazySchemaFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"26caa6050e347d71e8cfcc5fb9c7577ecab2a390","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LocalConstraint.java","status":"added","additions":184,"deletions":0,"changes":184,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LocalConstraint.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LocalConstraint.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LocalConstraint.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"cbce16dc664d32fd2b8903bf4241fded5648ed9d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/NameSet.java","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/NameSet.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/NameSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/NameSet.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"83522fb091a6fb3c3ef49297dc73ad661a4a0655","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/PrimaryKey.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/PrimaryKey.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/PrimaryKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/PrimaryKey.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"fce2b59371ebb5a4daefa5039e7118c4793c67ad","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ReferenceCounter.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ReferenceCounter.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ReferenceCounter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ReferenceCounter.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"e05ccb8229f2f0832bf9b73d101d9817521a4ea1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schema.java","status":"added","additions":259,"deletions":0,"changes":259,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schema.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schema.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schema.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"870156d2bba0ecc5d61ff4bfc729733aa84a2735","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaFactory.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"825b6e52f75ce1d1f7c83099726765b9e6393212","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java","status":"added","additions":943,"deletions":0,"changes":943,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"5be72ac443c2c541d24ea3dd751def350d419355","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGroup.java","status":"added","additions":401,"deletions":0,"changes":401,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGroup.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGroup.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGroup.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"4712a463842699ad1fded9ef8121ef94fe20f042","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaParser.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaParser.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaParser.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"13dc3f347057376dbc9d45891f00807cf9f6abc4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaSerializer.java","status":"added","additions":78,"deletions":0,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaSerializer.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"4eb2633f6454d8b5d669fecc77510e2ea0d9e679","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java","status":"added","additions":1523,"deletions":0,"changes":1523,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"fa641cacc75d58620e042200a20175681f790bb1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schemas.java","status":"added","additions":232,"deletions":0,"changes":232,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schemas.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schemas.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schemas.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"4cc9045acaa1bb5240172dfbf1f5debe6e1b0a9f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Sequence.java","status":"added","additions":209,"deletions":0,"changes":209,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Sequence.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Sequence.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Sequence.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"986cecfb0732b894904fb85017ce3fd3539f0997","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SimpleDriverDataSource.java","status":"added","additions":180,"deletions":0,"changes":180,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SimpleDriverDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SimpleDriverDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SimpleDriverDataSource.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"d3c37880a3906b028f8068eebb9ea64765aa7c20","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java","status":"added","additions":692,"deletions":0,"changes":692,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"64dbbefac184ac21ccd796fba6369d6d6640ac44","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java","status":"added","additions":493,"deletions":0,"changes":493,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"602287f7385780deb4fcd5948625e6fd2b875ba2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"5a37e70829314c327f5a4e2baad9573b728aefa5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java","status":"added","additions":601,"deletions":0,"changes":601,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"50beba2659204fd48d85eb5de75511e24f3190b1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java","status":"added","additions":444,"deletions":0,"changes":444,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"8438bc461d62389ddbf4c7cb72ffdc624391a564","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/package.html","status":"added","additions":16,"deletions":0,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/package.html","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/package.html?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"4f4773355553c4c037ab94d576c85bcb8c77b35e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"1ceb35e5237e0c9dfb1dee57af3407d0881dc00d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java","status":"added","additions":847,"deletions":0,"changes":847,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"a0aea73225702515c34f966d1e264e6669fac496","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java","status":"added","additions":151,"deletions":0,"changes":151,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"47a90da0eaa737c146a4c5ecf5fd34a2d8672074","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java","status":"added","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"f17cd2adae9c66271e3133e7c74c3fab3a7480c8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/CacheDictionary.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/CacheDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/CacheDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/CacheDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"33f2dd5b7ebebf8f687d5c78d69fa9c0c9084969","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Calendard.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Calendard.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Calendard.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Calendard.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"a08e4d6001c8edafeb59a512918dad63101cc2cb","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","status":"added","additions":144,"deletions":0,"changes":144,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"def86e86d07d8db229eff5b7526be9a699ca8537","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","status":"added","additions":3721,"deletions":0,"changes":3721,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"99e00ac8d5d98218d22d5ab4a910d3589ab4425a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java","status":"added","additions":592,"deletions":0,"changes":592,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"fb2000544a571df8a471ca8968ad9bd6cc21329a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java","status":"added","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"622cbf49ca94c75e555e1a528a2d45e416985c6b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java","status":"added","additions":171,"deletions":0,"changes":171,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"2030fba8709099be1c1dae84de561d72b387984d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"50d4f23ee7bc1657fc13a8af66f2ddbae3b3271c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java","status":"added","additions":159,"deletions":0,"changes":159,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"011aba567debd9ab6d8cbbd252a3ba2838f04625","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java","status":"added","additions":309,"deletions":0,"changes":309,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"d4e17e26debe8cb20fb6786de4b2677fd5311015","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java","status":"added","additions":253,"deletions":0,"changes":253,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"5c4b544d46cf8c7f190450cf13f53b2ef70cb874","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java","status":"added","additions":115,"deletions":0,"changes":115,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"179dac6aabb723aa60638046750d4e2b48b0cbc4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java","status":"added","additions":112,"deletions":0,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"954a33e05301cdce69e724df0e6cae8bb2b61986","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java","status":"added","additions":151,"deletions":0,"changes":151,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"799da038586af6e1cc42ef5da7fdb2e5d05bbca1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSet.java","status":"added","additions":403,"deletions":0,"changes":403,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSet.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSet.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"4ff6a950ac1ca40ae2e158c595b967675a0b49b9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSyntaxes.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSyntaxes.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSyntaxes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSyntaxes.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"9ff3b5e4bb2bcb0ac727d706ff7a608bbe5299bd","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"968322e0dacaa157e301c5bb3da02f18e70873d3","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java","status":"added","additions":900,"deletions":0,"changes":900,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"a26a289cdaa8d406bc19a2251d3dc2b441eda5ca","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MergedResult.java","status":"added","additions":534,"deletions":0,"changes":534,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MergedResult.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MergedResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MergedResult.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"aea4fba2a9602dfd881c87c5d321d68f8a98f776","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java","status":"added","additions":166,"deletions":0,"changes":166,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"a846752adb7dde05f073c91e216fa2e22ab6e625","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","status":"added","additions":1019,"deletions":0,"changes":1019,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"54ec7347f25593835aa273bba7068599f7b910cb","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java","status":"added","additions":124,"deletions":0,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"af7b362aba3678841a8b8079592c43e787cca44a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java","status":"added","additions":376,"deletions":0,"changes":376,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"1f611ce86ffd9eb435de557b9285ea2a0c34f763","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java","status":"added","additions":432,"deletions":0,"changes":432,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"4fef3aa48046579e2e32eae8c72a99a306b6be73","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Raw.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Raw.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Raw.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Raw.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"f79c60cd33f492d203b788e1a524330bb1586eb7","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Result.java","status":"added","additions":572,"deletions":0,"changes":572,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Result.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Result.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Result.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"7563f4d624a0f300e9acb3955fc7be17d48770eb","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java","status":"added","additions":488,"deletions":0,"changes":488,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"9ed8f8c15557806e89f6460fa1d87d327425ab39","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Row.java","status":"added","additions":520,"deletions":0,"changes":520,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Row.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Row.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Row.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"cf50e4c9a42b086a30eec2a4a319e767ec251d32","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java","status":"added","additions":941,"deletions":0,"changes":941,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"2163a01b1ffbba9fca72fb4cdb454b7eb387feca","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManager.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"8c2ac6cf7540aee143ff0fe07500049ab064dfd4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManagerImpl.java","status":"added","additions":258,"deletions":0,"changes":258,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManagerImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"5640420a9da2622db2559c3d5fc5c653e4dc714d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","status":"added","additions":609,"deletions":0,"changes":609,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"}]}

