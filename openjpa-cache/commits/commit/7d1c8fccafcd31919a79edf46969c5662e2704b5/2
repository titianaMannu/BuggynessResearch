{"sha":"7d1c8fccafcd31919a79edf46969c5662e2704b5","node_id":"MDY6Q29tbWl0MjA2MzY0OjdkMWM4ZmNjYWZjZDMxOTE5YTc5ZWRmNDY5NjljNTY2MmUyNzA0YjU=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-19T21:34:44Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-19T21:34:44Z"},"message":"OpenJPA JDBC subsystem; reformatted some core OpenJPA code to move catch and finally blocks around.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@423615 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"be4d9e542f71a74f7c6aa343f8d6ec98f572240c","url":"https://api.github.com/repos/apache/openjpa/git/trees/be4d9e542f71a74f7c6aa343f8d6ec98f572240c"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/7d1c8fccafcd31919a79edf46969c5662e2704b5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/7d1c8fccafcd31919a79edf46969c5662e2704b5","html_url":"https://github.com/apache/openjpa/commit/7d1c8fccafcd31919a79edf46969c5662e2704b5","comments_url":"https://api.github.com/repos/apache/openjpa/commits/7d1c8fccafcd31919a79edf46969c5662e2704b5/comments","author":null,"committer":null,"parents":[{"sha":"f9eb746445e84c4d2fab223175ed54cdac45cede","url":"https://api.github.com/repos/apache/openjpa/commits/f9eb746445e84c4d2fab223175ed54cdac45cede","html_url":"https://github.com/apache/openjpa/commit/f9eb746445e84c4d2fab223175ed54cdac45cede"}],"stats":{"total":83470,"additions":81398,"deletions":2072},"files":[{"sha":"c2adba16d22ff0c3c253d21cc92c523102cb5d85","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLExceptions.java","status":"added","additions":103,"deletions":0,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLExceptions.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLExceptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLExceptions.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.SQLException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.StoreException;\n+\n+/**\n+ * Helper class for converting a {@link SQLException} into\n+ * the appropriate OpenJPA type.\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @nojavadoc\n+ */\n+public class SQLExceptions {\n+\n+    private static final SQLException[] EMPTY_EXCEPS = new SQLException[0];\n+\n+    /**\n+     * Convert the specified exception into a {@link StoreException}.\n+     */\n+    public static OpenJPAException getStore(SQLException se) {\n+        return getStore(se, null, null);\n+    }\n+\n+    /**\n+     * Convert the specified exception into a {@link OpenJPAException}.\n+     */\n+    public static OpenJPAException getStore(SQLException se, Object failed) {\n+        return getStore(se, failed, null);\n+    }\n+\n+    /**\n+     * Convert the specified exception into a {@link StoreException}.\n+     */\n+    public static OpenJPAException getStore(SQLException se,\n+        DBDictionary dict) {\n+        return getStore(se.getMessage(), se, dict);\n+    }\n+\n+    /**\n+     * Convert the specified exception into a {@link StoreException}.\n+     */\n+    public static OpenJPAException getStore(SQLException se, Object failed,\n+        DBDictionary dict) {\n+        return getStore(se.getMessage(), se, failed, dict);\n+    }\n+\n+    /**\n+     * Convert the specified exception into a {@link StoreException}.\n+     */\n+    public static OpenJPAException getStore(String msg, SQLException se,\n+        DBDictionary dict) {\n+        return getStore(msg, se, null, dict);\n+    }\n+\n+    /**\n+     * Convert the specified exception into a {@link StoreException}.\n+     */\n+    public static OpenJPAException getStore(String msg, SQLException se,\n+        Object failed, DBDictionary dict) {\n+        if (msg == null)\n+            msg = se.getClass().getName();\n+        SQLException[] ses = getSQLExceptions(se);\n+        if (dict == null)\n+            return new StoreException(msg).setFailedObject(failed).\n+                setNestedThrowables(ses);\n+        return dict.newStoreException(msg, ses, failed);\n+    }\n+\n+    /**\n+     * Returns an array of {@link SQLException} instances for the\n+     * specified exception.\n+     */\n+    private static SQLException[] getSQLExceptions(SQLException se) {\n+        if (se == null)\n+            return EMPTY_EXCEPS;\n+\n+        List errs = new LinkedList();\n+        while (se != null && !errs.contains(se)) {\n+            errs.add(se);\n+            se = se.getNextException();\n+        }\n+        return (SQLException[]) errs.toArray(new SQLException[errs.size()]);\n+    }\n+}"},{"sha":"f5a999739b0c94d6ca80181ff98f28e26238ed33","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactory.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+/**\n+ * Factory for SQL constructs.\n+ *\n+ * @author Abe White\n+ */\n+public interface SQLFactory {\n+\n+    /**\n+     * Select factory.\n+     */\n+    public Select newSelect();\n+\n+    /**\n+     * Union factory.\n+     *\n+     * @param selects the number of selects in the union\n+     */\n+    public Union newUnion(int selects);\n+\n+    /**\n+     * Union factory.\n+     *\n+     * @param selects the members of the union\n+     */\n+    public Union newUnion(Select[] selects);\n+}"},{"sha":"bd43041545840114616fa8df64aae6cbb53693c6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactoryImpl.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactoryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactoryImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+\n+/**\n+ * Default factory for SQL abstraction constructs.\n+ *\n+ * @author Abe White\n+ */\n+public class SQLFactoryImpl\n+    implements SQLFactory, Configurable {\n+\n+    private JDBCConfiguration _conf = null;\n+\n+    /**\n+     * System configuration.\n+     */\n+    public JDBCConfiguration getConfiguration() {\n+        return _conf;\n+    }\n+\n+    public Select newSelect() {\n+        return new SelectImpl(_conf);\n+    }\n+\n+    public Union newUnion(int selects) {\n+        return new LogicalUnion(_conf, selects);\n+    }\n+\n+    public Union newUnion(Select[] selects) {\n+        return new LogicalUnion(_conf, selects);\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+        _conf = (JDBCConfiguration) conf;\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+    }\n+}"},{"sha":"7bafbbdf68cb680d205bdde0495ec780aad4d72a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","status":"added","additions":124,"deletions":0,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+/**\n+ * Dictionary for MS SQLServer.\n+ */\n+public class SQLServerDictionary\n+    extends AbstractSQLServerDictionary {\n+\n+    public static final String VENDOR_MICROSOFT = \"microsoft\";\n+    public static final String VENDOR_NETDIRECT = \"netdirect\";\n+    public static final String VENDOR_JTDS = \"jtds\";\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (SQLServerDictionary.class);\n+\n+    /**\n+     * Flag whether to treat UNIQUEIDENTIFIER as VARBINARY or VARCHAR\n+     */\n+    public boolean uniqueIdentifierAsVarbinary = true;\n+\n+    public SQLServerDictionary() {\n+        platform = \"Microsoft SQL Server\";\n+\n+        // SQLServer locks on a table-by-table basis\n+        forUpdateClause = null;\n+        tableForUpdateClause = \"WITH (UPDLOCK)\";\n+\n+        supportsNullTableForGetColumns = false;\n+        requiresAliasForSubselect = true;\n+\n+        stringLengthFunction = \"LEN({0})\";\n+    }\n+\n+    public void connectedConfiguration(Connection conn)\n+        throws SQLException {\n+        super.connectedConfiguration(conn);\n+\n+        DatabaseMetaData meta = conn.getMetaData();\n+        String driverName = meta.getDriverName();\n+        String url = meta.getURL();\n+        if (driverVendor == null) {\n+            if (\"NetDirect JSQLConnect\".equals(driverName))\n+                driverVendor = VENDOR_NETDIRECT;\n+            else if (driverName != null && driverName.startsWith(\"jTDS\"))\n+                driverVendor = VENDOR_JTDS;\n+            else if (\"SQLServer\".equals(driverName)) {\n+                if (url != null && url.startsWith(\"jdbc:microsoft:sqlserver:\"))\n+                    driverVendor = VENDOR_MICROSOFT;\n+                else if (url != null\n+                    && url.startsWith(\"jdbc:datadirect:sqlserver:\"))\n+                    driverVendor = VENDOR_DATADIRECT;\n+                else\n+                    driverVendor = VENDOR_OTHER;\n+            } else\n+                driverVendor = VENDOR_OTHER;\n+        }\n+\n+        // warn about using cursors\n+        if ((VENDOR_MICROSOFT.equalsIgnoreCase(driverVendor)\n+            || VENDOR_DATADIRECT.equalsIgnoreCase(driverVendor))\n+            && url.toLowerCase().indexOf(\"selectmethod=cursor\") == -1)\n+            log.warn(_loc.get(\"sqlserver-cursor\", url));\n+\n+        // warn about prepared statement caching if using ms driver\n+        String props = conf.getConnectionFactoryProperties();\n+        if (props == null)\n+            props = \"\";\n+        if (VENDOR_MICROSOFT.equalsIgnoreCase(driverVendor)\n+            && props.toLowerCase().indexOf(\"maxcachedstatements=0\") == -1)\n+            log.warn(_loc.get(\"sqlserver-cachedstmnts\"));\n+    }\n+\n+    public Column[] getColumns(DatabaseMetaData meta, String catalog,\n+        String schemaName, String tableName, String columnName, Connection conn)\n+        throws SQLException {\n+        Column[] cols = super.getColumns(meta, catalog, schemaName, tableName,\n+            columnName, conn);\n+\n+        // for opta driver, which reports nvarchar as unknown type\n+        for (int i = 0; cols != null && i < cols.length; i++) {\n+            String typeName = cols[i].getTypeName();\n+            if (typeName == null)\n+                continue;\n+\n+            typeName = typeName.toUpperCase();\n+\n+            if (\"NVARCHAR\".equals(typeName))\n+                cols[i].setType(Types.VARCHAR);\n+            else if (\"UNIQUEIDENTIFIER\".equals(typeName)) {\n+                if (uniqueIdentifierAsVarbinary)\n+                    cols[i].setType(Types.VARBINARY);\n+                else\n+                    cols[i].setType(Types.VARCHAR);\n+            } else if (\"NCHAR\".equals(typeName))\n+                cols[i].setType(Types.CHAR);\n+            else if (\"NTEXT\".equals(typeName))\n+                cols[i].setType(Types.CLOB);\n+        }\n+        return cols;\n+    }\n+}"},{"sha":"5ed5062f2deb16a8668875ced37a70be0d7e6ca6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SecondaryRow.java","status":"added","additions":184,"deletions":0,"changes":184,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SecondaryRow.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SecondaryRow.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SecondaryRow.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.RelationId;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * Secondary table row that tracks foreign keys to auto-inc columns.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class SecondaryRow\n+    extends RowImpl {\n+\n+    private OpenJPAStateManager[] _fks = null;\n+    private ColumnIO[] _fkIO = null;\n+    private OpenJPAStateManager[] _rels = null;\n+    private RelationId[] _callbacks = null;\n+\n+    /**\n+     * Constructor; supply table and action.\n+     */\n+    public SecondaryRow(Table table, int action) {\n+        super(table, action);\n+    }\n+\n+    public void setForeignKey(ForeignKey fk, OpenJPAStateManager sm)\n+        throws SQLException {\n+        setForeignKey(fk, null, sm);\n+    }\n+\n+    public void setForeignKey(ForeignKey fk, ColumnIO io,\n+        OpenJPAStateManager sm)\n+        throws SQLException {\n+        if (!delayForeignKey(fk, sm)) {\n+            super.setForeignKey(fk, io, sm);\n+            return;\n+        }\n+\n+        // force valid\n+        if (canSetAny(io, fk.getColumns().length\n+            + fk.getConstantColumns().length, false))\n+            setValid(true);\n+\n+        // record foreig key for delayed flush\n+        if (_fks == null)\n+            _fks = new OpenJPAStateManager[getTable().getForeignKeys().length];\n+        _fks[fk.getIndex()] = sm;\n+\n+        if (_fkIO != null)\n+            _fkIO[fk.getIndex()] = io;\n+        else if (io != null\n+            && ((getAction() == ACTION_INSERT\n+            && !io.isAllInsertable(fk, false))\n+            || (getAction() != ACTION_INSERT\n+            && !io.isAllUpdatable(fk, false)))) {\n+            _fkIO = new ColumnIO[_fks.length];\n+            _fkIO[fk.getIndex()] = io;\n+        }\n+    }\n+\n+    /**\n+     * Record foreign keys to new auto-inc instances; flush them only when\n+     * we have to generate our SQL to give the instance a chance to finalize\n+     * its values.\n+     */\n+    private boolean delayForeignKey(ForeignKey fk, OpenJPAStateManager sm) {\n+        return fk.isPrimaryKeyAutoAssigned() && getAction() != ACTION_DELETE\n+            && sm != null && sm.isNew() && !sm.isFlushed();\n+    }\n+\n+    public void setRelationId(Column col, OpenJPAStateManager sm,\n+        RelationId rel)\n+        throws SQLException {\n+        if (sm == null || sm.getObjectId() != null || !sm.isNew()\n+            || sm.isFlushed() || !isPrimaryKeyAutoAssigned(sm))\n+            super.setRelationId(col, sm, rel);\n+        else {\n+            if (_rels == null) {\n+                Column[] cols = getTable().getRelationIdColumns();\n+                _rels = new OpenJPAStateManager[cols.length];\n+                _callbacks = new RelationId[cols.length];\n+            }\n+            int idx = getRelationIdIndex(col);\n+            _rels[idx] = sm;\n+            _callbacks[idx] = rel;\n+        }\n+    }\n+\n+    /**\n+     * Return the index into our relation id array of the value for the\n+     * given column.\n+     */\n+    private int getRelationIdIndex(Column col) {\n+        Column[] cols = getTable().getRelationIdColumns();\n+        for (int i = 0; i < cols.length; i++)\n+            if (cols[i] == col)\n+                return i;\n+        return -1;\n+    }\n+\n+    /**\n+     * Return true if any primary key columns of the given instance are\n+     * auto-assigned.\n+     */\n+    private static boolean isPrimaryKeyAutoAssigned(OpenJPAStateManager sm) {\n+        ClassMapping cls = (ClassMapping) sm.getMetaData();\n+        while (cls.getJoinablePCSuperclassMapping() != null)\n+            cls = cls.getJoinablePCSuperclassMapping();\n+        Column[] cols = cls.getPrimaryKeyColumns();\n+        for (int i = 0; i < cols.length; i++)\n+            if (cols[i].isAutoAssigned())\n+                return true;\n+        return false;\n+    }\n+\n+    protected String generateSQL(DBDictionary dict) {\n+        try {\n+            if (_fks != null) {\n+                ForeignKey[] fks = getTable().getForeignKeys();\n+                ColumnIO io;\n+                for (int i = 0; i < _fks.length; i++) {\n+                    if (_fks[i] != null) {\n+                        io = (_fkIO == null) ? null : _fkIO[i];\n+                        super.setForeignKey(fks[i], io, _fks[i]);\n+                    }\n+                }\n+            }\n+            if (_rels != null) {\n+                Column[] cols = getTable().getRelationIdColumns();\n+                for (int i = 0; i < _rels.length; i++)\n+                    if (_rels[i] != null)\n+                        super.setRelationId(cols[i], _rels[i], _callbacks[i]);\n+            }\n+        }\n+        catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, dict);\n+        }\n+        return super.generateSQL(dict);\n+    }\n+\n+    protected RowImpl newInstance(Table table, int action) {\n+        return new SecondaryRow(table, action);\n+    }\n+\n+    public void copyInto(RowImpl row, boolean whereOnly) {\n+        super.copyInto(row, whereOnly);\n+        if (_fks == null || whereOnly || row.getAction() == ACTION_DELETE\n+            || !(row instanceof SecondaryRow))\n+            return;\n+\n+        SecondaryRow srow = (SecondaryRow) row;\n+        if (srow._fks == null)\n+            srow._fks = new OpenJPAStateManager[_fks.length];\n+        System.arraycopy(_fks, 0, srow._fks, 0, _fks.length);\n+        if (_fkIO != null) {\n+            if (srow._fkIO == null)\n+                srow._fkIO = new ColumnIO[_fkIO.length];\n+            System.arraycopy(_fkIO, 0, srow._fkIO, 0, _fkIO.length);\n+        }\n+    }\n+}"},{"sha":"e5edc1662077a1d9495fa79a7041dfe122023781","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java","status":"added","additions":668,"deletions":0,"changes":668,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,668 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+\n+/**\n+ * Abstraction of a SQL SELECT statement.\n+ *\n+ * @author Abe White\n+ */\n+public interface Select\n+    extends SelectExecutor {\n+\n+    /**\n+     * Constant indicating to batch the select using an inner join.\n+     */\n+    public static final int EAGER_INNER = 0;\n+\n+    /**\n+     * Constant indicating to batch the select using an outer join.\n+     */\n+    public static final int EAGER_OUTER = 1;\n+\n+    /**\n+     * Constant indicating to use a separate select executed in parallel.\n+     */\n+    public static final int EAGER_PARALLEL = 2;\n+\n+    /**\n+     * Constant indicating a select can be made without joins.\n+     */\n+    public static final int TYPE_JOINLESS = 3;\n+\n+    /**\n+     * Constant indicating a two-part select and load.\n+     */\n+    public static final int TYPE_TWO_PART = 4;\n+\n+    /**\n+     * Constant indicating to add conditions to the selcet to select this\n+     * class and joinable subclasses only.\n+     */\n+    public static final int SUBS_JOINABLE = 1;\n+\n+    /**\n+     * Constant indicating to add conditions to the select to select this\n+     * class only.\n+     */\n+    public static final int SUBS_NONE = 2;\n+\n+    /**\n+     * Constant indicating to select subclasses but without adding any\n+     * class conditions to the select.\n+     */\n+    public static final int SUBS_ANY_JOINABLE = 3;\n+\n+    /**\n+     * Constant indicating to select this class but without adding any\n+     * class conditions to the select.\n+     */\n+    public static final int SUBS_EXACT = 4;\n+\n+    /**\n+     * The alias to use for the from select, if any.\n+     */\n+    public static final String FROM_SELECT_ALIAS = \"s\";\n+\n+    /**\n+     * The index of this select within the UNION, or 0.\n+     */\n+    public int indexOf();\n+\n+    /**\n+     * Return this select's subselects, or empty collection if none.\n+     */\n+    public List getSubselects();\n+\n+    /**\n+     * Return the parent of this select, if it is a subselect.\n+     */\n+    public Select getParent();\n+\n+    /**\n+     * Return the subselect path for this select, if it is a subselect.\n+     */\n+    public String getSubselectPath();\n+\n+    /**\n+     * Turn this select into a subselect of the given instance.\n+     */\n+    public void setParent(Select parent, String path);\n+\n+    /**\n+     * Another select instance that creates a temporary table from which\n+     * this select pulls data.\n+     */\n+    public Select getFromSelect();\n+\n+    /**\n+     * Another select instance that creates a temporary table from which\n+     * this select pulls data.\n+     */\n+    public void setFromSelect(Select sel);\n+\n+    /**\n+     * Whether this select has an eager join of the specified type.\n+     */\n+    public boolean hasEagerJoin(boolean toMany);\n+\n+    /**\n+     * Whether this select has a join of the specified type.\n+     */\n+    public boolean hasJoin(boolean toMany);\n+\n+    /**\n+     * Return whether the given table is being used in this select.\n+     */\n+    public boolean isSelected(Table table);\n+\n+    /**\n+     * Return the set of all used table aliases.\n+     */\n+    public Collection getTableAliases();\n+\n+    /**\n+     * Return the aliases of all selected columns and all selected buffers,\n+     * in the order they were selected. Each alias may be either a string\n+     * or a {@link SQLBuffer}.\n+     */\n+    public List getSelectAliases();\n+\n+    /**\n+     * Get the aliases for identifier columns that can be used in COUNT\n+     * selects to find the number of matches. Each alias will be a\n+     * string. If no identifier columns have been nominated, then all\n+     * column alises are returned.\n+     */\n+    public List getIdentifierAliases();\n+\n+    /**\n+     * Return the ordering SQL for this select.\n+     */\n+    public SQLBuffer getOrdering();\n+\n+    /**\n+     * Return the grouping SQL for this select.\n+     */\n+    public SQLBuffer getGrouping();\n+\n+    /**\n+     * Return the WHERE clause, minus any necessary end joins.\n+     */\n+    public SQLBuffer getWhere();\n+\n+    /**\n+     * Return the HAVING clause, or null if none.\n+     */\n+    public SQLBuffer getHaving();\n+\n+    /**\n+     * Return the top-level joins for this select.\n+     */\n+    public Joins getJoins();\n+\n+    /**\n+     * Return the top-level {@link Join} elements for this select.\n+     */\n+    public Iterator getJoinIterator();\n+\n+    /**\n+     * The result start index.\n+     */\n+    public long getStartIndex();\n+\n+    /**\n+     * The result end index.\n+     */\n+    public long getEndIndex();\n+\n+    /**\n+     * Set the result range for this select.\n+     */\n+    public void setRange(long start, long end);\n+\n+    /**\n+     * Return the alias for the given column.\n+     */\n+    public String getColumnAlias(Column col);\n+\n+    /**\n+     * Return the alias for the given column.\n+     */\n+    public String getColumnAlias(Column col, Joins joins);\n+\n+    /**\n+     * Return the alias for the given column.\n+     */\n+    public String getColumnAlias(String col, Table table);\n+\n+    /**\n+     * Return the alias for the given column.\n+     */\n+    public String getColumnAlias(String col, Table table, Joins joins);\n+\n+    /**\n+     * Return true if this is an aggregate select.\n+     */\n+    public boolean isAggregate();\n+\n+    /**\n+     * Set to true for aggregate selects.\n+     */\n+    public void setAggregate(boolean agg);\n+\n+    /**\n+     * Return true if this select includes a LOB.\n+     */\n+    public boolean isLob();\n+\n+    /**\n+     * Set to true for selects that include LOB columns.\n+     */\n+    public void setLob(boolean lob);\n+\n+    /**\n+     * Clear the existing column selects.\n+     */\n+    public void clearSelects();\n+\n+    /**\n+     * Select the given SQL as a placeholder for a UNION element.\n+     */\n+    public void selectPlaceholder(String sql);\n+\n+    /**\n+     * Select the given SQL; the given id object is an identifier\n+     * to use when retrieving the corresponding value from a {@link Result}.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean select(SQLBuffer sql, Object id);\n+\n+    /**\n+     * Select the given SQL; the given id object is an identifier\n+     * to use when retrieving the corresponding value from a {@link Result}.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean select(SQLBuffer sql, Object id, Joins joins);\n+\n+    /**\n+     * Select the given SQL; the given id object is an identifier\n+     * to use when retrieving the corresponding value from a {@link Result}.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean select(String sql, Object id);\n+\n+    /**\n+     * Select the given SQL; the given id object is an identifier\n+     * to use when retrieving the corresponding value from a {@link Result}.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean select(String sql, Object id, Joins joins);\n+\n+    /**\n+     * Select the given column.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean select(Column col);\n+\n+    /**\n+     * Select the given column.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean select(Column col, Joins joins);\n+\n+    /**\n+     * Select the given columns.\n+     *\n+     * @return bit set of indexes of columns that were selected\n+     */\n+    public int select(Column[] cols);\n+\n+    /**\n+     * Select the given columns.\n+     *\n+     * @return bit set of indexes of columns that were selected\n+     */\n+    public int select(Column[] cols, Joins joins);\n+\n+    /**\n+     * Select the columns of the given mapping, possibly including subclasses.\n+     * This method should be called after all where conditions are added in\n+     * case the given mapping batches other selects.\n+     */\n+    public void select(ClassMapping mapping, int subclasses,\n+        JDBCStore store, JDBCFetchState fetchState, int eager);\n+\n+    /**\n+     * Select the columns of the given mapping, possibly including subclasses.\n+     * This method should be called after all where conditions are added in\n+     * case the given mapping batches other selects.\n+     */\n+    public void select(ClassMapping mapping, int subclasses,\n+        JDBCStore store, JDBCFetchState fetchState, int eager,\n+        Joins joins);\n+\n+    /**\n+     * Select the given column as one that can be used to get a count of\n+     * distinct matches. It is not necessary to designate distinct identifiers\n+     * when eagerly traversing the entire result of the select or when\n+     * not using an LRSSize setting of <code>count</code>.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean selectIdentifier(Column col);\n+\n+    /**\n+     * Select the given column as one that can be used to get a count of\n+     * distinct matches. It is not necessary to designate distinct identifiers\n+     * when eagerly traversing the entire result of the select or when\n+     * not using an LRSSize setting of <code>count</code>.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean selectIdentifier(Column col, Joins joins);\n+\n+    /**\n+     * Select the given columns as ones that can be used to get a count of\n+     * distinct matches. It is not necessary to designate distinct identifiers\n+     * when eagerly traversing the entire result of the select or when\n+     * not using an LRSSize setting of <code>count</code>.\n+     *\n+     * @return bit set of indexes of columns that were selected\n+     */\n+    public int selectIdentifier(Column[] cols);\n+\n+    /**\n+     * Select the given columns as ones that can be used to get a count of\n+     * distinct matches. It is not necessary to designate distinct identifiers\n+     * when eagerly traversing the entire result of the select or when\n+     * not using an LRSSize setting of <code>count</code>.\n+     *\n+     * @return bit set of indexes of columns that were selected\n+     */\n+    public int selectIdentifier(Column[] cols, Joins joins);\n+\n+    /**\n+     * Select the columns of the given mapping, possibly including subclasses.\n+     * This method should be called after all where conditions are added in\n+     * case the given mapping batches other selects.\n+     * The primary key columns of the mapping can be used to get a count of\n+     * distinct matches. It is not necessary to designate distinct identifiers\n+     * when eagerly traversing the entire result of the select or when\n+     * not using an LRSSize setting of <code>count</code>.\n+     */\n+    public void selectIdentifier(ClassMapping mapping, int subclasses,\n+        JDBCStore store, JDBCFetchState fetchState, int eager);\n+\n+    /**\n+     * Select the columns of the given mapping, possibly including subclasses.\n+     * This method should be called after all where conditions are added in\n+     * case the given mapping batches other selects.\n+     * The primary key columns of the mapping can be used to get a count of\n+     * distinct matches. It is not necessary to designate distinct identifiers\n+     * when eagerly traversing the entire result of the select or when\n+     * not using an LRSSize setting of <code>count</code>.\n+     */\n+    public void selectIdentifier(ClassMapping mapping, int subclasses,\n+        JDBCStore store, JDBCFetchState fetchState, int eager,\n+        Joins joins);\n+\n+    /**\n+     * Select the primary key columns of the given mapping, joining to\n+     * superclasses as necessary to get all columns needed to construct\n+     * an object id.\n+     *\n+     * @return bit set of indexes of pk columns that were selected\n+     */\n+    public int selectPrimaryKey(ClassMapping mapping);\n+\n+    /**\n+     * Select the primary key columns of the given mapping, joining to\n+     * superclasses as necessary to get all columns needed to construct\n+     * an object id.\n+     *\n+     * @return bit set of indexes of pk columns that were selected\n+     */\n+    public int selectPrimaryKey(ClassMapping mapping, Joins joins);\n+\n+    /**\n+     * Clear odering conditions.\n+     */\n+    public void clearOrdering();\n+\n+    /**\n+     * Order on the primary key columns of the given mapping,\n+     * joining to superclasses as necessary to get all columns needed to\n+     * construct an object id.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public int orderByPrimaryKey(ClassMapping mapping, boolean asc,\n+        boolean sel);\n+\n+    /**\n+     * Select and order on the primary key columns of the given mapping,\n+     * joining to superclasses as necessary to get all columns needed to\n+     * construct an object id.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public int orderByPrimaryKey(ClassMapping mapping, boolean asc,\n+        Joins joins, boolean sel);\n+\n+    /**\n+     * Order by the given column.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public boolean orderBy(Column col, boolean asc, boolean sel);\n+\n+    /**\n+     * Order by the given column.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public boolean orderBy(Column col, boolean asc, Joins joins,\n+        boolean sel);\n+\n+    /**\n+     * Order by the given columns.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public int orderBy(Column[] cols, boolean asc, boolean sel);\n+\n+    /**\n+     * Order by the given columns.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public int orderBy(Column[] cols, boolean asc, Joins joins, boolean sel);\n+\n+    /**\n+     * Add an ORDER BY clause.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public boolean orderBy(SQLBuffer sql, boolean asc, boolean sel);\n+\n+    /**\n+     * Add an ORDER BY clause.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public boolean orderBy(SQLBuffer sql, boolean asc, Joins joins,\n+        boolean sel);\n+\n+    /**\n+     * Add an ORDER BY clause.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public boolean orderBy(String sql, boolean asc, boolean sel);\n+\n+    /**\n+     * Add an ORDER BY clause.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public boolean orderBy(String sql, boolean asc, Joins joins, boolean sel);\n+\n+    /**\n+     * Add where conditions setting the mapping's primary key to the given\n+     * oid values. If the given mapping does not use oid values for its\n+     * primary key, we will recursively join to its superclass until we find\n+     * an ancestor that does.\n+     */\n+    public void wherePrimaryKey(Object oid, ClassMapping mapping,\n+        JDBCStore store);\n+\n+    /**\n+     * Add where conditions setting the given foreign key to the given\n+     * oid values.\n+     *\n+     * @see #wherePrimaryKey\n+     */\n+    public void whereForeignKey(ForeignKey fk, Object oid,\n+        ClassMapping mapping, JDBCStore store);\n+\n+    /**\n+     * Add the given where conditions.\n+     */\n+    public void where(Joins joins);\n+\n+    /**\n+     * Add the given where conditions.\n+     */\n+    public void where(SQLBuffer sql);\n+\n+    /**\n+     * Add the given where conditions.\n+     */\n+    public void where(SQLBuffer sql, Joins joins);\n+\n+    /**\n+     * Add the given where conditions.\n+     */\n+    public void where(String sql);\n+\n+    /**\n+     * Add the given where conditions.\n+     */\n+    public void where(String sql, Joins joins);\n+\n+    /**\n+     * Add the given having conditions.\n+     */\n+    public void having(SQLBuffer sql);\n+\n+    /**\n+     * Add the given having conditions.\n+     */\n+    public void having(SQLBuffer sql, Joins joins);\n+\n+    /**\n+     * Add the given having conditions.\n+     */\n+    public void having(String sql);\n+\n+    /**\n+     * Add the given having conditions.\n+     */\n+    public void having(String sql, Joins joins);\n+\n+    /**\n+     * Group by the given column.\n+     * Optionally selects grouping data if not already selected.\n+     */\n+    public boolean groupBy(Column col, boolean sel);\n+\n+    /**\n+     * Group by the given column.\n+     * Optionally selects grouping data if not already selected.\n+     */\n+    public boolean groupBy(Column col, Joins joins, boolean sel);\n+\n+    /**\n+     * Group by the given columns.\n+     * Optionally selects grouping data if not already selected.\n+     */\n+    public int groupBy(Column[] cols, boolean sel);\n+\n+    /**\n+     * Group by the given columns.\n+     * Optionally selects grouping data if not already selected.\n+     */\n+    public int groupBy(Column[] cols, Joins joins, boolean sel);\n+\n+    /**\n+     * Add a GROUP BY clause.\n+     * Optionally selects grouping data if not already selected.\n+     */\n+    public boolean groupBy(SQLBuffer sql, boolean sel);\n+\n+    /**\n+     * Add a GROUP BY clause.\n+     * Optionally selects grouping data if not already selected.\n+     */\n+    public boolean groupBy(SQLBuffer sql, Joins joins, boolean sel);\n+\n+    /**\n+     * Add a GROUP BY clause.\n+     * Optionally selects grouping data if not already selected.\n+     */\n+    public boolean groupBy(String sql, boolean sel);\n+\n+    /**\n+     * Add a GROUP BY clause.\n+     * Optionally selects grouping data if not already selected.\n+     */\n+    public boolean groupBy(String sql, Joins joins, boolean sel);\n+\n+    /**\n+     * Return a SELECT with the same joins and where conditions as this one.\n+     *\n+     * @param sels number of selects to UNION together; ignored if &lt;= 1\n+     */\n+    public SelectExecutor whereClone(int sels);\n+\n+    /**\n+     * Return a SELECT that is a complete clone of this one.\n+     *\n+     * @param sels number of selects to UNION together; ignored if &lt;= 1\n+     */\n+    public SelectExecutor fullClone(int sels);\n+\n+    /**\n+     * Return a select that will be eagerly executed with this one, or null if\n+     * the\tselect cannot be created for the given key and join type.\n+     * If the join type is inner or outer, then this select instance will be\n+     * returned. Otherwise, the returned select will have a clone of this\n+     * select's where conditions and joins but will be independent.\n+     *\n+     * @param key the key for the eager select\n+     * @param eagerType one of the EAGER_* constants\n+     * @param toMany whether the eager join is to-many\n+     * @param sels number of selects to UNION together; ignored if &lt;= 1\n+     */\n+    public SelectExecutor eagerClone(FieldMapping key, int eagerType,\n+        boolean toMany, int sels);\n+\n+    /**\n+     * Return the eager select for the given key.\n+     */\n+    public SelectExecutor getEager(FieldMapping key);\n+\n+    /**\n+     * Return a new instance to use for joining.\n+     */\n+    public Joins newJoins();\n+\n+    /**\n+     * Append the given joins to the given buffer.\n+     */\n+    public void append(SQLBuffer buf, Joins joins);\n+\n+    /**\n+     * AND the given joins together. The given joins will be hollowed in the\n+     * process.\n+     */\n+    public Joins and(Joins joins1, Joins joins2);\n+\n+    /**\n+     * OR the given joins together. The common joins will be removed in the\n+     * process.\n+     */\n+    public Joins or(Joins joins1, Joins joins2);\n+\n+    /**\n+     * Return a join set making the given joins outer joins.\n+     */\n+    public Joins outer(Joins joins);\n+\n+    /**\n+     * Implement toString to generate SQL string for profiling/debuggging.\n+     */\n+    public String toString();\n+}"},{"sha":"1d6d36149becb80dc4ebfaf63e4d2645812bedea","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java","status":"added","additions":122,"deletions":0,"changes":122,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+\n+/**\n+ * Interface for configuring and executing a SQL select.\n+ *\n+ * @author Abe White\n+ */\n+public interface SelectExecutor {\n+\n+    /**\n+     * Return the select configuration.\n+     */\n+    public JDBCConfiguration getConfiguration();\n+\n+    /**\n+     * Return this select as a SQL statement formatted for the current\n+     * dictionary.\n+     */\n+    public SQLBuffer toSelect(boolean forUpdate, JDBCFetchConfiguration fetch);\n+\n+    /**\n+     * Return this select as a COUNT SQL statement formatted for the current\n+     * dictionary.\n+     */\n+    public SQLBuffer toSelectCount();\n+\n+    /**\n+     * Whether to automatically make results distinct when relational joins\n+     * would otherwise introduce duplicates.\n+     */\n+    public boolean getAutoDistinct();\n+\n+    /**\n+     * Whether to automatically make results distinct when relational joins\n+     * would otherwise introduce duplicates.\n+     */\n+    public void setAutoDistinct(boolean distinct);\n+\n+    /**\n+     * Whether this is a SELECT DISTINCT / UNION ALL.\n+     */\n+    public boolean isDistinct();\n+\n+    /**\n+     * Whether this is a SELECT DISTINCT / UNION ALL.\n+     */\n+    public void setDistinct(boolean distinct);\n+\n+    /**\n+     * Whether the result of this select should be treated as a large\n+     * result set.\n+     */\n+    public boolean isLRS();\n+\n+    /**\n+     * Whether the result of this select should be treated as a large\n+     * result set.\n+     */\n+    public void setLRS(boolean lrs);\n+\n+    /**\n+     * The join syntax for this select, as one of the syntax constants from\n+     * {@link JoinSyntaxes}.\n+     */\n+    public int getJoinSyntax();\n+\n+    /**\n+     * The join syntax for this select, as one of the syntax constants from\n+     * {@link JoinSyntaxes}.\n+     */\n+    public void setJoinSyntax(int joinSyntax);\n+\n+    /**\n+     * Return whether this select can support a random access result set type.\n+     */\n+    public boolean supportsRandomAccess(boolean forUpdate);\n+\n+    /**\n+     * Whether this select can be executed for update.\n+     */\n+    public boolean supportsLocking();\n+\n+    /**\n+     * Return the number of instances matching this select.\n+     */\n+    public int getCount(JDBCStore store)\n+        throws SQLException;\n+\n+    /**\n+     * Execute this select in the context of the given store manager.\n+     */\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch)\n+        throws SQLException;\n+\n+    /**\n+     * Execute this select in the context of the given store manager.\n+     */\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n+        int lockLevel)\n+        throws SQLException;\n+}"},{"sha":"071952c23abfe6ba1e61308ea9ea27e73463d4aa","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","status":"added","additions":2795,"deletions":0,"changes":2795,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,2795 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Types;\n+import java.util.AbstractList;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.Stack;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.iterators.EmptyIterator;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchState;\n+import org.apache.openjpa.jdbc.kernel.JDBCLockManager;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.kernel.JDBCStoreManager;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.Joinable;\n+import org.apache.openjpa.jdbc.meta.ValueMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.ApplicationIds;\n+import org.apache.openjpa.util.Id;\n+import org.apache.openjpa.util.InternalException;\n+import serp.util.Numbers;\n+\n+/**\n+ * Standard {@link Select} implementation. Usage note: though this class\n+ * implements {@link Joins}, it should not be used for joining directly.\n+ * Instead, use the return value of {@link #newJoins}.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class SelectImpl\n+    implements Select, PathJoins {\n+\n+    private static final int NONAUTO_DISTINCT = 2 << 0;\n+    private static final int DISTINCT = 2 << 1;\n+    private static final int NOT_DISTINCT = 2 << 2;\n+    private static final int IMPLICIT_DISTINCT = 2 << 3;\n+    private static final int TO_MANY = 2 << 4;\n+    private static final int AGGREGATE = 2 << 5;\n+    private static final int LOB = 2 << 6;\n+    private static final int OUTER = 2 << 7;\n+    private static final int LRS = 2 << 8;\n+    private static final int EAGER_TO_ONE = 2 << 9;\n+    private static final int EAGER_TO_MANY = 2 << 10;\n+    private static final int RECORD_ORDERED = 2 << 11;\n+\n+    private static final String[] TABLE_ALIASES = new String[16];\n+    private static final String[] ORDER_ALIASES = new String[16];\n+    private static final Object[] NULL_IDS = new Object[16];\n+    private static final Object[] PLACEHOLDERS = new Object[50];\n+\n+    private static final Localizer _loc = Localizer.forPackage(Select.class);\n+\n+    static {\n+        for (int i = 0; i < TABLE_ALIASES.length; i++)\n+            TABLE_ALIASES[i] = \"t\" + i;\n+        for (int i = 0; i < ORDER_ALIASES.length; i++)\n+            ORDER_ALIASES[i] = \"o\" + i;\n+        for (int i = 0; i < NULL_IDS.length; i++)\n+            NULL_IDS[i] = new NullId();\n+        for (int i = 0; i < PLACEHOLDERS.length; i++)\n+            PLACEHOLDERS[i] = new Placeholder();\n+    }\n+\n+    private final JDBCConfiguration _conf;\n+    private final DBDictionary _dict;\n+\n+    // map of variable + relation path + table keys to the correct alias index:\n+    // each relation path/table combination should have a unique alias because\n+    // it represents a separate object; for example, if a Person class has a\n+    // 'parent' field representing another Person and also has an 'address'\n+    // field of type Address:\n+    // 'address.street' should map to a different table alias than\n+    // 'parent.address.street' for the purposes of comparisons\n+    private Map _aliases = null;\n+\n+    // map of indexes to table aliases like 'TABLENAME t0'\n+    private SortedMap _tables = null;\n+\n+    // combined list of selected ids and map of each id to its alias\n+    private final Selects _selects = new Selects();\n+    private List _ordered = null;\n+\n+    // flags\n+    private int _flags = 0;\n+    private int _joinSyntax = 0;\n+    private long _startIdx = 0;\n+    private long _endIdx = Long.MAX_VALUE;\n+    private int _nullIds = 0;\n+    private int _orders = 0;\n+    private int _placeholders = 0;\n+\n+    // query clauses\n+    private SQLBuffer _ordering = null;\n+    private SQLBuffer _where = null;\n+    private SQLBuffer _grouping = null;\n+    private SQLBuffer _having = null;\n+\n+    // joins to add to the end of our where clause, and joins to prepend to\n+    // all selects (see select(classmapping) method)\n+    private SelectJoins _joins = null;\n+    private Stack _preJoins = null;\n+\n+    // map of joins+keys to eager selects and global set of eager keys; the\n+    // same key can't be used more than once\n+    private Map _eager = null;\n+    private Set _eagerKeys = null;\n+\n+    // subselect support\n+    private List _subsels = null;\n+    private SelectImpl _parent = null;\n+    private String _subPath = null;\n+\n+    // from select if this select selects from a tmp table created by another\n+    private SelectImpl _from = null;\n+    private SelectImpl _outer = null;\n+\n+    /**\n+     * Helper method to return the proper table alias for the given alias index.\n+     */\n+    static String toAlias(int index) {\n+        if (index == -1)\n+            return null;\n+        if (index < TABLE_ALIASES.length)\n+            return TABLE_ALIASES[index];\n+        return \"t\" + index;\n+    }\n+\n+    /**\n+     * Helper method to return the proper order alias for the given order\n+     * column index.\n+     */\n+    public static String toOrderAlias(int index) {\n+        if (index == -1)\n+            return null;\n+        if (index < ORDER_ALIASES.length)\n+            return ORDER_ALIASES[index];\n+        return \"o\" + index;\n+    }\n+\n+    /**\n+     * Constructor. Supply configuration.\n+     */\n+    public SelectImpl(JDBCConfiguration conf) {\n+        _conf = conf;\n+        _dict = _conf.getDBDictionaryInstance();\n+        _joinSyntax = _dict.joinSyntax;\n+    }\n+\n+    /////////////////////////////////\n+    // SelectExecutor implementation\n+    /////////////////////////////////\n+\n+    public JDBCConfiguration getConfiguration() {\n+        return _conf;\n+    }\n+\n+    public SQLBuffer toSelect(boolean forUpdate, JDBCFetchConfiguration fetch) {\n+        return _dict.toSelect(this, forUpdate, fetch);\n+    }\n+\n+    public SQLBuffer toSelectCount() {\n+        return _dict.toSelectCount(this);\n+    }\n+\n+    public boolean getAutoDistinct() {\n+        return (_flags & NONAUTO_DISTINCT) == 0;\n+    }\n+\n+    public void setAutoDistinct(boolean val) {\n+        if (val)\n+            _flags &= ~NONAUTO_DISTINCT;\n+        else\n+            _flags |= NONAUTO_DISTINCT;\n+    }\n+\n+    public boolean isDistinct() {\n+        return (_flags & NOT_DISTINCT) == 0 && ((_flags & DISTINCT) != 0\n+            || ((_flags & NONAUTO_DISTINCT) == 0\n+            && (_flags & IMPLICIT_DISTINCT) != 0));\n+    }\n+\n+    public void setDistinct(boolean distinct) {\n+        // need two flags in case set not_distinct, then a to-many join happens\n+        // and distinct flag gets set automatically\n+        if (distinct) {\n+            _flags |= DISTINCT;\n+            _flags &= ~NOT_DISTINCT;\n+        } else {\n+            _flags |= NOT_DISTINCT;\n+            _flags &= ~DISTINCT;\n+        }\n+    }\n+\n+    public boolean isLRS() {\n+        return (_flags & LRS) != 0;\n+    }\n+\n+    public void setLRS(boolean lrs) {\n+        if (lrs)\n+            _flags |= LRS;\n+        else\n+            _flags &= ~LRS;\n+    }\n+\n+    public int getJoinSyntax() {\n+        return _joinSyntax;\n+    }\n+\n+    public void setJoinSyntax(int joinSyntax) {\n+        _joinSyntax = joinSyntax;\n+    }\n+\n+    public boolean supportsRandomAccess(boolean forUpdate) {\n+        return _dict.supportsRandomAccessResultSet(this, forUpdate);\n+    }\n+\n+    public boolean supportsLocking() {\n+        return _dict.supportsLocking(this);\n+    }\n+\n+    public int getCount(JDBCStore store)\n+        throws SQLException {\n+        Connection conn = null;\n+        PreparedStatement stmnt = null;\n+        ResultSet rs = null;\n+        try {\n+            SQLBuffer sql = toSelectCount();\n+            conn = store.getConnection();\n+            stmnt = sql.prepareStatement(conn);\n+            rs = stmnt.executeQuery();\n+            rs.next();\n+            return rs.getInt(1);\n+        } finally {\n+            if (rs != null)\n+                try {\n+                    rs.close();\n+                } catch (SQLException se) {\n+                }\n+            if (stmnt != null)\n+                try {\n+                    stmnt.close();\n+                } catch (SQLException se) {\n+                }\n+            if (conn != null)\n+                try {\n+                    conn.close();\n+                } catch (SQLException se) {\n+                }\n+        }\n+    }\n+\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch)\n+        throws SQLException {\n+        if (fetch == null)\n+            fetch = store.getFetchConfiguration();\n+        return execute(this, store.getContext(), store, fetch,\n+            fetch.getReadLockLevel());\n+    }\n+\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n+        int lockLevel)\n+        throws SQLException {\n+        if (fetch == null)\n+            fetch = store.getFetchConfiguration();\n+        return execute(this, store.getContext(), store, fetch, lockLevel);\n+    }\n+\n+    /**\n+     * Execute this select in the context of the given store manager. The\n+     * context is passed in separately for profiling purposes.\n+     */\n+    private static Result execute(SelectImpl sel, StoreContext ctx,\n+        JDBCStore store, JDBCFetchConfiguration fetch, int lockLevel)\n+        throws SQLException {\n+        boolean forUpdate = false;\n+        if (!sel.isAggregate() && sel._grouping == null) {\n+            JDBCLockManager lm = store.getLockManager();\n+            if (lm != null)\n+                forUpdate = lm.selectForUpdate(sel, lockLevel);\n+        }\n+\n+        SQLBuffer sql = sel.toSelect(forUpdate, fetch);\n+        int rsType = (sel.isLRS() && sel.supportsRandomAccess(forUpdate))\n+            ? -1 : ResultSet.TYPE_FORWARD_ONLY;\n+        Connection conn = store.getConnection();\n+        PreparedStatement stmnt = null;\n+        ResultSet rs = null;\n+        try {\n+            if (sel.isLRS())\n+                stmnt = sql.prepareStatement(conn, fetch, rsType, -1);\n+            else\n+                stmnt = sql.prepareStatement(conn, rsType, -1);\n+            rs = stmnt.executeQuery();\n+        } catch (SQLException se) {\n+            // clean up statement\n+            if (stmnt != null)\n+                try {\n+                    stmnt.close();\n+                } catch (SQLException se2) {\n+                }\n+            try {\n+                conn.close();\n+            } catch (SQLException se2) {\n+            }\n+            throw se;\n+        }\n+\n+        SelectResult res = new SelectResult(conn, stmnt, rs, sel._dict);\n+        res.setSelect(sel);\n+        res.setStore(store);\n+        res.setLocking(forUpdate);\n+        try {\n+            addEagerResults(res, sel, store, fetch);\n+        } catch (SQLException se) {\n+            res.close();\n+            throw se;\n+        }\n+        return res;\n+    }\n+\n+    /**\n+     * Execute our eager selects, adding the results under the same keys\n+     * to the given result.\n+     */\n+    private static void addEagerResults(SelectResult res, SelectImpl sel,\n+        JDBCStore store, JDBCFetchConfiguration fetch)\n+        throws SQLException {\n+        if (sel._eager == null)\n+            return;\n+\n+        // execute eager selects\n+        Map.Entry entry;\n+        Result eres;\n+        Map eager;\n+        for (Iterator itr = sel._eager.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+\n+            // simulated batched selects for inner/outer joins; for separate\n+            // selects, don't pass on lock level, because they're probably\n+            // for relations and therefore should use default level\n+            if (entry.getValue() == sel)\n+                eres = res;\n+            else\n+                eres = ((SelectExecutor) entry.getValue()).execute(store,\n+                    fetch);\n+\n+            eager = res.getEagerMap(false);\n+            if (eager == null) {\n+                eager = new HashMap();\n+                res.setEagerMap(eager);\n+            }\n+            eager.put(entry.getKey(), eres);\n+        }\n+    }\n+\n+    /////////////////////////\n+    // Select implementation\n+    /////////////////////////\n+\n+    public int indexOf() {\n+        return 0;\n+    }\n+\n+    public List getSubselects() {\n+        return (_subsels == null) ? Collections.EMPTY_LIST : _subsels;\n+    }\n+\n+    public Select getParent() {\n+        return _parent;\n+    }\n+\n+    public String getSubselectPath() {\n+        return _subPath;\n+    }\n+\n+    public void setParent(Select parent, String path) {\n+        if (path != null)\n+            _subPath = path + ':';\n+        else\n+            _subPath = null;\n+\n+        if (parent == _parent)\n+            return;\n+        if (_parent != null)\n+            _parent._subsels.remove(this);\n+\n+        //### right now we can't use sql92 joins with subselects, cause\n+        //### I can't figure out what to do when the subselect has a join\n+        //### with an alias also present in the outer select... you don't want\n+        //### the join to appear in the FROM clause of the subselect cause\n+        //### then it re-aliases both tables in the scope of the subselect\n+        //### and the correlation with the outer select is lost\n+        _parent = (SelectImpl) parent;\n+        if (_parent != null) {\n+            if (_parent._subsels == null)\n+                _parent._subsels = new ArrayList(2);\n+            _parent._subsels.add(this);\n+            if (_parent._joinSyntax == JoinSyntaxes.SYNTAX_SQL92)\n+                _joinSyntax = JoinSyntaxes.SYNTAX_TRADITIONAL;\n+            else\n+                _joinSyntax = _parent._joinSyntax;\n+        }\n+    }\n+\n+    public Select getFromSelect() {\n+        return _from;\n+    }\n+\n+    public void setFromSelect(Select sel) {\n+        _from = (SelectImpl) sel;\n+        if (_from != null)\n+            _from._outer = this;\n+    }\n+\n+    public boolean hasEagerJoin(boolean toMany) {\n+        if (toMany)\n+            return (_flags & EAGER_TO_MANY) != 0;\n+        return (_flags & EAGER_TO_ONE) != 0;\n+    }\n+\n+    public boolean hasJoin(boolean toMany) {\n+        if (toMany)\n+            return (_flags & TO_MANY) != 0;\n+        return _tables != null && _tables.size() > 1;\n+    }\n+\n+    public boolean isSelected(Table table) {\n+        PathJoins pj = getJoins(null, false);\n+        if (_from != null)\n+            return _from.getTableIndex(table, pj, false) != -1;\n+        return getTableIndex(table, pj, false) != -1;\n+    }\n+\n+    public Collection getTableAliases() {\n+        return (_tables == null) ? Collections.EMPTY_SET : _tables.values();\n+    }\n+\n+    public List getSelectAliases() {\n+        return _selects.getAliases(false, _outer != null);\n+    }\n+\n+    public List getIdentifierAliases() {\n+        return _selects.getAliases(true, _outer != null);\n+    }\n+\n+    public SQLBuffer getOrdering() {\n+        return _ordering;\n+    }\n+\n+    public SQLBuffer getGrouping() {\n+        return _grouping;\n+    }\n+\n+    public SQLBuffer getWhere() {\n+        return _where;\n+    }\n+\n+    public SQLBuffer getHaving() {\n+        return _having;\n+    }\n+\n+    public Joins getJoins() {\n+        return _joins;\n+    }\n+\n+    public Iterator getJoinIterator() {\n+        if (_joins == null || _joins.isEmpty())\n+            return EmptyIterator.INSTANCE;\n+        return _joins.joins().joinIterator();\n+    }\n+\n+    public long getStartIndex() {\n+        return _startIdx;\n+    }\n+\n+    public long getEndIndex() {\n+        return _endIdx;\n+    }\n+\n+    public void setRange(long start, long end) {\n+        _startIdx = start;\n+        _endIdx = end;\n+    }\n+\n+    public String getColumnAlias(Column col) {\n+        return getColumnAlias(col, (Joins) null);\n+    }\n+\n+    public String getColumnAlias(Column col, Joins joins) {\n+        return getColumnAlias(col, getJoins(joins, false));\n+    }\n+\n+    /**\n+     * Return the alias for the given column.\n+     */\n+    private String getColumnAlias(Column col, PathJoins pj) {\n+        return getColumnAlias(col.getName(), col.getTable(), pj);\n+    }\n+\n+    public String getColumnAlias(String col, Table table) {\n+        return getColumnAlias(col, table, (Joins) null);\n+    }\n+\n+    public String getColumnAlias(String col, Table table, Joins joins) {\n+        return getColumnAlias(col, table, getJoins(joins, false));\n+    }\n+\n+    /**\n+     * Return the alias for the given column.\n+     */\n+    private String getColumnAlias(String col, Table table, PathJoins pj) {\n+        if (_from != null) {\n+            String alias = toAlias(_from.getTableIndex(table, pj, true));\n+            if (_dict.requiresAliasForSubselect)\n+                return FROM_SELECT_ALIAS + \".\" + alias + \"_\" + col;\n+            return alias + \"_\" + col;\n+        }\n+        return toAlias(getTableIndex(table, pj, true)) + \".\" + col;\n+    }\n+\n+    public boolean isAggregate() {\n+        return (_flags & AGGREGATE) != 0;\n+    }\n+\n+    public void setAggregate(boolean agg) {\n+        if (agg)\n+            _flags |= AGGREGATE;\n+        else\n+            _flags &= ~AGGREGATE;\n+    }\n+\n+    public boolean isLob() {\n+        return (_flags & LOB) != 0;\n+    }\n+\n+    public void setLob(boolean lob) {\n+        if (lob)\n+            _flags |= LOB;\n+        else\n+            _flags &= ~LOB;\n+    }\n+\n+    public void clearSelects() {\n+        _selects.clear();\n+    }\n+\n+    public boolean select(SQLBuffer sql, Object id) {\n+        return select(sql, id, null);\n+    }\n+\n+    public boolean select(SQLBuffer sql, Object id, Joins joins) {\n+        return select((Object) sql, id, joins);\n+    }\n+\n+    /**\n+     * Record the select of the given SQL buffer or string.\n+     */\n+    private boolean select(Object sql, Object id, Joins joins) {\n+        getJoins(joins, true);\n+        boolean contains;\n+        if (id == null) {\n+            int idx = _selects.indexOfAlias(sql);\n+            contains = idx != -1;\n+            if (contains)\n+                id = _selects.get(idx);\n+            else\n+                id = nullId();\n+        } else\n+            contains = _selects.contains(id);\n+\n+        if (contains)\n+            return false;\n+        _selects.setAlias(id, sql, false);\n+        return true;\n+    }\n+\n+    /**\n+     * Returns a unique id for a SQL string whose given id is null.\n+     */\n+    private Object nullId() {\n+        if (_nullIds >= NULL_IDS.length)\n+            return new NullId();\n+        return NULL_IDS[_nullIds++];\n+    }\n+\n+    public boolean select(String sql, Object id) {\n+        return select(sql, id, null);\n+    }\n+\n+    public boolean select(String sql, Object id, Joins joins) {\n+        return select((Object) sql, id, joins);\n+    }\n+\n+    public void selectPlaceholder(String sql) {\n+        Object holder = (_placeholders >= PLACEHOLDERS.length)\n+            ? new Placeholder() : PLACEHOLDERS[_placeholders++];\n+        select(sql, holder);\n+    }\n+\n+    /**\n+     * Insert a placeholder at the given index; use a negative index\n+     * to count from the back of the select list.\n+     */\n+    public void insertPlaceholder(String sql, int pos) {\n+        Object holder = (_placeholders >= PLACEHOLDERS.length)\n+            ? new Placeholder() : PLACEHOLDERS[_placeholders++];\n+        _selects.insertAlias(pos, holder, sql);\n+    }\n+\n+    /**\n+     * Clear selected placeholders, and return removed select indexes.\n+     */\n+    public void clearPlaceholderSelects() {\n+        _selects.clearPlaceholders();\n+    }\n+\n+    public boolean select(Column col) {\n+        return select(col, (Joins) null);\n+    }\n+\n+    public boolean select(Column col, Joins joins) {\n+        return select(col, getJoins(joins, true), false);\n+    }\n+\n+    public int select(Column[] cols) {\n+        return select(cols, null);\n+    }\n+\n+    public int select(Column[] cols, Joins joins) {\n+        if (cols == null || cols.length == 0)\n+            return 0;\n+        PathJoins pj = getJoins(joins, true);\n+        int seld = 0;\n+        for (int i = 0; i < cols.length; i++)\n+            if (select(cols[i], pj, false))\n+                seld |= 2 << i;\n+        return seld;\n+    }\n+\n+    /**\n+     * Select the given column after making the given joins.\n+     */\n+    private boolean select(Column col, PathJoins pj, boolean ident) {\n+        // we cache on column object if there are no joins so that when\n+        // looking up columns in the result we don't have to create a string\n+        // buffer for the table + column alias; if there are joins, then\n+        // we key on the alias\n+        String alias = getColumnAlias(col, pj);\n+        Object id;\n+        if (pj == null || pj.path() == null)\n+            id = col;\n+        else\n+            id = alias;\n+        if (_selects.contains(id))\n+            return false;\n+\n+        if (col.getType() == Types.BLOB || col.getType() == Types.CLOB)\n+            setLob(true);\n+        _selects.setAlias(id, alias, ident);\n+        return true;\n+    }\n+\n+    public void select(ClassMapping mapping, int subclasses,\n+        JDBCStore store, JDBCFetchState fetchState, int eager) {\n+        select(mapping, subclasses, store, fetchState, eager, null);\n+    }\n+\n+    public void select(ClassMapping mapping, int subclasses,\n+        JDBCStore store, JDBCFetchState fetchState, int eager,\n+        Joins joins) {\n+        select(this, mapping, subclasses, store, fetchState, eager, joins,\n+            false);\n+    }\n+\n+    /**\n+     * Select the given mapping.\n+     */\n+    void select(Select wrapper, ClassMapping mapping, int subclasses,\n+        JDBCStore store, JDBCFetchState fetchState, int eager,\n+        Joins joins, boolean ident) {\n+        // note that this is one case where we don't want to use the result\n+        // of getJoins(); just use the given joins, which will either be clean\n+        // or the result of previous pre-joins. this way we don't push extra\n+        // stack stuff when no actual new joins have been made, and we don't\n+        // think the user wants outer joins when actually only the previous\n+        // joins were outer.  we do invoke getJoins(), though, to add these\n+        // joins (if any) to our top-level joins; otherwise it'd be possible\n+        // for the user to immediately do another join and select something,\n+        // and if we're in outer mode all these joins will get switched to outer\n+        // joins.  caching them as their original join type prevents that\n+        getJoins(joins, true);\n+\n+        PathJoins pj = (PathJoins) joins;\n+        boolean hasJoins = pj != null && pj.isDirty();\n+        if (hasJoins) {\n+            if (_preJoins == null)\n+                _preJoins = new Stack();\n+            _preJoins.push(pj);\n+        }\n+\n+        // if they are selecting this mapping with outer joins, then all joins\n+        // from this mapping should also be outer\n+        boolean wasOuter = (_flags & OUTER) != 0;\n+        if (hasJoins && !wasOuter && pj.isOuter())\n+            _flags |= OUTER;\n+\n+        // delegate to store manager to select in same order it loads result\n+        ((JDBCStoreManager) store).select(wrapper, mapping, subclasses, null,\n+            null, fetchState, eager, ident);\n+\n+        // reset\n+        if (hasJoins)\n+            _preJoins.pop();\n+        if (!wasOuter && (_flags & OUTER) != 0)\n+            _flags &= ~OUTER;\n+    }\n+\n+    public boolean selectIdentifier(Column col) {\n+        return selectIdentifier(col, (Joins) null);\n+    }\n+\n+    public boolean selectIdentifier(Column col, Joins joins) {\n+        return select(col, getJoins(joins, true), true);\n+    }\n+\n+    public int selectIdentifier(Column[] cols) {\n+        return selectIdentifier(cols, null);\n+    }\n+\n+    public int selectIdentifier(Column[] cols, Joins joins) {\n+        if (cols == null || cols.length == 0)\n+            return 0;\n+        PathJoins pj = getJoins(joins, true);\n+        int seld = 0;\n+        for (int i = 0; i < cols.length; i++)\n+            if (select(cols[i], pj, true))\n+                seld |= 2 << i;\n+        return seld;\n+    }\n+\n+    public void selectIdentifier(ClassMapping mapping, int subclasses,\n+        JDBCStore store, JDBCFetchState fetchState, int eager) {\n+        selectIdentifier(mapping, subclasses, store, fetchState, eager, null);\n+    }\n+\n+    public void selectIdentifier(ClassMapping mapping, int subclasses,\n+        JDBCStore store, JDBCFetchState fetchState, int eager,\n+        Joins joins) {\n+        select(this, mapping, subclasses, store, fetchState, eager, joins,\n+            true);\n+    }\n+\n+    public int selectPrimaryKey(ClassMapping mapping) {\n+        return selectPrimaryKey(mapping, null);\n+    }\n+\n+    public int selectPrimaryKey(ClassMapping mapping, Joins joins) {\n+        return primaryKeyOperation(mapping, true, null, joins, false);\n+    }\n+\n+    /**\n+     * Operate on primary key data. Return a bit mask of selected columns.\n+     */\n+    private int primaryKeyOperation(ClassMapping mapping, boolean sel,\n+        Boolean asc, Joins joins, boolean aliasOrder) {\n+        if (!sel && asc == null)\n+            return 0;\n+\n+        // if this mapping can't select the full pk values, then join to\n+        // super and recurse\n+        ClassMapping sup;\n+        if (!mapping.isPrimaryKeyObjectId(true)) {\n+            sup = mapping.getJoinablePCSuperclassMapping();\n+            if (joins == null)\n+                joins = newJoins();\n+            joins = mapping.joinSuperclass(joins, false);\n+            return primaryKeyOperation(sup, sel, asc, joins, aliasOrder);\n+        }\n+\n+        PathJoins pj = getJoins(joins, false);\n+        Column[] cols = mapping.getPrimaryKeyColumns();\n+        int seld = 0;\n+        for (int i = 0, idx; i < cols.length; i++)\n+            if (columnOperation(cols[i], sel, asc, pj, aliasOrder))\n+                seld |= 2 << i;\n+\n+        // if this mapping has not been used in the select yet (and therefore\n+        // is not joined to anything), but has an other-table superclass that\n+        // has been used, make sure to join to it\n+        boolean joined = false;\n+        for (sup = mapping.getJoinablePCSuperclassMapping(); sup != null;\n+            mapping = sup, sup = mapping.getJoinablePCSuperclassMapping()) {\n+            if (sup.getTable() == mapping.getTable())\n+                continue;\n+\n+            if (mapping.getTable() != sup.getTable()\n+                && getTableIndex(mapping.getTable(), pj, false) == -1\n+                && getTableIndex(sup.getTable(), pj, false) != -1) {\n+                if (pj == null)\n+                    pj = (PathJoins) newJoins();\n+                pj = (PathJoins) mapping.joinSuperclass(pj, false);\n+                joined = true;\n+            } else\n+                break;\n+        }\n+        if (joined)\n+            where(pj);\n+\n+        return seld;\n+    }\n+\n+    /**\n+     * Perform an operation on a column.\n+     */\n+    private boolean columnOperation(Column col, boolean sel, Boolean asc,\n+        PathJoins pj, boolean aliasOrder) {\n+        String as = null;\n+        if (asc != null && (aliasOrder || (_flags & RECORD_ORDERED) != 0)) {\n+            Object id;\n+            if (pj == null || pj.path() == null)\n+                id = col;\n+            else\n+                id = getColumnAlias(col, pj);\n+            if ((_flags & RECORD_ORDERED) != 0) {\n+                if (_ordered == null)\n+                    _ordered = new ArrayList(5);\n+                _ordered.add(id);\n+            }\n+            if (aliasOrder) {\n+                as = toOrderAlias(_orders++);\n+                _selects.setSelectAs(id, as);\n+            }\n+        }\n+\n+        boolean seld = sel && select(col, pj, false);\n+        if (asc != null) {\n+            String alias = (as != null) ? as : getColumnAlias(col, pj);\n+            appendOrdering(alias, asc.booleanValue());\n+        }\n+        return seld;\n+    }\n+\n+    /**\n+     * Append ordering information to our internal buffer.\n+     */\n+    private void appendOrdering(Object orderBy, boolean asc) {\n+        if (_ordering == null)\n+            _ordering = new SQLBuffer(_dict);\n+        else\n+            _ordering.append(\", \");\n+\n+        if (orderBy instanceof SQLBuffer)\n+            _ordering.append((SQLBuffer) orderBy);\n+        else\n+            _ordering.append((String) orderBy);\n+        if (asc)\n+            _ordering.append(\" ASC\");\n+        else\n+            _ordering.append(\" DESC\");\n+    }\n+\n+    public int orderByPrimaryKey(ClassMapping mapping, boolean asc,\n+        boolean sel) {\n+        return orderByPrimaryKey(mapping, asc, null, sel);\n+    }\n+\n+    public int orderByPrimaryKey(ClassMapping mapping, boolean asc,\n+        Joins joins, boolean sel) {\n+        return orderByPrimaryKey(mapping, asc, joins, sel, false);\n+    }\n+\n+    /**\n+     * Allow unions to set aliases on order columns.\n+     */\n+    public int orderByPrimaryKey(ClassMapping mapping, boolean asc,\n+        Joins joins, boolean sel, boolean aliasOrder) {\n+        return primaryKeyOperation(mapping, sel,\n+            (asc) ? Boolean.TRUE : Boolean.FALSE, joins, aliasOrder);\n+    }\n+\n+    public boolean orderBy(Column col, boolean asc, boolean sel) {\n+        return orderBy(col, asc, null, sel);\n+    }\n+\n+    public boolean orderBy(Column col, boolean asc, Joins joins, boolean sel) {\n+        return orderBy(col, asc, joins, sel, false);\n+    }\n+\n+    /**\n+     * Allow unions to set aliases on order columns.\n+     */\n+    boolean orderBy(Column col, boolean asc, Joins joins, boolean sel,\n+        boolean aliasOrder) {\n+        return columnOperation(col, sel, (asc) ? Boolean.TRUE : Boolean.FALSE,\n+            getJoins(joins, true), aliasOrder);\n+    }\n+\n+    public int orderBy(Column[] cols, boolean asc, boolean sel) {\n+        return orderBy(cols, asc, null, sel);\n+    }\n+\n+    public int orderBy(Column[] cols, boolean asc, Joins joins, boolean sel) {\n+        return orderBy(cols, asc, joins, sel, false);\n+    }\n+\n+    /**\n+     * Allow unions to set aliases on order columns.\n+     */\n+    int orderBy(Column[] cols, boolean asc, Joins joins, boolean sel,\n+        boolean aliasOrder) {\n+        PathJoins pj = getJoins(joins, true);\n+        int seld = 0;\n+        for (int i = 0; i < cols.length; i++)\n+            if (columnOperation(cols[i], sel,\n+                (asc) ? Boolean.TRUE : Boolean.FALSE, pj, aliasOrder))\n+                seld |= 2 << i;\n+        return seld;\n+    }\n+\n+    public boolean orderBy(SQLBuffer sql, boolean asc, boolean sel) {\n+        return orderBy(sql, asc, (Joins) null, sel);\n+    }\n+\n+    public boolean orderBy(SQLBuffer sql, boolean asc, Joins joins,\n+        boolean sel) {\n+        return orderBy(sql, asc, joins, sel, false);\n+    }\n+\n+    /**\n+     * Allow unions to set aliases on order columns.\n+     */\n+    boolean orderBy(SQLBuffer sql, boolean asc, Joins joins, boolean sel,\n+        boolean aliasOrder) {\n+        return orderBy((Object) sql, asc, joins, sel, aliasOrder);\n+    }\n+\n+    /**\n+     * Order on a SQL buffer or string.\n+     */\n+    private boolean orderBy(Object sql, boolean asc, Joins joins, boolean sel,\n+        boolean aliasOrder) {\n+        Object order = sql;\n+        if (aliasOrder) {\n+            order = toOrderAlias(_orders++);\n+            _selects.setSelectAs(sql, (String) order);\n+        }\n+        if ((_flags & RECORD_ORDERED) != 0) {\n+            if (_ordered == null)\n+                _ordered = new ArrayList(5);\n+            _ordered.add(sql);\n+        }\n+\n+        getJoins(joins, true);\n+        appendOrdering(order, asc);\n+        if (sel) {\n+            int idx = _selects.indexOfAlias(sql);\n+            if (idx == -1) {\n+                _selects.setAlias(nullId(), sql, false);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean orderBy(String sql, boolean asc, boolean sel) {\n+        return orderBy(sql, asc, null, sel);\n+    }\n+\n+    public boolean orderBy(String sql, boolean asc, Joins joins, boolean sel) {\n+        return orderBy(sql, asc, joins, sel, false);\n+    }\n+\n+    /**\n+     * Allow unions to set aliases on order columns.\n+     */\n+    boolean orderBy(String sql, boolean asc, Joins joins, boolean sel,\n+        boolean aliasOrder) {\n+        return orderBy((Object) sql, asc, joins, sel, aliasOrder);\n+    }\n+\n+    public void clearOrdering() {\n+        _ordering = null;\n+        _orders = 0;\n+    }\n+\n+    /**\n+     * Allow unions to record the select list indexes of items we order by.\n+     */\n+    void setRecordOrderedIndexes(boolean record) {\n+        if (record)\n+            _flags |= RECORD_ORDERED;\n+        else {\n+            _ordered = null;\n+            _flags &= ~RECORD_ORDERED;\n+        }\n+    }\n+\n+    /**\n+     * Return the indexes in the select list of all items we're ordering\n+     * by, or null if none. For use with unions.\n+     */\n+    List getOrderedIndexes() {\n+        if (_ordered == null)\n+            return null;\n+        List idxs = new ArrayList(_ordered.size());\n+        for (int i = 0; i < _ordered.size(); i++)\n+            idxs.add(Numbers.valueOf(_selects.indexOf(_ordered.get(i))));\n+        return idxs;\n+    }\n+\n+    public void wherePrimaryKey(Object oid, ClassMapping mapping,\n+        JDBCStore store) {\n+        wherePrimaryKey(oid, mapping, null, store);\n+    }\n+\n+    /**\n+     * Add where conditions setting the mapping's primary key to the given\n+     * oid values. If the given mapping does not use oid values for its\n+     * primary key, we will recursively join to its superclass until we find\n+     * an ancestor that does.\n+     */\n+    private void wherePrimaryKey(Object oid, ClassMapping mapping, Joins joins,\n+        JDBCStore store) {\n+        // if this mapping's identifiers include something other than\n+        // the pk values, join to super and recurse\n+        if (!mapping.isPrimaryKeyObjectId(false)) {\n+            ClassMapping sup = mapping.getJoinablePCSuperclassMapping();\n+            if (joins == null)\n+                joins = newJoins();\n+            joins = mapping.joinSuperclass(joins, false);\n+            wherePrimaryKey(oid, sup, joins, store);\n+            return;\n+        }\n+\n+        Column[] cols = mapping.getPrimaryKeyColumns();\n+        where(oid, mapping, cols, cols, null, null, getJoins(joins, true),\n+            store);\n+    }\n+\n+    public void whereForeignKey(ForeignKey fk, Object oid,\n+        ClassMapping mapping, JDBCStore store) {\n+        whereForeignKey(fk, oid, mapping, null, store);\n+    }\n+\n+    /**\n+     * Add where conditions setting the given foreign key to the given\n+     * oid values.\n+     *\n+     * @see #wherePrimaryKey\n+     */\n+    private void whereForeignKey(ForeignKey fk, Object oid,\n+        ClassMapping mapping, Joins joins, JDBCStore store) {\n+        // if this mapping's identifiers include something other than\n+        // the pk values, or if this foreign key doesn't link to only\n+        // identifiers, join to table and do a getPrimaryKey\n+        if (!mapping.isPrimaryKeyObjectId(false) || !containsAll\n+            (mapping.getPrimaryKeyColumns(), fk.getPrimaryKeyColumns())) {\n+            if (joins == null)\n+                joins = newJoins();\n+            joins = joins.join(fk, false, false);\n+            wherePrimaryKey(oid, mapping, joins, store);\n+            return;\n+        }\n+\n+        Column[] fromCols = fk.getColumns();\n+        Column[] toCols = fk.getPrimaryKeyColumns();\n+        Column[] constCols = fk.getConstantColumns();\n+        Object[] consts = fk.getConstants();\n+        where(oid, mapping, toCols, fromCols, consts, constCols,\n+            getJoins(joins, true), store);\n+    }\n+\n+    /**\n+     * Internal method to flush the oid values as where conditions to the\n+     * given columns.\n+     */\n+    private void where(Object oid, ClassMapping mapping, Column[] toCols,\n+        Column[] fromCols, Object[] vals, Column[] constCols, PathJoins pj,\n+        JDBCStore store) {\n+        ValueMapping embed = mapping.getEmbeddingMapping();\n+        if (embed != null) {\n+            where(oid, embed.getFieldMapping().getDefiningMapping(),\n+                toCols, fromCols, vals, constCols, pj, store);\n+            return;\n+        }\n+\n+        // only bother to pack pk values into array if app id\n+        Object[] pks = null;\n+        if (mapping.getIdentityType() == ClassMapping.ID_APPLICATION)\n+            pks = ApplicationIds.toPKValues(oid, mapping);\n+\n+        SQLBuffer buf = new SQLBuffer(_dict);\n+        Joinable join;\n+        Object val;\n+        int count = 0;\n+        for (int i = 0; i < toCols.length; i++, count++) {\n+            if (pks == null)\n+                val = (oid == null) ? null\n+                    : Numbers.valueOf(((Id) oid).getId());\n+            else {\n+                // must be app identity; use pk index to get correct pk value\n+                join = mapping.assertJoinable(toCols[i]);\n+                val = pks[mapping.getField(join.getFieldIndex()).\n+                    getPrimaryKeyIndex()];\n+                val = join.getJoinValue(val, toCols[i], store);\n+            }\n+\n+            if (count > 0)\n+                buf.append(\" AND \");\n+            buf.append(getColumnAlias(fromCols[i], pj));\n+            if (val == null)\n+                buf.append(\" IS \");\n+            else\n+                buf.append(\" = \");\n+            buf.appendValue(val, fromCols[i]);\n+        }\n+\n+        if (constCols != null && constCols.length > 0) {\n+            for (int i = 0; i < constCols.length; i++, count++) {\n+                if (count > 0)\n+                    buf.append(\" AND \");\n+                buf.append(getColumnAlias(constCols[i], pj));\n+\n+                if (vals[i] == null)\n+                    buf.append(\" IS \");\n+                else\n+                    buf.append(\" = \");\n+                buf.appendValue(vals[i], constCols[i]);\n+            }\n+        }\n+\n+        where(buf, pj);\n+    }\n+\n+    /**\n+     * Test to see if the given set of columns contains all the\n+     * columns in the given potential subset.\n+     */\n+    private static boolean containsAll(Column[] set, Column[] sub) {\n+        if (sub.length > set.length)\n+            return false;\n+\n+        // this is obviously n^2, but the number of columns should be in\n+        // the 1-2 range, so no biggie\n+        boolean found = true;\n+        for (int i = 0; i < sub.length && found; i++) {\n+            found = false;\n+            for (int j = 0; j < set.length && !found; j++)\n+                found = sub[i] == set[j];\n+        }\n+        return found;\n+    }\n+\n+    public void where(Joins joins) {\n+        if (joins != null)\n+            where((String) null, joins);\n+    }\n+\n+    public void where(SQLBuffer sql) {\n+        where(sql, (Joins) null);\n+    }\n+\n+    public void where(SQLBuffer sql, Joins joins) {\n+        where(sql, getJoins(joins, true));\n+    }\n+\n+    /**\n+     * Add the given condition to the WHERE clause.\n+     */\n+    private void where(SQLBuffer sql, PathJoins pj) {\n+        // no need to use joins...\n+        if (sql == null || sql.isEmpty())\n+            return;\n+\n+        if (_where == null)\n+            _where = new SQLBuffer(_dict);\n+        else if (!_where.isEmpty())\n+            _where.append(\" AND \");\n+        _where.append(sql);\n+    }\n+\n+    public void where(String sql) {\n+        where(sql, (Joins) null);\n+    }\n+\n+    public void where(String sql, Joins joins) {\n+        where(sql, getJoins(joins, true));\n+    }\n+\n+    /**\n+     * Add the given condition to the WHERE clause.\n+     */\n+    private void where(String sql, PathJoins pj) {\n+        // no need to use joins...\n+        if (sql == null || sql.length() == 0)\n+            return;\n+\n+        if (_where == null)\n+            _where = new SQLBuffer(_dict);\n+        else if (!_where.isEmpty())\n+            _where.append(\" AND \");\n+        _where.append(sql);\n+    }\n+\n+    public void having(SQLBuffer sql) {\n+        having(sql, (Joins) null);\n+    }\n+\n+    public void having(SQLBuffer sql, Joins joins) {\n+        having(sql, getJoins(joins, true));\n+    }\n+\n+    /**\n+     * Add the given condition to the HAVING clause.\n+     */\n+    private void having(SQLBuffer sql, PathJoins pj) {\n+        // no need to use joins...\n+        if (sql == null || sql.isEmpty())\n+            return;\n+\n+        if (_having == null)\n+            _having = new SQLBuffer(_dict);\n+        else if (!_having.isEmpty())\n+            _having.append(\" AND \");\n+        _having.append(sql);\n+    }\n+\n+    public void having(String sql) {\n+        having(sql, (Joins) null);\n+    }\n+\n+    public void having(String sql, Joins joins) {\n+        having(sql, getJoins(joins, true));\n+    }\n+\n+    /**\n+     * Add the given condition to the HAVING clause.\n+     */\n+    private void having(String sql, PathJoins pj) {\n+        // no need to use joins...\n+        if (sql == null || sql.length() == 0)\n+            return;\n+\n+        if (_having == null)\n+            _having = new SQLBuffer(_dict);\n+        else if (!_having.isEmpty())\n+            _having.append(\" AND \");\n+        _having.append(sql);\n+    }\n+\n+    public boolean groupBy(SQLBuffer sql, boolean sel) {\n+        return groupBy(sql, (Joins) null, sel);\n+    }\n+\n+    public boolean groupBy(SQLBuffer sql, Joins joins, boolean sel) {\n+        getJoins(joins, true);\n+        if (_grouping == null)\n+            _grouping = new SQLBuffer(_dict);\n+        else\n+            _grouping.append(\", \");\n+        _grouping.append(sql);\n+\n+        if (!sel)\n+            return false;\n+        int idx = _selects.indexOfAlias(sql);\n+        if (idx != -1)\n+            return false;\n+        _selects.setAlias(nullId(), sql, false);\n+        return true;\n+    }\n+\n+    public boolean groupBy(String sql, boolean sel) {\n+        return groupBy(sql, (Joins) null, sel);\n+    }\n+\n+    public boolean groupBy(String sql, Joins joins, boolean sel) {\n+        getJoins(joins, true);\n+        if (_grouping == null)\n+            _grouping = new SQLBuffer(_dict);\n+        else\n+            _grouping.append(\", \");\n+        _grouping.append(sql);\n+\n+        if (!sel)\n+            return false;\n+        int idx = _selects.indexOfAlias(sql);\n+        if (idx != -1)\n+            return false;\n+        _selects.setAlias(nullId(), sql, false);\n+        return true;\n+    }\n+\n+    public boolean groupBy(Column col, boolean sel) {\n+        return groupBy(col, null, sel);\n+    }\n+\n+    public boolean groupBy(Column col, Joins joins, boolean sel) {\n+        if (_grouping == null)\n+            _grouping = new SQLBuffer(_dict);\n+        else\n+            _grouping.append(\", \");\n+\n+        PathJoins pj = getJoins(joins, true);\n+        _grouping.append(getColumnAlias(col, pj));\n+        return sel && select(col, pj, false);\n+    }\n+\n+    public int groupBy(Column[] cols, boolean sel) {\n+        return groupBy(cols, null, sel);\n+    }\n+\n+    public int groupBy(Column[] cols, Joins joins, boolean sel) {\n+        if (_grouping == null)\n+            _grouping = new SQLBuffer(_dict);\n+        else\n+            _grouping.append(\", \");\n+\n+        PathJoins pj = getJoins(joins, true);\n+        int seld = 0;\n+        for (int i = 0; i < cols.length; i++) {\n+            if (i > 0)\n+                _grouping.append(\", \");\n+            _grouping.append(getColumnAlias(cols[i], pj));\n+\n+            if (sel && select(cols[i], pj, false))\n+                seld |= 2 << i;\n+        }\n+        return seld;\n+    }\n+\n+    /**\n+     * Return the joins to use for column aliases, etc.\n+     *\n+     * @param joins joins given by the user\n+     * @return the joins to use for aliases, etc\n+     */\n+    private PathJoins getJoins(Joins joins, boolean record) {\n+        PathJoins pj = (PathJoins) joins;\n+        boolean pre = (pj == null || !pj.isDirty())\n+            && _preJoins != null && !_preJoins.isEmpty();\n+        if (pre)\n+            pj = (PathJoins) _preJoins.peek();\n+\n+        if (pj == null || !pj.isDirty())\n+            pj = _joins;\n+        else if (!pre) {\n+            if ((_flags & OUTER) != 0)\n+                pj = (PathJoins) outer(pj);\n+            if (record) {\n+                if (!pj.isEmpty())\n+                    removeParentJoins(pj);\n+                if (!pj.isEmpty()) {\n+                    removeJoinsFromSubselects(pj);\n+                    if (_joins == null)\n+                        _joins = new SelectJoins(this);\n+                    if (_joins.joins() == null)\n+                        _joins.setJoins(new JoinSet(pj.joins()));\n+                    else\n+                        _joins.joins().addAll(pj.joins());\n+                }\n+            }\n+        }\n+        return pj;\n+    }\n+\n+    /**\n+     * Remove any joins already in our parent select from the given non-empty\n+     * join set.\n+     */\n+    private void removeParentJoins(PathJoins pj) {\n+        if (_parent == null)\n+            return;\n+        if (_parent._joins != null && !_parent._joins.isEmpty())\n+            pj.joins().removeAll(_parent._joins.joins());\n+        if (!pj.isEmpty())\n+            _parent.removeParentJoins(pj);\n+    }\n+\n+    /**\n+     * Remove the given non-empty joins from the joins of our subselects.\n+     */\n+    private void removeJoinsFromSubselects(PathJoins pj) {\n+        if (_subsels == null)\n+            return;\n+        SelectImpl sub;\n+        for (int i = 0; i < _subsels.size(); i++) {\n+            sub = (SelectImpl) _subsels.get(i);\n+            if (sub._joins != null && !sub._joins.isEmpty())\n+                sub._joins.joins().removeAll(pj.joins());\n+        }\n+    }\n+\n+    public SelectExecutor whereClone(int sels) {\n+        if (sels < 1)\n+            sels = 1;\n+\n+        Select[] clones = null;\n+        SelectImpl sel;\n+        for (int i = 0; i < sels; i++) {\n+            sel = new SelectImpl(_conf);\n+            sel._flags = _flags;\n+            sel._flags &= ~AGGREGATE;\n+            sel._flags &= ~OUTER;\n+            sel._flags &= ~LRS;\n+            sel._flags &= ~EAGER_TO_ONE;\n+            sel._flags &= ~EAGER_TO_MANY;\n+            sel._joinSyntax = _joinSyntax;\n+            if (_aliases != null)\n+                sel._aliases = new HashMap(_aliases);\n+            if (_tables != null)\n+                sel._tables = new TreeMap(_tables);\n+            if (_joins != null)\n+                sel._joins = _joins.clone(sel);\n+            if (_where != null)\n+                sel._where = new SQLBuffer(_where);\n+            if (_from != null) {\n+                sel._from = (SelectImpl) _from.whereClone(1);\n+                sel._from._outer = sel;\n+            }\n+            if (_subsels != null) {\n+                sel._subsels = new ArrayList(_subsels.size());\n+                SelectImpl sub, selSub;\n+                for (int j = 0; j < _subsels.size(); j++) {\n+                    sub = (SelectImpl) _subsels.get(j);\n+                    selSub = (SelectImpl) sub.fullClone(1);\n+                    selSub._parent = sel;\n+                    selSub._subPath = sub._subPath;\n+                    sel._subsels.add(selSub);\n+                    if (sel._where != null)\n+                        sel._where.replace(sub, selSub);\n+                }\n+            }\n+\n+            if (sels == 1)\n+                return sel;\n+            if (clones == null)\n+                clones = new Select[sels];\n+            clones[i] = sel;\n+        }\n+        return _conf.getSQLFactoryInstance().newUnion(clones);\n+    }\n+\n+    public SelectExecutor fullClone(int sels) {\n+        if (sels < 1)\n+            sels = 1;\n+\n+        Select[] clones = null;\n+        SelectImpl sel;\n+        for (int i = 0; i < sels; i++) {\n+            sel = (SelectImpl) whereClone(1);\n+            sel._flags = _flags;\n+            sel._selects.addAll(_selects);\n+            if (_ordering != null)\n+                sel._ordering = new SQLBuffer(_ordering);\n+            sel._orders = _orders;\n+            if (_grouping != null)\n+                sel._grouping = new SQLBuffer(_grouping);\n+            if (_having != null)\n+                sel._having = new SQLBuffer(_having);\n+            if (_from != null) {\n+                sel._from = (SelectImpl) _from.fullClone(1);\n+                sel._from._outer = sel;\n+            }\n+\n+            if (sels == 1)\n+                return sel;\n+            if (clones == null)\n+                clones = new Select[sels];\n+            clones[i] = sel;\n+        }\n+        return _conf.getSQLFactoryInstance().newUnion(clones);\n+    }\n+\n+    public SelectExecutor eagerClone(FieldMapping key, int eagerType,\n+        boolean toMany, int sels) {\n+        if (eagerType == EAGER_OUTER\n+            && _joinSyntax == JoinSyntaxes.SYNTAX_TRADITIONAL)\n+            return null;\n+        if (_eagerKeys != null && _eagerKeys.contains(key))\n+            return null;\n+\n+        // global set of eager keys\n+        if (_eagerKeys == null)\n+            _eagerKeys = new HashSet();\n+        _eagerKeys.add(key);\n+\n+        SelectExecutor sel;\n+        if (eagerType != EAGER_PARALLEL) {\n+            if (toMany)\n+                _flags |= EAGER_TO_MANY;\n+            else\n+                _flags |= EAGER_TO_ONE;\n+            sel = this;\n+        } else if (sels < 2)\n+            sel = parallelClone();\n+        else {\n+            Select[] clones = new Select[sels];\n+            for (int i = 0; i < clones.length; i++)\n+                clones[i] = parallelClone();\n+            sel = _conf.getSQLFactoryInstance().newUnion(clones);\n+        }\n+\n+        if (_eager == null)\n+            _eager = new HashMap();\n+        _eager.put(toEagerKey(key, getJoins(null, false)), sel);\n+        return sel;\n+    }\n+\n+    /**\n+     * Return a clone of this select for use in eager parallel selects.\n+     */\n+    private SelectImpl parallelClone() {\n+        SelectImpl sel = (SelectImpl) whereClone(1);\n+        sel._flags &= ~NONAUTO_DISTINCT;\n+        sel._eagerKeys = _eagerKeys;\n+        if (_preJoins != null && !_preJoins.isEmpty()) {\n+            sel._preJoins = new Stack();\n+            sel._preJoins.push(((SelectJoins) _preJoins.peek()).\n+                clone(sel));\n+        }\n+        return sel;\n+    }\n+\n+    /**\n+     * Return view of eager selects. May be null.\n+     */\n+    public Map getEagerMap() {\n+        return _eager;\n+    }\n+\n+    public SelectExecutor getEager(FieldMapping key) {\n+        if (_eager == null || !_eagerKeys.contains(key))\n+            return null;\n+        return (SelectExecutor) _eager.get(toEagerKey(key, getJoins(null,\n+            false)));\n+    }\n+\n+    /**\n+     * Return the eager key to use for the user-given key.\n+     */\n+    private static Object toEagerKey(FieldMapping key, PathJoins pj) {\n+        if (pj == null || pj.path() == null)\n+            return key;\n+        return new Key(pj.path().toString(), key);\n+    }\n+\n+    public Joins newJoins() {\n+        if (_preJoins != null && !_preJoins.isEmpty()) {\n+            SelectJoins sj = (SelectJoins) _preJoins.peek();\n+            return sj.clone(this);\n+        }\n+        // return this for efficiency in case no joins end up being made\n+        return this;\n+    }\n+\n+    public void append(SQLBuffer buf, Joins joins) {\n+        if (joins == null || joins.isEmpty())\n+            return;\n+\n+        if (!buf.isEmpty())\n+            buf.append(\" AND \");\n+        Join join = null;\n+        for (Iterator itr = ((PathJoins) joins).joins().joinIterator();\n+            itr.hasNext();) {\n+            join = (Join) itr.next();\n+            switch (_joinSyntax) {\n+                case JoinSyntaxes.SYNTAX_TRADITIONAL:\n+                    buf.append(_dict.toTraditionalJoin(join));\n+                    break;\n+                case JoinSyntaxes.SYNTAX_DATABASE:\n+                    buf.append(_dict.toNativeJoin(join));\n+                    break;\n+                default:\n+                    throw new InternalException();\n+            }\n+\n+            if (itr.hasNext())\n+                buf.append(\" AND \");\n+        }\n+    }\n+\n+    public Joins and(Joins joins1, Joins joins2) {\n+        return and((PathJoins) joins1, (PathJoins) joins2, true);\n+    }\n+\n+    /**\n+     * Combine the given joins.\n+     */\n+    private SelectJoins and(PathJoins j1, PathJoins j2, boolean nullJoins) {\n+        if ((j1 == null || j1.isEmpty())\n+            && (j2 == null || j2.isEmpty()))\n+            return null;\n+\n+        SelectJoins sj = new SelectJoins(this);\n+        if (j1 == null || j1.isEmpty()) {\n+            if (nullJoins)\n+                sj.setJoins(j2.joins());\n+            else\n+                sj.setJoins(new JoinSet(j2.joins()));\n+        } else {\n+            JoinSet set;\n+            if (nullJoins)\n+                set = j1.joins();\n+            else\n+                set = new JoinSet(j1.joins());\n+\n+            if (j2 != null && !j2.isEmpty())\n+                set.addAll(j2.joins());\n+            sj.setJoins(set);\n+        }\n+\n+        // null previous joins; all are combined into this one\n+        if (nullJoins && j1 != null)\n+            j1.nullJoins();\n+        if (nullJoins && j2 != null)\n+            j2.nullJoins();\n+\n+        return sj;\n+    }\n+\n+    public Joins or(Joins joins1, Joins joins2) {\n+        PathJoins j1 = (PathJoins) joins1;\n+        PathJoins j2 = (PathJoins) joins2;\n+\n+        // if no common joins, return null; if one side of the or clause has\n+        // different joins than the other, then we need to use distinct\n+        boolean j1Empty = j1 == null || j1.isEmpty();\n+        boolean j2Empty = j2 == null || j2.isEmpty();\n+        if (j1Empty || j2Empty) {\n+            if (j1Empty && !j2Empty) {\n+                collectOuterJoins(j2);\n+                if (!j2.isEmpty())\n+                    _flags |= IMPLICIT_DISTINCT;\n+            } else if (j2Empty && !j1Empty) {\n+                collectOuterJoins(j1);\n+                if (!j1.isEmpty())\n+                    _flags |= IMPLICIT_DISTINCT;\n+            }\n+            return null;\n+        }\n+\n+        // if all common joins, move all joins to returned instance\n+        SelectJoins sj = new SelectJoins(this);\n+        if (j1.joins().equals(j2.joins())) {\n+            sj.setJoins(j1.joins());\n+            j1.nullJoins();\n+            j2.nullJoins();\n+        } else {\n+            JoinSet commonJoins = new JoinSet(j1.joins());\n+            commonJoins.retainAll(j2.joins());\n+            if (!commonJoins.isEmpty()) {\n+                // put common joins in returned instance; remove them from\n+                // each given instance\n+                sj.setJoins(commonJoins);\n+                j1.joins().removeAll(commonJoins);\n+                j2.joins().removeAll(commonJoins);\n+            }\n+            collectOuterJoins(j1);\n+            collectOuterJoins(j2);\n+\n+            // if one side of the or clause has different joins than the other,\n+            // then we need to use distinct\n+            if (!j1.isEmpty() || !j2.isEmpty())\n+                _flags |= IMPLICIT_DISTINCT;\n+        }\n+        return sj;\n+    }\n+\n+    public Joins outer(Joins joins) {\n+        if (_joinSyntax == JoinSyntaxes.SYNTAX_TRADITIONAL || joins == null)\n+            return joins;\n+\n+        // record that this is an outer join set, even if it's empty\n+        PathJoins pj = (PathJoins) joins;\n+        pj.setOuter(true);\n+        if (joins.isEmpty())\n+            return joins;\n+\n+        Join join;\n+        Join rec;\n+        boolean hasJoins = _joins != null && _joins.joins() != null;\n+        for (Iterator itr = pj.joins().iterator(); itr.hasNext();) {\n+            join = (Join) itr.next();\n+            if (join.getType() == Join.TYPE_INNER) {\n+                if (!hasJoins)\n+                    join.setType(Join.TYPE_OUTER);\n+                else {\n+                    rec = _joins.joins().getRecordedJoin(join);\n+                    if (rec == null || rec.getType() == Join.TYPE_OUTER)\n+                        join.setType(Join.TYPE_OUTER);\n+                }\n+            }\n+        }\n+        return joins;\n+    }\n+\n+    /**\n+     * Moves the joins from the given instance into our outer joins set.\n+     */\n+    private void collectOuterJoins(PathJoins pj) {\n+        if (_joinSyntax == JoinSyntaxes.SYNTAX_TRADITIONAL || pj == null\n+            || pj.isEmpty())\n+            return;\n+\n+        if (_joins == null)\n+            _joins = new SelectJoins(this);\n+\n+        boolean add = true;\n+        if (_joins.joins() == null) {\n+            _joins.setJoins(pj.joins());\n+            add = false;\n+        }\n+\n+        Join join;\n+        for (Iterator itr = pj.joins().iterator(); itr.hasNext();) {\n+            join = (Join) itr.next();\n+            if (join.getType() == Join.TYPE_INNER) {\n+                if (join.getForeignKey() != null\n+                    && !_dict.canOuterJoin(_joinSyntax, join.getForeignKey())) {\n+                    Log log = _conf.getLog(JDBCConfiguration.LOG_JDBC);\n+                    if (log.isWarnEnabled())\n+                        log.warn(_loc.get(\"cant-outer-fk\",\n+                            join.getForeignKey()));\n+                } else\n+                    join.setType(Join.TYPE_OUTER);\n+            }\n+            if (add)\n+                _joins.joins().add(join);\n+        }\n+        pj.nullJoins();\n+    }\n+\n+    /**\n+     * Return the alias for the given table under the given joins.\n+     * NOTE: WE RELY ON THESE INDEXES BEING MONOTONICALLY INCREASING FROM 0\n+     */\n+    private int getTableIndex(Table table, PathJoins pj, boolean create) {\n+        // if we have a from select, then there are no table aliases\n+        if (_from != null)\n+            return -1;\n+\n+        Object key = table.getFullName();\n+        if (pj != null && pj.path() != null)\n+            key = new Key(pj.path().toString(), key);\n+\n+        // check out existing aliases\n+        Integer i = findAlias(table, key, false, null);\n+        if (i != null)\n+            return i.intValue();\n+        if (!create)\n+            return -1;\n+\n+        // not found; create alias\n+        i = Numbers.valueOf(aliasSize());\n+        recordTableAlias(table, key, i);\n+        return i.intValue();\n+    }\n+\n+    /**\n+     * Attempt to find the alias for the given key.\n+     *\n+     * @param fromParent whether a parent is checking its subselects\n+     * @param fromSub the subselect checking its parent\n+     */\n+    private Integer findAlias(Table table, Object key, boolean fromParent,\n+        SelectImpl fromSub) {\n+        Integer alias = null;\n+        if (_aliases != null) {\n+            alias = (Integer) ((fromParent) ? _aliases.remove(key)\n+                : _aliases.get(key));\n+            if (alias != null) {\n+                if (fromParent)\n+                    _tables.remove(alias);\n+                return alias;\n+            }\n+        }\n+        if (!fromParent && _parent != null) {\n+            alias = _parent.findAlias(table, key, false, this);\n+            if (alias != null)\n+                return alias;\n+        }\n+        if (_subsels != null) {\n+            SelectImpl sub;\n+            for (int i = 0; i < _subsels.size(); i++) {\n+                sub = (SelectImpl) _subsels.get(i);\n+                if (sub == fromSub)\n+                    continue;\n+                if (alias != null) {\n+                    if (sub._aliases != null)\n+                        sub._aliases.remove(key);\n+                    if (sub._tables != null)\n+                        sub._tables.remove(alias);\n+                } else {\n+                    alias = sub.findAlias(table, key, true, null);\n+                    if (!fromParent && alias != null)\n+                        recordTableAlias(table, key, alias);\n+                }\n+            }\n+        }\n+        return alias;\n+    }\n+\n+    /**\n+     * Record the mapping of the given key to the given alias.\n+     */\n+    private void recordTableAlias(Table table, Object key, Integer alias) {\n+        if (_aliases == null)\n+            _aliases = new HashMap();\n+        _aliases.put(key, alias);\n+\n+        String tableString = _dict.getFullName(table, false) + \" \"\n+            + toAlias(alias.intValue());\n+        if (_tables == null)\n+            _tables = new TreeMap();\n+        _tables.put(alias, tableString);\n+    }\n+\n+    /**\n+     * Calculate total number of aliases.\n+     */\n+    private int aliasSize() {\n+        return aliasSize(false, null);\n+    }\n+\n+    /**\n+     * Calculate total number of aliases.\n+     *\n+     * @param fromParent whether a parent is checking its subselects\n+     * @param fromSub the subselect checking its parent\n+     */\n+    private int aliasSize(boolean fromParent, SelectImpl fromSub) {\n+        int aliases = (fromParent || _parent == null) ? 0\n+            : _parent.aliasSize(false, this);\n+        aliases += (_aliases == null) ? 0 : _aliases.size();\n+        if (_subsels != null) {\n+            SelectImpl sub;\n+            for (int i = 0; i < _subsels.size(); i++) {\n+                sub = (SelectImpl) _subsels.get(i);\n+                if (sub != fromSub)\n+                    aliases += sub.aliasSize(true, null);\n+            }\n+        }\n+        return aliases;\n+    }\n+\n+    public String toString() {\n+        return toSelect(false, null).getSQL();\n+    }\n+\n+    ////////////////////////////\n+    // PathJoins implementation\n+    ////////////////////////////\n+\n+    public boolean isOuter() {\n+        return false;\n+    }\n+\n+    public void setOuter(boolean outer) {\n+    }\n+\n+    public boolean isDirty() {\n+        return false;\n+    }\n+\n+    public StringBuffer path() {\n+        return null;\n+    }\n+\n+    public JoinSet joins() {\n+        return null;\n+    }\n+\n+    public int joinCount() {\n+        return 0;\n+    }\n+\n+    public void nullJoins() {\n+    }\n+\n+    public boolean isEmpty() {\n+        return true;\n+    }\n+\n+    public Joins crossJoin(Table localTable, Table foreignTable) {\n+        return new SelectJoins(this).crossJoin(localTable, foreignTable);\n+    }\n+\n+    public Joins join(ForeignKey fk, boolean inverse, boolean toMany) {\n+        return new SelectJoins(this).join(fk, inverse, toMany);\n+    }\n+\n+    public Joins outerJoin(ForeignKey fk, boolean inverse, boolean toMany) {\n+        return new SelectJoins(this).outerJoin(fk, inverse, toMany);\n+    }\n+\n+    public Joins joinRelation(String name, ForeignKey fk, boolean inverse,\n+        boolean toMany) {\n+        return new SelectJoins(this).joinRelation(name, fk, inverse, toMany);\n+    }\n+\n+    public Joins outerJoinRelation(String name, ForeignKey fk,\n+        boolean inverse, boolean toMany) {\n+        return new SelectJoins(this).outerJoinRelation(name, fk, inverse,\n+            toMany);\n+    }\n+\n+    public Joins setVariable(String var) {\n+        if (var == null)\n+            return this;\n+        return new SelectJoins(this).setVariable(var);\n+    }\n+\n+    public Joins setSubselect(String alias) {\n+        if (alias == null)\n+            return this;\n+        return new SelectJoins(this).setSubselect(alias);\n+    }\n+\n+    /**\n+     * Represents a SQL string selected with null id.\n+     */\n+    private static class NullId {\n+\n+    }\n+\n+    /**\n+     * Represents a placeholder SQL string.\n+     */\n+    private static class Placeholder {\n+\n+    }\n+\n+    /**\n+     * Key type used for aliases.\n+     */\n+    private static class Key {\n+\n+        private final String _path;\n+        private final Object _key;\n+\n+        public Key(String path, Object key) {\n+            _path = path;\n+            _key = key;\n+        }\n+\n+        public int hashCode() {\n+            return _path.hashCode() ^ _key.hashCode();\n+        }\n+\n+        public boolean equals(Object other) {\n+            if (other == this)\n+                return true;\n+            if (other.getClass() != getClass())\n+                return false;\n+            Key k = (Key) other;\n+            return k._path.equals(_path) && k._key.equals(_key);\n+        }\n+\n+        public String toString() {\n+            return _path + \"|\" + _key;\n+        }\n+    }\n+\n+    /**\n+     * A {@link Result} implementation wrapped around this select.\n+     */\n+    public static class SelectResult\n+        extends ResultSetResult\n+        implements PathJoins {\n+\n+        private SelectImpl _sel = null;\n+\n+        // position in selected columns list where we expect the next load\n+        private int _pos = 0;\n+        private Stack _preJoins = null;\n+\n+        /**\n+         * Constructor.\n+         */\n+        public SelectResult(Connection conn, Statement stmnt, ResultSet rs,\n+            DBDictionary dict) {\n+            super(conn, stmnt, rs, dict);\n+        }\n+\n+        /**\n+         * Select for this result.\n+         */\n+        public SelectImpl getSelect() {\n+            return _sel;\n+        }\n+\n+        /**\n+         * Select for this result.\n+         */\n+        public void setSelect(SelectImpl sel) {\n+            _sel = sel;\n+        }\n+\n+        public Object getEager(FieldMapping key) {\n+            // don't bother creating key if we know we don't have any\n+            // eager results\n+            if (_sel._eager == null || !_sel._eagerKeys.contains(key))\n+                return null;\n+            Map map = SelectResult.this.getEagerMap(true);\n+            if (map == null)\n+                return null;\n+            return map.get(_sel.toEagerKey(key, getJoins(null)));\n+        }\n+\n+        public void putEager(FieldMapping key, Object res) {\n+            Map map = SelectResult.this.getEagerMap(true);\n+            if (map == null) {\n+                map = new HashMap();\n+                setEagerMap(map);\n+            }\n+            map.put(_sel.toEagerKey(key, getJoins(null)), res);\n+        }\n+\n+        public Object load(ClassMapping mapping, JDBCStore store,\n+            JDBCFetchState fetchState, Joins joins)\n+            throws SQLException {\n+            boolean hasJoins = joins != null\n+                && ((PathJoins) joins).path() != null;\n+            if (hasJoins) {\n+                if (_preJoins == null)\n+                    _preJoins = new Stack();\n+                _preJoins.push(joins);\n+            }\n+\n+            Object obj = super.load(mapping, store, fetchState, joins);\n+\n+            // reset\n+            if (hasJoins)\n+                _preJoins.pop();\n+            return obj;\n+        }\n+\n+        public Joins newJoins() {\n+            PathJoins pre = getPreJoins();\n+            if (pre == null || pre.path() == null)\n+                return this;\n+\n+            PathJoinsImpl pj = new PathJoinsImpl();\n+            pj.path = new StringBuffer(pre.path().toString());\n+            return pj;\n+        }\n+\n+        protected boolean containsInternal(Object obj, Joins joins) {\n+            // we key directly on objs and join-less cols, or on the alias\n+            // for cols with joins\n+            PathJoins pj = getJoins(joins);\n+            if (pj != null && pj.path() != null)\n+                obj = getColumnAlias((Column) obj, pj);\n+            return obj != null && _sel._selects.contains(obj);\n+        }\n+\n+        protected boolean containsAllInternal(Object[] objs, Joins joins)\n+            throws SQLException {\n+            PathJoins pj = getJoins(joins);\n+            Object obj;\n+            for (int i = 0; i < objs.length; i++) {\n+                if (pj != null && pj.path() != null)\n+                    obj = getColumnAlias((Column) objs[i], pj);\n+                else\n+                    obj = objs[i];\n+                if (obj == null || !_sel._selects.contains(obj))\n+                    return false;\n+            }\n+            return true;\n+        }\n+\n+        public void pushBack()\n+            throws SQLException {\n+            _pos = 0;\n+            super.pushBack();\n+        }\n+\n+        protected boolean absoluteInternal(int row)\n+            throws SQLException {\n+            _pos = 0;\n+            return super.absoluteInternal(row);\n+        }\n+\n+        protected boolean nextInternal()\n+            throws SQLException {\n+            _pos = 0;\n+            return super.nextInternal();\n+        }\n+\n+        protected int findObject(Object obj, Joins joins)\n+            throws SQLException {\n+            if (_pos == _sel._selects.size())\n+                _pos = 0;\n+\n+            // we key directly on objs and join-less cols, or on the alias\n+            // for cols with joins\n+            PathJoins pj = getJoins(joins);\n+            Boolean pk = null;\n+            if (pj != null && pj.path() != null) {\n+                Column col = (Column) obj;\n+                pk = (col.isPrimaryKey()) ? Boolean.TRUE : Boolean.FALSE;\n+                obj = getColumnAlias(col, pj);\n+                if (obj == null)\n+                    throw new SQLException(col.getTable() + \": \"\n+                        + pj.path() + \" (\" + _sel._aliases + \")\");\n+            }\n+\n+            // we load in the same order we select, more or less...\n+            if (_sel._selects.get(_pos).equals(obj))\n+                return ++_pos;\n+\n+            // if we're looking for a primary key, try back a couple places,\n+            // since pks might be selected in a slightly different order than\n+            // they are loaded back; don't change the marker position\n+            if (pk == null)\n+                pk = (obj instanceof Column && ((Column) obj).isPrimaryKey())\n+                    ? Boolean.TRUE : Boolean.FALSE;\n+            if (pk.booleanValue()) {\n+                for (int i = _pos - 1; i >= 0 && i >= _pos - 3; i--)\n+                    if (_sel._selects.get(i).equals(obj))\n+                        return i + 1;\n+            }\n+\n+            // search forward on the assumption that we might be skipping\n+            // selects for sibling classes; advance the position if we find\n+            // something forward\n+            for (int i = _pos + 1; i < _sel._selects.size(); i++) {\n+                if (_sel._selects.get(i).equals(obj)) {\n+                    _pos = i;\n+                    return ++_pos;\n+                }\n+            }\n+\n+            // maybe the column was selected by 2 different mappings, so it's\n+            // somewhere prior to the current position; in this case leave the\n+            // position marker at its current place cause subsequent loads will\n+            // still probably start from there\n+            for (int i = 0; i < _pos; i++)\n+                if (_sel._selects.get(i).equals(obj))\n+                    return i + 1;\n+\n+            // somethings's wrong...\n+            throw new SQLException(obj.toString());\n+        }\n+\n+        /**\n+         * Return the joins to use to find column data.\n+         */\n+        private PathJoins getJoins(Joins joins) {\n+            PathJoins pj = (PathJoins) joins;\n+            if (pj != null && pj.path() != null)\n+                return pj;\n+            return getPreJoins();\n+        }\n+\n+        /**\n+         * Return the pre joins for the result, or null if none. Note that\n+         * we have to take the Select's pre joins into account too, since\n+         * batched selects can have additional pre joins on the stack even\n+         * on execution.\n+         */\n+        private PathJoins getPreJoins() {\n+            if (_preJoins != null && !_preJoins.isEmpty())\n+                return (PathJoins) _preJoins.peek();\n+            if (_sel._preJoins != null && !_sel._preJoins.isEmpty())\n+                return (PathJoins) _sel._preJoins.peek();\n+            return null;\n+        }\n+\n+        /**\n+         * Return the alias used to key on the column data, considering the\n+         * given joins.\n+         */\n+        private String getColumnAlias(Column col, PathJoins pj) {\n+            String alias;\n+            if (_sel._from != null) {\n+                alias = _sel.toAlias(_sel._from.getTableIndex\n+                    (col.getTable(), pj, false));\n+                if (alias == null)\n+                    return null;\n+                if (_sel._dict.requiresAliasForSubselect)\n+                    return FROM_SELECT_ALIAS + \".\" + alias + \"_\" + col;\n+                return alias + \"_\" + col;\n+            }\n+            alias = _sel.toAlias(_sel.getTableIndex(col.getTable(), pj,\n+                false));\n+            return (alias == null) ? null : alias + \".\" + col;\n+        }\n+\n+        ////////////////////////////\n+        // PathJoins implementation\n+        ////////////////////////////\n+\n+        public boolean isOuter() {\n+            return false;\n+        }\n+\n+        public void setOuter(boolean outer) {\n+        }\n+\n+        public boolean isDirty() {\n+            return false;\n+        }\n+\n+        public StringBuffer path() {\n+            return null;\n+        }\n+\n+        public JoinSet joins() {\n+            return null;\n+        }\n+\n+        public int joinCount() {\n+            return 0;\n+        }\n+\n+        public void nullJoins() {\n+        }\n+\n+        public boolean isEmpty() {\n+            return true;\n+        }\n+\n+        public Joins crossJoin(Table localTable, Table foreignTable) {\n+            return this;\n+        }\n+\n+        public Joins join(ForeignKey fk, boolean inverse, boolean toMany) {\n+            return this;\n+        }\n+\n+        public Joins outerJoin(ForeignKey fk, boolean inverse, boolean toMany) {\n+            return this;\n+        }\n+\n+        public Joins joinRelation(String name, ForeignKey fk, boolean inverse,\n+            boolean toMany) {\n+            return new PathJoinsImpl().joinRelation(name, fk, inverse, toMany);\n+        }\n+\n+        public Joins outerJoinRelation(String name, ForeignKey fk,\n+            boolean inverse, boolean toMany) {\n+            return new PathJoinsImpl().outerJoinRelation(name, fk, inverse,\n+                toMany);\n+        }\n+\n+        public Joins setVariable(String var) {\n+            if (var == null)\n+                return this;\n+            return new PathJoinsImpl().setVariable(var);\n+        }\n+\n+        public Joins setSubselect(String alias) {\n+            if (alias == null)\n+                return this;\n+            return new PathJoinsImpl().setSubselect(alias);\n+        }\n+    }\n+\n+    /**\n+     * Base joins implementation.\n+     */\n+    private static class PathJoinsImpl\n+        implements PathJoins {\n+\n+        protected StringBuffer path = null;\n+        protected String var = null;\n+\n+        public boolean isOuter() {\n+            return false;\n+        }\n+\n+        public void setOuter(boolean outer) {\n+        }\n+\n+        public boolean isDirty() {\n+            return var != null || path != null;\n+        }\n+\n+        public StringBuffer path() {\n+            return path;\n+        }\n+\n+        public JoinSet joins() {\n+            return null;\n+        }\n+\n+        public int joinCount() {\n+            return 0;\n+        }\n+\n+        public void nullJoins() {\n+        }\n+\n+        public Joins setVariable(String var) {\n+            this.var = var;\n+            return this;\n+        }\n+\n+        public Joins setSubselect(String alias) {\n+            if (!alias.endsWith(\":\"))\n+                alias += ':';\n+            append(alias);\n+            return this;\n+        }\n+\n+        public boolean isEmpty() {\n+            return true;\n+        }\n+\n+        public Joins crossJoin(Table localTable, Table foreignTable) {\n+            append(var);\n+            var = null;\n+            return this;\n+        }\n+\n+        public Joins join(ForeignKey fk, boolean inverse, boolean toMany) {\n+            append(var);\n+            var = null;\n+            return this;\n+        }\n+\n+        public Joins outerJoin(ForeignKey fk, boolean inverse, boolean toMany) {\n+            append(var);\n+            var = null;\n+            return this;\n+        }\n+\n+        public Joins joinRelation(String name, ForeignKey fk, boolean inverse,\n+            boolean toMany) {\n+            append(name);\n+            append(var);\n+            var = null;\n+            return this;\n+        }\n+\n+        public Joins outerJoinRelation(String name, ForeignKey fk,\n+            boolean inverse, boolean toMany) {\n+            append(name);\n+            append(var);\n+            var = null;\n+            return this;\n+        }\n+\n+        protected void append(String str) {\n+            if (str != null) {\n+                if (path == null)\n+                    path = new StringBuffer(str);\n+                else\n+                    path.append('.').append(str);\n+            }\n+        }\n+\n+        public String toString() {\n+            return \"PathJoinsImpl<\" + hashCode() + \">: \"\n+                + String.valueOf(path);\n+        }\n+    }\n+\n+    /**\n+     * Joins implementation.\n+     */\n+    private static class SelectJoins\n+        extends PathJoinsImpl {\n+\n+        private final SelectImpl _sel;\n+        private JoinSet _joins = null;\n+        private boolean _outer = false;\n+        private int _count = 0;\n+\n+        public SelectJoins(SelectImpl sel) {\n+            _sel = sel;\n+        }\n+\n+        public boolean isOuter() {\n+            return _outer;\n+        }\n+\n+        public void setOuter(boolean outer) {\n+            _outer = outer;\n+        }\n+\n+        public boolean isDirty() {\n+            return super.isDirty() || !isEmpty();\n+        }\n+\n+        public JoinSet joins() {\n+            return _joins;\n+        }\n+\n+        public void setJoins(JoinSet joins) {\n+            _joins = joins;\n+            _outer = joins != null && joins.last() != null\n+                && joins.last().getType() == Join.TYPE_OUTER;\n+        }\n+\n+        public int joinCount() {\n+            if (_joins == null)\n+                return _count;\n+            return Math.max(_count, _joins.size());\n+        }\n+\n+        public void nullJoins() {\n+            if (_joins != null)\n+                _count = Math.max(_count, _joins.size());\n+            _joins = null;\n+        }\n+\n+        public boolean isEmpty() {\n+            return _joins == null || _joins.isEmpty();\n+        }\n+\n+        public Joins crossJoin(Table localTable, Table foreignTable) {\n+            // cross joins are for unbound variables; unfortunately we have\n+            // to always go DISTINCT for unbound vars because there are certain\n+            // cases that require it, and we can't differentiate them from the\n+            // cases that don't\n+            _sel._flags |= IMPLICIT_DISTINCT;\n+\n+            if (_sel.getJoinSyntax() != JoinSyntaxes.SYNTAX_SQL92\n+                || _sel._from != null) {\n+                // don't make any joins, but update the path if a variable\n+                // has been set\n+                this.append(this.var);\n+                this.var = null;\n+                _outer = false;\n+                return this;\n+            }\n+\n+            // don't let the get alias methods see that a var has been set\n+            // until we get past the local table\n+            String var = this.var;\n+            this.var = null;\n+\n+            int alias1 = _sel.getTableIndex(localTable, this, true);\n+            this.append(var);\n+            int alias2 = _sel.getTableIndex(foreignTable, this, true);\n+            Join j = new Join(localTable, alias1, foreignTable, alias2,\n+                null, false);\n+            j.setType(Join.TYPE_CROSS);\n+\n+            if (_joins == null)\n+                _joins = new JoinSet();\n+            _joins.add(j);\n+            _outer = false;\n+            return this;\n+        }\n+\n+        public Joins join(ForeignKey fk, boolean inverse, boolean toMany) {\n+            return join(null, fk, inverse, toMany, false);\n+        }\n+\n+        public Joins outerJoin(ForeignKey fk, boolean inverse, boolean toMany) {\n+            return join(null, fk, inverse, toMany, true);\n+        }\n+\n+        public Joins joinRelation(String name, ForeignKey fk, boolean inverse,\n+            boolean toMany) {\n+            return join(name, fk, inverse, toMany, false);\n+        }\n+\n+        public Joins outerJoinRelation(String name, ForeignKey fk,\n+            boolean inverse, boolean toMany) {\n+            return join(name, fk, inverse, toMany, true);\n+        }\n+\n+        private Joins join(String name, ForeignKey fk, boolean inverse,\n+            boolean toMany, boolean outer) {\n+            // don't let the get alias methods see that a var has been set\n+            // until we get past the local table\n+            String var = this.var;\n+            this.var = null;\n+\n+            // get first table alias before updating path; if there is a from\n+            // select then we shouldn't actually create a join object, since\n+            // the joins will all be done in the from select\n+            boolean createJoin = _sel._from == null;\n+            Table table1 = null;\n+            int alias1 = -1;\n+            if (createJoin) {\n+                table1 = (inverse) ? fk.getPrimaryKeyTable() : fk.getTable();\n+                alias1 = _sel.getTableIndex(table1, this, true);\n+            }\n+\n+            // update the path with the relation name before getting pk alias\n+            this.append(name);\n+            this.append(var);\n+            if (toMany) {\n+                _sel._flags |= IMPLICIT_DISTINCT;\n+                _sel._flags |= TO_MANY;\n+            }\n+            _outer = outer;\n+\n+            if (createJoin) {\n+                Table table2 = (inverse) ? fk.getTable()\n+                    : fk.getPrimaryKeyTable();\n+                int alias2 = _sel.getTableIndex(table2, this, true);\n+\n+                Join j = new Join(table1, alias1, table2, alias2, fk, inverse);\n+                j.setType((outer) ? Join.TYPE_OUTER : Join.TYPE_INNER);\n+\n+                if (_joins == null)\n+                    _joins = new JoinSet();\n+                _joins.add(j);\n+            }\n+            return this;\n+        }\n+\n+        public SelectJoins clone(SelectImpl sel) {\n+            SelectJoins sj = new SelectJoins(sel);\n+            sj.var = var;\n+            if (path != null)\n+                sj.path = new StringBuffer(path.toString());\n+            if (_joins != null && !_joins.isEmpty())\n+                sj._joins = new JoinSet(_joins);\n+            sj._outer = _outer;\n+            return sj;\n+        }\n+\n+        public String toString() {\n+            return super.toString() + \" (\" + _outer + \"): \" + _joins;\n+        }\n+    }\n+\n+    /**\n+     * Helper class to track selected columns, with fast contains method.\n+     * Acts as a list of select ids, with additional methods to manipulate\n+     * the alias of each selected id.\n+     */\n+    private static class Selects\n+        extends AbstractList {\n+\n+        private List _ids = null;\n+        private List _idents = null;\n+        private Map _aliases = null;\n+        private Map _selectAs = null;\n+\n+        /**\n+         * Add all aliases from another instance.\n+         */\n+        public void addAll(Selects sels) {\n+            if (_ids == null && sels._ids != null)\n+                _ids = new ArrayList(sels._ids);\n+            else if (sels._ids != null)\n+                _ids.addAll(sels._ids);\n+\n+            if (_idents == null && sels._idents != null)\n+                _idents = new ArrayList(sels._idents);\n+            else if (sels._idents != null)\n+                _idents.addAll(sels._idents);\n+\n+            if (_aliases == null && sels._aliases != null)\n+                _aliases = new HashMap(sels._aliases);\n+            else if (sels._aliases != null)\n+                _aliases.putAll(sels._aliases);\n+\n+            if (_selectAs == null && sels._selectAs != null)\n+                _selectAs = new HashMap(sels._selectAs);\n+            else if (sels._selectAs != null)\n+                _selectAs.putAll(sels._selectAs);\n+        }\n+\n+        /**\n+         * Returns the alias of a given id.\n+         */\n+        public Object getAlias(Object id) {\n+            return (_aliases == null) ? null : _aliases.get(id);\n+        }\n+\n+        /**\n+         * Set an alias for a given id.\n+         */\n+        public int setAlias(Object id, Object alias, boolean ident) {\n+            if (_ids == null) {\n+                _ids = new ArrayList();\n+                _aliases = new HashMap();\n+            }\n+\n+            int idx;\n+            if (_aliases.put(id, alias) != null)\n+                idx = _ids.indexOf(id);\n+            else {\n+                _ids.add(id);\n+                idx = _ids.size() - 1;\n+\n+                if (ident) {\n+                    if (_idents == null)\n+                        _idents = new ArrayList(3);\n+                    _idents.add(id);\n+                }\n+            }\n+            return idx;\n+        }\n+\n+        /**\n+         * Set an alias for a given index.\n+         */\n+        public void setAlias(int idx, Object alias) {\n+            Object id = _ids.get(idx);\n+            _aliases.put(id, alias);\n+        }\n+\n+        /**\n+         * Insert an alias before the given index, using negative indexes\n+         * to count backwards.\n+         */\n+        public void insertAlias(int idx, Object id, Object alias) {\n+            _aliases.put(id, alias);\n+            if (idx >= 0)\n+                _ids.add(idx, id);\n+            else\n+                _ids.add(_ids.size() + idx, id);\n+        }\n+\n+        /**\n+         * Return the index of the given alias.\n+         */\n+        public int indexOfAlias(Object alias) {\n+            if (_aliases == null)\n+                return -1;\n+            for (int i = 0; i < _ids.size(); i++)\n+                if (alias.equals(_aliases.get(_ids.get(i))))\n+                    return i;\n+            return -1;\n+        }\n+\n+        /**\n+         * A list representation of the aliases, in select order, with\n+         * AS aliases present.\n+         */\n+        public List getAliases(final boolean ident, final boolean inner) {\n+            if (_ids == null)\n+                return Collections.EMPTY_LIST;\n+\n+            return new AbstractList() {\n+                public int size() {\n+                    return (ident && _idents != null) ? _idents.size()\n+                        : _ids.size();\n+                }\n+\n+                public Object get(int i) {\n+                    Object id = (ident && _idents != null) ? _idents.get(i)\n+                        : _ids.get(i);\n+                    Object alias = _aliases.get(id);\n+                    String as = null;\n+                    if (inner)\n+                        as = ((String) alias).replace('.', '_');\n+                    else if (_selectAs != null)\n+                        as = (String) _selectAs.get(id);\n+\n+                    if (as != null) {\n+                        if (ident && _idents != null)\n+                            return as;\n+                        if (alias instanceof SQLBuffer)\n+                            alias = new SQLBuffer((SQLBuffer) alias).\n+                                append(\" AS \").append(as);\n+                        else\n+                            alias = alias + \" AS \" + as;\n+                    }\n+                    return alias;\n+                }\n+            };\n+        }\n+\n+        /**\n+         * Set that a given id's alias has an AS value.\n+         */\n+        public void setSelectAs(Object id, String as) {\n+            if (_selectAs == null)\n+                _selectAs = new HashMap((int) (5 * 1.33 + 1));\n+            _selectAs.put(id, as);\n+        }\n+\n+        /**\n+         * Clear all placeholders and select AS clauses.\n+         */\n+        public void clearPlaceholders() {\n+            if (_ids == null)\n+                return;\n+\n+            Object id;\n+            for (Iterator itr = _ids.iterator(); itr.hasNext();) {\n+                id = itr.next();\n+                if (id instanceof Placeholder) {\n+                    itr.remove();\n+                    _aliases.remove(id);\n+                }\n+            }\n+        }\n+\n+        public boolean contains(Object id) {\n+            return _aliases != null && _aliases.containsKey(id);\n+        }\n+\n+        public Object get(int i) {\n+            if (_ids == null)\n+                throw new ArrayIndexOutOfBoundsException();\n+            return _ids.get(i);\n+        }\n+\n+        public int size() {\n+            return (_ids == null) ? 0 : _ids.size();\n+        }\n+\n+        public void clear() {\n+            _ids = null;\n+            _aliases = null;\n+            _selectAs = null;\n+            _idents = null;\n+        }\n+    }\n+}\n+\n+/**\n+ * Common joins interface used internally. Cannot be made an inner class\n+ * because the outer class (Select) has to implement it.\n+ */\n+interface PathJoins\n+    extends Joins {\n+\n+    /**\n+     * Return whether this join set ended with an outer join.\n+     */\n+    public boolean isOuter();\n+\n+    /**\n+     * Mark this as an outer joins set.\n+     */\n+    public void setOuter(boolean outer);\n+\n+    /**\n+     * Return true if this instance has a path, any joins, or a variable.\n+     */\n+    public boolean isDirty();\n+\n+    /**\n+     * Return the relation path traversed by these joins, or null if none.\n+     */\n+    public StringBuffer path();\n+\n+    /**\n+     * Return the set of {@link Join} elements, or null if none.\n+     */\n+    public JoinSet joins();\n+\n+    /**\n+     * Return the maximum number of joins contained in this instance at any\n+     * time.\n+     */\n+    public int joinCount();\n+\n+    /**\n+     * Null the set of {@link Join} elements.\n+     */\n+    public void nullJoins();\n+}\n+"},{"sha":"aed865e9ca17d9b9f00b3d011603319974ef4b00","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Sized.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Sized.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Sized.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Sized.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+/**\n+ * A sized value. Used to represent both a value and its size for calls\n+ * to {@link Row#setObject}.\n+ *\n+ * @author Abe White\n+ */\n+public class Sized {\n+\n+    public final Object value;\n+    public final int size;\n+\n+    public Sized(Object value, int size) {\n+        this.value = value;\n+        this.size = size;\n+    }\n+}"},{"sha":"673cf055556097c6fd1973801d882c3185fdc42d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java","status":"added","additions":298,"deletions":0,"changes":298,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,298 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.Arrays;\n+\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.PrimaryKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.schema.Unique;\n+import org.apache.openjpa.lib.jdbc.DelegatingConnection;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.JavaTypes;\n+\n+/**\n+ * Dictionary for Sybase.\n+ *  The main point of interest is that by default, every table\n+ * that is created will have a unique column named \"UNQ_INDEX\" of\n+ * the \"IDENTITY\" type. OpenJPA will not ever utilize this column. However,\n+ * due to internal Sybase restrictions, this column is required\n+ * in order to support pessimistic (datastore) locking, since Sybase\n+ * requires that any tables in a \"SELECT ... FOR UPDATE\" clause have\n+ * a unique index that is <strong>not</strong> included in the list\n+ * of columns, as described in the\n+ * <a href=\"http://www.sybase.com/detail/1,6904,1023075,00.html\"\n+ * >Sybase documentation</a>. This behavior can be surpressed by setting the\n+ * dictionary property <code>CreateIdentityColumn=false</code>. The\n+ * name of the unique column can be changed by setting the property\n+ * <code>IdentityColumnName=COLUMN_NAME</code>.\n+ *  A good Sybase type reference is can be found <a\n+ * href=\"http://www.ispirer.com/doc/sqlways36/sybase/syb_dtypes.html\">here</a>.\n+ */\n+public class SybaseDictionary\n+    extends AbstractSQLServerDictionary {\n+\n+    private static Localizer _loc = Localizer.forPackage\n+        (SybaseDictionary.class);\n+\n+    /**\n+     * If true, then whenever the <code>schematool</code> creates a\n+     * table, it will append an additional IDENTITY column to the\n+     * table's creation SQL. This is so Sybase will be able to\n+     * perform <code>SELECT...FOR UPDATE</code> statements.\n+     */\n+    public boolean createIdentityColumn = true;\n+\n+    /**\n+     * If {@link #createIdentityColumn} is true, then the\n+     * <code>identityColumnName</code> will be the name of the\n+     * additional unique column that will be created.\n+     */\n+    public String identityColumnName = \"UNQ_INDEX\";\n+\n+    public SybaseDictionary() {\n+        platform = \"Sybase\";\n+        schemaCase = SCHEMA_CASE_PRESERVE;\n+        forUpdateClause = \"FOR UPDATE AT ISOLATION SERIALIZABLE\";\n+\n+        supportsLockingWithDistinctClause = false;\n+        supportsNullTableForGetColumns = false;\n+        requiresAutoCommitForMetaData = true;\n+\n+        maxTableNameLength = 30;\n+        maxColumnNameLength = 30;\n+        maxIndexNameLength = 30;\n+        maxConstraintNameLength = 30;\n+\n+        bigintTypeName = \"NUMERIC(38)\";\n+        bitTypeName = \"TINYINT\";\n+\n+        // Sybase doesn't understand \"X CROSS JOIN Y\", but it does understand\n+        // the equivalent \"X JOIN Y ON 1 = 1\"\n+        crossJoinClause = \"JOIN\";\n+        requiresConditionForCrossJoin = true;\n+\n+        // these tables should not be reflected on\n+        systemTableSet.addAll(Arrays.asList(new String[]{\n+            \"IJDBC_FUNCTION_ESCAPES\", \"JDBC_FUNCTION_ESCAPES\",\n+            \"SPT_IJDBC_CONVERSION\", \"SPT_IJDBC_MDA\", \"SPT_IJDBC_TABLE_TYPES\",\n+            \"SPT_JDBC_CONVERSION\", \"SPT_JDBC_TABLE_TYPES\", \"SPT_JTEXT\",\n+            \"SPT_LIMIT_TYPES\", \"SPT_MDA\", \"SPT_MONITOR\", \"SPT_VALUES\",\n+            \"SYBLICENSESLOG\",\n+        }));\n+\n+        // reserved words specified at:\n+        // http://manuals.sybase.com/onlinebooks/group-as/asg1250e/\n+        // refman/@Generic__BookTextView/26603\n+        reservedWordSet.addAll(Arrays.asList(new String[]{\n+            \"ARITH_OVERFLOW\", \"BREAK\", \"BROWSE\", \"BULK\", \"CHAR_CONVERT\",\n+            \"CHECKPOINT\", \"CLUSTERED\", \"COMPUTE\", \"CONFIRM\", \"CONTROLROW\",\n+            \"DATABASE\", \"DBCC\", \"DETERMINISTIC\", \"DISK DISTINCT\", \"DUMMY\",\n+            \"DUMP\", \"ENDTRAN\", \"ERRLVL\", \"ERRORDATA\", \"ERROREXIT\", \"EXCLUSIVE\",\n+            \"EXIT\", \"EXP_ROW_SIZE\", \"FILLFACTOR\", \"FUNC\", \"FUNCTION\",\n+            \"HOLDLOCK\", \"IDENTITY_GAP\", \"IDENTITY_INSERT\", \"IDENTITY_START\",\n+            \"IF\", \"INDEX\", \"INOUT\", \"INSTALL\", \"INTERSECT\", \"JAR\", \"KILL\",\n+            \"LINENO\", \"LOAD\", \"LOCK\", \"MAX_ROWS_PER_PAGE\", \"MIRROR\",\n+            \"MIRROREXIT\", \"MODIFY\", \"NEW\", \"NOHOLDLOCK\", \"NONCLUSTERED\",\n+            \"NUMERIC_TRUNCATION\", \"OFF\", \"OFFSETS\", \"ONCE\", \"ONLINE\", \"OUT\",\n+            \"OVER\", \"PARTITION\", \"PERM\", \"PERMANENT\", \"PLAN\", \"PRINT\", \"PROC\",\n+            \"PROCESSEXIT\", \"PROXY_TABLE\", \"QUIESCE\", \"RAISERROR\", \"READ\",\n+            \"READPAST\", \"READTEXT\", \"RECONFIGURE\", \"REFERENCES REMOVE\", \"REORG\",\n+            \"REPLACE\", \"REPLICATION\", \"RESERVEPAGEGAP\", \"RETURN\", \"RETURNS\",\n+            \"ROLE\", \"ROWCOUNT\", \"RULE\", \"SAVE\", \"SETUSER\", \"SHARED\",\n+            \"SHUTDOWN\", \"SOME\", \"STATISTICS\", \"STRINGSIZE\", \"STRIPE\",\n+            \"SYB_IDENTITY\", \"SYB_RESTREE\", \"SYB_TERMINATE\", \"TEMP\", \"TEXTSIZE\",\n+            \"TRAN\", \"TRIGGER\", \"TRUNCATE\", \"TSEQUAL\", \"UNPARTITION\", \"USE\",\n+            \"USER_OPTION\", \"WAITFOR\", \"WHILE\", \"WRITETEXT\",\n+        }));\n+    }\n+\n+    public int getJDBCType(int metaTypeCode, boolean lob) {\n+        switch (metaTypeCode) {\n+            // the default mapping for BYTE is a TINYINT, but Sybase's TINYINT\n+            // type can't handle the complete range for a Java byte\n+            case JavaTypes.BYTE:\n+            case JavaTypes.BYTE_OBJ:\n+                return getPreferredType(Types.SMALLINT);\n+            default:\n+                return super.getJDBCType(metaTypeCode, lob);\n+        }\n+    }\n+\n+    public void setBigInteger(PreparedStatement stmnt, int idx, BigInteger val,\n+        Column col)\n+        throws SQLException {\n+        // setBigDecimal doesn't work here: in one case, a stored value\n+        // of 7799438514924349440 turns into 7799438514924349400\n+        // setObject gets around this in the Sybase JDBC drivers\n+        setObject(stmnt, idx, new BigDecimal(val), Types.BIGINT, col);\n+    }\n+\n+    public String[] getAddForeignKeySQL(ForeignKey fk) {\n+        // Sybase has problems with adding foriegn keys via ALTER TABLE command\n+        return new String[0];\n+    }\n+\n+    public String[] getCreateTableSQL(Table table) {\n+        if (!createIdentityColumn)\n+            return super.getCreateTableSQL(table);\n+\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"CREATE TABLE \").append(getFullName(table, false)).\n+            append(\" (\");\n+\n+        Column[] cols = table.getColumns();\n+        boolean hasIdentity = false;\n+\n+        for (int i = 0; i < cols.length; i++) {\n+            if (cols[i].isAutoAssigned())\n+                hasIdentity = true;\n+\n+            buf.append(i == 0 ? \"\" : \", \");\n+            buf.append(getDeclareColumnSQL(cols[i], false));\n+        }\n+\n+        // add an identity column if we do not already have one\n+        if (!hasIdentity)\n+            buf.append(\", \").append(identityColumnName).\n+                append(\" NUMERIC IDENTITY UNIQUE\");\n+\n+        PrimaryKey pk = table.getPrimaryKey();\n+        if (pk != null)\n+            buf.append(\", \").append(getPrimaryKeyConstraintSQL(pk));\n+\n+        Unique[] unqs = table.getUniques();\n+        String unqStr;\n+        for (int i = 0; i < unqs.length; i++) {\n+            unqStr = getUniqueConstraintSQL(unqs[i]);\n+            if (unqStr != null)\n+                buf.append(\", \").append(unqStr);\n+        }\n+\n+        buf.append(\")\");\n+        return new String[]{ buf.toString() };\n+    }\n+\n+    protected String getDeclareColumnSQL(Column col, boolean alter) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(col).append(\" \");\n+        buf.append(getTypeName(col));\n+\n+        // can't add constraints to a column we're adding after table\n+        // creation, cause some data might already be inserted\n+        if (!alter) {\n+            if (col.getDefaultString() != null && !col.isAutoAssigned())\n+                buf.append(\" DEFAULT \").append(col.getDefaultString());\n+            if (col.isAutoAssigned())\n+                buf.append(\" IDENTITY\");\n+        }\n+\n+        if (col.isNotNull())\n+            buf.append(\" NOT NULL\");\n+        else if (!col.isPrimaryKey()) {\n+            // sybase forces you to explicitly specify that\n+            // you will allow NULL values\n+            buf.append(\" NULL\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public String[] getDropColumnSQL(Column column) {\n+        // Sybase uses \"ALTER TABLE DROP <COLUMN_NAME>\" rather than the\n+        // usual \"ALTER TABLE DROP COLUMN <COLUMN_NAME>\"\n+        return new String[]{ \"ALTER TABLE \"\n+            + getFullName(column.getTable(), false) + \" DROP \" + column };\n+    }\n+\n+    public void refSchemaComponents(Table table) {\n+        // note that we use getColumns() rather than getting the column by name\n+        // because under some circumstances this method is called under the\n+        // dynamic schema factory, where getting a column by name creates\n+        // that column\n+        Column[] cols = table.getColumns();\n+        for (int i = 0; i < cols.length; i++)\n+            if (identityColumnName.equalsIgnoreCase(cols[i].getName()))\n+                cols[i].ref();\n+    }\n+\n+    public void endConfiguration() {\n+        super.endConfiguration();\n+\n+        // warn about jdbc compliant flag\n+        String url = conf.getConnectionURL();\n+        if (url != null && url.length() > 0\n+            && url.toLowerCase().indexOf(\"jdbc:sybase:tds\") != -1\n+            && url.toLowerCase().indexOf(\"be_as_jdbc_compliant_as_possible=\")\n+            == -1) {\n+            log.warn(_loc.get(\"sybase-compliance\", url));\n+        }\n+    }\n+\n+    public Connection decorate(Connection conn)\n+        throws SQLException {\n+        return new SybaseConnection(super.decorate(conn));\n+    }\n+\n+    /**\n+     * Connection wrapper to cache the {@link Connection#getCatalog} result,\n+     * which takes a very long time with the Sybase Connection (and\n+     * which we frequently invoke).\n+     */\n+    private static class SybaseConnection\n+        extends DelegatingConnection {\n+\n+        private String _catalog = null;\n+\n+        public SybaseConnection(Connection conn) {\n+            super(conn);\n+        }\n+\n+        public String getCatalog()\n+            throws SQLException {\n+            if (_catalog == null)\n+                _catalog = super.getCatalog();\n+            return _catalog;\n+        }\n+\n+        public void setAutoCommit(boolean autocommit)\n+            throws SQLException {\n+            // the sybase jdbc driver demands that the Connection always\n+            // be rolled back before autocommit status changes. Failure to\n+            // do so will yield \"SET CHAINED command not allowed within\n+            // multi-statement transaction.\" exceptions\n+            try {\n+                super.setAutoCommit(autocommit);\n+            } catch (SQLException e) {\n+                // failed for some reason: try rolling back and then\n+                // setting autocommit again.\n+                if (autocommit)\n+                    super.commit();\n+                else\n+                    super.rollback();\n+                super.setAutoCommit(autocommit);\n+            }\n+        }\n+    }\n+}"},{"sha":"c5c333e333f32568dc28c14cab0f98eb6952cbf9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Union.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Union.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Union.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Union.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+/**\n+ * SQL UNION.\n+ *\n+ * @author Abe White\n+ */\n+public interface Union\n+    extends SelectExecutor {\n+\n+    /**\n+     * Return the selects that make up this union.\n+     */\n+    public Select[] getSelects();\n+\n+    /**\n+     * Get the union-level ordering, if any.\n+     */\n+    public String getOrdering();\n+\n+    /**\n+     * Whether this union will return at most a single result. Setting this\n+     * flag makes it more efficient to execute logical unions that are actually\n+     * made up from multiple selects executed in batch.\n+     */\n+    public boolean isSingleResult();\n+\n+    /**\n+     * Whether this union will return at most a single result. Setting this\n+     * flag makes it more efficient to execute logical unions that are actually\n+     * made up from multiple selects executed in batch.\n+     */\n+    public void setSingleResult(boolean single);\n+\n+    /**\n+     * Whether this is a true UNION, rather than a logical combination of\n+     * independent selects.\n+     */\n+    public boolean isUnion();\n+\n+    /**\n+     * Force the use of a series of standard selects rather than a true UNION.\n+     */\n+    public void abortUnion();\n+\n+    /**\n+     * Select data using the given selector.\n+     */\n+    public void select(Selector selector);\n+\n+    /**\n+     * A callback used to create the selects in a SQL union.\n+     */\n+    public static interface Selector {\n+\n+        /**\n+         * Populate the <code>i</code>th select in the union.\n+         */\n+        public void select(Select sel, int i);\n+    }\n+}"},{"sha":"f8c3cc7b34089aef9cf9dc1eea47207261760534","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/package.html","status":"added","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/package.html","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/package.html?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,9 @@\n+<html>\n+<body>\n+<p><strong>OpenJPA-JDBC SQL Abstraction</strong></p>\n+\n+<p>\n+    Utilities for generating SQL.\n+</p>\n+</body>\n+</html>"},{"sha":"a7db4237287df97173cfcc7769dc8a3531cecefb","filename":"openjpa-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.conf.ProductDerivation","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.conf.ProductDerivation","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.conf.ProductDerivation","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.conf.ProductDerivation?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1 @@\n+org.apache.openjpa.jdbc.conf.JDBCProductDerivation"},{"sha":"0a3a3906ae224bd61b0680c0353d370df852b014","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/localizer.properties","status":"added","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/localizer.properties?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,2 @@\n+bad-conf: The options supplied to the {0} are not valid. Please check your \\\n+\tant build file."},{"sha":"74639b536d81d57184507d0267bd965df1a40d7c","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/conf/localizer.properties","status":"added","additions":226,"deletions":0,"changes":226,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/conf/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/conf/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/conf/localizer.properties?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,226 @@\n+Schema-name: Schema\n+Schema-desc: The default schema for unqualified table names. \n+Schema-type: Connecting\n+Schema-cat: Database.Schemas\n+Schema-displayorder: 50\n+\n+Schemas-name: Schemas\n+Schemas-desc: A comma-separated list of the schemas and/or tables you are \\\n+\tusing for persistent class tables.  \n+Schemas-type: Connecting\n+Schemas-cat: Database.Schemas\n+Schemas-displayorder: 50\n+\n+TransactionIsolation-name: JDBC transaction isolation level\n+TransactionIsolation-desc: The name of the JDBC transaction isolation \\\n+\tlevel to use.  \"default\" indicates to use \\\n+\tthe JDBC driver''s default level. \\\n+\tOther standard values are \"none\", \"read-committed\", \"read-uncommitted\", \\\n+\t\"repeatable-read\", and \"serializable\".\n+TransactionIsolation-type: Connecting\n+TransactionIsolation-cat: Database.Transactions\n+TransactionIsolation-displayorder: 50\n+TransactionIsolation-expert: true\n+\n+ResultSetType-name: JDBC result set type\n+ResultSetType-desc: The name of the JDBC result set type to use.  Standard \\\n+\tvalues are \"forward-only\", \"scroll-sensitive\", and \"scroll-insensitive\".\n+ResultSetType-type: Optimization\n+ResultSetType-cat: JDBC\n+ResultSetType-displayorder: 50\n+ResultSetType-expert: true\n+\n+FetchDirection-name: JDBC fetch direction\n+FetchDirection-desc: The name of the JDBC fetch direction to use.  Standard \\\n+\tvalues are \"forward\", \"reverse\", and \"unknown\".\n+FetchDirection-type: Optimization\n+FetchDirection-cat: JDBC\n+FetchDirection-displayorder: 50\n+FetchDirection-expert: true\n+\n+EagerFetchMode-name: Eager fetch mode\n+EagerFetchMode-desc: Specifies the default eager fetch mode to use.  Either \\\n+\t\"none\" to never eagerly-load relations, \"join\" for selecting 1-1 relations \\\n+\talong with the target object using inner or outer joins, or \"parallel\" for \\\n+\tselecting 1-1 relations via joins, and collections (including to-many \\\n+\trelations) along with the target object using separate select statements \\\n+\texecuted in parallel.\n+EagerFetchMode-type: Optimization\n+EagerFetchMode-cat: Fetching\n+EagerFetchMode-displayorder: 50\n+EagerFetchMode-expert: true\n+\n+SubclassFetchMode-name: Subclass fetch mode\n+SubclassFetchMode-desc: Specifies the default subclass fetch mode to use. \\\n+\tEitehr \"none\" to always select data in base class tables only, \"join\" to \\\n+\touter-join to tables for all subclasses, or \"parallel\" to execute a \\\n+\tseparate select in parallel for each possible subclass.  Parallel mode is \\\n+\tonly applicable to Query execution; in other situations it mirrors \\\n+\tjoin mode.\n+SubclassFetchMode-type: Optimization\n+SubclassFetchMode-cat: Fetching\n+SubclassFetchMode-displayorder: 50\n+SubclassFetchMode-expert: true\n+\n+LRSSize-name: Large result set size mode\n+LRSSize-desc: The mode to use for calculating the size of large result sets. \\\n+\tLegal values are \"unknown\", \"last\", and \"query\".\n+LRSSize-type: Optimization\n+LRSSize-cat: JDBC\n+LRSSize-displayorder: 50\n+LRSSize-expert: true\n+\n+SynchronizeMappings-name: Automatically synchronize schema\n+SynchronizeMappings-desc: Controls whether OpenJPA will attempt to run the \\\n+\tmapping tool on all persistent classes to synchronize their mappings \\\n+\tand schema at runtime.\n+SynchronizeMappings-type: General\n+SynchronizeMappings-cat: Mappings\n+SynchronizeMappings-displayorder: 50\n+SynchronizeMappings-expert: true\n+\n+JDBCListeners-name: JDBC event listeners\n+JDBCListeners-desc: A comma-separated list of \\\n+\torg.apache.openjpa.lib.jdbc.JDBCListener implementations to install on \\\n+\tall connection pools.\n+JDBCListeners-type: Connecting\n+JDBCListeners-cat: JDBC.Advanced\n+JDBCListeners-displayorder: 50\n+JDBCListeners-expert: true\n+\n+ConnectionDecorators-name: Connection decorators\n+ConnectionDecorators-desc: A comma-separated list of \\\n+\torg.apache.openjpa.lib.jdbc.ConnectionDecorator implementations to install \\\n+\ton all connection pools.\n+ConnectionDecorators-type: Connecting\n+ConnectionDecorators-cat: JDBC.Advanced\n+ConnectionDecorators-displayorder: 50\n+ConnectionDecorators-expert: true\n+ConnectionDecorators-interface: org.apache.openjpa.lib.jdbc.ConnectionDecorator\n+\n+DBDictionary-name: Database dictionary\n+DBDictionary-desc: The org.apache.openjpa.jdbc.sql.DBDictionary to use for database \\\n+\tinteraction. This is auto-detected based on the ConnectionURL setting, \\\n+\tso you need only set this to override the default with your own custom \\\n+\tdictionary or if you are using an unrecognized driver.\n+DBDictionary-type: Connecting\n+DBDictionary-cat: Database\n+DBDictionary-displayorder: 50\n+DBDictionary-interface: org.apache.openjpa.jdbc.sql.DBDictionary\n+\n+UpdateManager-name: Update manager\n+UpdateManager-desc: The org.apache.openjpa.jdbc.kernel.UpdateManager to use to flush \\\n+\tpersistent object modifications to the database.\n+UpdateManager-type: General\n+UpdateManager-cat: JDBC.Interaction\n+UpdateManager-displayorder: 50\n+UpdateManager-expert: true\n+UpdateManager-interface: org.apache.openjpa.jdbc.kernel.UpdateManager\n+\n+DriverDataSource-name: Update manager\n+DriverDataSource-desc: The org.apache.openjpa.jdbc.schema.DriverDataSource to use to wrap \\\n+\ta JDBC driver in a DataSource.\n+DriverDataSource-type: General\n+DriverDataSource-cat: JDBC.Interaction\n+DriverDataSource-displayorder: 50\n+DriverDataSource-expert: true\n+DriverDataSource-interface: org.apache.openjpa.jdbc.schema.DriverDataSource\n+\n+SchemaFactory-name: Schema factory\n+SchemaFactory-desc: The org.apache.openjpa.jdbc.schema.SchemaFactory that \\\n+\twill provide information about the existing tables and other database \\\n+\tstructures at runtime.\n+SchemaFactory-type: General\n+SchemaFactory-cat: JDBC.Interaction\n+SchemaFactory-displayorder: 50\n+SchemaFactory-expert: true\n+SchemaFactory-interface: org.apache.openjpa.jdbc.schema.SchemaFactory\n+\n+SQLFactory-name: SQL factory\n+SQLFactory-desc: The org.apache.openjpa.jdbc.sql.SQLFactory used to create SQL constructs.\n+SQLFactory-type: General\n+SQLFactory-cat: JDBC.Interaction\n+SQLFactory-displayorder: 50\n+SQLFactory-expert: true\n+SQLFactory-interface: org.apache.openjpa.jdbc.sql.SQLFactory\n+\n+MappingFactory-name: Mapping factory\n+MappingFactory-desc: The org.apache.openjpa.meta.MetaDataFactory that will provide the \\\n+\tobject-relational mapping information needed to map each persistent class \\\n+\tto the database, if it isn't provided by current metadata MetaDataFactory.\n+MappingFactory-type: General\n+MappingFactory-cat: Mappings\n+MappingFactory-displayorder: 50\n+MappingFactory-expert: true\n+MappingFactory-interface: org.apache.openjpa.meta.MetaDataFactory\n+\n+MappingDefaults-name: Mapping defaults\n+MappingDefaults-desc: The org.apache.openjpa.jdbc.meta.MappingDefaults that determines \\\n+\tdefault table names, column names, and other information.\n+MappingDefaults-type: General\n+MappingDefaults-cat: Mappings\n+MappingDefaults-displayorder: 50\n+MappingDefaults-interface: org.apache.openjpa.jdbc.meta.MappingDefaults\n+\n+ConnectionDriverName-values: org.hsqldb.jdbcDriver,org.hsql.jdbcDriver,\\\n+\tCOM.cloudscape.core.JDBCDriver,in.co.daffodil.db.jdbc.DaffodilDBDriver,\\\n+\tcom.ddtek.jdbc.db2.DB2Driver,interbase.interclient.Driver,\\\n+\tcom.mysql.jdbc.Driver,com.ddtek.jdbc.oracle.OracleDriver,\\\n+\torg.postgresql.Driver,com.pointbase.jdbc.jdbcUniversalDriver,\\\n+\torg.sourceforge.jxdbcon.JXDBConDriver,\\\n+\tcom.ddtek.jdbc.sqlserver.SQLServerDriver,com.jnetdirect.jsql.JSQLDriver,\\\n+\tcom.microsoft.jdbc.sqlserver.SQLServerDriver,\\\n+\tweblogic.jdbc.mssqlserver4.Driver,com.ddtek.jdbc.sybase.SybaseDriver,\\\n+\toracle.jdbc.pool.OracleDataSource,org.axiondb.jdbc.AxionDriver,\\\n+\tCOM.ibm.db2.jdbc.app.DB2Driver,com.ibm.as400.access.AS400JDBCDriver,\\\n+\tCOM.FirstSQL.Dbcp.DbcpDriver,COM.ibm.db2.jdbc.net.DB2Driver,\\\n+\torg.enhydra.instantdb.jdbc.idbDriver,com.informix.jdbc.IfxDriver,\\\n+\tcom.microsoft.jdbc.sqlserver.SQLServerDriver,\\\n+\tcom.imaginary.sql.msql.MsqlDriver,sun.jdbc.odbc.JdbcOdbcDriver,\\\n+\toracle.jdbc.driver.OracleDriver,intersolv.jdbc.sequelink.SequeLinkDriver,\\\n+\topenlink.jdbc2.Driver,com.pointbase.jdbc.jdbcUniversalDriver,\\\n+\tpostgres95.PGDriver,postgresql.Driver,solid.jdbc.SolidDriver,\\\n+ \tcentura.java.sqlbase.SqlbaseDriver,interbase.interclient.Driver,\\\n+\tcom.mckoi.JDBCDriver,com.inet.tds.TdsDriver,\\\n+\tcom.microsoft.jdbc.sqlserver.SQLServerDriver,com.thinweb.tds.Driver,\\\n+\tweblogic.jdbc.mssqlserver4.Driver,com.mysql.jdbc.DatabaseMetaData,\\\n+\torg.gjt.mm.mysql.Driver,com.sap.dbtech.jdbc.DriverSapDB,\\\n+\tcom.sybase.jdbc2.jdbc.SybDriver,com.sybase.jdbc.SybDriver,\\\n+\tcom.internetcds.jdbc.tds.Driver,weblogic.jdbc.pool.Driver\n+ConnectionURL-values: jdbc:JSQLConnect://<hostname>/database=<database>,\\\n+\tjdbc:cloudscape:<database>;create=true,\\\n+\tjdbc:twtds:sqlserver://<hostname>/<database>,\\\n+\tjdbc:daffodilDB_embedded:<database>;create=true,\\\n+\tjdbc:datadirect:db2://<hostname>:50000;databaseName=<database>,\\\n+\tjdbc:inetdae:<hostname>:1433,\\\n+\tjdbc:datadirect:oracle://<hostname>:1521;SID=<database>;\\\n+\tMaxPooledStatements=0,\\\n+\tjdbc:datadirect:sqlserver://<hostname>:1433;SelectMethod=cursor;\\\n+\tDatabaseName=<database>,jdbc:datadirect:sybase://<hostname>:5000,\\\n+\tjdbc:db2://<hostname>/<database>,jdbc:hsqldb:<database>,\\\n+\tjdbc:idb:<database>.properties,\\\n+\tjdbc:informix-sqli://<hostname>:1526/<database>:INFORMIXSERVER=<database>,\\\n+\tjdbc:interbase://<hostname>//<database>.gdb,\\\n+\tjdbc:microsoft:sqlserver://<hostname>:1433;DatabaseName=<database>;\\\n+\tSelectMethod=cursor,jdbc:mysql://<hostname>/<database>?autoReconnect=true,\\\n+\tjdbc:oracle:thin:@<hostname>:1521:<database>,\\\n+\tjdbc:postgresql://<hostname>:5432/<database>,\\\n+\tjdbc:postgresql:net//<hostname>/<database>,\\\n+\tjdbc:sybase:Tds:<hostname>:4100/<database>?ServiceName=<database>,\\\n+\tjdbc:weblogic:mssqlserver4:<database>@<hostname>:1433,\\\n+\tjdbc:odbc:<database>,jdbc:sequelink://<hostname>:4003/[Oracle],\\\n+\tjdbc:sequelink://<hostname>:4004/[Informix];Database=<database>,\\\n+\tjdbc:sequelink://<hostname>:4005/[Sybase];Database=<database>,\\\n+\tjdbc:sequelink://<hostname>:4006/[SQLServer];Database=<database>,\\\n+\tjdbc:sequelink://<hostname>:4011/[ODBC MS Access];Database=<database>,\\\n+\tjdbc:openlink://<hostname>/DSN=SQLServerDB/UID=sa/PWD=,\\\n+\tjdbc:solid://<hostname>:<port>/<UID>/<PWD>,\\\n+\tjdbc:dbaw://<hostname>:8889/<database>\n+\n+connecting-for-dictionary: OpenJPA will now connect to the database to attempt to \\\n+\tdetermine what type of database dictionary to use.  To prevent this \\\n+\tconnection in the future, set your org.apache.openjpa.jdbc.DBDictionary configuration \\\n+\tproperty to the appropriate value for your database (see the documentation \\\n+\tfor available values).\n+map-factory: Using mapping factory \"{0}\".\n+meta-factory: Using metadata factory \"{0}\"."},{"sha":"4616e9300dc706d6f94f4cacd8f303592639d517","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/exps/localizer.properties","status":"added","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/exps/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/exps/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/exps/localizer.properties?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,11 @@\n+bad-getobjectid: Attempt to get the object id of a non-persistent or \\\n+\tembedded object field \"{0}\".\n+non-pers-field: Field \"{0}\" is not persistent, and thus cannot be queried.\n+no-in-mem: The filter listener \"{0}\" does not support in-memory operation; it \\\n+\tcan only be used with queries against the database.\n+const-only: The filter listener \"{0}\" requires a constant argument.\t\n+path-only: The target for filter listener \"{0}\" must be \"this\" or some \\\n+\tfield traversal to a related objects, such as \"company.address\".\n+no-col: The column \"{0}\" given to filter \"{1}\" doesn''t exist in the table \\\n+\tof the specified target.\n+cant-convert: Attempt to compare incompatible types \"{0}\" and \"{1}\"."},{"sha":"bcd72a8f1ff3efbb41673606ce49069007430919","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","status":"added","additions":81,"deletions":0,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,81 @@\n+error-rollback: An error occurred attempting to rollback to the savepoint \"{0}\"\n+error-save: An error occurred attempting to set the savepoint \"{0}\".  This \\\n+\tdriver may not support JDBC 3 savepoints.\n+mult-mapping-aggregate: Cannot perform an aggregate query on a hierarchy with \\\n+\tunjoined subclasses: {0}\n+sqlquery-missing-params: SQL query \"{0}\" declares a parameter index \"{1}\" for \\\n+\twhich no value was given.  The given parameters were: {2}\n+no-sql: You have not specified a SQL filter to execute in your SQL query.\n+del-ins-cycle: An unresolvable constraint cycle was detected.  This typically \\\n+\tmeans that you are persisting a new object with the same primary key value \\\n+\tas an object you are deleting in the same transaction, and at the same \\\n+\ttime you have circular foreign key dependencies in the transaction.  The \\\n+\tcombination of these two factors can sometimes lead to a situation in \\\n+\twhich OpenJPA cannot meet all the database constraints.\n+ref-cycle: An unresolvable constraint cycle was detected.  This typically \\\n+\tmeans that a mapping in a table other than the class'' primary table has \\\n+\ta foreign key that is part of a circular foreign key dependency.  OpenJPA \\\n+\tsometimes cannot meet circular dependencies when some of the involved \\\n+\tmappings are in secondary tables.\n+update-failed-no-failed-obj: Database operation failed. Update count for SQL \\\n+    statement was {0}. Statement: {1}\n+virtual-mapping: Cannot instantiate virtual mapping \"{0}\".\n+press-key-end: Server running.  Press enter to stop.\n+no-server-conf: There is no persistence server configured.\n+server-usage: Usage: java org.apache.openjpa.jdbc.kernel.StartPersistenceServer\\n\\\n+\t\\t[-properties/-p <properties file or resource>]\\n\\\n+\t\\t[-<property name> <property value>]* \n+cant-lock-on-load: The database is unable to lock this query.  Each object \\\n+\tmatching the query will be locked individually after it is loaded; \\\n+\thowever, it is technically possible that another transaction could modify \\\n+\tthe data before the lock is obtained.  See the documentation on Object \\\n+\tLocking for details.\\n\"{0}\" \n+start-trans-for-lock: Though you are using optimistic transactions, OpenJPA is \\\n+\tnow beginning a datastore transaction because you have requested a lock \\\n+\ton some data.\n+millis-timeout: JDBC lock manager does not support millisecond-granularity \\\n+\ttimeouts.  Use timeouts that are multiples of 1000 for even second values.\n+millis-query-timeout: JDBC lock manager does not support \\\n+\tmillisecond-granularity timeouts.  Use timeouts that are multiples \\\n+\tof 1000 for even second values.\n+batch-not-supported: The update count for the statement was an invalid \\\n+\tvalue ({0}). This indicates that your database or JDBC driver does not \\\n+\thave complete support for executing batch statements. Batch \\\n+\tfunctionality should be disabled by including \"BatchLimit=0\" in \\\n+\tyour org.apache.openjpa.jdbc.DBDictionary configuration property. Statement: {1}\n+bad-synch-mappings: Invalid SynchronizeMappings operation (\"{0}\") specified. \\\n+\tValid operations are: {1}\n+make-native-seq: Creating sequence.\n+drop-native-seq: Dropping sequence.\n+make-seq-table: Creating sequence table.\n+drop-seq-table: Dropping sequence table.\n+bad-seq-up: Attempt to update the sequence table \"{0}\" failed.  The sequence \\\n+\ttable is typically created when you run the mappingtool''s refresh action \\\n+\ton any datastore identity class. If you have not run the mappingtool but \\\n+\twant to create the sequence table, run:\\n\\\n+\tjava org.apache.openjpa.jdbc.kernel.TableJDBCSeq -action add\n+bad-seq-type: This sequence of type \"{0}\" cannot generate values for \\\n+\tpersistent type \"{1}\".\n+no-seq-sql: Error instantiating named sequence \"{0}\": Your database dictionary \\\n+\tdoes not support native sequences.  To tell the dictionary how to select \\\n+\tsequence values, use:\\n\\\n+\torg.apache.openjpa.jdbc.DBDictionary: NextSequenceQuery=\"SELECT NEXT VALUE FOR \\{0\\}\"\\n\\\n+\tWhere the above string is replaced with the proper SQL for your database.\n+invalid-seq-sql: No rows returned for sql \"{0}\".  Check your configuration.\n+insert-seq: Inserting row for this mapping into sequence table.\n+no-seq-row: There is no row for mapping \"{0}\" in sequence table \"{1}\", and \\\n+\tthe attempt to insert a row has apparently failed.\n+update-seq: Updating sequence values.\n+get-seq: Getting current sequence values.\n+seq-usage: Usage: java org.apache.openjpa.jdbc.kernel.TableJDBCSeq\\n\\\n+\t\\t[-properties/-p <properties file or resource>]\\n\\\n+\t\\t[-<property name> <property value>]*\\n\\\n+\t\\t-action/-a <add | drop | get | set> [value]\n+clstable-seq-usage: Usage: java org.apache.openjpa.jdbc.kernel.ClassTableJDBCSeq\\n\\\n+\t\\t[-properties/-p <properties file or resource>]\\n\\\n+\t\\t[-<property name> <property value>]*\\n\\\n+\t\\t-action/-a <add | drop | get | set>\\n\\\n+\t\\t[class name | .java file | .class file | .jdo file] [value]\n+native-seq-usage: Usage: java org.apache.openjpa.jdbc.kernel.NativeJDBCSeq\\n\\\n+\t\\t[-properties/-p <properties file or resource>]\\n\\\n+\t\\t[-<property name> <property value>]*"},{"sha":"b5111fcc26b6e5dde5fd4a887bc4d76857974994","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/java-keywords.rsrc","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/java-keywords.rsrc","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/java-keywords.rsrc","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/java-keywords.rsrc?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1 @@\n+abstract,abs,assert,assertion,boolean,bool,break,brk,byte,bits,case,cse,catch,ctch,char,ch,class,type,const,cnst,continue,cont,default,def,do,doIt,double,dbl,else,els,extends,extend,final,fnl,finally,fnly,float,flt,for,forWhat,goto,go2,if,ifTrue,implements,impl,import,imports,instanceof,instance,int,integer,interface,intrface,long,longint,native,natively,new,isNew,null,isNull,package,pkg,private,priv,protected,protect,public,pub,return,ret,short,shrt,static,stat,super,sup,switch,change,synchronized,synch,this,thisOne,throw,thrw,throws,thrws,transient,trans,try,tryIt,void,isVoid,volatile,vol,while,whil"},{"sha":"66903735ce902246e42742973dbba6f1f59c67ab","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties","status":"added","additions":400,"deletions":0,"changes":400,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,400 @@\n+resolve-mapping: Resolving mapping for \"{0}\".\n+init-mapping: Initializing mapping for \"{0}\".\n+strategy: \"{0}\" has mapping strategy \"{1}\".\n+field-strategy: \\t\"{0}\" has mapping strategy \"{1}\".\n+no-equiv-col: Cannot use \"{0}\" as the mapped-by value for a field in \"{1}\".  \\\n+\tThere is no column \"{2}\" in this subclass'' table.\n+no-equiv-field: Cannot use \"{0}\" as the mapped-by value for a field in \"{1}\".  \\\n+\tThere is no target-field \"{2}\" for column \"{3}\" in this subclass.\n+bad-equiv-field: Cannot use \"{0}\" as the mapped-by value for a field in \"{1}\". \\\n+\tThe target-field \"{2}\" for column \"{3}\" is mapped to multiple columns.\n+no-mapping: No mapping information found for type \"{0}\".\n+bad-mapped-by: Collection field \"{0}\" declares that it is mapped by \"{1}\", but \\\n+\tthis is not a valid inverse relation.\n+no-targetfield: Some of the columns on \"{0}\" are missing target field \\\n+\tdeclarations.\n+bad-targetfield: \"{0}\" has a column with target field \"{1}\", but that is not a \\\n+\tprimary key field of the related class.\n+bad-col-lg-counts: Cannot synchronize mapping information: the number of \\\n+\tversion columns is not equal to the number of lock groups.\n+no-joinable: You cannot join on column \"{0}\".  It is not managed by a mapping \\\n+\tthat supports joins.\n+join-required: Missing table name for field \"{0}\".  This field cannot reside \\\n+\tin the owning class table.\n+bad-discrim-value: The declared discriminator value \"{1}\" for type \"{0}\" \\\n+\tcannot be parsed as a number, though it starts with a digit.   \n+unexpected-cols: You have supplied columns for \"{0}\", but this mapping cannot \\\n+\thave columns in this context.\n+unexpected-index: \"{0}\" is marked as indexed, but OpenJPA does not support \\\n+\tan index on this mapping in this context.\n+unexpected-unique: \"{0}\" is marked as having a unique constraint, but OpenJPA \\\n+\tdoes not support a constraint on this mapping in this context.\n+unexpected-fk: \"{0}\" is marked as having a foreign key, but OpenJPA does not \\\n+\tsupport a foreign key on this mapping in this context.\n+unexpected-join: \"{0}\" has columns with targets, but OpenJPA does not support any \\\n+\tjoins on this mapping in this context.\n+unexpected-strategy: \"{0}\" has an invalid mapping strategy in this context. \\\n+\tExpected \"{1}\" but found \"{2}\".\n+no-table: No table was given for persistent type \"{0}\".\n+bad-table: Table \"{0}\" given for \"{1}\" does not exist.\n+generic-num-cols: For \"{0}\", expected {1} column(s), but found {2}.\n+generic-no-col-name: No column name was given for \"{0}\".\n+generic-bad-col-name: \"{0}\" declares column \"{1}\", but this column does not \\\n+\texist in table \"{2}\".\n+generic-incompat-col: \"{0}\" declares a column \"{1}\" whose jdbc-type is not \\\n+\tcompatible with the expected type \"{2}\".\n+generic-bad-col: \"{0}\" declares a column that is not compatible with the \\\n+\texpected type \"{1}\".  Column details:\\n{2}\n+datastoreid-num-cols: For type \"{0}\", expected {1} datastore identity \\\n+\tcolumn(s), but found {2}.\n+datastoreid-no-col-name: No datastore identity column name was given for \"{0}\".\n+datastoreid-bad-col-name: Type \"{0}\" declares datastore identity column \"{1}\", \\\n+\tbut this column does not exist in table \"{2}\".\n+datastoreid-incompat-col: Type \"{0}\" declares a datastore identity column \\\n+\t\"{1}\" whose jdbc-type is not compatible with the expected type \"{2}\".\n+datastoreid-bad-col: Type \"{0}\" declares a datastore identity column that is \\\n+\tnot compatible with the expected type \"{1}\".  Column details:\\n{2}\n+nondfg-field-orderable: Cannot order \"{0}\" on \"{1}\", because that field is not \\\n+\tin the default fetch group.  You can only order on fields that will be \\\n+\tselected when the related object is loaded.\n+order-conflict: Field \"{0}\" declares both a synthetic ordering column and \\\n+\torder-by values.  You cannot use both.  \n+order-no-col-name: No order column name was given for \"{0}\".\n+order-bad-col-name: \"{0}\" declares order column \"{1}\", but this column does \\\n+\tnot exist in table \"{2}\".\n+order-incompat-col: \"{0}\" declares an order column \"{1}\" whose jdbc-type is \\\n+\tnot compatible with the expected type \"{2}\".\n+order-bad-col: \"{0}\" declares an order column column that is not compatible \\\n+\twith the expected type \"{1}\".  Column details:\\n{2}\n+null-ind-no-col-name: No null-indicator column name was given for \"{0}\".\n+null-ind-bad-col-name: \"{0}\" declares null-indicator column \"{1}\", but this \\\n+\tcolumn does not exist in table \"{2}\".\n+null-ind-incompat-col: \"{0}\" declares a null-indicator column \"{1}\" whose \\\n+\tjdbc-type is not compatible with the expected type \"{2}\".\n+null-ind-bad-col: \"{0}\" declares a null-indicator column column that is not \\\n+\tcompatible with the expected type \"{1}\".  Column details:\\n{2}\n+generic-no-index-cols: \"{0}\" declares an index, but has no columns.\n+generic-index-exists: \"{0}\" marks its columns as explicitly not indexed, but \\\n+\tan index exists.\n+generic-index-not-unique: \"{0}\" marks its columns as having a unique index, \\\n+\tbut the existing index on those columns is not unique.\n+generic-no-unique-cols: \"{0}\" declares a unique constraint, but has no columns.\n+generic-unique-exists: \"{0}\" marks its columns as explicitly not unique, but \\\n+\ta unique constraint exists.\n+generic-unique-support: \"{0}\" marks its columns as having a unique constraint, \\\n+\tbut your database does not support unique constraints.  Include \\\n+\t\"SupportsUniqueConstraints=true\" in the org.apache.openjpa.jdbc.DBDictionary \\\n+\tconfiguration property to override this default.\n+generic-defer-unique: \"{0}\" marks its columns as having a deferred unique \\\n+\tconstraint, but the existing constraint on these columns is not deferred. \\\n+\tOpenJPA cannot change the deferrability of a constraint.\n+generic-create-defer-unique: \"{0}\" marks its columns as having a deferred \\\n+\tunique constraint, but the database dictionary \"{1}\" reports that it does \\\n+\tnot support deferred constraints.  Creating an undeferred constraint.\n+generic-no-fk-cols: \"{0}\" declares a foreign key, but has no columns.\n+generic-no-fkcol-name: \"{0}\" does not supply a name for at least one declared \\\n+\tcolumn.\n+generic-bad-fkconst: \"{0}\" declares invalid constant value target \"{1}\" for \\\n+\tcolumn with name \"{2}\".\n+generic-bad-fktarget-inverse: \"{0}\" declares a target for column \"{1}\" in \\\n+\ttable \"{3}\", but all targets must be in table \"{2}\".\n+generic-bad-fk-inverse: \"{0}\" declares a column in table \"{1}\", but all \\\n+\tcolumns must be in table \"{2}\".\n+generic-bad-fk-self-inverse: \"{0}\" declares an inverse self-join on table \\\n+\t\"{1}\", but this mapping does not allow inverse joins.  If you did not \\\n+\tintend to make this an inverse join, take the table name out of the \\\n+\tcolumn names for this mapping.\n+generic-no-fkcol-name-adapt: \"{0}\" does not supply a name for at least one \\\n+\tdeclared column.  Since this mapping can involve multiple columns or uses \\\n+\tconstant joins, each column must give either its name or a non-constant \\\n+\ttarget.\n+generic-no-fkcol-target-adapt: \"{0}\" does not supply a target for column \\\n+\t\"{1}\".  Since this mapping can involve multiple columns and the a target \\\n+\tcolumn with the same name doesn''t exist, you must give a target explicitly.\n+generic-bad-fktarget: \"{0}\" defines a target of \"{1}\" for column \"{2}\", but \\\n+\tthat target does not exist in table \"{3}\".\n+generic-bad-fktargetcls: \"{0}\" defines target field \"{1}\" for column \\\n+\t\"{2}\", but OpenJPA cannot deterimine the owning class for that field.\n+generic-bad-fktargetfield: \"{0}\" defines target field \"{1}\" for column \\\n+\t\"{2}\", but that field does not exist in type \"{3}\".\n+generic-fktargetfield-cols: \"{0}\" defines target field \"{1}\" for column \\\n+\t\"{2}\", but that field is either unmapped or has multiple columns.\n+generic-mult-fk-tables: \"{0}\" uses columns from multiple different tables: \\\n+\t\"{1}\", \"{2}\"\n+generic-fk-exists: \"{0}\" marks its columns as explicitly not having a foreign \\\n+\tkey delete action, but a database foreign key exists on these columns.\n+generic-defer-fk: \"{0}\" marks its columns as having a deferred foreign key, \\\n+\tbut the existing constraint on these columns is not deferred. OpenJPA cannot \\\n+\tchange the deferrability of a constraint.\n+generic-create-defer-fk: \"{0}\" marks its columns as having a deferred foreign \\\n+\tkey, but the database dictionary \"{1}\" reports that it does not support \\\n+\tdeferred constraints.  Creating an undeferred constraint.\n+generic-unsupported-fk-action: \"{0}\" uses an unsupported foreign key delete or \\\n+\tupdate action on its columns.  Reverting to a logical foreign key.\n+generic-const-join: \"{0}\" attmpts to join a constant value to another constant \\\n+\tvalue.\n+superclass-no-fk-cols: Type \"{0}\" is missing information on how to join to \\\n+\tits superclass.\n+superclass-no-fkcol-name: Type \"{0}\" does not supply a name for at least one \\\n+\tdeclared superclass join column.\n+superclass-bad-fkconst: Type \"{0}\" declares invalid constant value target \\\n+\t\"{1}\" for the column with name \"{2}\" in its superclass join.\n+superclass-bad-fktarget-inverse: Type \"{0}\" declares superclass join column \\\n+\t\"{1}\" with a target in table \"{3}\", but all targets must be in table \"{2}\".\n+superclass-bad-fk-inverse: Type \"{0}\" declares a superclass join in table \\\n+\t\"{1}\", but all columns must be in table \"{2}\".\n+superclass-no-fkcol-name-adapt: Type \"{0}\" does not supply a name for at \\\n+\tleast one declared column in its superclass join.  Since this join can \\\n+\tinvolve multiple columns, each column must give either its name or its \\\n+\ttarget.\n+superclass-no-fkcol-target-adapt: Type \"{0}\" does not supply a target for \\\n+\tcolumn \"{1}\" in its superclass join.  Since this mapping can involve \\\n+\tmultiple columns and the a target column with the same name doesn''t \\\n+\texist, you must give a target explicitly.\n+superclass-bad-fktarget: Type \"{0}\" defines a target of \"{1}\" for superclass \\\n+\tjoin column \"{2}\", but that target does not exist in table \"{3}\".\n+superclass-bad-fktargetcls: \"{0}\" defines target field \"{1}\" for superclass \\\n+\tjoin column \"{2}\", but OpenJPA cannot deterimine the owning class for that \\\n+\tfield.\n+superclass-bad-fktargetfield: Type \"{0}\" defines target field of \"{1}\" for \\\n+\tsuperclass join column \"{2}\", but that field does not exist in type \"{3}\".\n+superclass-fktargetfield-cols: Type \"{0}\" defines target field \"{1}\" for \\\n+\tsuperclass join column \"{2}\", but that field is either unmapped or has \\\n+\tmultiple columns.\n+superclass-mult-fk-tables: The superclass join on type \"{0}\" uses columns from \\\n+\tmultiple different tables: \"{1}\", \"{2}\"\n+superclass-fk-exists: Type \"{0}\" marks its superclass join columns as \\\n+\texplicitly not having a foreign key delete action, but a database foreign \\\n+\tkey exists on these columns.\n+superclass-defer-fk: Type \"{0}\" marks its superclass join columns as having a \\\n+\tdeferred foreign key, but the existing constraint on these columns is not \\\n+\tdeferred. OpenJPA cannot change the deferrability of a constraint.\n+superclass-create-defer-fk: Type \"{0}\" marks its superclass join columns as \\\n+\thaving a deferred foreign key, but the database dictionary \"{1}\" reports \\\n+\tthat it does not support deferred constraints.  Creating an undeferred \\\n+\tconstraint.\n+superclass-unsupported-fk-action: Type \"{0}\" uses an unsupported foreign key \\\n+\tdelete or update action on its superclass join columns.  Reverting to a \\\n+\tlogical foreign key.\n+superclass-const-join: \"{0}\" attmpts to join a constant value to another \\\n+\tconstant value.\n+join-no-index-cols: \"{0}\" declares a join index, but has no join columns.\n+join-index-exists: \"{0}\" marks its join columns as explicitly not indexed, but \\\n+\tan index exists.\n+join-index-not-unique: \"{0}\" marks its join columns as having a unique index, \\\n+\tbut the existing index on those columns is not unique.\n+join-no-unique-cols: \"{0}\" declares a unique join constraint, but has no \\\n+\tjoin columns.\n+join-unique-exists: \"{0}\" marks its join columns as explicitly not unique, but \\\n+\ta unique constraint exists.\n+join-unique-support: \"{0}\" marks its join columns as having a unique \\\n+\tconstraint, but your database does not support unique constraints.  \\\n+\tInclude \"SupportsUniqueConstraints=true\" in the org.apache.openjpa.jdbc.DBDictionary \\\n+\tconfiguration property to override this default.\n+join-defer-unique: \"{0}\" marks its join columns as having a deferred unique \\\n+\tconstraint, but the existing constraint on these columns is not deferred. \\\n+\tOpenJPA cannot change the deferrability of a constraint.\n+join-create-defer-unique: \"{0}\" marks its join columns as having a deferred \\\n+\tunique constraint, but the database dictionary \"{1}\" reports that it does \\\n+\tnot support deferred constraints.  Creating an undeferred constraint.\n+join-no-fk-cols: \"{0}\" declares a join foreign key, but has no join columns.\n+join-no-fkcol-name: \"{0}\" does not supply a name for at least one declared \\\n+\tjoin column.\n+join-bad-fkconst: \"{0}\" declares invalid constant value target \"{1}\" for \\\n+\tjoin column with name \"{2}\".\n+join-bad-fktarget-inverse: \"{0}\" declares a target for join column \"{1}\" in \\\n+\ttable \"{3}\", but all join targets must be in table \"{2}\".\n+join-bad-fk-inverse: \"{0}\" declares a join column in table \"{1}\", but all \\\n+\tjoin columns must be in table \"{2}\".\n+join-bad-fk-self-inverse: \"{0}\" declares an inverse self-join on table \\\n+\t\"{1}\", but this mapping does not allow inverse joins.  If you did not \\\n+\tintend to make this an inverse join, take the table name out of the \\\n+\tcolumn names for this mapping.\n+join-no-fkcol-name-adapt: \"{0}\" does not supply a name for at least one \\\n+\tdeclared join column.  Since this join can involve multiple columns or \\\n+\tuses constant joins, each column must give either its name or a \\\n+\tnon-constant target.\n+join-no-fkcol-target-adapt: \"{0}\" does not supply a target for join column \\\n+\t\"{1}\".  Since this join can involve multiple columns and the a target \\\n+\tcolumn with the same name doesn''t exist, you must give a target explicitly.\n+join-bad-fktarget: \"{0}\" defines a target of \"{1}\" for join column \"{2}\", but \\\n+\tthat target does not exist in table \"{3}\".\n+join-bad-fktargetcls: \"{0}\" defines target field \"{1}\" for join column \"{2}\", \\\n+\tbut OpenJPA cannot deterimine the owning class for that field.\n+join-bad-fktargetfield: \"{0}\" defines target field of \"{1}\" for join column \\\n+\t\"{2}\", but that field does not exist in type \"{3}\".\n+join-fktargetfield-cols: \"{0}\" defines target field \"{1}\" for join column \\\n+\t\"{2}\", but that field is either unmapped or has multiple columns.\n+join-mult-fk-tables: \"{0}\" uses join columns from multiple different tables: \\\n+\t\"{1}\", \"{2}\"\n+join-fk-exists: \"{0}\" marks its join columns as explicitly not having a \\\n+\tforeign key delete action, but a database foreign key exists on these \\\n+\tcolumns.\n+join-defer-fk: \"{0}\" marks its join columns as having a deferred foreign key, \\\n+\tbut the existing constraint on these columns is not deferred. OpenJPA cannot \\\n+\tchange the deferrability of a constraint.\n+join-create-defer-fk: \"{0}\" marks its join columns as having a deferred \\\n+\tforeign key, but the database dictionary \"{1}\" reports that it does not \\\n+\tsupport deferred constraints.  Creating an undeferred constraint.\n+join-unsupported-fk-action: \"{0}\" uses an unsupported foreign key delete or \\\n+\tupdate action on its join columns.  Reverting to a logical foreign key.\n+join-const-join: \"{0}\" attmpts to join a constant value to another constant \\\n+\tvalue.\n+unmapped: Attempt to map \"{0}\" failed: the owning entity is not mapped.\n+col-wrong-table: When mapping \"{0}\" to table \"{1}\", found a column mapped to \\\n+\tillegal table \"{2}\".\n+target-wrong-cls: When mapping \"{0}\", found join with a target-field in class \\\n+\t\"{1}\".  This class does not match the expected source or target mappings \\\n+\tfor the join (\"{2}\", \"{3}\").\n+no-equiv-mapped-by: \"{0}\" does not have a valid mapping.  It declares that it \\\n+\tis mapped by \"{2}\", but \"{1}\", a subclass of its declared type, does not \\\n+\tinherit that relation field.\n+cant-inverse: \"{0}\" is not a valid mapping.  Inverse foreign key-based \\\n+\trelations to types with unjoined subclasses are not supported.\n+importexport-instantiate: Could not instantiate library to import \\\n+\tor export mapping information.\n+tool-usage: Usage: java org.apache.openjpa.jdbc.meta.MappingTool\\n\\\n+\t\\t[-properties/-p <properties file or resource>]\\n\\\n+\t\\t[-<property name> <property value>]*\\n\\\n+\t\\t[-file/-f <stdout | output file or resource>]\\n\\\n+\t\\t[-schemaFile/-sf <stdout | output file or resource>]\\n\\\n+\t\\t[-sqlFile/-sql <stdout | output file or resource>]\\n\\\n+\t\\t[-schemaAction/-sa <add | retain | drop | refresh | build | none>]\\n\\\n+\t\\t[-schemas/-s <schemas and tables>]\\n\\\n+\t\\t[-readSchema/-rs <true/t | false/f>]\\n\\\n+\t\\t[-primaryKeys/-pk <true/t | false/f>]\\n\\\n+\t\\t[-foreignKeys/-fk <true/t | false/f>]\\n\\\n+\t\\t[-indexes/-ix <true/t | false/f>]\\n\\\n+\t\\t[-dropTables/-dt <true/t | false/f>]\\n\\\n+\t\\t[-openjpaTables/-kt <true/t | false/f>]\\n\\\n+\t\\t[-dropSequences/-dsq <true/t | false/f>]\\n\\\n+\t\\t[-sequences/-sq <true/t | false/f>]\\n\\\n+\t\\t[-ignoreErrors/-i <true/t | false/f>]\\n\\\n+\t\\t[-action/-a <refresh | add | buildSchema | drop | validate | import \\n\\\n+\t| export>]\\n\\\n+\t\\t<class name | .java file | .class file | .jdo file | .orm file | \\\n+\t.mapping file>*\n+tool-running: Mapping tool running on type \"{0}\" with action \"{1}\".\n+tool-time: The tool is now reading existing schema information; this process \\\n+\tmay take some time.  Enable the org.apache.openjpa.jdbc.Schema logging category to see \\\n+\tmessages about schema data.  Also see the -readSchema tool flag.\n+tool-record: Recording mapping and schema changes.\n+bad-store: Your configured MetaDataFactory or MappingFactory plugin does not \\\n+\tsupport storing information.  You must write the information by hand. If \\\n+\tyou are trying to create a schema using default column and table names, \\\n+\trun mappingtool with the \"buildSchema\" action instead of the \\\n+\t\"refresh\" or \"add\" actions.\n+bad-drop: Some of the following mappings may not have been dropped: {0}. \\\n+\tUndropped mappings will not affect the system.\n+no-drop-meta: The schema for type \"{0}\" may not be dropped, because its \\\n+\tmapping could not be parsed.\n+bad-bk-file: Could not create a backup file for \"{0}\".\n+running-all-classes: No targets were given.  Running on all classes listed in \\\n+\tyour configuration, or all persistent classes in the classpath if no \\\n+\tclasses are configured.\n+fatal-change: There has been a fatal change to the definition of \"{0}\" or its \\\n+\tschema since it was last mapped, or the mapping you defined is invalid:\\n\\\n+\t{1}\\nOpenJPA will attempt to create a new mapping.\n+bad-field-strategy: Field \"{0}\" declared custom mapping strategy \"{1}\", but \\\n+\tthis strategy cannot be instantiated.\n+bad-cls-strategy: Could not instantiate custom class strategy \"{1}\" \\\n+\tfor type \"{0}\".  Make sure this is a valid ClassStrategy implementation.\n+bad-discrim-strategy: Could not instantiate custom discriminator strategy \\\n+\t\"{1}\" for type \"{0}\".  Make sure this is a valid DiscriminatorStrategy \\\n+\timplementation.\n+bad-version-strategy: Could not instantiate custom version strategy \\\n+\t\"{1}\" for type \"{0}\".  Make sure this is a valid VersionStrategy \\\n+\timplementation.\n+bad-value-handler: \"{0}\" declared custom value handler \"{1}\", but this handler \\\n+\tcannot be instantiated.\n+bad-mapped-strategy: The type for \"{0}\" is mapped to custom strategy \"{1}\", \\\n+\tbut this strategy cannot be instantiated.\n+no-field-strategy: OpenJPA cannot map field \"{0}\" efficiently.  It is of an \\\n+\tunsupported type. The field value will be serialized to a BLOB by default.\n+max-embed-lob: \"{0}\" is being mapped with a handler that may not be able to \\\n+\tstore values over {1} bytes/chars long.\n+incomplete-join: The system has detected an incomplete join on column \"{0}\".  \\\n+\tWhen you specify a join between tables, you must join to all the columns \\\n+\tof any fields involved.\n+bad-remap: Column \"{0}\" cannot be involved in polymorphic table-per-class \\\n+\trelationships because its corresponding field is mapped differently in \\\n+\tvarious classes in the hierarchy.\n+unmap-table: Table \"{0}\" could not be reverse mapped.  This means that the \\\n+\ttable does not have a primary key (primary keys are required to establish \\\n+\tunique identifiers for all persistent objects) and does not match a known \\\n+\tpattern for a table used for cross-reference or value collections.\n+unmap-cols: The following columns of table \"{0}\" could not be reverse \\\n+\tmapped \"{1}\".\n+no-pk-fields: Reverse-mapped type \"{0}\" is configured to use application \\\n+\tidentity, but has no primary key fields.\n+class-code: Writing java code for generated type \"{0}\".\n+cant-use-char: Column \"{0}\" is type CHAR(1), but OpenJPA cannot \\\n+\treverse map it into a Java char because OpenJPA is currently configured to \\\n+\tstore Java chars into numeric database columns.  To configure OpenJPA to \\\n+\tstore Java chars into CHAR(1) columns, set the following property:\\n\\\n+\torg.apache.openjpa.jdbc.DBDictionary: StoreCharsAsNumbers=false\n+revtool-running: The reverse mapping tool will run on the database.  The tool \\\n+\tis gathering schema information; this process may take some time.  Enable \\\n+\tthe org.apache.openjpa.jdbc.Schema logging category to see messages about schema data.\n+revtool-running-file: The reverse mapping tool will run on schema file \"{0}\".\n+revtool-map: Calculating reverse mappings.\n+revtool-write-code: Writing generated class source code.\n+revtool-write-appid: Writing generated application identity classes.\n+revtool-write-metadata: Writing generated metadata.\n+revtool-usage: Usage: java org.apache.openjpa.jdbc.meta.ReverseMappingTool\\n\\\n+\t\\t[-properties/-p <properties file or resource>]\\n\\\n+\t\\t[-<property name> <property value>]*\\n\\\n+\t\\t[-directory/-d <output directory>]\\n\\\n+\t\\t[-schemas/-s <schema and table list>]\\n\\\n+\t\\t[-package/-pkg <package name>]\\n\\\n+\t\\t[-useSchemaName/-sn <true/t | false/f>]\\n\\\n+\t\\t[-useForeignKeyName/-fkn <true/t | false/f>]\\n\\\n+\t\\t[-nullableAsObject/-no <true/t | false/f>]\\n\\\n+\t\\t[-blobAsObject/-bo <true/t | false/f>]\\n\\\n+\t\\t[-typeMap/-type <types>]\\n\\\n+\t\\t[-primaryKeyOnJoin/-pkj <true/t | false/f>]\\n\\\n+\t\\t[-useDatastoreIdentity/-ds <true/t | false/f>]\\n\\\n+\t\\t[-useBuiltinIdentityClass/-bic <true/t | false/f>]\\n\\\n+\t\\t[-innerIdentityClasses/-inn <true/t | false/f>]\\n\\\n+\t\\t[-identityClassSuffix/-is <suffix>]\\n\\\n+\t\\t[-inverseRelations/-ir <true/t | false/f>]\\n\\\n+\t\\t[-detachable/-det <true/t | false/f>]\\n\\\n+\t\\t[-discriminatorStrategy/-ds <strategy>]\\n\\\n+\t\\t[-versionStrategy/-vs <strategy>]\\n\\\n+\t\\t[-metadata/-md <package | class>]\\n\\\n+\t\\t[-customizerClass/-cc <full class name>]\\n\\\n+\t\\t[-customizerProperties/-cp <properties file or resource>]\\n\\\n+\t\\t[-customizer/-c.<property name> <property value>]*\\n\\\n+\t\\t[-codeFormat/-cf.<property name> <property value>]*\\n\\\n+\t\\t[.schema file]*\n+custom-class: Customized name found for class \"{0}\": will rename as \"{1}\".\n+custom-no-class: No customized name found for class \"{0}\" of table \"{1}\".\n+custom-rm-class: Removing class \"{0}\" of table \"{1}\" from reverse mapped set.\n+custom-field: Customized name found for field \"{0}\" in type \"{1}\": will \\\n+\trename as \"{1}\".\n+custom-no-field: No customized name found for field \"{0}\" in type \"{1}\".\n+custom-rm-field: Removing field \"{0}\" in type \"{1}\" from reverse mapped set.\n+custom-unused-props: The following customizer properties were not used in \\\n+\tthe reverse mapping process: {0}.\n+reverse-type: Overriding type mapping for column of type name \"{0}\" to Java \\\n+\tclass \"{1}\". \n+no-reverse-type: No overridden type mapping for column of type name \"{0}\".\n+no-query-res: There is no query result mapping for \"{0}\" with name \"{1}\".\n+null-path: Attempt to add a null or empty path to result type \"{1}\" in mapping \\\n+\t\"{0}\". \n+bad-path: Result path \"{2}\" in result type \"{1}\" of mapping \"{0}\" contains \\\n+\tinvalid fields.\n+untraversable-path: Result path \"{2}\" in result type \"{1}\" of mapping \"{0}\" \\\n+\tattempts to traverse through a non-relation field.\n+num-cols-path: Result path \"{2}\" in result type \"{1}\" of mapping \"{0}\" \\\n+\tattempts to map a field that does not have exactly 1 column.\n+lock-group-requires-perf-pack: Field \"{0}\" declares the lock-group extension. \\\n+\tIn order to use custom lock groups, you must have a performance pack or \\\n+\tenterprise edition license. Contact sales@bea.com for details on \\\n+\tupgrading your license.\n+sub-lock-groups: Type \"{0}\" has a mapped superclass, and therefore cannot \\\n+\tdeclare additional lock groups.  Use the \"lock-groups\" extension on the \\\n+\tmapped superclass to declare any additional lock groups needed by this \\\n+\ttype.  {1}\n+vers-mult-lock-groups: Type \"{0}\" cannot use a version field because it has \\\n+\tmultiple lock groups."},{"sha":"bb3ec151b53e2098d89f96aa2b5fc55389291596","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties","status":"added","additions":121,"deletions":0,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,121 @@\n+rel-to-unknownid: You cannot map a logical foreign key relation to an object \\\n+\twith an unknown identity type.\n+cant-mapped-by: Field \"{0}\" cannot declare that it is mapped by another field. \\\n+\tIts mapping strategy ({1}) does not support mapping by another field.\n+mapped-inverse-unjoined: Field \"{0}\" as defined in \"{1}\" cannot be mapped by \\\n+\t\"{2}\".  You cannot use an inverse foreign key to map a superclass field of \\\n+\tan unjoined subclass.\n+mapped-by-unmapped: Field \"{0}\" cannot be mapped by \"{1}\", because the related \\\n+\ttype is unmapped.\n+cant-join: Cannot join across \"{0}\".  The related type has unjoined subclasses.\n+cant-inverse: \"{0}\" is not a valid mapping.  Inverse foreign key-based \\\n+\trelations to types with unjoined subclasses are not supported.\n+cant-load: \"{0}\" is not a valid mapping. The related type has subclasses that \\\n+\tare not reachable via joins, so OpenJPA must be able to construct an oid \\\n+\tfrom the mapped foreign key.  But your foreign key does not represent all \\\n+\tprimary key values of the related type. \n+flush-virtual: Attempt to flush an unmapped object of type \"{0}\" with oid \"{1}\".\n+cant-project-owned: \"{0}\" cannot be used in a projection, because it can only \\\n+\tbe loaded as part of its owning object.\n+not-embeddable: \"{0}\" is mapped as embedded, but embedded field \"{1}\" is not \\\n+\tembeddable.  Embedded element/key/value types are limited to simple fields \\\n+\tand direct relations to other persistent types.\n+oid-invalid: Object id data \"{0}\" loaded from the database for \"{1}\" is not in \\\n+\tthe correct format. Please ensure that your database records are in the \\\n+\tcorrect format.\n+lrs-no-owner: This container was loaded in large result set field \"{0}\", but \\\n+\thas been removed from its owning field.  Therefore, it can no longer be \\\n+\tused.\n+not-full: Type \"{0}\" specifies a full class mapping strategy, but has a mapped \\\n+\tpersistence capable superclass or is embedded.  Use a valid subclass or \\\n+\tembedded strategy instead.\n+not-base-vers: Type \"{0}\" specifies a version strategy, but has a mapped \\\n+\tpersistence capable superclass or is embedded.  Subclasses and embedded \\\n+\tvalues must use the version strategy of the base or embedding class.\n+not-base-disc: Type \"{0}\" specifies a discriminator strategy, but has a mapped \\\n+\tpersistence capable superclass or is embedded.  Subclasses and embedded \\\n+\tvalues must use the discriminator strategy of the base or embedding class.\n+not-sub: Type \"{0}\" specifies a subclass mapping strategy, but does not \\\n+\thave a mapped persistence capable superclass or is embedded.  Use a valid \\\n+\tbase or embedded class strategy instead.\n+not-embed: \"{0}\" specifies an embedded mapping strategy, but it is not \\\n+\tembedded.\n+not-oid: \"{0}\" species an object id mapping strategy, but it is not \\\n+\tan object id field.\n+oid-not-joinable: Field \"{0}\" embedded within object id field \"{1}\" cannot be \\\n+\ta primary key value.  Its mapping does not it to be a join target.\n+flat-table: Type \"{0}\" uses a flat inheritance mapping, but declares a table \\\n+\tname of \"{1}\", which does not match the superclass table \"{2}\".  \n+not-string: Field \"{0}\" declares a string field mapping strategy, but is not \\\n+\ta string field.\n+not-primitive: Field \"{0}\" declares a primitive field mapping strategy, but \\\n+\tis not of a primitive type.\n+not-clobstring: Field \"{0}\" declares a clob field mapping strategy, but is \\\n+\tnot a string field.\n+not-bytes: Field \"{0}\" declares a byte array field mapping strategy, but is \\\n+\tnot a byte array field.\n+not-chars: Field \"{0}\" declares a char array field mapping strategy, but is \\\n+\tnot a char array field.\n+not-serialized: Field \"{0}\" declares a blob mapping strategy, but the \\\n+\tfield''s value is not serialized.  Set the field''s \"serialized\" attribute \\\n+\tto true.  \n+not-relation: \"{0}\" declares a relation mapping strategy, but is not a \\\n+\tdirect, non-embedded relation to another persistence-capable object.\n+not-elem-relation: \"{0}\" declares a to-many relation strategy, but its \\\n+\telements are not direct, non-embedded relations to another mapped \\\n+\tpersistence-capable object.\n+not-inv-relation: Field \"{0}\" declares \"{1}\" as its mapped-by field, but this \\\n+\tfield is not a direct relation.\n+not-inv-relation-coll: Field \"{0}\" declares \"{1}\" as its mapped-by field, but \\\n+\tthis field is not a collection of inverse relations.\n+not-coll: Field \"{0}\" declares a collection mapping strategy, but is not a \\\n+\tcollection or array type.\n+coll-owner:  Inefficient mapping: You have declared that field \"{0}\" is mapped \\\n+\tby collection \"{1}\".  The mapping would be much more efficient if instead \\\n+\tyou map \"{0}\" and declare that \"{1}\" is mapped by it.\n+class-crit-owner: Field \"{0}\" declares that it uses class criteria for joins, \\\n+\tand this field is not owned by an inverse field.  As a result, it is \\\n+\timpossible to correctly null the inverse foreign keys when the field is \\\n+\tdeleted.  OpenJPA may leave orphan key values in the database if you do not \\\n+\tprovide an owning inverse relation using the \"mapped-by\" attribute.\n+not-map: Field \"{0}\" declares a map mapping strategy, but is not a map type.\n+mapped-by-key: Map field \"{0}\" is attempting to use a map table, but its key \\\n+\tis mapped by another field.  Use an inverse key or join table mapping.\n+not-mapped-by-key: Map field \"{0}\" is attempting to use an inverse key or join \\\n+\ttable mapping, but its key is not mapped by another field.  Use a map \\\n+\ttable mapping. \n+no-handler: Field \"{0}\" declares a handler-based mapping strategy, but no \\\n+\tvalue handler is installed.\n+auto-assign-handler: Attempt to use an auto-assigned column value in a handler \\\n+\twith multiple columns.  To use an auto-assigned column value with field \\\n+\t\"{0}\", you will have to write a custom field mapping that implements the \\\n+\torg.apache.openjpa.jdbc.meta.Joinable interface.\n+no-lock-groups: Type \"{0}\" does not have any fields that participate in \\\n+\toptimistic locking.  Set its version strategy to \"none\".\n+load-subs: Loading subclasses from discriminator column of \"{0}\".\n+no-class-name: The discriminator column \"{1}\" for type \"{1}\" contains a null \\\n+\tor empty value. \n+cant-init-subs: The discriminator for type \"{0}\" cannot compute the list of \\\n+\tits subclasses on its own.  You should either use a discriminator strategy \\\n+\tthat has this ability (such as the class-name strategy), include the set \\\n+\tof persistent classes in the \"org.apache.openjpa.MetaDataFactory\" property so that OpenJPA \\\n+\tcan discover all persistent classes at startup, or make sure that all \\\n+\tsubclasses of this type have had their class instantiated in the JVM \\\n+\tbefore performing any persistent operations on this class or its \\\n+\tsubclasses.  If this class does not have any subclasses, consider making \\\n+\tthe class final or changing its discriminator strategy to \"final\".\n+no-discrim-value: Type \"{0}\" uses the value-map discriminator strategy, but \\\n+\tdoes not declare a discriminator value.\n+dup-discrim-value: Discriminator value \"{0}\" is used for two different \\\n+\tclasses in the same inheritance tree: \"{1}\", \"{2}\"\n+outer-join-support: The subclass-join class indicator mapped to \"{0}\" requires \\\n+\touter joins to function.  Your database dictionary is configured to use \\\n+\t\"traditional\" join syntax, which does not support outer joins.  To \\\n+\tuse SQL 92 joins instead, set the following property:\\n\\\n+\torg.apache.openjpa.jdbc.DBDictionary: JoinSyntax=sql92\n+unknown-discrim-value: Could not map disciminator value \"{0}\" to any \\\n+\tknown subclasses of the requested class \"{1}\" (known discriminator \\\n+\tvalues: {2}).\n+bad-unmapped-rel: \"{0}\" cannot be mapped without stringifying the oid of \\\n+\tthe related object to a string column.  The related type is unmapped and \\\n+\tits \"{1}\" primary key field does not use a simple mapping."},{"sha":"692ff80d2487c86d4e5ee97d50d9c31b544772a8","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties","status":"added","additions":132,"deletions":0,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,132 @@\n+bad-join: The following error was detected when creating a foreign key: \\\n+\t\"{0}\".  The foreign key is being ignored.\n+no-driver: A JDBC Driver or DataSource class name must be specified in the \\\n+\tConnectionDriverName property.\n+bad-driver: The specified driver \"{0}\" is neither a java.sql.Driver \\\n+\tnor a javax.sql.DataSource class name.\n+bad-sch-ref: The schema information table could not be created: {0}\n+bad-sch-read: Attempt to read the schema information table failed; continuing \\\n+\ton the assumption that the table has not been created yet, and there is \\\n+\tno data to read: {0}\n+bad-sch-write-1: First attempt to write to the schema information table \\\n+\tfailed; will attempt to create the table in case it has been dropped \\\n+\tbefore re-trying: {0}\n+bad-sch-write-2: Attempt to write the schema information table for the second \\\n+\ttime failed.  See previous log messages for possible reasons.\n+bad-seq-num: Bad numeric constant for attribute in sequence \"{0}\".\n+pk-resolve: The column \"{0}\" specified as a primary key for table \"{1}\" \\\n+\tdoes not exist in that table.\n+index-info: Unable to get index information for table \"{0}\": \"{1}\"\n+index-resolve: The column \"{1}\" specified as part of index \"{0}\" on table \\\n+\t\"{2}\" does not exist in that table.\n+unq-resolve: The column \"{1}\" specified as part of unique constraint \"{0}\" on \\\n+\ttable \"{2}\" does not exist in that table.\n+fk-totable: The foreign table \"{1}\" specified in foreign key \"{0}\" on \\\n+\ttable \"{2}\" does not exist or does not have a primary key.\n+fk-nocol: The column \"{1}\" specified by foreign key \"{0}\" on table \"{2}\" \\\n+\tdoes not exist in that table.\n+fk-nopkcol: The column \"{1}\" of table \"{2}\" joined to by foreign key \"{0}\" \\\n+\ton table \"{3}\" does not exist or is not a primary key column.\n+bad-name: You must supply a valid name for this schema component.\n+dup-col-name: The name \"{0}\" is already taken by a column in this table.\n+table-mismatch: You are attempting to add a column from table \"{0}\" to a \\\n+\tconstraint or index on table \"{1}\".\n+fk-mismatch: You are attempting to link to a primary key column in table \\\n+\t\"{0}\" in a foreign key that is already linked to primary key columns in \\\n+\ttable \"{1}\".\n+ser-schema: Writing schema \"{0}\".\n+tool-norepos: You cannot perform this action until you set the schema group \\\n+\tto act on.\n+tool-running: Schema tool will run on schema file \"{0}\".\n+tool-import-store: Storing imported schema data in schema factory.\n+tool-export-gen: Gathering schema information to export; this process \\\n+\tmay take some time.  Enable the org.apache.openjpa.jdbc.Schema logging category to see \\\n+\tmessages about the collection of schema data.\n+tool-action: Schema tool running action \"{0}\".  This process may take some \\\n+\ttime.  Enable the org.apache.openjpa.jdbc.Schema logging category to see messages about \\\n+\tthe collection of schema data, and the org.apache.openjpa.jdbc.SQL category to see \\\n+\tgenerated SQL commands.\n+tool-record: Recording schema changes.\n+tool-export-write: Writing schema data to XML.\n+tool-usage: Usage: java org.apache.openjpa.jdbc.schema.SchemaTool\\n\\\n+\t\\t[-properties/-p <properties file or resource>]\\n\\\n+\t\\t[-<property name> <property value>]*\\n\\\n+\t\\t[-file/-f <stdout | output file or resource>]\\n\\\n+\t\\t[-ignoreErrors/-i <true/t | false/f>]\\n\\\n+\t\\t[-dropTables/-dt <true/t | false/f>]\\n\\\n+\t\\t[-openjpaTables/-kt <true/t | false/f>]\\n\\\n+\t\\t[-dropSequences/-dsq <true/t | false/f>]\\n\\\n+\t\\t[-sequences/-sq <true/t | false/f>]\\n\\\n+\t\\t[-primaryKeys/-pk <true/t | false/f>]\\n\\\n+\t\\t[-foreignKeys/-fk <true/t | false/f>]\\n\\\n+\t\\t[-indexes/-ix <true/t | false/f>]\\n\\\n+\t\\t[-record/-r <true/t | false/f>]\\n\\\n+\t\\t[-action/-a <add | retain | drop | refresh | build | reflect\\n\\\n+\t\\t\\t| createDB | dropDB | import | export>]\\n\\\n+\t\\t<.schema file or resource>*\n+sch-reflect: Reflecting on schemas \"{0}\".  This process may take some time.  \\\n+\tEnable the org.apache.openjpa.jdbc.Schema logging category to see messages about the \\\n+\tcollection of schema data.\n+sch-reflect-write: Writing XML representation of schema.\n+drop-index: The index \"{0}\" was not dropped from table \"{1}\".\n+drop-fk: The foreign key \"{0}\" was not dropped from table \"{1}\".\n+drop-pk: The primary key \"{0}\" was not dropped from table \"{1}\".\n+drop-col: The column \"{0}\" was not dropped from table \"{1}\".\n+drop-table: The table \"{0}\" was not dropped.\n+drop-seq: The sequence \"{0}\" was not dropped.\n+add-col: The column \"{0}\" was not added to table \"{1}\".\n+add-index: The index \"{0}\" was not created on table \"{1}\".\n+too-many-indexes: The index \"{0}\" was not created on table \"{1}\", since it \\\n+\twould go beyond the maximum index limit of {2}.\n+add-pk: The primary key \"{0}\" was not added to table \"{1}\".\n+add-fk: The foreign key \"{0}\" was not added to table \"{1}\".\n+add-table: The table \"{0}\" was not created.\n+add-seq: The sequence \"{0}\" was not added to the database.\n+bad-col: Existing column \"{0}\" on table \"{1}\" is incompatible with the \\\n+\tsame column in the given schema definition. Existing column:\\n{2}\\\n+\tGiven column:\\n{3}\t\n+bad-pk: Existing primary key \"{0}\" on table \"{1}\" is incompatible with \\\n+\tthe same primary key in the given schema definition.\n+bad-index: Existing index \"{0}\" on table \"{1}\" is incompatible with the \\\n+\tsame index in the given schema definition.\n+bad-fk: Existing foreign key \"{0}\" on table \"{1}\" is incompatible with \\\n+\tthe same foreign key in the given schema definition.\n+bad-fk-action-hint: \"{1}\" is not a recognized foreign key action, though it \\\n+\tclosely resembles the standard action \"{2}\". Available actions are: {3}\n+bad-fk-action: \"{1}\" is not a recognized foreign key action.  Available \\\n+\tactions are: {2}\n+gen-pk: Found existing primary key \"{0}\" on table \"{1} ({2})\".\n+gen-index: Found existing index \"{0}\" on table \"{1} ({2})\".\n+gen-fk: Found existing foreign key \"{0}\" on table \"{1} ({2})\" linking to \\\n+\ttable \"{3} ({4})\".  Sequence: \"{5}\".\n+gen-nofktable: Table \"{0}\" has a foreign key to table \"{1}\" that has not been \\\n+\tgenerated.  You must run the schema generator on all inter-related tables \\\n+\tat once.\n+gen-tables: Reading table information for schema name \"{0}\", table name \"{1}\".\n+gen-pks: Reading primary keys for schema name \"{0}\", table name \"{1}\".\n+gen-indexes: Reading indexes for schema name \"{0}\", table name \"{1}\".\n+gen-fks: Reading foreign keys for schema name \"{0}\", table name \"{1}\".\n+col-table: Reading column information for table \"{0}\".\n+gen-column: Found existing column \"{0}\" on table \"{1}\".\n+gen-seqs: Reading sequence information for schema \"{0}\", sequence name \"{1}\".\n+no-idx-meta: Unable to get index metadata for table \"{0}\": {1}\n+make-sch-table: Creating table to hold schema information.\n+drop-sch-table: Dropping schema table.\n+sch-usage: Usage: java org.apache.openjpa.jdbc.schema.TableSchemaFactory\\n\\\n+\t\\t[-properties <properties file or resource>]\\n\\\n+\t\\t[-<property name> <property value>]\\n\\\n+\t\\t-action/-a <add | drop>\n+refresh-cancelled: Refresh operation cancelled.\n+generating-schemas: Reading schemas\n+generating-schema: Reading schema \"{0}\"\n+generating-all-primaries: Reading primary keys for schema \"{0}\"\n+generating-all-indexes: Reading indexes for schema \"{0}\"\n+generating-all-foreigns: Reading foreign keys for schema \"{0}\"\n+generating-columns: Reading columns for table \"{1}\"\n+generating-primary: Reading primary keys for table \"{1}\"\n+generating-indexes: Reading indexes for table \"{1}\"\n+generating-foreign: Reading foreign keys for table \"{1}\"\n+generating-sequences: Reading sequences for schema \"{0}\"\n+no-custom-ds: use a custom DataSource\n+max-pool-license: Your license only permits a maximum of {0} pooled \\\n+\tconnections; the connection pool will be configured accordingly."},{"sha":"1587d78d17a2231231d22c775aa2c7615debc9a8","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/schemas-doctype.rsrc","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/schemas-doctype.rsrc","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/schemas-doctype.rsrc","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/schemas-doctype.rsrc?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,47 @@\n+<!DOCTYPE schemas [\n+\t<!ELEMENT schemas (schema)*>\n+\t<!ELEMENT schema (table|sequence)*>\n+\t<!ATTLIST schema name CDATA #IMPLIED>\n+\t<!ELEMENT table (column|index|pk|fk)+>\n+\t<!ATTLIST table name CDATA #REQUIRED>\n+\t<!ELEMENT column EMPTY>\n+\t<!ATTLIST column name CDATA #REQUIRED> \n+ \t<!ATTLIST column type (array|bigint|binary|bit|blob|char|clob|date|decimal|distinct|double|float|integer|java_object|longvarbinary|longvarchar|null|numeric|other|real|ref|smallint|struct|time|timestamp|tinyint|varbinary|varchar) #REQUIRED>\n+\t<!ATTLIST column type-name CDATA #IMPLIED>\n+\t<!ATTLIST column not-null (true|false) #IMPLIED>\n+\t<!ATTLIST column auto-assign (true|false) #IMPLIED>\n+\t<!ATTLIST column auto-increment (true|false) #IMPLIED> <!-- deprecated -->\n+\t<!ATTLIST column default CDATA #IMPLIED>\n+\t<!ATTLIST column size CDATA #IMPLIED>\n+\t<!ATTLIST column decimal-digits CDATA #IMPLIED>\n+\t<!ELEMENT index (on)*>\n+\t<!ATTLIST index name CDATA #REQUIRED>\n+\t<!ATTLIST index column CDATA #IMPLIED>\n+\t<!ATTLIST index unique (true|false) #IMPLIED>\n+\t<!ELEMENT pk (on)*>\n+\t<!ATTLIST pk name CDATA #IMPLIED>\n+\t<!ATTLIST pk logical (true|false) #IMPLIED>\n+\t<!ATTLIST pk column CDATA #IMPLIED>\n+\t<!ELEMENT on EMPTY>\n+\t<!ATTLIST on column CDATA #REQUIRED>\n+\t<!ELEMENT fk (join)*>\n+\t<!ATTLIST fk name CDATA #IMPLIED>\n+\t<!ATTLIST fk deferred (true|false) #IMPLIED>\n+\t<!ATTLIST fk to-table CDATA #REQUIRED>\n+\t<!ATTLIST fk column CDATA #IMPLIED>\n+\t<!ATTLIST fk delete-action (cascade|default|restrict|exception|none|null) #IMPLIED>\n+\t<!ATTLIST fk update-action (cascade|default|restrict|exception|none|null) #IMPLIED>\n+\t<!ELEMENT join EMPTY>\n+\t<!ATTLIST join column CDATA #IMPLIED>\n+\t<!ATTLIST join to-column CDATA #IMPLIED>\n+\t<!ATTLIST join value CDATA #IMPLIED>\n+\t<!ELEMENT unique (on)*>\n+\t<!ATTLIST unique name CDATA #IMPLIED>\n+\t<!ATTLIST unique column CDATA #IMPLIED>\n+\t<!ATTLIST unique deferred (true|false) #IMPLIED>\n+\t<!ELEMENT sequence EMPTY>\n+\t<!ATTLIST sequence name CDATA #REQUIRED>\n+\t<!ATTLIST sequence initial-value CDATA #IMPLIED>\n+\t<!ATTLIST sequence increment CDATA #IMPLIED>\n+\t<!ATTLIST sequence allocate CDATA #IMPLIED>\n+]>"},{"sha":"a79b066c784850cf24f19228b45cc6572608d679","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","status":"added","additions":142,"deletions":0,"changes":142,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,142 @@\n+union-sql-placeholder: Aborting UNION: cannot select placeholder for \\\n+\tnon-column select SQL.\n+union-number-ordering: Aborting UNION: different numbers of order-by criteria \\\n+\tin selects.\n+union-incompat-ordering: Aborting UNION: incompatible ordering columns/sql or \\\n+\tdirection.\n+union-unaligned-ordering: Aborting UNION: your database does not support \\\n+\tordering columns/sql that appear at different positions in the SELECTs \\\n+\tthat make up the UNION.\n+union-element: Individual selects involved in a UNION do not support this \\\n+\toperation.\n+incompat-ordering: This query cannot be completed.  The SQL SELECTs needed \\\n+\tto complete the query have incompatible ordering.  Their results cannot \\\n+\tbe merged.\n+unpadded-char-cols: You are using CHAR columns with a data source or driver \\\n+\tthat doesn't implement OraclePreparedStatement.setFixedCHAR(). \\\n+\tComparisons on unpadded string values may fail.\n+unconfigured-nchar-cols: You are using NCHAR or NCLOB columns with a \\\n+\tdata source or driver \\\n+\tthat doesn't implement OraclePreparedStatement.setFormOfUse(). \\\n+\tStoring unicode values may fail or be corrupted.\n+diff-values: Attempt to set column \"{0}\" to two different values: \\\n+\t({1})\"{2}\", ({3})\"{4}\" \\\n+\tThis can occur when you fail to set both sides of a two-sided relation \\\n+\tbetween objects, or when you map different fields to the same column, but \\\n+\tyou do not keep the values of these fields in synch.\n+feature-not-supported: The database dictionary in use (\"{0}\") reports that it \\\n+\tdoes not have feature \"{1}\".  This feature is needed to complete the \\\n+\tcurrent operation.  To force OpenJPA to try to use the feature anyway, set \\\n+\tthe following property:\\n\\\n+\torg.apache.openjpa.jdbc.DBDictionary: {1}=<value>\n+cant-outer-fk: Could not outer join the given foreign key \"{0}\" due to syntax \\\n+\tand foreign key limitations.  The join was converted to an inner join.\n+no-auto-assign: This database dictionary does not support auto-assigned column \\\n+\tvalues.\n+bad-join: The following error was detected when creating a foreign key: \\\n+\t\"{0}\".  The foreign key is being ignored.\n+sybase-compliance: They Sybase connection URL \"{0}\" may be invalid: \\\n+\tit does not contain the parameter \"BE_AS_JDBC_COMPLIANT_AS_POSSIBLE=true\", \\\n+\twhich is required for the Sybase JConnect driver to behave in a \\\n+\tJDBC-compliant way.\n+sqlserver-cachedstmnts: The Microsoft JDBC driver has bugs that manifest \\\n+\tthemselves when prepared statements are pooled.  Please disable prepared \\\n+\tstatement pooling when using the Microsoft JDBC driver by including \\\n+\t\"MaxCachedStatements=0\" in your org.apache.openjpa.ConnectionFactoryProperties \\\n+\tconfiguration property.\n+sqlserver-netdirect-batch: The JNetDirect JDBC driver has problems when using \\\n+\tbatch statements. Please disable prepared \\\n+\tstatement pooling when using the this JDBC driver by including \\\n+\t\"BatchLimit=0\" in your org.apache.openjpa.jdbc.DBDictionary \\\n+\tconfiguration property.\n+sqlserver-cursor: The SQLServer connection URL \"{0}\" may be invalid: \\\n+\tit does not contain the parameter \"SelectMethod=cursor\", which is \\\n+\tnecessary for the driver to properly support large result sets.\n+oracle-syntax: Oracle 8 does not support SQL92 syntax.  You can avoid \\\n+\tthis message by setting the \"JoinSyntax\" DBDictionary property \\\n+\tto \"database\".\\\n+\tFor example:\\n\\\n+\torg.apache.openjpa.jdbc.DBDictionary: oracle(JoinSyntax=database)\n+oracle-batch-lob: LOB operations not allowed for batched statement: {0}\n+oracle-batch-bug: The Oracle 9.2 JDBC driver has problems with \\\n+\tbatch statements and has been disabled by default.  You can \\\n+\tenable batched statements by setting the \"BatchLimit\" DBDictionary \\\n+\tproperty.  You may be able to bypass this problem by disabling \\\n+\tprepared statement pooling. The compatible 9.0.1 driver does not \\\n+\thave this behavior.\n+oracle-batch-override: The BatchLimit property was set even though \\\n+\tthe Oracle 9.2 driver may not support this behavior correctly. \\\n+\tIf you see a number of invalid update count errors, you should \\\n+\tdisable statement batching by setting the BatchLimit property to 0.\n+oracle-connecting-for-driver: OpenJPA is now connecting to the database in order \\\n+\tto figure out what JDBC driver you are using, as OpenJPA must alter its \\\n+\tbehavior for this database depending on the driver vendor.  To avoid this \\\n+\tconnection, set the DriverVendor value in your org.apache.openjpa.jdbc.DBDictionary \\\n+\tconfiguration property to one of the following values:\\n\\\n+\toracle, oracle92 (for the 9.2 driver), datadirect, datadirect61 \\\n+\t(for driver versions <= 3.1), other \\n\\\n+\tFor example:\\n\\\n+\torg.apache.openjpa.jdbc.DBDictionary: oracle(DriverVendor=oracle92)\n+oracle-constant: Cannot outer join tables \"{0}\" and \"{1}\" using native \\\n+\tjoin syntax and constant joins.  If you are using Oracle 9 or higher, \\\n+\tyou should instead use SQL92 joins by specifying the JoinSyntax \\\n+\tvalue in the org.apache.openjpa.jdbc.DBDictionary configuration property:\\n\\\n+\torg.apache.openjpa.jdbc.DBDictionary: oracle(JoinSyntax=sql92).\n+oracle-savepoint: An error occurred when attempting to set an Oracle \\\n+\tsavepoint \"{0}\".  You must use Oracle driver and database 9.2 or higher.\n+oracle-rollback: An error occurred when attempting to rollback to an Oracle \\\n+\tsavepoint \"{0}\".  You must use Oracle driver and database 9.2 or higher.\n+oracle-unknown-svpt: Could not find an OracleConnection instance from this \\\n+\tconnection class \"{0}\".\n+db2-cant-lock: DB2 cannot perform FOR UPDATE selects on multiple tables. \\\n+\tThe tables used in this select are: \"{0}\".  You should either configure \\\n+\tyour application to avoid multi-table selects, use optimistic locking, \\\n+\tor set the \"SimulateLocking\" DBDictionary property to allow non-locking \\\n+\tselects within pessimistic transactions. \n+informix-cant-lock: Informix cannot perform FOR UPDATE selects on multiple \\\n+\ttables, or when it is a SELECT DISTINCT.  The tables used in this select \\\n+\tare: \"{0}\".  You should either configure your application to avoid \\\n+\tmulti-table/distinct selects, use optimistic locking, or set the \\\n+\t\"SimulateLocking\" DBDictionary property to allow non-locking selects \\\n+\twithin pessimistic transactions. \n+bad-param: The specified parameter of type \"{0}\" is not a valid query parameter.\n+warn-generic: Your database configuration was not recognized as a supported \\\n+\tOpenJPA database. The generic dictionary will be used, which may result in \\\n+\tlimited functionality. This behavior can be overridden by specifying the \\\n+\tappropriate dictionary class in the \"org.apache.openjpa.jdbc.DBDictionary\" \\\n+\tproperty of the OpenJPA configuration.\n+using-dict: Using dictionary class \"{0}\"{1}.\n+no-pessimistic: This dictionary ({0}) does not support locking, so \\\n+\toperations may not be performed using a Broker that does not have \\\n+\toptimistic locking enabled.\n+no-fk-table: Foreign key \"{0}\" on table \"{1}\" references a table \\\n+\t(\"{2}\") that was not found.\n+dd-lock-bug: This version of the DataDirect JDBC driver has a bug that \\\n+\tprevents SELECT FOR UPDATE statements from working.  Please \\\n+\tuse version 3.2 or higher of the driver.\t\n+storage-restriction: The database \"{0}\" has restrictions that prevent it \\\n+\tfrom being able to store the value \"{1}\" of type \"{2}\". The value \\\n+\twill be rounded to \"{3}\" for storage.\n+dict-not-supported: This database dictionary \"{0}\" is not officially supported \\\n+\tby BEA.\n+invalid-autoassign: This database dictionary \"{0}\" does not support \\\n+\tauto-assigned column values.  The column \"{1}\" may not behave as desired.\n+psql-no-set-fetch-size:\tThis version of the PostgreSQL JDBC driver does not \\\n+\tsupport the Statement.setFetchSize() method. OpenJPA will no longer attempt \\\n+\tto set the statement fetch size. To suppress this warning, ensure that \\\n+\tthe org.apache.openjpa.FetchBatchSize configuration property is set to zero. The \\\n+\toriginal PostgreSQL driver exception is being logged for your reference.\n+no-genkey: The last generated key query did not return any results.\n+invalid-genkey: The column \"{0}\" was marked as being auto-assigned, but \\\n+\tthe server reported that the assigned value was null.\n+indexof-not-supported: The database \"{0}\" does not support the \\\n+\tindexOf function.\n+substring-not-supported: The database \"{0}\" does not support the \\\n+\tsubstring function.\n+null-result-provider: supplied array of result object providers is null\n+empty-result-provider: supplied array of result object providers is empty\n+null-shared-result-set: supplied result set is null  \n+illegal-method: {0}.{1}() is illegal to be invoked \n+column-not-mapped: SQLResultSetMapping \"{0}\" does not map the columns \"{1}\" \\\n+\tthat are selected by the SQL query\\r\\n \"{2}\"\n+batch-license: Your license does not have SQL batching capabilities."},{"sha":"952ae4c0d56976010a2d31e92226fa940b654aad","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-keywords.rsrc","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-keywords.rsrc","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-keywords.rsrc","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-keywords.rsrc?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1 @@\n+ABSOLUTE,ACTION,ADD,ALL,ALLOCATE,ALTER,AND,ANY,ARE,AS,ASC,ASSERTION,AT,AUTHORIZATION,AVG,BEGIN,BETWEEN,BIT,BIT_LENGTH,BOTH,BY,CASCADE,CASCADED,CASE,CAST,CATALOG,CHAR,CHARACTER,CHAR_LENGTH,CHARACTER_LENGTH,CHECK,CLOSE,COALESCE,COLLATE,COLLATION,COLUMN,COMMIT,CONNECT,CONNECTION,CONSTRAINT,CONSTRAINTS,CONTINUE,CONVERT,CORRESPONDING,COUNT,CREATE,CROSS,CURRENT,CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,CURRENT_USER,CURSOR,DATE,DAY,DEALLOCATE,DEC,DECIMAL,DECLARE,DEFAULT,DEFERRABLE,DEFERRED,DELETE,DESC,DESCRIBE,DESCRIPTOR,DIAGNOSTICS,DISCONNECT,DISTINCT,DOMAIN,DOUBLE,DROP,ELSE,END,END-EXEC,ESCAPE,EXCEPT,EXCEPTION,EXEC,EXECUTE,EXISTS,EXTERNAL,EXTRACT,FALSE,FETCH,FIRST,FLOAT,FOR,FOREIGN,FOUND,FROM,FULL,GET,GLOBAL,GO,GOTO,GRANT,GROUP,HAVING,HOUR,IDENTITY,IMMEDIATE,IN,INDICATOR,INITIALLY,INNER,INPUT,INSENSITIVE,INSERT,INT,INTEGER,INTERSECT,INTERVAL,INTO,IS,ISOLATION,JOIN,KEY,LANGUAGE,LAST,LEADING,LEFT,LEVEL,LIKE,LOCAL,LOWER,MATCH,MAX,MIN,MINUTE,MODULE,MONTH,NAMES,NATIONAL,NATURAL,NCHAR,NEXT,NO,NOT,NULL,NULLIF,NUMERIC,OCTET_LENGTH,OF,ON,ONLY,OPEN,OPTION,OR,ORDER,OUTER,OUTPUT,OVERLAPS,PAD,PARTIAL,POSITION,PRECISION,PREPARE,PRESERVE,PRIMARY,PRIOR,PRIVILEGES,PROCEDURE,PUBLIC,READ,REAL,REFERENCES,RELATIVE,RESTRICT,REVOKE,RIGHT,ROLLBACK,ROWS,SCHEMA,SCROLL,SECOND,SECTION,SELECT,SESSION,SESSION_USER,SET,SIZE,SMALLINT,SOME,SPACE,SQL,SQLCODE,SQLERROR,SQLSTATE,SUBSTRING,SUM,SYSTEM_USER,TABLE,TEMPORARY,THEN,TIME,TIMESTAMP,TIMEZONE_HOUR,TIMEZONE_MINUTE,TO,TRAILING,TRANSACTION,TRANSLATE,TRANSLATION,TRIM,TRUE,UNION,UNIQUE,UNKNOWN,UPDATE,UPPER,USAGE,USER,USING,VALUE,VALUES,VARCHAR,VARYING,VIEW,WHEN,WHENEVER,WHERE,WITH,WORK,WRITE,YEAR,ZONE,ADA,C,CATALOG_NAME,CHARACTER_SET_CATALOG,CHARACTER_SET_NAME,CHARACTER_SET_SCHEMA,CLASS_ORIGIN,COBOL,COLLATION_CATALOG,COLLATION_NAME,COLLATION_SCHEMA,COLUMN_NAME,COMMAND_FUNCTION,COMMITTED,CONDITION_NUMBER,CONNECTION_NAME,CONSTRAINT_CATALOG,CONSTRAINT_NAME,CONSTRAINT_SCHEMA,CURSOR_NAME,DATA,DATETIME_INTERVAL_CODE,DATETIME_INTERVAL_PRECISION,DYNAMIC_FUNCTION,FORTRAN,LENGTH,MESSAGE_LENGTH,MESSAGE_OCTET_LENGTH,MESSAGE_TEXT,MORE,MUMPS,NAME,NULLABLE,NUMBER,PASCAL,PLI,REPEATABLE,RETURNED_LENGTH,RETURNED_OCTET_LENGTH,RETURNED_SQLSTATE,ROW_COUNT,SCALE,SCHEMA_NAME,SERIALIZABLE,SERVER_NAME,SUBCLASS_ORIGIN,TABLE_NAME,TYPE,UNCOMMITTED,UNNAMED"},{"sha":"2e33d487b0565e8ea7c4c7569389b962cec501e5","filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","status":"modified","additions":4,"deletions":8,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -122,8 +122,7 @@ public PCClassFileTransformer(MetaDataRepository repos,\n             if (enhancer.run() == PCEnhancer.ENHANCE_NONE)\n                 return null;\n             return enhancer.getBytecode().toByteArray();\n-        }\n-        catch (Throwable t) {\n+        } catch (Throwable t) {\n             _log.warn(_loc.get(\"cft-exception-thrown\", className), t);\n             if (t instanceof RuntimeException)\n                 throw (RuntimeException) t;\n@@ -162,11 +161,9 @@ private Boolean needsEnhance(String clsName, Class redef, byte[] bytes) {\n             if (_repos.getMetaData(c, null, false) != null)\n                 return Boolean.TRUE;\n             return null;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw re;\n-        }\n-        catch (Throwable t) {\n+        } catch (Throwable t) {\n             throw new GeneralException(t);\n         }\n     }\n@@ -217,8 +214,7 @@ private static boolean isEnhanced(byte[] b) {\n                 name = new String(b, entries[utfEntry] + 2, len, \"UTF-8\");\n                 if (\"openjpa/enhance/PersistenceCapable\".equals(name))\n                     return true;\n-            }\n-            catch (UnsupportedEncodingException uee) {\n+            } catch (UnsupportedEncodingException uee) {\n                 throw new ClassFormatError(uee.toString());\n             }\n         }"},{"sha":"6975ff820ec258e869ad7de001e08e904dd1c34f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivations.java","status":"modified","additions":5,"deletions":10,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivations.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivations.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -39,8 +39,7 @@\n         for (int i = 0; i < pdcls.length; i++) {\n             try {\n                 derivations.add(pdcls[i].newInstance());\n-            }\n-            catch (Throwable t) {\n+            } catch (Throwable t) {\n                 // invalid service\n             }\n         }\n@@ -57,8 +56,7 @@ public static void beforeConfigurationConstruct(ConfigurationProvider cp) {\n         for (int i = 0; i < _derivations.length; i++) {\n             try {\n                 _derivations[i].beforeConfigurationConstruct(cp);\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 // can't log; no configuration yet\n                 e.printStackTrace();\n             }\n@@ -73,8 +71,7 @@ public static void beforeConfigurationLoad(OpenJPAConfiguration conf) {\n         for (int i = 0; i < _derivations.length; i++) {\n             try {\n                 _derivations[i].beforeConfigurationLoad(conf);\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 // logging not configured yet\n                 e.printStackTrace();\n             }\n@@ -89,8 +86,7 @@ public static void afterSpecificationSet(OpenJPAConfiguration conf) {\n         for (int i = 0; i < _derivations.length; i++) {\n             try {\n                 _derivations[i].afterSpecificationSet(conf);\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 // logging not configured yet\n                 e.printStackTrace();\n             }\n@@ -105,8 +101,7 @@ public static void afterClose(OpenJPAConfigurationImpl impl) {\n         for (int i = 0; i < _derivations.length; i++) {\n             try {\n                 _derivations[i].afterClose(impl);\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 // logging not available\n                 e.printStackTrace();\n             }"},{"sha":"2c52071ec2dae52205c0a23623b0666a591252e6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -421,8 +421,7 @@ protected void fireEvent(Object event, Object listener) {\n         ExpirationEvent ev = (ExpirationEvent) event;\n         try {\n             listen.onExpire(ev);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             if (log.isWarnEnabled())\n                 log.warn(s_loc.get (\"exp-listener-ex\"), e);\n \t\t}"},{"sha":"f87ef9aa559ab1e346a7ec4062c438ab3cf6e138","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -72,8 +72,7 @@ public void onTypesChanged(TypesChangedEvent ev) {\n             if (hasListeners())\n                 fireEvent(ev);\n             keys = keySet();\n-        }\n-        finally {\n+        } finally {\n             writeUnlock();\n         }\n \n@@ -303,8 +302,7 @@ protected void fireEvent(Object event, Object listener) {\n         TypesChangedEvent ev = (TypesChangedEvent) event;\n         try {\n             listen.onTypesChanged(ev);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             if (log.isWarnEnabled())\n                 log.warn(s_loc.get(\"exp-listener-ex\"), e);\n         }"},{"sha":"8fb09bc3c4422876f6c434152b27fec054a2d698","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -46,8 +46,7 @@ static Set addTypesByName(OpenJPAConfiguration conf,\n                 if (classes == null)\n                     classes = new HashSet();\n                 classes.add(cls);\n-            }\n-            catch (Throwable t) {\n+            } catch (Throwable t) {\n                 conf.getLog(OpenJPAConfiguration.LOG_RUNTIME).warn(t, t);\n             }\n         }"},{"sha":"96e2832df90872e9086b66e9fb4d7350a5860ccc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","status":"modified","additions":3,"deletions":6,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -137,8 +137,7 @@ public void run() {\n                     }\n                 }\n                 lastRun = now;\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 throw new InvalidStateException(_loc.get(\"scheduler-fail\"), e).\n                     setFatal(true);\n             }\n@@ -185,8 +184,7 @@ public Schedule(String date) {\n                 dayOfMonth = parse(token.nextToken(), 1, 31);\n                 month = parse(token.nextToken(), 1, 13);\n                 dayOfWeek = parse(token.nextToken(), 1, 8);\n-            }\n-            catch (Throwable t) {\n+            } catch (Throwable t) {\n                 throw new UserException(_loc.get(\"bad-schedule\", date), t).\n                     setFatal(true);\n             }\n@@ -200,8 +198,7 @@ public Schedule(String date) {\n             for (int i = 0; i < tokens.length; i++) {\n                 try {\n                     times[i] = Integer.parseInt(tokens[i]);\n-                }\n-                catch (Throwable t) {\n+                } catch (Throwable t) {\n                     throw new UserException(_loc.get(\"not-number\", token)).\n                         setFatal(true);\n                 }"},{"sha":"8481cc7cab9662389102133973399b14b801a571","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","status":"modified","additions":6,"deletions":12,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -84,8 +84,7 @@ public void commit() {\n         try {\n             super.commit();\n             updateCaches();\n-        }\n-        finally {\n+        } finally {\n             _inserts = null;\n             _updates = null;\n             _deletes = null;\n@@ -95,8 +94,7 @@ public void commit() {\n     public void rollback() {\n         try {\n             super.rollback();\n-        }\n-        finally {\n+        } finally {\n             _inserts = null;\n             _updates = null;\n             _deletes = null;\n@@ -220,8 +218,7 @@ private void updateCaches() {\n                     transformToVersionSafePCDatas(cache, mods.existingUpdates);\n                     cache.commit(mods.additions, mods.newUpdates,\n                         mods.existingUpdates, mods.deletes);\n-                }\n-                finally {\n+                } finally {\n                     cache.writeUnlock();\n                 }\n             }\n@@ -357,8 +354,7 @@ public boolean initialize(OpenJPAStateManager sm, PCState state,\n                 data = newPCData(sm);\n             data.store(sm);\n             cache.put(data);\n-        }\n-        finally {\n+        } finally {\n             cache.writeUnlock();\n         }\n         return true;\n@@ -405,8 +401,7 @@ public boolean load(OpenJPAStateManager sm, BitSet fields,\n                 cache.put(data);\n             else\n                 cache.update(data);\n-        }\n-        finally {\n+        } finally {\n             cache.writeUnlock();\n         }\n         return true;\n@@ -499,8 +494,7 @@ public Collection loadAll(Collection sms, PCState state, int load,\n                     cache.put(data);\n                 else\n                     cache.update(data);\n-            }\n-            finally {\n+            } finally {\n                 cache.writeUnlock();\n             }\n         }"},{"sha":"f47a764332c60039e953310e9fd976513ecb03b8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java","status":"modified","additions":22,"deletions":44,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -95,8 +95,7 @@ public String getName() {\n             return null;\n         try {\n             return _cache.getName();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -106,8 +105,7 @@ public void setName(String name) {\n             return;\n         try {\n             _cache.setName(name);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -117,8 +115,7 @@ public void initialize(DataCacheManager manager) {\n             return;\n         try {\n             _cache.initialize(manager);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -129,8 +126,7 @@ public void commit(Collection additions, Collection newUpdates,\n             return;\n         try {\n             _cache.commit(additions, newUpdates, existingUpdates, deletes);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -140,8 +136,7 @@ public boolean contains(Object oid) {\n             return false;\n         try {\n             return _cache.contains(oid);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -151,8 +146,7 @@ public BitSet containsAll(Collection oids) {\n             return EMPTY_BITSET;\n         try {\n             return _cache.containsAll(oids);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -162,8 +156,7 @@ public DataCachePCData get(Object oid) {\n             return null;\n         try {\n             return _cache.get(oid);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -173,8 +166,7 @@ public DataCachePCData put(DataCachePCData value) {\n             return null;\n         try {\n             return _cache.put(value);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -184,8 +176,7 @@ public void update(DataCachePCData value) {\n             return;\n         try {\n             _cache.update(value);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -195,8 +186,7 @@ public DataCachePCData remove(Object oid) {\n             return null;\n         try {\n             return _cache.remove(oid);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -206,8 +196,7 @@ public BitSet removeAll(Collection oids) {\n             return EMPTY_BITSET;\n         try {\n             return _cache.removeAll(oids);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -217,8 +206,7 @@ public void removeAll(Class cls, boolean subclasses) {\n             return;\n         try {\n             _cache.removeAll(cls, subclasses);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -228,8 +216,7 @@ public void clear() {\n             return;\n         try {\n             _cache.clear();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -239,8 +226,7 @@ public boolean pin(Object oid) {\n             return false;\n         try {\n             return _cache.pin(oid);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -250,8 +236,7 @@ public BitSet pinAll(Collection oids) {\n             return EMPTY_BITSET;\n         try {\n             return _cache.pinAll(oids);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -261,8 +246,7 @@ public boolean unpin(Object oid) {\n             return false;\n         try {\n             return _cache.unpin(oid);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -272,8 +256,7 @@ public BitSet unpinAll(Collection oids) {\n             return EMPTY_BITSET;\n         try {\n             return _cache.unpinAll(oids);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -283,8 +266,7 @@ public void writeLock() {\n             return;\n         try {\n             _cache.writeLock();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -294,8 +276,7 @@ public void writeUnlock() {\n             return;\n         try {\n             _cache.writeUnlock();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -305,8 +286,7 @@ public void addExpirationListener(ExpirationListener listen) {\n             return;\n         try {\n             _cache.addExpirationListener(listen);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -316,8 +296,7 @@ public boolean removeExpirationListener(ExpirationListener listen) {\n             return false;\n         try {\n             return _cache.removeExpirationListener(listen);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -327,8 +306,7 @@ public void close() {\n             return;\n         try {\n             _cache.close();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n \t\t}\n \t}"},{"sha":"885a680f586c77c08f056988d34633e469282d42","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java","status":"modified","additions":13,"deletions":26,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -89,8 +89,7 @@ public void initialize(DataCacheManager mgr) {\n             return;\n         try {\n             _cache.initialize(mgr);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -100,8 +99,7 @@ public void onTypesChanged(TypesChangedEvent e) {\n             return;\n         try {\n             _cache.onTypesChanged(e);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -111,8 +109,7 @@ public QueryResult get(QueryKey qk) {\n             return null;\n         try {\n             return _cache.get(qk);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -122,8 +119,7 @@ public QueryResult put(QueryKey qk, QueryResult oids) {\n             return null;\n         try {\n             return _cache.put(qk, oids);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -133,8 +129,7 @@ public QueryResult remove(QueryKey qk) {\n             return null;\n         try {\n             return _cache.remove(qk);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -144,8 +139,7 @@ public void clear() {\n             return;\n         try {\n             _cache.clear();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -155,8 +149,7 @@ public boolean pin(QueryKey qk) {\n             return false;\n         try {\n             return _cache.pin(qk);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -166,8 +159,7 @@ public boolean unpin(QueryKey qk) {\n             return false;\n         try {\n             return _cache.unpin(qk);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -177,8 +169,7 @@ public void writeLock() {\n             return;\n         try {\n             _cache.writeLock();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -188,8 +179,7 @@ public void writeUnlock() {\n             return;\n         try {\n             _cache.writeUnlock();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -199,8 +189,7 @@ public void addTypesChangedListener(TypesChangedListener listen) {\n             return;\n         try {\n             _cache.addTypesChangedListener(listen);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -210,8 +199,7 @@ public boolean removeTypesChangedListener(TypesChangedListener listen) {\n             return false;\n         try {\n             return _cache.removeTypesChangedListener(listen);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -221,8 +209,7 @@ public void close() {\n             return;\n         try {\n             _cache.close();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n \t\t}\n \t}"},{"sha":"8fed19c995f444a7995670ebeaecc9591b494a58","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","status":"modified","additions":4,"deletions":8,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -346,35 +346,31 @@ private void clearAccesssPath(StoreQuery q) {\n         public Number executeDelete(StoreQuery q, Object[] params) {\n             try {\n                 return _ex.executeDelete(unwrap(q), params);\n-            }\n-            finally {\n+            } finally {\n                 clearAccesssPath(q);\n             }\n         }\n \n         public Number executeDelete(StoreQuery q, Map params) {\n             try {\n                 return _ex.executeDelete(unwrap(q), params);\n-            }\n-            finally {\n+            } finally {\n                 clearAccesssPath(q);\n             }\n         }\n \n         public Number executeUpdate(StoreQuery q, Object[] params) {\n             try {\n                 return _ex.executeUpdate(unwrap(q), params);\n-            }\n-            finally {\n+            } finally {\n                 clearAccesssPath(q);\n             }\n         }\n \n         public Number executeUpdate(StoreQuery q, Map params) {\n             try {\n                 return _ex.executeUpdate(unwrap(q), params);\n-            }\n-            finally {\n+            } finally {\n                 clearAccesssPath(q);\n             }\n         }"},{"sha":"69eef59455350d66ee4e1d3d488f7d72e03aad93","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java","status":"modified","additions":4,"deletions":8,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -103,8 +103,7 @@ public TransactionManager getTransactionManager()\n         if (WLS != null) {\n             try {\n                 tm = WLS.getTransactionManager();\n-            }\n-            catch (Throwable t) {\n+            } catch (Throwable t) {\n                 errors.add(t);\n             }\n             if (tm != null) {\n@@ -119,8 +118,7 @@ public TransactionManager getTransactionManager()\n             jmr.setTransactionManagerName(JNDI_LOCS[i]);\n             try {\n                 tm = jmr.getTransactionManager();\n-            }\n-            catch (Throwable t) {\n+            } catch (Throwable t) {\n                 errors.add(t);\n             }\n             if (tm != null) {\n@@ -136,8 +134,7 @@ public TransactionManager getTransactionManager()\n             imr.setTransactionManagerMethod(METHODS[i]);\n             try {\n                 tm = imr.getTransactionManager();\n-            }\n-            catch (Throwable t) {\n+            } catch (Throwable t) {\n                 errors.add(t);\n             }\n             if (tm != null) {\n@@ -149,8 +146,7 @@ public TransactionManager getTransactionManager()\n         if (SUNONE != null) {\n             try {\n                 tm = SUNONE.getTransactionManager();\n-            }\n-            catch (Throwable t) {\n+            } catch (Throwable t) {\n                 errors.add(t);\n             }\n             if (tm != null) {"},{"sha":"74639edbfea2bf681d24e7e050638210dc4246e5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -49,8 +49,7 @@ public TransactionManager getTransactionManager()\n         Context ctx = new InitialContext();\n         try {\n             return (TransactionManager) ctx.lookup(_tmLoc);\n-        }\n-        finally {\n+        } finally {\n             ctx.close();\n         }\n \t}"},{"sha":"ce7231a7c6f9e13d47a3371c130b50c3e0079615","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -1268,8 +1268,7 @@ public static void main(String[] args)\n         try {\n             if (!run(conf, args, opts))\n                 System.err.println(_loc.get(\"appid-usage\"));\n-        }\n-        finally {\n+        } finally {\n             conf.close();\n         }\n     }\n@@ -1405,8 +1404,7 @@ private static Class loadClass(Class context, String name,\n             loader = Thread.currentThread().getContextClassLoader();\n         try {\n             return Class.forName(name, false, loader);\n-        }\n-        catch (Throwable t) {\n+        } catch (Throwable t) {\n         }\n \n         // create class"},{"sha":"ad74860b2e1bf0fcf1dc4e4d50ce4f975d52aa19","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -166,8 +166,7 @@ protected DynamicStorage createFactory(BCClass bc) {\n                 ((Object[]) null);\n             _project.clear(); // remove old refs\n             return data;\n-        }\n-        catch (Throwable t) {\n+        } catch (Throwable t) {\n             throw new InternalException(\"cons-access\", t).setFatal(true);\n         }\n     }"},{"sha":"ce8dcd1cdb79262e5a2138100aeeedaaca3509c0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","status":"modified","additions":12,"deletions":24,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -304,11 +304,9 @@ public int run() {\n             if (_log.isWarnEnabled())\n                 _log.warn(_loc.get(\"pers-aware\", _pc.getType()));\n             return ENHANCE_AWARE;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new GeneralException(e);\n         }\n     }\n@@ -656,8 +654,7 @@ private ClassMetaData getPersistenceCapableOwner(String fieldName,\n             try {\n                 owner.getDeclaredField(fieldName);\n                 break;\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n             }\n         }\n         if (owner.getName().equals(Object.class.getName()))\n@@ -1646,14 +1643,12 @@ private Boolean usesClassStringIdConstructor() {\n         try {\n             oidType.getConstructor(new Class[]{ Class.class, String.class });\n             return Boolean.TRUE;\n-        }\n-        catch (Throwable t) {\n+        } catch (Throwable t) {\n         }\n         try {\n             oidType.getConstructor(new Class[]{ String.class });\n             return Boolean.FALSE;\n-        }\n-        catch (Throwable t) {\n+        } catch (Throwable t) {\n         }\n         return null;\n     }\n@@ -2045,8 +2040,7 @@ private void addSerializationCode() {\n             try {\n                 uid = Numbers.valueOf(ObjectStreamClass.lookup\n                     (_meta.getDescribedType()).getSerialVersionUID());\n-            }\n-            catch (Throwable t) {\n+            } catch (Throwable t) {\n                 // last-chance catch for bug #283 (which can happen\n                 // in a variety of ClassLoading environments)\n                 _log.warn(_loc.get(\"enhance-uid-access\", _meta), t);\n@@ -2540,11 +2534,9 @@ private Field findDeclaredField(Class cls, String name) {\n \n         try {\n             return cls.getDeclaredField(name);\n-        }\n-        catch (NoSuchFieldException nsfe) {\n+        } catch (NoSuchFieldException nsfe) {\n             return findDeclaredField(cls.getSuperclass(), name);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new GeneralException(e);\n         }\n     }\n@@ -2569,11 +2561,9 @@ private Method findDeclaredMethod(Class cls, String name, Class[] params) {\n \n         try {\n             return cls.getDeclaredMethod(name, params);\n-        }\n-        catch (NoSuchMethodException nsme) {\n+        } catch (NoSuchMethodException nsme) {\n             return findDeclaredMethod(cls.getSuperclass(), name, params);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new GeneralException(e);\n         }\n     }\n@@ -2810,8 +2800,7 @@ private void addAttachDetachCode()\n             try {\n                 addDetachExternalize(parentDetachable,\n                     _meta.usesDetachedState() != Boolean.FALSE);\n-            }\n-            catch (NoSuchMethodException nsme) {\n+            } catch (NoSuchMethodException nsme) {\n                 throw new GeneralException(nsme);\n             }\n         }\n@@ -3376,8 +3365,7 @@ public static void main(String[] args)\n         try {\n             if (!run(conf, args, opts))\n                 System.err.println(_loc.get(\"enhance-usage\"));\n-        }\n-        finally {\n+        } finally {\n             conf.close();\n         }\n     }"},{"sha":"183dc53cfde7fe6852d4861b8a4f74e5f51854da","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -50,8 +50,7 @@ public BeanLifecycleCallbacks(Class cls, Method method, boolean arg) {\n         super(method, arg);\n         try {\n             _listener = cls.newInstance();\n-        }\n-        catch (Throwable t) {\n+        } catch (Throwable t) {\n             throw new UserException(_loc.get(\"bean-constructor\",\n                 cls.getName()), t);\n         }"},{"sha":"147832dcfa74cdcdee7910b62a2b84c6c14b1927","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java","status":"modified","additions":7,"deletions":14,"changes":21,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -118,8 +118,7 @@ public void broadcast(RemoteCommitEvent event) {\n             _publisher.publish(createMessage(event));\n             if (log.isTraceEnabled())\n                 log.trace(s_loc.get(\"jms-sent-update\", _topicName));\n-        }\n-        catch (JMSException jmse) {\n+        } catch (JMSException jmse) {\n             if (log.isWarnEnabled())\n                 log.warn(s_loc.get(\"jms-send-error\", _topicName), jmse);\n         }\n@@ -136,8 +135,7 @@ public void close() {\n         catch (JMSException jmse) {\n             if (log.isWarnEnabled())\n                 log.warn(s_loc.get(\"jms-close-error\", _topicName), jmse);\n-        }\n-        finally {\n+        } finally {\n             _connection = null;\n         }\n     }\n@@ -179,11 +177,9 @@ private void connect() {\n  _connection.setExceptionListener(this);\n  if (log.isInfoEnabled())\n  log.info(s_loc.get(\"jms-start-listener\", _topicName));\n- }\n- catch (OpenJPAException ke) {\n+ } catch (OpenJPAException ke) {\n  throw ke;\n- }\n- catch (Exception e) {\n+ } catch (Exception e) {\n  throw new UserException(s_loc.get(\"jms-provider-config\",\n  _topicName, _tcfName), e).setFatal(true);\n  }\n@@ -209,8 +205,7 @@ public void onMessage(Message m) {\n                 Object o;\n                 try {\n                     o = om.getObject();\n-                }\n-                catch (JMSException jmse) {\n+                } catch (JMSException jmse) {\n                     if (log.isWarnEnabled())\n                         log.warn(s_loc.get(\"jms-receive-error-1\"), jmse);\n                     return;\n@@ -256,14 +251,12 @@ public void onException(JMSException ex) {\n                         String.valueOf(i + 1)));\n                 connect();\n                 connected = true;\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 if (log.isInfoEnabled())\n                     log.info(s_loc.get(\"jms-reconnect-fail\", _topicName), e);\n                 try {\n                     Thread.sleep(1000);\n-                }\n-                catch (InterruptedException ie) {\n+                } catch (InterruptedException ie) {\n                     break;\n                 }\n             }"},{"sha":"c3017bfb8d27d49066fbdeb937173999d1170851","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -316,8 +316,7 @@ private void makeCallbacks(Object source, Object related,\n         for (int i = 0; !_fail && i < callbacks.length; i++) {\n             try {\n                 callbacks[i].makeCallback(source, related, type);\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 exceptions.add(e);\n                 if (failFast)\n                     _fail = true;"},{"sha":"6b9a52cc1c9fd76d12874f965735f4da1a7e7173","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -93,17 +93,15 @@ public String toString() {\n     protected static Method getMethod(Class cls, String method, Class[] args) {\n         try {\n             return cls.getMethod(method, args);\n-        }\n-        catch (Throwable t) {\n+        } catch (Throwable t) {\n             try {\n                 // try again with the declared methods, which will\n                 // check private and protected methods\n                 Method m = cls.getDeclaredMethod(method, args);\n                 if (!m.isAccessible())\n                     m.setAccessible(true);\n                 return m;\n-            }\n-            catch (Throwable t2) {\n+            } catch (Throwable t2) {\n                 throw new UserException(_loc.get(\"method-notfound\",\n                     cls.getName(), method), t);\n             }"},{"sha":"b8b43477d13d3c239f0454ee384a219c8beeddcb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -176,8 +176,7 @@ public void readExternal(ObjectInput in)\n                 _addIds = (Collection) in.readObject();\n             _updates = (Collection) in.readObject();\n             _deletes = (Collection) in.readObject();\n-        }\n-        catch (ClassNotFoundException cnfe) {\n+        } catch (ClassNotFoundException cnfe) {\n             // ### do something\n \t\t}\n \t}"},{"sha":"8f00b0bd2a4b8afd5fc3677f0fb86d6736256bc2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","status":"modified","additions":21,"deletions":42,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -263,8 +263,7 @@ private void acquireWriteLock(\n         edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock lock) {\n         try {\n             lock.writeLock().lockInterruptibly();\n-        }\n-        catch (InterruptedException e) {\n+        } catch (InterruptedException e) {\n         }\n     }\n \n@@ -277,8 +276,7 @@ private void acquireReadLock(\n         edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock lock) {\n         try {\n             lock.readLock().lockInterruptibly();\n-        }\n-        catch (InterruptedException e) {\n+        } catch (InterruptedException e) {\n         }\n     }\n \n@@ -306,8 +304,7 @@ public void endConfiguration() {\n                     _listener = new TCPPortListener(_port, log);\n                     _listener.listen();\n                     s_portListenerMap.put(String.valueOf(_port), _listener);\n-                }\n-                catch (Exception e) {\n+                } catch (Exception e) {\n                     throw new GeneralException(s_loc.get(\"tcp-init-exception\",\n                         String.valueOf(_port)), e).setFatal(true);\n                 }\n@@ -364,8 +361,7 @@ public void broadcast(RemoteCommitEvent event) {\n                 sendUpdatePacket(bytes);\n             else\n                 _broadcastQueue.addPacket(bytes);\n-        }\n-        catch (IOException ioe) {\n+        } catch (IOException ioe) {\n             if (log.isWarnEnabled())\n                 log.warn(s_loc.get(\"tcp-payload-create-error\"), ioe);\n         }\n@@ -380,8 +376,7 @@ private void sendUpdatePacket(byte[] bytes) {\n         try {\n             for (Iterator iter = _addresses.iterator(); iter.hasNext();)\n                 ((HostAddress) iter.next()).sendUpdatePacket(bytes);\n-        }\n-        finally {\n+        } finally {\n             releaseReadLock(_addressesLock);\n         }\n     }\n@@ -394,8 +389,7 @@ public void close() {\n         try {\n             for (Iterator iter = _addresses.iterator(); iter.hasNext();)\n                 ((HostAddress) iter.next()).close();\n-        }\n-        finally {\n+        } finally {\n             releaseWriteLock(_addressesLock);\n         }\n \n@@ -446,8 +440,7 @@ public void run() {\n                     // This will block until there is a packet to send.\n                     byte[] bytes = _broadcastQueue.removePacket();\n                     sendUpdatePacket(bytes);\n-                }\n-                catch (InterruptedException e) {\n+                } catch (InterruptedException e) {\n                     // End the thread.\n                     break;\n                 }\n@@ -539,8 +532,7 @@ private void addProvider(TCPRemoteCommitProvider provider) {\n                     _isRunning = false;\n                     try {\n                         _receiveSocket.close();\n-                    }\n-                    catch (IOException ioe) {\n+                    } catch (IOException ioe) {\n                         if (_log.isWarnEnabled())\n                             _log.warn(s_loc.get(\"tcp-close-error\"), ioe);\n                     }\n@@ -576,8 +568,7 @@ public void run() {\n                     receiverThread.setDaemon(true);\n                     receiverThread.start();\n                     _receiverThreads.add(receiverThread);\n-                }\n-                catch (Exception e) {\n+                } catch (Exception e) {\n                     if (!(e instanceof SocketException) || _isRunning)\n                         if (_log.isWarnEnabled())\n                             _log.warn(s_loc.get(\"tcp-accept-error\"), e);\n@@ -587,8 +578,7 @@ public void run() {\n                     try {\n                         if (s != null)\n                             s.close();\n-                    }\n-                    catch (Exception ee) {\n+                    } catch (Exception ee) {\n                         if (_log.isWarnEnabled())\n                             _log.warn(s_loc.get(\"tcp-close-error\"), e);\n                     }\n@@ -611,8 +601,7 @@ public void run() {\n                 try {\n                     if (_isRunning)\n                         _receiveSocket.close();\n-                }\n-                catch (Exception e) {\n+                } catch (Exception e) {\n                     if (_log.isWarnEnabled())\n                         _log.warn(s_loc.get(\"tcp-close-error\"), e);\n                 }\n@@ -641,13 +630,11 @@ private ReceiveSocketHandler(Socket s) {\n                 try {\n                     _s.setTcpNoDelay(true);\n                     _in = new BufferedInputStream(s.getInputStream());\n-                }\n-                catch (IOException ioe) {\n+                } catch (IOException ioe) {\n                     if (_log.isInfoEnabled())\n                         _log.info(s_loc.get(\"tcp-socket-option-error\"), ioe);\n                     _s = null;\n-                }\n-                catch (Exception e) {\n+                } catch (Exception e) {\n                     if (_log.isWarnEnabled())\n                         _log.warn(s_loc.get(\"tcp-receive-error\"), e);\n                     _s = null;\n@@ -662,8 +649,7 @@ public void run() {\n                         // This will block our thread, waiting to read\n                         // the next Event-object-message.\n                         handle(_in);\n-                    }\n-                    catch (EOFException eof) {\n+                    } catch (EOFException eof) {\n                         // EOFException raised when peer is properly\n                         // closing its end.\n                         if (_log.isTraceEnabled()) {\n@@ -672,22 +658,19 @@ public void run() {\n                                     + \":\" + _s.getPort()));\n                         }\n                         break;\n-                    }\n-                    catch (Exception e) {\n+                    } catch (Exception e) {\n                         if (_log.isWarnEnabled())\n                             _log.warn(s_loc.get(\"tcp-receive-error\"), e);\n                         break;\n-                    }\n-                    catch (Throwable t) {\n+                    } catch (Throwable t) {\n                     }\n                 }\n                 // We are done receiving on this socket and this worker\n                 // thread is terminating.\n                 try {\n                     _in.close();\n                     _s.close();\n-                }\n-                catch (Exception e) {\n+                } catch (Exception e) {\n                     _log.warn(s_loc.get(\"tcp-close-socket-error\",\n                         _s.getInetAddress().getHostAddress() + \":\"\n                             + _s.getPort()), e);\n@@ -790,8 +773,7 @@ public void close() {\n             // will close all sockets in the pool.\n             try {\n                 _socketPool.close();\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 if (log.isWarnEnabled()) {\n                     log.warn(s_loc.get(\"tcp-close-pool-error\"), e);\n                 }\n@@ -822,8 +804,7 @@ private void sendUpdatePacket(byte[] bytes) {\n                 // Return the socket to the pool; the socket is\n                 // still good.\n                 returnSocket(s);\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 // There has been a problem sending to the peer.\n                 // The OS socket that was being used is can no longer\n                 // be used.\n@@ -882,8 +863,7 @@ private void closeSocket(Socket s) {\n             // pool.\n             try {\n                 _socketPool.invalidateObject(s);\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n             }\n         }\n \n@@ -911,8 +891,7 @@ public void destroyObject(Object obj) {\n                         log.trace(s_loc.get(\"tcp-close-sending-socket\",\n                             _address + \":\" + _port, \"\" + s.getLocalPort()));\n                     s.close();\n-                }\n-                catch (Exception e) {\n+                } catch (Exception e) {\n                     log.warn(s_loc.get(\"tcp-close-socket-error\",\n                         _address.getHostAddress() + \":\" + _port), e);\n                 }"},{"sha":"d8a4f1db62ede32315bd647176f5cfdf0a727ee0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"modified","additions":14,"deletions":28,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -177,14 +177,11 @@ public Broker newBroker(String user, String pass, boolean managed,\n             _brokers.add(broker);\n \n             return broker;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -237,8 +234,7 @@ private void loadPersistentTypes(ClassLoader envLoader) {\n             for (Iterator itr = _pcClassNames.iterator(); itr.hasNext();) {\n                 try {\n                     Class.forName((String) itr.next(), true, loader);\n-                }\n-                catch (Throwable t) {\n+                } catch (Throwable t) {\n                     _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME).warn(t, t);\n                 }\n             }\n@@ -252,8 +248,7 @@ public void addLifecycleListener(Object listener, Class[] classes) {\n             if (_lifecycleListeners == null)\n                 _lifecycleListeners = new HashMap(7);\n             _lifecycleListeners.put(listener, classes);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -264,8 +259,7 @@ public void removeLifecycleListener(Object listener) {\n             assertOpen();\n             if (_lifecycleListeners != null)\n                 _lifecycleListeners.remove(listener);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -304,8 +298,7 @@ public void close() {\n \n             _conf.close();\n             _closed = new IllegalStateException();\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -329,8 +322,7 @@ public Object getUserObject(Object key) {\n         try {\n             assertOpen();\n             return (_userObjects == null) ? null : _userObjects.get(key);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -345,8 +337,7 @@ public Object putUserObject(Object key, Object val) {\n             if (_userObjects == null)\n                 _userObjects = new HashMap();\n             return _userObjects.put(key, val);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -444,11 +435,9 @@ protected BrokerImpl findTransactionalBroker(String user, String pass) {\n                 || trans.getStatus() == Status.STATUS_NO_TRANSACTION\n                 || trans.getStatus() == Status.STATUS_UNKNOWN)\n                 return null;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new GeneralException(e);\n         }\n \n@@ -543,8 +532,7 @@ public void makeReadOnly() {\n             // avoid synchronization\n             _conf.setReadOnly(true);\n             _conf.instantiateAll();\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -631,11 +619,9 @@ boolean syncWithManagedTransaction(BrokerImpl broker, boolean begin) {\n             }\n \n             return true;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new GeneralException(e);\n         }\n     }"},{"sha":"ac0d14db1ff68a34df8ad6115e03ede61512dd1f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","status":"modified","additions":5,"deletions":10,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -95,12 +95,10 @@ public Object attach(Object pc) {\n         CallbackException excep = null;\n         try {\n             return attach(pc, null, null, null);\n-        }\n-        catch (CallbackException ce) {\n+        } catch (CallbackException ce) {\n             excep = ce;\n             return null; // won't be reached as the exceps will be rethrown\n-        }\n-        finally {\n+        } finally {\n             List exceps = null;\n             if (excep == null || !_failFast)\n                 exceps = invokeAfterAttach(null);\n@@ -125,8 +123,7 @@ public Object attach(Object pc) {\n             for (Iterator itr = instances.iterator(); itr.hasNext(); i++) {\n                 try {\n                     attached[i] = attach(itr.next(), null, null, null);\n-                }\n-                catch (OpenJPAException ke) {\n+                } catch (OpenJPAException ke) {\n                     // track exceptions and optimistic failed objects\n                     if (opt && !(ke instanceof OptimisticException))\n                         opt = false;\n@@ -143,8 +140,7 @@ public Object attach(Object pc) {\n                     exceps = add(exceps, re);\n                 }\n             }\n-        }\n-        finally {\n+        } finally {\n             // invoke post callbacks unless all failed\n             if (!failFast && (exceps == null\n                 || exceps.size() < instances.size()))\n@@ -171,8 +167,7 @@ private List invokeAfterAttach(List exceps) {\n             try {\n                 _broker.fireLifecycleEvent(attached, entry.getKey(),\n                     sm.getMetaData(), LifecycleEvent.AFTER_ATTACH);\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 exceps = add(exceps, re);\n                 if (_failFast && re instanceof CallbackException)\n                     break;"},{"sha":"06ea2b9d0397872c71b91ad66fcd3dcdff035a99","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java","status":"modified","additions":5,"deletions":10,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -61,15 +61,13 @@ public static BrokerFactory newBrokerFactory(ConfigurationProvider conf,\n         try {\n             Method meth = cls.getMethod(\"newInstance\", FACTORY_ARGS);\n             return (BrokerFactory) meth.invoke(null, new Object[]{ conf });\n-        }\n-        catch (InvocationTargetException ite) {\n+        } catch (InvocationTargetException ite) {\n             Throwable cause = ite.getTargetException();\n             if (cause instanceof OpenJPAException)\n                 throw (OpenJPAException) cause;\n             throw new InternalException(s_loc.get(\"new-brokerfactory-excep\",\n                 cls), cause);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new UserException(s_loc.get(\"bad-new-brokerfactory\", cls),\n                 e).setFatal(true);\n         }\n@@ -97,15 +95,13 @@ public static BrokerFactory getBrokerFactory(ConfigurationProvider conf,\n         try {\n             Method meth = cls.getMethod(\"getInstance\", FACTORY_ARGS);\n             return (BrokerFactory) meth.invoke(null, new Object[]{ conf });\n-        }\n-        catch (InvocationTargetException ite) {\n+        } catch (InvocationTargetException ite) {\n             Throwable cause = ite.getTargetException();\n             if (cause instanceof OpenJPAException)\n                 throw (OpenJPAException) cause;\n             throw new InternalException(s_loc.get(\"brokerfactory-excep\", cls),\n                 cause);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new UserException(s_loc.get(\"bad-brokerfactory\", cls), e).\n                 setFatal(true);\n         }\n@@ -132,8 +128,7 @@ private static Class getFactoryClass(ConfigurationProvider conf,\n \n         try {\n             return Class.forName(clsName, true, loader);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new UserException(s_loc.get(\"bad-brokerfactory-class\",\n                 clsName), e).setFatal(true);\n \t\t}"},{"sha":"5e9449f7e25d55b8b630f00b39dfcbd645c76c95","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":173,"deletions":346,"changes":519,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -582,8 +582,7 @@ public Object getUserObject(Object key) {\n         beginOperation(false);\n         try {\n             return (_userObjects == null) ? null : _userObjects.get(key);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -597,8 +596,7 @@ public Object putUserObject(Object key, Object val) {\n             if (_userObjects == null)\n                 _userObjects = new HashMap();\n             return _userObjects.put(key, val);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -611,8 +609,7 @@ public void addLifecycleListener(Object listener, Class[] classes) {\n         beginOperation(false);\n         try {\n             _lifeEventManager.addListener(listener, classes);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -621,8 +618,7 @@ public void removeLifecycleListener(Object listener) {\n         beginOperation(false);\n         try {\n             _lifeEventManager.removeListener(listener);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -673,8 +669,7 @@ public void addTransactionListener(Object tl) {\n             _transEventManager.addListener(tl);\n             if (tl instanceof RemoteCommitEventManager)\n                 _flags |= FLAG_REMOTE_LISTENER;\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -686,8 +681,7 @@ public void removeTransactionListener(Object tl) {\n                 && _transEventManager.removeListener(tl)\n                 && (tl instanceof RemoteCommitEventManager))\n                 _flags &= ~FLAG_REMOTE_LISTENER;\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -748,8 +742,7 @@ protected Object find(Object oid, FetchState fetchState, BitSet exclude,\n                             loaded = sm.load(fetchState,\n                                 StateManagerImpl.LOAD_FGS, exclude, edata,\n                                 false);\n-                        }\n-                        catch (ObjectNotFoundException onfe) {\n+                        } catch (ObjectNotFoundException onfe) {\n                             if ((flags & OID_NODELETED) != 0\n                                 || (flags & OID_NOVALIDATE) != 0)\n                                 throw onfe;\n@@ -803,23 +796,19 @@ protected Object find(Object oid, FetchState fetchState, BitSet exclude,\n                 try {\n                     sm.load(fetchState, StateManagerImpl.LOAD_FGS, exclude,\n                         edata, false);\n-                }\n-                catch (ObjectNotFoundException onfe) {\n+                } catch (ObjectNotFoundException onfe) {\n                     if ((flags & OID_NODELETED) != 0\n                         || (flags & OID_NOVALIDATE) != 0)\n                         throw onfe;\n                     return call.processReturn(oid, null);\n                 }\n             }\n             return call.processReturn(oid, sm);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -841,8 +830,7 @@ protected StateManagerImpl initialize(StateManagerImpl sm, boolean load,\n             try {\n                 if (!_store.initialize(sm, state, fetchState, edata))\n                     return null;\n-            }\n-            finally {\n+            } finally {\n                 sm.setLoading(false);\n             }\n         }\n@@ -966,14 +954,11 @@ protected StateManagerImpl initialize(StateManagerImpl sm, boolean load,\n                 results[idx] = call.processReturn(oid, sm);\n             }\n             return results;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             _loading = null;\n             endOperation();\n         }\n@@ -1017,8 +1002,7 @@ public Object findCached(Object oid, FindCallbacks call) {\n         try {\n             StateManagerImpl sm = getStateManagerImplById(oid, true);\n             return call.processReturn(oid, sm);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1038,14 +1022,11 @@ public Class getObjectIdType(Class cls) {\n                 return meta.getObjectIdType();\n \n             return _store.getDataStoreIdType(meta);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1089,18 +1070,14 @@ public Object newObjectId(Class cls, Object val) {\n             Object[] arr = (val instanceof Object[]) ? (Object[]) val\n                 : new Object[]{ val };\n             return ApplicationIds.fromPKValues(arr, meta);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (ClassCastException cce) {\n+        } catch (ClassCastException cce) {\n             throw new UserException(_loc.get(\"bad-id-value\", val,\n                 val.getClass().getName(), cls)).setCause(cce);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1160,8 +1137,7 @@ public void begin() {\n                 throw new InvalidStateException(_loc.get(\"active\"));\n             _factory.syncWithManagedTransaction(this, true);\n             beginInternal();\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1186,14 +1162,12 @@ private void beginInternal() {\n                 && _transEventManager.hasBeginListeners())\n                 _transEventManager.fireEvent(new TransactionEvent(this,\n                     TransactionEvent.AFTER_BEGIN, null, null, null, null));\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             // if we already started the transaction, don't let it commit\n             if ((_flags & FLAG_ACTIVE) != 0)\n                 setRollbackOnlyInternal();\n             throw ke.setFatal(true);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             // if we already started the transaction, don't let it commit\n             if ((_flags & FLAG_ACTIVE) != 0)\n                 setRollbackOnlyInternal();\n@@ -1218,14 +1192,11 @@ public void beginStore() {\n             assertTransactionOperation();\n             if ((_flags & FLAG_STORE_ACTIVE) == 0)\n                 beginStoreManagerTransaction(false);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new StoreException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1275,16 +1246,14 @@ private RuntimeException endStoreManagerTransaction(boolean rollback) {\n                 }\n             }\n             err = re;\n-        }\n-        finally {\n+        } finally {\n             _flags &= ~FLAG_STORE_ACTIVE;\n         }\n \n         if (releaseConn) {\n             try {\n                 releaseConnection();\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 if (err == null)\n                     err = re;\n             }\n@@ -1308,18 +1277,15 @@ public void commit() {\n             // this commit on the transaction will cause our\n             // beforeCompletion method to be invoked\n             trans.commit();\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             if (_log.isTraceEnabled())\n                 _log.trace(_loc.get(\"end-trans-error\"), ke);\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             if (_log.isTraceEnabled())\n                 _log.trace(_loc.get(\"end-trans-error\"), e);\n             throw new StoreException(e);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1333,18 +1299,15 @@ public void rollback() {\n                 _runtime.getTransactionManager().getTransaction();\n             if (trans != null)\n                 trans.rollback();\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             if (_log.isTraceEnabled())\n                 _log.trace(_loc.get(\"end-trans-error\"), ke);\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             if (_log.isTraceEnabled())\n                 _log.trace(_loc.get(\"end-trans-error\"), e);\n             throw new StoreException(e);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1362,8 +1325,7 @@ public boolean syncWithManagedTransaction() {\n                 return true;\n             }\n             return false;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1384,8 +1346,7 @@ private void endAndResume(boolean commit) {\n             else\n                 rollback();\n             begin();\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1401,14 +1362,11 @@ public boolean getRollbackOnly() {\n             if (trans == null)\n                 return false;\n             return trans.getStatus() == Status.STATUS_MARKED_ROLLBACK;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new GeneralException(e);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1418,8 +1376,7 @@ public void setRollbackOnly() {\n         try {\n             assertTransactionOperation();\n             setRollbackOnlyInternal();\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1434,11 +1391,9 @@ private void setRollbackOnlyInternal() {\n             if (trans == null)\n                 throw new InvalidStateException(_loc.get(\"null-trans\"));\n             trans.setRollbackOnly();\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new GeneralException(e);\n         }\n     }\n@@ -1468,14 +1423,11 @@ public void setSavepoint(String name) {\n                 }\n             }\n             _savepoints.put(name, save);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new GeneralException(e);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1487,8 +1439,7 @@ public void releaseSavepoint() {\n                 throw new UserException(_loc.get(\"no-lastsavepoint\"));\n             releaseSavepoint((String) _savepoints.get\n                 (_savepoints.size() - 1));\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1515,14 +1466,11 @@ public void releaseSavepoint(String savepoint) {\n             save.release(true);\n             if (_savepointCache != null)\n                 _savepointCache.clear();\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new GeneralException(e);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1534,8 +1482,7 @@ public void rollbackToSavepoint() {\n                 throw new UserException(_loc.get(\"no-lastsavepoint\"));\n             rollbackToSavepoint((String) _savepoints.get\n                 (_savepoints.size() - 1));\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1598,11 +1545,9 @@ public void rollbackToSavepoint(String savepoint) {\n         }\n         catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new GeneralException(e);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1629,13 +1574,11 @@ public void flush() {\n             try {\n                 flushSafe(FLUSH_INC);\n                 _flags |= FLAG_FLUSHED;\n-            }\n-            catch (OpenJPAException ke) {\n+            } catch (OpenJPAException ke) {\n                 // rollback on flush error; objects may be in inconsistent state\n                 setRollbackOnly();\n                 throw ke.setFatal(true);\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 // rollback on flush error; objects may be in inconsistent state\n                 setRollbackOnly();\n                 throw new StoreException(re).setFatal(true);\n@@ -1651,8 +1594,7 @@ public void preFlush() {\n         try {\n             if ((_flags & FLAG_ACTIVE) != 0)\n                 flushSafe(FLUSH_LOGICAL);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1675,11 +1617,9 @@ public void validateChanges() {\n \n             try {\n                 flushSafe(FLUSH_ROLLBACK);\n-            }\n-            catch (OpenJPAException ke) {\n+            } catch (OpenJPAException ke) {\n                 throw ke;\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 throw new StoreException(re);\n             }\n         }\n@@ -1692,8 +1632,7 @@ public boolean isActive() {\n         beginOperation(true);\n         try {\n             return (_flags & FLAG_ACTIVE) != 0;\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1704,8 +1643,7 @@ public boolean isStoreActive() {\n         beginOperation(true);\n         try {\n             return (_flags & FLAG_STORE_ACTIVE) != 0;\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1719,12 +1657,10 @@ public boolean beginOperation(boolean syncTrans) {\n                 && (_flags & FLAG_ACTIVE) == 0)\n                 syncWithManagedTransaction();\n             return _operationCount++ == 1;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             unlock();\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             unlock();\n             throw new GeneralException(re);\n         }\n@@ -1743,14 +1679,11 @@ public boolean endOperation() {\n             if (_operationCount < 1)\n                 throw new InternalException();\n             return _operationCount == 1;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             _operationCount--;\n             if (_operationCount == 0)\n                 _operating.clear();\n@@ -1779,18 +1712,15 @@ public void beforeCompletion() {\n                 _sync.beforeCompletion();\n \n             flushSafe(FLUSH_COMMIT);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             if (_log.isTraceEnabled())\n                 _log.trace(_loc.get(\"end-trans-error\"), ke);\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             if (_log.isTraceEnabled())\n                 _log.trace(_loc.get(\"end-trans-error\"), re);\n             throw new StoreException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -1813,18 +1743,15 @@ public void afterCompletion(int status) {\n             if ((_flags & FLAG_CLOSE_INVOKED) != 0\n                 && _compat.getCloseOnManagedCommit())\n                 free();\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             if (_log.isTraceEnabled())\n                 _log.trace(_loc.get(\"end-trans-error\"), ke);\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             if (_log.isTraceEnabled())\n                 _log.trace(_loc.get(\"end-trans-error\"), re);\n             throw new StoreException(re);\n-        }\n-        finally {\n+        } finally {\n             _flags &= ~FLAG_ACTIVE;\n             _flags &= ~FLAG_FLUSHED;\n \n@@ -1851,8 +1778,7 @@ private void flushSafe(int reason) {\n         _flags |= FLAG_FLUSHING;\n         try {\n             flush(reason);\n-        }\n-        finally {\n+        } finally {\n             _flags &= ~FLAG_FLUSHING;\n         }\n     }\n@@ -2122,8 +2048,7 @@ protected void endTransaction(int status) {\n \n         try {\n             exceps = add(exceps, endStoreManagerTransaction(rollback));\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             rollback = true;\n             exceps = add(exceps, re);\n         }\n@@ -2186,8 +2111,7 @@ protected void endTransaction(int status) {\n                     sm.rollback();\n                 } else\n                     sm.commit();\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 exceps = add(exceps, re);\n             }\n         }\n@@ -2237,13 +2161,11 @@ public void persistAll(Collection objs, OpCallbacks call) {\n             for (Iterator itr = objs.iterator(); itr.hasNext();) {\n                 try {\n                     persist(itr.next(), call);\n-                }\n-                catch (UserException ue) {\n+                } catch (UserException ue) {\n                     exceps = add(exceps, ue);\n                 }\n             }\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n         throwNestedExceptions(exceps, false);\n@@ -2381,14 +2303,11 @@ else if (meta.getIdentityType() == ClassMetaData.ID_UNKNOWN)\n             if ((action & OpCallbacks.ACT_CASCADE) != 0)\n                 sm.cascadePersist(call);\n             return sm;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -2442,14 +2361,12 @@ public void deleteAll(Collection objs, OpCallbacks call) {\n                     obj = itr.next();\n                     if (obj != null)\n                         delete(obj, getStateManagerImpl(obj, true), call);\n-                }\n-                catch (UserException ue) {\n+                } catch (UserException ue) {\n                     exceps = add(exceps, ue);\n                 }\n             }\n             throwNestedExceptions(exceps, false);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -2462,14 +2379,11 @@ public void delete(Object obj, OpCallbacks call) {\n         try {\n             assertWriteOperation();\n             delete(obj, getStateManagerImpl(obj, true), call);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -2522,14 +2436,12 @@ public void releaseAll(Collection objs, OpCallbacks call) {\n             for (Iterator itr = objs.iterator(); itr.hasNext();) {\n                 try {\n                     release(itr.next(), call);\n-                }\n-                catch (UserException ue) {\n+                } catch (UserException ue) {\n                     exceps = add(exceps, ue);\n                 }\n             }\n             throwNestedExceptions(exceps, false);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -2554,11 +2466,9 @@ public void release(Object obj, OpCallbacks call) {\n         }\n         catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -2619,8 +2529,7 @@ public OpenJPAStateManager embed(Object obj, Object id,\n                     copy.pcCopyFields(pc, fields);\n                     state = PCState.ECOPY;\n                     copy.pcReplaceStateManager(null);\n-                }\n-                finally {\n+                } finally {\n                     // if the instance didn't have a state manager to start,\n                     // revert it to being transient\n                     if (orig == null)\n@@ -2637,14 +2546,11 @@ public OpenJPAStateManager embed(Object obj, Object id,\n \n             sm.initialize(copy, state);\n             return sm;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -2674,8 +2580,7 @@ OpenJPAStateManager copy(OpenJPAStateManager copy, PCState state) {\n                 sm.initialize(sm.getMetaData().getDescribedType(), state);\n             }\n             return sm;\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -2696,8 +2601,7 @@ public void refreshAll(Collection objs, OpCallbacks call) {\n                 refreshInternal(_operating.iterator().next(), call);\n             else\n                 refreshInternal(_operating, call);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -2717,8 +2621,7 @@ public void refresh(Object obj, OpCallbacks call) {\n                 refreshInternal(_operating.iterator().next(), call);\n             else\n                 refreshInternal(_operating, call);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -2777,8 +2680,7 @@ else if (sm.beforeRefresh(true)) {\n                     } else if (assertPersistenceCapable(obj).pcIsDetached()\n                         == Boolean.TRUE)\n                         throw newDetachedException(obj, \"refresh\");\n-                }\n-                catch (OpenJPAException ke) {\n+                } catch (OpenJPAException ke) {\n                     exceps = add(exceps, ke);\n                 }\n             }\n@@ -2801,8 +2703,7 @@ else if (sm.beforeRefresh(true)) {\n                         sm.afterRefresh();\n                         sm.load(_fc.newFetchState(),\n                             StateManagerImpl.LOAD_FGS, null, null, false);\n-                    }\n-                    catch (OpenJPAException ke) {\n+                    } catch (OpenJPAException ke) {\n                         exceps = add(exceps, ke);\n                     }\n                 }\n@@ -2815,16 +2716,13 @@ else if (sm.beforeRefresh(true)) {\n                     if (sm != null && !sm.isDetached())\n                         fireLifecycleEvent(sm.getManagedInstance(), null,\n                             sm.getMetaData(), LifecycleEvent.AFTER_REFRESH);\n-                }\n-                catch (OpenJPAException ke) {\n+                } catch (OpenJPAException ke) {\n                     exceps = add(exceps, ke);\n                 }\n             }\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n         }\n         throwNestedExceptions(exceps, false);\n@@ -2853,11 +2751,9 @@ else if (sm.beforeRefresh(false)) {\n             } else if (assertPersistenceCapable(obj).pcIsDetached()\n                 == Boolean.TRUE)\n                 throw newDetachedException(obj, \"refresh\");\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n         }\n     }\n@@ -2907,8 +2803,7 @@ public void retrieveAll(Collection objs, boolean dfgOnly,\n                     } else if (assertPersistenceCapable(obj).pcIsDetached()\n                         == Boolean.TRUE)\n                         throw newDetachedException(obj, \"retrieve\");\n-                }\n-                catch (UserException ue) {\n+                } catch (UserException ue) {\n                     exceps = add(exceps, ue);\n                 }\n             }\n@@ -2935,19 +2830,15 @@ public void retrieveAll(Collection objs, boolean dfgOnly,\n                 try {\n                     sm.beforeRead(-1);\n                     sm.load(_fc.newFetchState(), mode, null, null, false);\n-                }\n-                catch (OpenJPAException ke) {\n+                } catch (OpenJPAException ke) {\n                     exceps = add(exceps, ke);\n                 }\n             }\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n         throwNestedExceptions(exceps, false);\n@@ -2979,14 +2870,11 @@ public void retrieve(Object obj, boolean dfgOnly, OpCallbacks call) {\n             } else if (assertPersistenceCapable(obj).pcIsDetached()\n                 == Boolean.TRUE)\n                 throw newDetachedException(obj, \"retrieve\");\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3015,13 +2903,11 @@ public void evictAll(Collection objs, OpCallbacks call) {\n             for (Iterator itr = objs.iterator(); itr.hasNext();) {\n                 try {\n                     evict(itr.next(), call);\n-                }\n-                catch (UserException ue) {\n+                } catch (UserException ue) {\n                     exceps = add(exceps, ue);\n                 }\n             }\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n         throwNestedExceptions(exceps, false);\n@@ -3047,8 +2933,7 @@ public void evictAll(Extent extent, OpCallbacks call) {\n                         evict(sm.getManagedInstance(), call);\n                 }\n             }\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3075,11 +2960,9 @@ public void evict(Object obj, OpCallbacks call) {\n         }\n         catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3093,14 +2976,11 @@ public Object detach(Object obj, OpCallbacks call) {\n         beginOperation(true);\n         try {\n             return new DetachManager(this, false, call).detach(obj);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3116,14 +2996,11 @@ public Object detach(Object obj, OpCallbacks call) {\n         beginOperation(true);\n         try {\n             return new DetachManager(this, false, call).detachAll(objs);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3134,14 +3011,11 @@ public void detachAll(OpCallbacks call) {\n             if ((_flags & FLAG_FLUSH_REQUIRED) != 0)\n                 flush();\n             detachAllInternal(call);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3178,15 +3052,12 @@ public Object attach(Object obj, boolean copyNew, OpCallbacks call) {\n             assertWriteOperation();\n             try {\n                 return new AttachManager(this, copyNew, call).attach(obj);\n-            }\n-            catch (OptimisticException oe) {\n+            } catch (OptimisticException oe) {\n                 setRollbackOnly();\n                 throw oe.setFatal(true);\n-            }\n-            catch (OpenJPAException ke) {\n+            } catch (OpenJPAException ke) {\n                 throw ke;\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 throw new GeneralException(re);\n             }\n         }\n@@ -3208,15 +3079,12 @@ public Object attach(Object obj, boolean copyNew, OpCallbacks call) {\n             assertWriteOperation();\n             try {\n                 return new AttachManager(this, copyNew, call).attachAll(objs);\n-            }\n-            catch (OptimisticException oe) {\n+            } catch (OptimisticException oe) {\n                 setRollbackOnly();\n                 throw oe.setFatal(true);\n-            }\n-            catch (OpenJPAException ke) {\n+            } catch (OpenJPAException ke) {\n                 throw ke;\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 throw new GeneralException(re);\n             }\n         }\n@@ -3232,14 +3100,12 @@ public void nontransactionalAll(Collection objs, OpCallbacks call) {\n             for (Iterator itr = objs.iterator(); itr.hasNext();) {\n                 try {\n                     nontransactional(itr.next(), call);\n-                }\n-                catch (UserException ue) {\n+                } catch (UserException ue) {\n                     exceps = add(exceps, ue);\n                 }\n             }\n             throwNestedExceptions(exceps, false);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3256,14 +3122,11 @@ public void nontransactional(Object obj, OpCallbacks call) {\n                 return;\n             if (sm != null)\n                 sm.nontransactional();\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3341,14 +3204,11 @@ public void transactionalAll(Collection objs, boolean updateVersion,\n             }\n \n             transactionalStatesAll(sms, failed, exceps);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3389,11 +3249,9 @@ public void transactional(Object obj, boolean updateVersion,\n         }\n         catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3414,8 +3272,7 @@ private void transactionalStatesAll(Collection sms, Collection failed,\n                 sm.transactional();\n                 sm.load(_fc.newFetchState(), StateManagerImpl.LOAD_FGS, null,\n                     null, false);\n-            }\n-            catch (OpenJPAException ke) {\n+            } catch (OpenJPAException ke) {\n                 exceps = add(exceps, ke);\n             }\n         }\n@@ -3440,14 +3297,11 @@ private Extent newExtent(Class type, boolean subclasses,\n             _extents.add(extent);\n \n             return extent;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3494,14 +3348,11 @@ else if (QueryLanguages.LANG_METHODQL.equals(language))\n                 _queries = new ReferenceHashSet(ReferenceHashSet.WEAK);\n             _queries.add(q);\n             return q;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3569,8 +3420,7 @@ public void lock(Object obj, OpCallbacks call) {\n         beginOperation(true); // have to sync or lock level always NONE\n         try {\n             lock(obj, _fc.getWriteLockLevel(), _fc.getLockTimeout(), call);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3592,14 +3442,11 @@ public void lock(Object obj, int level, int timeout, OpCallbacks call) {\n \n             _lm.lock(sm, level, timeout, null);\n             sm.readLocked(level, level); // use same level for future write\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3612,8 +3459,7 @@ public void lockAll(Collection objs, OpCallbacks call) {\n         try {\n             lockAll(objs, _fc.getWriteLockLevel(), _fc.getLockTimeout(),\n                 call);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3650,14 +3496,11 @@ public void lockAll(Collection objs, int level, int timeout,\n             _lm.lockAll(sms, level, timeout, null);\n             for (Iterator itr = sms.iterator(); itr.hasNext();)\n                 ((StateManagerImpl) itr.next()).readLocked(level, level);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3679,11 +3522,9 @@ public boolean cancelAll() {\n             if ((_flags & FLAG_STORE_FLUSHING) != 0)\n                 setRollbackOnlyInternal();\n             return _store.cancelAll();\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new StoreException(re);\n         }\n     }\n@@ -3730,8 +3571,7 @@ public Collection getManagedObjects() {\n         beginOperation(false);\n         try {\n             return new ManagedObjectCollection(getManagedStates());\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3740,8 +3580,7 @@ public Collection getTransactionalObjects() {\n         beginOperation(false);\n         try {\n             return new ManagedObjectCollection(getTransactionalStates());\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3751,8 +3590,7 @@ public Collection getPendingTransactionalObjects() {\n         try {\n             return new ManagedObjectCollection\n                 (getPendingTransactionalStates());\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3761,8 +3599,7 @@ public Collection getDirtyObjects() {\n         beginOperation(false);\n         try {\n             return new ManagedObjectCollection(getDirtyStates());\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -3862,8 +3699,7 @@ void addToTransaction(StateManagerImpl sm) {\n             if (_transCache == null)\n                 _transCache = new TransactionalCache(_orderDirty);\n             _transCache.addClean(sm);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -3879,8 +3715,7 @@ void removeFromTransaction(StateManagerImpl sm) {\n                 _transCache.remove(sm);\n             if (_derefCache != null && !sm.isPersistent())\n                 _derefCache.remove(sm);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -3949,8 +3784,7 @@ void addToPendingTransaction(StateManagerImpl sm) {\n             if (_pending == null)\n                 _pending = new HashSet();\n             _pending.add(sm);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -3966,8 +3800,7 @@ void removeFromPendingTransaction(StateManagerImpl sm) {\n                 _pending.remove(sm);\n             if (_derefCache != null && !sm.isPersistent())\n                 _derefCache.remove(sm);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -4011,8 +3844,7 @@ void removeDereferencedDependent(StateManagerImpl sm) {\n                     Exceptions.toString(sm.getManagedInstance()))).\n                     setFailedObject(sm.getManagedInstance()).\n                     setFatal(true);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -4026,8 +3858,7 @@ public void dirtyType(Class cls) {\n             if (_updatedClss == null)\n                 _updatedClss = new HashSet();\n             _updatedClss.add(cls);\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -4071,8 +3902,7 @@ public void close() {\n \n             if ((_flags & FLAG_ACTIVE) == 0)\n                 free();\n-        }\n-        finally {\n+        } finally {\n             endOperation();\n         }\n     }\n@@ -4085,8 +3915,7 @@ protected void free() {\n         if ((_autoDetach & DETACH_CLOSE) != 0) {\n             try {\n                 detachAllInternal(_call);\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 err = re;\n             }\n         }\n@@ -4117,8 +3946,7 @@ protected void free() {\n             for (Iterator itr = _queries.iterator(); itr.hasNext();) {\n                 try {\n                     ((Query) itr.next()).closeResources();\n-                }\n-                catch (RuntimeException re) {\n+                } catch (RuntimeException re) {\n                 }\n             }\n             _queries = null;\n@@ -4180,8 +4008,7 @@ public Object newInstance(Class cls) {\n         if (!PCRegistry.isRegistered(cls)) {\n             try {\n                 Class.forName(cls.getName(), true, cls.getClassLoader());\n-            }\n-            catch (Throwable t) {\n+            } catch (Throwable t) {\n             }\n         }\n         return PCRegistry.newInstance(cls, null, false);"},{"sha":"741d187d36789b383b813fd7bf9d69a5cf3cd522","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","status":"modified","additions":151,"deletions":302,"changes":453,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -111,71 +111,63 @@ public Broker getBroker() {\n     public OpenJPAConfiguration getConfiguration() {\n         try {\n             return _broker.getConfiguration();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public FetchConfiguration getFetchConfiguration() {\n         try {\n             return _broker.getFetchConfiguration();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public ClassLoader getClassLoader() {\n         try {\n             return _broker.getClassLoader();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public LockManager getLockManager() {\n         try {\n             return _broker.getLockManager();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public DelegatingStoreManager getStoreManager() {\n         try {\n             return _broker.getStoreManager();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public String getConnectionUserName() {\n         try {\n             return _broker.getConnectionUserName();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public String getConnectionPassword() {\n         try {\n             return _broker.getConnectionPassword();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object find(Object oid, boolean validate, FindCallbacks call) {\n         try {\n             return _broker.find(oid, validate, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -184,17 +176,15 @@ public Object find(Object oid, boolean validate, FindCallbacks call) {\n         FindCallbacks call) {\n         try {\n             return _broker.findAll(oids, validate, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object findCached(Object oid, FindCallbacks call) {\n         try {\n             return _broker.findCached(oid, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -203,8 +193,7 @@ public Object find(Object oid, FetchState fetchState, BitSet exclude,\n         Object edata, int flags) {\n         try {\n             return _broker.find(oid, fetchState, exclude, edata, flags);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -213,8 +202,7 @@ public Object find(Object oid, FetchState fetchState, BitSet exclude,\n         BitSet exclude, Object edata, int flags) {\n         try {\n             return _broker.findAll(oids, fetchState, exclude, edata, flags);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -223,26 +211,23 @@ public Iterator extentIterator(Class cls, boolean subs,\n         FetchConfiguration fetch, boolean ignoreChanges) {\n         try {\n             return _broker.extentIterator(cls, subs, fetch, ignoreChanges);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void retrieve(Object obj, boolean fgOnly, OpCallbacks call) {\n         try {\n             _broker.retrieve(obj, fgOnly, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void retrieveAll(Collection objs, boolean fgOnly, OpCallbacks call) {\n         try {\n             _broker.retrieveAll(objs, fgOnly, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -251,269 +236,239 @@ public OpenJPAStateManager embed(Object obj, Object id,\n         OpenJPAStateManager owner, ValueMetaData ownerMeta) {\n         try {\n             return _broker.embed(obj, id, owner, ownerMeta);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Class getObjectIdType(Class cls) {\n         try {\n             return _broker.getObjectIdType(cls);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object newObjectId(Class cls, Object val) {\n         try {\n             return _broker.newObjectId(cls, val);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Collection getManagedObjects() {\n         try {\n             return _broker.getManagedObjects();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Collection getTransactionalObjects() {\n         try {\n             return _broker.getTransactionalObjects();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Collection getPendingTransactionalObjects() {\n         try {\n             return _broker.getPendingTransactionalObjects();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Collection getDirtyObjects() {\n         try {\n             return _broker.getDirtyObjects();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean getOrderDirtyObjects() {\n         try {\n             return _broker.getOrderDirtyObjects();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setOrderDirtyObjects(boolean order) {\n         try {\n             _broker.setOrderDirtyObjects(order);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Collection getPersistedTypes() {\n         try {\n             return _broker.getPersistedTypes();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Collection getUpdatedTypes() {\n         try {\n             return _broker.getUpdatedTypes();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Collection getDeletedTypes() {\n         try {\n             return _broker.getDeletedTypes();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public OpenJPAStateManager getStateManager(Object obj) {\n         try {\n             return _broker.getStateManager(obj);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int getLockLevel(Object obj) {\n         try {\n             return _broker.getLockLevel(obj);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object getVersion(Object obj) {\n         try {\n             return _broker.getVersion(obj);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isDirty(Object obj) {\n         try {\n             return _broker.isDirty(obj);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isTransactional(Object obj) {\n         try {\n             return _broker.isTransactional(obj);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isPersistent(Object obj) {\n         try {\n             return _broker.isPersistent(obj);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isNew(Object obj) {\n         try {\n             return _broker.isNew(obj);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isDeleted(Object obj) {\n         try {\n             return _broker.isDeleted(obj);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object getObjectId(Object obj) {\n         try {\n             return _broker.getObjectId(obj);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isManaged() {\n         try {\n             return _broker.isManaged();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isActive() {\n         try {\n             return _broker.isActive();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isStoreActive() {\n         try {\n             return _broker.isStoreActive();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean hasConnection() {\n         try {\n             return _broker.hasConnection();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object getConnection() {\n         try {\n             return _broker.getConnection();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void lock() {\n         try {\n             _broker.lock();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void unlock() {\n         try {\n             _broker.unlock();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean beginOperation(boolean read) {\n         try {\n             return _broker.beginOperation(read);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean endOperation() {\n         try {\n             return _broker.endOperation();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -522,557 +477,495 @@ public void setImplicitBehavior(OpCallbacks call,\n         RuntimeExceptionTranslator ex) {\n         try {\n             _broker.setImplicitBehavior(call, ex);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public BrokerFactory getBrokerFactory() {\n         try {\n             return _broker.getBrokerFactory();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int getConnectionRetainMode() {\n         try {\n             return _broker.getConnectionRetainMode();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public ManagedRuntime getManagedRuntime() {\n         try {\n             return _broker.getManagedRuntime();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public InverseManager getInverseManager() {\n         try {\n             return _broker.getInverseManager();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean getMultithreaded() {\n         try {\n             return _broker.getMultithreaded();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setMultithreaded(boolean multi) {\n         try {\n             _broker.setMultithreaded(multi);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean getIgnoreChanges() {\n         try {\n             return _broker.getIgnoreChanges();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setIgnoreChanges(boolean ignore) {\n         try {\n             _broker.setIgnoreChanges(ignore);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean getNontransactionalRead() {\n         try {\n             return _broker.getNontransactionalRead();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setNontransactionalRead(boolean read) {\n         try {\n             _broker.setNontransactionalRead(read);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean getNontransactionalWrite() {\n         try {\n             return _broker.getNontransactionalWrite();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setNontransactionalWrite(boolean write) {\n         try {\n             _broker.setNontransactionalWrite(write);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int getRestoreState() {\n         try {\n             return _broker.getRestoreState();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setRestoreState(int restore) {\n         try {\n             _broker.setRestoreState(restore);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean getOptimistic() {\n         try {\n             return _broker.getOptimistic();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setOptimistic(boolean opt) {\n         try {\n             _broker.setOptimistic(opt);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean getRetainState() {\n         try {\n             return _broker.getRetainState();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setRetainState(boolean retain) {\n         try {\n             _broker.setRetainState(retain);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int getAutoClear() {\n         try {\n             return _broker.getAutoClear();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setAutoClear(int clear) {\n         try {\n             _broker.setAutoClear(clear);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int getAutoDetach() {\n         try {\n             return _broker.getAutoDetach();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setAutoDetach(int flags) {\n         try {\n             _broker.setAutoDetach(flags);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setAutoDetach(int flag, boolean on) {\n         try {\n             _broker.setAutoDetach(flag, on);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int getDetachState() {\n         try {\n             return _broker.getDetachState();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setDetachState(int mode) {\n         try {\n             _broker.setDetachState(mode);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isDetachedNew() {\n         try {\n             return _broker.isDetachedNew();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setDetachedNew(boolean isNew) {\n         try {\n             _broker.setDetachedNew(isNew);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean getSyncWithManagedTransactions() {\n         try {\n             return _broker.getSyncWithManagedTransactions();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setSyncWithManagedTransactions(boolean sync) {\n         try {\n             _broker.setSyncWithManagedTransactions(sync);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean getEvictFromDataCache() {\n         try {\n             return _broker.getEvictFromDataCache();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setEvictFromDataCache(boolean evict) {\n         try {\n             _broker.setEvictFromDataCache(evict);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean getPopulateDataCache() {\n         try {\n             return _broker.getPopulateDataCache();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setPopulateDataCache(boolean cache) {\n         try {\n             _broker.setPopulateDataCache(cache);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isLargeTransaction() {\n         try {\n             return _broker.isLargeTransaction();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setLargeTransaction(boolean largeTransaction) {\n         try {\n             _broker.setLargeTransaction(largeTransaction);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object putUserObject(Object key, Object val) {\n         try {\n             return _broker.putUserObject(key, val);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object getUserObject(Object key) {\n         try {\n             return _broker.getUserObject(key);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void addTransactionListener(Object listener) {\n         try {\n             _broker.addTransactionListener(listener);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void removeTransactionListener(Object listener) {\n         try {\n             _broker.removeTransactionListener(listener);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void addLifecycleListener(Object listener, Class[] classes) {\n         try {\n             _broker.addLifecycleListener(listener, classes);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void removeLifecycleListener(Object listener) {\n         try {\n             _broker.removeLifecycleListener(listener);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public LifecycleEventManager getLifecycleEventManager() {\n         try {\n             return _broker.getLifecycleEventManager();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void begin() {\n         try {\n             _broker.begin();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void commit() {\n         try {\n             _broker.commit();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void rollback() {\n         try {\n             _broker.rollback();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean syncWithManagedTransaction() {\n         try {\n             return _broker.syncWithManagedTransaction();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void commitAndResume() {\n         try {\n             _broker.commitAndResume();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void rollbackAndResume() {\n         try {\n             _broker.rollbackAndResume();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setRollbackOnly() {\n         try {\n             _broker.setRollbackOnly();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean getRollbackOnly() {\n         try {\n             return _broker.getRollbackOnly();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setSavepoint(String name) {\n         try {\n             _broker.setSavepoint(name);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void rollbackToSavepoint() {\n         try {\n             _broker.rollbackToSavepoint();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void rollbackToSavepoint(String name) {\n         try {\n             _broker.rollbackToSavepoint(name);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void releaseSavepoint() {\n         try {\n             _broker.releaseSavepoint();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void releaseSavepoint(String name) {\n         try {\n             _broker.releaseSavepoint(name);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void flush() {\n         try {\n             _broker.flush();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void preFlush() {\n         try {\n             _broker.preFlush();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void validateChanges() {\n         try {\n             _broker.validateChanges();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void beginStore() {\n         try {\n             _broker.beginStore();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void persist(Object obj, OpCallbacks call) {\n         try {\n             _broker.persist(obj, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void persistAll(Collection objs, OpCallbacks call) {\n         try {\n             _broker.persistAll(objs, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -1081,134 +974,119 @@ public OpenJPAStateManager persist(Object obj, Object id,\n         OpCallbacks call) {\n         try {\n             return _broker.persist(obj, id, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void delete(Object obj, OpCallbacks call) {\n         try {\n             _broker.delete(obj, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void deleteAll(Collection objs, OpCallbacks call) {\n         try {\n             _broker.deleteAll(objs, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void release(Object obj, OpCallbacks call) {\n         try {\n             _broker.release(obj, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void releaseAll(Collection objs, OpCallbacks call) {\n         try {\n             _broker.releaseAll(objs, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void refresh(Object obj, OpCallbacks call) {\n         try {\n             _broker.refresh(obj, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void refreshAll(Collection objs, OpCallbacks call) {\n         try {\n             _broker.refreshAll(objs, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void evict(Object obj, OpCallbacks call) {\n         try {\n             _broker.evict(obj, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void evictAll(Collection objs, OpCallbacks call) {\n         try {\n             _broker.evictAll(objs, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void evictAll(OpCallbacks call) {\n         try {\n             _broker.evictAll(call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void evictAll(Extent extent, OpCallbacks call) {\n         try {\n             _broker.evictAll(extent, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object detach(Object obj, OpCallbacks call) {\n         try {\n             return _broker.detach(obj, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object[] detachAll(Collection objs, OpCallbacks call) {\n         try {\n             return _broker.detachAll(objs, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void detachAll(OpCallbacks call) {\n         try {\n             _broker.detachAll(call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object attach(Object obj, boolean copyNew, OpCallbacks call) {\n         try {\n             return _broker.attach(obj, copyNew, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -1217,8 +1095,7 @@ public Object attach(Object obj, boolean copyNew, OpCallbacks call) {\n         OpCallbacks call) {\n         try {\n             return _broker.attachAll(objs, copyNew, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -1227,8 +1104,7 @@ public void transactional(Object pc, boolean updateVersion, OpCallbacks\n         call) {\n         try {\n             _broker.transactional(pc, updateVersion, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -1237,89 +1113,79 @@ public void transactionalAll(Collection objs, boolean updateVersion,\n         OpCallbacks call) {\n         try {\n             _broker.transactionalAll(objs, updateVersion, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void nontransactional(Object pc, OpCallbacks call) {\n         try {\n             _broker.nontransactional(pc, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void nontransactionalAll(Collection objs, OpCallbacks call) {\n         try {\n             _broker.nontransactionalAll(objs, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Extent newExtent(Class cls, boolean subs) {\n         try {\n             return _broker.newExtent(cls, subs);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Query newQuery(String language, Class cls, Object query) {\n         try {\n             return _broker.newQuery(language, cls, query);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Query newQuery(String language, Object query) {\n         try {\n             return _broker.newQuery(language, query);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Seq getIdentitySequence(ClassMetaData meta) {\n         try {\n             return _broker.getIdentitySequence(meta);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Seq getValueSequence(FieldMetaData fmd) {\n         try {\n             return _broker.getValueSequence(fmd);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void lock(Object obj, int level, int timeout, OpCallbacks call) {\n         try {\n             _broker.lock(obj, level, timeout, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void lock(Object obj, OpCallbacks call) {\n         try {\n             _broker.lock(obj, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -1328,89 +1194,79 @@ public void lockAll(Collection objs, int level, int timeout,\n         OpCallbacks call) {\n         try {\n             _broker.lockAll(objs, level, timeout, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void lockAll(Collection objs, OpCallbacks call) {\n         try {\n             _broker.lockAll(objs, call);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean cancelAll() {\n         try {\n             return _broker.cancelAll();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void dirtyType(Class cls) {\n         try {\n             _broker.dirtyType(cls);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void close() {\n         try {\n             _broker.close();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isClosed() {\n         try {\n             return _broker.isClosed();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void assertOpen() {\n         try {\n             _broker.assertOpen();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void assertActiveTransaction() {\n         try {\n             _broker.assertActiveTransaction();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void assertNontransactionalRead() {\n         try {\n             _broker.assertNontransactionalRead();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void assertWriteOperation() {\n         try {\n             _broker.assertWriteOperation();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -1422,17 +1278,15 @@ public void assertWriteOperation() {\n     public void beforeCompletion() {\n         try {\n             _broker.beforeCompletion();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void afterCompletion(int status) {\n         try {\n             _broker.afterCompletion(status);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -1445,8 +1299,7 @@ public ConnectionMetaData getMetaData()\n         throws ResourceException {\n         try {\n             return _broker.getMetaData();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -1455,8 +1308,7 @@ public Interaction createInteraction()\n         throws ResourceException {\n         try {\n             return _broker.createInteraction();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -1470,26 +1322,23 @@ public ResultSetInfo getResultSetInfo()\n         throws ResourceException {\n         try {\n             return _broker.getResultSetInfo();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object newInstance(Class cls) {\n         try {\n             return _broker.newInstance(cls);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isDetached(Object obj) {\n         try {\n             return _broker.isDetached(obj);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }"},{"sha":"958ee78bf41dd47e6b40b5bb86244efc6dac9ad8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java","status":"modified","additions":12,"deletions":24,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -96,44 +96,39 @@ protected RuntimeException translate(RuntimeException re) {\n     public OpenJPAConfiguration getConfiguration() {\n         try {\n             return _factory.getConfiguration();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Properties getProperties() {\n         try {\n             return _factory.getProperties();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object putUserObject(Object key, Object val) {\n         try {\n             return _factory.putUserObject(key, val);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object getUserObject(Object key) {\n         try {\n             return _factory.getUserObject(key);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Broker newBroker() {\n         try {\n             return _factory.newBroker();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -143,62 +138,55 @@ public Broker newBroker(String user, String pass, boolean managed,\n         try {\n             return _factory.newBroker(user, pass, managed, connRetainMode,\n                 findExisting);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void addLifecycleListener(Object listener, Class[] classes) {\n         try {\n             _factory.addLifecycleListener(listener, classes);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void removeLifecycleListener(Object listener) {\n         try {\n             _factory.removeLifecycleListener(listener);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void close() {\n         try {\n             _factory.close();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isClosed() {\n         try {\n             return _factory.isClosed();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void lock() {\n         try {\n             _factory.lock();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void unlock() {\n         try {\n             _factory.unlock();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n \t\t}\n \t}"},{"sha":"bc2f1bd2f2836fd61f3e38c6e62c44c8afd4a613","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java","status":"modified","additions":11,"deletions":22,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -95,98 +95,87 @@ protected RuntimeException translate(RuntimeException re) {\n     public Class getElementType() {\n         try {\n             return _extent.getElementType();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean hasSubclasses() {\n         try {\n             return _extent.hasSubclasses();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Broker getBroker() {\n         try {\n             return _extent.getBroker();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public FetchConfiguration getFetchConfiguration() {\n         try {\n             return _extent.getFetchConfiguration();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean getIgnoreChanges() {\n         try {\n             return _extent.getIgnoreChanges();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setIgnoreChanges(boolean ignoreCache) {\n         try {\n             _extent.setIgnoreChanges(ignoreCache);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public List list() {\n         try {\n             return _extent.list();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Iterator iterator() {\n         try {\n             return _extent.iterator();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void closeAll() {\n         try {\n             _extent.closeAll();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void lock() {\n         try {\n             _extent.lock();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void unlock() {\n         try {\n             _extent.unlock();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n \t\t}\n \t}"},{"sha":"392d9fa3f396e9c0c7d5a75ada124c9e7dbf556a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","status":"modified","additions":42,"deletions":84,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -98,26 +98,23 @@ protected RuntimeException translate(RuntimeException re) {\n     public StoreContext getContext() {\n         try {\n             return _fetch.getContext();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setContext(StoreContext ctx) {\n         try {\n             _fetch.setContext(ctx);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int getFetchBatchSize() {\n         try {\n             return _fetch.getFetchBatchSize();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -126,17 +123,15 @@ public FetchConfiguration setFetchBatchSize(int fetchBatchSize) {\n         try {\n             _fetch.setFetchBatchSize(fetchBatchSize);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int getMaxFetchDepth() {\n         try {\n             return _fetch.getMaxFetchDepth();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -145,17 +140,15 @@ public FetchConfiguration setMaxFetchDepth(int depth) {\n         try {\n             _fetch.setMaxFetchDepth(depth);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Set getRootInstances() {\n         try {\n             return _fetch.getRootInstances();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -164,17 +157,15 @@ public FetchConfiguration setRootInstances(Collection roots) {\n         try {\n             _fetch.setRootInstances(roots);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Set getRootClasses() {\n         try {\n             return _fetch.getRootClasses();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -183,17 +174,15 @@ public FetchConfiguration setRootClasses(Collection roots) {\n         try {\n             _fetch.setRootClasses(roots);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean getQueryCache() {\n         try {\n             return _fetch.getQueryCache();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -202,17 +191,15 @@ public FetchConfiguration setQueryCache(boolean cache) {\n         try {\n             _fetch.setQueryCache(cache);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int getFlushBeforeQueries() {\n         try {\n             return _fetch.getFlushBeforeQueries();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -221,35 +208,31 @@ public FetchConfiguration setFlushBeforeQueries(int flush) {\n         try {\n             _fetch.setFlushBeforeQueries(flush);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Set getFetchGroups() {\n         try {\n             return _fetch.getFetchGroups();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean hasFetchGroup(String group) {\n         try {\n             return _fetch.hasFetchGroup(group);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean hasFetchGroup(Set groups) {\n         try {\n             return _fetch.hasFetchGroup(groups);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -258,8 +241,7 @@ public FetchConfiguration addFetchGroup(String group) {\n         try {\n             _fetch.addFetchGroup(group);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -268,8 +250,7 @@ public FetchConfiguration addFetchGroups(Collection groups) {\n         try {\n             _fetch.addFetchGroups(groups);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -278,8 +259,7 @@ public FetchConfiguration removeFetchGroup(String group) {\n         try {\n             _fetch.removeFetchGroup(group);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -288,8 +268,7 @@ public FetchConfiguration removeFetchGroups(Collection groups) {\n         try {\n             _fetch.removeFetchGroups(groups);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -298,8 +277,7 @@ public FetchConfiguration clearFetchGroups() {\n         try {\n             _fetch.clearFetchGroups();\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -308,26 +286,23 @@ public FetchConfiguration resetFetchGroups() {\n         try {\n             _fetch.resetFetchGroups();\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Set getFields() {\n         try {\n             return _fetch.getFields();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean hasField(String field) {\n         try {\n             return _fetch.hasField(field);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -336,8 +311,7 @@ public FetchConfiguration addField(String field) {\n         try {\n             _fetch.addField(field);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -346,8 +320,7 @@ public FetchConfiguration addFields(Collection fields) {\n         try {\n             _fetch.addFields(fields);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -356,8 +329,7 @@ public FetchConfiguration removeField(String field) {\n         try {\n             _fetch.removeField(field);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -366,8 +338,7 @@ public FetchConfiguration removeFields(Collection fields) {\n         try {\n             _fetch.removeFields(fields);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -376,17 +347,15 @@ public FetchConfiguration clearFields() {\n         try {\n             _fetch.clearFields();\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int getLockTimeout() {\n         try {\n             return _fetch.getLockTimeout();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -395,17 +364,15 @@ public FetchConfiguration setLockTimeout(int timeout) {\n         try {\n             _fetch.setLockTimeout(timeout);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int getReadLockLevel() {\n         try {\n             return _fetch.getReadLockLevel();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -414,17 +381,15 @@ public FetchConfiguration setReadLockLevel(int level) {\n         try {\n             _fetch.setReadLockLevel(level);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int getWriteLockLevel() {\n         try {\n             return _fetch.getWriteLockLevel();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -433,62 +398,55 @@ public FetchConfiguration setWriteLockLevel(int level) {\n         try {\n             _fetch.setWriteLockLevel(level);\n             return this;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public ResultList newResultList(ResultObjectProvider rop) {\n         try {\n             return _fetch.newResultList(rop);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public FetchState newFetchState() {\n         try {\n             return _fetch.newFetchState();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void copy(FetchConfiguration fetch) {\n         try {\n             _fetch.copy(fetch);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object clone() {\n         try {\n             return _fetch.clone();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setHint(String name, Object value) {\n         try {\n             _fetch.setHint(name, value);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object getHint(String name) {\n         try {\n             return _fetch.getHint(name);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n \t\t}\n \t}"},{"sha":"6d32564351ea87998cd51ed579534c5b554ff0af","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java","status":"modified","additions":69,"deletions":138,"changes":207,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -98,8 +98,7 @@ protected RuntimeException translate(RuntimeException re) {\n     public Broker getBroker() {\n         try {\n             return _query.getBroker();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -111,611 +110,543 @@ public Query getQuery() {\n     public StoreContext getStoreContext() {\n         try {\n             return _query.getStoreContext();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int getOperation() {\n         try {\n             return _query.getOperation();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public String getLanguage() {\n         try {\n             return _query.getLanguage();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public FetchConfiguration getFetchConfiguration() {\n         try {\n             return _query.getFetchConfiguration();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public String getQueryString() {\n         try {\n             return _query.getQueryString();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean getIgnoreChanges() {\n         try {\n             return _query.getIgnoreChanges();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object getCompilation() {\n         try {\n             return _query.getCompilation();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public String getAlias() {\n         try {\n             return _query.getAlias();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public String[] getProjectionAliases() {\n         try {\n             return _query.getProjectionAliases();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Class[] getProjectionTypes() {\n         try {\n             return _query.getProjectionTypes();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isAggregate() {\n         try {\n             return _query.isAggregate();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean hasGrouping() {\n         try {\n             return _query.hasGrouping();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public ClassMetaData[] getAccessPathMetaDatas() {\n         try {\n             return _query.getAccessPathMetaDatas();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public FilterListener getFilterListener(String tag) {\n         try {\n             return _query.getFilterListener(tag);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public AggregateListener getAggregateListener(String tag) {\n         try {\n             return _query.getAggregateListener(tag);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Collection getFilterListeners() {\n         try {\n             return _query.getFilterListeners();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Collection getAggregateListeners() {\n         try {\n             return _query.getAggregateListeners();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Collection getCandidateCollection() {\n         try {\n             return _query.getCandidateCollection();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Class getCandidateType() {\n         try {\n             return _query.getCandidateType();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean hasSubclasses() {\n         try {\n             return _query.hasSubclasses();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setCandidateType(Class cls, boolean subs) {\n         try {\n             _query.setCandidateType(cls, subs);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isReadOnly() {\n         try {\n             return _query.isReadOnly();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setReadOnly(boolean readOnly) {\n         try {\n             _query.setReadOnly(readOnly);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Class getResultMappingScope() {\n         try {\n             return _query.getResultMappingScope();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public String getResultMappingName() {\n         try {\n             return _query.getResultMappingName();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setResultMapping(Class scope, String name) {\n         try {\n             _query.setResultMapping(scope, name);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isUnique() {\n         try {\n             return _query.isUnique();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setUnique(boolean unique) {\n         try {\n             _query.setUnique(unique);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Class getResultType() {\n         try {\n             return _query.getResultType();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setResultType(Class cls) {\n         try {\n             _query.setResultType(cls);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public long getStartRange() {\n         try {\n             return _query.getStartRange();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public long getEndRange() {\n         try {\n             return _query.getEndRange();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setRange(long start, long end) {\n         try {\n             _query.setRange(start, end);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public String getParameterDeclaration() {\n         try {\n             return _query.getParameterDeclaration();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public LinkedMap getParameterTypes() {\n         try {\n             return _query.getParameterTypes();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Map getUpdates() {\n         try {\n             return _query.getUpdates();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void declareParameters(String params) {\n         try {\n             _query.declareParameters(params);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object[] toParameterArray(LinkedMap paramTypes, Map params) {\n         try {\n             return _query.toParameterArray(paramTypes, params);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Number deleteInMemory(StoreQuery.Executor ex, Object[] params) {\n         try {\n             return _query.deleteInMemory(ex, params);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Number updateInMemory(StoreQuery.Executor ex, Object[] params) {\n         try {\n             return _query.updateInMemory(ex, params);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Class classForName(String name, String[] imports) {\n         try {\n             return _query.classForName(name, imports);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void lock() {\n         try {\n             _query.lock();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void unlock() {\n         try {\n             _query.unlock();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void addFilterListener(FilterListener listener) {\n         try {\n             _query.addFilterListener(listener);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void removeFilterListener(FilterListener listener) {\n         try {\n             _query.removeFilterListener(listener);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void addAggregateListener(AggregateListener listener) {\n         try {\n             _query.addAggregateListener(listener);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void removeAggregateListener(AggregateListener listener) {\n         try {\n             _query.removeAggregateListener(listener);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Extent getCandidateExtent() {\n         try {\n             return _query.getCandidateExtent();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setCandidateExtent(Extent extent) {\n         try {\n             _query.setCandidateExtent(extent);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setCandidateCollection(Collection coll) {\n         try {\n             _query.setCandidateCollection(coll);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void compile() {\n         try {\n             _query.compile();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object execute() {\n         try {\n             return _query.execute();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object execute(Map params) {\n         try {\n             return _query.execute(params);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object execute(Object[] params) {\n         try {\n             return _query.execute(params);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public long deleteAll() {\n         try {\n             return _query.deleteAll();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public long deleteAll(Object[] parameters) {\n         try {\n             return _query.deleteAll(parameters);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public long deleteAll(Map parameterMap) {\n         try {\n             return _query.deleteAll(parameterMap);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public long updateAll() {\n         try {\n             return _query.updateAll();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public long updateAll(Object[] parameters) {\n         try {\n             return _query.updateAll(parameters);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public long updateAll(Map parameterMap) {\n         try {\n             return _query.updateAll(parameterMap);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void closeAll() {\n         try {\n             _query.closeAll();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void closeResources() {\n         try {\n             _query.closeResources();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public String[] getDataStoreActions(Map params) {\n         try {\n             return _query.getDataStoreActions(params);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean setQuery(Object query) {\n         try {\n             return _query.setQuery(query);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void setIgnoreChanges(boolean ignore) {\n         try {\n             _query.setIgnoreChanges(ignore);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void assertOpen() {\n         try {\n             _query.assertOpen();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void assertNotReadOnly() {\n         try {\n             _query.assertNotReadOnly();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void assertNotSerialized() {\n         try {\n             _query.assertNotSerialized();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n \t\t}\n \t}"},{"sha":"2b55a7ccb12e3e49276261b861f6acdc21e637b2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java","status":"modified","additions":38,"deletions":76,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -80,8 +80,7 @@ public Object writeReplace()\n     public int hashCode() {\n         try {\n             return getInnermostDelegate().hashCode();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -93,8 +92,7 @@ public boolean equals(Object other) {\n             other = ((DelegatingResultList) other).getInnermostDelegate();\n         try {\n             return getInnermostDelegate().equals(other);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -109,53 +107,47 @@ protected RuntimeException translate(RuntimeException re) {\n     public boolean isProviderOpen() {\n         try {\n             return _del.isProviderOpen();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void close() {\n         try {\n             _del.close();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isClosed() {\n         try {\n             return _del.isClosed();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int size() {\n         try {\n             return _del.size();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean isEmpty() {\n         try {\n             return _del.isEmpty();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean contains(Object o) {\n         try {\n             return _del.contains(o);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -167,170 +159,151 @@ public Iterator iterator() {\n     public Object[] toArray() {\n         try {\n             return _del.toArray();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object[] toArray(Object[] a) {\n         try {\n             return _del.toArray(a);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean add(Object o) {\n         try {\n             return _del.add(o);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean remove(Object o) {\n         try {\n             return _del.remove(o);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean containsAll(Collection c) {\n         try {\n             return _del.containsAll(c);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean addAll(Collection c) {\n         try {\n             return _del.addAll(c);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean addAll(int index, Collection c) {\n         try {\n             return _del.addAll(index, c);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean removeAll(Collection c) {\n         try {\n             return _del.removeAll(c);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public boolean retainAll(Collection c) {\n         try {\n             return _del.retainAll(c);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void clear() {\n         try {\n             _del.clear();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object get(int index) {\n         try {\n             return _del.get(index);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object set(int index, Object element) {\n         try {\n             return _del.set(index, element);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void add(int index, Object element) {\n         try {\n             _del.add(index, element);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object remove(int index) {\n         try {\n             return _del.remove(index);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int indexOf(Object o) {\n         try {\n             return _del.indexOf(o);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public int lastIndexOf(Object o) {\n         try {\n             return _del.lastIndexOf(o);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public ListIterator listIterator() {\n         try {\n             return new DelegatingListIterator(_del.listIterator());\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public ListIterator listIterator(int index) {\n         try {\n             return new DelegatingListIterator(_del.listIterator(index));\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public List subList(int fromIndex, int toIndex) {\n         try {\n             return _del.subList(fromIndex, toIndex);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -368,8 +341,7 @@ public ListIterator getInnermostDelegate() {\n         public int hashCode() {\n             try {\n                 return getInnermostDelegate().hashCode();\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 throw translate(re);\n             }\n         }\n@@ -382,89 +354,79 @@ public boolean equals(Object other) {\n                     getInnermostDelegate();\n             try {\n                 return getInnermostDelegate().equals(other);\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 throw translate(re);\n             }\n         }\n \n         public boolean hasNext() {\n             try {\n                 return _del.hasNext();\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 throw translate(re);\n             }\n         }\n \n         public Object next() {\n             try {\n                 return _del.next();\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 throw translate(re);\n             }\n         }\n \n         public boolean hasPrevious() {\n             try {\n                 return _del.hasPrevious();\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 throw translate(re);\n             }\n         }\n \n         public Object previous() {\n             try {\n                 return _del.previous();\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 throw translate(re);\n             }\n         }\n \n         public int nextIndex() {\n             try {\n                 return _del.nextIndex();\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 throw translate(re);\n             }\n         }\n \n         public int previousIndex() {\n             try {\n                 return _del.previousIndex();\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 throw translate(re);\n             }\n         }\n \n         public void remove() {\n             try {\n                 _del.remove();\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 throw translate(re);\n             }\n         }\n \n         public void set(Object o) {\n             try {\n                 _del.set(o);\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 throw translate(re);\n             }\n         }\n \n         public void add(Object o) {\n             try {\n                 _del.add(o);\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 throw translate (re);\n \t\t\t}\n \t\t}"},{"sha":"63b9d4e083bf2d2a37478b40e94b8f3c1b9e12a5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java","status":"modified","additions":5,"deletions":10,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -92,44 +92,39 @@ protected RuntimeException translate(RuntimeException re) {\n     public void setType(int type) {\n         try {\n             _seq.setType(type);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object next(StoreContext ctx, ClassMetaData meta) {\n         try {\n             return _seq.next(ctx, meta);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public Object current(StoreContext ctx, ClassMetaData meta) {\n         try {\n             return _seq.current(ctx, meta);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void allocate(int additional, StoreContext ctx, ClassMetaData meta) {\n         try {\n             _seq.allocate(additional, ctx, meta);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n     public void close() {\n         try {\n             _seq.close();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n \t\t}\n \t}"},{"sha":"b6a35b921f6504ee5df0297ac09b681c16b4c66c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","status":"modified","additions":5,"deletions":10,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -267,12 +267,10 @@ public Object detach(Object toDetach) {\n         CallbackException excep = null;\n         try {\n             return detachInternal(toDetach);\n-        }\n-        catch (CallbackException ce) {\n+        } catch (CallbackException ce) {\n             excep = ce;\n             return null; // won't be reached as exception will be rethrown\n-        }\n-        finally {\n+        } finally {\n             List exceps = null;\n \n             if (excep == null || !_failFast) {\n@@ -309,8 +307,7 @@ public Object detach(Object toDetach) {\n             if (re instanceof CallbackException && _failFast)\n                 failFast = true;\n             exceps = add(exceps, re);\n-        }\n-        finally {\n+        } finally {\n             // invoke post callbacks unless all failed\n             if (!failFast && (exceps == null\n                 || exceps.size() < instances.size())) {\n@@ -353,8 +350,7 @@ private List invokeAfterDetach(Collection objs, List exceps) {\n                 if (sm != null)\n                     _broker.fireLifecycleEvent(detached, orig,\n                         sm.getMetaData(), LifecycleEvent.AFTER_DETACH);\n-            }\n-            catch (CallbackException ce) {\n+            } catch (CallbackException ce) {\n                 exceps = add(exceps, ce);\n                 if (_failFast)\n                     break; // don't continue processing\n@@ -594,8 +590,7 @@ public void detachFields(BitSet fgfields) {\n                 for (int i = 0; i < fmds.length; i++)\n                     if (!fmds[i].isPrimaryKey() && !fmds[i].isVersion())\n                         detachField(from, i, fgfields.get(i));\n-            }\n-            finally {\n+            } finally {\n                 // clear the StateManager from the target object\n                 if (_copy)\n                     _to.pcReplaceStateManager(null);"},{"sha":"fe62450c9b5ef7c14a8f16bf71853ee4a751acc6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","status":"modified","additions":12,"deletions":24,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -400,8 +400,7 @@ public void proxyDetachedDeserialized(int idx) {\n             if (objval instanceof Proxy)\n                 ((Proxy) objval).setOwner(this, idx);\n             objval = null;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -416,8 +415,7 @@ public void settingBooleanField(PersistenceCapable pc, int idx,\n             _dirty.set(idx);\n             longval = next ? 1 : 0;\n             pc.pcReplaceField(idx);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -432,8 +430,7 @@ public void settingCharField(PersistenceCapable pc, int idx, char cur,\n             _dirty.set(idx);\n             longval = next;\n             pc.pcReplaceField(idx);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -448,8 +445,7 @@ public void settingByteField(PersistenceCapable pc, int idx, byte cur,\n             _dirty.set(idx);\n             longval = next;\n             pc.pcReplaceField(idx);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -464,8 +460,7 @@ public void settingShortField(PersistenceCapable pc, int idx, short cur,\n             _dirty.set(idx);\n             longval = next;\n             pc.pcReplaceField(idx);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -480,8 +475,7 @@ public void settingIntField(PersistenceCapable pc, int idx, int cur,\n             _dirty.set(idx);\n             longval = next;\n             pc.pcReplaceField(idx);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -496,8 +490,7 @@ public void settingLongField(PersistenceCapable pc, int idx, long cur,\n             _dirty.set(idx);\n             longval = next;\n             pc.pcReplaceField(idx);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -512,8 +505,7 @@ public void settingFloatField(PersistenceCapable pc, int idx, float cur,\n             _dirty.set(idx);\n             dblval = next;\n             pc.pcReplaceField(idx);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -528,8 +520,7 @@ public void settingDoubleField(PersistenceCapable pc, int idx, double cur,\n             _dirty.set(idx);\n             dblval = next;\n             pc.pcReplaceField(idx);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -544,8 +535,7 @@ public void settingStringField(PersistenceCapable pc, int idx, String cur,\n             _dirty.set(idx);\n             objval = next;\n             pc.pcReplaceField(idx);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n             objval = null;\n         }\n@@ -561,8 +551,7 @@ public void settingObjectField(PersistenceCapable pc, int idx, Object cur,\n             _dirty.set(idx);\n             objval = next;\n             pc.pcReplaceField(idx);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n             objval = null;\n         }\n@@ -808,8 +797,7 @@ public void dirty(int field) {\n         lock();\n         try {\n             _dirty.set(field);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }"},{"sha":"011142240a5bd1607b78dbdbece8c3186b2a8b57","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","status":"modified","additions":9,"deletions":18,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -98,8 +98,7 @@ public List list() {\n             while (itr.hasNext())\n                 list.add(itr.next());\n             return list;\n-        }\n-        finally {\n+        } finally {\n             ImplHelper.close(itr);\n         }\n     }\n@@ -144,11 +143,9 @@ else if (meta == null && _subs)\n             else\n                 citr = chain;\n             citr.setRemoveOnClose(this);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n         }\n \n@@ -157,8 +154,7 @@ else if (meta == null && _subs)\n             if (_openItrs == null)\n                 _openItrs = new ReferenceHashSet(ReferenceHashSet.WEAK);\n             _openItrs.add(citr);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n         return citr;\n@@ -192,14 +188,11 @@ public void closeAll() {\n                 }\n             }\n             _openItrs.clear();\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -260,8 +253,7 @@ public void close()\n                 _extent.lock();\n                 try {\n                     _extent._openItrs.remove(this);\n-                }\n-                finally {\n+                } finally {\n                     _extent.unlock();\n                 }\n             }\n@@ -311,8 +303,7 @@ public void close()\n                 _extent.lock();\n                 try {\n                     _extent._openItrs.remove(this);\n-                }\n-                finally {\n+                } finally {\n                     _extent.unlock();\n                 }\n             }"},{"sha":"f75d7f13561b2079b20746b754d2d589d3f22406","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","status":"modified","additions":6,"deletions":12,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -709,8 +709,7 @@ public static AggregateListener hintToAggregateListener(Object hint,\n             try {\n                 return (AggregateListener) Class.forName((String) hint, true,\n                     loader).newInstance();\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 cause = e;\n             }\n         }\n@@ -746,8 +745,7 @@ public static AggregateListener hintToAggregateListener(Object hint,\n                     aggs[i] = (AggregateListener) Class.forName(clss[i], true,\n                         loader).newInstance();\n                 return aggs;\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 cause = e;\n             }\n         }\n@@ -771,8 +769,7 @@ public static FilterListener hintToFilterListener(Object hint,\n             try {\n                 return (FilterListener) Class.forName((String) hint, true,\n                     loader).newInstance();\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 cause = e;\n             }\n         }\n@@ -807,8 +804,7 @@ public static FilterListener hintToFilterListener(Object hint,\n                     filts[i] = (FilterListener) Class.forName(clss[i], true,\n                         loader).newInstance();\n                 return filts;\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 cause = e;\n             }\n         }\n@@ -826,8 +822,7 @@ public static Object hintToGetter(Object target, String hintKey) {\n         Method getter = ImplHelper.getGetter(target.getClass(), hintKey);\n         try {\n             return getter.invoke(target, (Object[]) null);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             Throwable t = e;\n             if (e instanceof InvocationTargetException)\n                 t = ((InvocationTargetException) e).getTargetException();\n@@ -854,8 +849,7 @@ public static void hintToSetter(Object target, String hintKey,\n                         setter.getParameterTypes()[0]);\n             }\n             setter.invoke(target, new Object[]{ value });\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             Throwable t = e;\n             if (e instanceof InvocationTargetException)\n                 t = ((InvocationTargetException) e).getTargetException();"},{"sha":"d54e1e815593e73455c1acbe76c997fe90da058e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java","status":"modified","additions":6,"deletions":12,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -76,8 +76,7 @@ public synchronized void commit() {\n                 _broker.beforeCompletion();\n                 if (_factorySync != null)\n                     _factorySync.beforeCompletion();\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 _rollbackOnly = true;\n                 err = re;\n             }\n@@ -89,8 +88,7 @@ public synchronized void commit() {\n             try {\n                 _broker.afterCompletion(Status.STATUS_COMMITTED);\n                 notifyAfterCompletion(Status.STATUS_COMMITTED);\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 if (err == null)\n                     err = re;\n             }\n@@ -100,8 +98,7 @@ public synchronized void commit() {\n         if (_active) {\n             try {\n                 rollback();\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 if (err == null)\n                     err = re;\n             }\n@@ -120,16 +117,14 @@ public synchronized void rollback() {\n         RuntimeException err = null;\n         try {\n             _broker.afterCompletion(Status.STATUS_ROLLEDBACK);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             err = re;\n         }\n \n         // rollback synch, even if broker throws exception\n         try {\n             notifyAfterCompletion(Status.STATUS_ROLLEDBACK);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             if (err == null)\n                 err = re;\n         }\n@@ -149,8 +144,7 @@ private void notifyAfterCompletion(int status) {\n         try {\n             if (_factorySync != null)\n                 _factorySync.afterCompletion(status);\n-        }\n-        finally {\n+        } finally {\n             _rollbackOnly = false;\n             _factorySync = null;\n         }"},{"sha":"5677910ce4826d61b1b47d8f1946efd752c2cbb0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java","status":"modified","additions":4,"deletions":8,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -109,8 +109,7 @@ private LinkedMap bindParameterTypes() {\n                 _params.put(decs.get(i + 1), cls);\n             }\n             return _params;\n-        }\n-        finally {\n+        } finally {\n             ctx.unlock();\n         }\n     }\n@@ -229,8 +228,7 @@ private Object invoke(StoreQuery q, Object[] args) {\n                 Class[] types = (_inMem) ? ARGS_INMEM : ARGS_DATASTORE;\n                 try {\n                     meth = cls.getMethod(methName, types);\n-                }\n-                catch (Exception e) {\n+                } catch (Exception e) {\n                     String msg = (_inMem) ? \"bad-inmem-method\"\n                         : \"bad-datastore-method\";\n                     throw new UserException(_loc.get(msg, methName, cls));\n@@ -243,11 +241,9 @@ private Object invoke(StoreQuery q, Object[] args) {\n \n             try {\n                 return meth.invoke(null, args);\n-            }\n-            catch (OpenJPAException ke) {\n+            } catch (OpenJPAException ke) {\n                 throw ke;\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 throw new UserException(_loc.get(\"method-error\", _meth,\n                     Exceptions.toString(Arrays.asList(args))), e);\n             }"},{"sha":"ca867c0709f0b356e1abb786e4ef6e4cc5b9c40b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","status":"modified","additions":4,"deletions":8,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -697,14 +697,12 @@ private Object getValue(int field) {\n             try {\n                 meth = _oid.getClass().getMethod(\"get\"\n                     + StringUtils.capitalize(fmd.getName()), (Class[]) null);\n-            }\n-            catch (NoSuchMethodException nsme) {\n+            } catch (NoSuchMethodException nsme) {\n                 meth = _oid.getClass().getMethod(\"is\"\n                     + StringUtils.capitalize(fmd.getName()), (Class[]) null);\n             }\n             return meth.invoke(_oid, (Object[]) null);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new GeneralException(e);\n         }\n     }\n@@ -718,8 +716,7 @@ private void setValue(int field, Object val, boolean forceInst) {\n         if (_oid == null && forceInst) {\n             try {\n                 _oid = getMetaData().getDescribedType().newInstance();\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 throw new GeneralException(e);\n             }\n         } else if (_oid == null)\n@@ -736,8 +733,7 @@ else if (fmd.getDefiningMetaData().getAccessType()\n                 _oid.getClass().getMethod(\"set\" + StringUtils.capitalize\n                     (fmd.getName()), new Class[]{ fmd.getDeclaredType() }).\n                     invoke(_oid, new Object[]{ val });\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new GeneralException(e);\n         }\n \t}"},{"sha":"67b921d7ad1c3fd98af49c079d1dac68705ce9cd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","status":"modified","additions":58,"deletions":116,"changes":174,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -164,8 +164,7 @@ public void setIgnoreChanges(boolean flag) {\n             assertOpen();\n             // allowed modification: no read-only check\n             _ignoreChanges = flag;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -180,8 +179,7 @@ public void setReadOnly(boolean flag) {\n         try {\n             assertOpen();\n             _readOnly = flag;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -194,8 +192,7 @@ public void addFilterListener(FilterListener listener) {\n             if (_filtListeners == null)\n                 _filtListeners = new HashMap(5);\n             _filtListeners.put(listener.getTag(), listener);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -207,8 +204,7 @@ public void removeFilterListener(FilterListener listener) {\n             assertNotReadOnly();\n             if (_filtListeners != null)\n                 _filtListeners.remove(listener.getTag());\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -245,8 +241,7 @@ public void addAggregateListener(AggregateListener listener) {\n             if (_aggListeners == null)\n                 _aggListeners = new HashMap(5);\n             _aggListeners.put(listener.getTag(), listener);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -258,8 +253,7 @@ public void removeAggregateListener(AggregateListener listener) {\n             assertNotReadOnly();\n             if (_aggListeners != null)\n                 _aggListeners.remove(listener.getTag());\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -308,8 +302,7 @@ public Extent getCandidateExtent() {\n                 _extent.setIgnoreChanges(_ignoreChanges);\n             }\n             return _extent;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -343,8 +336,7 @@ public void setCandidateExtent(Extent candidateExtent) {\n             }\n             if (invalidate)\n                 invalidateCompilation();\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -367,8 +359,7 @@ public void setCandidateCollection(Collection candidateCollection) {\n             _collection = candidateCollection;\n             if (_collection != null)\n                 _extent = null;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -384,8 +375,7 @@ public Class getCandidateType() {\n             // check again after compilation; maybe encoded in string\n             compileForCompilation();\n             return _class;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -399,8 +389,7 @@ public void setCandidateType(Class candidateClass, boolean subs) {\n             _subclasses = subs;\n             _loader = null;\n             invalidateCompilation();\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -426,8 +415,7 @@ public void setResultMapping(Class scope, String name) {\n             _resultMappingScope = scope;\n             _resultMappingName = name;\n             _packer = null;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -453,8 +441,7 @@ public boolean isUnique() {\n             if (!ex.isAggregate(_storeQuery))\n                 return false;\n             return !ex.hasGrouping(_storeQuery);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -465,8 +452,7 @@ public void setUnique(boolean unique) {\n             assertOpen();\n             assertNotReadOnly();\n             _unique = (unique) ? Boolean.TRUE : Boolean.FALSE;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -482,8 +468,7 @@ public Class getResultType() {\n             // check again after compilation; maybe encoded in string\n             compileForCompilation();\n             return _resultClass;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -495,8 +480,7 @@ public void setResultType(Class cls) {\n             // allowed modification: no read-only check\n             _resultClass = cls;\n             _packer = null;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -512,8 +496,7 @@ public long getStartRange() {\n             // check again after compilation; maybe encoded in string\n             compileForCompilation();\n             return _startIdx;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -529,8 +512,7 @@ public long getEndRange() {\n             // check again after compilation; maybe encoded in string\n             compileForCompilation();\n             return _endIdx;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -550,8 +532,7 @@ public void setRange(long start, long end) {\n             // allowed modification: no read-only check\n             _startIdx = start;\n             _endIdx = end;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -566,8 +547,7 @@ public String getParameterDeclaration() {\n \n             compileForCompilation();\n             return _params;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -587,8 +567,7 @@ public void declareParameters(String params) {\n                 params = null;\n             _params = params;\n             invalidateCompilation();\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -598,8 +577,7 @@ public void compile() {\n         try {\n             assertOpen();\n             getResultPacker(compileForExecutor());\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -620,14 +598,11 @@ private Compilation compileForCompilation() {\n         try {\n             _compiled = newCompilation();\n             return _compiled;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n-        }\n-        finally {\n+        } finally {\n             _compiling = false;\n             _readOnly = readOnly;\n         }\n@@ -727,11 +702,9 @@ else if (_subclasses)\n                     es[i] = _storeQuery.newDataStoreExecutor(metas[i], true);\n             }\n             return new MergedExecutor(es, this);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw new GeneralException(re);\n         }\n     }\n@@ -794,14 +767,11 @@ private Object execute(int operation, Object[] params) {\n                 if (operation == OP_UPDATE)\n                     return update(ex, params);\n                 throw new UnsupportedException();\n-            }\n-            catch (OpenJPAException ke) {\n+            } catch (OpenJPAException ke) {\n                 throw ke;\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 throw new UserException(e);\n-            }\n-            finally {\n+            } finally {\n                 _broker.endOperation();\n             }\n         }\n@@ -838,14 +808,11 @@ private Object execute(int operation, Map params) {\n                 if (operation == OP_UPDATE)\n                     return update(ex, params);\n                 throw new UnsupportedException();\n-            }\n-            catch (OpenJPAException ke) {\n+            } catch (OpenJPAException ke) {\n                 throw ke;\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 throw new UserException(e);\n-            }\n-            finally {\n+            } finally {\n                 _broker.endOperation();\n             }\n         }\n@@ -981,8 +948,7 @@ private Object execute(StoreQuery.Executor ex, Object[] params)\n             _startIdx, _endIdx);\n         try {\n             return toResult(ex, rop, lrs);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             if (rop != null)\n                 try {\n                     rop.close();\n@@ -1011,8 +977,7 @@ private Object execute(StoreQuery.Executor ex, Map params)\n             _startIdx, _endIdx);\n         try {\n             return toResult(ex, rop, lrs);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             if (rop != null)\n                 try {\n                     rop.close();\n@@ -1059,11 +1024,9 @@ public Number deleteInMemory(StoreQuery.Executor executor,\n             for (Iterator i = ((Collection) o).iterator(); i.hasNext(); size++)\n                 _broker.delete(i.next(), null);\n             return Numbers.valueOf(size);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new UserException(e);\n         }\n     }\n@@ -1105,11 +1068,9 @@ public Number updateInMemory(StoreQuery.Executor executor,\n             for (Iterator i = ((Collection) o).iterator(); i.hasNext(); size++)\n                 updateInMemory(i.next(), params);\n             return Numbers.valueOf(size);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new UserException(e);\n         }\n     }\n@@ -1348,8 +1309,7 @@ private Object singleResult(ResultObjectProvider rop)\n \n             // return single result\n             return single;\n-        }\n-        finally {\n+        } finally {\n             rop.close();\n         }\n     }\n@@ -1423,8 +1383,7 @@ private void closeResults(boolean force) {\n                     res.close(false);\n             }\n             _resultLists.clear();\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1443,14 +1402,11 @@ private void closeResults(boolean force) {\n             Object[] arr = toParameterArray(ex.getParameterTypes(_storeQuery),\n                 params);\n             return ex.getDataStoreActions(_storeQuery, arr, _startIdx, _endIdx);\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new UserException(e);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1492,8 +1448,7 @@ public boolean setQuery(Object query) {\n             if (q._aggListeners != null)\n                 _aggListeners = new HashMap(q._aggListeners);\n             return true;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1505,8 +1460,7 @@ public String getAlias() {\n             if (alias == null)\n                 alias = Strings.getClassName(_class);\n             return alias;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1515,8 +1469,7 @@ public String getAlias() {\n         lock();\n         try {\n             return compileForExecutor().getProjectionAliases(_storeQuery);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1525,8 +1478,7 @@ public String getAlias() {\n         lock();\n         try {\n             return compileForExecutor().getProjectionTypes(_storeQuery);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1535,8 +1487,7 @@ public int getOperation() {\n         lock();\n         try {\n             return compileForExecutor().getOperation(_storeQuery);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1545,8 +1496,7 @@ public boolean isAggregate() {\n         lock();\n         try {\n             return compileForExecutor().isAggregate(_storeQuery);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1555,8 +1505,7 @@ public boolean hasGrouping() {\n         lock();\n         try {\n             return compileForExecutor().hasGrouping(_storeQuery);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1567,8 +1516,7 @@ public boolean hasGrouping() {\n             ClassMetaData[] metas = compileForExecutor().\n                 getAccessPathMetaDatas(_storeQuery);\n             return (metas == null) ? StoreQuery.EMPTY_METAS : metas;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1577,8 +1525,7 @@ public LinkedMap getParameterTypes() {\n         lock();\n         try {\n             return compileForExecutor().getParameterTypes(_storeQuery);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1587,8 +1534,7 @@ public Map getUpdates() {\n         lock();\n         try {\n             return compileForExecutor().getUpdates(_storeQuery);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1607,8 +1553,7 @@ public Object getCompilation() {\n         lock();\n         try {\n             return compileForCompilation().storeData;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1677,10 +1622,8 @@ private Class toClass(String name) {\n                 getClassLoader(_class, _broker.getClassLoader());\n         try {\n             return Strings.toClass(name, _loader);\n-        }\n-        catch (RuntimeException re) {\n-        }\n-        catch (NoClassDefFoundError ncdfe) {\n+        } catch (RuntimeException re) {\n+        } catch (NoClassDefFoundError ncdfe) {\n         }\n         return null;\n     }\n@@ -2127,8 +2070,7 @@ public void close(boolean remove) {\n                         break;\n                     }\n                 }\n-            }\n-            finally {\n+            } finally {\n                 unlock();\n             }\n         }"},{"sha":"dd408eb6b335472815ffe0b73d78a878937642f0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -43,11 +43,9 @@\n             ExpressionParser ep;\n             try {\n                 ep = (ExpressionParser) classes[i].newInstance();\n-            }\n-            catch (InstantiationException e) {\n+            } catch (InstantiationException e) {\n                 throw new InternalException(e);\n-            }\n-            catch (IllegalAccessException e) {\n+            } catch (IllegalAccessException e) {\n                 throw new InternalException(e);\n             }\n             _expressionParsers.put(ep.getLanguage(), ep);"},{"sha":"652e8502e50670f10196f6fe68c42ac2c503d76e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -45,11 +45,9 @@ public boolean initialize(OpenJPAStateManager sm, PCState state,\n             try {\n                 ((PCResultObjectProvider) context).initialize\n                     (sm, state, fetchState);\n-            }\n-            catch (OpenJPAException ke) {\n+            } catch (OpenJPAException ke) {\n                 throw ke;\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 throw new StoreException(e);\n             }\n             return true;"},{"sha":"5ffb30f049593694772505a8f4a2197985a4f9d8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java","status":"modified","additions":4,"deletions":8,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -113,8 +113,7 @@ private ResultPacker(Class candidate, Class[] types, String[] aliases,\n             if (types != null && types.length > 0) {\n                 try {\n                     cons = _resultClass.getConstructor(types);\n-                }\n-                catch (NoSuchMethodException nsme) {\n+                } catch (NoSuchMethodException nsme) {\n                 }\n             }\n             _constructor = cons;\n@@ -243,15 +242,12 @@ private Object packUserType(Object[] result) {\n                 }\n             }\n             return user;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (InstantiationException ie) {\n+        } catch (InstantiationException ie) {\n             throw new UserException(_loc.get(\"pack-instantiation-err\",\n                 _resultClass), ie);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new UserException(_loc.get(\"pack-err\", _resultClass), e);\n         }\n     }"},{"sha":"f2dab979105fc17f56d0db5c8894aa17e7ff97d4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":53,"deletions":106,"changes":159,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -216,8 +216,7 @@ else if (wasPending && !_state.isPendingTransactional())\n             _state.initialize(this);\n             if (_state.isDeleted() && !wasDeleted)\n                 fireLifecycleEvent(LifecycleEvent.AFTER_DELETE);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -463,8 +462,7 @@ public boolean assignObjectId(boolean flush) {\n         lock();\n         try {\n             return assignObjectId(flush, false);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -509,8 +507,7 @@ private void assertObjectIdAssigned(boolean recache) {\n             try {\n                 _broker.setStateManager(orig, this,\n                     BrokerImpl.STATUS_OID_ASSIGN);\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 _id = orig;\n                 _oid = null;\n                 throw re;\n@@ -769,8 +766,7 @@ public Object fetchInitialField(int field) {\n \n             provideField(_saved.getState(), _single, field);\n             return fetchField(_single, fmd);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -814,8 +810,7 @@ public void setRemote(int field, Object value) {\n             storeField(field, value, _single);\n             replaceField(_pc, _single, field);\n             postDirty(stat);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1025,8 +1020,7 @@ void release(boolean unproxy, boolean force) {\n                 setPCState(PCState.TRANSIENT);\n             else\n                 setPCState(_state.release(this));\n-        }\n-        finally {\n+        } finally {\n             _flags &= ~FLAG_NO_UNPROXY;\n         }\n     }\n@@ -1093,8 +1087,7 @@ public boolean beforeRefresh(boolean refreshAll) {\n                 return true;\n             }\n             return false;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1113,8 +1106,7 @@ else if (_broker.getOptimistic())\n                 setPCState(_state.afterOptimisticRefresh());\n             else\n                 setPCState(_state.afterRefresh());\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1221,8 +1213,7 @@ public boolean serializing() {\n             load(_broker.getFetchConfiguration().newFetchState(),\n                 LOAD_SERIALIZE, null, null, false);\n             return false;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -1245,11 +1236,9 @@ public boolean writeDetached(ObjectOutput out)\n                 _single.clear();\n             }\n             return true;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n-        }\n-        finally {\n+        } finally {\n             _flags &= ~FLAG_DETACHING;\n             unlock();\n         }\n@@ -1304,8 +1293,7 @@ public Object fetchObjectId() {\n             if (_meta.getIdentityType() == ClassMetaData.ID_DATASTORE)\n                 return _broker.getStoreManager().copyDataStoreId(_oid, _meta);\n             return ApplicationIds.copy(_oid, _meta);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -1325,8 +1313,7 @@ public void accessingField(int field) {\n         try {\n             beforeRead(field);\n             beforeAccessField(field);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -1344,11 +1331,9 @@ protected void beforeAccessField(int field) {\n             else\n                 assignField(field, false);\n             obtainLocks(active, false, lockLevel, null, null);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1467,11 +1452,9 @@ private Boolean dirty(int field, Boolean mutate, boolean loadFetchGroup) {\n                     loadField(field, lockLevel, true, true);\n             }\n             obtainLocks(active, true, lockLevel, null, null);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n-        }\n-        finally {\n+        } finally {\n             if (locked)\n                 unlock();\n         }\n@@ -1510,8 +1493,7 @@ public void removed(int field, Object removed, boolean key) {\n                 _single.delete(vmd, removed, null);\n             else if (vmd.getCascadeDelete() == ValueMetaData.CASCADE_AUTO)\n                 _single.dereferenceDependent(removed);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n@@ -1573,8 +1555,7 @@ public boolean isDefaultValue(int field) {\n             boolean ret = _single.isDefaultValue();\n             _single.clear();\n             return ret;\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1597,8 +1578,7 @@ public void settingBooleanField(PersistenceCapable pc, int field,\n             _single.storeBooleanField(field, newVal);\n             replaceField(pc, _single, field);\n             postDirty(stat);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1617,8 +1597,7 @@ public void settingByteField(PersistenceCapable pc, int field,\n             _single.storeByteField(field, newVal);\n             replaceField(pc, _single, field);\n             postDirty(stat);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1637,8 +1616,7 @@ public void settingCharField(PersistenceCapable pc, int field,\n             _single.storeCharField(field, newVal);\n             replaceField(pc, _single, field);\n             postDirty(stat);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1657,8 +1635,7 @@ public void settingDoubleField(PersistenceCapable pc, int field,\n             _single.storeDoubleField(field, newVal);\n             replaceField(pc, _single, field);\n             postDirty(stat);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1677,8 +1654,7 @@ public void settingFloatField(PersistenceCapable pc, int field,\n             _single.storeFloatField(field, newVal);\n             replaceField(pc, _single, field);\n             postDirty(stat);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1697,8 +1673,7 @@ public void settingIntField(PersistenceCapable pc, int field,\n             _single.storeIntField(field, newVal);\n             replaceField(pc, _single, field);\n             postDirty(stat);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1717,8 +1692,7 @@ public void settingLongField(PersistenceCapable pc, int field,\n             _single.storeLongField(field, newVal);\n             replaceField(pc, _single, field);\n             postDirty(stat);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1772,8 +1746,7 @@ public void settingObjectField(PersistenceCapable pc, int field,\n             _single.storeObjectField(field, newVal);\n             replaceField(pc, _single, field);\n             postDirty(stat);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1792,8 +1765,7 @@ public void settingShortField(PersistenceCapable pc, int field,\n             _single.storeShortField(field, newVal);\n             replaceField(pc, _single, field);\n             postDirty(stat);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1812,8 +1784,7 @@ public void settingStringField(PersistenceCapable pc, int field,\n             _single.storeStringField(field, newVal);\n             replaceField(pc, _single, field);\n             postDirty(stat);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1954,8 +1925,7 @@ public boolean fetchBooleanField(int field) {\n \n             provideField(_pc, _single, field);\n             return _single.fetchBooleanField(field);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -1977,8 +1947,7 @@ public byte fetchByteField(int field) {\n \n             provideField(_pc, _single, field);\n             return _single.fetchByteField(field);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2000,8 +1969,7 @@ public char fetchCharField(int field) {\n \n             provideField(_pc, _single, field);\n             return _single.fetchCharField(field);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2023,8 +1991,7 @@ public double fetchDoubleField(int field) {\n \n             provideField(_pc, _single, field);\n             return _single.fetchDoubleField(field);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2046,8 +2013,7 @@ public float fetchFloatField(int field) {\n \n             provideField(_pc, _single, field);\n             return _single.fetchFloatField(field);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2069,8 +2035,7 @@ public int fetchIntField(int field) {\n \n             provideField(_pc, _single, field);\n             return _single.fetchIntField(field);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2092,8 +2057,7 @@ public long fetchLongField(int field) {\n \n             provideField(_pc, _single, field);\n             return _single.fetchLongField(field);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2115,8 +2079,7 @@ public Object fetchObjectField(int field) {\n \n             provideField(_pc, _single, field);\n             return _single.fetchObjectField(field);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2138,8 +2101,7 @@ public short fetchShortField(int field) {\n \n             provideField(_pc, _single, field);\n             return _single.fetchShortField(field);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2161,8 +2123,7 @@ public String fetchStringField(int field) {\n \n             provideField(_pc, _single, field);\n             return _single.fetchStringField(field);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2184,8 +2145,7 @@ public void storeBooleanField(int field, boolean curVal) {\n             replaceField(_pc, _single, field);\n             setLoaded(field, true);\n             postLoad(field, null);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2206,8 +2166,7 @@ public void storeByteField(int field, byte curVal) {\n             replaceField(_pc, _single, field);\n             setLoaded(field, true);\n             postLoad(field, null);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2228,8 +2187,7 @@ public void storeCharField(int field, char curVal) {\n             replaceField(_pc, _single, field);\n             setLoaded(field, true);\n             postLoad(field, null);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2250,8 +2208,7 @@ public void storeDoubleField(int field, double curVal) {\n             replaceField(_pc, _single, field);\n             setLoaded(field, true);\n             postLoad(field, null);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2272,8 +2229,7 @@ public void storeFloatField(int field, float curVal) {\n             replaceField(_pc, _single, field);\n             setLoaded(field, true);\n             postLoad(field, null);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2294,8 +2250,7 @@ public void storeIntField(int field, int curVal) {\n             replaceField(_pc, _single, field);\n             setLoaded(field, true);\n             postLoad(field, null);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2316,8 +2271,7 @@ public void storeLongField(int field, long curVal) {\n             replaceField(_pc, _single, field);\n             setLoaded(field, true);\n             postLoad(field, null);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2339,8 +2293,7 @@ public void storeObjectField(int field, Object curVal) {\n             replaceField(_pc, _single, field);\n             setLoaded(field, true);\n             postLoad(field, null);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2361,8 +2314,7 @@ public void storeShortField(int field, short curVal) {\n             replaceField(_pc, _single, field);\n             setLoaded(field, true);\n             postLoad(field, null);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2382,8 +2334,7 @@ public void storeStringField(int field, String curVal) {\n             replaceField(_pc, _single, field);\n             setLoaded(field, true);\n             postLoad(field, null);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2523,8 +2474,7 @@ void clearFields() {\n             _loadVersion = null;\n             if (_fieldImpl != null)\n                 Arrays.fill(_fieldImpl, null);\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n \n@@ -2644,8 +2594,7 @@ void proxyFields(boolean reset, boolean replaceNull) {\n                         _single.clear();\n                 }\n             }\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2696,8 +2645,7 @@ void preFlush(boolean logical, OpCallbacks call) {\n                         _single.clear();\n                 }\n             }\n-        }\n-        finally {\n+        } finally {\n             unlock();\n         }\n     }\n@@ -2713,8 +2661,7 @@ void preDelete() {\n             _flags |= FLAG_PRE_DELETING;\n             try {\n                 fireLifecycleEvent(LifecycleEvent.BEFORE_DELETE);\n-            }\n-            finally {\n+            } finally {\n                 _flags &= ~FLAG_PRE_DELETING;\n             }\n         }"},{"sha":"7320eccd3418bc41a79537f0de56553fa0ed70cb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -139,8 +139,7 @@ public Object attach(AttachManager manager, Object toAttach,\n                         break;\n                 }\n             }\n-        }\n-        finally {\n+        } finally {\n             pc.pcReplaceStateManager(null);\n         }\n         if (!embedded && !isNew)"},{"sha":"22dfd561df51ab84818a8c6dcdd0f5e78c5963a0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -77,8 +77,7 @@ public void lock(OpenJPAStateManager sm, int level, int timeout,\n         setLockLevel(sm, level);\n         try {\n             lockInternal(sm, level, timeout, sdata);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             // revert lock\n             setLockLevel(sm, oldlevel);\n             throw re;"},{"sha":"128e8e8d2d84790af5e86ab49e5d52c07a94edc0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -281,8 +281,7 @@ protected Value traversePath(Path path, String field, boolean pcOnly,\n     protected Object traverseStaticField(Class cls, String field) {\n         try {\n             return cls.getField(field).get(null);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             // count not locate the field: return null\n             return null;\n         }"},{"sha":"7e5dda7f8d19b7d00be28b029b801861da1ab984","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -142,8 +142,7 @@ protected Object eval(Object candidate, Object orig,\n                 // get the specified field value and switch candidate\n                 Traversal traversal = (Traversal) action;\n                 candidate = sm.fetchField(traversal.field.getIndex(), true);\n-            }\n-            finally {\n+            } finally {\n                 // transactional does not clear the state, which is\n                 // important since tmpCandidate might be also managed by\n                 // another broker if it's a proxied non-pc instance"},{"sha":"271b2542e0a11de4cb478bfe638255fe1c73a389","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java","status":"modified","additions":4,"deletions":8,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -34,11 +34,9 @@ public final boolean evaluate(Object candidate, Object orig,\n         StoreContext ctx, Object[] params) {\n         try {\n             return eval(candidate, candidate, ctx, params);\n-        }\n-        catch (ClassCastException cce) {\n+        } catch (ClassCastException cce) {\n             return false;\n-        }\n-        catch (NullPointerException npe) {\n+        } catch (NullPointerException npe) {\n             return false;\n         }\n     }\n@@ -50,11 +48,9 @@ public final boolean evaluate(Collection candidates,\n         StoreContext ctx, Object[] params) {\n         try {\n             return eval(candidates, ctx, params);\n-        }\n-        catch (ClassCastException cce) {\n+        } catch (ClassCastException cce) {\n             return false;\n-        }\n-        catch (NullPointerException npe) {\n+        } catch (NullPointerException npe) {\n             return false;\n         }\n     }"},{"sha":"8f0657bbad060570d49df6b506143e9161bda954","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java","status":"modified","additions":3,"deletions":6,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -105,8 +105,7 @@ private boolean matches(Exp exp, Object candidate, StoreContext ctx,\n \n             // no match\n             return false;\n-        }\n-        finally {\n+        } finally {\n             ImplHelper.close(itr);\n         }\n     }\n@@ -208,8 +207,7 @@ private boolean matches(Exp exp, Collection group, StoreContext ctx,\n \n             // no match\n             return false;\n-        }\n-        finally {\n+        } finally {\n             ImplHelper.close(itr);\n         }\n     }\n@@ -713,8 +711,7 @@ public int compare(Object o1, Object o2) {\n                 if (_asc)\n                     return ((Comparable) o1).compareTo(o2);\n                 return ((Comparable) o2).compareTo(o1);\n-            }\n-            catch (ClassCastException cce) {\n+            } catch (ClassCastException cce) {\n                 Localizer loc = Localizer.forPackage\n                     (InMemoryExpressionFactory.class);\n                 throw new UserException(loc.get(\"not-comp\", o1, o2));"},{"sha":"8483b309362c70a1d0d3e3731f96bf693b32fd99","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","status":"modified","additions":4,"deletions":8,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -41,11 +41,9 @@ public final Object evaluate(Object candidate, Object orig,\n         StoreContext ctx, Object[] params) {\n         try {\n             return eval(candidate, candidate, ctx, params);\n-        }\n-        catch (NullPointerException npe) {\n+        } catch (NullPointerException npe) {\n             return null;\n-        }\n-        catch (ClassCastException cce) {\n+        } catch (ClassCastException cce) {\n             return null;\n         }\n     }\n@@ -61,11 +59,9 @@ public final Object evaluate(Collection candidates, Object orig,\n             if (c.isEmpty())\n                 return null;\n             return c.iterator().next();\n-        }\n-        catch (NullPointerException npe) {\n+        } catch (NullPointerException npe) {\n             return null;\n-        }\n-        catch (ClassCastException cce) {\n+        } catch (ClassCastException cce) {\n             return null;\n         }\n     }"},{"sha":"1fdb85455970ef92a8a45a749a71afdf53087cb6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","status":"modified","additions":6,"deletions":12,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -1113,8 +1113,7 @@ private Value getSubquery(JPQLNode node) {\n             QueryExpressions subexp = getQueryExpressions();\n             subq.setQueryExpressions(subexp, 0, Long.MAX_VALUE);\n             return subq;\n-        }\n-        finally {\n+        } finally {\n             // remove the subquery parse context\n             contexts.pop();\n         }\n@@ -1138,8 +1137,7 @@ private Parameter getParameter(String id, boolean positional) {\n                 // indexes in JPQL are 1-based, as opposed to 0-based in\n                 // the core ExpressionFactory\n                 index = Integer.parseInt(id) - 1;\n-            }\n-            catch (NumberFormatException e) {\n+            } catch (NumberFormatException e) {\n                 throw parseException(EX_USER, \"bad-positional-parameter\",\n                     new Object[]{ id }, e);\n             }\n@@ -1233,12 +1231,10 @@ private Value getPathOrConstant(JPQLNode node) {\n                 Field field = c.getField(fieldName);\n                 Object value = field.get(null);\n                 return factory.newLiteral(value, Literal.TYPE_UNKNOWN);\n-            }\n-            catch (NoSuchFieldException nsfe) {\n+            } catch (NoSuchFieldException nsfe) {\n                 throw parseException(EX_USER, \"no-field\",\n                     new Object[]{ className, fieldName }, nsfe);\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 throw parseException(EX_USER, \"unaccessible-field\",\n                     new Object[]{ className, fieldName }, e);\n             }\n@@ -1629,14 +1625,12 @@ public void dump(PrintStream out, String prefix, boolean text) {\n         private static final JPQLNode parse(String jpql) {\n             try {\n                 return (JPQLNode) new JPQL(jpql).parseQuery();\n-            }\n-            catch (Error e) {\n+            } catch (Error e) {\n                 // special handling for Error subclasses, which the\n                 // parser may sometimes (unfortunately) throw\n                 throw new UserException(_loc.get(\"parse-error\",\n                     new Object[]{ e.toString(), jpql }));\n-            }\n-            catch (ParseException e) {\n+            } catch (ParseException e) {\n                 throw new UserException(_loc.get(\"parse-error\",\n                     new Object[]{ e.toString(), jpql }), e);\n             }"},{"sha":"b4f91ebeecd1167bafd85dbb84f8b4be8fe880e8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -57,11 +57,9 @@ public QueryExpressions eval(Object parsed, ExpressionStoreQuery query,\n         try {\n             return new JPQLExpressionBuilder(factory, query, parsed).\n                 getQueryExpressions();\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new UserException(_loc.get(\"bad-jpql\", parsed), e);\n         }\n     }"},{"sha":"a241a408d484d0d0a22d6e97ba54db520be252fc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java","status":"modified","additions":6,"deletions":12,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -115,8 +115,7 @@ public void setURLs(String urls) {\n             try {\n                 for (int i = 0; i < strs.length; i++)\n                     this.urls.add(new URL(strs[i]));\n-            }\n-            catch (MalformedURLException mue) {\n+            } catch (MalformedURLException mue) {\n                 throw new UserException(mue);\n             }\n         }\n@@ -424,8 +423,7 @@ protected void parse(MetaDataParser parser, Collection files) {\n         try {\n             for (Iterator itr = files.iterator(); itr.hasNext();)\n                 parser.parse((File) itr.next());\n-        }\n-        catch (IOException ioe) {\n+        } catch (IOException ioe) {\n             throw new GeneralException(ioe);\n         }\n     }\n@@ -437,8 +435,7 @@ protected void parse(MetaDataParser parser, Class[] cls) {\n         try {\n             for (int i = 0; i < cls.length; i++)\n                 parser.parse(cls[i], isParseTopDown());\n-        }\n-        catch (IOException ioe) {\n+        } catch (IOException ioe) {\n             throw new GeneralException(ioe);\n         }\n     }\n@@ -459,8 +456,7 @@ protected void serialize(MetaDataSerializer ser, Map output, int flags) {\n                 ser.serialize(flags);\n             else\n                 ser.serialize(output, flags);\n-        }\n-        catch (IOException ioe) {\n+        } catch (IOException ioe) {\n             throw new GeneralException(ioe);\n         }\n     }\n@@ -589,8 +585,7 @@ public Set getPersistentTypeNames(boolean devpath, ClassLoader envLoader) {\n                 log.info(_loc.get(\"found-pcs\", String.valueOf(names.size()),\n                     String.valueOf(System.currentTimeMillis() - start)));\n             return (names.isEmpty()) ? null : names;\n-        }\n-        catch (IOException ioe) {\n+        } catch (IOException ioe) {\n             throw new GeneralException(ioe);\n         }\n     }\n@@ -682,8 +677,7 @@ private void scan(MetaDataIterator mitr, ClassArgParser cparser, Set names,\n         Map map;\n         try {\n             map = cparser.mapTypeNames(mitr);\n-        }\n-        finally {\n+        } finally {\n             mitr.close();\n         }\n "},{"sha":"4e27140a992e2ca252cfbf6a9ea15740a5e9e146","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","status":"modified","additions":7,"deletions":14,"changes":21,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -155,15 +155,12 @@ private boolean populateFromPCRegistry(ClassMetaData meta) {\n                 populate(fmd);\n             }\n             return true;\n-        }\n-        catch (IllegalStateException iae) {\n+        } catch (IllegalStateException iae) {\n             // thrown by registry when no metadata available\n             return false;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new UserException(e);\n         }\n     }\n@@ -279,11 +276,9 @@ public Member getBackingMember(FieldMetaData fmd) {\n                 return fmd.getDeclaringType().getDeclaredField(fmd.getName());\n             return getBackingMethod(fmd.getDeclaringType(), fmd.getName(),\n                 fmd.getDeclaredType());\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new InternalException(e);\n         }\n     }\n@@ -303,16 +298,14 @@ private Method getBackingMethod(Class cls, String name,\n         do {\n             try {\n                 return cls.getDeclaredMethod(\"get\" + capName, (Class[]) null);\n-            }\n-            catch (NoSuchMethodException e) {\n+            } catch (NoSuchMethodException e) {\n             }\n \n             if (isBoolean) {\n                 try {\n                     return cls.getDeclaredMethod(\"is\" + capName,\n                         (Class[]) null);\n-                }\n-                catch (NoSuchMethodException e) {\n+                } catch (NoSuchMethodException e) {\n                 }\n             }\n             // ### EJB3: recursion should be limited to manageable types,"},{"sha":"8108c877819a687308a22322c85dd3091cd67b83","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","status":"modified","additions":8,"deletions":16,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -1280,8 +1280,7 @@ public Field getDetachedStateField() {\n             type = type.getSuperclass()) {\n             try {\n                 return type.getDeclaredField(fieldName);\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n             }\n         }\n         throw new MetaDataException(_loc.get(\"no-detach-state\", fieldName,\n@@ -1731,8 +1730,7 @@ private boolean hasConcretePCSuperclass() {\n     private void validateAppIdClassMethods(Class oid) {\n         try {\n             oid.getConstructor((Class[]) null);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new MetaDataException(_loc.get(\"null-cons\", _type)).\n                 setCause(e);\n         }\n@@ -1743,8 +1741,7 @@ private void validateAppIdClassMethods(Class oid) {\n         Method method;\n         try {\n             method = oid.getMethod(\"equals\", new Class[]{ Object.class });\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new GeneralException(e).setFatal(true);\n         }\n \n@@ -1754,8 +1751,7 @@ private void validateAppIdClassMethods(Class oid) {\n \n         try {\n             method = oid.getMethod(\"hashCode\", (Class[]) null);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new GeneralException(e).setFatal(true);\n         }\n         if (!abs && method.getDeclaringClass() == Object.class)\n@@ -1822,11 +1818,9 @@ private void validateAppIdClassPKs(ClassMetaData meta,\n                             _type)).setFailedObject(\"set\" + cap);\n                 }\n             }\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Throwable t) {\n+        } catch (Throwable t) {\n             throw new MetaDataException(_loc.get(\"invalid-id\", _type)).\n                 setCause(t);\n         }\n@@ -1842,8 +1836,7 @@ private static Field findField(Class c, String name, boolean pub)\n \n         try {\n             return (pub) ? c.getField(name) : c.getDeclaredField(name);\n-        }\n-        catch (NoSuchFieldException nsfe) {\n+        } catch (NoSuchFieldException nsfe) {\n             return (pub) ? null : findField(c.getSuperclass(), name, false);\n         }\n     }\n@@ -1860,8 +1853,7 @@ private static Method findMethod(Class c, String name, Class[] params,\n         try {\n             return (pub) ? c.getMethod(name, params)\n                 : c.getDeclaredMethod(name, params);\n-        }\n-        catch (NoSuchMethodException nsfe) {\n+        } catch (NoSuchMethodException nsfe) {\n             return (pub) ? null : findMethod(c.getSuperclass(), name, params,\n                 false);\n         }"},{"sha":"fb2c680bf7c8d8f4b0e1e48bdbc0902bcc2885f6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","status":"modified","additions":6,"deletions":12,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -113,8 +113,7 @@\n     static {\n         try {\n             DEFAULT_METHOD = Object.class.getMethod(\"wait\", (Class[]) null);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             // shouldn't ever happen\n             throw new InternalException(e);\n         }\n@@ -1101,11 +1100,9 @@ public Object getExternalValue(Object val, StoreContext ctx) {\n             if (externalizer.getParameterTypes().length == 0)\n                 return externalizer.invoke(val, (Object[]) null);\n             return externalizer.invoke(val, new Object[]{ ctx });\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new MetaDataException(_loc.get(\"externalizer-err\", this,\n                 Exceptions.toString(val), e.toString())).setCause(e);\n         }\n@@ -1142,8 +1139,7 @@ public Object getFieldValue(Object val, StoreContext ctx) {\n             if (meth.getParameterTypes().length == 1)\n                 return meth.invoke(null, new Object[]{ val });\n             return meth.invoke(null, new Object[]{ val, ctx });\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             // unwrap cause\n             if (e instanceof InvocationTargetException) {\n                 Throwable t = ((InvocationTargetException) e).\n@@ -1338,11 +1334,9 @@ public Member getFactoryMethod() {\n                             (new Class[]{ getType() });\n                     else\n                         _factMethod = findMethod(_factName);\n-                }\n-                catch (OpenJPAException ke) {\n+                } catch (OpenJPAException ke) {\n                     throw ke;\n-                }\n-                catch (Exception e) {\n+                } catch (Exception e) {\n                 }\n \n                 if (!(_factMethod instanceof Constructor)"},{"sha":"5582c55e6a16aca4a46fcf11fd7c6775d4039f9e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","status":"modified","additions":12,"deletions":24,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -408,8 +408,7 @@ private ClassMetaData getMetaDataInternal(Class cls,\n                 try {\n                     Class.forName(cls.getName(), true,\n                         cls.getClassLoader());\n-                }\n-                catch (Throwable t) {\n+                } catch (Throwable t) {\n                 }\n             }\n         }\n@@ -571,8 +570,7 @@ private void loadMapping(ClassMetaData meta) {\n                 try {\n                     _factory.load(meta.getDescribedType(), mode,\n                         meta.getEnvClassLoader());\n-                }\n-                catch (RuntimeException re) {\n+                } catch (RuntimeException re) {\n                     removeMetaData(meta);\n                     _errs.add(re);\n                     return;\n@@ -589,8 +587,7 @@ private void loadMapping(ClassMetaData meta) {\n                 prepareMapping(meta);\n             } else\n                 meta.defineSuperclassFields(false);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             removeMetaData(meta);\n             _errs.add(re);\n         }\n@@ -612,8 +609,7 @@ private boolean resolveMapping(ClassMetaData meta) {\n                 meta = (ClassMetaData) mapped.get(i);\n                 try {\n                     meta.resolve(MODE_MAPPING_INIT);\n-                }\n-                catch (RuntimeException re) {\n+                } catch (RuntimeException re) {\n                     removeMetaData(meta);\n                     _errs.add(re);\n                 }\n@@ -645,8 +641,7 @@ private List processBuffer(ClassMetaData meta, SortedSet buffer, int mode) {\n                 buffered.resolve(mode);\n                 processed.add(buffered);\n                 buffer.remove(buffered);\n-            }\n-            catch (RuntimeException re) {\n+            } catch (RuntimeException re) {\n                 _errs.add(re);\n \n                 // any exception during resolution of one type means we can't\n@@ -937,8 +932,7 @@ private void resolveIdentityClass(Object oid) {\n \n                 try {\n                     Class.forName(className.substring(0, i), true, cl);\n-                }\n-                catch (Exception e) {\n+                } catch (Exception e) {\n                 } // consume all exceptions\n             }\n \n@@ -1059,8 +1053,7 @@ public synchronized Collection loadPersistentTypes(boolean devpath,\n     private Class classForName(String name, ClassLoader loader) {\n         try {\n             return Class.forName(name, true, loader);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             if ((_validate & VALIDATE_RUNTIME) != 0) {\n                 if (_log.isWarnEnabled())\n                     _log.warn(_loc.get(\"bad-discover-class\", name));\n@@ -1104,8 +1097,7 @@ private void loadRegisteredClassMetaData(ClassLoader envLoader) {\n         for (int i = 0; i < reg.length; i++) {\n             try {\n                 getMetaData(reg[i], envLoader, false);\n-            }\n-            catch (MetaDataException me) {\n+            } catch (MetaDataException me) {\n                 if (_log.isWarnEnabled())\n                     _log.warn(me);\n             }\n@@ -1131,8 +1123,7 @@ private void loadRegisteredClassMetaData(ClassLoader envLoader) {\n         for (int i = 0; i < reg.length; i++) {\n             try {\n                 processRegisteredClass(reg[i]);\n-            }\n-            catch (Throwable t) {\n+            } catch (Throwable t) {\n                 if (!_conf.getRetryClassRegistration())\n                     throw new MetaDataException(_loc.get(\"error-registered\",\n                         reg[i]), t);\n@@ -1181,8 +1172,7 @@ private void processRegisteredClass(Class cls) {\n         Object oid = null;\n         try {\n             oid = PCRegistry.newObjectId(cls);\n-        }\n-        catch (InternalException ie) {\n+        } catch (InternalException ie) {\n             // thrown for single field identity with null pk field value\n         }\n         if (oid != null) {\n@@ -1436,8 +1426,7 @@ SequenceMetaData getSequenceMetaData(ClassMetaData context, String name,\n                 context.getEnvClassLoader(), mustExist);\n             if (seq != null)\n                 return seq;\n-        }\n-        catch (MetaDataException mde) {\n+        } catch (MetaDataException mde) {\n             e = mde;\n         }\n \n@@ -1454,8 +1443,7 @@ SequenceMetaData getSequenceMetaData(ClassMetaData context, String name,\n         try {\n             return getSequenceMetaData(name, context.getEnvClassLoader(),\n                 mustExist);\n-        }\n-        catch (MetaDataException mde) {\n+        } catch (MetaDataException mde) {\n             // throw original exception\n             if (e != null)\n                 throw e;"},{"sha":"a4dcfd10f635f2f7e5098eff2440a5beca5c8ae6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataTool.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataTool.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataTool.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -252,8 +252,7 @@ public static void main(String[] args)\n         try {\n             if (!run(conf, args, opts))\n                 System.err.println(_loc.get(\"tool-usage\"));\n-        }\n-        finally {\n+        } finally {\n             conf.close();\n         }\n     }\n@@ -323,8 +322,7 @@ public static boolean run(OpenJPAConfiguration conf, String[] args,\n                 log.info(_loc.get(\"tool-running\", classes[j], flags.action));\n                 try {\n                     tool.run(classes[j]);\n-                }\n-                catch (IllegalArgumentException iae) {\n+                } catch (IllegalArgumentException iae) {\n                     return false;\n                 }\n             }"},{"sha":"38d3f85d55c3260147e78ec06984b937d1e3d6c5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/SequenceMetaData.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/SequenceMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/SequenceMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/SequenceMetaData.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -266,11 +266,9 @@ protected Seq instantiate(ClassLoader envLoader) {\n                 throw new MetaDataException(_loc.get(\"not-seq-cls\", _name,\n                     cls));\n             return seq;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new MetaDataException(_loc.get(\"cant-init-seq\", _name)).\n                 setCause(e);\n         }"},{"sha":"b84ce7320b2e081d60057f4edab8077a86c2b573","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyCollection.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyCollection.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyCollection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyCollection.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -171,8 +171,7 @@ public boolean retainAll(Collection all) {\n                 }\n             }\n             return removed;\n-        }\n-        finally {\n+        } finally {\n             itr.close();\n         }\n     }\n@@ -227,8 +226,7 @@ private List asList() {\n             while (itr.hasNext())\n                 list.add(itr.next());\n             return list;\n-        }\n-        finally {\n+        } finally {\n             itr.close();\n         }\n     }"},{"sha":"e0797ca109113c6347a422e80fbf1625fe0219f6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyMap.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyMap.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyMap.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -301,8 +301,7 @@ protected Object writeReplace()\n                 map.put(entry.getKey(), entry.getValue());\n             }\n             return map;\n-        }\n-        finally {\n+        } finally {\n             itr.close();\n         }\n     }"},{"sha":"b44ace79105e16f04e24b038fa7bb6e6d5ae5dc2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java","status":"modified","additions":5,"deletions":10,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -95,11 +95,9 @@\n                 }\n             }\n             return pks;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Throwable t) {\n+        } catch (Throwable t) {\n             throw new GeneralException(t);\n         }\n     }\n@@ -203,8 +201,7 @@ public static Object fromPKValues(Object[] pks, ClassMetaData meta) {\n             if (meta.isObjectIdTypeShared())\n                 copy = new ObjectId(meta.getDescribedType(), copy);\n             return copy;\n-        }\n-        catch (Throwable t) {\n+        } catch (Throwable t) {\n             throw new GeneralException(t);\n         }\n     }\n@@ -315,11 +312,9 @@ private static Object copy(Object oid, ClassMetaData meta,\n                 }\n             }\n             return copy;\n-        }\n-        catch (OpenJPAException ke) {\n+        } catch (OpenJPAException ke) {\n             throw ke;\n-        }\n-        catch (Throwable t) {\n+        } catch (Throwable t) {\n             throw new GeneralException(t);\n         }\n     }"},{"sha":"fbfbf0987c9fd4ccb502bdd84c7583211689ce44","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","status":"modified","additions":13,"deletions":26,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -211,8 +211,7 @@ public void setCacheSize(int size) {\n         writeLock();\n         try {\n             cacheMap.setMaxSize((size < 0) ? Integer.MAX_VALUE : size);\n-        }\n-        finally {\n+        } finally {\n             writeUnlock();\n         }\n     }\n@@ -232,8 +231,7 @@ public void setSoftReferenceSize(int size) {\n         writeLock();\n         try {\n             softMap.setMaxSize((size < 0) ? Integer.MAX_VALUE : size);\n-        }\n-        finally {\n+        } finally {\n             writeUnlock();\n         }\n     }\n@@ -253,8 +251,7 @@ public Set getPinnedKeys() {\n         readLock();\n         try {\n             return Collections.unmodifiableSet(pinnedMap.keySet());\n-        }\n-        finally {\n+        } finally {\n             readUnlock();\n         }\n     }\n@@ -287,8 +284,7 @@ public boolean pin(Object key) {\n                 return true;\n             }\n             return false;\n-        }\n-        finally {\n+        } finally {\n             writeUnlock();\n         }\n     }\n@@ -307,8 +303,7 @@ public boolean unpin(Object key) {\n                 return true;\n             }\n             return false;\n-        }\n-        finally {\n+        } finally {\n             writeUnlock();\n         }\n     }\n@@ -353,8 +348,7 @@ public Object get(Object key) {\n                     put(key, val);\n             }\n             return val;\n-        }\n-        finally {\n+        } finally {\n             readUnlock();\n         }\n     }\n@@ -396,8 +390,7 @@ public Object put(Object key, Object value) {\n                 entryAdded(key, value);\n             }\n             return val;\n-        }\n-        finally {\n+        } finally {\n             writeUnlock();\n         }\n     }\n@@ -437,8 +430,7 @@ public Object remove(Object key) {\n                 entryRemoved(key, val, false);\n \n             return val;\n-        }\n-        finally {\n+        } finally {\n             writeUnlock();\n         }\n     }\n@@ -458,8 +450,7 @@ public void clear() {\n \n             notifyEntryRemovals(softMap.entrySet());\n             softMap.clear();\n-        }\n-        finally {\n+        } finally {\n             writeUnlock();\n         }\n     }\n@@ -477,8 +468,7 @@ public int size() {\n         readLock();\n         try {\n             return _pinnedSize + cacheMap.size() + softMap.size();\n-        }\n-        finally {\n+        } finally {\n             readUnlock();\n         }\n     }\n@@ -493,8 +483,7 @@ public boolean containsKey(Object key) {\n             return pinnedMap.get(key) != null\n                 || cacheMap.containsKey(key)\n                 || softMap.containsKey(key);\n-        }\n-        finally {\n+        } finally {\n             readUnlock();\n         }\n     }\n@@ -505,8 +494,7 @@ public boolean containsValue(Object val) {\n             return pinnedMap.containsValue(val)\n                 || cacheMap.containsValue(val)\n                 || softMap.containsValue(val);\n-        }\n-        finally {\n+        } finally {\n             readUnlock();\n         }\n     }\n@@ -528,8 +516,7 @@ public String toString() {\n         try {\n             return \"CacheMap:\" + cacheMap.toString() + \"::\"\n                 + softMap.toString();\n-        }\n-        finally {\n+        } finally {\n             readUnlock();\n         }\n     }"},{"sha":"076499e78f01909e9ab5886d45c6ab2fe717b629","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -68,8 +68,7 @@ private static boolean isSerializable(Object ob) {\n         try {\n             new ObjectOutputStream(DEV_NULL).writeObject(ob);\n             return true;\n-        }\n-        catch (Throwable t) {\n+        } catch (Throwable t) {\n             return false;\n         }\n     }\n@@ -109,8 +108,7 @@ public static String toString(Object ob) {\n             if (s.indexOf(ob.getClass().getName()) == -1)\n                 s += \" [\" + ob.getClass().getName() + \"]\";\n             return s;\n-        }\n-        catch (Throwable t) {\n+        } catch (Throwable t) {\n             return ob.getClass().getName();\n         }\n     }"},{"sha":"d230d0b233cff3a8df499aed11018981bc7452cf","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -80,8 +80,7 @@ public Id(String str, ClassLoader loader) {\n             int dash = str.indexOf('-');\n             try {\n                 type = Class.forName(str.substring(0, dash), true, loader);\n-            }\n-            catch (Throwable t) {\n+            } catch (Throwable t) {\n                 throw new UserException(_loc.get(\"string-id\", str), t);\n             }\n             _id = Long.parseLong(str.substring(dash + 1));"},{"sha":"a647c2ff5898787a1be9fd00b8404f3444c34d0c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","status":"modified","additions":5,"deletions":10,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -57,12 +57,10 @@ public static Method getGetter(Class cls, String prop) {\n         prop = StringUtils.capitalize(prop);\n         try {\n             return cls.getMethod(\"get\" + prop, (Class[]) null);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             try {\n                 return cls.getMethod(\"is\" + prop, (Class[]) null);\n-            }\n-            catch (Exception e2) {\n+            } catch (Exception e2) {\n                 throw new UserException(_loc.get(\"bad-getter\", cls,\n                     prop)).setCause(e);\n             }\n@@ -78,8 +76,7 @@ public static Method getSetter(Class cls, String prop) {\n         try {\n             return cls.getMethod(\"set\" + prop,\n                 new Class[]{ getter.getReturnType() });\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new UserException(_loc.get(\"bad-setter\", cls, prop)).\n                 setCause(e);\n         }\n@@ -178,11 +175,9 @@ public static void close(Object o) {\n         try {\n             if (o instanceof Closeable)\n                 ((Closeable) o).close();\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw re;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new GeneralException(e);\n         }\n     }"},{"sha":"c936a36094a3ce25e6710a130cde4957c9b3b987","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","status":"modified","additions":3,"deletions":6,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -74,8 +74,7 @@\n             cal = (ProxyGregorianCalendar) JavaVersions.\n                 getVersionSpecificClass(ProxyGregorianCalendar.class).\n                 newInstance();\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n         }\n \n         _calendars.put(Calendar.class, cal);\n@@ -201,8 +200,7 @@ public Object copyArray(Object orig) {\n \n             System.arraycopy(orig, 0, array, 0, length);\n             return array;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new UnsupportedException(_loc.get(\"bad-array\",\n                 e.getMessage()), e);\n         }\n@@ -256,8 +254,7 @@ private static Proxy findProxy(Class type, Class proxyType, Map proxies) {\n                 try {\n                     p = (Proxy) type.newInstance();\n                     proxies.put(type, p);\n-                }\n-                catch (Exception e) {\n+                } catch (Exception e) {\n                     throw new UnsupportedException(_loc.get(\"no-proxy-cons\",\n                         type), e);\n                 }"},{"sha":"78d7e4cb6e4c30fbc05ffce9afcd1f60aabd6f15","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/Serialization.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/Serialization.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-kernel/src/main/java/org/apache/openjpa/util/Serialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/Serialization.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -55,8 +55,7 @@\n             objs.writeObject(val);\n             objs.flush();\n             return bytes.toByteArray();\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new StoreException(e);\n         }\n     }\n@@ -77,8 +76,7 @@ public static Object deserialize(InputStream in, StoreContext ctx) {\n             if (ctx == null)\n                 return new ObjectInputStream(in).readObject();\n             return new PersistentObjectInputStream(in, ctx).readObject();\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw new StoreException(e);\n         }\n     }"},{"sha":"afedfef502153410418962e75d36b1ea1f777b0b","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/AbstractTask.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/AbstractTask.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/AbstractTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/AbstractTask.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -150,8 +150,7 @@ public void execute() throws BuildException {\n             e.printStackTrace();\n             if (haltOnError)\n                 throw new BuildException(e);\n-        }\n-        finally {\n+        } finally {\n             if (_conf != null)\n                 _conf.close();\n             _conf = null;"},{"sha":"0c15d1c0d59f6bcdd4760b3d2132671b44b34783","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -558,8 +558,7 @@ public static Object lookup(String name) {\n         } catch (NamingException ne) {\n             throw new NestableRuntimeException(_loc.get(\"naming-err\", name),\n                 ne);\n-        }\n-        finally {\n+        } finally {\n             if (ctx != null)\n                 try {\n                     ctx.close();"},{"sha":"46d51f8cc052a1eb39eb84b94f71e75872164a5f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","status":"modified","additions":12,"deletions":24,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -114,8 +114,7 @@ public void commit() throws SQLException {\n                 JDBCEvent.BEFORE_COMMIT, null, null, null);\n             try {\n                 super.commit();\n-            }\n-            finally {\n+            } finally {\n                 fireEvent(getDelegate(), JDBCEvent.AFTER_COMMIT, before,\n                     null, null);\n             }\n@@ -126,8 +125,7 @@ public void rollback() throws SQLException {\n                 JDBCEvent.BEFORE_ROLLBACK, null, null, null);\n             try {\n                 super.rollback();\n-            }\n-            finally {\n+            } finally {\n                 fireEvent(getDelegate(), JDBCEvent.AFTER_ROLLBACK, before,\n                     null, null);\n             }\n@@ -140,8 +138,7 @@ protected Statement createStatement(boolean wrap) throws SQLException {\n             try {\n                 stmnt = new EventStatement(super.createStatement(false),\n                     EventConnection.this);\n-            }\n-            finally {\n+            } finally {\n                 fireEvent(getDelegate(), JDBCEvent.AFTER_CREATE_STATEMENT,\n                     before, stmnt, null);\n             }\n@@ -156,8 +153,7 @@ protected Statement createStatement(int rsType, int rsConcur,\n             try {\n                 stmnt = new EventStatement(super.createStatement\n                     (rsType, rsConcur, false), EventConnection.this);\n-            }\n-            finally {\n+            } finally {\n                 fireEvent(getDelegate(), JDBCEvent.AFTER_CREATE_STATEMENT,\n                     before, stmnt, null);\n             }\n@@ -172,8 +168,7 @@ protected PreparedStatement prepareStatement(String sql, boolean wrap)\n             try {\n                 stmnt = new EventPreparedStatement(super.prepareStatement\n                     (sql, false), EventConnection.this, sql);\n-            }\n-            finally {\n+            } finally {\n                 fireEvent(getDelegate(), JDBCEvent.AFTER_PREPARE_STATEMENT,\n                     before, stmnt, sql);\n             }\n@@ -188,8 +183,7 @@ protected PreparedStatement prepareStatement(String sql, int rsType,\n             try {\n                 stmnt = new EventPreparedStatement(super.prepareStatement\n                     (sql, rsType, rsConcur, false), EventConnection.this, sql);\n-            }\n-            finally {\n+            } finally {\n                 fireEvent(getDelegate(), JDBCEvent.AFTER_PREPARE_STATEMENT,\n                     before, stmnt, sql);\n             }\n@@ -200,8 +194,7 @@ public void close() throws SQLException {\n             try {\n                 fireEvent(getDelegate(), JDBCEvent.BEFORE_CLOSE,\n                     null, null, null);\n-            }\n-            finally {\n+            } finally {\n                 super.close();\n             }\n         }\n@@ -227,8 +220,7 @@ public int executeUpdate() throws SQLException {\n                 JDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate(), _sql);\n             try {\n                 return super.executeUpdate();\n-            }\n-            finally {\n+            } finally {\n                 fireEvent(_conn.getDelegate(),\n                     JDBCEvent.AFTER_EXECUTE_STATEMENT, before,\n                     getDelegate(), _sql);\n@@ -240,8 +232,7 @@ protected ResultSet executeQuery(boolean wrap) throws SQLException {\n                 JDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate(), _sql);\n             try {\n                 return super.executeQuery(wrap);\n-            }\n-            finally {\n+            } finally {\n                 fireEvent(_conn.getDelegate(),\n                     JDBCEvent.AFTER_EXECUTE_STATEMENT, before,\n                     getDelegate(), _sql);\n@@ -253,8 +244,7 @@ protected ResultSet executeQuery(boolean wrap) throws SQLException {\n                 JDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate(), _sql);\n             try {\n                 return super.executeBatch();\n-            }\n-            finally {\n+            } finally {\n                 fireEvent(_conn.getDelegate(),\n                     JDBCEvent.AFTER_EXECUTE_STATEMENT, before,\n                     getDelegate(), _sql);\n@@ -279,8 +269,7 @@ public int executeUpdate(String sql) throws SQLException {\n                 JDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate(), sql);\n             try {\n                 return super.executeUpdate(sql);\n-            }\n-            finally {\n+            } finally {\n                 fireEvent(_conn.getDelegate(),\n                     JDBCEvent.AFTER_EXECUTE_STATEMENT, before,\n                     getDelegate(), sql);\n@@ -293,8 +282,7 @@ protected ResultSet executeQuery(String sql, boolean wrap)\n                 JDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate(), sql);\n             try {\n                 return super.executeQuery(sql, wrap);\n-            }\n-            finally {\n+            } finally {\n                 fireEvent(_conn.getDelegate(),\n                     JDBCEvent.AFTER_EXECUTE_STATEMENT, before,\n                     getDelegate(), sql);"},{"sha":"55dac2bda49659629d9ead3cbfc7c7a7b37a60d4","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","status":"modified","additions":29,"deletions":58,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -245,8 +245,7 @@ public void commit() throws SQLException {\n \n             try {\n                 super.commit();\n-            }\n-            finally {\n+            } finally {\n                 if (_logs.isJDBCEnabled())\n                     _logs.logJDBC(\"commit\", start, this);\n                 handleSQLWarning();\n@@ -258,8 +257,7 @@ public void rollback() throws SQLException {\n \n             try {\n                 super.rollback();\n-            }\n-            finally {\n+            } finally {\n                 if (_logs.isJDBCEnabled())\n                     _logs.logJDBC(\"rollback\", start, this);\n                 handleSQLWarning();\n@@ -271,8 +269,7 @@ public void close() throws SQLException {\n \n             try {\n                 super.close();\n-            }\n-            finally {\n+            } finally {\n                 if (_logs.isJDBCEnabled())\n                     _logs.logJDBC(\"close\", start, this);\n             }\n@@ -282,8 +279,7 @@ public Savepoint setSavepoint() throws SQLException {\n             long start = System.currentTimeMillis();\n             try {\n                 return super.setSavepoint();\n-            }\n-            finally {\n+            } finally {\n                 if (_logs.isJDBCEnabled())\n                     _logs.logJDBC(\"savepoint\", start, this);\n                 handleSQLWarning();\n@@ -294,8 +290,7 @@ public Savepoint setSavepoint(String name) throws SQLException {\n             long start = System.currentTimeMillis();\n             try {\n                 return super.setSavepoint(name);\n-            }\n-            finally {\n+            } finally {\n                 if (_logs.isJDBCEnabled())\n                     _logs.logJDBC(\"savepoint: \" + name, start, this);\n                 handleSQLWarning();\n@@ -306,8 +301,7 @@ public void rollback(Savepoint savepoint) throws SQLException {\n             long start = System.currentTimeMillis();\n             try {\n                 super.rollback(savepoint);\n-            }\n-            finally {\n+            } finally {\n                 if (_logs.isJDBCEnabled()) {\n                     String name = null;\n                     try {\n@@ -325,8 +319,7 @@ public void releaseSavepoint(Savepoint savepoint) throws SQLException {\n             long start = System.currentTimeMillis();\n             try {\n                 super.releaseSavepoint(savepoint);\n-            }\n-            finally {\n+            } finally {\n                 if (_logs.isJDBCEnabled()) {\n                     String name = null;\n                     try {\n@@ -415,8 +408,7 @@ private void handleSQLWarning() throws SQLException {\n \n             try {\n                 handleSQLWarning(getWarnings());\n-            }\n-            finally {\n+            } finally {\n                 clearWarnings();\n             }\n         }\n@@ -432,8 +424,7 @@ private void handleSQLWarning(Statement stmnt) throws SQLException {\n \n             try {\n                 handleSQLWarning(stmnt.getWarnings());\n-            }\n-            finally {\n+            } finally {\n                 stmnt.clearWarnings();\n             }\n         }\n@@ -449,8 +440,7 @@ private void handleSQLWarning(ResultSet rs) throws SQLException {\n \n             try {\n                 handleSQLWarning(rs.getWarnings());\n-            }\n-            finally {\n+            } finally {\n                 rs.clearWarnings();\n             }\n         }\n@@ -723,8 +713,7 @@ protected ResultSet executeQuery(String sql, boolean wrap)\n                     return super.executeQuery(sql, wrap);\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingStatement.this);\n-                }\n-                finally {\n+                } finally {\n                     if (_logs.isSQLEnabled())\n                         _logs.logSQL(\"executing \" + this, start,\n                             LoggingConnection.this);\n@@ -740,8 +729,7 @@ public int executeUpdate(String sql) throws SQLException {\n                     return super.executeUpdate(sql);\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingStatement.this);\n-                }\n-                finally {\n+                } finally {\n                     if (_logs.isSQLEnabled())\n                         _logs.logSQL(\"executing \" + this, start,\n                             LoggingConnection.this);\n@@ -757,8 +745,7 @@ public boolean execute(String sql) throws SQLException {\n                     return super.execute(sql);\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingStatement.this);\n-                }\n-                finally {\n+                } finally {\n                     if (_logs.isSQLEnabled())\n                         _logs.logSQL(\"executing \" + this, start,\n                             LoggingConnection.this);\n@@ -794,8 +781,7 @@ protected ResultSet executeQuery(String sql, boolean wrap)\n                     return super.executeQuery(sql, wrap);\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingPreparedStatement.this);\n-                }\n-                finally {\n+                } finally {\n                     log(\"executing\", start);\n                     clearLogParameters(true);\n                     handleSQLWarning(LoggingPreparedStatement.this);\n@@ -809,8 +795,7 @@ public int executeUpdate(String sql) throws SQLException {\n                     return super.executeUpdate(sql);\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingPreparedStatement.this);\n-                }\n-                finally {\n+                } finally {\n                     log(\"executing\", start);\n                     clearLogParameters(true);\n                     handleSQLWarning(LoggingPreparedStatement.this);\n@@ -824,8 +809,7 @@ public boolean execute(String sql) throws SQLException {\n                     return super.execute(sql);\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingPreparedStatement.this);\n-                }\n-                finally {\n+                } finally {\n                     log(\"executing\", start);\n                     clearLogParameters(true);\n                     handleSQLWarning(LoggingPreparedStatement.this);\n@@ -839,8 +823,7 @@ protected ResultSet executeQuery(boolean wrap) throws SQLException {\n                     return super.executeQuery(wrap);\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingPreparedStatement.this);\n-                }\n-                finally {\n+                } finally {\n                     log(\"executing\", start);\n                     clearLogParameters(true);\n                     handleSQLWarning(LoggingPreparedStatement.this);\n@@ -854,8 +837,7 @@ public int executeUpdate() throws SQLException {\n                     return super.executeUpdate();\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingPreparedStatement.this);\n-                }\n-                finally {\n+                } finally {\n                     log(\"executing\", start);\n                     clearLogParameters(true);\n                     handleSQLWarning(LoggingPreparedStatement.this);\n@@ -901,8 +883,7 @@ public int executeUpdate() throws SQLException {\n                         }\n                     }\n                     throw wrap(se, LoggingPreparedStatement.this);\n-                }\n-                finally {\n+                } finally {\n                     log(\"executing batch\", start);\n                     clearLogParameters(true);\n                     handleSQLWarning(LoggingPreparedStatement.this);\n@@ -916,8 +897,7 @@ public boolean execute() throws SQLException {\n                     return super.execute();\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingPreparedStatement.this);\n-                }\n-                finally {\n+                } finally {\n                     log(\"executing\", start);\n                     clearLogParameters(true);\n                     handleSQLWarning(LoggingPreparedStatement.this);\n@@ -1221,80 +1201,71 @@ public LoggingResultSet(ResultSet rs, Statement stmnt) {\n             public boolean next() throws SQLException {\n                 try {\n                     return super.next();\n-                }\n-                finally {\n+                } finally {\n                     handleSQLWarning(LoggingResultSet.this);\n                 }\n             }\n \n             public void close() throws SQLException {\n                 try {\n                     super.close();\n-                }\n-                finally {\n+                } finally {\n                     handleSQLWarning(LoggingResultSet.this);\n                 }\n             }\n \n             public void beforeFirst() throws SQLException {\n                 try {\n                     super.beforeFirst();\n-                }\n-                finally {\n+                } finally {\n                     handleSQLWarning(LoggingResultSet.this);\n                 }\n             }\n \n             public void afterLast() throws SQLException {\n                 try {\n                     super.afterLast();\n-                }\n-                finally {\n+                } finally {\n                     handleSQLWarning(LoggingResultSet.this);\n                 }\n             }\n \n             public boolean first() throws SQLException {\n                 try {\n                     return super.first();\n-                }\n-                finally {\n+                } finally {\n                     handleSQLWarning(LoggingResultSet.this);\n                 }\n             }\n \n             public boolean last() throws SQLException {\n                 try {\n                     return super.last();\n-                }\n-                finally {\n+                } finally {\n                     handleSQLWarning(LoggingResultSet.this);\n                 }\n             }\n \n             public boolean absolute(int a) throws SQLException {\n                 try {\n                     return super.absolute(a);\n-                }\n-                finally {\n+                } finally {\n                     handleSQLWarning(LoggingResultSet.this);\n                 }\n             }\n \n             public boolean relative(int a) throws SQLException {\n                 try {\n                     return super.relative(a);\n-                }\n-                finally {\n+                } finally {\n                     handleSQLWarning(LoggingResultSet.this);\n                 }\n             }\n \n             public boolean previous() throws SQLException {\n                 try {\n                     return super.previous();\n-                }\n-                finally {\n+                } finally {\n                     handleSQLWarning(LoggingResultSet.this);\n                 }\n             }"},{"sha":"63019ec35a97c07bad49cde8ebca55d97f447deb","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java","status":"modified","additions":4,"deletions":8,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -250,8 +250,7 @@ private void appendTypeNames(Object source, InputStream in, List names)\n             if (source.toString().endsWith(\".class\"))\n                 names.add(getFromClass(in));\n             names.addAll(getFromMetaData(new InputStreamReader(in)));\n-        }\n-        finally {\n+        } finally {\n             try {\n                 in.close();\n             } catch (IOException ioe) {\n@@ -294,8 +293,7 @@ private String getFromClassFile(File file) throws IOException {\n         try {\n             fin = new FileInputStream(file);\n             return getFromClass(fin);\n-        }\n-        finally {\n+        } finally {\n             if (fin != null)\n                 try {\n                     fin.close();\n@@ -353,8 +351,7 @@ private String getFromJavaFile(File file) throws IOException {\n                 clsName = pack + \".\" + clsName;\n \n             return clsName;\n-        }\n-        finally {\n+        } finally {\n             if (in != null)\n                 try {\n                     in.close();\n@@ -371,8 +368,7 @@ private Collection getFromMetaDataFile(File file) throws IOException {\n         try {\n             in = new FileReader(file);\n             return getFromMetaData(in);\n-        }\n-        finally {\n+        } finally {\n             if (in != null)\n                 try {\n                     in.close();"},{"sha":"6554d59af3ab28894f084a81427123db075016aa","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -374,8 +374,7 @@ protected void parseNewResource(Reader xml, String sourceName)\n             IOException ioe = new IOException(se.toString());\n             JavaVersions.initCause(ioe, se);\n             throw ioe;\n-        }\n-        finally {\n+        } finally {\n             reset();\n         }\n     }"},{"sha":"1540fa53efcf38a62828cf480afd13a64a4e8ecd","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/EagerResultList.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/EagerResultList.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/EagerResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/EagerResultList.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -35,8 +35,7 @@ public EagerResultList(ResultObjectProvider rop) {\n             throw re;\n         } catch (Exception e) {\n             rop.handleCheckedException(e);\n-        }\n-        finally {\n+        } finally {\n             try {\n                 rop.close();\n             } catch (Exception e) {"},{"sha":"ad4b8c5010142c70dd10a9a56d70389215530849","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Files.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Files.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Files.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Files.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -250,8 +250,7 @@ public static boolean copy(File from, File to) throws IOException {\n             for (int b; (b = inbuf.read()) != -1; outbuf.write(b)) ;\n             outbuf.flush();\n             return true;\n-        }\n-        finally {\n+        } finally {\n             if (in != null)\n                 try {\n                     in.close();"},{"sha":"05697bfff11bee1195f2397d675eeb76f649101a","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -283,8 +283,7 @@ public void load(InputStream in) throws IOException {\n         isLoading = true;\n         try {\n             loadProperties(in);\n-        }\n-        finally {\n+        } finally {\n             isLoading = false;\n         }\n     }"},{"sha":"613eeea327fcf0fbcf85bb8ceac7825d7dce6288","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ParameterTemplate.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ParameterTemplate.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ParameterTemplate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ParameterTemplate.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -144,8 +144,7 @@ public ParameterTemplate append(File file) throws IOException {\n         FileReader reader = new FileReader(file);\n         try {\n             return append(reader);\n-        }\n-        finally {\n+        } finally {\n             try {\n                 reader.close();\n             } catch (IOException ioe) {\n@@ -245,8 +244,7 @@ public void write(File file) throws IOException {\n         FileWriter writer = new FileWriter(file);\n         try {\n             write(writer);\n-        }\n-        finally {\n+        } finally {\n             try {\n                 writer.close();\n             } catch (IOException ioe) {"},{"sha":"1ac73f4cfcf6ffba0dc8cea01c44a61658a50b96","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StreamResourceBundleProvider.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StreamResourceBundleProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StreamResourceBundleProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/StreamResourceBundleProvider.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -41,8 +41,7 @@ public ResourceBundle findResource(String name, Locale locale,\n             try {\n                 return new PropertyResourceBundle(in);\n             } catch (Exception e) {\n-            }\n-            finally {\n+            } finally {\n                 try {\n                     in.close();\n                 } catch (IOException ioe) {"},{"sha":"847138b8e78139aeaa2d4faea6f0ed0155665873","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ZipResourceBundleProvider.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ZipResourceBundleProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ZipResourceBundleProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/ZipResourceBundleProvider.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -56,8 +56,7 @@ public ResourceBundle findResource(String name, Locale locale,\n                 zip.closeEntry();\n             }\n         } catch (Exception e) {\n-        }\n-        finally {\n+        } finally {\n             try {\n                 zip.close();\n             } catch (IOException ioe) {"},{"sha":"d8316b360688830e412b883752d347359b42c01d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java","status":"modified","additions":3,"deletions":6,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -86,8 +86,7 @@ public void await() throws InterruptedException {\n                     throw ex;\n                 }\n             }\n-        }\n-        finally {\n+        } finally {\n             for (int i = holdCount; i > 0; i--) lock.lock();\n         }\n     }\n@@ -118,8 +117,7 @@ public boolean await(long timeout, TimeUnit unit)\n                     throw ex;\n                 }\n             }\n-        }\n-        finally {\n+        } finally {\n             for (int i = holdCount; i > 0; i--) lock.lock();\n         }\n         return success;\n@@ -157,8 +155,7 @@ public boolean awaitUntil(Date deadline) throws InterruptedException {\n                     throw ex;\n                 }\n             }\n-        }\n-        finally {\n+        } finally {\n             for (int i = holdCount; i > 0; i--) lock.lock();\n         }\n         return success;"},{"sha":"6e53ef0f7ec79e90892918030a2c7b492effaddc","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOCondVar.java","status":"modified","additions":3,"deletions":6,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOCondVar.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOCondVar.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOCondVar.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -58,8 +58,7 @@ public void awaitUninterruptibly() {\n         for (int i = holdCount; i > 0; i--) lock.unlock();\n         try {\n             n.doWaitUninterruptibly(sync);\n-        }\n-        finally {\n+        } finally {\n             for (int i = holdCount; i > 0; i--) lock.lock();\n         }\n     }\n@@ -75,8 +74,7 @@ public void await() throws InterruptedException {\n         for (int i = holdCount; i > 0; i--) lock.unlock();\n         try {\n             n.doWait(sync);\n-        }\n-        finally {\n+        } finally {\n             for (int i = holdCount; i > 0; i--) lock.lock();\n         }\n     }\n@@ -95,8 +93,7 @@ public boolean await(long timeout, TimeUnit unit)\n         for (int i = holdCount; i > 0; i--) lock.unlock();\n         try {\n             success = n.doTimedWait(sync, nanos);\n-        }\n-        finally {\n+        } finally {\n             for (int i = holdCount; i > 0; i--) lock.lock();\n         }\n         return success;"},{"sha":"1cd6a95f4849040e739d260bbbbf3c9dcff64f67","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -187,8 +187,7 @@ public void lock() {\n                                 return;\n                             }\n                         }\n-                    }\n-                    finally {\n+                    } finally {\n                         if (wasInterrupted) Thread.currentThread().interrupt();\n                     }\n                 }"},{"sha":"e350644ce6f112ad198c6fd2337a8c7f19dd269c","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/WaitQueue.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/WaitQueue.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/WaitQueue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/WaitQueue.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -139,8 +139,7 @@ public synchronized void doWaitUninterruptibly(QueuedSync sync) {\n                             // must be not waiting, and we'll act like signalled\n                         }\n                     }\n-                }\n-                finally {\n+                } finally {\n                     if (wasInterrupted) Thread.currentThread().interrupt();\n                 }\n             }"},{"sha":"5bbc0a67c512fff6988d906b11ed58092043a1b4","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestMultiClassLoader.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestMultiClassLoader.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestMultiClassLoader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestMultiClassLoader.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -101,16 +101,14 @@ public void testClassForName()\n  assertEquals(TestMultiClassLoader.class, Class.forName\n  (TestMultiClassLoader.class.getName(), true, _loader));\n  fail(\"System class laoder still working.\");\n- }\n- catch (ClassNotFoundException cnfe)\n+ } catch (ClassNotFoundException cnfe)\n  {\n  }\n  try\n  {\n  Class.forName(\"foo\", true, _loader);\n  fail(\"Somehow found 'foo'???\");\n- }\n- catch (ClassNotFoundException cnfe)\n+ } catch (ClassNotFoundException cnfe)\n  {\n  }\n  _loader.addClassLoader(new FooLoader());"},{"sha":"131da5d8a25fab4ca3356ea314a8eb29000db69a","filename":"openjpa-persistence-jdbc/pom.xml","status":"added","additions":120,"deletions":0,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/pom.xml?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,120 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.apache.openjpa</groupId>\n+    <artifactId>openjpa-persistence-jdbc</artifactId>\n+    <packaging>jar</packaging>\n+\n+    <name>JPA JDBC</name>\n+    <description>JPA JDBC</description>\n+    <url>http://incubator.apache.org/projects/openjpa</url>\n+    <parent>\n+\n+        <groupId>org.apache.openjpa</groupId>\n+        <artifactId>openjpa</artifactId>\n+        <version>0.0.1</version>\n+\n+    </parent>\n+    <dependencies>\n+\n+        <dependency>\n+\n+            <groupId>org.apache.openjpa</groupId>\n+            <artifactId>openjpa-jdbc-5</artifactId>\n+            <version>0.0.1</version>\n+            <scope>compile</scope>\n+\n+        </dependency>\n+        <dependency>\n+\n+            <groupId>org.apache.openjpa</groupId>\n+            <artifactId>openjpa-persistence</artifactId>\n+            <version>0.0.1</version>\n+            <scope>compile</scope>\n+\n+        </dependency>\n+        <dependency>\n+\n+            <groupId>org.apache.derby</groupId>\n+            <artifactId>derby</artifactId>\n+            <version>10.1.2.1</version>\n+            <scope>test</scope>\n+\n+        </dependency>\n+        <dependency>\n+\n+            <groupId>commons-dbcp</groupId>\n+            <artifactId>commons-dbcp</artifactId>\n+            <version>1.2.1</version>\n+            <scope>test</scope>\n+\n+        </dependency>\n+        <dependency>\n+\n+            <groupId>commons-collections</groupId>\n+            <artifactId>commons-collections</artifactId>\n+            <version>3.1</version>\n+            <scope>test</scope>\n+\n+        </dependency>\n+\n+    </dependencies>\n+    <build>\n+\n+        <plugins>\n+\n+            <plugin>\n+\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>1.5</source>\n+                    <target>1.5</target>\n+                </configuration>\n+\n+            </plugin>\n+            <plugin>\n+                <artifactId>maven-antrun-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <phase>test-compile</phase>\n+                        <configuration>\n+                            <tasks>\n+                                <path id=\"enhance.path.ref\">\n+                                    <fileset\n+                                        dir=\"${project.build.testOutputDirectory}\">\n+                                        <include name=\"**/*.class\"/>\n+                                    </fileset>\n+                                </path>\n+                                <pathconvert property=\"enhance.files\"\n+                                             refid=\"enhance.path.ref\"\n+                                             pathsep=\" \"/>\n+                                <java\n+                                    classname=\"org.apache.openjpa.enhance.PCEnhancer\">\n+                                    <arg value=\"-MetaDataFactory\"/>\n+                                    <arg\n+                                        value=\"org.apache.openjpa.persistence.PersistenceMetaDataFactory\"/>\n+                                    <arg line=\"${enhance.files}\"/>\n+                                    <classpath>\n+                                        <path\n+                                            refid=\"maven.dependency.classpath\"/>\n+                                        <path refid=\"maven.compile.classpath\"/>\n+                                        <path refid=\"maven.test.classpath\"/>\n+                                    </classpath>\n+                                </java>\n+                            </tasks>\n+                        </configuration>\n+                        <goals>\n+                            <goal>run</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+\n+        </plugins>\n+\n+    </build>\n+\n+\n+</project>"},{"sha":"b655fe4f94a35c2304ea93a57d35c166f471ca77","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java","status":"added","additions":1334,"deletions":0,"changes":1334,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,1334 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.persistence.AssociationOverride;\n+import javax.persistence.AssociationOverrides;\n+import javax.persistence.AttributeOverride;\n+import javax.persistence.AttributeOverrides;\n+import javax.persistence.ColumnResult;\n+import javax.persistence.DiscriminatorColumn;\n+import javax.persistence.DiscriminatorValue;\n+import javax.persistence.EntityResult;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import javax.persistence.FieldResult;\n+import javax.persistence.Inheritance;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.JoinColumns;\n+import javax.persistence.JoinTable;\n+import javax.persistence.PrimaryKeyJoinColumn;\n+import javax.persistence.PrimaryKeyJoinColumns;\n+import javax.persistence.SecondaryTable;\n+import javax.persistence.SecondaryTables;\n+import javax.persistence.SqlResultSetMapping;\n+import javax.persistence.SqlResultSetMappings;\n+import javax.persistence.Table;\n+import javax.persistence.TableGenerator;\n+import javax.persistence.Temporal;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.kernel.EagerFetchModes;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.ClassMappingInfo;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.MappingInfo;\n+import org.apache.openjpa.jdbc.meta.MappingRepository;\n+import org.apache.openjpa.jdbc.meta.QueryResultMapping;\n+import org.apache.openjpa.jdbc.meta.SequenceMapping;\n+import org.apache.openjpa.jdbc.meta.ValueMapping;\n+import org.apache.openjpa.jdbc.meta.ValueMappingInfo;\n+import org.apache.openjpa.jdbc.meta.strats.EnumValueHandler;\n+import org.apache.openjpa.jdbc.meta.strats.FlatClassStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.FullClassStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.VerticalClassStrategy;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser;\n+import static org.apache.openjpa.persistence.jdbc.MappingTag.*;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.MetaDataException;\n+import org.apache.openjpa.util.UnsupportedException;\n+\n+/**\n+ * Persistence annotation mapping parser.\n+ *\n+ * @author Pinaki Poddar\n+ * @author Steve Kim\n+ * @author Abe White\n+ */\n+public class AnnotationPersistenceMappingParser\n+    extends AnnotationPersistenceMetaDataParser {\n+\n+    protected static final int TRUE = 1;\n+    protected static final int FALSE = 2;\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (AnnotationPersistenceMappingParser.class);\n+\n+    private static final Map<Class, MappingTag> _tags =\n+        new HashMap<Class, MappingTag>();\n+\n+    static {\n+        _tags.put(AssociationOverride.class, ASSOC_OVERRIDE);\n+        _tags.put(AssociationOverrides.class, ASSOC_OVERRIDES);\n+        _tags.put(AttributeOverride.class, ATTR_OVERRIDE);\n+        _tags.put(AttributeOverrides.class, ATTR_OVERRIDES);\n+        _tags.put(javax.persistence.Column.class, COL);\n+        _tags.put(ColumnResult.class, COLUMN_RESULT);\n+        _tags.put(DiscriminatorColumn.class, DISCRIM_COL);\n+        _tags.put(DiscriminatorValue.class, DISCRIM_VAL);\n+        _tags.put(EntityResult.class, ENTITY_RESULT);\n+        _tags.put(Enumerated.class, ENUMERATED);\n+        _tags.put(FieldResult.class, FIELD_RESULT);\n+        _tags.put(Inheritance.class, INHERITANCE);\n+        _tags.put(JoinColumn.class, JOIN_COL);\n+        _tags.put(JoinColumns.class, JOIN_COLS);\n+        _tags.put(JoinTable.class, JOIN_TABLE);\n+        _tags.put(PrimaryKeyJoinColumn.class, PK_JOIN_COL);\n+        _tags.put(PrimaryKeyJoinColumns.class, PK_JOIN_COLS);\n+        _tags.put(SecondaryTable.class, SECONDARY_TABLE);\n+        _tags.put(SecondaryTables.class, SECONDARY_TABLES);\n+        _tags.put(SqlResultSetMapping.class, SQL_RESULT_SET_MAPPING);\n+        _tags.put(SqlResultSetMappings.class, SQL_RESULT_SET_MAPPINGS);\n+        _tags.put(Table.class, TABLE);\n+        _tags.put(Temporal.class, TEMPORAL);\n+        _tags.put(TableGenerator.class, TABLE_GEN);\n+        _tags.put(ClassCriteria.class, CLASS_CRIT);\n+        _tags.put(Columns.class, COLS);\n+        _tags.put(ContainerTable.class, CONTAINER_TABLE);\n+        _tags.put(DataStoreIdColumn.class, DATASTORE_ID_COL);\n+        _tags.put(DiscriminatorStrategy.class, DISCRIM_STRAT);\n+        _tags.put(EagerFetchMode.class, EAGER_FETCH_MODE);\n+        _tags.put(ElementClassCriteria.class, ELEM_CLASS_CRIT);\n+        _tags.put(ElementForeignKey.class, ELEM_FK);\n+        _tags.put(ElementIndex.class, ELEM_INDEX);\n+        _tags.put(ElementJoinColumn.class, ELEM_JOIN_COL);\n+        _tags.put(ElementJoinColumns.class, ELEM_JOIN_COLS);\n+        _tags.put(ElementNonpolymorphic.class, ELEM_NONPOLY);\n+        _tags.put(EmbeddedMapping.class, EMBEDDED_MAPPING);\n+        _tags.put(ForeignKey.class, FK);\n+        _tags.put(Index.class, INDEX);\n+        _tags.put(MappingOverride.class, MAPPING_OVERRIDE);\n+        _tags.put(MappingOverrides.class, MAPPING_OVERRIDES);\n+        _tags.put(Nonpolymorphic.class, NONPOLY);\n+        _tags.put(OrderColumn.class, ORDER_COL);\n+        _tags.put(Strategy.class, STRAT);\n+        _tags.put(SubclassFetchMode.class, SUBCLASS_FETCH_MODE);\n+        _tags.put(Unique.class, UNIQUE);\n+        _tags.put(VersionColumn.class, VERSION_COL);\n+        _tags.put(VersionColumns.class, VERSION_COLS);\n+        _tags.put(VersionStrategy.class, VERSION_STRAT);\n+        _tags.put(XJoinColumn.class, X_JOIN_COL);\n+        _tags.put(XJoinColumns.class, X_JOIN_COLS);\n+        _tags.put(XSecondaryTable.class, X_SECONDARY_TABLE);\n+        _tags.put(XSecondaryTables.class, X_SECONDARY_TABLES);\n+        _tags.put(XTable.class, X_TABLE);\n+    }\n+\n+    public AnnotationPersistenceMappingParser(JDBCConfiguration conf) {\n+        super(conf);\n+    }\n+\n+    @Override\n+    protected MetaDataRepository newRepository() {\n+        return ((JDBCConfiguration) getConfiguration()).\n+            newMappingRepositoryInstance();\n+    }\n+\n+    @Override\n+    protected void parsePackageMappingAnnotations(Package pkg) {\n+        MappingTag tag;\n+        for (Annotation anno : pkg.getDeclaredAnnotations()) {\n+            tag = _tags.get(anno.annotationType());\n+            if (tag == null) {\n+                handleUnknownPackageMappingAnnotation(pkg, anno);\n+                continue;\n+            }\n+\n+            switch (tag) {\n+                case TABLE_GEN:\n+                    parseTableGenerator(pkg, (TableGenerator) anno);\n+                    break;\n+                default:\n+                    throw new UnsupportedException(_loc.get(\"unsupported\", pkg,\n+                        anno.toString()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Allow subclasses to handle unknown annotations.\n+     */\n+    protected boolean handleUnknownPackageMappingAnnotation(Package pkg,\n+        Annotation anno) {\n+        return false;\n+    }\n+\n+    /**\n+     * Parse @TableGenerator.\n+     */\n+    private void parseTableGenerator(AnnotatedElement el, TableGenerator gen) {\n+        String name = gen.name();\n+        if (StringUtils.isEmpty(name))\n+            throw new MetaDataException(_loc.get(\"no-gen-name\", el));\n+\n+        Log log = getLog();\n+        if (log.isInfoEnabled())\n+            log.info(_loc.get(\"parse-gen\", name));\n+\n+        SequenceMapping meta = (SequenceMapping) getRepository().\n+            getCachedSequenceMetaData(name);\n+        if (meta != null) {\n+            if (log.isWarnEnabled())\n+                log.warn(_loc.get(\"dup-gen\", name, el));\n+            return;\n+        }\n+\n+        meta = (SequenceMapping) getRepository().addSequenceMetaData(name);\n+        meta.setSequencePlugin(SequenceMapping.IMPL_VALUE_TABLE);\n+        meta.setTable(toTableName(gen.schema(), gen.table()));\n+        meta.setPrimaryKeyColumn(gen.pkColumnName());\n+        meta.setSequenceColumn(gen.valueColumnName());\n+        meta.setPrimaryKeyValue(gen.pkColumnValue());\n+        meta.setInitialValue(gen.initialValue());\n+        meta.setAllocate(gen.allocationSize());\n+        meta.setSource(getSourceFile(), (el instanceof Class) ? el : null,\n+            meta.SRC_ANNOTATIONS);\n+\n+        //### EJB3\n+        if (gen.uniqueConstraints().length > 0 && log.isWarnEnabled())\n+            log.warn(_loc.get(\"unique-constraints\", name));\n+    }\n+\n+    @Override\n+    protected void parseClassMappingAnnotations(ClassMetaData meta) {\n+        ClassMapping cm = (ClassMapping) meta;\n+        Class cls = cm.getDescribedType();\n+\n+        MappingTag tag;\n+        for (Annotation anno : cls.getDeclaredAnnotations()) {\n+            tag = _tags.get(anno.annotationType());\n+            if (tag == null) {\n+                handleUnknownClassMappingAnnotation(cm, anno);\n+                continue;\n+            }\n+\n+            switch (tag) {\n+                case ASSOC_OVERRIDE:\n+                    parseAssociationOverrides(cm, (AssociationOverride) anno);\n+                    break;\n+                case ASSOC_OVERRIDES:\n+                    parseAssociationOverrides(cm, ((AssociationOverrides) anno).\n+                        value());\n+                    break;\n+                case ATTR_OVERRIDE:\n+                    parseAttributeOverrides(cm, (AttributeOverride) anno);\n+                    break;\n+                case ATTR_OVERRIDES:\n+                    parseAttributeOverrides(cm, ((AttributeOverrides) anno).\n+                        value());\n+                    break;\n+                case DISCRIM_COL:\n+                    parseDiscriminatorColumn(cm, (DiscriminatorColumn) anno);\n+                    break;\n+                case DISCRIM_VAL:\n+                    cm.getDiscriminator().getMappingInfo().setValue\n+                        (((DiscriminatorValue) anno).value());\n+                    break;\n+                case INHERITANCE:\n+                    parseInheritance(cm, (Inheritance) anno);\n+                    break;\n+                case PK_JOIN_COL:\n+                    parsePrimaryKeyJoinColumns(cm, (PrimaryKeyJoinColumn) anno);\n+                    break;\n+                case PK_JOIN_COLS:\n+                    parsePrimaryKeyJoinColumns(cm,\n+                        ((PrimaryKeyJoinColumns) anno).\n+                            value());\n+                    break;\n+                case SECONDARY_TABLE:\n+                    parseSecondaryTables(cm, (SecondaryTable) anno);\n+                    break;\n+                case SECONDARY_TABLES:\n+                    parseSecondaryTables(cm, ((SecondaryTables) anno).value());\n+                    break;\n+                case SQL_RESULT_SET_MAPPING:\n+                    parseSQLResultSetMappings(cm, (SqlResultSetMapping) anno);\n+                    break;\n+                case SQL_RESULT_SET_MAPPINGS:\n+                    parseSQLResultSetMappings(cm, ((SqlResultSetMappings) anno).\n+                        value());\n+                    break;\n+                case TABLE:\n+                    parseTable(cm, (Table) anno);\n+                    break;\n+                case TABLE_GEN:\n+                    parseTableGenerator(cls, (TableGenerator) anno);\n+                    break;\n+                case DATASTORE_ID_COL:\n+                    parseDataStoreIdColumn(cm, (DataStoreIdColumn) anno);\n+                    break;\n+                case DISCRIM_STRAT:\n+                    cm.getDiscriminator().getMappingInfo().setStrategy\n+                        (((DiscriminatorStrategy) anno).value());\n+                    break;\n+                case FK:\n+                    parseForeignKey(cm.getMappingInfo(), (ForeignKey) anno);\n+                    break;\n+                case MAPPING_OVERRIDE:\n+                    parseMappingOverrides(cm, (MappingOverride) anno);\n+                    break;\n+                case MAPPING_OVERRIDES:\n+                    parseMappingOverrides(cm,\n+                        ((MappingOverrides) anno).value());\n+                    break;\n+                case STRAT:\n+                    cm.getMappingInfo().setStrategy(((Strategy) anno).value());\n+                    break;\n+                case SUBCLASS_FETCH_MODE:\n+                    cm.setSubclassFetchMode(toEagerFetchModeConstant\n+                        (((SubclassFetchMode) anno).value()));\n+                    break;\n+                case VERSION_COL:\n+                    parseVersionColumns(cm, (VersionColumn) anno);\n+                    break;\n+                case VERSION_COLS:\n+                    parseVersionColumns(cm, ((VersionColumns) anno).value());\n+                    break;\n+                case VERSION_STRAT:\n+                    cm.getVersion().getMappingInfo().setStrategy\n+                        (((VersionStrategy) anno).value());\n+                    break;\n+                case X_TABLE:\n+                case X_SECONDARY_TABLE:\n+                case X_SECONDARY_TABLES:\n+                    // no break; not supported yet\n+                default:\n+                    throw new UnsupportedException(_loc.get(\"unsupported\", cm,\n+                        anno));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Allow subclasses to handle unknown annotations.\n+     */\n+    protected boolean handleUnknownClassMappingAnnotation(ClassMapping cls,\n+        Annotation anno) {\n+        return false;\n+    }\n+\n+    /**\n+     * Parse @AssociationOverride(s).\n+     */\n+    private void parseAssociationOverrides(ClassMapping cm,\n+        AssociationOverride... assocs) {\n+        FieldMapping sup;\n+        JoinColumn[] scols;\n+        int unique;\n+        List<Column> jcols;\n+        for (AssociationOverride assoc : assocs) {\n+            if (StringUtils.isEmpty(assoc.name()))\n+                throw new MetaDataException(_loc.get(\"no-override-name\", cm));\n+            sup = (FieldMapping) cm.getDefinedSuperclassField(assoc.name());\n+            if (sup == null)\n+                sup = (FieldMapping) cm.addDefinedSuperclassField\n+                    (assoc.name(), Object.class, Object.class);\n+            scols = assoc.joinColumns();\n+            if (scols == null || scols.length == 0)\n+                continue;\n+\n+            jcols = new ArrayList<Column>(scols.length);\n+            unique = 0;\n+            for (JoinColumn scol : scols) {\n+                unique |= (scol.unique()) ? TRUE : FALSE;\n+                jcols.add(newColumn(scol));\n+            }\n+            setColumns(sup, sup.getValueInfo(), jcols, unique);\n+        }\n+    }\n+\n+    /**\n+     * Parse @AttributeOverride(s).\n+     */\n+    private void parseAttributeOverrides(ClassMapping cm,\n+        AttributeOverride... attrs) {\n+        FieldMapping sup;\n+        javax.persistence.Column scol;\n+        int unique;\n+        for (AttributeOverride attr : attrs) {\n+            if (StringUtils.isEmpty(attr.name()))\n+                throw new MetaDataException(_loc.get(\"no-override-name\", cm));\n+            sup = (FieldMapping) cm.getDefinedSuperclassField(attr.name());\n+            if (sup == null)\n+                sup = (FieldMapping) cm.addDefinedSuperclassField(attr.name(),\n+                    Object.class, Object.class);\n+            scol = attr.column();\n+            if (scol == null)\n+                continue;\n+\n+            unique = (scol.unique()) ? TRUE : FALSE;\n+            setColumns(sup, sup.getValueInfo(), Arrays.asList\n+                (new Column[]{ newColumn(scol) }), unique);\n+        }\n+    }\n+\n+    /**\n+     * Parse inheritance @PrimaryKeyJoinColumn(s).\n+     */\n+    private void parsePrimaryKeyJoinColumns(ClassMapping cm,\n+        PrimaryKeyJoinColumn... joins) {\n+        List<Column> cols = new ArrayList<Column>(joins.length);\n+        for (PrimaryKeyJoinColumn join : joins)\n+            cols.add(newColumn(join));\n+        cm.getMappingInfo().setColumns(cols);\n+    }\n+\n+    /**\n+     * Create a new schema column with information from the given annotation.\n+     */\n+    private static Column newColumn(PrimaryKeyJoinColumn join) {\n+        Column col = new Column();\n+        col.setFlag(Column.FLAG_PK_JOIN, true);\n+        if (!StringUtils.isEmpty(join.name()))\n+            col.setName(join.name());\n+        if (!StringUtils.isEmpty(join.columnDefinition()))\n+            col.setName(join.columnDefinition());\n+        if (!StringUtils.isEmpty(join.referencedColumnName()))\n+            col.setTarget(join.referencedColumnName());\n+        return col;\n+    }\n+\n+    /**\n+     * Parse @SecondaryTable(s).\n+     */\n+    private void parseSecondaryTables(ClassMapping cm,\n+        SecondaryTable... tables) {\n+        ClassMappingInfo info = cm.getMappingInfo();\n+        Log log = getLog();\n+\n+        String name;\n+        List<Column> joins;\n+        boolean warnUnique = false;\n+        for (SecondaryTable table : tables) {\n+            name = table.name();\n+            if (StringUtils.isEmpty(name))\n+                throw new MetaDataException(_loc.get(\"second-name\", cm));\n+            if (!StringUtils.isEmpty(table.schema()))\n+                name = table.schema() + \".\" + name;\n+            if (table.pkJoinColumns().length > 0) {\n+                joins = new ArrayList<Column>(table.pkJoinColumns().length);\n+                for (PrimaryKeyJoinColumn join : table.pkJoinColumns())\n+                    joins.add(newColumn(join));\n+                info.setSecondaryTableJoinColumns(name, joins);\n+            }\n+            warnUnique |= table.uniqueConstraints().length > 0;\n+        }\n+\n+        //### EJB3\n+        if (warnUnique && log.isWarnEnabled())\n+            log.warn(_loc.get(\"unique-constraints\", cm));\n+    }\n+\n+    /**\n+     * Set class table.\n+     */\n+    private void parseTable(ClassMapping cm, Table table) {\n+        String tableName = toTableName(table.schema(), table.name());\n+        if (tableName != null)\n+            cm.getMappingInfo().setTableName(tableName);\n+\n+        //### EJB3\n+        Log log = getLog();\n+        if (table.uniqueConstraints().length > 0 && log.isWarnEnabled())\n+            log.warn(_loc.get(\"unique-constraints\", cm));\n+    }\n+\n+    /**\n+     * Form a qualified table name from a schema and table name.\n+     */\n+    private static String toTableName(String schema, String table) {\n+        if (StringUtils.isEmpty(table))\n+            return null;\n+        if (StringUtils.isEmpty(schema))\n+            return table;\n+        return schema + \".\" + table;\n+    }\n+\n+    /**\n+     * Parses the given annotation to create and cache a\n+     * {@link SQLResultSetMappingMetaData}.\n+     */\n+    private void parseSQLResultSetMappings(ClassMapping cm,\n+        SqlResultSetMapping... annos) {\n+        MappingRepository repos = (MappingRepository) getRepository();\n+        Log log = getLog();\n+        for (SqlResultSetMapping anno : annos) {\n+            if (log.isInfoEnabled())\n+                log.info(_loc.get(\"parse-sqlrsmapping\", anno.name()));\n+\n+            QueryResultMapping result = repos.getCachedQueryResultMapping\n+                (null, anno.name());\n+            if (result != null) {\n+                if (log.isWarnEnabled())\n+                    log.warn(_loc.get(\"dup-sqlrsmapping\", anno.name(), cm));\n+                continue;\n+            }\n+\n+            result = repos.addQueryResultMapping(null, anno.name());\n+            result.setSource(getSourceFile(), cm.getDescribedType(),\n+                result.SRC_ANNOTATIONS);\n+\n+            for (EntityResult entity : anno.entities()) {\n+                QueryResultMapping.PCResult entityResult = result.addPCResult\n+                    (entity.entityClass());\n+                if (!StringUtils.isEmpty(entity.discriminatorColumn()))\n+                    entityResult.addMapping(entityResult.DISCRIMINATOR,\n+                        entity.discriminatorColumn());\n+\n+                for (FieldResult field : entity.fields())\n+                    entityResult.addMapping(field.name(), field.column());\n+            }\n+            for (ColumnResult column : anno.columns())\n+                result.addColumnResult(column.name());\n+        }\n+    }\n+\n+    /**\n+     * Parse @DiscriminatorColumn.\n+     */\n+    private void parseDiscriminatorColumn(ClassMapping cm,\n+        DiscriminatorColumn dcol) {\n+        Column col = new Column();\n+        if (!StringUtils.isEmpty(dcol.name()))\n+            col.setName(dcol.name());\n+        if (!StringUtils.isEmpty(dcol.columnDefinition()))\n+            col.setTypeName(dcol.columnDefinition());\n+        switch (dcol.discriminatorType()) {\n+            case CHAR:\n+                col.setJavaType(JavaTypes.CHAR);\n+                break;\n+            case INTEGER:\n+                col.setJavaType(JavaTypes.INT);\n+                if (dcol.length() != 31)\n+                    col.setSize(dcol.length());\n+                break;\n+            default:\n+                col.setJavaType(JavaTypes.STRING);\n+                col.setSize(dcol.length());\n+        }\n+        cm.getDiscriminator().getMappingInfo().setColumns\n+            (Arrays.asList(new Column[]{ col }));\n+    }\n+\n+    /**\n+     * Parse @Inheritance.\n+     */\n+    private void parseInheritance(ClassMapping cm, Inheritance inherit) {\n+        ClassMappingInfo info = cm.getMappingInfo();\n+        switch (inherit.strategy()) {\n+            case SINGLE_TABLE:\n+                info.setHierarchyStrategy(FlatClassStrategy.ALIAS);\n+                break;\n+            case JOINED:\n+                info.setHierarchyStrategy(VerticalClassStrategy.ALIAS);\n+                break;\n+            case TABLE_PER_CLASS:\n+                info.setHierarchyStrategy(FullClassStrategy.ALIAS);\n+                break;\n+            default:\n+                throw new InternalException();\n+        }\n+    }\n+\n+    /**\n+     * Parse class-level @MappingOverride(s).\n+     */\n+    private void parseMappingOverrides(ClassMapping cm,\n+        MappingOverride... overs) {\n+        FieldMapping sup;\n+        for (MappingOverride over : overs) {\n+            if (StringUtils.isEmpty(over.name()))\n+                throw new MetaDataException(_loc.get(\"no-override-name\", cm));\n+            sup = (FieldMapping) cm.getDefinedSuperclassField(over.name());\n+            if (sup == null)\n+                sup = (FieldMapping) cm.addDefinedSuperclassField(over.name(),\n+                    Object.class, Object.class);\n+            populate(sup, over);\n+        }\n+    }\n+\n+    /**\n+     * Populate the given field from override data.\n+     */\n+    private void populate(FieldMapping fm, MappingOverride over) {\n+        if (over.containerTable().specified())\n+            parseContainerTable(fm, over.containerTable());\n+        parseColumns(fm, over.columns());\n+        parseXJoinColumns(fm, fm.getValueInfo(), true, over.joinColumns());\n+        parseElementJoinColumns(fm, over.elementJoinColumns());\n+    }\n+\n+    /**\n+     * Parse datastore identity information in @DataStoreIdColumn.\n+     */\n+    private void parseDataStoreIdColumn(ClassMapping cm, DataStoreIdColumn id) {\n+        Column col = new Column();\n+        if (!StringUtils.isEmpty(id.name()))\n+            col.setName(id.name());\n+        if (!StringUtils.isEmpty(id.columnDefinition()))\n+            col.setTypeName(id.columnDefinition());\n+        if (id.precision() != 0)\n+            col.setSize(id.precision());\n+        col.setFlag(Column.FLAG_UNINSERTABLE, !id.insertable());\n+        col.setFlag(Column.FLAG_UNUPDATABLE, !id.updatable());\n+        cm.getMappingInfo().setColumns(Arrays.asList(new Column[]{ col }));\n+    }\n+\n+    /**\n+     * Parse the given foreign key.\n+     */\n+    private void parseForeignKey(MappingInfo info, ForeignKey fk) {\n+        parseForeignKey(info, fk.name(), fk.enabled(), fk.deferred(),\n+            fk.deleteAction(), fk.updateAction());\n+    }\n+\n+    /**\n+     * Set foreign key data on the given mapping info.\n+     */\n+    protected void parseForeignKey(MappingInfo info, String name,\n+        boolean enabled, boolean deferred, ForeignKeyAction deleteAction,\n+        ForeignKeyAction updateAction) {\n+        if (!enabled) {\n+            info.setCanForeignKey(false);\n+            return;\n+        }\n+\n+        org.apache.openjpa.jdbc.schema.ForeignKey fk =\n+            new org.apache.openjpa.jdbc.schema.ForeignKey();\n+        if (!StringUtils.isEmpty(name))\n+            fk.setName(name);\n+        fk.setDeferred(deferred);\n+        fk.setDeleteAction(toForeignKeyAction(deleteAction));\n+        fk.setUpdateAction(toForeignKeyAction(deleteAction));\n+        info.setForeignKey(fk);\n+    }\n+\n+    /**\n+     * Convert our FK action enum to an internal OpenJPA action.\n+     */\n+    private int toForeignKeyAction(ForeignKeyAction action) {\n+        switch (action) {\n+            case RESTRICT:\n+                return org.apache.openjpa.jdbc.schema.ForeignKey.ACTION_RESTRICT;\n+            case CASCADE:\n+                return org.apache.openjpa.jdbc.schema.ForeignKey.ACTION_CASCADE;\n+            case NULL:\n+                return org.apache.openjpa.jdbc.schema.ForeignKey.ACTION_NULL;\n+            case DEFAULT:\n+                return org.apache.openjpa.jdbc.schema.ForeignKey.ACTION_DEFAULT;\n+            default:\n+                throw new InternalException();\n+        }\n+    }\n+\n+    /**\n+     * Parse the given index.\n+     */\n+    private void parseIndex(MappingInfo info, Index idx) {\n+        parseIndex(info, idx.name(), idx.enabled(), idx.unique());\n+    }\n+\n+    /**\n+     * Set index data on the given mapping info.\n+     */\n+    protected void parseIndex(MappingInfo info, String name,\n+        boolean enabled, boolean unique) {\n+        if (!enabled) {\n+            info.setCanIndex(false);\n+            return;\n+        }\n+\n+        org.apache.openjpa.jdbc.schema.Index idx =\n+            new org.apache.openjpa.jdbc.schema.Index();\n+        if (!StringUtils.isEmpty(name))\n+            idx.setName(name);\n+        idx.setUnique(unique);\n+        info.setIndex(idx);\n+    }\n+\n+    /**\n+     * Set unique data on the given mapping info.\n+     */\n+    private void parseUnique(FieldMapping fm, Unique anno) {\n+        ValueMappingInfo info = fm.getValueInfo();\n+        if (!anno.enabled()) {\n+            info.setCanUnique(false);\n+            return;\n+        }\n+\n+        org.apache.openjpa.jdbc.schema.Unique unq =\n+            new org.apache.openjpa.jdbc.schema.Unique();\n+        if (!StringUtils.isEmpty(anno.name()))\n+            unq.setName(anno.name());\n+        unq.setDeferred(anno.deferred());\n+        info.setUnique(unq);\n+    }\n+\n+    /**\n+     * Parse @VersionColumn(s).\n+     */\n+    private void parseVersionColumns(ClassMapping cm, VersionColumn... vcols) {\n+        if (vcols.length == 0)\n+            return;\n+\n+        List<Column> cols = new ArrayList<Column>(vcols.length);\n+        for (VersionColumn vcol : vcols)\n+            cols.add(newColumn(vcol));\n+        cm.getVersion().getMappingInfo().setColumns(cols);\n+    }\n+\n+    /**\n+     * Create a new schema column with information from the given annotation.\n+     */\n+    private static Column newColumn(VersionColumn anno) {\n+        Column col = new Column();\n+        if (!StringUtils.isEmpty(anno.name()))\n+            col.setName(anno.name());\n+        if (!StringUtils.isEmpty(anno.columnDefinition()))\n+            col.setTypeName(anno.columnDefinition());\n+        if (anno.precision() != 0)\n+            col.setSize(anno.precision());\n+        else if (anno.length() != 255)\n+            col.setSize(anno.length());\n+        col.setNotNull(!anno.nullable());\n+        col.setDecimalDigits(anno.scale());\n+        col.setFlag(Column.FLAG_UNINSERTABLE, !anno.insertable());\n+        col.setFlag(Column.FLAG_UNUPDATABLE, !anno.updatable());\n+        return col;\n+    }\n+\n+    /**\n+     * Translate the fetch mode enum value to the internal OpenJPA constant.\n+     */\n+    private static int toEagerFetchModeConstant(EagerFetchType type) {\n+        switch (type) {\n+            case NONE:\n+                return EagerFetchModes.EAGER_NONE;\n+            case JOIN:\n+                return EagerFetchModes.EAGER_JOIN;\n+            case PARALLEL:\n+                return EagerFetchModes.EAGER_PARALLEL;\n+            default:\n+                throw new InternalException();\n+        }\n+    }\n+\n+    @Override\n+    protected void parseLobMapping(FieldMetaData fmd) {\n+        Column col = new Column();\n+        if (fmd.getDeclaredTypeCode() == JavaTypes.STRING\n+            || fmd.getDeclaredType() == char[].class\n+            || fmd.getDeclaredType() == Character[].class)\n+            col.setType(Types.CLOB);\n+        else\n+            col.setType(Types.BLOB);\n+        ((FieldMapping) fmd).getValueInfo().setColumns(Arrays.asList\n+            (new Column[]{ col }));\n+    }\n+\n+    @Override\n+    protected void parseMemberMappingAnnotations(FieldMetaData fmd) {\n+        FieldMapping fm = (FieldMapping) fmd;\n+        AnnotatedElement el = (AnnotatedElement) getRepository().\n+            getMetaDataFactory().getDefaults().getBackingMember(fmd);\n+\n+        MappingTag tag;\n+        for (Annotation anno : el.getDeclaredAnnotations()) {\n+            tag = _tags.get(anno.annotationType());\n+            if (tag == null) {\n+                handleUnknownMemberMappingAnnotation(fm, anno);\n+                continue;\n+            }\n+\n+            switch (tag) {\n+                case ASSOC_OVERRIDE:\n+                    parseAssociationOverrides(fm, (AssociationOverride) anno);\n+                    break;\n+                case ASSOC_OVERRIDES:\n+                    parseAssociationOverrides(fm, ((AssociationOverrides) anno).\n+                        value());\n+                    break;\n+                case ATTR_OVERRIDE:\n+                    parseAttributeOverrides(fm, (AttributeOverride) anno);\n+                    break;\n+                case ATTR_OVERRIDES:\n+                    parseAttributeOverrides(fm, ((AttributeOverrides) anno).\n+                        value());\n+                    break;\n+                case COL:\n+                    parseColumns(fm, (javax.persistence.Column) anno);\n+                    break;\n+                case COLS:\n+                    parseColumns(fm, ((Columns) anno).value());\n+                    break;\n+                case ENUMERATED:\n+                    parseEnumerated(fm, (Enumerated) anno);\n+                    break;\n+                case JOIN_COL:\n+                    parseJoinColumns(fm, fm.getValueInfo(), true,\n+                        (JoinColumn) anno);\n+                    break;\n+                case JOIN_COLS:\n+                    parseJoinColumns(fm, fm.getValueInfo(), true,\n+                        ((JoinColumns) anno).value());\n+                    break;\n+                case JOIN_TABLE:\n+                    parseJoinTable(fm, (JoinTable) anno);\n+                    break;\n+                case PK_JOIN_COL:\n+                    parsePrimaryKeyJoinColumns(fm, (PrimaryKeyJoinColumn) anno);\n+                    break;\n+                case PK_JOIN_COLS:\n+                    parsePrimaryKeyJoinColumns(fm,\n+                        ((PrimaryKeyJoinColumns) anno).\n+                            value());\n+                    break;\n+                case TABLE_GEN:\n+                    parseTableGenerator(el, (TableGenerator) anno);\n+                    break;\n+                case TEMPORAL:\n+                    parseTemporal(fm, (Temporal) anno);\n+                    break;\n+                case CLASS_CRIT:\n+                    fm.getValueInfo().setUseClassCriteria\n+                        (((ClassCriteria) anno).value());\n+                    break;\n+                case CONTAINER_TABLE:\n+                    parseContainerTable(fm, (ContainerTable) anno);\n+                    break;\n+                case EAGER_FETCH_MODE:\n+                    fm.setEagerFetchMode(toEagerFetchModeConstant\n+                        (((EagerFetchMode) anno).value()));\n+                    break;\n+                case ELEM_CLASS_CRIT:\n+                    fm.getElementMapping().getValueInfo().setUseClassCriteria\n+                        (((ElementClassCriteria) anno).value());\n+                    break;\n+                case ELEM_FK:\n+                    ElementForeignKey efk = (ElementForeignKey) anno;\n+                    parseForeignKey(fm.getElementMapping().getValueInfo(),\n+                        efk.name(), efk.enabled(), efk.deferred(),\n+                        efk.deleteAction(), efk.updateAction());\n+                    break;\n+                case ELEM_INDEX:\n+                    ElementIndex eidx = (ElementIndex) anno;\n+                    parseIndex(fm.getElementMapping().getValueInfo(),\n+                        eidx.name(), eidx.enabled(), eidx.unique());\n+                    break;\n+                case ELEM_JOIN_COL:\n+                    parseElementJoinColumns(fm, (ElementJoinColumn) anno);\n+                    break;\n+                case ELEM_JOIN_COLS:\n+                    parseElementJoinColumns(fm, ((ElementJoinColumns) anno).\n+                        value());\n+                    break;\n+                case ELEM_NONPOLY:\n+                    fm.getElementMapping().setPolymorphic(toPolymorphicConstant\n+                        (((ElementNonpolymorphic) anno).value()));\n+                    break;\n+                case EMBEDDED_MAPPING:\n+                    parseEmbeddedMapping(fm, (EmbeddedMapping) anno);\n+                    break;\n+                case FK:\n+                    parseForeignKey(fm.getValueInfo(), (ForeignKey) anno);\n+                    break;\n+                case INDEX:\n+                    parseIndex(fm.getValueInfo(), (Index) anno);\n+                    break;\n+                case NONPOLY:\n+                    fm.setPolymorphic(toPolymorphicConstant\n+                        (((Nonpolymorphic) anno).value()));\n+                    break;\n+                case ORDER_COL:\n+                    parseOrderColumn(fm, (OrderColumn) anno);\n+                    break;\n+                case STRAT:\n+                    fm.getValueInfo().setStrategy(((Strategy) anno).value());\n+                    break;\n+                case UNIQUE:\n+                    parseUnique(fm, (Unique) anno);\n+                    break;\n+                case X_JOIN_COL:\n+                    parseXJoinColumns(fm, fm.getValueInfo(), true,\n+                        (XJoinColumn) anno);\n+                    break;\n+                case X_JOIN_COLS:\n+                    parseXJoinColumns(fm, fm.getValueInfo(), true,\n+                        ((XJoinColumns) anno).value());\n+                    break;\n+                default:\n+                    throw new UnsupportedException(_loc.get(\"unsupported\", fm,\n+                        anno.toString()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Allow subclasses to handle unknown annotations.\n+     */\n+    protected boolean handleUnknownMemberMappingAnnotation(FieldMapping fm,\n+        Annotation anno) {\n+        return false;\n+    }\n+\n+    /**\n+     * Return the {@link ValueMapping} <code>POLY_*</code> constant for\n+     * the given enum value.\n+     */\n+    protected static int toPolymorphicConstant(NonpolymorphicType val) {\n+        switch (val) {\n+            case EXACT:\n+                return ValueMapping.POLY_FALSE;\n+            case JOINABLE:\n+                return ValueMapping.POLY_JOINABLE;\n+            case FALSE:\n+                return ValueMapping.POLY_TRUE;\n+            default:\n+                throw new InternalException();\n+        }\n+    }\n+\n+    /**\n+     * Parse given @AssociationOverride annotations on an embedded mapping.\n+     */\n+    private void parseAssociationOverrides(FieldMapping fm,\n+        AssociationOverride... assocs) {\n+        ClassMapping embed = fm.getEmbeddedMapping();\n+        if (embed == null)\n+            throw new MetaDataException(_loc.get(\"not-embedded\", fm));\n+\n+        FieldMapping efm;\n+        JoinColumn[] ecols;\n+        int unique;\n+        List<Column> jcols;\n+        for (AssociationOverride assoc : assocs) {\n+            efm = embed.getFieldMapping(assoc.name());\n+            if (efm == null)\n+                throw new MetaDataException(_loc.get(\"embed-override-name\",\n+                    fm, assoc.name()));\n+            ecols = assoc.joinColumns();\n+            if (ecols == null || ecols.length == 0)\n+                continue;\n+\n+            unique = 0;\n+            jcols = new ArrayList<Column>(ecols.length);\n+            for (JoinColumn ecol : ecols) {\n+                unique |= (ecol.unique()) ? TRUE : FALSE;\n+                jcols.add(newColumn(ecol));\n+            }\n+            setColumns(efm, efm.getValueInfo(), jcols, unique);\n+        }\n+    }\n+\n+    /**\n+     * Parse given @AttributeOverride annotations on an embedded mapping.\n+     */\n+    private void parseAttributeOverrides(FieldMapping fm,\n+        AttributeOverride... attrs) {\n+        ClassMapping embed = fm.getEmbeddedMapping();\n+        if (embed == null)\n+            throw new MetaDataException(_loc.get(\"not-embedded\", fm));\n+\n+        FieldMapping efm;\n+        javax.persistence.Column ecol;\n+        int unique;\n+        for (AttributeOverride attr : attrs) {\n+            efm = embed.getFieldMapping(attr.name());\n+            if (efm == null)\n+                throw new MetaDataException(_loc.get(\"embed-override-name\",\n+                    fm, attr.name()));\n+            ecol = attr.column();\n+            if (ecol == null)\n+                continue;\n+\n+            unique = (ecol.unique()) ? TRUE : FALSE;\n+            setColumns(efm, efm.getValueInfo(), Arrays.asList\n+                (new Column[]{ newColumn(ecol) }), unique);\n+        }\n+    }\n+\n+    /**\n+     * Parse @Enumerated.\n+     */\n+    private void parseEnumerated(FieldMapping fm, Enumerated anno) {\n+        String strat = EnumValueHandler.class.getName() + \"(StoreOrdinal=\"\n+            + String.valueOf(anno.value() == EnumType.ORDINAL) + \")\";\n+        fm.getValueInfo().setStrategy(strat);\n+    }\n+\n+    /**\n+     * Parse @Temporal.\n+     */\n+    private void parseTemporal(FieldMapping fm, Temporal anno) {\n+        List cols = fm.getValueInfo().getColumns();\n+        if (!cols.isEmpty() && cols.size() != 1)\n+            throw new MetaDataException(_loc.get(\"num-cols-mismatch\", fm,\n+                String.valueOf(cols.size()), \"1\"));\n+        if (cols.isEmpty())\n+            cols = Arrays.asList(new Column[]{ new Column() });\n+\n+        Column col = (Column) cols.get(0);\n+        switch (anno.value()) {\n+            case DATE:\n+                col.setType(Types.DATE);\n+                break;\n+            case TIME:\n+                col.setType(Types.TIME);\n+                break;\n+            case TIMESTAMP:\n+                col.setType(Types.TIMESTAMP);\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Parse @Column(s).\n+     */\n+    protected void parseColumns(FieldMapping fm,\n+        javax.persistence.Column... pcols) {\n+        if (pcols.length == 0)\n+            return;\n+\n+        // might already have some column information from mapping annotation\n+        List cols = fm.getValueInfo().getColumns();\n+        if (!cols.isEmpty() && cols.size() != pcols.length)\n+            throw new MetaDataException(_loc.get(\"num-cols-mismatch\", fm,\n+                String.valueOf(cols.size()), String.valueOf(pcols.length)));\n+\n+        int unique = 0;\n+        String secondary = null;\n+        for (int i = 0; i < pcols.length; i++) {\n+            if (cols.size() > i)\n+                setupColumn((Column) cols.get(i), pcols[i]);\n+            else {\n+                if (cols.isEmpty())\n+                    cols = new ArrayList<Column>(pcols.length);\n+                cols.add(newColumn(pcols[i]));\n+            }\n+\n+            unique |= (pcols[i].unique()) ? TRUE : FALSE;\n+            secondary = trackSecondaryTable(fm, secondary,\n+                pcols[i].table(), i);\n+        }\n+\n+        setColumns(fm, fm.getValueInfo(), cols, unique);\n+        if (secondary != null)\n+            fm.getMappingInfo().setTableName(secondary);\n+    }\n+\n+    /**\n+     * Create a new schema column with information from the given annotation.\n+     */\n+    private static Column newColumn(javax.persistence.Column anno) {\n+        Column col = new Column();\n+        setupColumn(col, anno);\n+        return col;\n+    }\n+\n+    /**\n+     * Setup the given column with information from the given annotation.\n+     */\n+    private static void setupColumn(Column col, javax.persistence.Column anno) {\n+        if (!StringUtils.isEmpty(anno.name()))\n+            col.setName(anno.name());\n+        if (!StringUtils.isEmpty(anno.columnDefinition()))\n+            col.setTypeName(anno.columnDefinition());\n+        if (anno.precision() != 0)\n+            col.setSize(anno.precision());\n+        else if (anno.length() != 255)\n+            col.setSize(anno.length());\n+        col.setNotNull(!anno.nullable());\n+        col.setDecimalDigits(anno.scale());\n+        col.setFlag(Column.FLAG_UNINSERTABLE, !anno.insertable());\n+        col.setFlag(Column.FLAG_UNUPDATABLE, !anno.updatable());\n+    }\n+\n+    /**\n+     * Set the given columns as the columns for <code>fm</code>.\n+     *\n+     * @param unique bitwise combination of TRUE and FALSE for the\n+     * unique attribute of each column\n+     */\n+    protected void setColumns(FieldMapping fm, MappingInfo info,\n+        List<Column> cols, int unique) {\n+        info.setColumns(cols);\n+        if (unique == TRUE)\n+            info.setUnique(new org.apache.openjpa.jdbc.schema.Unique());\n+\n+        //### EJB3\n+        Log log = getLog();\n+        if (log.isWarnEnabled() && unique == (TRUE | FALSE))\n+            log.warn(_loc.get(\"inconsist-col-attrs\", fm));\n+    }\n+\n+    /**\n+     * Helper to track the secondary table for a set of columns.\n+     *\n+     * @param secondary secondary table for last column\n+     * @param colSecondary secondary table for current column\n+     * @return secondary table for field\n+     */\n+    private String trackSecondaryTable(FieldMapping fm, String secondary,\n+        String colSecondary, int col) {\n+        if (StringUtils.isEmpty(colSecondary))\n+            colSecondary = null;\n+        if (col == 0)\n+            return colSecondary;\n+        if (!StringUtils.equalsIgnoreCase(secondary, colSecondary))\n+            throw new MetaDataException(_loc.get(\"second-inconsist\", fm));\n+        return secondary;\n+    }\n+\n+    /**\n+     * Parse @JoinTable.\n+     */\n+    private void parseJoinTable(FieldMapping fm, JoinTable join) {\n+        fm.getMappingInfo().setTableName(toTableName(join.schema(),\n+            join.name()));\n+        parseJoinColumns(fm, fm.getMappingInfo(), false, join.joinColumns());\n+        parseJoinColumns(fm, fm.getElementMapping().getValueInfo(), false,\n+            join.inverseJoinColumns());\n+    }\n+\n+    /**\n+     * Parse given @JoinColumn annotations.\n+     */\n+    private void parseJoinColumns(FieldMapping fm, MappingInfo info,\n+        boolean secondaryAllowed, JoinColumn... joins) {\n+        if (joins.length == 0)\n+            return;\n+\n+        List<Column> cols = new ArrayList<Column>(joins.length);\n+        int unique = 0;\n+        String secondary = null;\n+        for (int i = 0; i < joins.length; i++) {\n+            cols.add(newColumn(joins[i]));\n+            unique |= (joins[i].unique()) ? TRUE : FALSE;\n+            secondary = trackSecondaryTable(fm, secondary,\n+                joins[i].table(), i);\n+            if (!secondaryAllowed && secondary != null)\n+                throw new MetaDataException(_loc.get(\"bad-second\", fm));\n+        }\n+\n+        setColumns(fm, info, cols, unique);\n+        if (secondary != null)\n+            fm.getMappingInfo().setTableName(secondary);\n+    }\n+\n+    /**\n+     * Create a new schema column with information from the given annotation.\n+     */\n+    private static Column newColumn(JoinColumn join) {\n+        Column col = new Column();\n+        if (!StringUtils.isEmpty(join.name()))\n+            col.setName(join.name());\n+        if (!StringUtils.isEmpty(join.columnDefinition()))\n+            col.setName(join.columnDefinition());\n+        if (!StringUtils.isEmpty(join.referencedColumnName()))\n+            col.setTarget(join.referencedColumnName());\n+        col.setNotNull(!join.nullable());\n+        col.setFlag(Column.FLAG_UNINSERTABLE, !join.insertable());\n+        col.setFlag(Column.FLAG_UNUPDATABLE, !join.updatable());\n+        return col;\n+    }\n+\n+    /**\n+     * Parse given @PrimaryKeyJoinColumn annotations.\n+     */\n+    private void parsePrimaryKeyJoinColumns(FieldMapping fm,\n+        PrimaryKeyJoinColumn... joins) {\n+        List<Column> cols = new ArrayList<Column>(joins.length);\n+        for (PrimaryKeyJoinColumn join : joins)\n+            cols.add(newColumn(join));\n+        setColumns(fm, fm.getValueInfo(), cols, 0);\n+    }\n+\n+    /**\n+     * Parse given @XJoinColumn annotations.\n+     */\n+    protected void parseXJoinColumns(FieldMapping fm, MappingInfo info,\n+        boolean secondaryAllowed, XJoinColumn... joins) {\n+        if (joins.length == 0)\n+            return;\n+\n+        List<Column> cols = new ArrayList<Column>(joins.length);\n+        int unique = 0;\n+        String secondary = null;\n+        for (int i = 0; i < joins.length; i++) {\n+            cols.add(newColumn(joins[i]));\n+            unique |= (joins[i].unique()) ? TRUE : FALSE;\n+            secondary = trackSecondaryTable(fm, secondary,\n+                joins[i].table(), i);\n+            if (!secondaryAllowed && secondary != null)\n+                throw new MetaDataException(_loc.get(\"bad-second\", fm));\n+        }\n+\n+        setColumns(fm, info, cols, unique);\n+        if (secondary != null)\n+            fm.getMappingInfo().setTableName(secondary);\n+    }\n+\n+    /**\n+     * Create a new schema column with information from the given annotation.\n+     */\n+    private static Column newColumn(XJoinColumn join) {\n+        Column col = new Column();\n+        if (!StringUtils.isEmpty(join.name()))\n+            col.setName(join.name());\n+        if (!StringUtils.isEmpty(join.columnDefinition()))\n+            col.setName(join.columnDefinition());\n+        if (!StringUtils.isEmpty(join.referencedColumnName()))\n+            col.setTarget(join.referencedColumnName());\n+        if (!StringUtils.isEmpty(join.referencedAttributeName()))\n+            col.setTargetField(join.referencedAttributeName());\n+        col.setNotNull(!join.nullable());\n+        col.setFlag(Column.FLAG_UNINSERTABLE, !join.insertable());\n+        col.setFlag(Column.FLAG_UNUPDATABLE, !join.updatable());\n+        return col;\n+    }\n+\n+    /**\n+     * Parse embedded info for the given mapping.\n+     */\n+    private void parseEmbeddedMapping(FieldMapping fm, EmbeddedMapping anno) {\n+        ClassMapping embed = fm.getEmbeddedMapping();\n+        if (embed == null)\n+            throw new MetaDataException(_loc.get(\"not-embedded\", fm));\n+\n+        FieldMapping efm;\n+        for (MappingOverride over : anno.overrides()) {\n+            efm = embed.getFieldMapping(over.name());\n+            if (efm == null)\n+                throw new MetaDataException(_loc.get(\"embed-override-name\",\n+                    fm, over.name()));\n+            populate(efm, over);\n+        }\n+\n+        String nullInd = null;\n+        if (!StringUtils.isEmpty(anno.nullIndicatorAttributeName()))\n+            nullInd = anno.nullIndicatorAttributeName();\n+        else if (!StringUtils.isEmpty(anno.nullIndicatorColumnName()))\n+            nullInd = anno.nullIndicatorColumnName();\n+        if (nullInd == null)\n+            return;\n+\n+        ValueMappingInfo info = fm.getValueInfo();\n+        if (\"false\".equals(nullInd))\n+            info.setCanIndicateNull(false);\n+        else {\n+            Column col = new Column();\n+            if (!\"true\".equals(nullInd))\n+                col.setName(nullInd);\n+            info.setColumns(Arrays.asList(new Column[]{ col }));\n+        }\n+    }\n+\n+    /**\n+     * Parse @ContainerTable.\n+     */\n+    protected void parseContainerTable(FieldMapping fm, ContainerTable ctbl) {\n+        fm.getMappingInfo().setTableName(toTableName(ctbl.schema(),\n+            ctbl.name()));\n+        parseXJoinColumns(fm, fm.getMappingInfo(), false, ctbl.joinColumns());\n+        if (ctbl.joinForeignKey().specified())\n+            parseForeignKey(fm.getMappingInfo(), ctbl.joinForeignKey());\n+        if (ctbl.joinIndex().specified())\n+            parseIndex(fm.getMappingInfo(), ctbl.joinIndex());\n+    }\n+\n+    /**\n+     * Parse @OrderColumn.\n+     */\n+    private void parseOrderColumn(FieldMapping fm, OrderColumn order) {\n+        if (!order.enabled()) {\n+            fm.getMappingInfo().setCanOrderColumn(false);\n+            return;\n+        }\n+\n+        Column col = new Column();\n+        if (!StringUtils.isEmpty(order.name()))\n+            col.setName(order.name());\n+        if (!StringUtils.isEmpty(order.columnDefinition()))\n+            col.setTypeName(order.columnDefinition());\n+        if (order.precision() != 0)\n+            col.setSize(order.precision());\n+        col.setFlag(Column.FLAG_UNINSERTABLE, !order.insertable());\n+        col.setFlag(Column.FLAG_UNUPDATABLE, !order.updatable());\n+        fm.getMappingInfo().setOrderColumn(col);\n+    }\n+\n+    /**\n+     * Parse @ElementJoinColumn(s).\n+     */\n+    protected void parseElementJoinColumns(FieldMapping fm,\n+        ElementJoinColumn... joins) {\n+        if (joins.length == 0)\n+            return;\n+\n+        List<Column> cols = new ArrayList<Column>(joins.length);\n+        int unique = 0;\n+        for (int i = 0; i < joins.length; i++) {\n+            cols.add(newColumn(joins[i]));\n+            unique |= (joins[i].unique()) ? TRUE : FALSE;\n+        }\n+        setColumns(fm, fm.getElementMapping().getValueInfo(), cols, unique);\n+    }\n+\n+    /**\n+     * Create a new schema column with information from the given annotation.\n+     */\n+    private static Column newColumn(ElementJoinColumn join) {\n+        Column col = new Column();\n+        if (!StringUtils.isEmpty(join.name()))\n+            col.setName(join.name());\n+        if (!StringUtils.isEmpty(join.columnDefinition()))\n+            col.setName(join.columnDefinition());\n+        if (!StringUtils.isEmpty(join.referencedColumnName()))\n+            col.setTarget(join.referencedColumnName());\n+        if (!StringUtils.isEmpty(join.referencedAttributeName()))\n+            col.setTargetField(join.referencedAttributeName());\n+        col.setNotNull(!join.nullable());\n+        col.setFlag (Column.FLAG_UNINSERTABLE, !join.insertable ());\n+\t\tcol.setFlag (Column.FLAG_UNUPDATABLE, !join.updatable ());\n+\t\treturn col;\n+\t}\n+}"},{"sha":"eb6402caca34b315a39f498aecdb7474b60095b9","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ClassCriteria.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ClassCriteria.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ClassCriteria.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ClassCriteria.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Marker interface specifying to use the expected class of the relation\n+ * as criteria in the join.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface ClassCriteria {\n+\n+    boolean value() default true;\n+}"},{"sha":"05c46dad46d46ddaa52f111897a530a52cbb0c69","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Columns.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Columns.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Columns.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Columns.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+import javax.persistence.Column;\n+\n+/**\n+ * Allows the specification of multiple columns for complex mappings.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface Columns {\n+\n+    Column[] value() default {};\n+}"},{"sha":"a2a9b63924c13b83fcaca1684de876b8ab21499e","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ContainerTable.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ContainerTable.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ContainerTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ContainerTable.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Table for array, collection, or map elements.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface ContainerTable {\n+\n+    String name() default \"\";\n+\n+    String catalog() default \"\";\n+\n+    String schema() default \"\";\n+\n+    XJoinColumn[] joinColumns() default {};\n+\n+    ForeignKey joinForeignKey() default @ForeignKey(specified = false);\n+\n+    Index joinIndex() default @Index(specified = false);\n+\n+    boolean specified() default true;\n+}"},{"sha":"71a6e64811f32dd2a055b5a36346f511d445e4c3","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/DataStoreIdColumn.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/DataStoreIdColumn.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/DataStoreIdColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/DataStoreIdColumn.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.TYPE;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Surrogate datastore identity column.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ TYPE })\n+@Retention(RUNTIME)\n+public @interface DataStoreIdColumn {\n+\n+    String name() default \"\";\n+\n+    boolean insertable() default true;\n+\n+    boolean updatable() default true;\n+\n+    String columnDefinition() default \"\";\n+\n+    int precision() default 0; // decimal precision\n+}"},{"sha":"c37443326d821f1f14ea6963a461e38b07b33df5","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/DiscriminatorStrategy.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/DiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/DiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/DiscriminatorStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.TYPE;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Discriminator mapping strategy.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ TYPE })\n+@Retention(RUNTIME)\n+public @interface DiscriminatorStrategy {\n+\n+    String value() default \"\";\n+}"},{"sha":"66e7e8986df57c6a2c8099e01d5f06d6c50b1645","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/EagerFetchMode.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/EagerFetchMode.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/EagerFetchMode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/EagerFetchMode.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Determines how to eager-fetch a field.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface EagerFetchMode {\n+\n+    EagerFetchType value() default EagerFetchType.NONE;\n+}"},{"sha":"4eeabeb152321144bf3f4cbb105ea1812c84b222","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/EagerFetchType.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/EagerFetchType.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/EagerFetchType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/EagerFetchType.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+/**\n+ * Type of fetching to employ.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+public enum EagerFetchType {\n+\n+    NONE,\n+    JOIN,\n+    PARALLEL };"},{"sha":"d986bfb8c703e2cd4075b615b137e6e4d72a1f09","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementClassCriteria.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementClassCriteria.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementClassCriteria.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementClassCriteria.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Marker interface specifying to use the expected class of the array,\n+ * collection, or map element relation as criteria in the join.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface ElementClassCriteria {\n+\n+    boolean value() default true;\n+}"},{"sha":"25eab0abb119da62ae931655be1e5899efa232b3","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementForeignKey.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementForeignKey.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementForeignKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementForeignKey.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Foreign key on array, collection, or map element columns.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface ElementForeignKey {\n+\n+    String name() default \"\";\n+\n+    boolean enabled() default true;\n+\n+    boolean deferred() default false;\n+\n+    ForeignKeyAction deleteAction() default ForeignKeyAction.RESTRICT;\n+\n+    ForeignKeyAction updateAction() default ForeignKeyAction.RESTRICT;\n+}"},{"sha":"3093dd6cceda969415a03d2d14380bdb1167e6a8","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementIndex.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementIndex.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementIndex.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementIndex.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Index on array, collection, or map element columns.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface ElementIndex {\n+\n+    String name() default \"\";\n+\n+    boolean enabled() default true;\n+\n+    boolean unique() default false;\n+}"},{"sha":"e82f497310807c1dc0628e54f53572af71849f89","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementJoinColumn.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementJoinColumn.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementJoinColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementJoinColumn.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Array, collection, or map element join column.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface ElementJoinColumn {\n+\n+    String name() default \"\";\n+\n+    String referencedColumnName() default \"\";\n+\n+    String referencedAttributeName() default \"\";\n+\n+    boolean unique() default false;\n+\n+    boolean nullable() default true;\n+\n+    boolean insertable() default true;\n+\n+    boolean updatable() default true;\n+\n+    String columnDefinition() default \"\";\n+}"},{"sha":"e9eb510d1173300567c98c8426714c4e1ab75024","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementJoinColumns.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementJoinColumns.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementJoinColumns.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementJoinColumns.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Allows the specification of multiple array, collection, or map element\n+ * columns for compound joins.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface ElementJoinColumns {\n+\n+    ElementJoinColumn[] value() default {};\n+}"},{"sha":"e62762acd9aa6d0fc3f5aef21dda1a2eb2d17d4f","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementNonpolymorphic.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementNonpolymorphic.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementNonpolymorphic.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementNonpolymorphic.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Indicates that the annotated array, collection, or map's elements are\n+ * not entirely polymorphic.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface ElementNonpolymorphic {\n+\n+    NonpolymorphicType value() default NonpolymorphicType.EXACT;\n+}"},{"sha":"ba2594aa0e0bb8e01074eef067f0896f359aa816","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/EmbeddedMapping.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/EmbeddedMapping.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/EmbeddedMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/EmbeddedMapping.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Embedded mapping information.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface EmbeddedMapping {\n+\n+    public static final String TRUE = \"true\";\n+    public static final String FALSE = \"false\";\n+\n+    String nullIndicatorColumnName() default \"\";\n+\n+    String nullIndicatorAttributeName() default \"\";\n+\n+    MappingOverride[] overrides() default {};\n+}"},{"sha":"217b431f0f27cf909f48d5d985576bed74327a84","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ForeignKey.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ForeignKey.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ForeignKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ForeignKey.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.*;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Foreign key definition.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ TYPE, METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface ForeignKey {\n+\n+    String name() default \"\";\n+\n+    boolean enabled() default true;\n+\n+    boolean deferred() default false;\n+\n+    ForeignKeyAction deleteAction() default ForeignKeyAction.RESTRICT;\n+\n+    ForeignKeyAction updateAction() default ForeignKeyAction.RESTRICT;\n+\n+    String[] columnNames() default {};\n+\n+    boolean specified() default true;\n+}"},{"sha":"2ccc8e4e3925bb1147f117f0943970f2e20cecdc","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ForeignKeyAction.java","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ForeignKeyAction.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ForeignKeyAction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ForeignKeyAction.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,29 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+/**\n+ * Foreign key actions.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+public enum ForeignKeyAction {\n+\n+    RESTRICT,\n+    CASCADE,\n+    NULL,\n+    DEFAULT };"},{"sha":"027502aa2c12d4039d12afdf7f1415906e199a4e","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Index.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Index.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Index.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Index.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Index definition.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface Index {\n+\n+    String name() default \"\";\n+\n+    boolean enabled() default true;\n+\n+    boolean unique() default false;\n+\n+    String[] columnNames() default {};\n+\n+    boolean specified() default true;\n+}"},{"sha":"c6b37cdeb75763a88f58333114db0537b849ccc4","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlan.java","status":"added","additions":109,"deletions":0,"changes":109,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlan.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlan.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlan.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import org.apache.openjpa.jdbc.kernel.DelegatingJDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.EagerFetchModes;\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.LRSSizes;\n+import org.apache.openjpa.jdbc.sql.JoinSyntaxes;\n+import org.apache.openjpa.kernel.DelegatingFetchConfiguration;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.persistence.FetchPlan;\n+import org.apache.openjpa.persistence.PersistenceExceptions;\n+\n+/**\n+ * JDBC extensions to the fetch plan.\n+ *\n+ * @since 4.0\n+ * @author Abe White\n+ * @published\n+ */\n+public class JDBCFetchPlan\n+    extends FetchPlan\n+    implements EagerFetchModes, LRSSizes, JoinSyntaxes {\n+\n+    private DelegatingJDBCFetchConfiguration _fetch;\n+\n+    /**\n+     * Constructor; supply delegate.\n+     */\n+    public JDBCFetchPlan(FetchConfiguration fetch) {\n+        super(fetch);\n+    }\n+\n+    @Override\n+    protected DelegatingFetchConfiguration newDelegatingFetchConfiguration\n+        (FetchConfiguration fetch) {\n+        _fetch = new DelegatingJDBCFetchConfiguration((JDBCFetchConfiguration)\n+            fetch, PersistenceExceptions.TRANSLATOR);\n+        return _fetch;\n+    }\n+\n+    public int getEagerFetchMode() {\n+        return _fetch.getEagerFetchMode();\n+    }\n+\n+    public JDBCFetchPlan setEagerFetchMode(int mode) {\n+        _fetch.setEagerFetchMode(mode);\n+        return this;\n+    }\n+\n+    public int getSubclassFetchMode() {\n+        return _fetch.getSubclassFetchMode();\n+    }\n+\n+    public JDBCFetchPlan setSubclassFetchMode(int mode) {\n+        _fetch.setSubclassFetchMode(mode);\n+        return this;\n+    }\n+\n+    public int getResultSetType() {\n+        return _fetch.getResultSetType();\n+    }\n+\n+    public JDBCFetchPlan setResultSetType(int type) {\n+        _fetch.setResultSetType(type);\n+        return this;\n+    }\n+\n+    public int getFetchDirection() {\n+        return _fetch.getFetchDirection();\n+    }\n+\n+    public JDBCFetchPlan setFetchDirection(int direction) {\n+        _fetch.setFetchDirection(direction);\n+        return this;\n+    }\n+\n+    public int getLRSSize() {\n+        return _fetch.getLRSSize();\n+    }\n+\n+    public JDBCFetchPlan setLRSSize(int lrsSize) {\n+        _fetch.setLRSSize(lrsSize);\n+        return this;\n+    }\n+\n+    public int getJoinSyntax() {\n+        return _fetch.getJoinSyntax();\n+    }\n+\n+    public JDBCFetchPlan setJoinSyntax(int syntax) {\n+        _fetch.setJoinSyntax(syntax);\n+        return this;\n+    }\n+}"},{"sha":"b188bc8a55b3f1cc4b71a0c06675727b15b4f314","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCPersistenceProductDerivation.java","status":"added","additions":81,"deletions":0,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCPersistenceProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCPersistenceProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCPersistenceProductDerivation.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.conf.ProductDerivation;\n+import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\n+import org.apache.openjpa.persistence.FetchPlan;\n+import org.apache.openjpa.persistence.PersistenceProductDerivation;\n+\n+/**\n+ * Sets JDBC-specific JPA specification defaults.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class JDBCPersistenceProductDerivation\n+    implements ProductDerivation {\n+\n+    public int getType() {\n+        return TYPE_SPEC_STORE;\n+    }\n+\n+    public void beforeConfigurationConstruct(ConfigurationProvider cp) {\n+    }\n+\n+    public void beforeConfigurationLoad(OpenJPAConfiguration c) {\n+        if (!(c instanceof JDBCConfigurationImpl))\n+            return;\n+\n+        c.getStoreFacadeTypeRegistry().registerImplementation(\n+            FetchPlan.class, JDBCFetchPlan.class);\n+\n+        JDBCConfigurationImpl conf = (JDBCConfigurationImpl) c;\n+        String jpa = PersistenceProductDerivation.SPEC_JPA;\n+        String ejb = PersistenceProductDerivation.ALIAS_EJB;\n+\n+        conf.metaFactoryPlugin.setAlias(jpa,\n+            PersistenceMappingFactory.class.getName());\n+        conf.metaFactoryPlugin.setAlias(ejb,\n+            PersistenceMappingFactory.class.getName());\n+\n+        conf.mappingFactoryPlugin.setAlias(jpa,\n+            PersistenceMappingFactory.class.getName());\n+        conf.mappingFactoryPlugin.setAlias(ejb,\n+            PersistenceMappingFactory.class.getName());\n+\n+        conf.mappingDefaultsPlugin.setAlias(jpa,\n+            PersistenceMappingDefaults.class.getName());\n+        conf.mappingDefaultsPlugin.setAlias(ejb,\n+            PersistenceMappingDefaults.class.getName());\n+    }\n+\n+    public void afterSpecificationSet(OpenJPAConfiguration c) {\n+        String jpa = PersistenceProductDerivation.SPEC_JPA;\n+        if (!(c instanceof JDBCConfigurationImpl)\n+            || !jpa.equals(c.getSpecification()))\n+            return;\n+\n+        JDBCConfigurationImpl conf = (JDBCConfigurationImpl) c;\n+        conf.mappingDefaultsPlugin.setDefault(jpa);\n+        conf.mappingDefaultsPlugin.setString(jpa);\n+    }\n+\n+    public void afterClose(OpenJPAConfiguration c) {\n+    }\n+}"},{"sha":"1e1c4cce54f534d276a43c3aa378f772e066ef22","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingOverride.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingOverride.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingOverride.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingOverride.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.TYPE;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+import javax.persistence.Column;\n+\n+/**\n+ * Allows override of complex embedded or superclass mappings.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ TYPE })\n+@Retention(RUNTIME)\n+public @interface MappingOverride {\n+\n+    String name() default \"\";\n+\n+    Column[] columns() default {};\n+\n+    XJoinColumn[] joinColumns() default {};\n+\n+    ElementJoinColumn[] elementJoinColumns() default {};\n+\n+    ContainerTable containerTable() default @ContainerTable(specified = false);\n+}"},{"sha":"a65fd142c86e92ad38880ac47609a6a4c3dffecb","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingOverrides.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingOverrides.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingOverrides.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingOverrides.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.TYPE;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Allows override of complex embedded or superclass mappings.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ TYPE })\n+@Retention(RUNTIME)\n+public @interface MappingOverrides {\n+\n+    MappingOverride[] value() default {};\n+}"},{"sha":"0a527829a8eedf1db3015c71b2332f4ab1453caa","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingTag.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingTag.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingTag.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingTag.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+/////////////////////////////////////////////////////////\n+// NOTE: when adding a new type, make sure to update the\n+// table in PersistenceMappingParser\n+/////////////////////////////////////////////////////////\n+\n+/**\n+ * Set of mapping tags used in JPA.\n+ *\n+ * @author Abe White\n+ */\n+enum MappingTag {\n+\n+    ASSOC_OVERRIDE,\n+    ASSOC_OVERRIDES,\n+    ATTR_OVERRIDE,\n+    ATTR_OVERRIDES,\n+    COL,\n+    COLUMN_RESULT,\n+    DISCRIM_COL,\n+    DISCRIM_VAL,\n+    ENTITY_RESULT,\n+    ENUMERATED,\n+    FIELD_RESULT,\n+    GEN_ID_TABLE,\n+    INHERITANCE,\n+    JOIN_COL,\n+    JOIN_COLS,\n+    JOIN_TABLE,\n+    PK_JOIN_COL,\n+    PK_JOIN_COLS,\n+    SECONDARY_TABLE,\n+    SECONDARY_TABLES,\n+    SQL_RESULT_SET_MAPPING,\n+    SQL_RESULT_SET_MAPPINGS,\n+    TABLE,\n+    TABLE_GEN,\n+    TEMPORAL,\n+    // openjpa extensions\n+    CLASS_CRIT,\n+    COLS,\n+    CONTAINER_TABLE,\n+    DATASTORE_ID_COL,\n+    DISCRIM_STRAT,\n+    EAGER_FETCH_MODE,\n+    ELEM_CLASS_CRIT,\n+    ELEM_FK,\n+    ELEM_INDEX,\n+    ELEM_JOIN_COL,\n+    ELEM_JOIN_COLS,\n+    ELEM_NONPOLY,\n+    EMBEDDED_MAPPING,\n+    FK,\n+    INDEX,\n+    MAPPING_OVERRIDE,\n+    MAPPING_OVERRIDES,\n+    NONPOLY,\n+    ORDER_COL,\n+    STRAT,\n+    SUBCLASS_FETCH_MODE,\n+    UNIQUE,\n+    VERSION_COL,\n+    VERSION_COLS,\n+    VERSION_STRAT,\n+    X_JOIN_COL,\n+    X_JOIN_COLS,\n+    X_SECONDARY_TABLE,\n+    X_SECONDARY_TABLES,\n+    X_TABLE,\n+}"},{"sha":"e35b4ef2d486096cc3a245ffb9f7ec947d08fe0b","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Nonpolymorphic.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Nonpolymorphic.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Nonpolymorphic.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Nonpolymorphic.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Indicates that the annotated relation is not entirely polymorphic.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface Nonpolymorphic {\n+\n+    NonpolymorphicType value() default NonpolymorphicType.EXACT;\n+}"},{"sha":"3daa15621f201abc3b4d458c29e9c22c55c0f749","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/NonpolymorphicType.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/NonpolymorphicType.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/NonpolymorphicType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/NonpolymorphicType.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+/**\n+ * Nonpolymorphic settings.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+public enum NonpolymorphicType {\n+\n+    EXACT,\n+    JOINABLE,\n+    FALSE };"},{"sha":"ff138cac16db89469bee5853450c058b5bb16e93","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/OrderColumn.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/OrderColumn.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/OrderColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/OrderColumn.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Surrogate order column.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface OrderColumn {\n+\n+    String name() default \"\";\n+\n+    boolean enabled() default true;\n+\n+    boolean insertable() default true;\n+\n+    boolean updatable() default true;\n+\n+    String columnDefinition() default \"\";\n+\n+    int precision() default 0; // decimal precision\n+}"},{"sha":"c48f6fcfe1a45d1b9c5200d21fa120334c99c246","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java","status":"added","additions":165,"deletions":0,"changes":165,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.Discriminator;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.MappingDefaultsImpl;\n+import org.apache.openjpa.jdbc.meta.ValueMapping;\n+import org.apache.openjpa.jdbc.meta.Version;\n+import org.apache.openjpa.jdbc.meta.strats.FlatClassStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.NoneDiscriminatorStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.NoneVersionStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.NumberVersionStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.SubclassJoinDiscriminatorStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.ValueMapDiscriminatorStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.VerticalClassStrategy;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Schema;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.JoinSyntaxes;\n+import org.apache.openjpa.meta.JavaTypes;\n+import serp.util.Strings;\n+\n+/**\n+ * Supplies default mapping information in accordance with JPA spec.\n+ *\n+ * @author Steve Kim\n+ * @author Abe White\n+ */\n+public class PersistenceMappingDefaults\n+    extends MappingDefaultsImpl {\n+\n+    public PersistenceMappingDefaults() {\n+        setDefaultMissingInfo(true);\n+        setStoreEnumOrdinal(true);\n+        setOrderLists(false);\n+        setAddNullIndicator(false);\n+        setDiscriminatorColumnName(\"DTYPE\");\n+    }\n+\n+    @Override\n+    public Object getStrategy(Version vers, boolean adapt) {\n+        Object strat = super.getStrategy(vers, adapt);\n+        ClassMapping cls = vers.getClassMapping();\n+        if (strat != null || cls.getJoinablePCSuperclassMapping() != null\n+            || cls.getVersionField() != null)\n+            return strat;\n+\n+        if (vers.getMappingInfo().getColumns().isEmpty())\n+            return NoneVersionStrategy.getInstance();\n+        return new NumberVersionStrategy();\n+    }\n+\n+    @Override\n+    public Object getStrategy(Discriminator disc, boolean adapt) {\n+        Object strat = super.getStrategy(disc, adapt);\n+        ClassMapping cls = disc.getClassMapping();\n+        if (strat != null || cls.getJoinablePCSuperclassMapping() != null\n+            || disc.getMappingInfo().getValue() != null)\n+            return strat;\n+\n+        // don't use a column-based discriminator approach unless user has set\n+        // a column explicitly or is using flat inheritance explicitly\n+        if (!disc.getMappingInfo().getColumns().isEmpty())\n+            return new ValueMapDiscriminatorStrategy();\n+\n+        ClassMapping base = cls;\n+        while (base.getMappingInfo().getHierarchyStrategy() == null\n+            && base.getPCSuperclassMapping() != null)\n+            base = base.getPCSuperclassMapping();\n+\n+        strat = base.getMappingInfo().getHierarchyStrategy();\n+        if (FlatClassStrategy.ALIAS.equals(strat))\n+            return new ValueMapDiscriminatorStrategy();\n+        if (VerticalClassStrategy.ALIAS.equals(strat)\n+            && dict.joinSyntax != JoinSyntaxes.SYNTAX_TRADITIONAL)\n+            return new SubclassJoinDiscriminatorStrategy();\n+        return NoneDiscriminatorStrategy.getInstance();\n+    }\n+\n+    @Override\n+    public String getTableName(ClassMapping cls, Schema schema) {\n+        return Strings.getClassName(cls.getDescribedType()).replace('$', '_');\n+    }\n+\n+    @Override\n+    public String getTableName(FieldMapping fm, Schema schema) {\n+        // base name is table of defining type + '_'\n+        String name = fm.getDefiningMapping().getTable().getName() + \"_\";\n+\n+        // if this is an assocation table, spec says to suffix with table of\n+        // the related type. spec doesn't cover other cases; we're going to\n+        // suffix with the field name\n+        ClassMapping rel = fm.getElementMapping().getTypeMapping();\n+        boolean assoc = rel != null && rel.getTable() != null\n+            && fm.getTypeCode() != JavaTypes.MAP;\n+        if (assoc)\n+            name += rel.getTable().getName();\n+        else\n+            name += fm.getName();\n+        return name.replace('$', '_');\n+    }\n+\n+    @Override\n+    public void populateJoinColumn(FieldMapping fm, Table local, Table foreign,\n+        Column col, Object target, int pos, int cols) {\n+        // only use spec defaults with column targets\n+        if (!(target instanceof Column))\n+            return;\n+\n+        // if this is a bidi relation, prefix with inverse field name, else\n+        // prefix with owning entity name\n+        FieldMapping[] inverses = fm.getInverseMappings();\n+        String name;\n+        if (inverses.length > 0)\n+            name = inverses[0].getName();\n+        else\n+            name = fm.getDefiningMapping().getTypeAlias();\n+\n+        // suffix with '_' + target column\n+        name += \"_\" + ((Column) target).getName();\n+        col.setName(name);\n+    }\n+\n+    @Override\n+    public void populateForeignKeyColumn(ValueMapping vm, String name,\n+        Table local, Table foreign, Column col, Object target, boolean inverse,\n+        int pos, int cols) {\n+        // if this is a non-inverse collection element key, it must be in\n+        // a join table; jpa says to use the target column name,\n+        // which is the default\n+        if (!inverse && vm == vm.getFieldMapping().getElement()\n+            && vm.getFieldMapping().getTypeCode() != JavaTypes.MAP)\n+            return;\n+\n+        // otherwise jpa always uses <field>_<pkcol> for column name, even\n+        // when only one col\n+        if (target instanceof Column)\n+            col.setName(name + \"_\" + ((Column) target).getName());\n+    }\n+\n+    @Override\n+    public void populateColumns(Version vers, Table table, Column[] cols) {\n+        // check for version field and use its name as column name\n+        FieldMapping fm = vers.getClassMapping().getVersionFieldMapping();\n+        if (fm != null && cols.length == 1)\n+            cols[0].setName(fm.getName());\n+        else\n+            super.populateColumns(vers, table, cols);\n+    }\n+}"},{"sha":"a9d5e603a6948f8f3eea0a10924e92bc45b4f544","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingFactory.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.meta.MappingRepository;\n+import org.apache.openjpa.meta.MetaDataFactory;\n+import org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser;\n+import org.apache.openjpa.persistence.PersistenceMetaDataFactory;\n+import org.apache.openjpa.persistence.XMLPersistenceMetaDataParser;\n+\n+/**\n+ * {@link MetaDataFactory} for JPA mapping information.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+public class PersistenceMappingFactory\n+    extends PersistenceMetaDataFactory {\n+\n+    @Override\n+    protected AnnotationPersistenceMetaDataParser newAnnotationParser() {\n+        AnnotationPersistenceMappingParser parser =\n+            new AnnotationPersistenceMappingParser((JDBCConfiguration)\n+                repos.getConfiguration());\n+        // strict mode means we're using a separate mapping parser, so if\n+        // we're adapting parse metadata hints\n+        if (strict)\n+            parser.setMappingOverride(((MappingRepository) repos).\n+                getStrategyInstaller().isAdapting());\n+        return parser;\n+    }\n+\n+    @Override\n+    protected XMLPersistenceMetaDataParser newXMLParser(boolean loading) {\n+        XMLPersistenceMappingParser parser = new XMLPersistenceMappingParser\n+            ((JDBCConfiguration) repos.getConfiguration());\n+        // strict mode means we're using a separate mapping parser, so if\n+        // we're adapting parse metadata hints\n+        if (strict && loading)\n+            parser.setMappingOverride(((MappingRepository) repos).\n+                getStrategyInstaller().isAdapting());\n+        return parser;\n+    }\n+}"},{"sha":"776f35a7e959affc6b96a511faba6d38e0fd9e39","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Strategy.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Strategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Strategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Strategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.*;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Mapping strategy.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ TYPE, METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface Strategy {\n+\n+    String value() default \"\";\n+}"},{"sha":"24b0c7190e9edf57ae426fa176b2b5273d89e374","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/SubclassFetchMode.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/SubclassFetchMode.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/SubclassFetchMode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/SubclassFetchMode.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.TYPE;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Determines how to eager-fetch subclass data.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ TYPE })\n+@Retention(RUNTIME)\n+public @interface SubclassFetchMode {\n+\n+    EagerFetchType value() default EagerFetchType.NONE;\n+}"},{"sha":"48d34200ce4ef152252ac92b8a5524c3c74abff3","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Unique.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Unique.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Unique.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/Unique.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Unique constraint definition.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface Unique {\n+\n+    String name() default \"\";\n+\n+    boolean enabled() default true;\n+\n+    boolean deferred() default false;\n+\n+    String[] columnNames() default {};\n+}"},{"sha":"74d04ac4360f9c6b2ac0a56c4b676cf3ed1493a5","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/VersionColumn.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/VersionColumn.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/VersionColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/VersionColumn.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.TYPE;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Surrogate version column.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ TYPE })\n+@Retention(RUNTIME)\n+public @interface VersionColumn {\n+\n+    String name() default \"\";\n+\n+    boolean nullable() default true;\n+\n+    boolean insertable() default true;\n+\n+    boolean updatable() default true;\n+\n+    String columnDefinition() default \"\";\n+\n+    int length() default 255;\n+\n+    int precision() default 0; // decimal precision\n+\n+    int scale() default 0; // decimal scale\n+}"},{"sha":"8f49fa86ab0ded134e806af7a3543d772ea1f181","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/VersionColumns.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/VersionColumns.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/VersionColumns.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/VersionColumns.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.TYPE;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Allows the specification of multiple version columns for complex versioning.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ TYPE })\n+@Retention(RUNTIME)\n+public @interface VersionColumns {\n+\n+    VersionColumn[] value() default {};\n+}"},{"sha":"906166ead7ada6c10292acde8ec005831b894593","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/VersionStrategy.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/VersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/VersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/VersionStrategy.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.TYPE;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Version mapping strategy.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ TYPE })\n+@Retention(RUNTIME)\n+public @interface VersionStrategy {\n+\n+    String value() default \"\";\n+}"},{"sha":"70d73ce80c0b0e114b48254f0874ce1d9ce7b3f6","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XJoinColumn.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XJoinColumn.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XJoinColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XJoinColumn.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Extended join column.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface XJoinColumn {\n+\n+    String name() default \"\";\n+\n+    String referencedColumnName() default \"\";\n+\n+    String referencedAttributeName() default \"\";\n+\n+    boolean unique() default false;\n+\n+    boolean nullable() default true;\n+\n+    boolean insertable() default true;\n+\n+    boolean updatable() default true;\n+\n+    String columnDefinition() default \"\";\n+\n+    String table() default \"\";\n+}"},{"sha":"2a7110156c4d157d4b08405e5c30a46f561e494f","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XJoinColumns.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XJoinColumns.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XJoinColumns.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XJoinColumns.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Allows the specification of multiple columns for compound joins.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ METHOD, FIELD })\n+@Retention(RUNTIME)\n+public @interface XJoinColumns {\n+\n+    XJoinColumn[] value() default {};\n+}"},{"sha":"bb44596f781a5ac98a58619e59f25b4aeed10965","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMLPersistenceMappingParser.java","status":"added","additions":867,"deletions":0,"changes":867,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMLPersistenceMappingParser.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMLPersistenceMappingParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMLPersistenceMappingParser.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,867 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.persistence.DiscriminatorType;\n+import javax.persistence.EnumType;\n+import javax.persistence.InheritanceType;\n+import javax.persistence.TemporalType;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.SAXException;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.ClassMappingInfo;\n+import org.apache.openjpa.jdbc.meta.DiscriminatorMappingInfo;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.MappingRepository;\n+import org.apache.openjpa.jdbc.meta.QueryResultMapping;\n+import org.apache.openjpa.jdbc.meta.SequenceMapping;\n+import org.apache.openjpa.jdbc.meta.strats.EnumValueHandler;\n+import org.apache.openjpa.jdbc.meta.strats.FlatClassStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.FullClassStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.NoneClassStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.VerticalClassStrategy;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Unique;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.persistence.XMLPersistenceMetaDataParser;\n+import static org.apache.openjpa.persistence.jdbc.MappingTag.*;\n+\n+/**\n+ * Custom SAX parser used by the system to parse persistence mapping files.\n+ *\n+ * @author Steve Kim\n+ * @nojavadoc\n+ */\n+public class XMLPersistenceMappingParser\n+    extends XMLPersistenceMetaDataParser {\n+\n+    private static final Map<String, MappingTag> _elems =\n+        new HashMap<String, MappingTag>();\n+\n+    static {\n+        _elems.put(\"association-override\", ASSOC_OVERRIDE);\n+        _elems.put(\"attribute-override\", ATTR_OVERRIDE);\n+        _elems.put(\"column\", COL);\n+        _elems.put(\"column-result\", COLUMN_RESULT);\n+        _elems.put(\"discriminator-column\", DISCRIM_COL);\n+        _elems.put(\"discriminator-value\", DISCRIM_VAL);\n+        _elems.put(\"entity-result\", ENTITY_RESULT);\n+        _elems.put(\"enumerated\", ENUMERATED);\n+        _elems.put(\"field-result\", FIELD_RESULT);\n+        _elems.put(\"inheritance\", INHERITANCE);\n+        _elems.put(\"join-column\", JOIN_COL);\n+        _elems.put(\"inverse-join-column\", COL);\n+        _elems.put(\"join-table\", JOIN_TABLE);\n+        _elems.put(\"primary-key-join-column\", PK_JOIN_COL);\n+        _elems.put(\"secondary-table\", SECONDARY_TABLE);\n+        _elems.put(\"sql-result-set-mapping\", SQL_RESULT_SET_MAPPING);\n+        _elems.put(\"table\", TABLE);\n+        _elems.put(\"table-generator\", TABLE_GEN);\n+        _elems.put(\"temporal\", TEMPORAL);\n+    }\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (XMLPersistenceMappingParser.class);\n+\n+    private String _override = null;\n+    private String _schema = null;\n+    private String _colTable = null;\n+    private String _secondaryTable = null;\n+    private List<Column> _cols = null;\n+    private List<Column> _joinCols = null;\n+    private List<Column> _supJoinCols = null;\n+    private boolean _lob = false;\n+    private TemporalType _temporal = null;\n+    private EnumSet<UniqueFlag> _unique = EnumSet.noneOf(UniqueFlag.class);\n+    private DiscriminatorType _discType;\n+    private Column _discCol;\n+    private int _resultIdx = 0;\n+\n+    /**\n+     * Constructor; supply configuration.\n+     */\n+    public XMLPersistenceMappingParser(JDBCConfiguration conf) {\n+        super(conf);\n+    }\n+\n+    /**\n+     * Create a new metadata repository.\n+     */\n+    @Override\n+    protected MetaDataRepository newRepository() {\n+        return ((JDBCConfiguration) getConfiguration()).\n+            newMappingRepositoryInstance();\n+    }\n+\n+    @Override\n+    protected void reset() {\n+        super.reset();\n+        clearColumnInfo();\n+        clearClassInfo();\n+        clearSecondaryTableInfo();\n+        _override = null;\n+        _schema = null;\n+        _resultIdx = 0;\n+    }\n+\n+    @Override\n+    protected Object startSystemMappingElement(String name, Attributes attrs)\n+        throws SAXException {\n+        MappingTag tag = _elems.get(name);\n+        if (tag == null) {\n+            if (\"schema\".equals(name))\n+                return name;\n+            return null;\n+        }\n+\n+        boolean ret;\n+        switch (tag) {\n+            case TABLE_GEN:\n+                ret = startTableGenerator(attrs);\n+                break;\n+            case SQL_RESULT_SET_MAPPING:\n+                ret = startSQLResultSetMapping(attrs);\n+                break;\n+            case ENTITY_RESULT:\n+                ret = startEntityResult(attrs);\n+                break;\n+            case FIELD_RESULT:\n+                ret = startFieldResult(attrs);\n+                break;\n+            case COLUMN_RESULT:\n+                ret = startColumnResult(attrs);\n+                break;\n+            default:\n+                ret = false;\n+        }\n+        return (ret) ? tag : null;\n+    }\n+\n+    @Override\n+    protected void endSystemMappingElement(String name)\n+        throws SAXException {\n+        MappingTag tag = _elems.get(name);\n+        if (tag == null) {\n+            if (\"schema\".equals(name))\n+                _schema = currentText();\n+            return;\n+        }\n+\n+        switch (tag) {\n+            case SQL_RESULT_SET_MAPPING:\n+                endSQLResultSetMapping();\n+                break;\n+            case ENTITY_RESULT:\n+                endEntityResult();\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    protected Object startClassMappingElement(String name, Attributes attrs)\n+        throws SAXException {\n+        MappingTag tag = _elems.get(name);\n+        if (tag == null)\n+            return null;\n+\n+        boolean ret;\n+        switch (tag) {\n+            case TABLE:\n+                ret = startTable(attrs);\n+                break;\n+            case SECONDARY_TABLE:\n+                ret = startSecondaryTable(attrs);\n+                break;\n+            case DISCRIM_COL:\n+                _discCol = parseColumn(attrs);\n+                ret = true;\n+                break;\n+            case DISCRIM_VAL:\n+                ret = true;\n+                break;\n+            case INHERITANCE:\n+                ret = startInheritance(attrs);\n+                break;\n+            case ASSOC_OVERRIDE:\n+            case ATTR_OVERRIDE:\n+                ret = startAttributeOverride(attrs);\n+                break;\n+            case PK_JOIN_COL:\n+                ret = startPrimaryKeyJoinColumn(attrs);\n+                break;\n+            case COL:\n+                ret = startColumn(attrs);\n+                break;\n+            case JOIN_COL:\n+                ret = startJoinColumn(attrs);\n+                break;\n+            case JOIN_TABLE:\n+                ret = startJoinTable(attrs);\n+                break;\n+            case TABLE_GEN:\n+                ret = startTableGenerator(attrs);\n+                break;\n+            case UNIQUE:\n+                getLog().warn(_loc.get(\"unique-constraints\", currentElement()));\n+                ret = false;\n+                break;\n+            case TEMPORAL:\n+            case ENUMERATED:\n+                ret = true;\n+                break;\n+            case SQL_RESULT_SET_MAPPING:\n+                ret = startSQLResultSetMapping(attrs);\n+                break;\n+            case ENTITY_RESULT:\n+                ret = startEntityResult(attrs);\n+                break;\n+            case FIELD_RESULT:\n+                ret = startFieldResult(attrs);\n+                break;\n+            case COLUMN_RESULT:\n+                ret = startColumnResult(attrs);\n+                break;\n+            default:\n+                ret = false;\n+        }\n+        return (ret) ? tag : null;\n+    }\n+\n+    @Override\n+    protected void endClassMappingElement(String name)\n+        throws SAXException {\n+        MappingTag tag = _elems.get(name);\n+        if (tag == null)\n+            return;\n+\n+        switch (tag) {\n+            case SECONDARY_TABLE:\n+                endSecondaryTable();\n+                break;\n+            case DISCRIM_VAL:\n+                endDiscriminatorValue();\n+                break;\n+            case ATTR_OVERRIDE:\n+                endAttributeOverride();\n+                break;\n+            case JOIN_TABLE:\n+                endJoinTable();\n+                break;\n+            case TEMPORAL:\n+                endTemporal();\n+                break;\n+            case ENUMERATED:\n+                endEnumerated();\n+                break;\n+            case SQL_RESULT_SET_MAPPING:\n+                endSQLResultSetMapping();\n+                break;\n+            case ENTITY_RESULT:\n+                endEntityResult();\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    protected void startClassMapping(ClassMetaData meta, boolean mappedSuper,\n+        Attributes attrs)\n+        throws SAXException {\n+        if (mappedSuper)\n+            ((ClassMapping) meta).getMappingInfo().setStrategy\n+                (NoneClassStrategy.ALIAS);\n+    }\n+\n+    @Override\n+    protected void endClassMapping(ClassMetaData meta)\n+        throws SAXException {\n+        ClassMapping cm = (ClassMapping) meta;\n+        if (_supJoinCols != null)\n+            cm.getMappingInfo().setColumns(_supJoinCols);\n+\n+        if (_discCol != null) {\n+            DiscriminatorMappingInfo dinfo = cm.getDiscriminator().\n+                getMappingInfo();\n+            if (_discType != null) {\n+                switch (_discType) {\n+                    case CHAR:\n+                        _discCol.setJavaType(JavaTypes.CHAR);\n+                        break;\n+                    case INTEGER:\n+                        _discCol.setJavaType(JavaTypes.INT);\n+                        break;\n+                    default:\n+                        _discCol.setJavaType(JavaTypes.STRING);\n+                        break;\n+                }\n+            }\n+            dinfo.setColumns(Arrays.asList(new Column[]{ _discCol }));\n+        }\n+        clearClassInfo();\n+    }\n+\n+    /**\n+     * Clear cached class mapping info.\n+     */\n+    private void clearClassInfo() {\n+        _supJoinCols = null;\n+        _discCol = null;\n+        _discType = null;\n+    }\n+\n+    /**\n+     * Start tracking secondary table information and columns\n+     */\n+    private boolean startSecondaryTable(Attributes attrs)\n+        throws SAXException {\n+        _secondaryTable = toTableName(attrs.getValue(\"schema\"),\n+            attrs.getValue(\"name\"));\n+        return true;\n+    }\n+\n+    /**\n+     * Set the secondary table information back to the owning class mapping.\n+     */\n+    private void endSecondaryTable() {\n+        ClassMapping cm = (ClassMapping) currentElement();\n+        ClassMappingInfo info = cm.getMappingInfo();\n+        info.setSecondaryTableJoinColumns(_secondaryTable, _joinCols);\n+        clearSecondaryTableInfo();\n+    }\n+\n+    /**\n+     * Clear cached secondary table info.\n+     */\n+    private void clearSecondaryTableInfo() {\n+        _joinCols = null;\n+        _secondaryTable = null;\n+    }\n+\n+    /**\n+     * Parse table-generator.\n+     */\n+    private boolean startTableGenerator(Attributes attrs) {\n+        String name = attrs.getValue(\"name\");\n+        Log log = getLog();\n+        if (log.isInfoEnabled())\n+            log.info(_loc.get(\"parse-gen\", name));\n+        if (getRepository().getCachedSequenceMetaData(name) != null\n+            && log.isWarnEnabled())\n+            log.warn(_loc.get(\"override-gen\", name));\n+\n+        SequenceMapping seq = (SequenceMapping) getRepository().\n+            addSequenceMetaData(name);\n+        seq.setSequencePlugin(SequenceMapping.IMPL_VALUE_TABLE);\n+        seq.setTable(toTableName(attrs.getValue(\"schema\"),\n+            attrs.getValue(\"table\")));\n+        seq.setPrimaryKeyColumn(attrs.getValue(\"pk-column-name\"));\n+        seq.setSequenceColumn(attrs.getValue(\"value-column-name\"));\n+        seq.setPrimaryKeyValue(attrs.getValue(\"pk-column-value\"));\n+        String val = attrs.getValue(\"initial-value\");\n+        if (val != null)\n+            seq.setInitialValue(Integer.parseInt(val));\n+        val = attrs.getValue(\"allocation-size\");\n+        if (val != null)\n+            seq.setAllocate(Integer.parseInt(val));\n+\n+        Object cur = currentElement();\n+        Object scope = (cur instanceof ClassMetaData)\n+            ? ((ClassMetaData) cur).getDescribedType() : null;\n+        seq.setSource(getSourceFile(), scope, seq.SRC_XML);\n+        return true;\n+    }\n+\n+    /**\n+     * Parse inheritance.\n+     */\n+    private boolean startInheritance(Attributes attrs) {\n+        String val = attrs.getValue(\"strategy\");\n+        if (val == null)\n+            return true;\n+\n+        ClassMapping cm = (ClassMapping) currentElement();\n+        ClassMappingInfo info = cm.getMappingInfo();\n+        switch (Enum.valueOf(InheritanceType.class, val)) {\n+            case SINGLE_TABLE:\n+                info.setHierarchyStrategy(FlatClassStrategy.ALIAS);\n+                break;\n+            case JOINED:\n+                info.setHierarchyStrategy(VerticalClassStrategy.ALIAS);\n+                break;\n+            case TABLE_PER_CLASS:\n+                info.setHierarchyStrategy(FullClassStrategy.ALIAS);\n+                break;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Parse discriminator-value.\n+     */\n+    private void endDiscriminatorValue() {\n+        String val = currentText();\n+        if (StringUtils.isEmpty(val))\n+            return;\n+\n+        ClassMapping cm = (ClassMapping) currentElement();\n+        cm.getDiscriminator().getMappingInfo().setValue(val);\n+    }\n+\n+    /**\n+     * Parse temporal.\n+     */\n+    private void endTemporal() {\n+        String temp = currentText();\n+        if (!StringUtils.isEmpty(temp))\n+            _temporal = Enum.valueOf(TemporalType.class, temp);\n+    }\n+\n+    /**\n+     * Parse enumerated.\n+     */\n+    private void endEnumerated() {\n+        String text = currentText();\n+        if (StringUtils.isEmpty(text))\n+            return;\n+        EnumType type = Enum.valueOf(EnumType.class, text);\n+\n+        FieldMapping fm = (FieldMapping) currentElement();\n+        String strat = EnumValueHandler.class.getName() + \"(StoreOrdinal=\"\n+            + String.valueOf(type == EnumType.ORDINAL) + \")\";\n+        fm.getValueInfo().setStrategy(strat);\n+    }\n+\n+    @Override\n+    protected boolean startLob(Attributes attrs)\n+        throws SAXException {\n+        if (super.startLob(attrs)) {\n+            _lob = true;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Extend to clear annotation mapping info.\n+     */\n+    @Override\n+    protected void startFieldMapping(FieldMetaData field, Attributes attrs)\n+        throws SAXException {\n+        super.startFieldMapping(field, attrs);\n+        if (getAnnotationParser() != null) {\n+            FieldMapping fm = (FieldMapping) field;\n+            fm.getMappingInfo().clear();\n+            fm.getValueInfo().clear();\n+            fm.getElementMapping().getValueInfo().clear();\n+            fm.getKeyMapping().getValueInfo().clear();\n+        }\n+    }\n+\n+    /**\n+     * Extend to set the columns.\n+     */\n+    @Override\n+    protected void endFieldMapping(FieldMetaData field)\n+        throws SAXException {\n+        // setup columns with cached lob and temporal info\n+        FieldMapping fm = (FieldMapping) field;\n+        if (_lob || _temporal != null) {\n+            if (_cols == null) {\n+                _cols = new ArrayList<Column>(1);\n+                _cols.add(new Column());\n+            }\n+            for (Column col : _cols) {\n+                if (_lob && (fm.getDeclaredTypeCode() == JavaTypes.STRING\n+                    || fm.getDeclaredType() == char[].class\n+                    || fm.getDeclaredType() == Character[].class)) {\n+                    col.setSize(-1);\n+                    col.setType(Types.CLOB);\n+                } else if (_lob)\n+                    col.setType(Types.BLOB);\n+                else {\n+                    switch (_temporal) {\n+                        case DATE:\n+                            col.setType(Types.DATE);\n+                            break;\n+                        case TIME:\n+                            col.setType(Types.TIME);\n+                            break;\n+                        case TIMESTAMP:\n+                            col.setType(Types.TIMESTAMP);\n+                            break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (_cols != null) {\n+            switch (fm.getDeclaredTypeCode()) {\n+                case JavaTypes.ARRAY:\n+                    if (fm.getDeclaredType() == byte[].class\n+                        || fm.getDeclaredType() == char[].class\n+                        || fm.getDeclaredType() == Character[].class) {\n+                        fm.getValueInfo().setColumns(_cols);\n+                        break;\n+                    }\n+                    // else no break\n+                case JavaTypes.COLLECTION:\n+                case JavaTypes.MAP:\n+                    fm.getElementMapping().getValueInfo().setColumns(_cols);\n+                    break;\n+                default:\n+                    fm.getValueInfo().setColumns(_cols);\n+            }\n+            if (_colTable != null)\n+                fm.getMappingInfo().setTableName(_colTable);\n+            setUnique(fm);\n+        }\n+        clearColumnInfo();\n+    }\n+\n+    /**\n+     * Set unique for field.\n+     */\n+    private void setUnique(FieldMapping fm) {\n+        if (_unique.size() == 2) // i.e. TRUE & FALSE\n+            getLog().warn(_loc.get(\"inconsist-col-attrs\", fm));\n+        else if (_unique.contains(UniqueFlag.TRUE))\n+            fm.getValueInfo().setUnique(new Unique());\n+    }\n+\n+    /**\n+     * Clear field level column information.\n+     */\n+    private void clearColumnInfo() {\n+        _cols = null;\n+        _joinCols = null;\n+        _colTable = null;\n+        _lob = false;\n+        _temporal = null;\n+        _unique.clear();\n+    }\n+\n+    /**\n+     * Parse attribute-override.\n+     */\n+    private boolean startAttributeOverride(Attributes attr) {\n+        _override = attr.getValue(\"name\");\n+        return true;\n+    }\n+\n+    /**\n+     * Set attribute override into proper mapping.\n+     */\n+    private void endAttributeOverride()\n+        throws SAXException {\n+        Object elem = currentElement();\n+        FieldMapping fm;\n+        if (elem instanceof ClassMapping)\n+            fm = getAttributeOverride((ClassMapping) elem);\n+        else\n+            fm = getAttributeOverride((FieldMapping) elem);\n+        if (_cols != null) {\n+            fm.getValueInfo().setColumns(_cols);\n+            if (_colTable != null)\n+                fm.getMappingInfo().setTableName(_colTable);\n+            setUnique(fm);\n+        }\n+        clearColumnInfo();\n+        _override = null;\n+    }\n+\n+    /**\n+     * Return the proper override.\n+     */\n+    private FieldMapping getAttributeOverride(ClassMapping cm) {\n+        FieldMapping sup = (FieldMapping) cm.getDefinedSuperclassField\n+            (_override);\n+        if (sup == null)\n+            sup = (FieldMapping) cm.addDefinedSuperclassField(_override,\n+                Object.class, Object.class);\n+        return sup;\n+    }\n+\n+    /**\n+     * Return the proper override.\n+     */\n+    private FieldMapping getAttributeOverride(FieldMapping fm)\n+        throws SAXException {\n+        ClassMapping embed = fm.getEmbeddedMapping();\n+        if (embed == null)\n+            throw getException(_loc.get(\"not-embedded\", fm));\n+\n+        FieldMapping efm = embed.getFieldMapping(_override);\n+        if (efm == null)\n+            throw getException(_loc.get(\"embed-override-name\",\n+                fm, _override));\n+        return efm;\n+    }\n+\n+    /**\n+     * Parse table.\n+     */\n+    private boolean startTable(Attributes attrs)\n+        throws SAXException {\n+        String table = toTableName(attrs.getValue(\"schema\"),\n+            attrs.getValue(\"name\"));\n+        if (table != null)\n+            ((ClassMapping) currentElement()).getMappingInfo().setTableName\n+                (table);\n+        return true;\n+    }\n+\n+    /**\n+     * Parse join-table.\n+     */\n+    private boolean startJoinTable(Attributes attrs)\n+        throws SAXException {\n+        String table = toTableName(attrs.getValue(\"schema\"),\n+            attrs.getValue(\"name\"));\n+        if (table != null)\n+            ((FieldMapping) currentElement()).getMappingInfo().setTableName\n+                (table);\n+        return true;\n+    }\n+\n+    /**\n+     * Set the join table information back.\n+     */\n+    private void endJoinTable() {\n+        FieldMapping fm = (FieldMapping) currentElement();\n+        if (_joinCols != null)\n+            fm.getMappingInfo().setColumns(_joinCols);\n+        if (_cols != null)\n+            fm.getElementMapping().getValueInfo().setColumns(_cols);\n+        clearColumnInfo();\n+    }\n+\n+    /**\n+     * Parse primary-key-join-column.\n+     */\n+    private boolean startPrimaryKeyJoinColumn(Attributes attrs)\n+        throws SAXException {\n+        Column col = parseColumn(attrs);\n+        col.setFlag(Column.FLAG_PK_JOIN, true);\n+        // pk join columns on fields act as field cols\n+        if (currentElement() instanceof FieldMapping) {\n+            if (_cols == null)\n+                _cols = new ArrayList<Column>(3);\n+            _cols.add(col);\n+        } else if (currentParent() == SECONDARY_TABLE) {\n+            // pk join columns in secondary table acts as join cols\n+            if (_joinCols == null)\n+                _joinCols = new ArrayList<Column>(3);\n+            _joinCols.add(col);\n+        } else {\n+            // must be pk join cols from this class to superclass\n+            if (_supJoinCols == null)\n+                _supJoinCols = new ArrayList<Column>(3);\n+            _supJoinCols.add(col);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Parse join-column.\n+     */\n+    private boolean startJoinColumn(Attributes attrs)\n+        throws SAXException {\n+        // only join cols in a join table join field table to class table;\n+        // others act as data fk cols\n+        if (currentParent() != JOIN_TABLE)\n+            return startColumn(attrs);\n+\n+        if (_joinCols == null)\n+            _joinCols = new ArrayList<Column>(3);\n+        _joinCols.add(parseColumn(attrs));\n+        return true;\n+    }\n+\n+    /**\n+     * Parse column.\n+     */\n+    private boolean startColumn(Attributes attrs)\n+        throws SAXException {\n+        if (_cols == null)\n+            _cols = new ArrayList<Column>(3);\n+        _cols.add(parseColumn(attrs));\n+        return true;\n+    }\n+\n+    /**\n+     * Create a column with the given attributes.\n+     */\n+    private Column parseColumn(Attributes attrs)\n+        throws SAXException {\n+        Column col = new Column();\n+        String val = attrs.getValue(\"name\");\n+        if (val != null)\n+            col.setName(val);\n+        val = attrs.getValue(\"referenced-column-name\");\n+        if (val != null)\n+            col.setTarget(val);\n+        val = attrs.getValue(\"column-definition\");\n+        if (val != null)\n+            col.setTypeName(val);\n+        val = attrs.getValue(\"precision\");\n+        if (val != null)\n+            col.setSize(Integer.parseInt(val));\n+        val = attrs.getValue(\"length\");\n+        if (val != null)\n+            col.setSize(Integer.parseInt(val));\n+        val = attrs.getValue(\"scale\");\n+        if (val != null)\n+            col.setDecimalDigits(Integer.parseInt(val));\n+        val = attrs.getValue(\"nullable\");\n+        if (val != null)\n+            col.setNotNull(\"false\".equals(val));\n+        val = attrs.getValue(\"insertable\");\n+        if (val != null)\n+            col.setFlag(Column.FLAG_UNINSERTABLE, \"false\".equals(val));\n+        val = attrs.getValue(\"updatable\");\n+        if (val != null)\n+            col.setFlag(Column.FLAG_UNUPDATABLE, \"false\".equals(val));\n+\n+        val = attrs.getValue(\"unique\");\n+        if (val != null)\n+            _unique.add(Enum.valueOf(UniqueFlag.class, val.toUpperCase()));\n+        val = attrs.getValue(\"table\");\n+        if (val != null) {\n+            if (_colTable != null && !_colTable.equals(val))\n+                throw getException(_loc.get(\"second-inconsist\",\n+                    currentElement()));\n+            _colTable = val;\n+        }\n+        return col;\n+    }\n+\n+    /**\n+     * Return a table name for the given attributes.\n+     */\n+    private String toTableName(String schema, String table) {\n+        if (StringUtils.isEmpty(table))\n+            return null;\n+        schema = StringUtils.isEmpty(schema) ? _schema : schema;\n+        if (StringUtils.isEmpty(schema))\n+            return table;\n+        return schema + \".\" + table;\n+    }\n+\n+    /**\n+     * Start processing <code>sql-result-set-mapping</code> node.\n+     * Pushes the {@link QueryResultMapping} onto the stack as current element.\n+     */\n+    private boolean startSQLResultSetMapping(Attributes attrs) {\n+        String name = attrs.getValue(\"name\");\n+        Log log = getLog();\n+        if (log.isInfoEnabled())\n+            log.info(_loc.get(\"parse-sqlrsmapping\", name));\n+\n+        MappingRepository repos = (MappingRepository) getRepository();\n+        QueryResultMapping result = repos.getCachedQueryResultMapping\n+            (null, name);\n+        if (result != null && log.isWarnEnabled())\n+            log.warn(_loc.get(\"override-sqlrsmapping\", name,\n+                currentLocation()));\n+\n+        result = repos.addQueryResultMapping(null, name);\n+        result.setListingIndex(_resultIdx++);\n+        addComments(result);\n+\n+        Object cur = currentElement();\n+        Object scope = (cur instanceof ClassMetaData)\n+            ? ((ClassMetaData) cur).getDescribedType() : null;\n+        result.setSource(getSourceFile(), scope, result.SRC_XML);\n+\n+        pushElement(result);\n+        return true;\n+    }\n+\n+    private void endSQLResultSetMapping()\n+        throws SAXException {\n+        popElement();\n+    }\n+\n+    /**\n+     * Start processing <code>entity-result</code> node.\n+     * Pushes the {@link QueryResultMapping.PCResult}\n+     * onto the stack as current element.\n+     */\n+    private boolean startEntityResult(Attributes attrs)\n+        throws SAXException {\n+        Class entityClass = classForName(attrs.getValue(\"entity-class\"));\n+        String discriminator = attrs.getValue(\"discriminator-column\");\n+\n+        QueryResultMapping parent = (QueryResultMapping) currentElement();\n+        QueryResultMapping.PCResult result = parent.addPCResult(entityClass);\n+        if (!StringUtils.isEmpty(discriminator))\n+            result.addMapping(result.DISCRIMINATOR, discriminator);\n+        pushElement(result);\n+        return true;\n+    }\n+\n+    private void endEntityResult()\n+        throws SAXException {\n+        popElement();\n+    }\n+\n+    /**\n+     * Process a <code>field-result</code> node.\n+     */\n+    private boolean startFieldResult(Attributes attrs)\n+        throws SAXException {\n+        String fieldName = attrs.getValue(\"name\");\n+        String columnName = attrs.getValue(\"column\");\n+\n+        QueryResultMapping.PCResult parent = (QueryResultMapping.PCResult)\n+            currentElement();\n+        parent.addMapping(fieldName, columnName);\n+        return true;\n+    }\n+\n+    /**\n+     * Process a <code>column-result</code> node.\n+     */\n+    private boolean startColumnResult(Attributes attrs)\n+        throws SAXException {\n+        QueryResultMapping parent = (QueryResultMapping) currentElement();\n+        parent.addColumnResult(attrs.getValue(\"name\"));\n+        return true;\n+    }\n+\n+    /**\n+     * Track unique column settings.\n+\t */\n+\tprivate static enum UniqueFlag\n+\t{\n+\t\tTRUE,\n+\t\tFALSE\n+\t}\n+}"},{"sha":"5738ac4c85f986953385304d4af7fee32beb046e","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMLPersistenceMappingSerializer.java","status":"added","additions":682,"deletions":0,"changes":682,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMLPersistenceMappingSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMLPersistenceMappingSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMLPersistenceMappingSerializer.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,682 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.persistence.EnumType;\n+import javax.persistence.TemporalType;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.xml.sax.SAXException;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.ClassMappingInfo;\n+import org.apache.openjpa.jdbc.meta.DiscriminatorMappingInfo;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.MappingInfo;\n+import org.apache.openjpa.jdbc.meta.MappingRepository;\n+import org.apache.openjpa.jdbc.meta.QueryResultMapping;\n+import org.apache.openjpa.jdbc.meta.SequenceMapping;\n+import org.apache.openjpa.jdbc.meta.ValueMappingInfo;\n+import org.apache.openjpa.jdbc.meta.strats.EnumValueHandler;\n+import org.apache.openjpa.jdbc.meta.strats.FlatClassStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.FullClassStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.VerticalClassStrategy;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import static org.apache.openjpa.meta.MetaDataModes.MODE_MAPPING;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.meta.SequenceMetaData;\n+import org.apache.openjpa.persistence.PersistenceStrategy;\n+import org.apache.openjpa.persistence.XMLPersistenceMetaDataSerializer;\n+import serp.util.Strings;\n+\n+/**\n+ * Serializes persistence mapping to XML.\n+ *\n+ * @since 4.0\n+ * @author Steve Kim\n+ * @nojavadoc\n+ */\n+public class XMLPersistenceMappingSerializer\n+    extends XMLPersistenceMetaDataSerializer {\n+\n+    private static final int TYPE_RESULTMAP = TYPE_QUERY + 1;\n+\n+    private static final Map<ColType, String> _names;\n+\n+    static {\n+        _names = new EnumMap<ColType, String>(ColType.class);\n+        _names.put(ColType.COL, \"column\");\n+        _names.put(ColType.JOIN, \"join-column\");\n+        _names.put(ColType.INVERSE, \"inverse-join-column\");\n+        _names.put(ColType.PK_JOIN, \"primary-key-join-column\");\n+        _names.put(ColType.DISC, \"discriminator-column\");\n+    }\n+\n+    private List<QueryResultMapping> _results = null;\n+    private boolean _sync = false;\n+\n+    /**\n+     * Constructor. Supply configuration.\n+     */\n+    public XMLPersistenceMappingSerializer(JDBCConfiguration conf) {\n+        super(conf);\n+    }\n+\n+    /**\n+     * Whether to automatically synchronize mapping info with data available\n+     * from mapped components before serialization. Defaults to false.\n+     */\n+    public boolean getSyncMappingInfo() {\n+        return _sync;\n+    }\n+\n+    /**\n+     * Whether to automatically synchronize mapping info with data available\n+     * from mapped components before serialization. Defaults to false.\n+     */\n+    public void setSyncMappingInfo(boolean sync) {\n+        _sync = sync;\n+    }\n+\n+    /**\n+     * Adds the given result set mapping to local cache.\n+     */\n+    public void addQueryResultMapping(QueryResultMapping meta) {\n+        if (_results == null)\n+            _results = new ArrayList<QueryResultMapping>();\n+        _results.add(meta);\n+    }\n+\n+    /**\n+     * Removes given result set mapping from the local cache.\n+     */\n+    public boolean removeQueryResultMapping(QueryResultMapping meta) {\n+        return _results != null && _results.remove(meta);\n+    }\n+\n+    @Override\n+    public void addAll(MetaDataRepository repos) {\n+        super.addAll(repos);\n+        for (QueryResultMapping res : ((MappingRepository) repos)\n+            .getQueryResultMappings())\n+            addQueryResultMapping(res);\n+    }\n+\n+    @Override\n+    public boolean removeAll(MetaDataRepository repos) {\n+        boolean removed = super.removeAll(repos);\n+        for (QueryResultMapping res : ((MappingRepository) repos)\n+            .getQueryResultMappings())\n+            removed |= removeQueryResultMapping(res);\n+        return removed;\n+    }\n+\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        if (_results != null)\n+            _results.clear();\n+    }\n+\n+    protected void addCommments(Object obj)\n+        throws SAXException {\n+        if (isMappingMode() && !isMetaDataMode()) {\n+            if (obj instanceof ClassMapping)\n+                obj = ((ClassMapping) obj).getMappingInfo();\n+            else if (obj instanceof FieldMapping)\n+                obj = ((FieldMapping) obj).getMappingInfo();\n+        }\n+        super.addComments(obj);\n+    }\n+\n+    @Override\n+    protected void serializeClass(ClassMetaData meta, boolean access)\n+        throws SAXException {\n+        if (_sync && isMappingMode() && meta instanceof ClassMapping) {\n+            // sync if resolved and mapped\n+            ClassMapping cls = (ClassMapping) meta;\n+            if ((cls.getResolve() & MODE_MAPPING) != 0 && cls.isMapped()) {\n+                cls.syncMappingInfo();\n+                cls.getDiscriminator().syncMappingInfo();\n+                cls.getVersion().syncMappingInfo();\n+                FieldMapping[] fields;\n+                if (cls.getEmbeddingMetaData() == null)\n+                    fields = cls.getDefinedFieldMappings();\n+                else\n+                    fields = cls.getFieldMappings();\n+                for (FieldMapping f : fields)\n+                    f.syncMappingInfo();\n+            }\n+        }\n+        super.serializeClass(meta, access);\n+    }\n+\n+    @Override\n+    protected void serializeClassMappingContent(ClassMetaData mapping)\n+        throws SAXException {\n+        ClassMapping cls = (ClassMapping) mapping;\n+        ClassMappingInfo info = cls.getMappingInfo();\n+        serializeTable(info.getTableName(), \"table\", Strings\n+            .getClassName(mapping.getDescribedType()), null);\n+        for (String second : info.getSecondaryTableNames())\n+            serializeTable(second, \"secondary-table\", null, info);\n+        serializeColumns(info, ColType.PK_JOIN, null);\n+    }\n+\n+    @Override\n+    protected void serializeInheritanceContent(ClassMetaData mapping)\n+        throws SAXException {\n+        ClassMapping cls = (ClassMapping) mapping;\n+        ClassMappingInfo info = cls.getMappingInfo();\n+        DiscriminatorMappingInfo dinfo = cls.getDiscriminator()\n+            .getMappingInfo();\n+        String strat = info.getHierarchyStrategy();\n+        if (FlatClassStrategy.ALIAS.equals(strat))\n+            addAttribute(\"strategy\", \"SINGLE_TABLE\");\n+        else if (VerticalClassStrategy.ALIAS.equals(strat))\n+            addAttribute(\"strategy\", \"JOINED\");\n+        else if (FullClassStrategy.ALIAS.equals(strat))\n+            addAttribute(\"strategy\", \"TABLE_PER_CLASS\");\n+        if (strat != null) {\n+            startElement(\"inheritance\");\n+            endElement(\"inheritance\");\n+        }\n+        if (dinfo.getValue() != null) {\n+            startElement(\"discriminator-value\");\n+            addText(dinfo.getValue());\n+            endElement(\"discriminator-value\");\n+        }\n+        serializeColumns(dinfo, ColType.DISC, null);\n+    }\n+\n+    /**\n+     * Serialize table optionally listing primary-key-joins stored\n+     * in the given {@link ClassMappingInfo}.\n+     */\n+    private void serializeTable(String table, String elementName,\n+        String defaultName, ClassMappingInfo secondaryInfo)\n+        throws SAXException {\n+        List<Column> cols = null;\n+        if (secondaryInfo != null)\n+            cols = (List<Column>) secondaryInfo.getSecondaryTableJoinColumns\n+                (table);\n+\n+        boolean print = cols != null && cols.size() > 0;\n+        if (table != null\n+            && (defaultName == null || !defaultName.equals(table))) {\n+            print = true;\n+            int index = table.indexOf('.');\n+            if (index < 0)\n+                addAttribute(\"name\", table);\n+            else {\n+                addAttribute(\"schema\", table.substring(0, index));\n+                addAttribute(\"name\", table.substring(index + 1));\n+            }\n+        }\n+        if (print) {\n+            startElement(elementName);\n+            if (cols != null) {\n+                for (Column col : cols)\n+                    serializeColumn(col, ColType.PK_JOIN, null, false);\n+            }\n+            endElement(elementName);\n+        }\n+    }\n+\n+    @Override\n+    protected boolean serializeAttributeOverride(FieldMetaData fmd,\n+        FieldMetaData orig) {\n+        if (orig == null || fmd == orig)\n+            return false;\n+\n+        FieldMapping field = (FieldMapping) fmd;\n+        FieldMapping field2 = (FieldMapping) orig;\n+        if (field.getMappingInfo().hasSchemaComponents()\n+            || field2.getMappingInfo().hasSchemaComponents())\n+            return true;\n+\n+        ValueMappingInfo info = field.getValueInfo();\n+        List<Column> cols = (List<Column>) info.getColumns();\n+        if (cols == null || cols.size() == 0)\n+            return false;\n+        ValueMappingInfo info2 = field2.getValueInfo();\n+        List<Column> cols2 = (List<Column>) info2.getColumns();\n+        if (cols2 == null || cols2.size() != cols.size())\n+            return true;\n+        if (cols.size() != 1)\n+            return true;\n+\n+        Column col;\n+        Column col2;\n+        for (int i = 0; i < cols.size(); i++) {\n+            col = cols.get(i);\n+            col2 = cols2.get(i);\n+            if (!StringUtils.equals(col.getName(), col2.getName()))\n+                return true;\n+            if (!StringUtils.equals(col.getTypeName(), col2.getTypeName()))\n+                return true;\n+            if (col.getSize() != col2.getSize())\n+                return true;\n+            if (col.getDecimalDigits() != col2.getDecimalDigits())\n+                return true;\n+            if (col.getFlag(Column.FLAG_UNINSERTABLE)\n+                != col2.getFlag(Column.FLAG_UNINSERTABLE))\n+                return true;\n+            if (col.getFlag(Column.FLAG_UNUPDATABLE)\n+                != col2.getFlag(Column.FLAG_UNUPDATABLE))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    protected void serializeAttributeOverrideMappingContent(FieldMetaData fmd,\n+        FieldMetaData orig)\n+        throws SAXException {\n+        FieldMapping fm = (FieldMapping) fmd;\n+        serializeColumns(fm.getValueInfo(), ColType.COL, fm.getMappingInfo()\n+            .getTableName());\n+    }\n+\n+    @Override\n+    protected PersistenceStrategy getStrategy(FieldMetaData fmd) {\n+        PersistenceStrategy strat = super.getStrategy(fmd);\n+        FieldMapping field = (FieldMapping) fmd;\n+        switch (strat) {\n+            case MANY_MANY:\n+                // we can differentiate a one-many by the fact that there is no\n+                // secondary table join, or the fk is unique\n+                if (field.getMappedBy() == null\n+                    && (field.getMappingInfo().getJoinDirection()\n+                    == MappingInfo.JOIN_NONE\n+                    || field.getElementMapping().getValueInfo().getUnique()\n+                    != null))\n+                    return PersistenceStrategy.ONE_MANY;\n+                break;\n+            case MANY_ONE:\n+                // inverse join cols or unique fk?\n+                if (field.getValueInfo().getJoinDirection()\n+                    == MappingInfo.JOIN_INVERSE\n+                    || field.getValueInfo().getUnique() != null)\n+                    return PersistenceStrategy.ONE_ONE;\n+\n+                // scan for primary-key-join-column\n+                List<Column> cols = field.getValueInfo().getColumns();\n+                boolean pkJoin = cols != null && cols.size() > 0;\n+                for (int i = 0; pkJoin && i < cols.size(); i++)\n+                    pkJoin = cols.get(i).getFlag(Column.FLAG_PK_JOIN);\n+                if (pkJoin)\n+                    return PersistenceStrategy.ONE_ONE;\n+                break;\n+        }\n+        return strat;\n+    }\n+\n+    @Override\n+    protected void serializeFieldMappingContent(FieldMetaData fmd,\n+        PersistenceStrategy strategy)\n+        throws SAXException {\n+        if (fmd.getMappedBy() != null)\n+            return;\n+\n+        // while I'd like to do auto detection based on join directions, etc.\n+        // the distinguished column / table / etc names forces our hand\n+        // esp for OpenJPA custom mappings.\n+        FieldMapping field = (FieldMapping) fmd;\n+        switch (strategy) {\n+            case ONE_ONE:\n+            case MANY_ONE:\n+                serializeColumns(field.getValueInfo(), ColType.JOIN,\n+                    field.getMappingInfo().getTableName());\n+                return;\n+            case ONE_MANY:\n+                if (field.getMappingInfo().getJoinDirection() ==\n+                    MappingInfo.JOIN_NONE) {\n+                    serializeColumns(field.getElementMapping().getValueInfo(),\n+                        ColType.JOIN, null);\n+                    return;\n+                }\n+                // else no break\n+            case MANY_MANY:\n+                if (field.getMappingInfo().hasSchemaComponents()\n+                    || field.getElementMapping().getValueInfo()\n+                    .hasSchemaComponents()) {\n+                    String table = field.getMappingInfo().getTableName();\n+                    if (table != null) {\n+                        int index = table.indexOf('.');\n+                        if (index < 0)\n+                            addAttribute(\"name\", table);\n+                        else {\n+                            addAttribute(\"schema\", table.substring(0, index));\n+                            addAttribute(\"name\", table.substring(index + 1));\n+                        }\n+                    }\n+                    startElement(\"join-table\");\n+                    serializeColumns(field.getMappingInfo(), ColType.JOIN,\n+                        null);\n+                    serializeColumns(field.getElementMapping().getValueInfo(),\n+                        ColType.INVERSE, null);\n+                    endElement(\"join-table\");\n+                }\n+                return;\n+        }\n+\n+        serializeColumns(field.getValueInfo(), ColType.COL,\n+            field.getMappingInfo().getTableName());\n+        if (strategy == PersistenceStrategy.BASIC && isLob(field)) {\n+            startElement(\"lob\");\n+            endElement(\"lob\");\n+        }\n+        TemporalType temporal = getTemporal(field);\n+        if (temporal != null) {\n+            startElement(\"temporal\");\n+            addText(temporal.toString());\n+            endElement(\"temporal\");\n+        }\n+\n+        EnumType enumType = getEnumType(field);\n+        if (enumType != null && enumType != EnumType.ORDINAL) {\n+            startElement(\"enumerated\");\n+            addText(enumType.toString());\n+            endElement(\"enumerated\");\n+        }\n+    }\n+\n+    /**\n+     * Determine if the field is a lob.\n+     */\n+    private boolean isLob(FieldMapping field) {\n+        for (Column col : (List<Column>) field.getValueInfo().getColumns())\n+            if (col.getType() == Types.BLOB || col.getType() == Types.CLOB)\n+                return true;\n+        return false;\n+    }\n+\n+    /**\n+     * Return field's temporal type.\n+     */\n+    private TemporalType getTemporal(FieldMapping field) {\n+        if (field.getDeclaredTypeCode() != JavaTypes.DATE\n+            && field.getDeclaredTypeCode() != JavaTypes.CALENDAR)\n+            return null;\n+\n+        DBDictionary dict = ((JDBCConfiguration) getConfiguration())\n+            .getDBDictionaryInstance();\n+        int def = dict.getJDBCType(field.getTypeCode(), false);\n+        for (Column col : (List<Column>) field.getValueInfo().getColumns()) {\n+            if (col.getType() == def)\n+                continue;\n+            switch (col.getType()) {\n+                case Types.DATE:\n+                    return TemporalType.DATE;\n+                case Types.TIME:\n+                    return TemporalType.TIME;\n+                case Types.TIMESTAMP:\n+                    return TemporalType.TIMESTAMP;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return enum type for the field.\n+     */\n+    protected EnumType getEnumType(FieldMapping field) {\n+        if (field.getDeclaredTypeCode() != JavaTypes.OBJECT)\n+            return null;\n+        if (!(field.getHandler() instanceof EnumValueHandler))\n+            return null;\n+        return ((EnumValueHandler) field.getHandler()).getStoreOrdinal()\n+            ? EnumType.ORDINAL : EnumType.STRING;\n+    }\n+\n+    /**\n+     * Serialize the columns in the given mapping info.\n+     */\n+    private void serializeColumns(MappingInfo info, ColType type,\n+        String secondary)\n+        throws SAXException {\n+        List<Column> cols = (List<Column>) info.getColumns();\n+        if (cols == null)\n+            return;\n+        for (Column col : cols)\n+            serializeColumn(col, type, secondary, info.getUnique() != null);\n+    }\n+\n+    /**\n+     * Serialize a single column.\n+     */\n+    private void serializeColumn(Column col, ColType type, String secondary,\n+        boolean unique)\n+        throws SAXException {\n+        if (col.getName() != null)\n+            addAttribute(\"name\", col.getName());\n+        if (col.getTypeName() != null)\n+            addAttribute(\"column-definition\", col.getTypeName());\n+        if (col.getTarget() != null\n+            && (type == ColType.JOIN || type == ColType.INVERSE\n+            || type == ColType.PK_JOIN))\n+            addAttribute(\"referenced-column-name\", col.getTarget());\n+        if (type == ColType.COL || type == ColType.JOIN\n+            || type == ColType.PK_JOIN) {\n+            if (unique)\n+                addAttribute(\"unique\", \"true\");\n+            if (col.isNotNull())\n+                addAttribute(\"nullable\", \"false\");\n+            if (col.getFlag(Column.FLAG_UNINSERTABLE))\n+                addAttribute(\"insertable\", \"false\");\n+            if (col.getFlag(Column.FLAG_UNUPDATABLE))\n+                addAttribute(\"updatable\", \"false\");\n+            if (secondary != null)\n+                addAttribute(\"table\", secondary);\n+\n+            if (type == ColType.COL) {\n+                if (col.getSize() > 0 && col.getSize() != 255)\n+                    addAttribute(\"length\", col.getSize() + \"\");\n+                if (col.getDecimalDigits() != 0)\n+                    addAttribute(\"scale\", col.getDecimalDigits() + \"\");\n+            }\n+        }\n+        if (type != ColType.COL || getAttributes().getLength() > 0) {\n+            String name = col.getFlag(Column.FLAG_PK_JOIN) ? _names\n+                .get(ColType.PK_JOIN) : _names.get(type);\n+            startElement(name);\n+            endElement(name);\n+        }\n+    }\n+\n+    @Override\n+    protected SerializationComparator newSerializationComparator() {\n+        return new MappingSerializationComparator();\n+    }\n+\n+    @Override\n+    protected void addSystemMappingElements(Collection toSerialize) {\n+        if (isQueryMode())\n+            toSerialize.addAll(getQueryResultMappings(null));\n+    }\n+\n+    @Override\n+    protected int type(Object o) {\n+        int type = super.type(o);\n+        if (type == -1 && o instanceof QueryResultMapping)\n+            return TYPE_RESULTMAP;\n+        return type;\n+    }\n+\n+    /**\n+     * Return the result set mappings for the given scope.\n+     */\n+    private List<QueryResultMapping> getQueryResultMappings(ClassMetaData cm) {\n+        if (_results == null || _results.isEmpty())\n+            return (List<QueryResultMapping>) Collections.EMPTY_LIST;\n+\n+        List<QueryResultMapping> result = null;\n+        for (int i = 0; i < _results.size(); i++) {\n+            QueryResultMapping element = _results.get(i);\n+            if ((cm == null && element.getSourceScope() != null) || (cm != null\n+                && element.getSourceScope() != cm.getDescribedType()))\n+                continue;\n+\n+            if (result == null)\n+                result = new ArrayList<QueryResultMapping>(_results.size() - i);\n+            result.add(element);\n+        }\n+        return (result == null)\n+            ? (List<QueryResultMapping>) Collections.EMPTY_LIST : result;\n+    }\n+\n+    @Override\n+    protected void serializeSystemMappingElement(Object obj)\n+        throws SAXException {\n+        if (obj instanceof QueryResultMapping)\n+            serializeQueryResultMapping((QueryResultMapping) obj);\n+    }\n+\n+    @Override\n+    protected void serializeQueryMappings(ClassMetaData meta)\n+        throws SAXException {\n+        for (QueryResultMapping res : getQueryResultMappings(meta))\n+            serializeQueryResultMapping(res);\n+    }\n+\n+    /**\n+     * Serialize given result set mapping.\n+     */\n+    private void serializeQueryResultMapping(QueryResultMapping meta)\n+        throws SAXException {\n+        if (!getSerializeAnnotations()\n+            && meta.getSourceType() == meta.SRC_ANNOTATIONS)\n+            return;\n+\n+        addAttribute(\"name\", meta.getName());\n+        startElement(\"sql-result-set-mapping\");\n+        for (QueryResultMapping.PCResult pc : meta.getPCResults()) {\n+            addAttribute(\"entity-class\", pc.getCandidateType().getName());\n+            Object discrim = pc.getMapping(pc.DISCRIMINATOR);\n+            if (discrim != null)\n+                addAttribute(\"discriminator-column\", discrim.toString());\n+\n+            startElement(\"entity-result\");\n+            for (String path : pc.getMappingPaths()) {\n+                addAttribute(\"name\", path);\n+                addAttribute(\"column\", pc.getMapping(path).toString());\n+                startElement(\"field-result\");\n+                endElement(\"field-result\");\n+            }\n+            endElement(\"entity-result\");\n+        }\n+        for (Object col : meta.getColumnResults()) {\n+            addAttribute(\"name\", col.toString());\n+            startElement(\"column-result\");\n+            endElement(\"column-result\");\n+        }\n+        endElement(\"sql-result-set-mapping\");\n+    }\n+\n+    @Override\n+    protected void serializeSequence(SequenceMetaData meta)\n+        throws SAXException {\n+        if (!getSerializeAnnotations()\n+            && meta.getSourceType() == meta.SRC_ANNOTATIONS)\n+            return;\n+        if (SequenceMapping.IMPL_VALUE_TABLE.equals(meta.getSequencePlugin())) {\n+            super.serializeSequence(meta);\n+            return;\n+        }\n+\n+        SequenceMapping seq = (SequenceMapping) meta;\n+        addAttribute(\"name\", seq.getName());\n+        String table = seq.getTable();\n+        if (table != null) {\n+            int dotIdx = table.indexOf('.');\n+            if (dotIdx == -1)\n+                addAttribute(\"table\", table);\n+            else {\n+                addAttribute(\"table\", table.substring(dotIdx + 1));\n+                addAttribute(\"schema\", table.substring(0, dotIdx));\n+            }\n+        }\n+        if (!StringUtils.isEmpty(seq.getPrimaryKeyColumn()))\n+            addAttribute(\"pk-column-name\", seq.getPrimaryKeyColumn());\n+        if (!StringUtils.isEmpty(seq.getSequenceColumn()))\n+            addAttribute(\"value-column-name\", seq.getSequenceColumn());\n+        if (!StringUtils.isEmpty(seq.getPrimaryKeyValue()))\n+            addAttribute(\"pk-column-value\", seq.getPrimaryKeyValue());\n+        if (seq.getAllocate() != 50 && seq.getAllocate() != -1)\n+            addAttribute(\"allocation-size\", seq.getAllocate() + \"\");\n+        if (seq.getInitialValue() != 0 && seq.getInitialValue() != -1)\n+            addAttribute(\"initial-value\", seq.getInitialValue() + \"\");\n+        startElement(\"table-generator\");\n+        endElement(\"table-generator\");\n+    }\n+\n+    /**\n+     * Column types serialized under different names.\n+     */\n+    private static enum ColType {\n+\n+        COL,\n+        JOIN,\n+        INVERSE,\n+        PK_JOIN,\n+        DISC\n+    }\n+\n+    /**\n+     * Extends {@link SerializationComparator} for store-specific tags such\n+     * as &lt;sql-result-set-mapping&gt;.\n+     *\n+     * @author Pinaki Poddar\n+     */\n+    protected class MappingSerializationComparator\n+        extends SerializationComparator {\n+\n+        protected int compareUnknown(Object o1, Object o2) {\n+            if (!(o1 instanceof QueryResultMapping))\n+                return super.compareUnknown(o1, o2);\n+\n+            QueryResultMapping res1 = (QueryResultMapping) o1;\n+            QueryResultMapping res2 = (QueryResultMapping) o2;\n+\n+            // system scope before class scope\n+            Object scope1 = res1.getSourceScope();\n+            Object scope2 = res2.getSourceScope();\n+            if (scope1 == null && scope2 != null)\n+                return -1;\n+            if (scope1 != null && scope2 == null)\n+                return 1;\n+\n+            // compare on listing index, or if none/same, use name\n+            int listingIndex1 = res1.getListingIndex();\n+            int listingIndex2 = res2.getListingIndex();\n+            if (listingIndex1 != listingIndex2)\n+                return listingIndex1 - listingIndex2;\n+            return res1.getName ().compareTo (res2.getName ());\n+\t\t}\n+\t}\n+}"},{"sha":"1391645c0fb43e55c9647272a1b7c100c30a21ef","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XSecondaryTable.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XSecondaryTable.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XSecondaryTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XSecondaryTable.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.TYPE;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+import javax.persistence.PrimaryKeyJoinColumn;\n+\n+/**\n+ * Extended secondary table.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ TYPE })\n+@Retention(RUNTIME)\n+public @interface XSecondaryTable {\n+\n+    String name();\n+\n+    String catalog() default \"\";\n+\n+    String schema() default \"\";\n+\n+    PrimaryKeyJoinColumn[] pkJoinColumns() default {};\n+\n+    Index[] indexes() default {};\n+\n+    ForeignKey[] foreignKeys() default {};\n+\n+    Unique[] uniqueConstraints() default {};\n+}"},{"sha":"faa7aec9a44722bcf06d0f47b84b56cb8c930ec9","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XSecondaryTables.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XSecondaryTables.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XSecondaryTables.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XSecondaryTables.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.TYPE;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Allows the specification of multiple secondary tables.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ TYPE })\n+@Retention(RUNTIME)\n+public @interface XSecondaryTables {\n+\n+    XSecondaryTable[] value() default {};\n+}"},{"sha":"3962d4765c8c4f49bb2bb80c2533f7eae2b2d0bd","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XTable.java","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XTable.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XTable.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import static java.lang.annotation.ElementType.TYPE;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Extended table.\n+ *\n+ * @author Abe White\n+ * @since 4.0\n+ */\n+@Target({ TYPE })\n+@Retention(RUNTIME)\n+public @interface XTable {\n+\n+    String name();\n+\n+    String catalog() default \"\";\n+\n+    String schema() default \"\";\n+\n+    Index[] indexes() default {};\n+\n+    ForeignKey[] foreignKeys() default {};\n+\n+    Unique[] uniqueConstraints() default {};\n+}"},{"sha":"6f452825888cd41134b5f09e6bd7586a281dcfac","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/package.html","status":"added","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/package.html","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/package.html?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,9 @@\n+<html>\n+<body>\n+<p><strong>OpenJPA JPA-JDBC</strong></p>\n+\n+<p>\n+    JDBC-specific extensions to OpenJPA JPA runtime.\n+</p>\n+</body>\n+</html>"},{"sha":"ec17ff434b661419ee550c62773d51fe5b15f0ff","filename":"openjpa-persistence-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.conf.ProductDerivation","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.conf.ProductDerivation","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.conf.ProductDerivation","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.conf.ProductDerivation?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1 @@\n+org.apache.openjpa.persistence.jdbc.JDBCPersistenceProductDerivation"},{"sha":"406215fbf101d218ad4b656220ace15000a826c9","filename":"openjpa-persistence-jdbc/src/main/resources/org/apache/openjpa/persistence/jdbc/localizer.properties","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/resources/org/apache/openjpa/persistence/jdbc/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/main/resources/org/apache/openjpa/persistence/jdbc/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/resources/org/apache/openjpa/persistence/jdbc/localizer.properties?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,31 @@\n+parse-gen: Parsing table generator \"{0}\".\n+dup-gen: Found duplicate generator \"{0}\" in \"{1}\".  Ignoring.\n+override-gen: Found duplicate generator \"{0}\" in \"{1}\".  Overriding previous \\\n+\tdefinition.\n+no-gen-name: The table generator in \"{0}\" must declare a name.\n+parse-sqlrsmapping: Parsing result set mapping \"{0}\".\n+dup-sqlrsmapping: Found duplicate result set mapping \"{0}\" in \"{1}\".  Ignoring.\n+override-sqlrsmapping: Found duplicate result set mapping \"{0}\" in \"{1}\". \\\n+\tOverriding previous definition.\n+unsupported: OpenJPA does not yet support \"{1}\" as used in \"{0}\".\n+second-name: Type \"{0}\" declares an unnamed @SecondaryTable.\n+second-inconsist: \"{0}\" declares inconsistent secondary tables on its join \\\n+\tcolumns.\n+bad-second: \"{0}\" declares a secondary table on columns that do not support \\\n+\tthis attribute.\n+unique-constraints: Detected declared unique constraints on \"{0}\".  OpenJPA \\\n+\tdoes not yet support the @UniqueConstraint annotation.\n+inconsist-col-attrs: Detected inconsistent values of \"unique\" on different \\\n+\tcolumns of \"{0}\".  OpenJPA does not yet support different per-column unique \\\n+\tvalues.  All columns for this mapping must use the same values.\n+pk-as-fk: The \"usePKasFK\" attribute is not yet supported.  Mapping your \\\n+\tOneToOne using JoinColumns that match your id property columns will work.\n+no-override-name: Missing \"name\" property on mapping override for \"{0}\".\n+embed-override-name: Embedded property \"{0}\" declares a mapping override for \\\n+\t\"{1}\", but that is not a persistent property in the embedded type.\n+num-cols-mismatch: Expected \"{0}\" to have \"{1}\" column(s), but you specified \\\n+\t\"{2}\" column(s).\n+second-version: Version property \"{0}\" cannot map to a secondary table column. \\\n+\tVersion columns must always be in the primary table of the class.\n+not-embedded: Attempt to declare mapping overrides on non-embedded field \"{0}\".\n+no-gen-table: No generated table found at \"{0}\"."},{"sha":"2e7f14218b913bbbd1bd8108d1705e78a4d94cb6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/AllFieldTypes.java","status":"added","additions":135,"deletions":0,"changes":135,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/AllFieldTypes.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/AllFieldTypes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/AllFieldTypes.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.simple;\n+\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.persistence.Entity;\n+\n+@Entity\n+public class AllFieldTypes {\n+\n+    private short shortField;\n+    private int intField;\n+    private boolean booleanField;\n+    private long longField;\n+    private float floatField;\n+    private char charField;\n+    private double doubleField;\n+    private byte byteField;\n+    private String stringField;\n+    private Date dateField;\n+    private Set<String> setOfStrings = new HashSet<String>();\n+    private String[] arrayOfStrings;\n+\n+    public void setShortField(short shortField) {\n+        this.shortField = shortField;\n+    }\n+\n+    public short getShortField() {\n+        return this.shortField;\n+    }\n+\n+    public void setIntField(int intField) {\n+        this.intField = intField;\n+    }\n+\n+    public int getIntField() {\n+        return this.intField;\n+    }\n+\n+    public void setBooleanField(boolean booleanField) {\n+        this.booleanField = booleanField;\n+    }\n+\n+    public boolean getBooleanField() {\n+        return this.booleanField;\n+    }\n+\n+    public void setLongField(long longField) {\n+        this.longField = longField;\n+    }\n+\n+    public long getLongField() {\n+        return this.longField;\n+    }\n+\n+    public void setFloatField(float floatField) {\n+        this.floatField = floatField;\n+    }\n+\n+    public float getFloatField() {\n+        return this.floatField;\n+    }\n+\n+    public void setCharField(char charField) {\n+        this.charField = charField;\n+    }\n+\n+    public char getCharField() {\n+        return this.charField;\n+    }\n+\n+    public void setDoubleField(double doubleField) {\n+        this.doubleField = doubleField;\n+    }\n+\n+    public double getDoubleField() {\n+        return this.doubleField;\n+    }\n+\n+    public void setByteField(byte byteField) {\n+        this.byteField = byteField;\n+    }\n+\n+    public byte getByteField() {\n+        return this.byteField;\n+    }\n+\n+    public void setStringField(String stringField) {\n+        this.stringField = stringField;\n+    }\n+\n+    public String getStringField() {\n+        return this.stringField;\n+    }\n+\n+    public void setDateField(Date dateField) {\n+        this.dateField = dateField;\n+    }\n+\n+    public Date getDateField() {\n+        return this.dateField;\n+    }\n+\n+    public void setSetOfStrings(Set<String> setOfStrings) {\n+        this.setOfStrings = setOfStrings;\n+    }\n+\n+    public Set<String> getSetOfStrings() {\n+        return this.setOfStrings;\n+    }\n+\n+    public void setArrayOfStrings(String[] arrayOfStrings) {\n+        this.arrayOfStrings = arrayOfStrings;\n+    }\n+\n+    public String[] getArrayOfStrings() {\n+        return this.arrayOfStrings;\n+    }\n+}\n+"},{"sha":"cd6153ca4e38d8bcfa76db4c482a2271352a2f3f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestPersistence.java","status":"added","additions":116,"deletions":0,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestPersistence.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestPersistence.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestPersistence.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.persistence.simple;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.EntityTransaction;\n+import javax.persistence.Persistence;\n+\n+import junit.framework.TestCase;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Simple test case to get an EntityManager and perform some basic operations.\n+ *\n+ * @author <a href=\"mailto:mprudhom@bea.com\">Marc Prud'hommeaux</a>\n+ */\n+public class TestPersistence\n+    extends TestCase {\n+\n+    private EntityManagerFactory emf;\n+\n+    protected EntityManager getEM() {\n+        if (emf == null)\n+            emf = Persistence.createEntityManagerFactory(\"simple-emf-test\");\n+        assertNotNull(emf);\n+\n+        EntityManager em = emf.createEntityManager();\n+        assertNotNull(em);\n+\n+        return em;\n+    }\n+\n+    public void tearDown()\n+        throws Exception {\n+        super.tearDown();\n+\n+        try {\n+            EntityManager em = getEM();\n+            em.getTransaction().begin();\n+            em.createQuery(\"delete from AllFieldTypes\").executeUpdate();\n+            em.getTransaction().commit();\n+            em.close();\n+            emf.close();\n+        } catch (Exception e) {\n+        }\n+    }\n+\n+    public void testCreateEntityManager() {\n+        EntityManager em = getEM();\n+\n+        EntityTransaction t = em.getTransaction();\n+        assertNotNull(t);\n+\n+        t.begin();\n+        t.setRollbackOnly();\n+        t.rollback();\n+\n+        em.close();\n+    }\n+\n+    public void testPersist() {\n+        EntityManager em;\n+\n+        em = getEM();\n+        em.getTransaction().begin();\n+        em.persist(new AllFieldTypes());\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testQuery() {\n+        EntityManager em;\n+\n+        em = getEM();\n+        em.getTransaction().begin();\n+        AllFieldTypes aft = new AllFieldTypes();\n+        aft.setStringField(\"foo\");\n+        aft.setIntField(10);\n+        em.persist(aft);\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        em = getEM();\n+        em.getTransaction().begin();\n+        assertEquals(1, em.createQuery\n+            (\"select x from AllFieldTypes x where x.stringField = 'foo'\").\n+            getResultList().size());\n+        assertEquals(0, em.createQuery\n+            (\"select x from AllFieldTypes x where x.stringField = 'bar'\").\n+            getResultList().size());\n+        assertEquals(1, em.createQuery\n+            (\"select x from AllFieldTypes x where x.intField >= 10\").\n+            getResultList().size());\n+        em.getTransaction().rollback();\n+        em.close();\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(TestPersistence.class);\n+    }\n+}\n+"},{"sha":"c8a37ca63b69aa25d8d72617bc39e13b71dcdc72","filename":"openjpa-persistence-jdbc/src/test/resources/META-INF/persistence.xml","status":"added","additions":24,"deletions":0,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/test/resources/META-INF/persistence.xml","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence-jdbc/src/test/resources/META-INF/persistence.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/resources/META-INF/persistence.xml?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -0,0 +1,24 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<persistence xmlns=\"http://java.sun.com/xml/ns/persistence\"\n+             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+             version=\"1.0\">\n+\n+    <persistence-unit name=\"simple-emf-test\" transaction-type=\"RESOURCE_LOCAL\">\n+\n+        <!--\n+          <provider>kodo.persistence.PersistenceProviderImpl</provider>\n+          <provider>org.apache.openjpa.persistence.PersistenceProviderImpl</provider>\n+          -->\n+\n+        <class>org.apache.openjpa.persistence.simple.AllFieldTypes</class>\n+\n+        <properties>\n+            <property name=\"openjpa.ConnectionDriverName\"\n+                      value=\"org.apache.commons.dbcp.BasicDataSource\"/>\n+            <property name=\"openjpa.ConnectionProperties\"\n+                      value=\"DriverClassName=org.apache.derby.jdbc.EmbeddedDriver,Url=jdbc:derby:tmp/openjpa-test-database;create=true,MaxActive=100,MaxWait=10000,TestOnBorrow=true\"/>\n+            <property name=\"openjpa.jdbc.SynchronizeMappings\"\n+                      value=\"buildSchema(ForeignKeys=true)\"/>\n+        </properties>\n+    </persistence-unit>\n+</persistence>"},{"sha":"1a0ee1e6f3b339227aec69dd6521b694c0a0559f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","status":"modified","additions":3,"deletions":6,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -349,8 +349,7 @@ public void parse(Class cls) {\n             parsePackageAnnotations();\n             ClassMetaData meta = parseClassAnnotations();\n             updateSourceMode(meta);\n-        }\n-        finally {\n+        } finally {\n             _cls = null;\n             _file = null;\n         }\n@@ -673,10 +672,8 @@ protected File getSourceFile() {\n         }\n         try {\n             _file = new File(url.toURI());\n-        }\n-        catch (URISyntaxException e) {\n-        }\n-        catch (IllegalArgumentException iae) {\n+        } catch (URISyntaxException e) {\n+        } catch (IllegalArgumentException iae) {\n             // this is thrown when the URI is non-hierarchical (aka JBoss)\n         }\n         return _file;"},{"sha":"e60d5ac8eb329182c5613bc5f321195ce6e7d54f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ConfigurationProviderImpl.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ConfigurationProviderImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ConfigurationProviderImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ConfigurationProviderImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -233,8 +233,7 @@ public boolean load(File file) {\n                 if (load(pinfo))\n                     return true;\n             return false;\n-        }\n-        catch (IOException ioe) {\n+        } catch (IOException ioe) {\n             throw new GeneralException(ioe);\n         }\n     }\n@@ -329,8 +328,7 @@ protected void endElement(String name)\n                     {\n                         try {\n                             _info.addJarFileName(currentText());\n-                        }\n-                        catch (IllegalArgumentException iae) {\n+                        } catch (IllegalArgumentException iae) {\n                             throw getException(iae.getMessage());\n                         }\n                     }"},{"sha":"991256d21540b6b31a8c014a6a24a0a7dd78bb0d","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java","status":"modified","additions":8,"deletions":16,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -98,8 +98,7 @@ public StoreCache getStoreCache() {\n                     conf.getDataCacheManagerInstance().getSystemDataCache());\n             }\n             return _cache;\n-        }\n-        finally {\n+        } finally {\n             _factory.unlock();\n         }\n     }\n@@ -116,8 +115,7 @@ public QueryResultCache getQueryResultCache() {\n                 _queryCache = new QueryResultCache(_factory.getConfiguration().\n                     getDataCacheManagerInstance().getSystemQueryCache());\n             return _queryCache;\n-        }\n-        finally {\n+        } finally {\n             _factory.unlock();\n         }\n     }\n@@ -161,8 +159,7 @@ else if (obj != null) {\n                 conf.getValue(\"openjpa.ConnectionRetainMode\");\n             try {\n                 retainMode = Integer.parseInt(val.unalias((String) obj));\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 throw new ArgumentException(_loc.get(\"bad-em-prop\",\n                     \"openjpa.ConnectionRetainMode\", obj),\n                     new Throwable[]{ e },\n@@ -191,8 +188,7 @@ else if (obj != null) {\n             prop = prop.substring(5);\n             try {\n                 setter = ImplHelper.getSetter(em.getClass(), prop);\n-            }\n-            catch (OpenJPAException ke) {\n+            } catch (OpenJPAException ke) {\n                 if (errs == null)\n                     errs = new LinkedList<RuntimeException>();\n                 errs.add(PersistenceExceptions.toPersistenceException(ke));\n@@ -209,8 +205,7 @@ else if (obj != null) {\n                             setter.getParameterTypes()[0]);\n                 }\n                 setter.invoke(em, new Object[]{ val });\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 ArgumentException err = new ArgumentException(_loc.get\n                     (\"bad-em-prop\", prop, entry.getValue()),\n                     new Throwable[]{ e }, null, true);\n@@ -284,15 +279,12 @@ FetchPlan toFetchPlan(FetchConfiguration fetch) {\n                 _plan = cls.getConstructor(FetchPlan.class);\n             }\n             return _plan.newInstance(fetch);\n-        }\n-        catch (InvocationTargetException ite) {\n+        } catch (InvocationTargetException ite) {\n             throw PersistenceExceptions.toPersistenceException\n                 (ite.getTargetException());\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw PersistenceExceptions.toPersistenceException(e);\n-        }\n-        finally {\n+        } finally {\n             _factory.unlock();\n         }\n \t}"},{"sha":"6c3c2507dc27f7b605c40d4d0f7400f232e44d73","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","status":"modified","additions":9,"deletions":18,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -121,8 +121,7 @@ public FetchPlan getFetchPlan() {\n             if (_fetch == null)\n                 _fetch = _emf.toFetchPlan(_broker.getFetchConfiguration());\n             return _fetch;\n-        }\n-        finally {\n+        } finally {\n             _broker.unlock();\n         }\n     }\n@@ -358,14 +357,11 @@ public void begin() {\n     public void commit() {\n         try {\n             _broker.commit();\n-        }\n-        catch (RollbackException e) {\n+        } catch (RollbackException e) {\n             throw e;\n-        }\n-        catch (IllegalStateException e) {\n+        } catch (IllegalStateException e) {\n             throw e;\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             // RollbackExceptions are special and aren't handled by the\n             // normal exception translator, since the spec says they\n             // should be thrown whenever the commit fails for any reason at\n@@ -617,8 +613,7 @@ public Generator getNamedGenerator(String name) {\n                 _broker.getClassLoader(), true);\n             Seq seq = meta.getInstance(_broker.getClassLoader());\n             return new Generator(seq, name, _broker, null);\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw PersistenceExceptions.toPersistenceException(re);\n         }\n     }\n@@ -631,8 +626,7 @@ public Generator getIdGenerator(Class forClass) {\n             Seq seq = _broker.getIdentitySequence(meta);\n             return (seq == null) ? null : new Generator(seq, null, _broker,\n                 meta);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw PersistenceExceptions.toPersistenceException(e);\n         }\n     }\n@@ -650,8 +644,7 @@ public Generator getFieldGenerator(Class forClass, String fieldName) {\n             Seq seq = _broker.getValueSequence(fmd);\n             return (seq == null) ? null : new Generator(seq, null, _broker,\n                 meta);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw PersistenceExceptions.toPersistenceException(e);\n         }\n     }\n@@ -692,8 +685,7 @@ public OpenJPAQuery createNamedQuery(String name) {\n             for (int i = 0; i < hints.length; i++)\n                 q.setHint(hints[i], values[i]);\n             return q;\n-        }\n-        catch (RuntimeException re) {\n+        } catch (RuntimeException re) {\n             throw PersistenceExceptions.toPersistenceException(re);\n         }\n     }\n@@ -893,8 +885,7 @@ public void dirty(Object o, String field) {\n         try {\n             if (sm != null)\n                 sm.dirty(field);\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             throw PersistenceExceptions.toPersistenceException(e);\n         }\n     }"},{"sha":"18b83d0a6418abf36a1bcd905d717dbf3efcfebb","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5","patch":"@@ -82,8 +82,7 @@ public FetchPlan getFetchPlan() {\n                     getEntityManagerFactory()).toFetchPlan(_extent.\n                     getFetchConfiguration());\n             return _fetch;\n-        }\n-        finally {\n+        } finally {\n             _extent.unlock();\n         }\n     }"},{"sha":"d7409d7e704b6ccf3164b0191dc2f6421e14b3ce","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"beacdb07665caa2be5a7a7fb90d09464732b44a8","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"0605891862d0c5e495b952efc47279c48d839611","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceListenerAdapter.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceListenerAdapter.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceListenerAdapter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceListenerAdapter.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"edaa6355e52005114060acce42d9dfb59c28cc53","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"37973db61fb8f2ef92866efca4666c8837649023","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"1e4103ff9f2ede3e981208943b1f7b9bb508d486","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceUnitInfoImpl.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceUnitInfoImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceUnitInfoImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceUnitInfoImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"c16338f91c0d62e07cbae8cdb9d20073c47a8d93","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","status":"modified","additions":9,"deletions":18,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"5dc5b24ad0dd253f977726343491f6b79d5d7ffb","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"d75340f117a83812ca50bfcabbc22ca4d02afe24","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","status":"modified","additions":3,"deletions":6,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"70bc41bb6e241401186cd09caab3a7ae8406e47c","filename":"openjpa-persistence/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ConfigurationProvider","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ConfigurationProvider","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-persistence/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ConfigurationProvider","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ConfigurationProvider?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"4f63c43c15227ed2c5e477bcd433a50dd0321bcb","filename":"openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLFileHandler.java","status":"modified","additions":11,"deletions":22,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLFileHandler.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLFileHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLFileHandler.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"a8ec58f1e4fabe265ebd2c42aa7fd95392f3bb46","filename":"openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStoreManager.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStoreManager.java?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"},{"sha":"efc9dc407b5085822da166ee9078eb352a771dcb","filename":"pom.xml","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/7d1c8fccafcd31919a79edf46969c5662e2704b5/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/7d1c8fccafcd31919a79edf46969c5662e2704b5/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/pom.xml?ref=7d1c8fccafcd31919a79edf46969c5662e2704b5"}]}

