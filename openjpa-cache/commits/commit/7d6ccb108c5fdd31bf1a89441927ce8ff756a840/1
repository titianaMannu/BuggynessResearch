{"sha":"7d6ccb108c5fdd31bf1a89441927ce8ff756a840","node_id":"MDY6Q29tbWl0MjA2MzY0OjdkNmNjYjEwOGM1ZmRkMzFiZjFhODk0NDE5MjdjZThmZjc1NmE4NDA=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-09-29T02:43:39Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-09-29T02:43:39Z"},"message":"OPENJPA-1050: Use generics for Filters\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@819801 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"66675dae2ed02779280626be5592d160fcf92349","url":"https://api.github.com/repos/apache/openjpa/git/trees/66675dae2ed02779280626be5592d160fcf92349"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/7d6ccb108c5fdd31bf1a89441927ce8ff756a840","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/7d6ccb108c5fdd31bf1a89441927ce8ff756a840","html_url":"https://github.com/apache/openjpa/commit/7d6ccb108c5fdd31bf1a89441927ce8ff756a840","comments_url":"https://api.github.com/repos/apache/openjpa/commits/7d6ccb108c5fdd31bf1a89441927ce8ff756a840/comments","author":null,"committer":null,"parents":[{"sha":"baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","url":"https://api.github.com/repos/apache/openjpa/commits/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","html_url":"https://github.com/apache/openjpa/commit/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1"}],"stats":{"total":87,"additions":38,"deletions":49},"files":[{"sha":"502a2c28c21e7f24f960f550495fca322e58eeed","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","status":"modified","additions":38,"deletions":49,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/7d6ccb108c5fdd31bf1a89441927ce8ff756a840/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","raw_url":"https://github.com/apache/openjpa/raw/7d6ccb108c5fdd31bf1a89441927ce8ff756a840/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java?ref=7d6ccb108c5fdd31bf1a89441927ce8ff756a840","patch":"@@ -28,6 +28,7 @@\n import java.util.ArrayList;\n import java.util.Calendar;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.Date;\n import java.util.List;\n \n@@ -65,7 +66,7 @@\n     /**\n      * Return the correct wrapper type for the given class.\n      */\n-    public static Class wrap(Class c) {\n+    public static Class<?> wrap(Class<?> c) {\n         if (!c.isPrimitive())\n             return c;\n         if (c == int.class)\n@@ -91,7 +92,7 @@ public static Class wrap(Class c) {\n      * Return the correct primitive type for the given class, if it is a\n      * wrapper.\n      */\n-    public static Class unwrap(Class c) {\n+    public static Class<?> unwrap(Class<?> c) {\n         if (c.isPrimitive() || c == String.class)\n             return c;\n         if (c == Integer.class)\n@@ -117,11 +118,11 @@ public static Class unwrap(Class c) {\n      * Given two types, return type they should both be converted\n      * to before performing any operations between them.\n      */\n-    public static Class promote(Class c1, Class c2) {\n+    public static Class<?> promote(Class<?> c1, Class<?> c2) {\n         if (c1 == c2)\n             return unwrap(c1);\n-        Class w1 = wrap(c1);\n-        Class w2 = wrap(c2);\n+        Class<?> w1 = wrap(c1);\n+        Class<?> w2 = wrap(c2);\n         if (w1 == w2)\n             return unwrap(c1);\n \n@@ -194,7 +195,7 @@ public static Class promote(Class c1, Class c2) {\n     /**\n      * Return whether the given type is not a standard persistent type.\n      */\n-    private static boolean isNonstandardType(Class c) {\n+    private static boolean isNonstandardType(Class<?> c) {\n         switch (JavaTypes.getTypeCode(c))\n         {\n         case JavaTypes.ARRAY:\n@@ -214,7 +215,7 @@ private static boolean isNonstandardType(Class c) {\n      * Return whether an instance of the first class can be converted to\n      * an instance of the second.\n      */\n-    public static boolean canConvert(Class c1, Class c2, boolean strict) {\n+    public static boolean canConvert(Class<?> c1, Class<?> c2, boolean strict) {\n         c1 = wrap(c1);\n         c2 = wrap(c2);\n         if (c2.isAssignableFrom(c1))\n@@ -241,7 +242,7 @@ public static boolean canConvert(Class c1, Class c2, boolean strict) {\n     /**\n      * Convert the given value to the given type.\n      */\n-    public static Object convert(Object o, Class type) {\n+    public static Object convert(Object o, Class<?> type) {\n         if (o == null)\n             return null;\n         if (o.getClass() == type)\n@@ -342,43 +343,43 @@ else if (o instanceof String && ((String) o).length() == 1)\n     /**\n      * Add the given values.\n      */\n-    public static Object add(Object o1, Class c1, Object o2, Class c2) {\n+    public static Object add(Object o1, Class<?> c1, Object o2, Class<?> c2) {\n         return op(o1, c1, o2, c2, OP_ADD);\n     }\n \n     /**\n      * Subtract the given values.\n      */\n-    public static Object subtract(Object o1, Class c1, Object o2, Class c2) {\n+    public static Object subtract(Object o1, Class<?> c1, Object o2, Class<?> c2) {\n         return op(o1, c1, o2, c2, OP_SUBTRACT);\n     }\n \n     /**\n      * Multiply the given values.\n      */\n-    public static Object multiply(Object o1, Class c1, Object o2, Class c2) {\n+    public static Object multiply(Object o1, Class<?> c1, Object o2, Class<?> c2) {\n         return op(o1, c1, o2, c2, OP_MULTIPLY);\n     }\n \n     /**\n      * Divide the given values.\n      */\n-    public static Object divide(Object o1, Class c1, Object o2, Class c2) {\n+    public static Object divide(Object o1, Class<?> c1, Object o2, Class<?> c2) {\n         return op(o1, c1, o2, c2, OP_DIVIDE);\n     }\n \n     /**\n      * Mod the given values.\n      */\n-    public static Object mod(Object o1, Class c1, Object o2, Class c2) {\n+    public static Object mod(Object o1, Class<?> c1, Object o2, Class<?> c2) {\n         return op(o1, c1, o2, c2, OP_MOD);\n     }\n \n     /**\n      * Perform the given operation on two numbers.\n      */\n-    private static Object op(Object o1, Class c1, Object o2, Class c2, int op) {\n-        Class promote = promote(c1, c2);\n+    private static Object op(Object o1, Class<?> c1, Object o2, Class<?> c2, int op) {\n+        Class<?> promote = promote(c1, c2);\n         if (promote == int.class) {\n             int n1 = (o1 == null) ? 0 : ((Number) o1).intValue();\n             int n2 = (o2 == null) ? 0 : ((Number) o2).intValue();\n@@ -575,8 +576,7 @@ private static Object op(BigInteger n1, BigInteger n2, int op) {\n      * @param decType the type of declaration being parsed, for use in\n      * error messages\n      */\n-    public static List parseDeclaration(String dec, char split,\n-        String decType) {\n+    public static List<String> parseDeclaration(String dec, char split, String decType) {\n         if (dec == null)\n             return null;\n \n@@ -591,7 +591,7 @@ public static List parseDeclaration(String dec, char split,\n         char cur;\n         int start = 0;\n         boolean skipSpace = false;\n-        List results = new ArrayList(6);\n+        List<String> results = new ArrayList<String>(6);\n         for (int i = 0; i < dec.length(); i++) {\n             cur = dec.charAt(i);\n             if (cur == bad)\n@@ -629,11 +629,11 @@ public static List parseDeclaration(String dec, char split,\n      * (valid assumptions given the checks in our setters and before\n      * this method call).\n      */\n-    public static List splitExpressions(String str, char split, int expected) {\n+    public static List<String> splitExpressions(String str, char split, int expected) {\n         if (str == null)\n             return null;\n \n-        List exps = null;\n+        List<String> exps = null;\n         int parenDepth = 0;\n         int begin = 0, pos = 0;\n         boolean escape = false;\n@@ -678,7 +678,7 @@ else if (!string) {\n                 case '\\r':\n                     if (c == split && !string && parenDepth == 0 && nonspace) {\n                         if (exps == null)\n-                            exps = new ArrayList(expected);\n+                            exps = new ArrayList<String>(expected);\n                         exps.add(str.substring(begin, pos).trim());\n                         begin = pos + 1;\n                         nonspace = false;\n@@ -687,7 +687,7 @@ else if (!string) {\n                 default:\n                     if (c == split && !string && parenDepth == 0) {\n                         if (exps == null)\n-                            exps = new ArrayList(expected);\n+                            exps = new ArrayList<String>(expected);\n                         exps.add(str.substring(begin, pos).trim());\n                         begin = pos + 1;\n                     }\n@@ -697,13 +697,11 @@ else if (!string) {\n         }\n \n         if (exps == null) {\n-            // Collections.singletonList wasn't added until 1.3\n-            exps = new ArrayList(1);\n-            exps.add(str);\n+            exps = Collections.singletonList(str);\n             return exps;\n         }\n \n-        // add last exp and return array\n+        // add last expression and return array\n         String last = str.substring(begin).trim();\n         if (last.length() > 0)\n             exps.add(last);\n@@ -714,14 +712,13 @@ else if (!string) {\n      * Add the given access path metadatas to the full path list, making sure\n      * to maintain only base metadatas in the list. The given list may be null.\n      */\n-    public static List addAccessPathMetaDatas(List metas,\n-        ClassMetaData[] path) {\n+    public static List<ClassMetaData> addAccessPathMetaDatas(List<ClassMetaData> metas, ClassMetaData[] path) {\n         if (path == null || path.length == 0)\n             return metas;\n \n         // create set of base class metadatas in access path\n         if (metas == null)\n-            metas = new ArrayList();\n+            metas = new ArrayList<ClassMetaData>();\n         int last = metas.size();\n \n         // for every element in the path of this executor, compare it\n@@ -733,14 +730,12 @@ public static List addAccessPathMetaDatas(List metas,\n         for (int i = 0; i < path.length; i++) {\n             add = true;\n             for (int j = 0; add && j < last; j++) {\n-                meta = (ClassMetaData) metas.get(j);\n+                meta = metas.get(j);\n \n-                if (meta.getDescribedType().isAssignableFrom\n-                    (path[i].getDescribedType())) {\n+                if (meta.getDescribedType().isAssignableFrom(path[i].getDescribedType())) {\n                     // list already contains base class\n                     add = false;\n-                } else if (path[i].getDescribedType().isAssignableFrom\n-                    (meta.getDescribedType())) {\n+                } else if (path[i].getDescribedType().isAssignableFrom(meta.getDescribedType())) {\n                     // this element replaces its subclass\n                     add = false;\n                     metas.set(j, path[i]);\n@@ -760,8 +755,7 @@ public static List addAccessPathMetaDatas(List metas,\n      * Convert the user-given hint value to an aggregate listener.\n      * The hint can be an aggregate listener instance or class name.\n      */\n-    public static AggregateListener hintToAggregateListener(Object hint,\n-        ClassLoader loader) {\n+    public static AggregateListener hintToAggregateListener(Object hint, ClassLoader loader) {\n         if (hint == null)\n             return null;\n         if (hint instanceof AggregateListener)\n@@ -771,8 +765,7 @@ public static AggregateListener hintToAggregateListener(Object hint,\n         if (hint instanceof String) {\n             try {\n                 return (AggregateListener) AccessController.doPrivileged(\n-                    J2DoPrivHelper.newInstanceAction(\n-                        Class.forName((String) hint, true, loader)));\n+                    J2DoPrivHelper.newInstanceAction(Class.forName((String) hint, true, loader)));\n             } catch (Exception e) {\n                 if (e instanceof PrivilegedActionException)\n                     e = ((PrivilegedActionException) e).getException();\n@@ -788,18 +781,16 @@ public static AggregateListener hintToAggregateListener(Object hint,\n      * The hint can be an aggregate listener, aggregate listener array,\n      * collection, or comma-separated class names.\n      */\n-    public static AggregateListener[] hintToAggregateListeners(Object hint,\n-        ClassLoader loader) {\n+    public static AggregateListener[] hintToAggregateListeners(Object hint, ClassLoader loader) {\n         if (hint == null)\n             return null;\n         if (hint instanceof AggregateListener[])\n             return (AggregateListener[]) hint;\n         if (hint instanceof AggregateListener)\n             return new AggregateListener[]{ (AggregateListener) hint };\n         if (hint instanceof Collection) {\n-            Collection c = (Collection) hint;\n-            return (AggregateListener[]) c.toArray\n-                (new AggregateListener[c.size()]);\n+            Collection<AggregateListener> c = (Collection<AggregateListener>) hint;\n+            return c.toArray(new AggregateListener[c.size()]);\n         }\n \n         Exception cause = null;\n@@ -826,8 +817,7 @@ public static AggregateListener hintToAggregateListener(Object hint,\n      * Convert the user-given hint value to a filter listener.\n      * The hint can be a filter listener instance or class name.\n      */\n-    public static FilterListener hintToFilterListener(Object hint,\n-        ClassLoader loader) {\n+    public static FilterListener hintToFilterListener(Object hint, ClassLoader loader) {\n         if (hint == null)\n             return null;\n         if (hint instanceof FilterListener)\n@@ -854,17 +844,16 @@ public static FilterListener hintToFilterListener(Object hint,\n      * The hint can be a filter listener, filter listener array,\n      * collection, or comma-separated class names.\n      */\n-    public static FilterListener[] hintToFilterListeners(Object hint,\n-        ClassLoader loader) {\n+    public static FilterListener[] hintToFilterListeners(Object hint, ClassLoader loader) {\n         if (hint == null)\n             return null;\n         if (hint instanceof FilterListener[])\n             return (FilterListener[]) hint;\n         if (hint instanceof FilterListener)\n             return new FilterListener[]{ (FilterListener) hint };\n         if (hint instanceof Collection) {\n-            Collection c = (Collection) hint;\n-            return (FilterListener[]) c.toArray(new FilterListener[c.size()]);\n+            Collection<FilterListener> c = (Collection<FilterListener>) hint;\n+            return c.toArray(new FilterListener[c.size()]);\n         }\n \n         Exception cause = null;"}]}

