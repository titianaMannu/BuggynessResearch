{"sha":"7e30623c7b5a30c2a9c9761736d8d493e2a8c968","node_id":"MDY6Q29tbWl0MjA2MzY0OjdlMzA2MjNjN2I1YTMwYzJhOWM5NzYxNzM2ZDhkNDkzZTJhOGM5Njg=","commit":{"author":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-09-07T17:51:05Z"},"committer":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-09-07T17:51:05Z"},"message":"Refactor JDBC query expression tree to allow greater concurrency and to handle\nparameters in result clauses of projections.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@441158 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6abc1094d7f0af5028f508b09295438b70e96b8b","url":"https://api.github.com/repos/apache/openjpa/git/trees/6abc1094d7f0af5028f508b09295438b70e96b8b"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/7e30623c7b5a30c2a9c9761736d8d493e2a8c968","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/7e30623c7b5a30c2a9c9761736d8d493e2a8c968","html_url":"https://github.com/apache/openjpa/commit/7e30623c7b5a30c2a9c9761736d8d493e2a8c968","comments_url":"https://api.github.com/repos/apache/openjpa/commits/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/comments","author":null,"committer":null,"parents":[{"sha":"56d5f6469eeaab2918c170deb779019ef3f841ec","url":"https://api.github.com/repos/apache/openjpa/commits/56d5f6469eeaab2918c170deb779019ef3f841ec","html_url":"https://github.com/apache/openjpa/commit/56d5f6469eeaab2918c170deb779019ef3f841ec"}],"stats":{"total":4565,"additions":2055,"deletions":2510},"files":[{"sha":"be3a2c3bac001750c1ea916d53537946518590c4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","status":"modified","additions":57,"deletions":39,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -27,10 +27,12 @@\n import java.util.Map;\n \n import org.apache.openjpa.event.LifecycleEventManager;\n+import org.apache.openjpa.jdbc.kernel.exps.ExpContext;\n import org.apache.openjpa.jdbc.kernel.exps.GetColumn;\n import org.apache.openjpa.jdbc.kernel.exps.JDBCExpressionFactory;\n import org.apache.openjpa.jdbc.kernel.exps.JDBCStringContains;\n import org.apache.openjpa.jdbc.kernel.exps.JDBCWildcardMatch;\n+import org.apache.openjpa.jdbc.kernel.exps.QueryExpressionsState;\n import org.apache.openjpa.jdbc.kernel.exps.SQLEmbed;\n import org.apache.openjpa.jdbc.kernel.exps.SQLExpression;\n import org.apache.openjpa.jdbc.kernel.exps.SQLValue;\n@@ -150,14 +152,19 @@ protected ResultObjectProvider executeQuery(Executor ex,\n             ? range.start : 0L;\n         long end = (dict.supportsSelectEndIndex) ? range.end : Long.MAX_VALUE;\n \n+        QueryExpressionsState[] states = new QueryExpressionsState[exps.length];\n+        for (int i = 0; i < states.length; i++)\n+            states[i] = new QueryExpressionsState();\n+        ExpContext ctx = new ExpContext(_store, params, fetch);\n+\n         // add selects with populate WHERE conditions to list\n         List sels = new ArrayList(mappings.length);\n         List selMappings = new ArrayList(mappings.length);\n         BitSet subclassBits = new BitSet();\n         BitSet nextBits = new BitSet();\n         boolean unionable = createWhereSelects(sels, mappings, selMappings,\n-            subclasses, subclassBits, nextBits, facts, exps, params,\n-            fetch, subclassMode)\n+            subclasses, subclassBits, nextBits, facts, exps, states, ctx,\n+            subclassMode)\n             && subclassMode == JDBCFetchConfiguration.EAGER_JOIN\n             && start == 0\n             && end == Long.MAX_VALUE;\n@@ -174,9 +181,9 @@ protected ResultObjectProvider executeQuery(Executor ex,\n             Union union = _store.getSQLFactory().newUnion(\n                 (Select[]) sels.toArray(new Select[sels.size()]));\n             BitSet[] paged = populateUnion(union, mappings, subclasses, facts,\n-                exps, params, fetch, lrs, eager, start, end);\n+                exps, states, ctx, lrs, eager, start, end);\n             union.setLRS(lrs);\n-            rop = executeUnion(union, mappings, exps, paged, fetch);\n+            rop = executeUnion(union, mappings, exps, states, ctx, paged);\n         } else {\n             if (sels.size() > 1)\n                 rops = new ResultObjectProvider[sels.size()];\n@@ -187,10 +194,10 @@ protected ResultObjectProvider executeQuery(Executor ex,\n                 sel = (Select) sels.get(i);\n                 paged = populateSelect(sel, (ClassMapping) selMappings.get(i),\n                     subclassBits.get(i), (JDBCExpressionFactory) facts[idx],\n-                    exps[idx], params, fetch, lrs, eager, start, end);\n+                    exps[idx], states[idx], ctx, lrs, eager, start, end);\n \n                 rop = executeSelect(sel, (ClassMapping) selMappings.get(i),\n-                    exps[idx], paged, fetch, start, end);\n+                    exps[idx], states[idx], ctx, paged, start, end);\n                 if (rops != null)\n                     rops[i] = rop;\n \n@@ -220,16 +227,16 @@ protected ResultObjectProvider executeQuery(Executor ex,\n      */\n     private BitSet[] populateUnion(Union union, final ClassMapping[] mappings,\n         final boolean subclasses, final ExpressionFactory[] facts,\n-        final QueryExpressions[] exps, final Object[] params,\n-        final JDBCFetchConfiguration fetch, final boolean lrs, final int eager,\n+        final QueryExpressions[] exps, final QueryExpressionsState[] states,\n+        final ExpContext ctx, final boolean lrs, final int eager,\n         final long start, final long end) {\n         final BitSet[] paged = (exps[0].projections.length > 0) ? null\n             : new BitSet[mappings.length];\n         union.select(new Union.Selector() {\n             public void select(Select sel, int idx) {\n                 BitSet bits = populateSelect(sel, mappings[idx], subclasses,\n-                    (JDBCExpressionFactory) facts[idx], exps[idx], params,\n-                    fetch, lrs, eager, start, end);\n+                    (JDBCExpressionFactory) facts[idx], exps[idx], states[idx],\n+                    ctx,  lrs, eager, start, end);\n                 if (paged != null)\n                     paged[idx] = bits;\n             }\n@@ -242,56 +249,56 @@ public void select(Select sel, int idx) {\n      */\n     private BitSet populateSelect(Select sel, ClassMapping mapping,\n         boolean subclasses, JDBCExpressionFactory fact, QueryExpressions exps,\n-        Object[] params, JDBCFetchConfiguration fetch, boolean lrs, int eager,\n+        QueryExpressionsState state, ExpContext ctx, boolean lrs, int eager,\n         long start, long end) {\n         sel.setLRS(lrs);\n         sel.setRange(start, end);\n \n         BitSet paged = null;\n         if (exps.projections.length == 0) {\n             paged = PagingResultObjectProvider.getPagedFields(sel, mapping,\n-                _store, fetch, eager, end - start);\n+                _store, ctx.fetch, eager, end - start);\n             if (paged != null)\n                 eager = JDBCFetchConfiguration.EAGER_JOIN;\n         }\n \n-        fact.select(this, mapping, subclasses, sel, exps, params, fetch,\n-            eager);\n+        fact.getSelectConstructor().select(sel, ctx, mapping, subclasses, exps,\n+            state, eager);\n         return paged;\n     }\n \n     /**\n      * Execute the given union.\n      */\n     private ResultObjectProvider executeUnion(Union union,\n-        ClassMapping[] mappings, QueryExpressions[] exps, BitSet[] paged,\n-        JDBCFetchConfiguration fetch) {\n+        ClassMapping[] mappings, QueryExpressions[] exps, \n+        QueryExpressionsState[] states, ExpContext ctx, BitSet[] paged) {\n         if (exps[0].projections.length > 0)\n-            return new ProjectionResultObjectProvider(union, _store,\n-                fetch, exps);\n+            return new ProjectionResultObjectProvider(union, exps, states, ctx);\n \n         if (paged != null)\n             for (int i = 0; i < paged.length; i++)\n                 if (paged[i] != null)\n                     return new PagingResultObjectProvider(union, mappings,\n-                        _store, fetch, paged, Long.MAX_VALUE);\n+                        _store, ctx.fetch, paged, Long.MAX_VALUE);\n \n         return new InstanceResultObjectProvider(union, mappings[0], _store,\n-            fetch);\n+            ctx.fetch);\n     }\n \n     /**\n      * Execute the given select.\n      */\n-    private ResultObjectProvider executeSelect(Select sel,\n-        ClassMapping mapping, QueryExpressions exps, BitSet paged,\n-        JDBCFetchConfiguration fetch, long start, long end) {\n+    private ResultObjectProvider executeSelect(Select sel, ClassMapping mapping,\n+        QueryExpressions exps, QueryExpressionsState state, ExpContext ctx, \n+        BitSet paged, long start, long end) {\n         if (exps.projections.length > 0)\n-            return new ProjectionResultObjectProvider(sel, _store, fetch, exps);\n+            return new ProjectionResultObjectProvider(sel, exps, state, ctx);\n         if (paged != null)\n-            return new PagingResultObjectProvider(sel, mapping, _store, fetch, \n-                paged, end - start);\n-        return new InstanceResultObjectProvider(sel, mapping, _store, fetch);\n+            return new PagingResultObjectProvider(sel, mapping, _store, \n+                ctx.fetch, paged, end - start);\n+        return new InstanceResultObjectProvider(sel, mapping, _store, \n+            ctx.fetch);\n     }\n \n     /**\n@@ -301,10 +308,10 @@ private ResultObjectProvider executeSelect(Select sel,\n     private boolean createWhereSelects(List sels, ClassMapping[] mappings,\n         List selMappings, boolean subclasses, BitSet subclassBits,\n         BitSet nextBits, ExpressionFactory[] facts, QueryExpressions[] exps,\n-        Object[] params, JDBCFetchConfiguration fetch, int subclassMode) {\n-        Select sel;\n+        QueryExpressionsState[] states, ExpContext ctx, int subclassMode) {\n         ClassMapping[] verts;\n         boolean unionable = true;\n+        Select sel;\n         for (int i = 0; i < mappings.length; i++) {\n             // determine vertical mappings to select separately\n             verts = getVerticalMappings(mappings[i], subclasses, exps[i],\n@@ -313,8 +320,8 @@ private boolean createWhereSelects(List sels, ClassMapping[] mappings,\n                 subclassBits.set(sels.size());\n \n             // create criteria select and clone for each vert mapping\n-            sel = ((JDBCExpressionFactory) facts[i]).evaluate(this, fetch,\n-                exps[i], params);\n+            sel = ((JDBCExpressionFactory) facts[i]).getSelectConstructor().\n+                evaluate(ctx, null, null, exps[i], states[i]);\n             for (int j = 0; j < verts.length; j++) {\n                 selMappings.add(verts[j]);\n                 if (j == verts.length - 1) {\n@@ -437,16 +444,22 @@ private Number executeBulkOperation(Executor ex, ClassMetaData base,\n \n         JDBCFetchConfiguration fetch = (JDBCFetchConfiguration) \n             ctx.getFetchConfiguration();\n+        ExpContext ctx = new ExpContext(_store, params, fetch);\n         DBDictionary dict = _store.getDBDictionary();\n+        QueryExpressionsState[] state = new QueryExpressionsState[exps.length];\n+        for (int i = 0; i < state.length; i++)\n+            state[i] = new QueryExpressionsState();\n \n         SQLBuffer[] sql = new SQLBuffer[mappings.length];\n         JDBCExpressionFactory jdbcFactory;\n         Select sel;\n         for (int i = 0; i < mappings.length; i++) {\n             jdbcFactory = (JDBCExpressionFactory) facts[i];\n-            sel = jdbcFactory.evaluate(this, fetch, exps[i], params);\n-            jdbcFactory.select(this, mappings[i], subclasses, sel, exps[i],\n-                params, fetch, JDBCFetchConfiguration.EAGER_NONE);\n+            sel = jdbcFactory.getSelectConstructor().evaluate(ctx, null, null,\n+                exps[i], state[i]);\n+            jdbcFactory.getSelectConstructor().select(sel, ctx, mappings[i], \n+                subclasses, exps[i], state[i], \n+                JDBCFetchConfiguration.EAGER_NONE);\n \n             // specification of the \"udpates\" map indicates that this is\n             // an update query; otherwise, this is a delete statement\n@@ -465,7 +478,7 @@ private Number executeBulkOperation(Executor ex, ClassMetaData base,\n         }\n \n         // we need to make sure we have an active store connection\n-        ctx.getStoreContext().beginStore();\n+        _store.getContext().beginStore();\n \n         Connection conn = _store.getConnection();\n         long count = 0;\n@@ -582,22 +595,27 @@ protected Number executeUpdate(ClassMetaData base, ClassMetaData[] metas,\n             ? range.start : 0L;\n         long end = (dict.supportsSelectEndIndex) ? range.end : Long.MAX_VALUE;\n \n+        QueryExpressionsState[] states = new QueryExpressionsState[exps.length];\n+        for (int i = 0; i < states.length; i++)\n+            states[i] = new QueryExpressionsState();\n+        ExpContext ctx = new ExpContext(_store, params, fetch);\n+\n         // add selects with populate WHERE conditions to list\n         List sels = new ArrayList(mappings.length);\n         List selMappings = new ArrayList(mappings.length);\n         BitSet subclassBits = new BitSet();\n         BitSet nextBits = new BitSet();\n         boolean unionable = createWhereSelects(sels, mappings, selMappings,\n-            subclasses, subclassBits, nextBits, facts, exps, params, fetch, \n+            subclasses, subclassBits, nextBits, facts, exps, states, ctx, \n             subclassMode) && subclassMode == JDBCFetchConfiguration.EAGER_JOIN;\n         if (sels.size() > 1)\n             start = 0L;\n \n         if (unionable) {\n             Union union = _store.getSQLFactory().newUnion(\n                 (Select[]) sels.toArray(new Select[sels.size()]));\n-            populateUnion(union, mappings, subclasses, facts, exps, params,\n-                fetch, false, eager, start, end);\n+            populateUnion(union, mappings, subclasses, facts, exps, states, ctx,\n+                false, eager, start, end);\n             if (union.isUnion())\n                 return new String[] {union.toSelect(false, fetch).getSQL(true)};\n             sels = Arrays.asList(union.getSelects());\n@@ -607,7 +625,7 @@ protected Number executeUpdate(ClassMetaData base, ClassMetaData[] metas,\n                 sel = (Select) sels.get(i);\n                 populateSelect(sel, (ClassMapping) selMappings.get(i),\n                     subclassBits.get(i), (JDBCExpressionFactory) facts[idx],\n-                    exps[idx], params, fetch, false, eager, start, end);\n+                    exps[idx], states[idx], ctx, false, eager, start, end);\n                 if (nextBits.get(i))\n                     idx++;\n             }"},{"sha":"6442af7fc4e78197b6f2647db0b834975d3e3d3f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ProjectionResultObjectProvider.java","status":"modified","additions":19,"deletions":12,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ProjectionResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ProjectionResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ProjectionResultObjectProvider.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,6 +15,8 @@\n  */\n package org.apache.openjpa.jdbc.kernel;\n \n+import org.apache.openjpa.jdbc.kernel.exps.ExpContext;\n+import org.apache.openjpa.jdbc.kernel.exps.QueryExpressionsState;\n import org.apache.openjpa.jdbc.kernel.exps.Val;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.SelectExecutor;\n@@ -29,32 +31,37 @@\n     extends SelectResultObjectProvider {\n \n     private final QueryExpressions[] _exps;\n+    private final QueryExpressionsState[] _state;\n+    private final ExpContext _ctx;\n \n     /**\n      * Constructor.\n      *\n      * @param sel the select to execute\n-     * @param store the store manager to delegate loading to\n-     * @param fetch the fetch configuration\n      * @param exps the query expressions\n+     * @param states the query expression states\n+     * @param ctx the query execution context\n      */\n-    public ProjectionResultObjectProvider(SelectExecutor sel, JDBCStore store,\n-        JDBCFetchConfiguration fetch, QueryExpressions exps) {\n-        this(sel, store, fetch, new QueryExpressions[]{ exps });\n+    public ProjectionResultObjectProvider(SelectExecutor sel, \n+        QueryExpressions exps, QueryExpressionsState state, ExpContext ctx) {\n+        this(sel, new QueryExpressions[]{ exps }, \n+            new QueryExpressionsState[]{ state }, ctx);\n     }\n \n     /**\n      * Constructor.\n      *\n      * @param sel the select to execute\n-     * @param store the store manager to delegate loading to\n-     * @param fetch the fetch configuration\n      * @param exps the query expressions\n+     * @param states the query expression states\n+     * @param ctx the query execution context\n      */\n-    public ProjectionResultObjectProvider(SelectExecutor sel, JDBCStore store,\n-        JDBCFetchConfiguration fetch, QueryExpressions[] exps) {\n-        super(sel, store, fetch);\n+    public ProjectionResultObjectProvider(SelectExecutor sel, \n+        QueryExpressions[] exps, QueryExpressionsState[] state, ExpContext ctx){\n+        super(sel, ctx.store, ctx.fetch);\n         _exps = exps;\n+        _state = state;\n+        _ctx = ctx;\n     }\n \n     public Object getResultObject()\n@@ -63,8 +70,8 @@ public Object getResultObject()\n         int idx = res.indexOf();\n         Object[] arr = new Object[_exps[idx].projections.length];\n         for (int i = 0; i < _exps[idx].projections.length; i++)\n-            arr[i] = ((Val) _exps[idx].projections[i]).load(res, getStore(),\n-                getFetchConfiguration());\n+            arr[i] = ((Val) _exps[idx].projections[i]).load(_ctx, \n+                _state[idx].projections[i], res);\n         return arr;\n     }\n }"},{"sha":"2a3bb00579e5bfa323e74902931378705a2f6c84","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java","status":"modified","additions":17,"deletions":14,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,8 +15,6 @@\n  */\n package org.apache.openjpa.jdbc.kernel.exps;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n@@ -40,30 +38,35 @@ public boolean isAggregate() {\n         return false;\n     }\n \n-    public void appendIsEmpty(SQLBuffer sql, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n+    public Object toDataStoreValue(Select sel, ExpContext ctx, ExpState state, \n+        Object val) {\n+        return val;\n+    }\n+\n+    public void appendIsEmpty(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n         sql.append(FALSE);\n     }\n \n-    public void appendIsNotEmpty(SQLBuffer sql, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendIsNotEmpty(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql){\n         sql.append(TRUE);\n     }\n \n-    public void appendIsNull(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        appendTo(sql, 0, sel, store, params, fetch);\n+    public void appendIsNull(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n+        appendTo(sel, ctx, state, sql, 0);\n         sql.append(\" IS \").appendValue(null);\n     }\n \n-    public void appendIsNotNull(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        appendTo(sql, 0, sel, store, params, fetch);\n+    public void appendIsNotNull(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n+        appendTo(sel, ctx, state, sql, 0);\n         sql.append(\" IS NOT \").appendValue(null);\n     }\n \n-    public void appendSize(SQLBuffer sql, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendSize(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n         sql.append(\"1\");\n     }\n "},{"sha":"fae830351f71b03dc807a446ddc973be9d22a6ca","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Aggregate.java","status":"modified","additions":36,"deletions":66,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Aggregate.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Aggregate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Aggregate.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,11 +17,8 @@\n \n import java.sql.SQLException;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n@@ -40,7 +37,6 @@\n     private final JDBCAggregateListener _listener;\n     private final Val _arg;\n     private final ClassMapping _candidate;\n-    private Joins _joins = null;\n     private ClassMetaData _meta = null;\n     private Class _cast = null;\n \n@@ -84,103 +80,77 @@ public void setImplicitType(Class type) {\n         _cast = type;\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        if (_arg == null)\n+            return ExpState.NULL;\n+\n         // note that we tell targets and args to extensions that are sql\n         // paths to go ahead and join to their related object (if any),\n         // because we assume that, unlike most operations, if a relation\n         // field like a 1-1 is given as the target of an extension, then\n         // the extension probably acts on some field or column in the\n         // related object, not the 1-1 field itself\n-        if (_arg != null) {\n-            _arg.initialize(sel, store, false);\n-            if (_arg instanceof PCPath)\n-                ((PCPath) _arg).joinRelation();\n-            _joins = _arg.getJoins();\n-        }\n-    }\n-\n-    public Joins getJoins() {\n-        return _joins;\n-    }\n-\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        return val;\n+        return _arg.initialize(sel, ctx, JOIN_REL);\n     }\n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n-        sel.select(newSQLBuffer(sel, store, params, fetch), this);\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        sel.select(newSQLBuffer(sel, ctx, state), this);\n         sel.setAggregate(true);\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n         if (_arg != null)\n-            _arg.selectColumns(sel, store, params, true, fetch);\n+            _arg.selectColumns(sel, ctx, state, true);\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-        sel.groupBy(newSQLBuffer(sel, store, params, fetch));\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+        sel.groupBy(newSQLBuffer(sel, ctx, state));\n     }\n \n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n-        sel.orderBy(newSQLBuffer(sel, store, params, fetch), asc, false);\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n+        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n     }\n \n-    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        calculateValue(sel, store, params, null, fetch);\n-        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n-        appendTo(buf, 0, sel, store, params, fetch);\n-        clearParameters();\n+    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n+        calculateValue(sel, ctx, state, null, null);\n+        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n+        appendTo(sel, ctx, state, buf, 0);\n         return buf;\n     }\n \n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res)\n         throws SQLException {\n-        return Filters.convert(res.getObject(this,\n-            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n+        return Filters.convert(res.getObject(this, JavaSQLTypes.JDBC_DEFAULT, \n+            null), getType());\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n         if (_arg != null)\n-            _arg.calculateValue(sel, store, params, null, fetch);\n+            _arg.calculateValue(sel, ctx, state, null, null);\n     }\n \n-    public void clearParameters() {\n-        if (_arg != null)\n-            _arg.clearParameters();\n-    }\n-\n-    public int length() {\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n         return 1;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        _listener.appendTo(sql, getArgs(sel, store, params, fetch),\n-            _candidate, store);\n-        sel.append(sql, _joins);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        _listener.appendTo(sql, getArgs(sel, ctx, state), _candidate, \n+            ctx.store);\n+        sel.append(sql, state.joins);\n     }\n \n-    private FilterValue[] getArgs(Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n+    private FilterValue[] getArgs(Select sel, ExpContext ctx, ExpState state) {\n         if (_arg == null)\n             return null;\n-        if (_arg instanceof Args) {\n-            Val[] vals = ((Args) _arg).getVals();\n-            FilterValue[] filts = new FilterValue[vals.length];\n-            for (int i = 0; i < vals.length; i++)\n-                filts[i] = new FilterValueImpl(vals[i], sel, store, params,\n-                    fetch);\n-            return filts;\n-        }\n+        if (_arg instanceof Args)\n+            return ((Args) _arg).newFilterValues(sel, ctx, state);\n         return new FilterValue[]{\n-            new FilterValueImpl(_arg, sel, store, params, fetch)\n+            new FilterValueImpl(sel, ctx, state, _arg)\n         };\n     }\n "},{"sha":"5d2f655382b20f0f46912792b0a958db9e4e5206","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AndExpression.java","status":"modified","additions":21,"deletions":31,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AndExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AndExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AndExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,9 +17,6 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n@@ -34,9 +31,6 @@\n \n     private final Exp _exp1;\n     private final Exp _exp2;\n-    private Joins _joins = null;\n-    private boolean _paren1 = false;\n-    private boolean _paren2 = false;\n \n     /**\n      * Constructor. Supply the expressions to combine.\n@@ -46,40 +40,36 @@ public AndExpression(Exp exp1, Exp exp2) {\n         _exp2 = exp2;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n-        _exp1.initialize(sel, store, params, contains);\n-        _exp2.initialize(sel, store, params, contains);\n-        _joins = sel.and(_exp1.getJoins(), _exp2.getJoins());\n-\n-        _paren1 = _exp1 instanceof OrExpression;\n-        _paren2 = _exp2 instanceof OrExpression;\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n+        ExpState s1 = _exp1.initialize(sel, ctx, contains);\n+        ExpState s2 = _exp2.initialize(sel, ctx, contains);\n+        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        if (_paren1)\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        boolean paren1 = _exp1 instanceof OrExpression;\n+        boolean paren2 = _exp2 instanceof OrExpression;\n+        if (paren1)\n             buf.append(\"(\");\n-        _exp1.appendTo(buf, sel, store, params, fetch);\n-        if (_paren1)\n+        _exp1.appendTo(sel, ctx, bstate.state1, buf);\n+        if (paren1)\n             buf.append(\")\");\n         buf.append(\" AND \");\n-        if (_paren2)\n+        if (paren2)\n             buf.append(\"(\");\n-        _exp2.appendTo(buf, sel, store, params, fetch);\n-        if (_paren2)\n+        _exp2.appendTo(sel, ctx, bstate.state2, buf);\n+        if (paren2)\n             buf.append(\")\");\n-        sel.append(buf, _joins);\n-    }\n-\n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _exp1.selectColumns(sel, store, params, pks, fetch);\n-        _exp2.selectColumns(sel, store, params, pks, fetch);\n+        sel.append(buf, state.joins);\n     }\n \n-    public Joins getJoins() {\n-        return _joins;\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _exp1.selectColumns(sel, ctx, bstate.state1, pks);\n+        _exp2.selectColumns(sel, ctx, bstate.state2, pks);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"8647105533fbb17d43d26906fc4d7ad1b2bc6358","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Args.java","status":"modified","additions":60,"deletions":46,"changes":106,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Args.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Args.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Args.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,8 +15,6 @@\n  */\n package org.apache.openjpa.jdbc.kernel.exps;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n@@ -36,7 +34,6 @@\n     implements Arguments {\n \n     private final Val[] _args;\n-    private Joins _joins = null;\n     private ClassMetaData _meta = null;\n \n     /**\n@@ -57,6 +54,19 @@ public Args(Val val1, Val val2) {\n             _args[len1] = val2;\n     }\n \n+    /**\n+     * Return a filter value for each argument.\n+     */\n+    public FilterValue[] newFilterValues(Select sel, ExpContext ctx, \n+        ExpState state) {\n+        ArgsExpState astate = (ArgsExpState) state; \n+        FilterValue[] filts = new FilterValue[_args.length];\n+        for (int i = 0; i < _args.length; i++)\n+            filts[i] = new FilterValueImpl(sel, ctx, astate.states[i], \n+                _args[i]); \n+        return filts;\n+    }\n+\n     public Value[] getValues() {\n         return _args;\n     }\n@@ -91,84 +101,88 @@ public Class getType() {\n     public void setImplicitType(Class type) {\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        ExpState[] states = new ExpState[_args.length];\n+        Joins joins = null;\n         for (int i = 0; i < _args.length; i++) {\n-            _args[i].initialize(sel, store, nullTest);\n-            if (_joins == null)\n-                _joins = _args[i].getJoins();\n+            states[i] = _args[i].initialize(sel, ctx, flags);\n+            if (joins == null)\n+                joins = states[i].joins;\n             else\n-                _joins = sel.and(_joins, _args[i].getJoins());\n+                joins = sel.and(joins, states[i].joins);\n         }\n+        return new ArgsExpState(joins, states);\n     }\n \n-    public Joins getJoins() {\n-        return _joins;\n-    }\n-\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        return val;\n+    /**\n+     * Expression state.\n+     */\n+    private static class ArgsExpState\n+        extends ExpState {\n+        \n+        public ExpState[] states;\n+\n+        public ArgsExpState(Joins joins, ExpState[] states) {\n+            super(joins);\n+            this.states = states;\n+        }\n     }\n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        ArgsExpState astate = (ArgsExpState) state;\n         for (int i = 0; i < _args.length; i++)\n-            _args[i].selectColumns(sel, store, params, pks, fetch);\n+            _args[i].selectColumns(sel, ctx, astate.states[i], pks);\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n     }\n \n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n     }\n \n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch) {\n+    public Object load(ExpContext ctx, ExpState state, Result res) {\n         return null;\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        for (int i = 0; i < _args.length; i++)\n-            _args[i].calculateValue(sel, store, params, null, fetch);\n-    }\n-\n-    public void clearParameters() {\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        ArgsExpState astate = (ArgsExpState) state;\n         for (int i = 0; i < _args.length; i++)\n-            _args[i].clearParameters();\n+            _args[i].calculateValue(sel, ctx, astate.states[i], null, null);\n     }\n \n-    public int length() {\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n         return 0;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n     }\n \n-    public void appendIsEmpty(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendIsEmpty(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n     }\n \n-    public void appendIsNotEmpty(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendIsNotEmpty(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql){\n     }\n \n-    public void appendSize(SQLBuffer sql, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendSize(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n     }\n \n-    public void appendIsNull(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendIsNull(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n     }\n \n-    public void appendIsNotNull(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendIsNotNull(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"916cf4bf290c7820ea9b008724c423dec3f0a5ed","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableAndExpression.java","status":"modified","additions":10,"deletions":19,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableAndExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableAndExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableAndExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,9 +17,6 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n@@ -34,7 +31,6 @@\n \n     private final BindVariableExpression _bind;\n     private final Exp _exp;\n-    private Joins _joins = null;\n \n     /**\n      * Constructor. Supply the two combined expressions.\n@@ -44,30 +40,25 @@ public BindVariableAndExpression(BindVariableExpression bind, Exp exp) {\n         _exp = exp;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n-        _bind.initialize(sel, store, params, contains);\n-        _exp.initialize(sel, store, params, contains);\n-        _joins = sel.and(_bind.getJoins(), _exp.getJoins());\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n+        ExpState s1 = _bind.initialize(sel, ctx, contains);\n+        ExpState s2 = _exp.initialize(sel, ctx, contains);\n+        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n         boolean or = _exp instanceof OrExpression;\n         if (or)\n             buf.append(\"(\");\n-        _exp.appendTo(buf, sel, store, params, fetch);\n+        _exp.appendTo(sel, ctx, ((BinaryOpExpState) state).state2, buf);\n         if (or)\n             buf.append(\")\");\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _exp.selectColumns(sel, store, params, pks, fetch);\n-    }\n-\n-    public Joins getJoins() {\n-        return _joins;\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        _exp.selectColumns(sel, ctx, ((BinaryOpExpState) state).state2, pks);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"d9746944a1e9ae86ae7ba2ae075391ffb67a0d46","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableExpression.java","status":"modified","additions":6,"deletions":14,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/BindVariableExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,9 +17,6 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n@@ -54,22 +51,17 @@ public Variable getVariable() {\n         return _var;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n-        _var.initialize(sel, store, false);\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n+        return _var.initialize(sel, ctx, 0);\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n         buf.append(\"1 = 1\");\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-    }\n-\n-    public Joins getJoins() {\n-        return _var.getJoins();\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"2864c5101a6f0b9e66922c028640b6bfa7000bc7","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareEqualExpression.java","status":"modified","additions":39,"deletions":44,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareEqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareEqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareEqualExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,12 +17,10 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.exps.Constant;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.util.UserException;\n@@ -40,7 +38,6 @@\n \n     private final Val _val1;\n     private final Val _val2;\n-    private Joins _joins = null;\n \n     /**\n      * Constructor. Supply values to compare.\n@@ -58,63 +55,61 @@ public Val getValue2() {\n         return _val2;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n         boolean direct = isDirectComparison();\n-        _val1.initialize(sel, store, direct && isNull(_val2, params));\n-        _val2.initialize(sel, store, direct && isNull(_val1, params));\n-        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n+        int flags1 = 0;\n+        int flags2 = 0;\n+        ExpState s1 = null;\n+        ExpState s2 = null;\n+        if (_val1 instanceof Const) {\n+            s1 = _val1.initialize(sel, ctx, 0);\n+            if (direct && ((Const) _val1).getValue(ctx, s1) == null)\n+                flags2 = Val.NULL_CMP;\n+        }\n+        if (_val2 instanceof Const) {\n+            s2 = _val2.initialize(sel, ctx, 0);\n+            if (direct && ((Const) _val2).getValue(ctx, s2) == null)\n+                flags1 = Val.NULL_CMP;\n+        }\n+        \n+        if (s1 == null)\n+            s1 = _val1.initialize(sel, ctx, flags1);\n+        if (s2 == null)\n+            s2 = _val2.initialize(sel, ctx, flags2);\n+        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n     }\n \n-    /**\n-     * Return whether the given value is null.\n-     */\n-    private boolean isNull(Val val, Object[] params) {\n-        if (val instanceof Null)\n-            return true;\n-        if (!(val instanceof Param))\n-            return false;\n-\n-        Param param = (Param) val;\n-        return params[param.getIndex()] == null;\n-    }\n-\n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        _val1.calculateValue(sel, store, params, _val2, fetch);\n-        _val2.calculateValue(sel, store, params, _val1, fetch);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.calculateValue(sel, ctx, bstate.state1, _val2, bstate.state2);\n+        _val2.calculateValue(sel, ctx, bstate.state2, _val1, bstate.state1);\n         if (!Filters.canConvert(_val1.getType(), _val2.getType(), false)\n             && !Filters.canConvert(_val2.getType(), _val1.getType(), false))\n             throw new UserException(_loc.get(\"cant-convert\", _val1.getType(),\n                 _val2.getType()));\n \n         boolean val1Null = _val1 instanceof Const\n-            && ((Const) _val1).isSQLValueNull();\n+            && ((Const) _val1).isSQLValueNull(sel, ctx, bstate.state1);\n         boolean val2Null = _val2 instanceof Const\n-            && ((Const) _val2).isSQLValueNull();\n-        appendTo(buf, sel, store, params, fetch, val1Null, val2Null);\n-        sel.append(buf, _joins);\n-\n-        _val1.clearParameters();\n-        _val2.clearParameters();\n-    }\n-\n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val1.selectColumns(sel, store, params, true, fetch);\n-        _val2.selectColumns(sel, store, params, true, fetch);\n+            && ((Const) _val2).isSQLValueNull(sel, ctx, bstate.state2);\n+        appendTo(sel, ctx, bstate, buf, val1Null, val2Null);\n+        sel.append(buf, state.joins);\n     }\n \n-    public Joins getJoins() {\n-        return _joins;\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.selectColumns(sel, ctx, bstate.state1, true);\n+        _val2.selectColumns(sel, ctx, bstate.state2, true);\n     }\n \n     /**\n      * Append the SQL for the comparison.\n      */\n-    protected abstract void appendTo(SQLBuffer buf, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch,\n-        boolean val1Null, boolean val2Null);\n+    protected abstract void appendTo(Select sel, ExpContext ctx, \n+        BinaryOpExpState state, SQLBuffer buf, boolean val1Null, \n+        boolean val2Null);\n \n     /**\n      * Subclasses can override this method if, when they compare to another,"},{"sha":"a5177e1d4610bba21557ee965ebddf965b2feaa4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareExpression.java","status":"modified","additions":18,"deletions":28,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CompareExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,9 +17,6 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.Filters;\n@@ -46,7 +43,6 @@\n     private final Val _val1;\n     private final Val _val2;\n     private final String _op;\n-    private Joins _joins = null;\n \n     /**\n      * Constructor. Supply values and operator.\n@@ -57,39 +53,33 @@ public CompareExpression(Val val1, Val val2, String op) {\n         _op = op;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n-        _val1.initialize(sel, store, false);\n-        _val2.initialize(sel, store, false);\n-        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n+        ExpState s1 = _val1.initialize(sel, ctx, 0);\n+        ExpState s2 = _val2.initialize(sel, ctx, 0);\n+        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        _val1.calculateValue(sel, store, params, _val2, fetch);\n-        _val2.calculateValue(sel, store, params, _val1, fetch);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.calculateValue(sel, ctx, bstate.state1, _val2, bstate.state2);\n+        _val2.calculateValue(sel, ctx, bstate.state2, _val1, bstate.state1);\n         if (!Filters.canConvert(_val1.getType(), _val2.getType(), false)\n             && !Filters.canConvert(_val2.getType(), _val1.getType(), false))\n             throw new UserException(_loc.get(\"cant-convert\", _val1.getType(),\n                 _val2.getType()));\n \n-        store.getDBDictionary().comparison(buf, _op,\n-            new FilterValueImpl(_val1, sel, store, params, fetch),\n-            new FilterValueImpl(_val2, sel, store, params, fetch));\n-        sel.append(buf, _joins);\n-\n-        _val1.clearParameters();\n-        _val2.clearParameters();\n-    }\n-\n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val1.selectColumns(sel, store, params, true, fetch);\n-        _val2.selectColumns(sel, store, params, true, fetch);\n+        ctx.store.getDBDictionary().comparison(buf, _op,\n+            new FilterValueImpl(sel, ctx, bstate.state1, _val1),\n+            new FilterValueImpl(sel, ctx, bstate.state2, _val2));\n+        sel.append(buf, state.joins);\n     }\n \n-    public Joins getJoins() {\n-        return _joins;\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.selectColumns(sel, ctx, bstate.state1, true);\n+        _val2.selectColumns(sel, ctx, bstate.state2, true);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"cc292d68e618d1b161f8c887fdb78e6dfa75d6ca","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Concat.java","status":"modified","additions":48,"deletions":76,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Concat.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Concat.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Concat.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -18,11 +18,8 @@\n import java.lang.Math;\n import java.sql.SQLException;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n@@ -40,11 +37,7 @@\n \n     private final Val _val1;\n     private final Val _val2;\n-    private Joins _joins = null;\n     private ClassMetaData _meta = null;\n-    private String _part1;\n-    private String _part2;\n-    private String _part3;\n \n     /**\n      * Constructor. Provide the strings to operate on.\n@@ -62,106 +55,85 @@ public void setMetaData(ClassMetaData meta) {\n         _meta = meta;\n     }\n \n-    public boolean isVariable() {\n-        return false;\n-    }\n-\n     public Class getType() {\n         return String.class;\n     }\n \n     public void setImplicitType(Class type) {\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n-        _val1.initialize(sel, store, false);\n-        _val2.initialize(sel, store, false);\n-        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n-\n-        DBDictionary dict = store.getDBDictionary();\n-        String func = dict.concatenateFunction;\n-\n-        dict.assertSupport(func != null, \"ConcatenateFunction\");\n-\n-        int part1idx = func.indexOf(\"{0}\");\n-        int part2idx = func.indexOf(\"{1}\");\n-\n-        _part1 = func.substring(0, Math.min(part1idx, part2idx));\n-        _part2 = func.substring(Math.min(part1idx, part2idx) + 3,\n-            Math.max(part1idx, part2idx));\n-        _part3 = func.substring(Math.max(part1idx, part2idx) + 3);\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        ExpState s1 = _val1.initialize(sel, ctx, 0);\n+        ExpState s2 = _val2.initialize(sel, ctx, 0);\n+        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n     }\n \n-    public Joins getJoins() {\n-        return _joins;\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        sel.select(newSQLBuffer(sel, ctx, state), this);\n     }\n \n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        return val;\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.selectColumns(sel, ctx, bstate.state1, true);\n+        _val2.selectColumns(sel, ctx, bstate.state2, true);\n     }\n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n-        sel.select(newSQLBuffer(sel, store, params, fetch), this);\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+        sel.groupBy(newSQLBuffer(sel, ctx, state));\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val1.selectColumns(sel, store, params, true, fetch);\n-        _val2.selectColumns(sel, store, params, true, fetch);\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n+        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-        sel.groupBy(newSQLBuffer(sel, store, params, fetch));\n-    }\n-\n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n-        sel.orderBy(newSQLBuffer(sel, store, params, fetch), asc, false);\n-    }\n-\n-    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        calculateValue(sel, store, params, null, fetch);\n-        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n-        appendTo(buf, 0, sel, store, params, fetch);\n-        clearParameters();\n+    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n+        calculateValue(sel, ctx, state, null, null);\n+        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n+        appendTo(sel, ctx, state, buf, 0);\n         return buf;\n     }\n \n-    public Object load(Result res, JDBCStore store, \n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res) \n         throws SQLException {\n         return Filters.convert(res.getObject(this,\n             JavaSQLTypes.JDBC_DEFAULT, null), getType());\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        _val1.calculateValue(sel, store, params, null, fetch);\n-        _val2.calculateValue(sel, store, params, null, fetch);\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.calculateValue(sel, ctx, bstate.state1, null, null);\n+        _val2.calculateValue(sel, ctx, bstate.state2, null, null);\n     }\n \n-    public void clearParameters() {\n-        _val1.clearParameters();\n-        _val2.clearParameters();\n-    }\n-\n-    public int length() {\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n         return 1;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        _val1.calculateValue(sel, store, params, _val2, fetch);\n-        _val2.calculateValue(sel, store, params, _val1, fetch);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.calculateValue(sel, ctx, bstate.state1, null, null);\n+        _val2.calculateValue(sel, ctx, bstate.state2, null, null);\n+\n+        DBDictionary dict = ctx.store.getDBDictionary();\n+        String func = dict.concatenateFunction;\n+        dict.assertSupport(func != null, \"ConcatenateFunction\");\n+        int part1idx = func.indexOf(\"{0}\");\n+        int part2idx = func.indexOf(\"{1}\");\n+        String part1 = func.substring(0, Math.min(part1idx, part2idx));\n+        String part2 = func.substring(Math.min(part1idx, part2idx) + 3,\n+            Math.max(part1idx, part2idx));\n+        String part3 = func.substring(Math.max(part1idx, part2idx) + 3);\n \n-        sql.append(_part1);\n-        _val1.appendTo(sql, 0, sel, store, params, fetch);\n-        sql.append(_part2);\n-        _val2.appendTo(sql, 0, sel, store, params, fetch);\n-        sql.append(_part3);\n+        sql.append(part1);\n+        _val1.appendTo(sel, ctx, bstate.state1, sql, 0);\n+        sql.append(part2);\n+        _val2.appendTo(sel, ctx, bstate.state2, sql, 0);\n+        sql.append(part3);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"c95a07e6ee979f3f58edc01c4ad7835c082a2ccf","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Const.java","status":"modified","additions":63,"deletions":74,"changes":137,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Const.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Const.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Const.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -19,11 +19,8 @@\n import java.util.Collection;\n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n@@ -42,7 +39,6 @@\n     implements Constant {\n \n     private ClassMetaData _meta = null;\n-    private Column[] _cols = null;\n \n     public ClassMetaData getMetaData() {\n         return _meta;\n@@ -52,34 +48,18 @@ public void setMetaData(ClassMetaData meta) {\n         _meta = meta;\n     }\n \n-    /**\n-     * Return the column for the value at the specified index, or null.\n-     */\n-    public Column getColumn(int index) {\n-        return (_cols != null && _cols.length > index) ? _cols[index] : null;\n-    }\n-\n-    /**\n-     * Return the value of this constant.\n-     */\n-    public abstract Object getValue();\n-\n-    public Object getValue(Object[] parameters) {\n-        return getValue();\n-    }\n-\n     /**\n      * Return the SQL value of this constant.\n      */\n-    public Object getSQLValue() {\n-        return getValue();\n+    public Object getSQLValue(Select sel, ExpContext ctx, ExpState state) {\n+        return getValue(ctx, state);\n     }\n \n     /**\n      * Return true if this constant's SQL value is equivalent to NULL.\n      */\n-    public boolean isSQLValueNull() {\n-        Object val = getSQLValue();\n+    public boolean isSQLValueNull(Select sel, ExpContext ctx, ExpState state) {\n+        Object val = getSQLValue(sel, ctx, state);\n         if (val == null)\n             return true;\n         if (!(val instanceof Object[]))\n@@ -93,69 +73,78 @@ public boolean isSQLValueNull() {\n         return true;\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+    /**\n+     * Return the value of this constant.  May be more robust than the\n+     * parameters-only form.\n+     */\n+    public Object getValue(ExpContext ctx, ExpState state) {\n+        return getValue(ctx.params);\n     }\n \n-    public Joins getJoins() {\n-        return null;\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        return new ConstExpState();\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        if (other instanceof PCPath)\n-            _cols = ((PCPath) other).getColumns();\n-        else\n-            _cols = null;\n+    /**\n+     * Constant expression state.\n+     */\n+    protected static class ConstExpState\n+        extends ExpState {\n+\n+        public Column[] cols = null;\n+\n+        /**\n+         * Return the column for the value at the specified index, or null.\n+         */\n+        public Column getColumn(int index) {\n+            return (cols != null && cols.length > index) ? cols[index] : null;\n+        }\n     }\n \n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        return val;\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        if (other instanceof PCPath)\n+            ((ConstExpState) state).cols = ((PCPath) other).\n+                getColumns(otherState);\n     }\n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n-        sel.select(newSQLBuffer(sel, store, params, fetch), this);\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        sel.select(newSQLBuffer(sel, ctx, state), this);\n     }\n \n-    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        calculateValue(sel, store, params, null, fetch);\n-        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n-        appendTo(buf, 0, sel, store, params, fetch);\n-        clearParameters();\n+    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n+        calculateValue(sel, ctx, state, null, null);\n+        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n+        appendTo(sel, ctx, state, buf, 0);\n         return buf;\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-        sel.groupBy(newSQLBuffer(sel, store, params, fetch));\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+        sel.groupBy(newSQLBuffer(sel, ctx, state));\n     }\n \n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n-        sel.orderBy(newSQLBuffer(sel, store, params, fetch), asc, false);\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n+        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n     }\n \n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res)\n         throws SQLException {\n-        int code = JavaTypes.getTypeCode(getType());\n-        if (code == JavaTypes.OBJECT)\n-            code = JavaSQLTypes.JDBC_DEFAULT;\n-        return Filters.convert(res.getObject(this, code, null), getType());\n+        return getValue(ctx, state);\n     }\n \n-    public int length() {\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n         return 1;\n     }\n \n-    public void appendIsEmpty(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        Object obj = getValue();\n+    public void appendIsEmpty(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n+        Object obj = getValue(ctx, state);\n         if (obj instanceof Collection && ((Collection) obj).isEmpty())\n             sql.append(TRUE);\n         else if (obj instanceof Map && ((Map) obj).isEmpty())\n@@ -164,9 +153,9 @@ else if (obj instanceof Map && ((Map) obj).isEmpty())\n             sql.append(FALSE);\n     }\n \n-    public void appendIsNotEmpty(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        Object obj = getValue();\n+    public void appendIsNotEmpty(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql){\n+        Object obj = getValue(ctx, state);\n         if (obj instanceof Collection && ((Collection) obj).isEmpty())\n             sql.append(FALSE);\n         else if (obj instanceof Map && ((Map) obj).isEmpty())\n@@ -175,9 +164,9 @@ else if (obj instanceof Map && ((Map) obj).isEmpty())\n             sql.append(TRUE);\n     }\n \n-    public void appendSize(SQLBuffer sql, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        Object obj = getValue();\n+    public void appendSize(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n+        Object obj = getValue(ctx, state);\n         if (obj instanceof Collection)\n             sql.appendValue(((Collection) obj).size());\n         else if (obj instanceof Map)\n@@ -186,17 +175,17 @@ else if (obj instanceof Map)\n             sql.append(\"1\");\n     }\n \n-    public void appendIsNull(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        if (getSQLValue() == null)\n+    public void appendIsNull(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n+        if (isSQLValueNull(sel, ctx, state))\n             sql.append(TRUE);\n         else\n             sql.append(FALSE);\n     }\n \n-    public void appendIsNotNull(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        if (getSQLValue() != null)\n+    public void appendIsNotNull(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n+        if (!isSQLValueNull(sel, ctx, state))\n             sql.append(TRUE);\n         else\n             sql.append(FALSE);"},{"sha":"dc2ececb95d0b28b25c3389560044476808de631","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstGetObjectId.java","status":"modified","additions":48,"deletions":26,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstGetObjectId.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstGetObjectId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstGetObjectId.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,8 +15,8 @@\n  */\n package org.apache.openjpa.jdbc.kernel.exps;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n \n@@ -29,9 +29,6 @@\n     extends Const {\n \n     private final Const _constant;\n-    private Object _val = null;\n-    private Object _sqlVal = null;\n-    private int _otherLen = 0;\n \n     /**\n      * Constructor. Supply constant to traverse.\n@@ -47,37 +44,62 @@ public Class getType() {\n     public void setImplicitType(Class type) {\n     }\n \n-    public Object getValue() {\n-        return _val;\n+    public Object getValue(Object[] params) {\n+        Object o = _constant.getValue(params);\n+        if (!(o instanceof PersistenceCapable))\n+            return null;\n+        return ((PersistenceCapable) o).pcFetchObjectId();\n     }\n \n-    public Object getSQLValue() {\n-        return _sqlVal;\n+    public Object getValue(ExpContext ctx, ExpState state) {\n+        return ctx.store.getContext().getObjectId(_constant.getValue(ctx, \n+            ((ConstGetObjectIdExpState) state).constantState));\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        super.calculateValue(sel, store, params, other, fetch);\n-        _constant.calculateValue(sel, store, params, null, fetch);\n-        _val = store.getContext().getObjectId(_constant.getValue());\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        return new ConstGetObjectIdExpState(_constant.initialize(sel, ctx, 0));\n+    }\n+\n+    public Object getSQLValue(Select sel, ExpContext ctx, ExpState state) {\n+        return ((ConstGetObjectIdExpState) state).sqlValue;\n+    }\n+\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        super.calculateValue(sel, ctx, state, other, otherState);\n+        ConstGetObjectIdExpState cstate = (ConstGetObjectIdExpState) state;\n+        _constant.calculateValue(sel, ctx, cstate.constantState, null, null);\n+        Object oid = ctx.store.getContext().getObjectId(_constant.getValue(ctx, \n+            cstate.constantState));\n         if (other != null) {\n-            _sqlVal = other.toDataStoreValue(_val, store);\n-            _otherLen = other.length();\n+            cstate.sqlValue = other.toDataStoreValue(sel, ctx, otherState, oid);\n+            cstate.otherLength = other.length(sel, ctx, otherState);\n         } else\n-            _sqlVal = _val;\n+            cstate.sqlValue = oid;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        if (_otherLen > 1)\n-            sql.appendValue(((Object[]) _sqlVal)[index], getColumn(index));\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        ConstGetObjectIdExpState cstate = (ConstGetObjectIdExpState) state;\n+        if (cstate.otherLength > 1)\n+            sql.appendValue(((Object[]) cstate.sqlValue)[index], \n+                cstate.getColumn(index));\n         else\n-            sql.appendValue(_sqlVal, getColumn(index));\n+            sql.appendValue(cstate.sqlValue, cstate.getColumn(index));\n     }\n \n-    public void clearParameters() {\n-        _constant.clearParameters();\n-        _val = null;\n-        _sqlVal = null;\n+    /**\n+     * Expression state.\n+     */\n+    private static class ConstGetObjectIdExpState \n+        extends ConstExpState {\n+\n+        public final ExpState constantState;\n+        public Object sqlValue = null;\n+        public int otherLength = 0;\n+\n+        public ConstGetObjectIdExpState(ExpState constantState) {\n+            this.constantState = constantState;\n+        }\n     }\n }"},{"sha":"742b21adaea12ccccfe4ce465ef89e2cd0a77f6a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstInstanceofExpression.java","status":"modified","additions":9,"deletions":18,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstInstanceofExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstInstanceofExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstInstanceofExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,9 +17,6 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.Filters;\n@@ -44,28 +41,22 @@ public ConstInstanceofExpression(Const val, Class cls) {\n         _cls = Filters.wrap(cls);\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n-        _const.initialize(sel, store, false);\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n+        return _const.initialize(sel, ctx, 0);\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        _const.calculateValue(sel, store, params, null, fetch);\n-        if (_cls.isInstance(_const.getValue()))\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n+        _const.calculateValue(sel, ctx, state, null, null);\n+        if (_cls.isInstance(_const.getValue(ctx, state)))\n             buf.append(\"1 = 1\");\n         else\n             buf.append(\"1 <> 1\");\n-        _const.clearParameters();\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _const.selectColumns(sel, store, params, pks, fetch);\n-    }\n-\n-    public Joins getJoins() {\n-        return _const.getJoins();\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        _const.selectColumns(sel, ctx, state, pks);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"fa3c723f0757b0945ade06115a5289c8cad13862","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java","status":"modified","additions":56,"deletions":38,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -20,8 +20,6 @@\n import java.util.ListIterator;\n \n import org.apache.openjpa.enhance.PersistenceCapable;\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.Broker;\n@@ -30,6 +28,7 @@\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.util.InternalException;\n \n /**\n  * A field traversal starting with a constant filter parameter.\n@@ -42,9 +41,6 @@\n \n     private final Const _constant;\n     private final LinkedList _actions = new LinkedList();\n-    private Object _val = null;\n-    private Object _sqlVal = null;\n-    private int _otherLen = 0;\n \n     /**\n      * Constructor. Supply constant to traverse.\n@@ -90,19 +86,28 @@ public FieldMetaData last() {\n         return null;\n     }\n \n-    public Object getValue() {\n-        return _val;\n+    public Object getValue(Object[] params) {\n+        throw new InternalException();\n     }\n \n-    public Object getSQLValue() {\n-        return _sqlVal;\n+    public Object getValue(ExpContext ctx, ExpState state) {\n+        return ((ConstPathExpState) state).value;\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        super.calculateValue(sel, store, params, other, fetch);\n-        _constant.calculateValue(sel, store, params, null, fetch);\n-        _val = _constant.getValue();\n+    public Object getSQLValue(Select sel, ExpContext ctx, ExpState state) {\n+        return ((ConstPathExpState) state).sqlValue;\n+    }\n+\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        return new ConstPathExpState(_constant.initialize(sel, ctx, 0));\n+    }\n+\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        super.calculateValue(sel, ctx, state, other, otherState);\n+        ConstPathExpState cstate = (ConstPathExpState) state;\n+        _constant.calculateValue(sel, ctx, cstate.constantState, null, null);\n+        cstate.value = _constant.getValue(ctx, cstate.constantState);\n         boolean failed = false;\n \n         // copied from org.apache.openjpa.query.InMemoryPath\n@@ -111,15 +116,15 @@ public void calculateValue(Select sel, JDBCStore store,\n         Broker tmpBroker = null;\n         for (Iterator itr = _actions.iterator(); itr.hasNext();) {\n             // fail on null value\n-            if (_val == null) {\n+            if (cstate.value == null) {\n                 failed = true;\n                 break;\n             }\n \n             action = itr.next();\n             if (action instanceof Class) {\n                 try {\n-                    _val = Filters.convert(_val, (Class) action);\n+                    cstate.value = Filters.convert(cstate.value, (Class)action);\n                     continue;\n                 } catch (ClassCastException cce) {\n                     failed = true;\n@@ -131,19 +136,19 @@ public void calculateValue(Select sel, JDBCStore store,\n             // be proxyable\n             sm = null;\n             tmpBroker = null;\n-            if (_val instanceof PersistenceCapable)\n-                sm = (OpenJPAStateManager) ((PersistenceCapable) _val).\n+            if (cstate.value instanceof PersistenceCapable)\n+                sm = (OpenJPAStateManager) ((PersistenceCapable) cstate.value).\n                     pcGetStateManager();\n             if (sm == null) {\n-                tmpBroker = store.getContext().getBroker();\n-                tmpBroker.transactional(_val, false, null);\n-                sm = tmpBroker.getStateManager(_val);\n+                tmpBroker = ctx.store.getContext().getBroker();\n+                tmpBroker.transactional(cstate.value, false, null);\n+                sm = tmpBroker.getStateManager(cstate.value);\n             }\n \n             try {\n                 // get the specified field value and switch candidate\n-                _val = sm.fetchField(((FieldMetaData) action).getIndex(),\n-                    true);\n+                cstate.value = sm.fetchField(((FieldMetaData) action).\n+                    getIndex(), true);\n             } finally {\n                 // setTransactional does not clear the state, which is\n                 // important since tmpVal might be also managed by\n@@ -154,32 +159,45 @@ public void calculateValue(Select sel, JDBCStore store,\n         }\n \n         if (failed)\n-            _val = null;\n+            cstate.value = null;\n \n         if (other != null) {\n-            _sqlVal = other.toDataStoreValue(_val, store);\n-            _otherLen = other.length();\n+            cstate.sqlValue = other.toDataStoreValue(sel, ctx, otherState, \n+                cstate.value);\n+            cstate.otherLength = other.length(sel, ctx, otherState);\n         } else\n-            _sqlVal = _val;\n+            cstate.sqlValue = cstate.value;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        if (_otherLen > 1)\n-            sql.appendValue(((Object[]) _sqlVal)[index], getColumn(index));\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        ConstPathExpState cstate = (ConstPathExpState) state;\n+        if (cstate.otherLength > 1)\n+            sql.appendValue(((Object[]) cstate.sqlValue)[index], \n+                cstate.getColumn(index));\n         else\n-            sql.appendValue(_sqlVal, getColumn(index));\n-    }\n-\n-    public void clearParameters() {\n-        _constant.clearParameters();\n-        _val = null;\n-        _sqlVal = null;\n+            sql.appendValue(cstate.sqlValue, cstate.getColumn(index));\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {\n         visitor.enter(this);\n         _constant.acceptVisit(visitor);\n         visitor.exit(this);\n     }\n+\n+    /**\n+     * Expression state.\n+     */\n+    private static class ConstPathExpState \n+        extends ConstExpState {\n+\n+        public final ExpState constantState;\n+        public Object value = null;\n+        public Object sqlValue = null;\n+        public int otherLength = 0;\n+\n+        public ConstPathExpState(ExpState constantState) {\n+            this.constantState = constantState;\n+        }\n+    }\n }"},{"sha":"632a91d9611cee94abb9582d3aeb5bc5f49581e4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsExpression.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,7 +17,6 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.Select;\n import serp.util.Numbers;\n \n@@ -36,8 +35,7 @@ public ContainsExpression(Val val1, Val val2) {\n         super(val1, val2);\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n         Val val1 = getValue1();\n         if (contains != null && val1 instanceof PCPath) {\n             PCPath sql = (PCPath) val1;\n@@ -53,7 +51,7 @@ public void initialize(Select sel, JDBCStore store,\n \n             sql.setContainsId(count.toString());\n         }\n-        super.initialize(sel, store, params, contains);\n+        return super.initialize(sel, ctx, contains);\n     }\n \n     protected boolean isDirectComparison() {"},{"sha":"815ded00660870421babe4c69a04dc2cca2db318","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsKeyExpression.java","status":"modified","additions":2,"deletions":5,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsKeyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsKeyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ContainsKeyExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,7 +17,6 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.Select;\n \n /**\n@@ -35,12 +34,10 @@ public ContainsKeyExpression(Val val1, Val val2) {\n         super(val1, val2);\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n         Val val1 = getValue1();\n         if (val1 instanceof PCPath)\n             ((PCPath) val1).getKey();\n-\n-        super.initialize(sel, store, params, contains);\n+        return super.initialize(sel, ctx, contains);\n     }\n }"},{"sha":"70e998fc4ef6aba7428ee92763e019531b2e20ae","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Count.java","status":"modified","additions":2,"deletions":5,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Count.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Count.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Count.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,7 +15,6 @@\n  */\n package org.apache.openjpa.jdbc.kernel.exps;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.Select;\n \n /**\n@@ -33,11 +32,9 @@ public Count(Val val) {\n         super(val);\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n-        super.initialize(sel, store, nullTest);\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n         // join into related object if present\n-        if (getVal()instanceof PCPath)\n-            ((PCPath) getVal()).joinRelation();\n+        return initializeValue(sel, ctx, JOIN_REL);\n     }\n \n     protected Class getType(Class c) {"},{"sha":"18caea70d9cbd59e5c44c2aed7952fde9f9c1389","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CurrentDate.java","status":"modified","additions":20,"deletions":23,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CurrentDate.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CurrentDate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/CurrentDate.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,10 +17,10 @@\n \n import java.util.Date;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.util.InternalException;\n \n /**\n  * A literal current DATE/TIME/TIMESTAMP value in a filter.\n@@ -30,13 +30,9 @@\n class CurrentDate\n     extends Const {\n \n-    static final int DATE = 1;\n-    static final int TIME = 2;\n-    static final int TIMESTAMP = 3;\n-\n     private final int _type;\n \n-    CurrentDate(int type) {\n+    public CurrentDate(int type) {\n         _type = type;\n     }\n \n@@ -47,24 +43,25 @@ public Class getType() {\n     public void setImplicitType(Class type) {\n     }\n \n-    public Object getValue() {\n+    public Object getValue(Object[] params) {\n         return new Date();\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-    }\n-\n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        if (_type == DATE)\n-            sql.append(store.getDBDictionary().currentDateFunction);\n-        else if (_type == TIME)\n-            sql.append(store.getDBDictionary().currentTimeFunction);\n-        else if (_type == TIMESTAMP)\n-            sql.append(store.getDBDictionary().currentTimestampFunction);\n-    }\n-\n-    public void clearParameters() {\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        switch (_type) {\n+            case JavaSQLTypes.DATE:\n+                sql.append(ctx.store.getDBDictionary().currentDateFunction);\n+                break;\n+            case JavaSQLTypes.TIME:\n+                sql.append(ctx.store.getDBDictionary().currentTimeFunction);\n+                break;\n+            case JavaSQLTypes.TIMESTAMP:\n+                sql.append(ctx.store.getDBDictionary().\n+                    currentTimestampFunction);\n+                break;\n+            default:\n+                throw new InternalException();\n+        }\n     }\n }"},{"sha":"862ff11e84f88fca321eb23a5240c4b18dcb610c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Distinct.java","status":"modified","additions":2,"deletions":7,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Distinct.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Distinct.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Distinct.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,7 +15,6 @@\n  */\n package org.apache.openjpa.jdbc.kernel.exps;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.Select;\n \n /**\n@@ -30,16 +29,12 @@ public Distinct(Val val) {\n         super(val);\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n-        super.initialize(sel, store, nullTest);\n-\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n         // join into related object if present\n-        if (getVal()instanceof PCPath)\n-            ((PCPath) getVal()).joinRelation();\n+        return initializeValue(sel, ctx, JOIN_REL);\n     }\n \n     protected String getOperator() {\n         return \"DISTINCT\";\n     }\n }\n-"},{"sha":"7e9444a199494a33724711882ff0c2791273d1f7","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EmptyExpression.java","status":"modified","additions":6,"deletions":13,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EmptyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EmptyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EmptyExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,9 +17,6 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n@@ -32,20 +29,16 @@\n class EmptyExpression\n     implements Exp {\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n+        return ExpState.NULL;\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-    }\n-\n-    public Joins getJoins() {\n-        return null;\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"83574d87742f5731825838eb0092d8da5c30ece2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EndsWithExpression.java","status":"modified","additions":47,"deletions":54,"changes":101,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EndsWithExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EndsWithExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EndsWithExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,14 +17,11 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.Table;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n@@ -39,9 +36,6 @@\n \n     private final Val _val1;\n     private final Val _val2;\n-    private Joins _joins = null;\n-    private String _pre = null;\n-    private String _post = null;\n \n     /**\n      * Constructor. Supply values.\n@@ -51,70 +45,67 @@ public EndsWithExpression(Val val1, Val val2) {\n         _val2 = val2;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n-        _val1.initialize(sel, store, false);\n-        _val2.initialize(sel, store, false);\n-        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n+        ExpState s1 = _val1.initialize(sel, ctx, 0);\n+        ExpState s2 = _val2.initialize(sel, ctx, 0);\n+        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n+    }\n+\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.calculateValue(sel, ctx, bstate.state1, _val2, bstate.state2);\n+        _val2.calculateValue(sel, ctx, bstate.state2, _val1, bstate.state1);\n \n-        DBDictionary dict = store.getDBDictionary();\n+        DBDictionary dict = ctx.store.getDBDictionary();\n         String func = dict.stringLengthFunction;\n+        String pre = null;\n+        String post = null;\n         if (func != null) {\n             int idx = func.indexOf(\"{0}\");\n-            _pre = func.substring(0, idx);\n-            _post = func.substring(idx + 3);\n+            pre = func.substring(0, idx);\n+            post = func.substring(idx + 3);\n         }\n-    }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        _val1.calculateValue(sel, store, params, _val2, fetch);\n-        _val2.calculateValue(sel, store, params, _val1, fetch);\n-\n-        if (_val1 instanceof Const && ((Const) _val1).getValue() == null)\n+        if (_val1 instanceof Const && ((Const) _val1).getValue(ctx, \n+            bstate.state1) == null)\n             buf.append(\"1 <> 1\");\n         else if (_val2 instanceof Const) {\n-            Object o = ((Const) _val2).getValue();\n+            Object o = ((Const) _val2).getValue(ctx, bstate.state2);\n             if (o == null)\n                 buf.append(\"1 <> 1\");\n             else {\n                 Column col = null;\n                 if (_val1 instanceof PCPath) {\n-                    Column[] cols = ((PCPath) _val1).getColumns();\n+                    Column[] cols = ((PCPath) _val1).getColumns(bstate.state1);\n                     if (cols.length == 1)\n                         col = cols[0];\n                 }\n \n-                _val1.appendTo(buf, 0, sel, store, params, fetch);\n+                _val1.appendTo(sel, ctx, bstate.state1, buf, 0);\n                 buf.append(\" LIKE \");\n                 buf.appendValue(\"%\" + o.toString(), col);\n             }\n         } else {\n             // if we can't use LIKE, we have to take the substring of the\n             // first value and compare it to the second\n-            DBDictionary dict = store.getDBDictionary();\n-            dict.assertSupport(_pre != null, \"StringLengthFunction\");\n-            dict.substring(buf,\n-                new FilterValueImpl(_val1, sel, store, params, fetch),\n-                new StringLengthDifferenceFilterValue(sel, store, params,\n-                    fetch), null);\n+            dict.assertSupport(pre != null, \"StringLengthFunction\");\n+            dict.substring(buf, \n+                new FilterValueImpl(sel, ctx, bstate.state1, _val1),\n+                new StringLengthDifferenceFilterValue(sel, ctx, bstate, pre, \n+                    post), null);\n             buf.append(\" = \");\n-            _val2.appendTo(buf, 0, sel, store, params, fetch);\n+            _val2.appendTo(sel, ctx, bstate.state2, buf, 0);\n         }\n \n-        sel.append(buf, _joins);\n-        _val1.clearParameters();\n-        _val2.clearParameters();\n-    }\n-\n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val1.selectColumns(sel, store, params, true, fetch);\n-        _val2.selectColumns(sel, store, params, true, fetch);\n+        sel.append(buf, state.joins);\n     }\n \n-    public Joins getJoins() {\n-        return _joins;\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.selectColumns(sel, ctx, bstate.state1, true);\n+        _val2.selectColumns(sel, ctx, bstate.state2, true);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {\n@@ -131,16 +122,18 @@ public void acceptVisit(ExpressionVisitor visitor) {\n         implements FilterValue {\n \n         private final Select _sel;\n-        private final JDBCStore _store;\n-        private final Object[] _params;\n-        private final JDBCFetchConfiguration _fetch;\n+        private final ExpContext _ctx;\n+        private final BinaryOpExpState _state;\n+        private final String _pre;\n+        private final String _post;\n \n-        public StringLengthDifferenceFilterValue(Select sel,\n-            JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+        public StringLengthDifferenceFilterValue(Select sel, ExpContext ctx, \n+            BinaryOpExpState state, String pre, String post) {\n             _sel = sel;\n-            _store = store;\n-            _params = params;\n-            _fetch = fetch;\n+            _ctx = ctx;\n+            _state = state;\n+            _pre = pre;\n+            _post = post;\n         }\n \n         public Class getType() {\n@@ -157,18 +150,18 @@ public void appendTo(SQLBuffer buf) {\n \n         public void appendTo(SQLBuffer buf, int index) {\n             buf.append(_pre);\n-            _val1.appendTo(buf, index, _sel, _store, _params, _fetch);\n+            _val1.appendTo(_sel, _ctx, _state.state1, buf, index);\n             buf.append(_post).append(\" - \").append(_pre);\n-            _val2.appendTo(buf, index, _sel, _store, _params, _fetch);\n+            _val2.appendTo(_sel, _ctx, _state.state2, buf, index);\n             buf.append(_post);\n         }\n \n         public String getColumnAlias(Column col) {\n-            return _sel.getColumnAlias(col, _joins);\n+            return _sel.getColumnAlias(col, _state.joins);\n         }\n \n         public String getColumnAlias(String col, Table table) {\n-            return _sel.getColumnAlias(col, table, _joins);\n+            return _sel.getColumnAlias(col, table, _state.joins);\n         }\n \n         public Object toDataStoreValue(Object val) {"},{"sha":"62a2e68fe952f164c437995c9cebe5601b818a6a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EqualExpression.java","status":"modified","additions":15,"deletions":15,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EqualExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,8 +15,6 @@\n  */\n package org.apache.openjpa.jdbc.kernel.exps;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n \n@@ -35,39 +33,41 @@ public EqualExpression(Val val1, Val val2) {\n         super(val1, val2);\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch,\n-        boolean val1Null, boolean val2Null) {\n+    public void appendTo(Select sel, ExpContext ctx, BinaryOpExpState bstate, \n+        SQLBuffer buf, boolean val1Null, boolean val2Null) {\n         if (val1Null && val2Null)\n             buf.appendValue(null).append(\" IS \").appendValue(null);\n         else if (val1Null || val2Null) {\n             Val val = (val1Null) ? getValue2() : getValue1();\n+            ExpState state = (val1Null) ? bstate.state2 : bstate.state1;\n             if (!isDirectComparison()) {\n-                int len = val.length();\n+                int len = val.length(sel, ctx, state);\n                 for (int i = 0; i < len; i++) {\n                     if (i > 0)\n                         buf.append(\" AND \");\n-                    val.appendTo(buf, i, sel, store, params, fetch);\n+                    val.appendTo(sel, ctx, state, buf, i);\n                     buf.append(\" IS \").appendValue(null);\n                 }\n             } else\n-                val.appendIsNull(buf, sel, store, params, fetch);\n+                val.appendIsNull(sel, ctx, state, buf);\n         } else {\n             Val val1 = getValue1();\n             Val val2 = getValue2();\n-            if (val1.length() == 1 && val2.length() == 1) {\n-                store.getDBDictionary().comparison(buf, \"=\",\n-                    new FilterValueImpl(val1, sel, store, params, fetch),\n-                    new FilterValueImpl(val2, sel, store, params, fetch));\n+            if (val1.length(sel, ctx, bstate.state1) == 1 \n+                && val2.length(sel, ctx, bstate.state2) == 1) {\n+                ctx.store.getDBDictionary().comparison(buf, \"=\",\n+                    new FilterValueImpl(sel, ctx, bstate.state1, val1),\n+                    new FilterValueImpl(sel, ctx, bstate.state2, val2));\n             } else {\n-                int len = java.lang.Math.max(val1.length(), val2.length());\n+                int len = java.lang.Math.max(val1.length(sel, ctx, \n+                    bstate.state1), val2.length(sel, ctx, bstate.state2));\n                 for (int i = 0; i < len; i++) {\n                     if (i > 0)\n                         buf.append(\" AND \");\n \n-                    val1.appendTo(buf, i, sel, store, params, fetch);\n+                    val1.appendTo(sel, ctx, bstate.state1, buf, i);\n                     buf.append(\" = \");\n-                    val2.appendTo(buf, i, sel, store, params, fetch);\n+                    val2.appendTo(sel, ctx, bstate.state2, buf, i);\n                 }\n             }\n         }"},{"sha":"9878932520502e7f1d871a0c93e6c8e75ff6be1f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Exp.java","status":"modified","additions":7,"deletions":23,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Exp.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Exp.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Exp.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,9 +17,6 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.Expression;\n@@ -35,38 +32,25 @@\n \n     /**\n      * Initialize the expression. This method should recursively\n-     * initialize any sub-expressions or values. It should also cache\n-     * the {@link Joins} instance containing the joins for this expression.\n+     * initialize any sub-expressions or values.\n      *\n-     * @param params the parameter values; the initialization process\n-     * should not rely on exact values, but may need\n-     * to see if parameter values are null\n      * @param contains map of relation paths to the number of times\n      * the paths appear in a contains() expression;\n      * used to ensure paths used for contains() within\n      * the same AND expression used different aliases\n      */\n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains);\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains);\n \n     /**\n      * Append the SQL for this expression to the given buffer. The SQL\n      * should optionally include any joins this expression needs.\n      */\n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf);\n \n     /**\n-     * Select just the columns for this value.\n+     * Select just the columns for this expression.\n      */\n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch);\n-\n-    /**\n-     * Return the joins for this expression. These joins should be created\n-     * and cached during the {@link #initialize} method. The parent\n-     * expression might modify these joins during its own initialization so\n-     * that common joins are moved up the expression tree.\n-     */\n-    public Joins getJoins();\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks);\n }"},{"sha":"6a68c4bbe0b30d8d276173099a603c7f3ed8680c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Extension.java","status":"modified","additions":68,"deletions":84,"changes":152,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Extension.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Extension.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Extension.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -18,8 +18,6 @@\n import java.sql.SQLException;\n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n import org.apache.openjpa.jdbc.sql.Joins;\n@@ -43,7 +41,6 @@\n     private final Val _target;\n     private final Val _arg;\n     private final ClassMapping _candidate;\n-    private Joins _joins = null;\n     private ClassMetaData _meta = null;\n     private Class _cast = null;\n \n@@ -93,119 +90,108 @@ public void setImplicitType(Class type) {\n         _cast = type;\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n         // note that we tell targets and args to extensions that are sql\n         // paths to go ahead and join to their related object (if any),\n         // because we assume that, unlike most operations, if a relation\n         // field like a 1-1 is given as the target of an extension, then\n         // the extension probably acts on some field or column in the\n         // related object, not the 1-1 field itself\n-        Joins j1 = null;\n-        Joins j2 = null;\n-        if (_target != null) {\n-            _target.initialize(sel, store, false);\n-            if (_target instanceof PCPath)\n-                ((PCPath) _target).joinRelation();\n-            j1 = _target.getJoins();\n-        }\n-        if (_arg != null) {\n-            _arg.initialize(sel, store, false);\n-            if (_arg instanceof PCPath)\n-                ((PCPath) _arg).joinRelation();\n-            j2 = _arg.getJoins();\n-        }\n-        _joins = sel.and(j1, j2);\n+        ExpState targetState = null;\n+        ExpState argState = null;\n+        if (_target != null)\n+            targetState = _target.initialize(sel, ctx, JOIN_REL);\n+        if (_arg != null)\n+            argState = _arg.initialize(sel, ctx, JOIN_REL);\n+        Joins j1 = (targetState == null) ? null : targetState.joins;\n+        Joins j2 = (argState == null) ? null : argState.joins;\n+        return new ExtensionExpState(sel.and(j1, j2), targetState, \n+            argState);\n     }\n \n-    public Joins getJoins() {\n-        return _joins;\n-    }\n+    /**\n+     * Expression state.\n+     */\n+    private static class ExtensionExpState\n+        extends ExpState {\n+\n+        public final ExpState targetState;\n+        public final ExpState argState;\n \n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        return val;\n+        public ExtensionExpState(Joins joins, ExpState targetState,\n+            ExpState argState) {\n+            super(joins);\n+            this.targetState = targetState;\n+            this.argState = argState;\n+        }\n     }\n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n-        sel.select(newSQLBuffer(sel, store, params, fetch), this);\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        sel.select(newSQLBuffer(sel, ctx, state), this);\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        ExtensionExpState estate = (ExtensionExpState) state;\n         if (_target != null)\n-            _target.selectColumns(sel, store, params, true, fetch);\n+            _target.selectColumns(sel, ctx, estate.targetState, true);\n         if (_arg != null)\n-            _arg.selectColumns(sel, store, params, true, fetch);\n+            _arg.selectColumns(sel, ctx, estate.argState, true);\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-        sel.groupBy(newSQLBuffer(sel, store, params, fetch));\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+        sel.groupBy(newSQLBuffer(sel, ctx, state));\n     }\n \n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n-        sel.orderBy(newSQLBuffer(sel, store, params, fetch), asc, false);\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n+        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n     }\n \n-    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        calculateValue(sel, store, params, null, fetch);\n-        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n-        appendTo(buf, 0, sel, store, params, fetch);\n-        clearParameters();\n+    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n+        calculateValue(sel, ctx, state, null, null);\n+        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n+        appendTo(sel, ctx, state, buf, 0);\n         return buf;\n     }\n \n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res) \n         throws SQLException {\n         return Filters.convert(res.getObject(this,\n             JavaSQLTypes.JDBC_DEFAULT, null), getType());\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        ExtensionExpState estate = (ExtensionExpState) state;\n         if (_target != null)\n-            _target.calculateValue(sel, store, params, null, fetch);\n+            _target.calculateValue(sel, ctx, estate.targetState, null, null);\n         if (_arg != null)\n-            _arg.calculateValue(sel, store, params, null, fetch);\n+            _arg.calculateValue(sel, ctx, estate.argState, null, null);\n     }\n \n-    public void clearParameters() {\n-        if (_target != null)\n-            _target.clearParameters();\n-        if (_arg != null)\n-            _arg.clearParameters();\n-    }\n-\n-    public int length() {\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n         return 1;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        ExtensionExpState estate = (ExtensionExpState) state;\n         FilterValue target = (_target == null) ? null\n-            : new FilterValueImpl(_target, sel, store, params, fetch);\n-        _listener.appendTo(sql, target, getArgs(sel, store, params, fetch), \n-            _candidate, store);\n-        sel.append(sql, _joins);\n+            : new FilterValueImpl(sel, ctx, estate.targetState, _target);\n+        _listener.appendTo(sql, target, getArgs(sel, ctx, estate.argState),\n+            _candidate, ctx.store);\n+        sel.append(sql, state.joins);\n     }\n \n-    private FilterValue[] getArgs(Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n+    private FilterValue[] getArgs(Select sel, ExpContext ctx, ExpState state) {\n         if (_arg == null)\n             return null;\n-        if (_arg instanceof Args) {\n-            Val[] vals = ((Args) _arg).getVals();\n-            FilterValue[] filts = new FilterValue[vals.length];\n-            for (int i = 0; i < vals.length; i++)\n-                filts[i] = new FilterValueImpl(vals[i], sel, store, params,\n-                    fetch);\n-            return filts;\n-        }\n-        return new FilterValue[]{\n-            new FilterValueImpl(_arg, sel, store, params, fetch)\n+        if (_arg instanceof Args)\n+            return ((Args) _arg).newFilterValues(sel, ctx, state);\n+        return new FilterValue[] {\n+            new FilterValueImpl(sel, ctx, state, _arg)\n         };\n     }\n \n@@ -222,16 +208,14 @@ public void acceptVisit(ExpressionVisitor visitor) {\n     // Exp implementation\n     //////////////////////\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n-        initialize(sel, store, false);\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n+        return initialize(sel, ctx, 0);\n     }\n \n-    public void appendTo(SQLBuffer sql, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        calculateValue(sel, store, params, null, fetch);\n-        appendTo(sql, 0, sel, store, params, fetch);\n-        sel.append(sql, getJoins());\n-        clearParameters();\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n+        calculateValue(sel, ctx, state, null, null);\n+        appendTo(sel, ctx, state, sql, 0);\n+        sel.append(sql, state.joins);\n     }\n }"},{"sha":"5be580987f4f06449b86531654035737d05fbbc5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java","status":"modified","additions":18,"deletions":21,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,8 +15,6 @@\n  */\n package org.apache.openjpa.jdbc.kernel.exps;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n@@ -32,70 +30,69 @@\n class FilterValueImpl\n     implements FilterValue {\n \n-    private final Val _val;\n     private final Select _sel;\n-    private final JDBCStore _store;\n-    private final Object[] _params;\n-    private final JDBCFetchConfiguration _fetch;\n+    private final ExpContext _ctx;\n+    private final ExpState _state;\n+    private final Val _val;\n \n-    public FilterValueImpl(Val val, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        _val = val;\n+    public FilterValueImpl(Select sel, ExpContext ctx, ExpState state, \n+        Val val) {\n         _sel = sel;\n-        _store = store;\n-        _params = params;\n-        _fetch = fetch;\n+        _ctx = ctx;\n+        _state = state;\n+        _val = val;\n     }\n \n     public Class getType() {\n         return _val.getType();\n     }\n \n     public int length() {\n-        return _val.length();\n+        return _val.length(_sel, _ctx, _state);\n     }\n \n     public void appendTo(SQLBuffer buf) {\n         appendTo(buf, 0);\n     }\n \n     public void appendTo(SQLBuffer buf, int index) {\n-        _val.appendTo(buf, index, _sel, _store, _params, _fetch);\n+        _val.appendTo(_sel, _ctx, _state, buf, index);\n     }\n \n     public String getColumnAlias(Column col) {\n-        return _sel.getColumnAlias(col, _val.getJoins());\n+        return _sel.getColumnAlias(col, _state.joins);\n     }\n \n     public String getColumnAlias(String col, Table table) {\n-        return _sel.getColumnAlias(col, table, _val.getJoins());\n+        return _sel.getColumnAlias(col, table, _state.joins);\n     }\n \n     public Object toDataStoreValue(Object val) {\n-        return _val.toDataStoreValue(val, _store);\n+        return _val.toDataStoreValue(_sel, _ctx, _state, val);\n     }\n \n     public boolean isConstant() {\n         return _val instanceof Const;\n     }\n \n     public Object getValue() {\n-        return (isConstant()) ? ((Const) _val).getValue() : null;\n+        return (isConstant()) ? ((Const) _val).getValue(_ctx.params) : null;\n     }\n \n     public Object getSQLValue() {\n-        return (isConstant()) ? ((Const) _val).getSQLValue() : null;\n+        return (isConstant()) ? ((Const) _val).getSQLValue(_sel, _ctx, _state) \n+            : null;\n     }\n \n     public boolean isPath() {\n         return _val instanceof PCPath;\n     }\n \n     public ClassMapping getClassMapping() {\n-        return (isPath()) ? ((PCPath) _val).getClassMapping() : null;\n+        return (isPath()) ? ((PCPath) _val).getClassMapping(_state) : null;\n     }\n \n     public FieldMapping getFieldMapping() {\n-        return (isPath()) ? ((PCPath) _val).getFieldMapping() : null;\n+        return (isPath()) ? ((PCPath) _val).getFieldMapping(_state) : null;\n     }\n }"},{"sha":"f1571b076cfc3833915475131600c9c642d392ba","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetMapValue.java","status":"modified","additions":66,"deletions":72,"changes":138,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetMapValue.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetMapValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetMapValue.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,8 +17,6 @@\n \n import java.sql.SQLException;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n@@ -27,7 +25,6 @@\n import org.apache.openjpa.jdbc.meta.strats.RelationStrategies;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n@@ -42,9 +39,9 @@\n  */\n class GetMapValue\n     extends AbstractVal {\n+\n     private final Val _map;\n     private final Val _key;\n-    private Joins _joins = null;\n     private ClassMetaData _meta = null;\n     private Class _cast = null;\n \n@@ -71,143 +68,140 @@ public boolean isVariable() {\n     public Class getType() {\n         if (_cast != null)\n             return _cast;\n-\n         return _map.getType();\n     }\n \n     public void setImplicitType(Class type) {\n         _cast = type;\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n-        _map.initialize(sel, store, false);\n-        _key.initialize(sel, store, false);\n-        _joins = sel.and(_map.getJoins(), _key.getJoins());\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        ExpState mapState = _map.initialize(sel, ctx, 0);\n+        ExpState keyState = _key.initialize(sel, ctx, 0);\n+        return new GetMapValueExpState(sel.and(mapState.joins, keyState.joins),\n+            mapState, keyState);\n     }\n \n-    public Joins getJoins() {\n-        return _joins;\n+    /**\n+     * Expression state.\n+     */\n+    private static class GetMapValueExpState\n+        extends ExpState {\n+\n+        public final ExpState mapState;\n+        public final ExpState keyState;\n+\n+        public GetMapValueExpState(Joins joins, ExpState mapState, \n+            ExpState keyState) {\n+            super(joins);\n+            this.mapState = mapState;\n+            this.keyState = keyState;\n+        }\n     }\n \n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        return _map.toDataStoreValue(val, store);\n+    public Object toDataStoreValue(Select sel, ExpContext ctx, ExpState state, \n+        Object val) {\n+        GetMapValueExpState gstate = (GetMapValueExpState) state;\n+        return _map.toDataStoreValue(sel, ctx, gstate.mapState, val);\n     }\n \n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n-        sel.select(newSQLBuffer(sel, store, params, fetch), this);\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        sel.select(newSQLBuffer(sel, ctx, state), this);\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _map.selectColumns(sel, store, params, true, fetch);\n-        _key.selectColumns(sel, store, params, true, fetch);\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state,\n+        boolean pks) {\n+        GetMapValueExpState gstate = (GetMapValueExpState) state;\n+        _map.selectColumns(sel, ctx, gstate.mapState, true);\n+        _key.selectColumns(sel, ctx, gstate.keyState, true);\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-        sel.groupBy(newSQLBuffer(sel, store, params, fetch));\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+        sel.groupBy(newSQLBuffer(sel, ctx, state));\n     }\n \n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n-        sel.orderBy(newSQLBuffer(sel, store, params, fetch), asc, false);\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n+        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n     }\n \n-    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        calculateValue(sel, store, params, null, fetch);\n-        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n-        appendTo(buf, 0, sel, store, params, fetch);\n-        clearParameters();\n+    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n+        calculateValue(sel, ctx, state, null, null);\n+        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n+        appendTo(sel, ctx, state, buf, 0);\n         return buf;\n     }\n \n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res)\n         throws SQLException {\n         return Filters.convert(res.getObject(this,\n             JavaSQLTypes.JDBC_DEFAULT, null), getType());\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        _map.calculateValue(sel, store, params, null, fetch);\n-        _key.calculateValue(sel, store, params, null, fetch);\n-    }\n-\n-    public void clearParameters() {\n-        _map.clearParameters();\n-        _key.clearParameters();\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        GetMapValueExpState gstate = (GetMapValueExpState) state;\n+        _map.calculateValue(sel, ctx, gstate.mapState, null, null);\n+        _key.calculateValue(sel, ctx, gstate.keyState, null, null);\n     }\n \n-    public int length() {\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n         return 1;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n         if (!(_map instanceof PCPath))\n             throw new UnsupportedOperationException();\n-\n         if (!(_key instanceof Const))\n             throw new UnsupportedOperationException();\n \n+        GetMapValueExpState gstate = (GetMapValueExpState) state;\n         PCPath map = (PCPath) _map;\n-        Object key = ((Const) _key).getValue();\n-\n-        FieldMapping field = map.getFieldMapping();\n-\n+        Object key = ((Const) _key).getValue(ctx, gstate.keyState);\n+        FieldMapping field = map.getFieldMapping(gstate.mapState);\n         if (!(field.getStrategy() instanceof LRSMapFieldStrategy))\n             throw new UnsupportedOperationException();\n \n         LRSMapFieldStrategy strat = (LRSMapFieldStrategy) field.getStrategy();\n-\n         ClassMapping[] clss = strat.getIndependentValueMappings(true);\n         if (clss != null && clss.length > 1)\n             throw RelationStrategies.unjoinable(field);\n \n         ClassMapping cls = (clss.length == 0) ? null : clss[0];\n         ForeignKey fk = strat.getJoinForeignKey(cls);\n-        DBDictionary dict = store.getDBDictionary();\n-        SQLBuffer sub = new SQLBuffer(dict);\n \n         // manually create a subselect for the Map's value\n-        sub.append(\"(SELECT \");\n+        sql.append(\"(SELECT \");\n         Column[] values = field.getElementMapping().getColumns();\n         for (int i = 0; i < values.length; i++) {\n             if (i > 0)\n-                sub.append(\", \");\n-            sub.append(values[i].getFullName());\n+                sql.append(\", \");\n+            sql.append(values[i].getFullName());\n         }\n-\n-        sub.append(\" FROM \").append(values[0].getTable().getFullName()).\n+        sql.append(\" FROM \").append(values[0].getTable().getFullName()).\n             append(\" WHERE \");\n \n         // add in the joins\n-        ContainerFieldStrategy.appendUnaliasedJoin(sub, sel, null,\n-            dict, field, fk);\n+        ContainerFieldStrategy.appendUnaliasedJoin(sql, sel, null, \n+            ctx.store.getDBDictionary(), field, fk);\n+        sql.append(\" AND \");\n \n-        sub.append(\" AND \");\n-\n-        key = strat.toKeyDataStoreValue(key, store);\n+        key = strat.toKeyDataStoreValue(key, ctx.store);\n         Column[] cols = strat.getKeyColumns(cls);\n         Object[] vals = (cols.length == 1) ? null : (Object[]) key;\n \n         for (int i = 0; i < cols.length; i++) {\n-            sub.append(cols[i].getFullName());\n-\n+            sql.append(cols[i].getFullName());\n             if (vals == null)\n-                sub.append((key == null) ? \" IS \" : \" = \").\n+                sql.append((key == null) ? \" IS \" : \" = \").\n                     appendValue(key, cols[i]);\n             else\n-                sub.append((vals[i] == null) ? \" IS \" : \" = \").\n+                sql.append((vals[i] == null) ? \" IS \" : \" = \").\n                     appendValue(vals[i], cols[i]);\n         }\n-\n-        sub.append(\")\");\n-\n-        sql.append(sub);\n+        sql.append(\")\");\n     }\n }"},{"sha":"0b2dd02cbcd6da143e691be68a4d47933a01384a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetObjectId.java","status":"modified","additions":35,"deletions":44,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetObjectId.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetObjectId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetObjectId.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,12 +17,9 @@\n \n import java.sql.SQLException;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.Joinable;\n import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n@@ -57,8 +54,11 @@ public GetObjectId(PCPath path) {\n         _path = path;\n     }\n \n-    public Column[] getColumns() {\n-        return _path.getClassMapping().getPrimaryKeyColumns();\n+    /**\n+     * Return the oid columns.\n+     */\n+    public Column[] getColumns(ExpState state) {\n+        return _path.getClassMapping(state).getPrimaryKeyColumns();\n     }\n \n     public ClassMetaData getMetaData() {\n@@ -76,26 +76,23 @@ public Class getType() {\n     public void setImplicitType(Class type) {\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n-        _path.initialize(sel, store, false);\n-        _path.joinRelation();\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        ExpState state = _path.initialize(sel, ctx, JOIN_REL);\n \n         // it's difficult to get calls on non-pc fields to always return null\n         // without screwing up the SQL, to just don't let users call it on\n         // non-pc fields at all\n-        if (_path.getClassMapping() == null\n-            || _path.getClassMapping().getEmbeddingMapping() != null)\n+        ClassMapping cls = _path.getClassMapping(state);\n+        if (cls == null || cls.getEmbeddingMapping() != null)\n             throw new UserException(_loc.get(\"bad-getobjectid\",\n-                _path.getFieldMapping()));\n-    }\n-\n-    public Joins getJoins() {\n-        return _path.getJoins();\n+                _path.getFieldMapping(state)));\n+        return state;\n     }\n \n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n+    public Object toDataStoreValue(Select sel, ExpContext ctx, ExpState state, \n+        Object val) {\n         // if datastore identity, try to convert to a long value\n-        ClassMapping mapping = _path.getClassMapping();\n+        ClassMapping mapping = _path.getClassMapping(state);\n         if (mapping.getIdentityType() == mapping.ID_DATASTORE) {\n             if (val instanceof Id)\n                 return Numbers.valueOf(((Id) val).getId());\n@@ -129,48 +126,42 @@ public Object toDataStoreValue(Object val, JDBCStore store) {\n         return ordered;\n     }\n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n-        selectColumns(sel, store, params, true, fetch);\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        selectColumns(sel, ctx, state, true);\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _path.selectColumns(sel, store, params, true, fetch);\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        _path.selectColumns(sel, ctx, state, true);\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-        _path.groupBy(sel, store, params, fetch);\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+        _path.groupBy(sel, ctx, state);\n     }\n \n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n-        _path.orderBy(sel, store, params, asc, fetch);\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n+        _path.orderBy(sel, ctx, state, asc);\n     }\n \n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res)\n         throws SQLException {\n-        return _path.load(res, store, true, fetch);\n-    }\n-\n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        _path.calculateValue(sel, store, params, null, fetch);\n+        return _path.load(ctx, state, res, true);\n     }\n \n-    public void clearParameters() {\n-        _path.clearParameters();\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        _path.calculateValue(sel, ctx, state, null, null);\n     }\n \n-    public int length() {\n-        return _path.length();\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n+        return _path.length(sel, ctx, state);\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        _path.appendTo(sql, index, sel, store, params, fetch);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        _path.appendTo(sel, ctx, state, sql, index);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"e63493e093fe31234a2e6e5c46f8e827d4d77e08","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InExpression.java","status":"modified","additions":55,"deletions":40,"changes":95,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -20,8 +20,6 @@\n import java.util.Iterator;\n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n@@ -48,58 +46,79 @@ public InExpression(Val val, Const constant) {\n         _const = constant;\n     }\n \n-    public Const getConst() {\n+    /**\n+     * Constant collection.\n+     */\n+    public Const getConstant() {\n         return _const;\n     }\n \n+    /**\n+     * Contained value.\n+     */\n     public Val getValue() {\n         return _val;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n-        _val.initialize(sel, store, false);\n-        _const.initialize(sel, store, false);\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n+        ExpState valueState = _val.initialize(sel, ctx, 0);\n+        ExpState constantState = _const.initialize(sel, ctx, 0);\n+        return new InExpState(valueState.joins, constantState, valueState);\n+    }\n+\n+    /**\n+     * Expression state.\n+     */\n+    private static class InExpState\n+        extends ExpState {\n+\n+        public final ExpState constantState;\n+        public final ExpState valueState;\n+\n+        public InExpState(Joins joins, ExpState constantState, \n+            ExpState valueState) {\n+            super(joins);\n+            this.constantState = constantState;\n+            this.valueState = valueState;\n+        }\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        _val.calculateValue(sel, store, params, null, fetch);\n-        _const.calculateValue(sel, store, params, null, fetch);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n+        InExpState istate = (InExpState) state; \n+        _const.calculateValue(sel, ctx, istate.constantState, null, null);\n+        _val.calculateValue(sel, ctx, istate.valueState, null, null);\n \n-        Collection coll = getCollection();\n+        Collection coll = getCollection(ctx, istate.constantState);\n         if (coll != null) {\n             Collection ds = new ArrayList(coll.size());\n             for (Iterator itr = coll.iterator(); itr.hasNext();)\n-                ds.add(_val.toDataStoreValue(itr.next(), store));\n+                ds.add(_val.toDataStoreValue(sel, ctx, istate.valueState, \n+                    itr.next()));\n             coll = ds;\n         }\n \n         Column[] cols = null;\n         if (_val instanceof PCPath)\n-            cols = ((PCPath) _val).getColumns();\n+            cols = ((PCPath) _val).getColumns(istate.valueState);\n         else if (_val instanceof GetObjectId)\n-            cols = ((GetObjectId) _val).getColumns();\n+            cols = ((GetObjectId) _val).getColumns(istate.valueState);\n \n         if (coll == null || coll.isEmpty())\n             buf.append(\"1 <> 1\");\n-        else if (_val.length() == 1)\n-            inContains(buf, sel, store, params, fetch, coll, cols);\n+        else if (_val.length(sel, ctx, istate.valueState) == 1)\n+            inContains(sel, ctx, istate.valueState, buf, coll, cols);\n         else\n-            orContains(buf, sel, store, params, fetch, coll, cols);\n-        sel.append(buf, _val.getJoins());\n-\n-        _val.clearParameters();\n-        _const.clearParameters();\n+            orContains(sel, ctx, istate.valueState, buf, coll, cols);\n+        sel.append(buf, state.joins);\n     }\n \n     /**\n      * Construct an IN clause with the value of the given collection.\n      */\n-    private void inContains(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch,\n-        Collection coll, Column[] cols) {\n-        _val.appendTo(buf, 0, sel, store, params, fetch);\n+    private void inContains(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf, Collection coll, Column[] cols) {\n+        _val.appendTo(sel, ctx, state, buf, 0);\n         buf.append(\" IN (\");\n \n         Column col = (cols != null && cols.length == 1) ? cols[0] : null;\n@@ -115,9 +134,8 @@ private void inContains(SQLBuffer buf, Select sel, JDBCStore store,\n      * If the value to test is a compound key, we can't use IN,\n      * so create a clause like '(a = b AND c = d) OR (e = f AND g = h) ...'\n      */\n-    private void orContains(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch, Collection coll,\n-        Column[] cols) {\n+    private void orContains(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf, Collection coll, Column[] cols) {\n         if (coll.size() > 1)\n             buf.append(\"(\");\n \n@@ -133,7 +151,7 @@ private void orContains(SQLBuffer buf, Select sel, JDBCStore store,\n                 if (i > 0)\n                     buf.append(\" AND \");\n \n-                _val.appendTo(buf, i, sel, store, params, fetch);\n+                _val.appendTo(sel, ctx, state, buf, i);\n                 if (vals[i] == null)\n                     buf.append(\" IS \");\n                 else\n@@ -149,21 +167,18 @@ private void orContains(SQLBuffer buf, Select sel, JDBCStore store,\n             buf.append(\")\");\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val.selectColumns(sel, store, params, true, fetch);\n-        _const.selectColumns(sel, store, params, pks, fetch);\n-    }\n-\n-    public Joins getJoins() {\n-        return _val.getJoins();\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        InExpState istate = (InExpState) state; \n+        _const.selectColumns(sel, ctx, istate.constantState, true);\n+        _val.selectColumns(sel, ctx, istate.valueState, true);\n     }\n \n     /**\n      * Return the collection to test for containment with.\n      */\n-    protected Collection getCollection() {\n-        return (Collection) _const.getValue();\n+    protected Collection getCollection(ExpContext ctx, ExpState state) {\n+        return (Collection) _const.getValue(ctx, state);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"44d2eddc7579b19078d1a75da3ff2b230cd2c8ea","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InKeyExpression.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InKeyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InKeyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InKeyExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -37,8 +37,8 @@ public InKeyExpression(Val val, Const constant) {\n     /**\n      * Return the collection to test for containment with.\n      */\n-    protected Collection getCollection() {\n-        Map map = (Map) getConst().getValue();\n+    protected Collection getCollection(ExpContext ctx, ExpState state) {\n+        Map map = (Map) getConstant().getValue(ctx, state);\n         return (map == null) ? null : map.keySet();\n     }\n }"},{"sha":"d912d5ad8db1a73185607f92028f15771a47614c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InSubQExpression.java","status":"modified","additions":32,"deletions":21,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InSubQExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InSubQExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InSubQExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,8 +17,6 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n@@ -43,31 +41,44 @@ public InSubQExpression(Val val, SubQ sub) {\n         _sub = sub;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n-        _val.initialize(sel, store, false);\n-        _sub.initialize(sel, store, false);\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n+        ExpState subqState = _sub.initialize(sel, ctx, 0);\n+        ExpState valueState = _val.initialize(sel, ctx, 0);\n+        return new InSubQExpState(valueState.joins, subqState, valueState);\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        _val.calculateValue(sel, store, params, null, fetch);\n-        _sub.calculateValue(sel, store, params, null, fetch);\n-        _val.appendTo(buf, 0, sel, store, params, fetch);\n-        buf.append(\" IN \");\n-        _sub.appendTo(buf, 0, sel, store, params, fetch);\n-        _val.clearParameters();\n-        _sub.clearParameters();\n+    /**\n+     * Expression state.\n+     */\n+    private static class InSubQExpState\n+        extends ExpState {\n+\n+        public final ExpState subqState;\n+        public final ExpState valueState;\n+\n+        public InSubQExpState(Joins joins, ExpState subqState, \n+            ExpState valueState) {\n+            super(joins);\n+            this.subqState = subqState;\n+            this.valueState = valueState;\n+        }\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val.selectColumns(sel, store, params, true, fetch);\n-        _sub.selectColumns(sel, store, params, pks, fetch);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n+        InSubQExpState istate = (InSubQExpState) state;\n+        _sub.calculateValue(sel, ctx, istate.subqState, null, null);\n+        _val.calculateValue(sel, ctx, istate.valueState, null, null);\n+        _val.appendTo(sel, ctx, istate.valueState, buf, 0);\n+        buf.append(\" IN \");\n+        _sub.appendTo(sel, ctx, istate.valueState, buf, 0);\n     }\n \n-    public Joins getJoins() {\n-        return _val.getJoins();\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        InSubQExpState istate = (InSubQExpState) state;\n+        _sub.selectColumns(sel, ctx, istate.subqState, pks);\n+        _val.selectColumns(sel, ctx, istate.valueState, true);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"cbb7f117dccb63a03bc821bbb445be4791c8d9c3","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InValueExpression.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InValueExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InValueExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InValueExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -37,8 +37,8 @@ public InValueExpression(Val val, Const constant) {\n     /**\n      * Return the collection to test for containment with.\n      */\n-    protected Collection getCollection() {\n-        Map map = (Map) getConst().getValue();\n+    protected Collection getCollection(ExpContext ctx, ExpState state) {\n+        Map map = (Map) getConstant().getValue(ctx, state);\n         return (map == null) ? null : map.values();\n     }\n }"},{"sha":"56cf879ae1320cfbaf6b30630c08fa2835f82b00","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IndexOf.java","status":"modified","additions":40,"deletions":63,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IndexOf.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IndexOf.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IndexOf.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,10 +17,7 @@\n \n import java.sql.SQLException;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n@@ -38,7 +35,6 @@\n \n     private final Val _val1;\n     private final Val _val2;\n-    private Joins _joins = null;\n     private ClassMetaData _meta = null;\n     private Class _cast = null;\n \n@@ -58,10 +54,6 @@ public void setMetaData(ClassMetaData meta) {\n         _meta = meta;\n     }\n \n-    public boolean isVariable() {\n-        return false;\n-    }\n-\n     public Class getType() {\n         if (_cast != null)\n             return _cast;\n@@ -72,87 +64,72 @@ public void setImplicitType(Class type) {\n         _cast = type;\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n-        _val1.initialize(sel, store, false);\n-        _val2.initialize(sel, store, false);\n-        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n-    }\n-\n-    public Joins getJoins() {\n-        return _joins;\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        ExpState s1 = _val1.initialize(sel, ctx, 0);\n+        ExpState s2 = _val2.initialize(sel, ctx, 0);\n+        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n     }\n \n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        return val;\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        sel.select(newSQLBuffer(sel, ctx, state), this);\n     }\n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n-        sel.select(newSQLBuffer(sel, store, params, fetch), this);\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.selectColumns(sel, ctx, bstate.state1, true);\n+        _val2.selectColumns(sel, ctx, bstate.state2, true);\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val1.selectColumns(sel, store, params, true, fetch);\n-        _val2.selectColumns(sel, store, params, true, fetch);\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+        sel.groupBy(newSQLBuffer(sel, ctx, state));\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-        sel.groupBy(newSQLBuffer(sel, store, params, fetch));\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n+        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n     }\n \n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n-        sel.orderBy(newSQLBuffer(sel, store, params, fetch), asc, false);\n-    }\n-\n-    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        calculateValue(sel, store, params, null, fetch);\n-        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n-        appendTo(buf, 0, sel, store, params, fetch);\n-        clearParameters();\n+    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n+        calculateValue(sel, ctx, state, null, null);\n+        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n+        appendTo(sel, ctx, state, buf, 0);\n         return buf;\n     }\n \n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res) \n         throws SQLException {\n-        return Filters.convert(res.getObject(this,\n-            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n-    }\n-\n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        _val1.calculateValue(sel, store, params, null, fetch);\n-        _val2.calculateValue(sel, store, params, null, fetch);\n+        return Filters.convert(res.getObject(this, JavaSQLTypes.JDBC_DEFAULT, \n+            null), getType());\n     }\n \n-    public void clearParameters() {\n-        _val1.clearParameters();\n-        _val2.clearParameters();\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.calculateValue(sel, ctx, bstate.state1, null, null);\n+        _val2.calculateValue(sel, ctx, bstate.state2, null, null);\n     }\n \n-    public int length() {\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n         return 1;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        FilterValue str = new FilterValueImpl(_val1, sel, store, params, fetch);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        FilterValue str = new FilterValueImpl(sel, ctx, bstate.state1, _val1);\n         FilterValue search;\n         FilterValue start = null;\n         if (_val2 instanceof Args) {\n-            Val[] args = ((Args) _val2).getVals();\n-            search =\n-                new FilterValueImpl(args[0], sel, store, params, fetch);\n-            start =\n-                new FilterValueImpl(args[1], sel, store, params, fetch);\n+            FilterValue[] filts = ((Args) _val2).newFilterValues(sel, ctx, \n+                bstate.state2);\n+            search = filts[0];\n+            start = filts[1];\n         } else\n-            search = new FilterValueImpl(_val2, sel, store, params, fetch);\n+            search = new FilterValueImpl(sel, ctx, bstate.state2, _val2);\n \n-        store.getDBDictionary().indexOf(sql, str, search, start);\n+        ctx.store.getDBDictionary().indexOf(sql, str, search, start);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"073baf15ed9c34e500dc123d2d878fd7c13f1886","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InstanceofExpression.java","status":"modified","additions":61,"deletions":46,"changes":107,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InstanceofExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InstanceofExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InstanceofExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,8 +17,6 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.Discriminator;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n@@ -39,10 +37,6 @@\n \n     private final PCPath _path;\n     private final Class _cls;\n-    private Joins _joins = null;\n-    private Discriminator _dsc = null;\n-    private Class _relCls = null;\n-    private ClassMapping _mapping = null;\n \n     /**\n      * Constructor. Supply path and class to test for.\n@@ -52,96 +46,117 @@ public InstanceofExpression(PCPath path, Class cls) {\n         _cls = cls;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n         // note that we tell the path to go ahead and join to its related\n         // object (if any) in order to access its class indicator\n-        _path.initialize(sel, store, false);\n-        _path.joinRelation();\n-        _joins = _path.getJoins();\n+        ExpState pathState = _path.initialize(sel, ctx, Val.JOIN_REL);\n \n         // does this path represent a relation?  if not, what class\n         // is the field?\n-        ClassMapping rel = _path.getClassMapping();\n-        if (rel == null) {\n-            FieldMapping field = _path.getFieldMapping();\n+        ClassMapping relMapping = _path.getClassMapping(pathState);\n+        Class rel = null;\n+        if (relMapping == null) {\n+            FieldMapping field = _path.getFieldMapping(pathState);\n             switch (field.getTypeCode()) {\n                 case JavaTypes.MAP:\n                     if (_path.isKey())\n-                        _relCls = field.getKey().getDeclaredType();\n+                        rel = field.getKey().getDeclaredType();\n                     // no break\n                 case JavaTypes.ARRAY:\n                 case JavaTypes.COLLECTION:\n-                    _relCls = field.getElement().getDeclaredType();\n+                    rel = field.getElement().getDeclaredType();\n                     break;\n                 default:\n-                    _relCls = field.getDeclaredType();\n+                    rel = field.getDeclaredType();\n             }\n         } else\n-            _relCls = rel.getDescribedType();\n+            rel = relMapping.getDescribedType();\n \n         // if the path represents a relation, get its class indicator and\n         // make sure it's joined down to its base type\n-        _dsc = (rel == null || !rel.getDescribedType().isAssignableFrom(_cls))\n-            ? null : rel.getDiscriminator();\n-        if (_dsc != null) {\n+        Discriminator discrim = (relMapping == null \n+            || !relMapping.getDescribedType().isAssignableFrom(_cls)) \n+            ? null : relMapping.getDiscriminator();\n+        ClassMapping mapping = null;\n+        Joins joins = pathState.joins;\n+        if (discrim != null) {\n             // cache mapping for cast\n-            MappingRepository repos = store.getConfiguration().\n+            MappingRepository repos = ctx.store.getConfiguration().\n                 getMappingRepositoryInstance();\n-            _mapping = repos.getMapping(_cls, store.getContext().\n+            mapping = repos.getMapping(_cls, ctx.store.getContext().\n                 getClassLoader(), false);\n \n             // if not looking for a PC, don't bother with indicator\n-            if (_mapping == null)\n-                _dsc = null;\n+            if (mapping == null)\n+                discrim = null;\n             else {\n-                ClassMapping owner = _dsc.getClassMapping();\n+                ClassMapping owner = discrim.getClassMapping();\n                 ClassMapping from, to;\n-                if (rel.getDescribedType().isAssignableFrom\n+                if (relMapping.getDescribedType().isAssignableFrom\n                     (owner.getDescribedType())) {\n                     from = owner;\n-                    to = rel;\n+                    to = relMapping;\n                 } else {\n-                    from = rel;\n+                    from = relMapping;\n                     to = owner;\n                 }\n \n                 for (; from != null && from != to;\n                     from = from.getJoinablePCSuperclassMapping())\n-                    _joins = from.joinSuperclass(_joins, false);\n+                    joins = from.joinSuperclass(joins, false);\n             }\n         }\n+        return new InstanceofExpState(joins, pathState, mapping, discrim, rel);\n     }\n \n-    public void appendTo(SQLBuffer sql, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n+    /**\n+     * Expression state.\n+     */\n+    private static class InstanceofExpState\n+        extends ExpState {\n+\n+        public final ExpState pathState;\n+        public final ClassMapping mapping;\n+        public final Discriminator discrim;\n+        public final Class rel;\n+\n+        public InstanceofExpState(Joins joins, ExpState pathState, \n+            ClassMapping mapping, Discriminator discrim, Class rel) {\n+            super(joins);\n+            this.pathState = pathState;\n+            this.mapping = mapping;\n+            this.discrim = discrim;\n+            this.rel = rel;\n+        }\n+    }\n+\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n         // if no class indicator or a final class, just append true or false\n         // depending on whether the cast matches the expected type\n-        if (_dsc == null) {\n-            if (_cls.isAssignableFrom(_relCls))\n+        InstanceofExpState istate = (InstanceofExpState) state;\n+        if (istate.discrim == null) {\n+            if (_cls.isAssignableFrom(istate.rel))\n                 sql.append(\"1 = 1\");\n             else\n                 sql.append(\"1 <> 1\");\n         } else {\n-            store.loadSubclasses(_dsc.getClassMapping());\n-            SQLBuffer buf = _dsc.getClassConditions(sel, _joins, _mapping, \n-                true);\n+            ctx.store.loadSubclasses(istate.discrim.getClassMapping());\n+            SQLBuffer buf = istate.discrim.getClassConditions(sel,\n+                istate.joins, istate.mapping, true);\n             if (buf == null)\n                 sql.append(\"1 = 1\");\n             else\n                 sql.append(buf);\n         }\n-        sel.append(sql, _joins);\n-    }\n-\n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        if (_dsc != null)\n-            sel.select(_dsc.getColumns(), _joins);\n+        sel.append(sql, istate.joins);\n     }\n \n-    public Joins getJoins() {\n-        return _joins;\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        InstanceofExpState istate = (InstanceofExpState) state;\n+        if (istate.discrim != null)\n+            sel.select(istate.discrim.getColumns(), istate.joins);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"3a047258ec940118229c6ae8979d829a1a2aba10","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsEmptyExpression.java","status":"modified","additions":10,"deletions":19,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsEmptyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsEmptyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsEmptyExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,9 +17,6 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n@@ -41,28 +38,22 @@ public IsEmptyExpression(Val val) {\n         _val = val;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n-        _val.initialize(sel, store, true);\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n+        return _val.initialize(sel, ctx, Val.NULL_CMP);\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        _val.calculateValue(sel, store, params, null, fetch);\n-        _val.appendIsEmpty(buf, sel, store, params, fetch);\n-        sel.append(buf, _val.getJoins());\n-        _val.clearParameters();\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n+        _val.calculateValue(sel, ctx, state, null, null);\n+        _val.appendIsEmpty(sel, ctx, state, buf);\n+        sel.append(buf, state.joins);\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val.selectColumns(sel, store, params, true, fetch);\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        _val.selectColumns(sel, ctx, state, true);\n     }\n \n-    public Joins getJoins() {\n-        return _val.getJoins();\n-    }\n-    \n     public void acceptVisit(ExpressionVisitor visitor) {\n         visitor.enter(this);\n         _val.acceptVisit(visitor);"},{"sha":"ff9fb49429c34107476dde37de728ed922bb3ad4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsNotEmptyExpression.java","status":"modified","additions":10,"deletions":19,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsNotEmptyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsNotEmptyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsNotEmptyExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,9 +17,6 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n@@ -41,26 +38,20 @@ public IsNotEmptyExpression(Val val) {\n         _val = val;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n-        _val.initialize(sel, store, true);\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n+        return _val.initialize(sel, ctx, Val.NULL_CMP);\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        _val.calculateValue(sel, store, params, null, fetch);\n-        _val.appendIsNotEmpty(buf, sel, store, params, fetch);\n-        sel.append(buf, _val.getJoins());\n-        _val.clearParameters();\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n+        _val.calculateValue(sel, ctx, state, null, null);\n+        _val.appendIsNotEmpty(sel, ctx, state, buf);\n+        sel.append(buf, state.joins);\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val.selectColumns(sel, store, params, true, fetch);\n-    }\n-\n-    public Joins getJoins() {\n-        return _val.getJoins();\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        _val.selectColumns(sel, ctx, state, true);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"68515d2aca52283060432b15f412d3068e986f3b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","status":"modified","additions":7,"deletions":55,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -19,6 +19,7 @@\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStoreQuery;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.AggregateListener;\n@@ -34,7 +35,6 @@\n import org.apache.openjpa.kernel.exps.Value;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.util.ImplHelper;\n import org.apache.openjpa.util.UserException;\n \n /**\n@@ -48,12 +48,10 @@\n     implements ExpressionFactory {\n \n     private static final Val NULL = new Null();\n-    private static final Val CURRENT_DATE =\n-        new CurrentDate(CurrentDate.DATE);\n-    private static final Val CURRENT_TIME =\n-        new CurrentDate(CurrentDate.TIME);\n+    private static final Val CURRENT_DATE = new CurrentDate(JavaSQLTypes.DATE);\n+    private static final Val CURRENT_TIME = new CurrentDate(JavaSQLTypes.TIME);\n     private static final Val CURRENT_TIMESTAMP =\n-        new CurrentDate(CurrentDate.TIMESTAMP);\n+        new CurrentDate(JavaSQLTypes.TIMESTAMP);\n \n     private static final Localizer _loc = Localizer.forPackage\n         (JDBCExpressionFactory.class);\n@@ -69,56 +67,10 @@ public JDBCExpressionFactory(ClassMapping type) {\n     }\n \n     /**\n-     * Evaluate the expression, returning a SQL select with the proper\n-     * conditions. Use {@link #select} to then select the data.\n-     * This method returns null if there is no query criteria. It is\n-     * synchronized because factories may be cached and used by multiple\n-     * queries at the same time.\n+     * Use to create SQL select.\n      */\n-    public synchronized Select evaluate(JDBCStoreQuery q,\n-        JDBCFetchConfiguration fetch, QueryExpressions exps, Object[] params) {\n-        // figure out proper cache level based on parameters\n-        int level = getCacheLevel(q, params);\n-        return _cons.evaluate(q.getStore(), null, null, exps, params,\n-            level, fetch);\n-    }\n-\n-    /**\n-     * Return the cache level for this query. The level depends on whether\n-     * the query uses any params, as well as the types and values of those\n-     * params.\n-     */\n-    private int getCacheLevel(JDBCStoreQuery q, Object[] params) {\n-        // if there are no parameters, we can cache the full SQL\n-        if (params.length == 0)\n-            return SelectConstructor.CACHE_FULL;\n-\n-        // if there is a null PC parameter, we have to cache differently\n-        // since it affects joins\n-        LinkedMap types = null;\n-        Class type;\n-        for (int i = 0; i < params.length; i++) {\n-            if (params[i] != null)\n-                continue;\n-\n-            if (types == null)\n-                types = q.getContext().getParameterTypes();\n-\n-            type = (Class) types.getValue(i);\n-            if (type != null && ImplHelper.isManagedType(type))\n-                return SelectConstructor.CACHE_NULL;\n-        }\n-        return SelectConstructor.CACHE_JOINS;\n-    }\n-\n-    /**\n-     * Select the data for this query.\n-     */\n-    public void select(JDBCStoreQuery q, ClassMapping mapping,\n-        boolean subclasses, Select sel, QueryExpressions exps,\n-        Object[] params, JDBCFetchConfiguration fetch, int eager) {\n-        _cons.select(q.getStore(), mapping, subclasses, sel, exps,\n-            params, fetch, eager);\n+    public SelectConstructor getSelectConstructor() {\n+        return _cons;\n     }\n \n     public Expression emptyExpression() {"},{"sha":"71d05965f66e116deb9466c34d572210a2ec70ed","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java","status":"modified","additions":33,"deletions":19,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,8 +15,6 @@\n  */\n package org.apache.openjpa.jdbc.kernel.exps;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.Filters;\n@@ -33,8 +31,6 @@\n \n     private Object _val;\n     private int _ptype;\n-    private Object _sqlVal = null;\n-    private int _otherLen = 0;\n \n     /**\n      * Constructor. Supply literal value.\n@@ -56,32 +52,50 @@ public int getParseType() {\n         return _ptype;\n     }\n \n-    public Object getValue() {\n+    public Object getValue() { \n         return _val;\n     }\n \n     public void setValue(Object val) {\n         _val = val;\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        super.calculateValue(sel, store, params, other, fetch);\n+    public Object getValue(Object[] params) {\n+        return getValue();\n+    }\n+\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        return new LitExpState();\n+    }\n+\n+    /**\n+     * Expression state.\n+     */\n+    private static class LitExpState\n+        extends ConstExpState {\n+\n+        public Object sqlValue;\n+        public int otherLength; \n+    } \n+\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        super.calculateValue(sel, ctx, state, other, otherState);\n+        LitExpState lstate = (LitExpState) state;\n         if (other != null) {\n-            _sqlVal = other.toDataStoreValue(_val, store);\n-            _otherLen = other.length();\n+            lstate.sqlValue = other.toDataStoreValue(sel, ctx, otherState,_val);\n+            lstate.otherLength = other.length(sel, ctx, otherState);\n         } else\n-            _sqlVal = _val;\n+            lstate.sqlValue = _val;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        if (_otherLen > 1)\n-            sql.appendValue(((Object[]) _sqlVal)[index], getColumn(index));\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        LitExpState lstate = (LitExpState) state;\n+        if (lstate.otherLength > 1)\n+            sql.appendValue(((Object[]) lstate.sqlValue)[index], \n+                lstate.getColumn(index));\n         else\n-            sql.appendValue(_sqlVal, getColumn(index));\n-    }\n-\n-    public void clearParameters() {\n+            sql.appendValue(lstate.sqlValue, lstate.getColumn(index));\n     }\n }"},{"sha":"8a4322ec81c51b6f6cd4e5acab6d86547554745d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MatchesExpression.java","status":"modified","additions":18,"deletions":29,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MatchesExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MatchesExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MatchesExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,10 +17,7 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n@@ -39,7 +36,6 @@\n     private final String _single;\n     private final String _multi;\n     private final String _escape;\n-    private Joins _joins = null;\n \n     /**\n      * Constructor. Supply values.\n@@ -53,26 +49,26 @@ public MatchesExpression(Val val, Const con,\n         _escape = escape;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n-        _val.initialize(sel, store, false);\n-        _const.initialize(sel, store, false);\n-        _joins = sel.and(_val.getJoins(), _const.getJoins());\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n+        ExpState s1 = _val.initialize(sel, ctx, 0);\n+        ExpState s2 = _const.initialize(sel, ctx, 0);\n+        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        _val.calculateValue(sel, store, params, _const, fetch);\n-        _const.calculateValue(sel, store, params, _val, fetch);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val.calculateValue(sel, ctx, bstate.state1, _const, bstate.state2);\n+        _const.calculateValue(sel, ctx, bstate.state2, _val, bstate.state1);\n \n         Column col = null;\n         if (_val instanceof PCPath) {\n-            Column[] cols = ((PCPath) _val).getColumns();\n+            Column[] cols = ((PCPath) _val).getColumns(bstate.state1);\n             if (cols.length == 1)\n                 col = cols[0];\n         }\n \n-        Object o = _const.getValue();\n+        Object o = _const.getValue(ctx, bstate.state2);\n         if (o == null)\n             buf.append(\"1 <> 1\");\n         else {\n@@ -92,7 +88,7 @@ public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n             // append target\n             if (ignoreCase)\n                 buf.append(\"LOWER(\");\n-            _val.appendTo(buf, 0, sel, store, params, fetch);\n+            _val.appendTo(sel, ctx, bstate.state1, buf, 0);\n             if (ignoreCase)\n                 buf.append(\")\");\n \n@@ -101,27 +97,20 @@ public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n             // with '%' and '.' with '_'\n             str = Strings.replace(str, _multi, \"%\");\n             str = Strings.replace(str, _single, \"_\");\n-\n             buf.append(\" LIKE \").appendValue(str, col);\n \n             // escape out characters by using the database's escape sequence\n             if (_escape != null)\n                 buf.append(\" ESCAPE '\").append(_escape).append(\"'\");\n         }\n-        sel.append(buf, _joins);\n-\n-        _val.clearParameters();\n-        _const.clearParameters();\n-    }\n-\n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val.selectColumns(sel, store, params, true, fetch);\n-        _const.selectColumns(sel, store, params, true, fetch);\n+        sel.append(buf, state.joins);\n     }\n \n-    public Joins getJoins() {\n-        return _joins;\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val.selectColumns(sel, ctx, bstate.state1, true);\n+        _const.selectColumns(sel, ctx, bstate.state2, true);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"e1fab303667783610dc8bc99f381b229bbf8cac8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java","status":"modified","additions":36,"deletions":59,"changes":95,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,10 +17,7 @@\n \n import java.sql.SQLException;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n@@ -45,7 +42,6 @@\n     private final Val _val1;\n     private final Val _val2;\n     private final String _op;\n-    private Joins _joins = null;\n     private ClassMetaData _meta = null;\n     private Class _cast = null;\n \n@@ -66,10 +62,6 @@ public void setMetaData(ClassMetaData meta) {\n         _meta = meta;\n     }\n \n-    public boolean isVariable() {\n-        return false;\n-    }\n-\n     public Class getType() {\n         if (_cast != null)\n             return _cast;\n@@ -82,78 +74,63 @@ public void setImplicitType(Class type) {\n         _cast = type;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        boolean nullTest) {\n-        _val1.initialize(sel, store, false);\n-        _val2.initialize(sel, store, false);\n-        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n-    }\n-\n-    public Joins getJoins() {\n-        return _joins;\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        ExpState s1 = _val1.initialize(sel, ctx, 0);\n+        ExpState s2 = _val2.initialize(sel, ctx, 0);\n+        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n     }\n \n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        return val;\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        sel.select(newSQLBuffer(sel, ctx, state), this);\n     }\n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n-        sel.select(newSQLBuffer(sel, store, params, fetch), this);\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.selectColumns(sel, ctx, bstate.state1, true);\n+        _val2.selectColumns(sel, ctx, bstate.state2, true);\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val1.selectColumns(sel, store, params, true, fetch);\n-        _val2.selectColumns(sel, store, params, true, fetch);\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+        sel.groupBy(newSQLBuffer(sel, ctx, state));\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-        sel.groupBy(newSQLBuffer(sel, store, params, fetch));\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n+        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n     }\n \n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n-        sel.orderBy(newSQLBuffer(sel, store, params, fetch), asc, false);\n-    }\n-\n-    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        calculateValue(sel, store, params, null, fetch);\n-        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n-        appendTo(buf, 0, sel, store, params, fetch);\n-        clearParameters();\n+    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n+        calculateValue(sel, ctx, state, null, null);\n+        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n+        appendTo(sel, ctx, state, buf, 0);\n         return buf;\n     }\n \n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res)\n         throws SQLException {\n-        return Filters.convert(res.getObject(this,\n-            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n-    }\n-\n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        _val1.calculateValue(sel, store, params, _val2, fetch);\n-        _val2.calculateValue(sel, store, params, _val1, fetch);\n+        return Filters.convert(res.getObject(this, JavaSQLTypes.JDBC_DEFAULT, \n+            null), getType());\n     }\n \n-    public void clearParameters() {\n-        _val1.clearParameters();\n-        _val2.clearParameters();\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.calculateValue(sel, ctx, bstate.state1, _val2, bstate.state2);\n+        _val2.calculateValue(sel, ctx, bstate.state2, _val1, bstate.state1);\n     }\n \n-    public int length() {\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n         return 1;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        store.getDBDictionary().mathFunction(sql, _op,\n-            new FilterValueImpl(_val1, sel, store, params, fetch),\n-            new FilterValueImpl(_val2, sel, store, params, fetch));\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        ctx.store.getDBDictionary().mathFunction(sql, _op,\n+            new FilterValueImpl(sel, ctx, bstate.state1, _val1),\n+            new FilterValueImpl(sel, ctx, bstate.state2, _val2));\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"8380d3cb127943e48f4f23eb3e9e911752d35506","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java","status":"modified","additions":29,"deletions":22,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,10 +17,7 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n@@ -35,7 +32,6 @@\n     implements Exp {\n \n     private final Exp _exp;\n-    private Map _contains = null;\n \n     /**\n      * Constructor. Supply the expression to negate.\n@@ -44,37 +40,48 @@ public NotContainsExpression(Exp exp) {\n         _exp = exp;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n-        _contains = contains;\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n+        return new NotContainsExpState(contains);\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        DBDictionary dict = store.getDBDictionary();\n+    /**\n+     * Expression state.\n+     */\n+    private static class NotContainsExpState\n+        extends ExpState {\n+        \n+        public final Map contains;\n+\n+        public NotContainsExpState(Map contains) {\n+            this.contains = contains;\n+        }\n+    }\n+\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n+        DBDictionary dict = ctx.store.getDBDictionary();\n         dict.assertSupport(dict.supportsSubselect, \"SupportsSubselect\");\n \n-        Select sub = store.getSQLFactory().newSelect();\n+        Select sub = ctx.store.getSQLFactory().newSelect();\n         sub.setParent(sel, null);\n-        _exp.initialize(sub, store, params, _contains);\n-        sub.where(sub.and(null, _exp.getJoins()));\n+        ExpState estate = _exp.initialize(sub, ctx, ((NotContainsExpState) \n+            state).contains);\n+        sub.where(sub.and(null, estate.joins));\n \n         SQLBuffer where = new SQLBuffer(dict).append(\"(\");\n-        _exp.appendTo(where, sub, store, params, fetch);\n+        _exp.appendTo(sub, ctx, estate, where);\n         if (where.getSQL().length() > 1)\n             sub.where(where.append(\")\"));\n \n         buf.append(\"0 = \");\n-        buf.appendCount(sub, fetch);\n-    }\n-\n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _exp.selectColumns(sel, store, params, true, fetch);\n+        buf.appendCount(sub, ctx.fetch);\n     }\n \n-    public Joins getJoins() {\n-        return null;\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        ExpState estate = _exp.initialize(sel, ctx, ((NotContainsExpState) \n+            state).contains);\n+        _exp.selectColumns(sel, ctx, estate, true);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"3cbab01546a2b21f89227e84d7df3d17f3a976e8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotEqualExpression.java","status":"modified","additions":15,"deletions":15,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotEqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotEqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotEqualExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,8 +15,6 @@\n  */\n package org.apache.openjpa.jdbc.kernel.exps;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n \n@@ -35,39 +33,41 @@ public NotEqualExpression(Val val1, Val val2) {\n         super(val1, val2);\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch, boolean val1Null,\n-        boolean val2Null) {\n+    public void appendTo(Select sel, ExpContext ctx, BinaryOpExpState bstate, \n+        SQLBuffer buf, boolean val1Null, boolean val2Null) {\n         if (val1Null && val2Null)\n             buf.appendValue(null).append(\" IS NOT \").appendValue(null);\n         else if (val1Null || val2Null) {\n             Val val = (val1Null) ? getValue2() : getValue1();\n+            ExpState state = (val1Null) ? bstate.state2 : bstate.state1;\n             if (!isDirectComparison()) {\n-                int len = val.length();\n+                int len = val.length(sel, ctx, state);\n                 for (int i = 0; i < len; i++) {\n                     if (i > 0)\n                         buf.append(\" AND \");\n-                    val.appendTo(buf, i, sel, store, params, fetch);\n+                    val.appendTo(sel, ctx, state, buf, i);\n                     buf.append(\" IS NOT \").appendValue(null);\n                 }\n             } else\n-                val.appendIsNotNull(buf, sel, store, params, fetch);\n+                val.appendIsNotNull(sel, ctx, state, buf);\n         } else {\n             Val val1 = getValue1();\n             Val val2 = getValue2();\n-            if (val1.length() == 1 && val2.length() == 1) {\n-                store.getDBDictionary().comparison(buf, \"<>\",\n-                    new FilterValueImpl(val1, sel, store, params, fetch),\n-                    new FilterValueImpl(val2, sel, store, params, fetch));\n+            if (val1.length(sel, ctx, bstate.state1) == 1 \n+                && val2.length(sel, ctx, bstate.state2) == 1) {\n+                ctx.store.getDBDictionary().comparison(buf, \"<>\",\n+                    new FilterValueImpl(sel, ctx, bstate.state1, val1),\n+                    new FilterValueImpl(sel, ctx, bstate.state2, val2));\n             } else {\n-                int len = java.lang.Math.max(val1.length(), val2.length());\n+                int len = java.lang.Math.max(val1.length(sel, ctx, \n+                    bstate.state1), val2.length(sel, ctx, bstate.state2));\n                 buf.append(\"(\");\n                 for (int i = 0; i < len; i++) {\n                     if (i > 0)\n                         buf.append(\" OR \");\n-                    val1.appendTo(buf, i, sel, store, params, fetch);\n+                    val1.appendTo(sel, ctx, bstate.state1, buf, i);\n                     buf.append(\" <> \");\n-                    val2.appendTo(buf, i, sel, store, params, fetch);\n+                    val2.appendTo(sel, ctx, bstate.state2, buf, i);\n                 }\n                 buf.append(\")\");\n             }"},{"sha":"ef8ff62889d534a90ada35c9588110a82a8e8794","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotExpression.java","status":"modified","additions":23,"deletions":17,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,8 +17,6 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n@@ -33,7 +31,6 @@\n     implements Exp {\n \n     private final Exp _exp;\n-    private Joins _joins = null;\n \n     /**\n      * Constructor. Supply the expression to negate.\n@@ -42,26 +39,35 @@ public NotExpression(Exp exp) {\n         _exp = exp;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n-        _exp.initialize(sel, store, params, contains);\n-        _joins = sel.or(_exp.getJoins(), null);\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) { \n+        ExpState state = _exp.initialize(sel, ctx, contains);\n+        return new NotExpState(sel.or(state.joins, null), state);\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        buf.append(\"NOT (\");\n-        _exp.appendTo(buf, sel, store, params, fetch);\n-        buf.append(\")\");\n+    /**\n+     * Expression state.\n+     */\n+    private static class NotExpState \n+        extends ExpState {\n+\n+        public final ExpState state;\n+\n+        public NotExpState(Joins joins, ExpState state) {\n+            super(joins);\n+            this.state = state;\n+        }\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _exp.selectColumns(sel, store, params, pks, fetch);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n+        buf.append(\"NOT (\");\n+        _exp.appendTo(sel, ctx, ((NotExpState) state).state, buf);\n+        buf.append(\")\");\n     }\n \n-    public Joins getJoins() {\n-        return _joins;\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        _exp.selectColumns(sel, ctx, ((NotExpState) state).state, pks);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"94967632ca4794d6763f73a7466ba09f227337d5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Null.java","status":"modified","additions":5,"deletions":10,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Null.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Null.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Null.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,8 +15,6 @@\n  */\n package org.apache.openjpa.jdbc.kernel.exps;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n \n@@ -35,19 +33,16 @@ public Class getType() {\n     public void setImplicitType(Class type) {\n     }\n \n-    public Object getValue() {\n+    public Object getValue(Object[] params) {\n         return null;\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n         sql.appendValue(null);\n     }\n-\n-    public void clearParameters() {\n-    }\n }"},{"sha":"346026fb339dc8c7beaf58f3bba1394ed29a44d8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/OrExpression.java","status":"modified","additions":19,"deletions":26,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/OrExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/OrExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/OrExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -19,9 +19,6 @@\n import java.util.Iterator;\n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n@@ -36,7 +33,6 @@\n \n     private final Exp _exp1;\n     private final Exp _exp2;\n-    private Joins _joins = null;\n \n     /**\n      * Constructor. Supply the expressions to combine.\n@@ -46,56 +42,53 @@ public OrExpression(Exp exp1, Exp exp2) {\n         _exp2 = exp2;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n         // when OR'ing expressions each expression gets its own copy of the\n         // contains counts, cause it's OK for each to use the same aliases\n         Map contains2 = null;\n         if (contains != null)\n             contains2 = new HashMap(contains);\n \n-        _exp1.initialize(sel, store, params, contains);\n-        _exp2.initialize(sel, store, params, contains2);\n-        _joins = sel.or(_exp1.getJoins(), _exp2.getJoins());\n+        ExpState s1 = _exp1.initialize(sel, ctx, contains);\n+        ExpState s2 = _exp2.initialize(sel, ctx, contains2);\n+        ExpState ret = new BinaryOpExpState(sel.or(s1.joins, s2.joins), s1, s2);\n         if (contains == null)\n-            return;\n+            return ret;\n \n         // combine the contains counts from the copy into the main map\n         Map.Entry entry;\n         Integer val1, val2;\n-        for (Iterator itr = contains2.entrySet().iterator();\n-            itr.hasNext();) {\n+        for (Iterator itr = contains2.entrySet().iterator(); itr.hasNext();) {\n             entry = (Map.Entry) itr.next();\n             val2 = (Integer) entry.getValue();\n             val1 = (Integer) contains.get(entry.getKey());\n             if (val1 == null || val2.intValue() > val1.intValue())\n                 contains.put(entry.getKey(), val2);\n         }\n+        return ret;\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        boolean paren = _joins != null && !_joins.isEmpty();\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        boolean paren = bstate.joins != null && !bstate.joins.isEmpty();\n         if (paren)\n             buf.append(\"(\");\n \n-        _exp1.appendTo(buf, sel, store, params, fetch);\n+        _exp1.appendTo(sel, ctx, bstate.state1, buf);\n         buf.append(\" OR \");\n-        _exp2.appendTo(buf, sel, store, params, fetch);\n+        _exp2.appendTo(sel, ctx, bstate.state2, buf);\n \n         if (paren)\n             buf.append(\")\");\n-        sel.append(buf, _joins);\n+        sel.append(buf, bstate.joins);\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _exp1.selectColumns(sel, store, params, pks, fetch);\n-        _exp2.selectColumns(sel, store, params, pks, fetch);\n-    }\n-\n-    public Joins getJoins() {\n-        return _joins;\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _exp1.selectColumns(sel, ctx, bstate.state1, pks);\n+        _exp2.selectColumns(sel, ctx, bstate.state2, pks);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"5474db5242d10a907df4d9b60b8739e5bb02b620","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","status":"modified","additions":207,"deletions":205,"changes":412,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -56,17 +56,13 @@\n     private static final Localizer _loc = Localizer.forPackage(PCPath.class);\n \n     private final ClassMapping _candidate;\n-    private LinkedList _actions = null;\n-    private Joins _joins = null;\n-    private boolean _forceOuter = false;\n     private ClassMapping _class = null;\n-    private FieldMapping _field = null;\n+    private LinkedList _actions = null;\n     private boolean _key = false;\n-    private boolean _joinedRel = false;\n     private int _type = PATH;\n     private String _varName = null;\n-    private Column[] _cols = null;\n     private Class _cast = null;\n+    private boolean _cid = false;\n \n     /**\n      * Return a path starting with the 'this' ptr.\n@@ -92,6 +88,7 @@ public PCPath(ClassMapping candidate, Variable var) {\n             // bound variable; copy path\n             _type = UNACCESSED_VAR;\n             _actions.addAll(other._actions);\n+            _key = other._key;\n \n             action.op = Action.VAR;\n             action.data = var.getName();\n@@ -136,14 +133,18 @@ public boolean isUnaccessedVariable() {\n      * If this path is part of a contains clause, then alias it to the\n      * proper contains id before initialization.\n      */\n-    public void setContainsId(String id) {\n+    public synchronized void setContainsId(String id) {\n+        if (_cid)\n+            return;\n+\n         // treat it just like a unique variable\n         Action action = new Action();\n         action.op = Action.VAR;\n         action.data = id;\n         if (_actions == null)\n             _actions = new LinkedList();\n         _actions.add(action);\n+        _cid = true;\n     }\n \n     public ClassMetaData getMetaData() {\n@@ -154,29 +155,6 @@ public void setMetaData(ClassMetaData meta) {\n         _class = (ClassMapping) meta;\n     }\n \n-    public boolean isVariable() {\n-        return false;\n-    }\n-\n-    public ClassMapping getClassMapping() {\n-        if (_field == null)\n-            return _class;\n-        if (_key) {\n-            if (_field.getKey().getTypeCode() == JavaTypes.PC)\n-                return _field.getKeyMapping().getTypeMapping();\n-            return null;\n-        }\n-        if (_field.getElement().getTypeCode() == JavaTypes.PC)\n-            return _field.getElementMapping().getTypeMapping();\n-        if (_field.getTypeCode() == JavaTypes.PC)\n-            return _field.getTypeMapping();\n-        return null;\n-    }\n-\n-    public FieldMapping getFieldMapping() {\n-        return _field;\n-    }\n-\n     public boolean isKey() {\n         return _key;\n     }\n@@ -193,7 +171,7 @@ public String getPath() {\n                 path.append(action.data);\n             else if (action.op == Action.UNBOUND_VAR)\n                 path.append(((Variable) action.data).getName());\n-            else\n+            else \n                 path.append(((FieldMapping) action.data).getName());\n             path.append('.');\n         }\n@@ -202,42 +180,65 @@ else if (action.op == Action.UNBOUND_VAR)\n         return path.toString();\n     }\n \n-    public Column[] getColumns() {\n-        if (_cols == null)\n-            _cols = calculateColumns();\n-        return _cols;\n+    public ClassMapping getClassMapping(ExpState state) {\n+        PathExpState pstate = (PathExpState) state;\n+        if (pstate.field == null)\n+            return _class;\n+        if (_key) {\n+            if (pstate.field.getKey().getTypeCode() == JavaTypes.PC)\n+                return pstate.field.getKeyMapping().getTypeMapping();\n+            return null;\n+        }\n+        if (pstate.field.getElement().getTypeCode() == JavaTypes.PC)\n+            return pstate.field.getElementMapping().getTypeMapping();\n+        if (pstate.field.getTypeCode() == JavaTypes.PC)\n+            return pstate.field.getTypeMapping();\n+        return null;\n+    }\n+\n+    public FieldMapping getFieldMapping(ExpState state) {\n+        return ((PathExpState) state).field;\n+    }\n+\n+    public Column[] getColumns(ExpState state) {\n+        PathExpState pstate = (PathExpState) state;\n+        if (pstate.cols == null)\n+            pstate.cols = calculateColumns(pstate);\n+        return pstate.cols;\n     }\n \n     /**\n      * The columns used by this path.\n      */\n-    private Column[] calculateColumns() {\n+    private Column[] calculateColumns(PathExpState pstate) {\n         if (_key) {\n-            if (!_joinedRel && _field.getKey().getValueMappedBy() != null)\n-                joinRelation();\n-            else if (_joinedRel\n-                && _field.getKey().getTypeCode() == JavaTypes.PC)\n-                return _field.getKeyMapping().getTypeMapping().\n+            if (!pstate.joinedRel \n+                && pstate.field.getKey().getValueMappedBy() != null)\n+                joinRelation(pstate, _key, false, false);\n+            else if (pstate.joinedRel \n+                && pstate.field.getKey().getTypeCode() == JavaTypes.PC)\n+                return pstate.field.getKeyMapping().getTypeMapping().\n                     getPrimaryKeyColumns();\n-            return _field.getKeyMapping().getColumns();\n+            return pstate.field.getKeyMapping().getColumns();\n         }\n-        if (_field != null) {\n-            switch (_field.getTypeCode()) {\n+        if (pstate.field != null) {\n+            switch (pstate.field.getTypeCode()) {\n                 case JavaTypes.MAP:\n                 case JavaTypes.ARRAY:\n                 case JavaTypes.COLLECTION:\n-                    ValueMapping elem = _field.getElementMapping();\n-                    if (_joinedRel && elem.getTypeCode() == JavaTypes.PC)\n+                    ValueMapping elem = pstate.field.getElementMapping();\n+                    if (pstate.joinedRel && elem.getTypeCode() == JavaTypes.PC)\n                         return elem.getTypeMapping().getPrimaryKeyColumns();\n                     if (elem.getColumns().length > 0)\n                         return elem.getColumns();\n-                    return _field.getColumns();\n+                    return pstate.field.getColumns();\n                 case JavaTypes.PC:\n-                    if (_joinedRel)\n-                        return _field.getTypeMapping().getPrimaryKeyColumns();\n-                    return _field.getColumns();\n+                    if (pstate.joinedRel)\n+                        return pstate.field.getTypeMapping().\n+                            getPrimaryKeyColumns();\n+                    return pstate.field.getColumns();\n                 default:\n-                    return _field.getColumns();\n+                    return pstate.field.getColumns();\n             }\n         }\n         return (_class == null) ? Schemas.EMPTY_COLUMNS\n@@ -254,13 +255,18 @@ public void get(FieldMetaData field, boolean nullTraversal) {\n         if (_type == UNACCESSED_VAR)\n             _type = BOUND_VAR;\n         _cast = null;\n+        _key = false;\n     }\n \n-    public void getKey() {\n+    public synchronized void getKey() {\n+        if (_cid)\n+            return;\n+\n         // change the last action to a get key\n         Action action = (Action) _actions.getLast();\n         action.op = Action.GET_KEY;\n         _cast = null;\n+        _key = true;\n     }\n \n     public FieldMetaData last() {\n@@ -295,17 +301,9 @@ private Action lastFieldAction() {\n     public Class getType() {\n         if (_cast != null)\n             return _cast;\n-        FieldMetaData fld;\n-        boolean key;\n-        if (_field != null) {\n-            fld = _field;\n-            key = _key;\n-        } else {\n-            Action act = lastFieldAction();\n-            fld = (act == null) ? null : (FieldMetaData) act.data;\n-            key = act != null && act.op == Action.GET_KEY;\n-        }\n-\n+        Action act = lastFieldAction();\n+        FieldMetaData fld = (act == null) ? null : (FieldMetaData) act.data;\n+        boolean key = act != null && act.op == Action.GET_KEY;\n         if (fld != null) {\n             switch (fld.getDeclaredTypeCode()) {\n                 case JavaTypes.ARRAY:\n@@ -334,16 +332,13 @@ public void setImplicitType(Class type) {\n         _cast = type;\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n-        // initialize can be called more than once, so reset\n-        _field = null;\n-        _key = false;\n-        _forceOuter = false;\n-        _joinedRel = false;\n-        _joins = sel.newJoins();\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        PathExpState pstate = new PathExpState(sel.newJoins());\n+        boolean key = false;\n+        boolean forceOuter = false;\n+        ClassMapping rel = _candidate;\n \n         // iterate to the final field\n-        ClassMapping rel = _candidate;\n         ClassMapping owner;\n         ClassMapping from, to;\n         Action action;\n@@ -354,32 +349,33 @@ public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n \n             // treat subqueries like variables for alias generation purposes\n             if (action.op == Action.VAR)\n-                _joins = _joins.setVariable((String) action.data);\n+                pstate.joins = pstate.joins.setVariable((String) action.data);\n             else if (action.op == Action.SUBQUERY)\n-                _joins = _joins.setSubselect((String) action.data);\n+                pstate.joins = pstate.joins.setSubselect((String) action.data);\n             else if (action.op == Action.UNBOUND_VAR) {\n                 // unbound vars are cross-joined to the candidate table\n                 var = (Variable) action.data;\n                 rel = (ClassMapping) var.getMetaData();\n-                _joins = _joins.setVariable(var.getName());\n-                _joins = _joins.crossJoin(_candidate.getTable(),\n+                pstate.joins = pstate.joins.setVariable(var.getName());\n+                pstate.joins = pstate.joins.crossJoin(_candidate.getTable(), \n                     rel.getTable());\n             } else {\n                 // move past the previous field, if any\n-                if (_field != null)\n-                    rel = traverseField(false);\n+                if (pstate.field != null)\n+                    rel = traverseField(pstate, key, forceOuter, false);\n \n                 // mark if the next traversal should go through\n                 // the key rather than value\n-                _key = action.op == Action.GET_KEY;\n-                _forceOuter |= action.op == Action.GET_OUTER;\n+                key = action.op == Action.GET_KEY;\n+                forceOuter |= action.op == Action.GET_OUTER;\n \n                 // get mapping for the current field\n-                _field = (FieldMapping) action.data;\n-                owner = _field.getDefiningMapping();\n-                if (_field.getManagement() != FieldMapping.MANAGE_PERSISTENT)\n-                    throw new UserException(_loc.get(\"non-pers-field\",\n-                        _field));\n+                pstate.field = (FieldMapping) action.data;\n+                owner = pstate.field.getDefiningMapping();\n+                if (pstate.field.getManagement() \n+                    != FieldMapping.MANAGE_PERSISTENT)\n+                    throw new UserException(_loc.get(\"non-pers-field\", \n+                        pstate.field));\n \n                 // find the most-derived type between the declared relation\n                 // type and the field's owner, and join from that type to\n@@ -396,22 +392,38 @@ else if (action.op == Action.UNBOUND_VAR) {\n \n                     for (; from != null && from != to;\n                         from = from.getJoinablePCSuperclassMapping())\n-                        _joins = from.joinSuperclass(_joins, false);\n+                        pstate.joins = from.joinSuperclass(pstate.joins, false);\n                 }\n             }\n         }\n         if (_varName != null)\n-            _joins = _joins.setVariable(_varName);\n+            pstate.joins = pstate.joins.setVariable(_varName);\n \n         // if we're not comparing to null or doing an isEmpty, then\n         // join into the data on the final field; obviously we can't do these\n         // joins when comparing to null b/c the whole purpose is to see\n         // whether the joins even exist\n-        if (!nullTest)\n-            traverseField(true);\n+        if ((flags & NULL_CMP) == 0)\n+            traverseField(pstate, key, forceOuter, true);\n+        pstate.joinedRel = false;\n+        if ((flags & JOIN_REL) != 0)\n+            joinRelation(pstate, key, forceOuter, false);\n+        return pstate;\n+    }\n+\n+    /**\n+     * Expression state.\n+     */\n+    private static class PathExpState\n+        extends ExpState {\n+\n+        private FieldMapping field = null;\n+        private Column[] cols = null;\n+        private boolean joinedRel = false;\n \n-        // note that we haven't yet joined to the relation of the last field yet\n-        _joinedRel = false;\n+        public PathExpState(Joins joins) {\n+            super(joins);\n+        }\n     }\n \n     /**\n@@ -420,211 +432,201 @@ else if (action.op == Action.UNBOUND_VAR) {\n      * @param last whether this is the last field in the path\n      * @return the mapping of the related type, or null\n      */\n-    private ClassMapping traverseField(boolean last) {\n-        if (_field == null)\n+    private ClassMapping traverseField(PathExpState pstate, boolean key, \n+        boolean forceOuter, boolean last) {\n+        if (pstate.field == null)\n             return null;\n \n         // traverse into field value\n-        if (_key)\n-            _joins = _field.joinKey(_joins, _forceOuter);\n+        if (key)\n+            pstate.joins = pstate.field.joinKey(pstate.joins, forceOuter);\n         else\n-            _joins = _field.join(_joins, _forceOuter);\n+            pstate.joins = pstate.field.join(pstate.joins, forceOuter);\n \n         // if this isn't the last field, traverse into the relation\n         if (!last)\n-            joinRelation(true);\n+            joinRelation(pstate, key, forceOuter, true);\n \n         // return the maping of the related type, if any\n-        if (_key)\n-            return _field.getKeyMapping().getTypeMapping();\n-        if (_field.getElement().getTypeCode() == JavaTypes.PC)\n-            return _field.getElementMapping().getTypeMapping();\n-        return _field.getTypeMapping();\n+        if (key)\n+            return pstate.field.getKeyMapping().getTypeMapping();\n+        if (pstate.field.getElement().getTypeCode() == JavaTypes.PC)\n+            return pstate.field.getElementMapping().getTypeMapping();\n+        return pstate.field.getTypeMapping();\n     }\n \n     /**\n      * Join into the relation represented by the current field, if any.\n      */\n-    void joinRelation() {\n-        joinRelation(false);\n-    }\n-\n-    private void joinRelation(boolean traverse) {\n-        if (_field == null)\n+    private void joinRelation(PathExpState pstate, boolean key, \n+        boolean forceOuter, boolean traverse) {\n+        if (pstate.field == null)\n             return;\n-        if (_key)\n-            _joins = _field.joinKeyRelation(_joins, _forceOuter, traverse);\n+        if (key)\n+            pstate.joins = pstate.field.joinKeyRelation(pstate.joins, \n+                forceOuter, traverse);\n         else\n-            _joins = _field.joinRelation(_joins, _forceOuter, traverse);\n-        _joinedRel = true;\n-    }\n-\n-    public Joins getJoins() {\n-        return _joins;\n+            pstate.joins = pstate.field.joinRelation(pstate.joins, forceOuter,\n+                traverse);\n+        pstate.joinedRel = true;\n     }\n \n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        if (_field != null) {\n+    public Object toDataStoreValue(Select sel, ExpContext ctx, ExpState state, \n+        Object val) {\n+        PathExpState pstate = (PathExpState) state;\n+        if (pstate.field != null) {\n             if (_key)\n-                return _field.toKeyDataStoreValue(val, store);\n-            if (_field.getElement().getDeclaredTypeCode() != JavaTypes.OBJECT)\n-                return _field.toDataStoreValue(val, store);\n+                return pstate.field.toKeyDataStoreValue(val, ctx.store);\n+            if (pstate.field.getElement().getDeclaredTypeCode() \n+                != JavaTypes.OBJECT)\n+                return pstate.field.toDataStoreValue(val, ctx.store);\n \n-            val = _field.getExternalValue(val, store.getContext());\n-            return _field.toDataStoreValue(val, store);\n+            val = pstate.field.getExternalValue(val, ctx.store.getContext());\n+            return pstate.field.toDataStoreValue(val, ctx.store);\n         }\n         return _class.toDataStoreValue(val, _class.getPrimaryKeyColumns(),\n-            store);\n+            ctx.store);\n     }\n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n-        selectColumns(sel, store, params, pks, fetch);\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        selectColumns(sel, ctx, state, pks);\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        ClassMapping mapping = getClassMapping();\n-        if (mapping == null || !_joinedRel)\n-            sel.select(getColumns(), _joins);\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        ClassMapping mapping = getClassMapping(state);\n+        PathExpState pstate = (PathExpState) state;\n+        if (mapping == null || !pstate.joinedRel)\n+            sel.select(getColumns(state), pstate.joins);\n         else if (pks)\n-            sel.select(mapping.getPrimaryKeyColumns(), _joins);\n+            sel.select(mapping.getPrimaryKeyColumns(), pstate.joins);\n         else {\n             // select the mapping; allow any subs because we know this must\n             // be either a relation, in which case it will already be\n             // constrained by the joins, or 'this', in which case the\n             // JDBCExpressionFactory takes care of adding class conditions for\n             // the candidate class on the select\n-            int subs = (_type == UNBOUND_VAR) ? sel.SUBS_JOINABLE\n-                : sel.SUBS_ANY_JOINABLE;\n-            sel.select(mapping, subs, store, fetch,\n-                JDBCFetchConfiguration.EAGER_NONE, sel.outer(_joins));\n+            int subs = (_type == UNBOUND_VAR) ? Select.SUBS_JOINABLE\n+                : Select.SUBS_ANY_JOINABLE;\n+            sel.select(mapping, subs, ctx.store, ctx.fetch,\n+                JDBCFetchConfiguration.EAGER_NONE, sel.outer(pstate.joins));\n         }\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-        ClassMapping mapping = getClassMapping();\n-        if (mapping == null || !_joinedRel)\n-            sel.groupBy(getColumns(), sel.outer(_joins));\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+        ClassMapping mapping = getClassMapping(state);\n+        PathExpState pstate = (PathExpState) state;\n+        if (mapping == null || !pstate.joinedRel)\n+            sel.groupBy(getColumns(state), sel.outer(pstate.joins));\n         else {\n-            int subs = (_type == UNBOUND_VAR) ? sel.SUBS_JOINABLE\n-                : sel.SUBS_ANY_JOINABLE;\n-            sel.groupBy(mapping, subs, store, fetch, sel.outer(_joins));\n+            int subs = (_type == UNBOUND_VAR) ? Select.SUBS_JOINABLE\n+                : Select.SUBS_ANY_JOINABLE;\n+            sel.groupBy(mapping, subs, ctx.store, ctx.fetch, \n+                sel.outer(pstate.joins));\n         }\n     }\n \n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n-        sel.orderBy(getColumns(), asc, sel.outer(_joins), false);\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n+        sel.orderBy(getColumns(state), asc, sel.outer(state.joins), false);\n     }\n \n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res)\n         throws SQLException {\n-        return load(res, store, false, fetch);\n+        return load(ctx, state, res, false);\n     }\n \n-    Object load(Result res, JDBCStore store, boolean pks,\n-        JDBCFetchConfiguration fetch)\n+    Object load(ExpContext ctx, ExpState state, Result res, boolean pks)\n         throws SQLException {\n-        ClassMapping mapping = getClassMapping();\n-        if (mapping != null && (_field == null || !_field.isEmbedded())) {\n+        ClassMapping mapping = getClassMapping(state);\n+        PathExpState pstate = (PathExpState) state;\n+        if (mapping != null && (pstate.field == null \n+            || !pstate.field.isEmbedded())) {\n             if (pks)\n-                return mapping.getObjectId(store, res, null, true, _joins);\n-            return res.load(mapping, store, fetch, _joins);\n+                return mapping.getObjectId(ctx.store, res, null, true, \n+                    pstate.joins);\n+            return res.load(mapping, ctx.store, ctx.fetch, pstate.joins);\n         }\n \n         Object ret;\n         if (_key)\n-            ret = _field.loadKeyProjection(store, fetch, res, _joins);\n+            ret = pstate.field.loadKeyProjection(ctx.store, ctx.fetch, res, \n+                pstate.joins);\n         else\n-            ret = _field.loadProjection(store, fetch, res, _joins);\n+            ret = pstate.field.loadProjection(ctx.store, ctx.fetch, res, \n+                pstate.joins);\n         if (_cast != null)\n             ret = Filters.convert(ret, _cast);\n         return ret;\n     }\n \n-    /**\n-     * Whether the given variable appears in this path.\n-     */\n-    public boolean hasVariable(Variable var) {\n-        if (_actions == null)\n-            return false;\n-\n-        Action action;\n-        for (Iterator itr = _actions.iterator(); itr.hasNext();) {\n-            action = (Action) itr.next();\n-            if (action.op == Action.VAR && action.data.equals(var.getName()))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n         // we don't create the SQL b/c it forces the Select to cache aliases\n         // for the tables we use, and these aliases might not ever be used if\n         // we eventually call appendIsEmpty or appendIsNull rather than appendTo\n     }\n \n-    public void clearParameters() {\n-    }\n-\n-    public int length() {\n-        return getColumns().length;\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n+        return getColumns(state).length;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        Column col = getColumns()[index];\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        Column col = getColumns(state)[index];\n \n         // if select is null, it means we are not aliasing columns\n         // (e.g., during a bulk update)\n         if (sel == null)\n             sql.append(col.getName());\n         else\n-            sql.append(sel.getColumnAlias(col, _joins));\n+            sql.append(sel.getColumnAlias(col, state.joins));\n     }\n \n-    public void appendIsEmpty(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        if (_field == null)\n+    public void appendIsEmpty(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n+        PathExpState pstate = (PathExpState) state;\n+        if (pstate.field == null)\n             sql.append(FALSE);\n         else\n-            _field.appendIsEmpty(sql, sel, _joins);\n+            pstate.field.appendIsEmpty(sql, sel, pstate.joins);\n     }\n \n-    public void appendIsNotEmpty(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        if (_field == null)\n+    public void appendIsNotEmpty(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n+        PathExpState pstate = (PathExpState) state;\n+        if (pstate.field == null)\n             sql.append(FALSE);\n         else\n-            _field.appendIsNotEmpty(sql, sel, _joins);\n+            pstate.field.appendIsNotEmpty(sql, sel, pstate.joins);\n     }\n \n-    public void appendSize(SQLBuffer sql, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        if (_field == null)\n+    public void appendSize(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n+        PathExpState pstate = (PathExpState) state;\n+        if (pstate.field == null)\n             sql.append(\"1\");\n         else\n-            _field.appendSize(sql, sel, _joins);\n+            pstate.field.appendSize(sql, sel, pstate.joins);\n     }\n \n-    public void appendIsNull(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        if (_field == null)\n+    public void appendIsNull(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n+        PathExpState pstate = (PathExpState) state;\n+        if (pstate.field == null)\n             sql.append(FALSE);\n         else\n-            _field.appendIsNull(sql, sel, _joins);\n+            pstate.field.appendIsNull(sql, sel, pstate.joins);\n     }\n \n-    public void appendIsNotNull(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        if (_field == null)\n+    public void appendIsNotNull(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n+        PathExpState pstate = (PathExpState) state;\n+        if (pstate.field == null)\n             sql.append(TRUE);\n         else\n-            _field.appendIsNotNull(sql, sel, _joins);\n+            pstate.field.appendIsNotNull(sql, sel, pstate.joins);\n     }\n \n     public int hashCode() {"},{"sha":"50a7ef0a4a8537a80c34d11d612a8abac2d95639","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java","status":"modified","additions":40,"deletions":28,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -18,8 +18,8 @@\n import java.util.Collection;\n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.Filters;\n@@ -39,9 +39,6 @@\n     private Class _type = null;\n     private int _idx = -1;\n     private boolean _container = false;\n-    private Object _val = null;\n-    private Object _sqlVal = null;\n-    private int _otherLen = 0;\n \n     /**\n      * Constructor. Supply parameter name and type.\n@@ -79,39 +76,54 @@ public void setIndex(int idx) {\n         _idx = idx;\n     }\n \n-    public Object getValue() {\n-        return _val;\n+    public Object getValue(Object[] params) {\n+        return Filters.convert(params[_idx], getType());\n     }\n \n-    public Object getSQLValue() {\n-        return _sqlVal;\n+    public Object getSQLValue(Select sel, ExpContext ctx, ExpState state) {\n+        return ((ParamExpState) state).sqlValue;\n     }\n \n-    public Object getValue(Object[] params) {\n-        return params[_idx];\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        return new ParamExpState();\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        super.calculateValue(sel, store, params, other, fetch);\n-        _val = Filters.convert(params[_idx], getType());\n+    /**\n+     * Expression state.\n+     */\n+    private static class ParamExpState\n+        extends ConstExpState {\n+\n+        public Object sqlValue = null;\n+        public int otherLength = 1; \n+    } \n+\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        super.calculateValue(sel, ctx, state, other, otherState);\n+        Object val = getValue(ctx.params);\n+        ParamExpState pstate = (ParamExpState) state;\n         if (other != null && !_container) {\n-            _sqlVal = other.toDataStoreValue(_val, store);\n-            _otherLen = other.length();\n+            pstate.sqlValue = other.toDataStoreValue(sel, ctx, otherState, val);\n+            pstate.otherLength = other.length(sel, ctx, otherState);\n+        } else if (val instanceof PersistenceCapable) {\n+            ClassMapping mapping = ctx.store.getConfiguration().\n+                getMappingRepositoryInstance().getMapping(val.getClass(), \n+                ctx.store.getContext().getClassLoader(), true);\n+            pstate.sqlValue = mapping.toDataStoreValue(val, \n+                mapping.getPrimaryKeyColumns(), ctx.store);\n+            pstate.otherLength = mapping.getPrimaryKeyColumns().length;\n         } else\n-            _sqlVal = _val;\n+            pstate.sqlValue = val;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        if (_otherLen > 1)\n-            sql.appendValue(((Object[]) _sqlVal)[index], getColumn(index));\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        ParamExpState pstate = (ParamExpState) state;\n+        if (pstate.otherLength > 1)\n+            sql.appendValue(((Object[]) pstate.sqlValue)[index], \n+                pstate.getColumn(index));\n         else\n-            sql.appendValue(_sqlVal, getColumn(index));\n-    }\n-\n-    public void clearParameters() {\n-        _val = null;\n-        _sqlVal = null;\n+            sql.appendValue(pstate.sqlValue, pstate.getColumn(index));\n     }\n }"},{"sha":"630e9b8dc65ae6f2514abd491fe75285f3584e4c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/QueryExpressionsState.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/QueryExpressionsState.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/QueryExpressionsState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/QueryExpressionsState.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+/**\n+ * Struct to hold the state of a query expressions instance.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class QueryExpressionsState {\n+\n+    public static final ExpState[] EMPTY_STATES = new ExpState[0];\n+\n+    public ExpState[] projections = EMPTY_STATES;\n+    public ExpState filter = null;\n+    public ExpState[] grouping = EMPTY_STATES;\n+    public ExpState having = null;\n+    public ExpState[] ordering = EMPTY_STATES;\n+}"},{"sha":"f412ddead569f815d8b08d62b151a7a3168477b1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLEmbed.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLEmbed.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLEmbed.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLEmbed.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -18,6 +18,7 @@\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.StoreContext;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.util.UnsupportedException;"},{"sha":"cd1c71ebb493e3651dc5e090afeea728eca3a5e4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java","status":"modified","additions":106,"deletions":152,"changes":258,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -32,17 +32,11 @@\n  * Turns parsed queries into selects.\n  *\n  * @author Abe White\n+ * @nojavadoc\n  */\n-class SelectConstructor {\n+public class SelectConstructor {\n \n-    public static final int CACHE_NULL = 0;\n-    public static final int CACHE_JOINS = 1;\n-    public static final int CACHE_FULL = 2;\n-\n-    // cache as much as we can for multiple executions of the same query\n-    private Select _template = null;\n     private boolean _extent = false;\n-    private int _cacheLevel = -1;\n \n     /**\n      * Return true if we know the select to have on criteria; to be an extent.\n@@ -54,109 +48,71 @@ public boolean isExtent() {\n     }\n \n     /**\n-     * Evaluate the expression, returning a SQL select with the proper\n-     * conditions. Use {@link #select} to then select the data.\n+     * Evaluate the expression, returning a new select and filling in any\n+     * associated expression state. Use {@link #select} to then select the data.\n+     * \n+     * @param ctx fill with execution context\n+     * @param state will be filled with expression state\n      */\n-    public Select evaluate(JDBCStore store, Select parent, String alias,\n-        QueryExpressions exps, Object[] params, int level,\n-        JDBCFetchConfiguration fetch) {\n+    public Select evaluate(ExpContext ctx, Select parent, String alias, \n+        QueryExpressions exps, QueryExpressionsState state) {\n         // already know that this query is equivalent to an extent?\n         Select sel;\n         if (_extent) {\n-            sel = store.getSQLFactory().newSelect();\n+            sel = ctx.store.getSQLFactory().newSelect();\n             sel.setAutoDistinct((exps.distinct & exps.DISTINCT_AUTO) != 0);\n             return sel;\n         }\n \n-        // already cached some SQL? if we're changing our cache level, we\n-        // have to abandon any already-cached data because a change means\n-        // different joins\n-        if (level != _cacheLevel)\n-            _template = null;\n-        _cacheLevel = level;\n+        // create a new select and initialize it with the joins needed for\n+        // the criteria of this query\n+        sel = newSelect(ctx, parent, alias, exps, state);\n \n-        if (_template != null && level == CACHE_FULL) {\n-            sel = (Select) _template.fullClone(1);\n-            sel.setParent(parent, alias);\n-        } else if (_template != null) {\n-            sel = (Select) _template.whereClone(1);\n-            sel.setParent(parent, alias);\n-        } else {\n-            // create a new select and initialize it with the joins needed for\n-            // the criteria of this query\n-            sel = newJoinsSelect(store, parent, alias, exps, params, fetch);\n+        // create where clause; if there are no where conditions and\n+        // no ordering or projections, we return null to signify that this\n+        // query should be treated like an extent\n+        Select inner = sel.getFromSelect();\n+        SQLBuffer where = buildWhere((inner != null) ? inner : sel, ctx, \n+            state.filter, exps.filter);\n+        if (where == null && exps.projections.length == 0\n+            && exps.ordering.length == 0\n+            && (sel.getJoins() == null || sel.getJoins().isEmpty())) {\n+            _extent = true;\n+            sel.setAutoDistinct((exps.distinct & exps.DISTINCT_AUTO) != 0);\n+            return sel;\n         }\n \n-        // if this select wasn't cloned from a full template,\n-        // build up sql conditions\n-        if (_template == null || level != CACHE_FULL) {\n-            // create where clause; if there are no where conditions and\n-            // no ordering or projections, we return null to signify that this\n-            // query should be treated like an extent\n-            Select inner = sel.getFromSelect();\n-            SQLBuffer where = buildWhere((inner != null) ? inner : sel,\n-                store, exps.filter, params, fetch);\n-            if (where == null && exps.projections.length == 0\n-                && exps.ordering.length == 0\n-                && (sel.getJoins() == null || sel.getJoins().isEmpty())) {\n-                _extent = true;\n-                sel = store.getSQLFactory().newSelect();\n-                sel.setAutoDistinct((exps.distinct & exps.DISTINCT_AUTO) != 0);\n-                return sel;\n-            }\n-\n-            // if we're caching joins, do that now before we start setting sql.\n-            // we can't cache subselects because they are also held in the\n-            // where buffer\n-            if (_template == null && level == CACHE_JOINS\n-                && (inner == null || inner.getSubselects().isEmpty())\n-                && sel.getSubselects().isEmpty()) {\n-                _template = sel;\n-                sel = (Select) sel.whereClone(1);\n-                sel.setParent(parent, alias);\n-                inner = sel.getFromSelect();\n-            }\n-\n-            // now set sql criteria; it goes on the inner select if present\n-            if (inner != null)\n-                inner.where(where);\n-            else\n-                sel.where(where);\n-\n-            // apply grouping and having.  this does not select the grouping\n-            // columns, just builds the GROUP BY clauses.  we don't build the\n-            // ORDER BY clauses yet because if we decide to add this select\n-            // to a union, the ORDER BY values get aliased differently\n-            if (exps.having != null) {\n-                Exp havingExp = (Exp) exps.having;\n-                SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n-                havingExp.appendTo(buf, sel, store, params, fetch);\n-                sel.having(buf);\n-            }\n-            for (int i = 0; i < exps.grouping.length; i++)\n-                ((Val) exps.grouping[i]).groupBy(sel, store, params, fetch);\n-\n-            // if template is still null at this point, must be a full cache\n-            if (_template == null && level == CACHE_FULL) {\n-                _template = sel;\n-                sel = (Select) _template.fullClone(1);\n-                sel.setParent(parent, alias);\n-            }\n+        // now set sql criteria; it goes on the inner select if present\n+        if (inner != null)\n+            inner.where(where);\n+        else\n+            sel.where(where);\n+\n+        // apply grouping and having.  this does not select the grouping\n+        // columns, just builds the GROUP BY clauses.  we don't build the\n+        // ORDER BY clauses yet because if we decide to add this select\n+        // to a union, the ORDER BY values get aliased differently\n+        if (exps.having != null) {\n+            Exp havingExp = (Exp) exps.having;\n+            SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n+            havingExp.appendTo(sel, ctx, state.having, buf);\n+            sel.having(buf);\n         }\n+        for (int i = 0; i < exps.grouping.length; i++)\n+            ((Val) exps.grouping[i]).groupBy(sel, ctx, state.grouping[i]);\n         return sel;\n     }\n \n     /**\n-     * Initialize the given select's joins.\n+     * Return a new select with expressions initialized.\n      */\n-    private Select newJoinsSelect(JDBCStore store, Select parent,\n-        String alias, QueryExpressions exps, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-        Select sel = store.getSQLFactory().newSelect();\n+    private Select newSelect(ExpContext ctx, Select parent,\n+        String alias, QueryExpressions exps, QueryExpressionsState state) {\n+        Select sel = ctx.store.getSQLFactory().newSelect();\n         sel.setAutoDistinct((exps.distinct & exps.DISTINCT_AUTO) != 0);\n-        sel.setJoinSyntax(fetch.getJoinSyntax());\n+        sel.setJoinSyntax(ctx.fetch.getJoinSyntax());\n         sel.setParent(parent, alias);\n-        initializeJoins(sel, store, exps, params);\n+        initialize(sel, ctx, exps, state);\n \n         if (!sel.getAutoDistinct()) {\n             if ((exps.distinct & exps.DISTINCT_TRUE) != 0)\n@@ -179,12 +135,12 @@ else if ((exps.distinct & exps.DISTINCT_FALSE) != 0)\n                 // ordering, grouping, etc\n                 if (exps.isAggregate() \n                     || (exps.distinct & exps.DISTINCT_TRUE) == 0) {\n-                    DBDictionary dict = store.getDBDictionary();\n+                    DBDictionary dict = ctx.store.getDBDictionary();\n                     dict.assertSupport(dict.supportsSubselect,\n                         \"SupportsSubselect\");\n \n                     Select inner = sel;\n-                    sel = store.getSQLFactory().newSelect();\n+                    sel = ctx.store.getSQLFactory().newSelect();\n                     sel.setParent(parent, alias);\n                     sel.setDistinct(exps.isAggregate()\n                         && (exps.distinct & exps.DISTINCT_TRUE) != 0);\n@@ -196,79 +152,78 @@ else if ((exps.distinct & exps.DISTINCT_FALSE) != 0)\n     }\n \n     /**\n-     * Initialize the joins for all expressions. This only has to be done\n-     * once for the template select, since each factory is only used for a\n-     * single filter + projections + grouping + having + ordering combination.\n-     * By initializing the joins once, we speed up subsequent executions\n-     * because the relation traversal logic, etc is cached.\n+     * Initialize all expressions.\n      */\n-    private void initializeJoins(Select sel, JDBCStore store,\n-        QueryExpressions exps, Object[] params) {\n+    private void initialize(Select sel, ExpContext ctx, QueryExpressions exps, \n+        QueryExpressionsState state) {\n         Map contains = null;\n         if (HasContainsExpressionVisitor.hasContains(exps.filter)\n             || HasContainsExpressionVisitor.hasContains(exps.having))\n             contains = new HashMap(7);\n \n         // initialize filter and having expressions\n         Exp filterExp = (Exp) exps.filter;\n-        filterExp.initialize(sel, store, params, contains);\n+        state.filter = filterExp.initialize(sel, ctx, contains);\n         Exp havingExp = (Exp) exps.having;\n         if (havingExp != null)\n-            havingExp.initialize(sel, store, params, contains);\n+            state.having = havingExp.initialize(sel, ctx, contains);\n \n         // get the top-level joins and null the expression's joins\n         // at the same time so they aren't included in the where/having SQL\n-        Joins filterJoins = filterExp.getJoins();\n-        Joins havingJoins = (havingExp == null) ? null : havingExp.getJoins();\n+        Joins filterJoins = state.filter.joins;\n+        Joins havingJoins = (state.having == null) ? null : state.having.joins;\n         Joins joins = sel.and(filterJoins, havingJoins);\n \n         // initialize result values\n-        Val resultVal;\n-        for (int i = 0; i < exps.projections.length; i++) {\n-            resultVal = (Val) exps.projections[i];\n-            resultVal.initialize(sel, store, false);\n-\n-            // have to join through to related type for pc object projections;\n-            // this ensures that we have all our joins cached\n-            if (resultVal instanceof PCPath)\n-                ((PCPath) resultVal).joinRelation();\n-            joins = sel.and(joins, resultVal.getJoins());\n+        if (exps.projections.length > 0) {\n+            state.projections = new ExpState[exps.projections.length];\n+            Val resultVal;\n+            for (int i = 0; i < exps.projections.length; i++) {\n+                resultVal = (Val) exps.projections[i];\n+                // have to join through to related type for pc object \n+                // projections; this ensures that we have all our joins cached\n+                state.projections[i] = resultVal.initialize(sel, ctx, \n+                    Val.JOIN_REL);\n+                joins = sel.and(joins, state.projections[i].joins);\n+            }\n         }\n \n         // initialize grouping\n-        Val groupVal;\n-        for (int i = 0; i < exps.grouping.length; i++) {\n-            groupVal = (Val) exps.grouping[i];\n-            groupVal.initialize(sel, store, false);\n-\n-            // have to join through to related type for pc object groupings;\n-            // this ensures that we have all our joins cached\n-            if (groupVal instanceof PCPath)\n-                ((PCPath) groupVal).joinRelation();\n-            joins = sel.and(joins, groupVal.getJoins());\n+        if (exps.grouping.length > 0) {\n+            state.grouping = new ExpState[exps.grouping.length];\n+            Val groupVal;\n+            for (int i = 0; i < exps.grouping.length; i++) {\n+                groupVal = (Val) exps.grouping[i];\n+                // have to join through to related type for pc object groupings;\n+                // this ensures that we have all our joins cached\n+                state.grouping[i] = groupVal.initialize(sel, ctx, Val.JOIN_REL);\n+                joins = sel.and(joins, state.grouping[i].joins);\n+            }\n         }\n \n         // initialize ordering\n-        Val orderVal;\n-        for (int i = 0; i < exps.ordering.length; i++) {\n-            orderVal = (Val) exps.ordering[i];\n-            orderVal.initialize(sel, store, false);\n-            joins = sel.and(joins, orderVal.getJoins());\n+        if (exps.ordering.length > 0) {\n+            state.ordering = new ExpState[exps.ordering.length];\n+            Val orderVal;\n+            for (int i = 0; i < exps.ordering.length; i++) {\n+                orderVal = (Val) exps.ordering[i];\n+                state.ordering[i] = orderVal.initialize(sel, ctx, 0);\n+                joins = sel.and(joins, state.ordering[i].joins);\n+            }\n         }\n-\n         sel.where(joins);\n     }\n \n     /**\n      * Create the where sql.\n      */\n-    private SQLBuffer buildWhere(Select sel, JDBCStore store,\n-        Expression filter, Object[] params, JDBCFetchConfiguration fetch) {\n+    private SQLBuffer buildWhere(Select sel, ExpContext ctx, ExpState state, \n+        Expression filter) {\n         // create where buffer\n-        SQLBuffer where = new SQLBuffer(store.getDBDictionary());\n+        SQLBuffer where = new SQLBuffer(ctx.store.getDBDictionary());\n         where.append(\"(\");\n         Exp filterExp = (Exp) filter;\n-        filterExp.appendTo(where, sel, store, params, fetch);\n+        filterExp.appendTo(sel, ctx, state, where);\n \n         if (where.sqlEquals(\"(\") || where.sqlEquals(\"(1 = 1\"))\n             return null;\n@@ -278,9 +233,9 @@ private SQLBuffer buildWhere(Select sel, JDBCStore store,\n     /**\n      * Select the data for this query.\n      */\n-    public void select(JDBCStore store, ClassMapping mapping,\n-        boolean subclasses, Select sel, QueryExpressions exps,\n-        Object[] params, JDBCFetchConfiguration fetch, int eager) {\n+    public void select(Select sel, ExpContext ctx, ClassMapping mapping,\n+        boolean subclasses, QueryExpressions exps, QueryExpressionsState state,\n+        int eager) {\n         Select inner = sel.getFromSelect();\n         Val val;\n         Joins joins = null;\n@@ -290,13 +245,13 @@ public void select(JDBCStore store, ClassMapping mapping,\n         // build ordering clauses before select so that any eager join\n         // ordering gets applied after query ordering\n         for (int i = 0; i < exps.ordering.length; i++)\n-            ((Val) exps.ordering[i]).orderBy(sel, store, params,\n-                exps.ascending[i], fetch);\n+            ((Val) exps.ordering[i]).orderBy(sel, ctx, state.ordering[i],\n+                exps.ascending[i]);\n \n         // if no result string set, select matching objects like normal\n         if (exps.projections.length == 0 && sel.getParent() == null) {\n-            int subs = (subclasses) ? sel.SUBS_JOINABLE : sel.SUBS_NONE;\n-            sel.selectIdentifier(mapping, subs, store, fetch, eager);\n+            int subs = (subclasses) ? Select.SUBS_JOINABLE : Select.SUBS_NONE;\n+            sel.selectIdentifier(mapping, subs, ctx.store, ctx.fetch, eager);\n         } else if (exps.projections.length == 0) {\n             // subselect for objects; we really just need the primary key values\n             sel.select(mapping.getPrimaryKeyColumns(), joins);\n@@ -312,33 +267,32 @@ public void select(JDBCStore store, ClassMapping mapping,\n             for (int i = 0; i < exps.projections.length; i++) {\n                 val = (Val) exps.projections[i];\n                 if (inner != null)\n-                    val.selectColumns(inner, store, params, pks, fetch);\n-                val.select(sel, store, params, pks, fetch);\n+                    val.selectColumns(inner, ctx, state.projections[i], pks);\n+                val.select(sel, ctx, state.projections[i], pks);\n             }\n \n             // make sure having columns are selected since it is required by \n             // some DBs.  put them last so they don't affect result processing\n             if (exps.having != null && inner != null)\n-                ((Exp) exps.having).selectColumns(inner, store, params, true,\n-                    fetch);\n+                ((Exp) exps.having).selectColumns(inner, ctx, state.having, \n+                    true);\n         }\n \n         // select ordering columns, since it is required by some DBs.  put them\n         // last so they don't affect result processing\n         for (int i = 0; i < exps.ordering.length; i++) {\n             val = (Val) exps.ordering[i];\n             if (inner != null)\n-                val.selectColumns(inner, store, params, true, fetch);\n-            val.select(sel, store, params, true, fetch);\n+                val.selectColumns(inner, ctx, state.ordering[i], true);\n+            val.select(sel, ctx, state.ordering[i], true);\n         }\n \n         // add conditions limiting the projections to the proper classes; if\n         // this isn't a projection then they will already be added\n         if (exps.projections.length > 0) {\n-            store.loadSubclasses(mapping);\n-            Select indSel = (inner == null) ? sel : inner;\n-            mapping.getDiscriminator().addClassConditions(indSel, subclasses, \n-                joins);\n+            ctx.store.loadSubclasses(mapping);\n+            mapping.getDiscriminator().addClassConditions((inner != null) \n+                ? inner : sel, subclasses, joins);\n         }\n     }\n }"},{"sha":"44b15de0065e9aaa54a16d0f3682fedef84a248a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Size.java","status":"modified","additions":7,"deletions":8,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Size.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Size.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Size.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -33,17 +33,16 @@ public Size(Val val) {\n         super(val);\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n         // initialize the value with a null test\n-        getVal().initialize(sel, store, true);\n+        return initializeValue(sel, ctx, NULL_CMP);\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        getVal().calculateValue(sel, store, params, null, fetch);\n-        getVal().appendSize(sql, sel, store, params, fetch);\n-        sel.append(sql, getVal().getJoins());\n-        getVal().clearParameters();\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        getValue().calculateValue(sel, ctx, state, null, null);\n+        getValue().appendSize(sel, ctx, state, sql);\n+        sel.append(sql, state.joins);\n     }\n \n     protected Class getType(Class c) {"},{"sha":"3e5c4874aafe388c579a735e0a606c57a43105c6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java","status":"modified","additions":55,"deletions":60,"changes":115,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,14 +17,11 @@\n \n import java.util.Map;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.Table;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n@@ -40,9 +37,6 @@\n \n     private final Val _val1;\n     private final Val _val2;\n-    private Joins _joins = null;\n-    private String _pre = null;\n-    private String _post = null;\n \n     /**\n      * Constructor. Supply values.\n@@ -52,70 +46,67 @@ public StartsWithExpression(Val val1, Val val2) {\n         _val2 = val2;\n     }\n \n-    public void initialize(Select sel, JDBCStore store,\n-        Object[] params, Map contains) {\n-        _val1.initialize(sel, store, false);\n-        _val2.initialize(sel, store, false);\n-        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n-\n-        DBDictionary dict = store.getDBDictionary();\n-        String func = dict.stringLengthFunction;\n-        if (func != null) {\n-            int idx = func.indexOf(\"{0}\");\n-            _pre = func.substring(0, idx);\n-            _post = func.substring(idx + 3);\n-        }\n+    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n+        ExpState s1 = _val1.initialize(sel, ctx, 0);\n+        ExpState s2 = _val2.initialize(sel, ctx, 0);\n+        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n     }\n \n-    public void appendTo(SQLBuffer buf, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        _val1.calculateValue(sel, store, params, _val2, fetch);\n-        _val2.calculateValue(sel, store, params, _val1, fetch);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.calculateValue(sel, ctx, bstate.state1, _val2, bstate.state2);\n+        _val2.calculateValue(sel, ctx, bstate.state2, _val1, bstate.state1);\n \n-        if (_val1 instanceof Const && ((Const) _val1).getValue() == null)\n+        if (_val1 instanceof Const \n+            && ((Const) _val1).getValue(ctx, bstate.state1) == null)\n             buf.append(\"1 <> 1\");\n         else if (_val2 instanceof Const) {\n-            Object o = ((Const) _val2).getValue();\n+            Object o = ((Const) _val2).getValue(ctx, bstate.state2);\n             if (o == null)\n                 buf.append(\"1 <> 1\");\n             else {\n                 Column col = null;\n                 if (_val1 instanceof PCPath) {\n-                    Column[] cols = ((PCPath) _val1).getColumns();\n+                    Column[] cols = ((PCPath) _val1).getColumns(bstate.state1);\n                     if (cols.length == 1)\n                         col = cols[0];\n                 }\n \n-                _val1.appendTo(buf, 0, sel, store, params, fetch);\n+                _val1.appendTo(sel, ctx, bstate.state1, buf, 0);\n                 buf.append(\" LIKE \");\n                 buf.appendValue(o.toString() + \"%\", col);\n             }\n         } else {\n+            String pre = null;\n+            String post = null;\n+            DBDictionary dict = ctx.store.getDBDictionary();\n+            String func = dict.stringLengthFunction;\n+            if (func != null) {\n+                int idx = func.indexOf(\"{0}\");\n+                pre = func.substring(0, idx);\n+                post = func.substring(idx + 3);\n+            }\n+\n             // if we can't use LIKE, we have to take the substring of the\n             // first value and compare it to the second\n-            DBDictionary dict = store.getDBDictionary();\n-            dict.assertSupport(_pre != null, \"StringLengthFunction\");\n+            dict.assertSupport(pre != null, \"StringLengthFunction\");\n             dict.substring(buf,\n-                new FilterValueImpl(_val1, sel, store, params, fetch),\n-                new ZeroFilterValue(sel),\n-                new StringLengthFilterValue(sel, store, params, fetch));\n+                new FilterValueImpl(sel, ctx, bstate.state1, _val1),\n+                new ZeroFilterValue(sel, state),\n+                new StringLengthFilterValue(sel, ctx, bstate.state2, pre,post));\n             buf.append(\" = \");\n-            _val2.appendTo(buf, 0, sel, store, params, fetch);\n+            _val2.appendTo(sel, ctx, bstate.state2, buf, 0);\n         }\n \n-        sel.append(buf, _joins);\n-        _val1.clearParameters();\n-        _val2.clearParameters();\n-    }\n-\n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val1.selectColumns(sel, store, params, true, fetch);\n-        _val2.selectColumns(sel, store, params, true, fetch);\n+        sel.append(buf, state.joins);\n     }\n \n-    public Joins getJoins() {\n-        return _joins;\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.selectColumns(sel, ctx, bstate.state1, true);\n+        _val2.selectColumns(sel, ctx, bstate.state2, true);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {\n@@ -128,13 +119,15 @@ public void acceptVisit(ExpressionVisitor visitor) {\n     /**\n      * Evaluates to 0.\n      */\n-    private class ZeroFilterValue\n+    private static class ZeroFilterValue\n         implements FilterValue {\n \n         private final Select _sel;\n+        private final ExpState _state;\n \n-        public ZeroFilterValue(Select sel) {\n+        public ZeroFilterValue(Select sel, ExpState state) {\n             _sel = sel;\n+            _state = state;\n         }\n \n         public Class getType() {\n@@ -154,11 +147,11 @@ public void appendTo(SQLBuffer buf, int index) {\n         }\n \n         public String getColumnAlias(Column col) {\n-            return _sel.getColumnAlias(col, _joins);\n+            return _sel.getColumnAlias(col, _state.joins);\n         }\n \n         public String getColumnAlias(String col, Table table) {\n-            return _sel.getColumnAlias(col, table, _joins);\n+            return _sel.getColumnAlias(col, table, _state.joins);\n         }\n \n         public Object toDataStoreValue(Object val) {\n@@ -197,16 +190,18 @@ public FieldMapping getFieldMapping() {\n         implements FilterValue {\n \n         private final Select _sel;\n-        private final JDBCStore _store;\n-        private final Object[] _params;\n-        private final JDBCFetchConfiguration _fetch;\n+        private final ExpContext _ctx;\n+        private final ExpState _state;\n+        private final String _pre;\n+        private final String _post;\n \n-        public StringLengthFilterValue(Select sel, JDBCStore store,\n-            Object[] params, JDBCFetchConfiguration fetch) {\n+        public StringLengthFilterValue(Select sel, ExpContext ctx, \n+            ExpState state, String pre, String post){\n             _sel = sel;\n-            _store = store;\n-            _params = params;\n-            _fetch = fetch;\n+            _ctx = ctx;\n+            _state = state;\n+            _pre = pre;\n+            _post = post;\n         }\n \n         public Class getType() {\n@@ -223,20 +218,20 @@ public void appendTo(SQLBuffer buf) {\n \n         public void appendTo(SQLBuffer buf, int index) {\n             buf.append(_pre);\n-            _val2.appendTo(buf, index, _sel, _store, _params, _fetch);\n+            _val2.appendTo(_sel, _ctx, _state, buf, index);\n             buf.append(_post);\n         }\n \n         public String getColumnAlias(Column col) {\n-            return _sel.getColumnAlias(col, _val2.getJoins());\n+            return _sel.getColumnAlias(col, _state.joins);\n         }\n \n         public String getColumnAlias(String col, Table table) {\n-            return _sel.getColumnAlias(col, table, _val2.getJoins());\n+            return _sel.getColumnAlias(col, table, _state.joins);\n         }\n \n         public Object toDataStoreValue(Object val) {\n-            return _val2.toDataStoreValue(val, _store);\n+            return _val2.toDataStoreValue(_sel, _ctx, _state, val);\n         }\n \n         public boolean isConstant() {"},{"sha":"ef2d91bed47eb1ffdc9c424de21d403bc59f7cd0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringFunction.java","status":"modified","additions":28,"deletions":49,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringFunction.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringFunction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringFunction.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -36,10 +36,8 @@\n abstract class StringFunction\n     extends AbstractVal {\n \n-    final Val _val;\n-    ClassMetaData _meta = null;\n-    String _pre = null;\n-    String _post = null;\n+    private final Val _val;\n+    private ClassMetaData _meta = null;\n \n     /**\n      * Constructor. Provide the string to operate on.\n@@ -48,6 +46,10 @@ public StringFunction(Val val) {\n         _val = val;\n     }\n \n+    public Val getValue() {\n+        return _val;\n+    }\n+\n     public ClassMetaData getMetaData() {\n         return _meta;\n     }\n@@ -56,81 +58,58 @@ public void setMetaData(ClassMetaData meta) {\n         _meta = meta;\n     }\n \n-    public boolean isVariable() {\n-        return false;\n-    }\n-\n     public Class getType() {\n         return String.class;\n     }\n \n     public void setImplicitType(Class type) {\n     }\n \n-    public Joins getJoins() {\n-        return _val.getJoins();\n-    }\n-\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        return val;\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        return _val.initialize(sel, ctx, flags);\n     }\n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n-        sel.select(newSQLBuffer(sel, store, params, fetch), this);\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        sel.select(newSQLBuffer(sel, ctx, state), this);\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val.selectColumns(sel, store, params, true, fetch);\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        _val.selectColumns(sel, ctx, state, true);\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-        sel.groupBy(newSQLBuffer(sel, store, params, fetch));\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+        sel.groupBy(newSQLBuffer(sel, ctx, state));\n     }\n \n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n-        sel.orderBy(newSQLBuffer(sel, store, params, fetch), asc, false);\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n+        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n     }\n \n-    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        calculateValue(sel, store, params, null, fetch);\n-        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n-        appendTo(buf, 0, sel, store, params, fetch);\n-        clearParameters();\n+    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n+        calculateValue(sel, ctx, state, null, null);\n+        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n+        appendTo(sel, ctx, state, buf, 0);\n         return buf;\n     }\n \n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res)\n         throws SQLException {\n         return Filters.convert(res.getObject(this,\n             JavaSQLTypes.JDBC_DEFAULT, null), getType());\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        _val.calculateValue(sel, store, params, null, fetch);\n-    }\n-\n-    public void clearParameters() {\n-        _val.clearParameters();\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        _val.calculateValue(sel, ctx, state, null, null);\n     }\n \n-    public int length() {\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n         return 1;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        sql.append(_pre);\n-        _val.appendTo(sql, 0, sel, store, params, fetch);\n-        sql.append(_post);\n-    }\n-\n     public void acceptVisit(ExpressionVisitor visitor) {\n         visitor.enter(this);\n         _val.acceptVisit(visitor);"},{"sha":"bd7a7ba35db660f9b08f1ccae298bc5fc2938aec","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringLength.java","status":"modified","additions":13,"deletions":12,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringLength.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringLength.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringLength.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,6 +17,7 @@\n \n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n \n /**\n@@ -36,18 +37,6 @@ public StringLength(Val val) {\n         super(val);\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n-        _val.initialize(sel, store, false);\n-\n-        DBDictionary dict = store.getConfiguration().getDBDictionaryInstance();\n-        String func = dict.stringLengthFunction;\n-        dict.assertSupport(func != null, \"StringLengthFunction\");\n-\n-        int idx = func.indexOf(\"{0}\");\n-        _pre = func.substring(0, idx);\n-        _post = func.substring(idx + 3);\n-    }\n-\n     public Class getType() {\n         if (_cast != null)\n             return _cast;\n@@ -57,5 +46,17 @@ public Class getType() {\n     public void setImplicitType(Class type) {\n         _cast = type;\n     }\n+\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf, int index) {\n+        DBDictionary dict = ctx.store.getDBDictionary();\n+        String func = dict.stringLengthFunction;\n+        dict.assertSupport(func != null, \"StringLengthFunction\");\n+\n+        int idx = func.indexOf(\"{0}\");\n+        buf.append(func.substring(0, idx));\n+        getValue().appendTo(sel, ctx, state, buf, index);\n+        buf.append(func.substring(idx + 3));\n+    }\n }\n "},{"sha":"eb20db0d640b67a7f3c9b98e91e5127c5522a7a6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java","status":"modified","additions":47,"deletions":59,"changes":106,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -18,10 +18,8 @@\n import java.sql.SQLException;\n \n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n@@ -82,10 +80,6 @@ public void setImplicitType(Class type) {\n         _type = type;\n     }\n \n-    public boolean isVariable() {\n-        return false;\n-    }\n-\n     public ClassMetaData getMetaData() {\n         return _meta;\n     }\n@@ -102,101 +96,95 @@ public void setQueryExpressions(QueryExpressions query) {\n         _exps = query;\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n-    }\n-\n-    public Joins getJoins() {\n-        return null;\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        if (_exps.projections.length == 1)\n+            return ((Val) _exps.projections[0]).initialize(sel, ctx, flags);\n+        return ExpState.NULL;\n     }\n \n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n+    public Object toDataStoreValue(Select sel, ExpContext ctx, ExpState state, \n+        Object val) {\n         if (_exps.projections.length == 0)\n             return _candidate.toDataStoreValue(val,\n-                _candidate.getPrimaryKeyColumns(), store);\n+                _candidate.getPrimaryKeyColumns(), ctx.store);\n         if (_exps.projections.length == 1)\n-            return ((Val) _exps.projections[0]).toDataStoreValue(val, store);\n+            return ((Val) _exps.projections[0]).toDataStoreValue(sel, ctx, \n+                state, val);\n         return val;\n     }\n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n-        selectColumns(sel, store, params, pks, fetch);\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        selectColumns(sel, ctx, state, pks);\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        sel.select(newSQLBuffer(sel, store, params, fetch), this);\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        sel.select(newSQLBuffer(sel, ctx, state), this);\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-        sel.groupBy(newSQLBuffer(sel, store, params, fetch));\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+        sel.groupBy(newSQLBuffer(sel, ctx, state));\n     }\n \n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n-        sel.orderBy(newSQLBuffer(sel, store, params, fetch), asc, false);\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n+        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n     }\n \n-    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n-        appendTo(buf, 0, sel, store, params, fetch);\n+    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n+        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n+        appendTo(sel, ctx, state, buf, 0);\n         return buf;\n     }\n \n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res) \n         throws SQLException {\n         return Filters.convert(res.getObject(this,\n             JavaSQLTypes.JDBC_DEFAULT, null), getType());\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-    }\n-\n-    public void clearParameters() {\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n     }\n \n-    public int length() {\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n         return 1;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        appendTo(sql, index, sel, store, params, fetch, false);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        appendTo(sel, ctx, state, sql, index, false);\n     }\n \n-    private void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch,\n-        boolean size) {\n-        sel = _cons.evaluate(store, sel, _alias, _exps, params,\n-            _cons.CACHE_NULL, fetch);\n-        _cons.select(store, _candidate, _subs, sel, _exps, params,\n-            fetch, fetch.EAGER_NONE);\n+    private void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index, boolean size) {\n+        QueryExpressionsState substate = new QueryExpressionsState();\n+        Select sub = _cons.evaluate(ctx, sel, _alias, _exps, substate);\n+        _cons.select(sub, ctx, _candidate, _subs, _exps, substate, \n+            JDBCFetchConfiguration.EAGER_NONE);\n \n         if (size)\n-            sql.appendCount(sel, fetch);\n+            sql.appendCount(sub, ctx.fetch);\n         else\n-            sql.append(sel, fetch);\n+            sql.append(sub, ctx.fetch);\n     }\n \n-    public void appendIsEmpty(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendIsEmpty(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n         sql.append(\"NOT EXISTS \");\n-        appendTo(sql, 0, sel, store, params, fetch);\n+        appendTo(sel, ctx, state, sql, 0);\n     }\n \n-    public void appendIsNotEmpty(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendIsNotEmpty(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n         sql.append(\"EXISTS \");\n-        appendTo(sql, 0, sel, store, params, fetch);\n+        appendTo(sel, ctx, state, sql, 0);\n     }\n \n-    public void appendSize(SQLBuffer sql, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        appendTo(sql, 0, sel, store, params, fetch, true);\n+    public void appendSize(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql) {\n+        appendTo(sel, ctx, state, sql, 0, true);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"132c84a71d8571d9c6656df927dad330a9ba2980","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Substring.java","status":"modified","additions":38,"deletions":60,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Substring.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Substring.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Substring.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,10 +17,7 @@\n \n import java.sql.SQLException;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n@@ -38,7 +35,6 @@\n \n     private final Val _val1;\n     private final Val _val2;\n-    private Joins _joins = null;\n     private ClassMetaData _meta = null;\n \n     /**\n@@ -57,97 +53,79 @@ public void setMetaData(ClassMetaData meta) {\n         _meta = meta;\n     }\n \n-    public boolean isVariable() {\n-        return false;\n-    }\n-\n     public Class getType() {\n         return String.class;\n     }\n \n     public void setImplicitType(Class type) {\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n-        _val1.initialize(sel, store, false);\n-        _val2.initialize(sel, store, false);\n-        _joins = sel.and(_val1.getJoins(), _val2.getJoins());\n-    }\n-\n-    public Joins getJoins() {\n-        return _joins;\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        ExpState s1 = _val1.initialize(sel, ctx, 0);\n+        ExpState s2 = _val2.initialize(sel, ctx, 0);\n+        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n     }\n \n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        return val;\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        sel.select(newSQLBuffer(sel, ctx, state), this);\n     }\n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n-        sel.select(newSQLBuffer(sel, store, params, fetch), this);\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.selectColumns(sel, ctx, bstate.state1, true);\n+        _val2.selectColumns(sel, ctx, bstate.state2, true);\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val1.selectColumns(sel, store, params, true, fetch);\n-        _val2.selectColumns(sel, store, params, true, fetch);\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+        sel.groupBy(newSQLBuffer(sel, ctx, state));\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-        sel.groupBy(newSQLBuffer(sel, store, params, fetch));\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n+        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n     }\n \n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n-        sel.orderBy(newSQLBuffer(sel, store, params, fetch), asc, false);\n-    }\n-\n-    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        calculateValue(sel, store, params, null, fetch);\n-        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n-        appendTo(buf, 0, sel, store, params, fetch);\n-        clearParameters();\n+    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n+        calculateValue(sel, ctx, state, null, null);\n+        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n+        appendTo(sel, ctx, state, buf, 0);\n         return buf;\n     }\n \n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res)\n         throws SQLException {\n         return Filters.convert(res.getObject(this,\n             JavaSQLTypes.JDBC_DEFAULT, null), getType());\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        _val1.calculateValue(sel, store, params, null, fetch);\n-        _val2.calculateValue(sel, store, params, null, fetch);\n-    }\n-\n-    public void clearParameters() {\n-        _val1.clearParameters();\n-        _val2.clearParameters();\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        _val1.calculateValue(sel, ctx, bstate.state1, null, null);\n+        _val2.calculateValue(sel, ctx, bstate.state2, null, null);\n     }\n \n-    public int length() {\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n         return 1;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        FilterValue str = new FilterValueImpl(_val1, sel, store, params, fetch);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        BinaryOpExpState bstate = (BinaryOpExpState) state;\n+        FilterValue str = new FilterValueImpl(sel, ctx, bstate.state1, _val1);\n         FilterValue start;\n         FilterValue end = null;\n         if (_val2 instanceof Args) {\n-            Val[] args = ((Args) _val2).getVals();\n-            start =\n-                new FilterValueImpl(args[0], sel, store, params, fetch);\n-            end = new FilterValueImpl(args[1], sel, store, params, fetch);\n+            FilterValue[] filts = ((Args) _val2).newFilterValues(sel, ctx, \n+                bstate.state2);\n+            start = filts[0];\n+            end = filts[1];\n         } else\n-            start = new FilterValueImpl(_val2, sel, store, params, fetch);\n+            start = new FilterValueImpl(sel, ctx, bstate.state2, _val2);\n \n-        store.getDBDictionary().substring(sql, str, start, end);\n+        ctx.store.getDBDictionary().substring(sql, str, start, end);\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"344f46322b045e6896f7d36db642a7f02f0bbde1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,8 +15,8 @@\n  */\n package org.apache.openjpa.jdbc.kernel.exps;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n \n /**\n@@ -34,16 +34,16 @@ public ToLowerCase(Val val) {\n         super(val);\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n-        _val.initialize(sel, store, false);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf, int index) {\n \n-        DBDictionary dict = store.getDBDictionary();\n+        DBDictionary dict = ctx.store.getDBDictionary();\n         String func = dict.toLowerCaseFunction;\n         dict.assertSupport(func != null, \"ToLowerCaseFunction\");\n \n         int idx = func.indexOf(\"{0}\");\n-        _pre = func.substring(0, idx);\n-        _post = func.substring(idx + 3);\n+        buf.append(func.substring(0, idx));\n+        getValue().appendTo(sel, ctx, state, buf, index);\n+        buf.append(func.substring(idx + 3));\n     }\n }\n-"},{"sha":"291dbf31a1034bf3e08a8b040585a05a2c263013","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java","status":"modified","additions":7,"deletions":6,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,8 +15,8 @@\n  */\n package org.apache.openjpa.jdbc.kernel.exps;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n \n /**\n@@ -34,16 +34,17 @@ public ToUpperCase(Val val) {\n         super(val);\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n-        _val.initialize(sel, store, false);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf, int index) {\n \n-        DBDictionary dict = store.getDBDictionary();\n+        DBDictionary dict = ctx.store.getDBDictionary();\n         String func = dict.toUpperCaseFunction;\n         dict.assertSupport(func != null, \"ToUpperCaseFunction\");\n \n         int idx = func.indexOf(\"{0}\");\n-        _pre = func.substring(0, idx);\n-        _post = func.substring(idx + 3);\n+        buf.append(func.substring(0, idx));\n+        getValue().appendTo(sel, ctx, state, buf, index);\n+        buf.append(func.substring(idx + 3));\n     }\n }\n "},{"sha":"7fcc0afbcfd7ba0573755b75e3fabe3d6134a106","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Trim.java","status":"modified","additions":77,"deletions":80,"changes":157,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Trim.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Trim.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Trim.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -18,8 +18,6 @@\n import java.lang.Math;\n import java.sql.SQLException;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.Joins;\n@@ -43,7 +41,6 @@\n     private final Val _trimChar;\n     private final Boolean _where;\n     private ClassMetaData _meta = null;\n-    private String _func = null;\n \n     /**\n      * Constructor. Provide the string to operate on.\n@@ -62,130 +59,130 @@ public void setMetaData(ClassMetaData meta) {\n         _meta = meta;\n     }\n \n-    public boolean isVariable() {\n-        return false;\n-    }\n-\n     public Class getType() {\n         return String.class;\n     }\n \n     public void setImplicitType(Class type) {\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n-        _val.initialize(sel, store, false);\n-\n-        DBDictionary dict = store.getDBDictionary();\n-        if (_where == null) {\n-            _func = dict.trimBothFunction;\n-            dict.assertSupport(_func != null, \"TrimBothFunction\");\n-        } else if (_where.equals(Boolean.TRUE)) {\n-            _func = dict.trimLeadingFunction;\n-            dict.assertSupport(_func != null, \"TrimLeadingFunction\");\n-        } else if (_where.equals(Boolean.FALSE)) {\n-            _func = dict.trimTrailingFunction;\n-            dict.assertSupport(_func != null, \"TrimTrailingFunction\");\n-        }\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        ExpState valueState =  _val.initialize(sel, ctx, 0);\n+        ExpState charState = _trimChar.initialize(sel, ctx, 0);\n+        return new TrimExpState(sel.and(valueState.joins, charState.joins), \n+            valueState, charState);\n     }\n \n-    public Joins getJoins() {\n-        return _val.getJoins();\n-    }\n+    /**\n+     * Expression state.\n+     */\n+    private static class TrimExpState\n+        extends ExpState {\n \n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        return val;\n+        public final ExpState valueState;\n+        public final ExpState charState;\n+\n+        public TrimExpState(Joins joins, ExpState valueState, \n+            ExpState charState) {\n+            super(joins);\n+            this.valueState = valueState;\n+            this.charState = charState;\n+        }\n     }\n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n-        sel.select(newSQLBuffer(sel, store, params, fetch), this);\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        sel.select(newSQLBuffer(sel, ctx, state), this);\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val.selectColumns(sel, store, params, true, fetch);\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        TrimExpState tstate = (TrimExpState) state;\n+        _val.selectColumns(sel, ctx, tstate.valueState, true);\n+        _trimChar.selectColumns(sel, ctx, tstate.charState, true);\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-        sel.groupBy(newSQLBuffer(sel, store, params, fetch));\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+        sel.groupBy(newSQLBuffer(sel, ctx, state));\n     }\n \n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n-        sel.orderBy(newSQLBuffer(sel, store, params, fetch), asc, false);\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n+        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n     }\n \n-    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        calculateValue(sel, store, params, null, fetch);\n-        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n-        appendTo(buf, 0, sel, store, params, fetch);\n-        clearParameters();\n+    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n+        calculateValue(sel, ctx, state, null, null);\n+        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n+        appendTo(sel, ctx, state, buf, 0);\n         return buf;\n     }\n \n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res)\n         throws SQLException {\n         return Filters.convert(res.getObject(this,\n             JavaSQLTypes.JDBC_DEFAULT, null), getType());\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        _val.calculateValue(sel, store, params, null, fetch);\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        TrimExpState tstate = (TrimExpState) state;\n+        _val.calculateValue(sel, ctx, tstate.valueState, null, null);\n+        _trimChar.calculateValue(sel, ctx, tstate.charState, null, null);\n     }\n \n-    public void clearParameters() {\n-        _val.clearParameters();\n-    }\n-\n-    public int length() {\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n         return 1;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n-        _val.calculateValue(sel, store, params, _trimChar, fetch);\n-        _trimChar.calculateValue(sel, store, params, _val, fetch);\n-\n-        int fromPart = _func.indexOf(\"{0}\");\n-        int charPart = _func.indexOf(\"{1}\");\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        DBDictionary dict = ctx.store.getDBDictionary();\n+        String func;\n+        if (_where == null) {\n+            func = dict.trimBothFunction;\n+            dict.assertSupport(func != null, \"TrimBothFunction\");\n+        } else if (_where.booleanValue()) {\n+            func = dict.trimLeadingFunction;\n+            dict.assertSupport(func != null, \"TrimLeadingFunction\");\n+        } else {\n+            func = dict.trimTrailingFunction;\n+            dict.assertSupport(func != null, \"TrimTrailingFunction\");\n+        }\n \n+        int fromPart = func.indexOf(\"{0}\");\n+        int charPart = func.indexOf(\"{1}\");\n         if (charPart == -1)\n-            charPart = _func.length();\n-\n-        String part1 = _func.substring(0, Math.min(fromPart, charPart));\n-\n-        String part2 = _func.substring(Math.min(fromPart, charPart) + 3,\n+            charPart = func.length();\n+        String part1 = func.substring(0, Math.min(fromPart, charPart));\n+        String part2 = func.substring(Math.min(fromPart, charPart) + 3,\n             Math.max(fromPart, charPart));\n-\n         String part3 = null;\n-        if (charPart != _func.length())\n-            part3 = _func.substring(Math.max(fromPart, charPart) + 3);\n+        if (charPart != func.length())\n+            part3 = func.substring(Math.max(fromPart, charPart) + 3);\n \n+        TrimExpState tstate = (TrimExpState) state;\n         sql.append(part1);\n-        (fromPart < charPart ? _val : _trimChar).\n-            appendTo(sql, 0, sel, store, params, fetch);\n+        if (fromPart < charPart)\n+            _val.appendTo(sel, ctx, tstate.valueState, sql, 0);\n+        else \n+            _trimChar.appendTo(sel, ctx, tstate.charState, sql, 0);\n         sql.append(part2);\n \n-        if (charPart != _func.length()) {\n-            (fromPart > charPart ? _val : _trimChar).\n-                appendTo(sql, 0, sel, store, params, fetch);\n+        if (charPart != func.length()) {\n+            if (fromPart > charPart)\n+                _val.appendTo(sel, ctx, tstate.valueState, sql, 0);\n+            else\n+                _trimChar.appendTo(sel, ctx, tstate.charState, sql, 0);\n             sql.append(part3);\n         } else {\n             // since the trim statement did not specify the token for\n             // where to specify the trim char (denoted by \"{1}\"),\n             // we do not have the ability to trim off non-whitespace\n             // characters; throw an exception when we attempt to do so\n-            if (!(_trimChar instanceof Literal)\n-                || String.valueOf(((Literal) _trimChar).getValue()).\n-                trim().length() != 0) {\n-                store.getDBDictionary().assertSupport(false,\n-                    \"TrimNonWhitespaceCharacters\");\n-            }\n+            if (!(_trimChar instanceof Const) || String.valueOf(((Const) \n+                _trimChar).getValue(ctx,tstate.charState)).trim().length() != 0)\n+                dict.assertSupport(false, \"TrimNonWhitespaceCharacters\");\n         }\n     }\n "},{"sha":"5540c5ad7f0193bc945b122e9fd92ec983f9c4ff","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/UnaryOp.java","status":"modified","additions":28,"deletions":47,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/UnaryOp.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/UnaryOp.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/UnaryOp.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,10 +17,7 @@\n \n import java.sql.SQLException;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n@@ -47,7 +44,7 @@ public UnaryOp(Val val) {\n         _val = val;\n     }\n \n-    protected Val getVal() {\n+    protected Val getValue() {\n         return _val;\n     }\n \n@@ -59,10 +56,6 @@ public void setMetaData(ClassMetaData meta) {\n         _meta = meta;\n     }\n \n-    public boolean isVariable() {\n-        return false;\n-    }\n-\n     public Class getType() {\n         if (_cast != null)\n             return _cast;\n@@ -73,74 +66,62 @@ public void setImplicitType(Class type) {\n         _cast = type;\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n-        _val.initialize(sel, store, false);\n-    }\n-\n-    public Joins getJoins() {\n-        return _val.getJoins();\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        return initializeValue(sel, ctx, flags);\n     }\n \n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        return val;\n+    protected ExpState initializeValue(Select sel, ExpContext ctx, int flags) {\n+        return _val.initialize(sel, ctx, flags);\n     }\n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n-        sel.select(newSQLBuffer(sel, store, params, fetch), this);\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        sel.select(newSQLBuffer(sel, ctx, state), this);\n         if (isAggregate())\n             sel.setAggregate(true);\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n-        _val.selectColumns(sel, store, params, true, fetch);\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n+        _val.selectColumns(sel, ctx, state, true);\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-        sel.groupBy(newSQLBuffer(sel, store, params, fetch));\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+        sel.groupBy(newSQLBuffer(sel, ctx, state));\n     }\n \n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n-        sel.orderBy(newSQLBuffer(sel, store, params, fetch), asc, false);\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n+        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n     }\n \n-    private SQLBuffer newSQLBuffer(Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch) {\n-        calculateValue(sel, store, params, null, fetch);\n-        SQLBuffer buf = new SQLBuffer(store.getDBDictionary());\n-        appendTo(buf, 0, sel, store, params, fetch);\n-        clearParameters();\n+    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n+        calculateValue(sel, ctx, state, null, null);\n+        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n+        appendTo(sel, ctx, state, buf, 0);\n         return buf;\n     }\n \n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res)\n         throws SQLException {\n         return Filters.convert(res.getObject(this,\n             JavaSQLTypes.JDBC_DEFAULT, null), getType());\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        _val.calculateValue(sel, store, params, null, fetch);\n-    }\n-\n-    public void clearParameters() {\n-        _val.clearParameters();\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        _val.calculateValue(sel, ctx, state, null, null);\n     }\n \n-    public int length() {\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n         return 1;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n         sql.append(getOperator());\n         sql.append(\"(\");\n-        _val.appendTo(sql, 0, sel, store, params, fetch);\n+        _val.appendTo(sel, ctx, state, sql, 0);\n         sql.append(\")\");\n     }\n "},{"sha":"c31dc49721905c312ad847db03df3dc69c377ea6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Val.java","status":"modified","additions":35,"deletions":50,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Val.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Val.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Val.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -36,64 +36,54 @@\n     extends Value {\n \n     /**\n-     * Initialize the value. This method should recursively initialize any\n-     * sub-values. It should also cache the {@link Joins} instance\n-     * containing the joins for this value. No additional joins should be\n-     * made after this call. The parent expression might modify these joins\n-     * during its own initialization so that common joins are moved up the\n-     * expression tree. These joins should not be included in the SQL\n-     * appended through any of the <code>append</code> methods.\n-     *\n-     * @param sel used to create {@link Joins} instances\n-     * @param store the store manager for the query\n-     * @param nullTest if true, then this value will be compared\n-     * to null or tested for emptiness\n+     * Initialization flag indicating that this value will be compared to null.\n      */\n-    public void initialize(Select sel, JDBCStore store, boolean nullTest);\n+    public final int NULL_CMP = 1;\n \n     /**\n-     * Return the joins for this value. These joins should be created\n-     * and cached during the {@link #initialize} method. The parent\n-     * expression might modify these joins during its own initialization so\n-     * that common joins are moved up the expression tree.\n+     * Initialization flag indicating to join into any relation path.\n      */\n-    public Joins getJoins();\n+    public final int JOIN_REL = 2; \n+\n+    /**\n+     * Initialize the value. This method should recursively initialize any\n+     * sub-values. \n+     */\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags);\n \n     /**\n      * Return the datastore value of the given object in the context of this\n      * value.\n      */\n-    public Object toDataStoreValue(Object val, JDBCStore store);\n+    public Object toDataStoreValue(Select sel, ExpContext ctx, ExpState state, \n+        Object val);\n \n     /**\n      * Select the data for this value.\n      */\n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch);\n+    public void select(Select sel, ExpContext ctx, ExpState state, boolean pks);\n \n     /**\n      * Select just the columns for this value.\n      */\n-    public void selectColumns(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch);\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks);\n \n     /**\n      * Group by this value.\n      */\n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch);\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state);\n \n     /**\n      * Order by this value.\n      */\n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch);\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc);\n \n     /**\n      * Load the data for this value.\n      */\n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res)\n         throws SQLException;\n \n     /**\n@@ -102,55 +92,50 @@ public Object load(Result res, JDBCStore store,\n      *\n      * @param other the value being compared to, or null if not a comparison\n      */\n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch);\n-\n-    /**\n-     * Clear parameter values held by this value or its subcomponents.\n-     * This method is called sometime after <code>calculateValue</code>.\n-     */\n-    public void clearParameters();\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState);\n \n     /**\n      * Return the number of SQL elements in this value.\n      */\n-    public int length();\n+    public int length(Select sel, ExpContext ctx, ExpState state);\n \n     /**\n      * Append the <code>index</code>th SQL element to the given buffer.\n      */\n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch);\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, \n+        int index);\n \n     /**\n      * Append the SQL testing whether this value is empty to the given buffer.\n      */\n-    public void appendIsEmpty(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch);\n+    public void appendIsEmpty(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql);\n \n     /**\n      * Append the SQL testing whether this value is not empty to\n      * the given buffer.\n      */\n-    public void appendIsNotEmpty(SQLBuffer sql, Select sel, JDBCStore store,\n-        Object[] params, JDBCFetchConfiguration fetch);\n+    public void appendIsNotEmpty(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql);\n \n     /**\n      * Append the SQL checking the size of this value.\n      */\n-    public void appendSize(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch);\n+    public void appendSize(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql);\n \n     /**\n      * Append the SQL testing whether this value is null to the given buffer.\n      */\n-    public void appendIsNull(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch);\n+    public void appendIsNull(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql);\n \n     /**\n      * Append the SQL testing whether this value is not null to the given\n      * buffer.\n      */\n-    public void appendIsNotNull(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch);\n+    public void appendIsNotNull(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql);\n }"},{"sha":"ea52365efbb97a2aa93bf0d6874c73965bce283f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Variable.java","status":"modified","additions":27,"deletions":45,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Variable.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Variable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Variable.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -17,9 +17,6 @@\n \n import java.sql.SQLException;\n \n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n@@ -106,81 +103,66 @@ public void setImplicitType(Class type) {\n             _path.setImplicitType(type);\n     }\n \n-    public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n         if (_path != null) {\n             _path.addVariableAction(this);\n-            _path.initialize(sel, store, nullTest);\n-            _path.joinRelation();\n+            return _path.initialize(sel, ctx, flags | JOIN_REL);\n         }\n+        return ExpState.NULL;\n     }\n \n-    public Joins getJoins() {\n-        return (_path == null) ? null : _path.getJoins();\n+    public void select(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n     }\n \n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        return val;\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n+        boolean pks) {\n     }\n \n-    public void select(Select sel, JDBCStore store, Object[] params,\n-        boolean pks, JDBCFetchConfiguration fetch) {\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n     }\n \n-    public void selectColumns(Select sel, JDBCStore store,\n-        Object[] params, boolean pks, JDBCFetchConfiguration fetch) {\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n+        boolean asc) {\n     }\n \n-    public void groupBy(Select sel, JDBCStore store, Object[] params,\n-        JDBCFetchConfiguration fetch) {\n-    }\n-\n-    public void orderBy(Select sel, JDBCStore store, Object[] params,\n-        boolean asc, JDBCFetchConfiguration fetch) {\n-    }\n-\n-    public Object load(Result res, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n+    public Object load(ExpContext ctx, ExpState state, Result res)\n         throws SQLException {\n         return null;\n     }\n \n-    public void calculateValue(Select sel, JDBCStore store,\n-        Object[] params, Val other, JDBCFetchConfiguration fetch) {\n-        if (_path != null)\n-            _path.calculateValue(sel, store, params, other, fetch);\n-    }\n-\n-    public void clearParameters() {\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n         if (_path != null)\n-            _path.clearParameters();\n+            _path.calculateValue(sel, ctx, state, other, otherState);\n     }\n \n-    public int length() {\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n         return 0;\n     }\n \n-    public void appendTo(SQLBuffer sql, int index, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n     }\n \n-    public void appendIsEmpty(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendIsEmpty(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n     }\n \n-    public void appendIsNotEmpty(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendIsNotEmpty(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n     }\n \n-    public void appendSize(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendSize(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n     }\n \n-    public void appendIsNull(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendIsNull(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n     }\n \n-    public void appendIsNotNull(SQLBuffer sql, Select sel,\n-        JDBCStore store, Object[] params, JDBCFetchConfiguration fetch) {\n+    public void appendIsNotNull(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer buf) {\n     }\n \n     public void acceptVisit(ExpressionVisitor visitor) {"},{"sha":"dd0f0e1327d155bb7fc6a0c9a3a923ed1941c73e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","status":"modified","additions":11,"deletions":10,"changes":21,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -59,6 +59,8 @@\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.kernel.exps.ExpContext;\n+import org.apache.openjpa.jdbc.kernel.exps.ExpState;\n import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n import org.apache.openjpa.jdbc.kernel.exps.Val;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n@@ -1851,6 +1853,8 @@ protected void appendUpdates(Select sel, JDBCStore store, SQLBuffer sql,\n \n         // manually build up the SET clause for the UPDATE statement\n         sql.append(\" SET \");\n+        ExpContext ctx = new ExpContext(store, params, \n+            store.getFetchConfiguration());\n         for (Iterator i = updateParams.entrySet().iterator(); i.hasNext();) {\n             Map.Entry next = (Map.Entry) i.next();\n             FieldMetaData fmd = (FieldMetaData) next.getKey();\n@@ -1859,15 +1863,15 @@ protected void appendUpdates(Select sel, JDBCStore store, SQLBuffer sql,\n             Column col = ((FieldMapping) fmd).getColumns()[0];\n             sql.append(col.getName());\n             sql.append(\" = \");\n-            val.initialize(sel, store, false);\n-            JDBCFetchConfiguration fetch = store.getFetchConfiguration();\n-            val.calculateValue(sel, store, params, null, fetch);\n+\n+            ExpState state = val.initialize(sel, ctx, 0);\n+            val.calculateValue(sel, ctx, state, null, null);\n \n             // append the value with a null for the Select; i\n             // indicates that the\n-            for (int j = 0; j < val.length(); j++)\n-                val.appendTo(sql, j, (allowAlias) ? sel : null, store, params, \n-                    fetch);\n+            int length = val.length(sel, ctx, state);\n+            for (int j = 0; j < length; j++)\n+                val.appendTo((allowAlias) ? sel : null, ctx, state, sql, j);\n \n             if (i.hasNext())\n                 sql.append(\", \");\n@@ -3607,10 +3611,7 @@ public void endConfiguration() {\n         } catch (IOException ioe) {\n             throw new GeneralException(ioe);\n         } finally {\n-            try {\n-                in.close();\n-            } catch (IOException e) {\n-            }\n+            try { in.close(); } catch (IOException e) {}\n         }\n \n         // add additional reserved words set by user"},{"sha":"469ccee66be29b8ad157c18ddf76ca6f2f0209d3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -96,6 +96,6 @@ public Broker newBroker(String user, String pass, boolean managed,\n \n     /**\n      * Release the internal lock.\n-\t */\n-\tpublic void unlock ();\n+     */\n+    public void unlock ();\n }"},{"sha":"588551c2cdaf7b83dde7bfda912b55337100407a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java","status":"modified","additions":17,"deletions":23,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -628,8 +628,8 @@ public void enter(Value val) {\n         private final ExpressionParser _parser;\n         private final ExpressionFactory[] _facts;\n         private final QueryExpressions[] _exps;\n+        private final Class[] _projTypes;\n         private Value[] _inMemOrdering;\n-        private Class[] _projTypes;\n \n         public DataStoreExecutor(ExpressionStoreQuery q,\n             ClassMetaData meta, boolean subclasses,\n@@ -644,10 +644,17 @@ public DataStoreExecutor(ExpressionStoreQuery q,\n                 _facts[i] = q.getExpressionFactory(_metas[i]);\n \n             _exps = new QueryExpressions[_metas.length];\n-            for (int i = 0; i < _exps.length; i++) {\n+            for (int i = 0; i < _exps.length; i++)\n                 _exps[i] = parser.eval(parsed, q, _facts[i], _metas[i]);\n-                for (int j = 0; j < _exps[i].projections.length; j++)\n-                    assertNotContainer(_exps[i].projections[j], q);\n+\n+            if (_exps[0].projections.length == 0)\n+                _projTypes = StoreQuery.EMPTY_CLASSES;\n+            else {\n+                _projTypes = new Class[_exps[0].projections.length];\n+                for (int i = 0; i < _exps[0].projections.length; i++) {\n+                    assertNotContainer(_exps[0].projections[i], q);\n+                    _projTypes[i] = _exps[0].projections[i].getType();\n+                }\n             }\n         }\n \n@@ -706,29 +713,16 @@ public Object getOrderingValue(StoreQuery q, Object[] params,\n                     _inMemOrdering = _parser.eval(_exps[0].orderingClauses,\n                         (ExpressionStoreQuery) q, factory, _meta);\n                 }\n-\n-                // use the parsed ordering expression to extract the ordering\n-                // value\n-                Val val = (Val) _inMemOrdering[orderIndex];\n-                return val.evaluate(resultObject, resultObject,\n-                    q.getContext().getStoreContext(), params);\n             }\n+\n+            // use the parsed ordering expression to extract the ordering value\n+            Val val = (Val) _inMemOrdering[orderIndex];\n+            return val.evaluate(resultObject, resultObject,\n+                q.getContext().getStoreContext(), params);\n         }\n \n         public Class[] getProjectionTypes(StoreQuery q) {\n-            if (_exps[0].projections.length == 0)\n-                return StoreQuery.EMPTY_CLASSES;\n-\n-            synchronized (this) {\n-                if (_projTypes == null) {\n-                    // delay creating this array until it is requested b/c\n-                    // before execution the types might not be initialized\n-                    _projTypes = new Class[_exps[0].projections.length];\n-                    for (int i = 0; i < _exps[0].projections.length; i++)\n-                        _projTypes[i] = _exps[0].projections[i].getType();\n-\t\t\t\t}\n-\t\t\t\treturn _projTypes;\n-\t\t\t}\n+            return _projTypes;\n \t\t}\n \t}\n }"},{"sha":"12a187b7221d97efe73968624ab2e20f54886650","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlan.java","status":"modified","additions":60,"deletions":5,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlan.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlan.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlan.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,15 +15,10 @@\n  */\n package org.apache.openjpa.persistence.jdbc;\n \n-import org.apache.openjpa.jdbc.kernel.DelegatingJDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.EagerFetchModes;\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.LRSSizes;\n import org.apache.openjpa.jdbc.sql.JoinSyntaxes;\n-import org.apache.openjpa.kernel.DelegatingFetchConfiguration;\n-import org.apache.openjpa.kernel.FetchConfiguration;\n import org.apache.openjpa.persistence.FetchPlan;\n-import org.apache.openjpa.persistence.PersistenceExceptions;\n \n /**\n  * JDBC extensions to the fetch plan.\n@@ -36,27 +31,87 @@\n public interface JDBCFetchPlan\n     extends FetchPlan, EagerFetchModes, LRSSizes, JoinSyntaxes {\n \n+    /**\n+     * Eager fetch mode in loading relations.\n+     * \n+     * @see EagerFetchModes\n+     */\n     public int getEagerFetchMode();\n \n+    /**\n+     * Eager fetch mode in loading relations.\n+     * \n+     * @see EagerFetchModes\n+     */\n     public JDBCFetchPlan setEagerFetchMode(int mode);\n \n+    /**\n+     * Eager fetch mode in loading subclasses.\n+     * \n+     * @see EagerFetchModes\n+     */\n     public int getSubclassFetchMode();\n \n+    /**\n+     * Eager fetch mode in loading subclasses.\n+     * \n+     * @see EagerFetchModes\n+     */\n     public JDBCFetchPlan setSubclassFetchMode(int mode);\n \n+    /**\n+     * Type of JDBC result set to use for query results.\n+     * \n+     * @see java.sql.ResultSet\n+     */\n     public int getResultSetType();\n \n+    /**\n+     * Type of JDBC result set to use for query results.\n+     * \n+     * @see java.sql.ResultSet\n+     */\n     public JDBCFetchPlan setResultSetType(int type);\n \n+    /**\n+     * Result set fetch direction.\n+     * \n+     * @see java.sql.ResultSet\n+     */\n     public int getFetchDirection();\n \n+    /**\n+     * Result set fetch direction.\n+     * \n+     * @see java.sql.ResultSet\n+     */\n     public JDBCFetchPlan setFetchDirection(int direction);\n \n+    /**\n+     * How to determine the size of a large result set.\n+     * \n+     * @see LRSSizes\n+     */\n     public int getLRSSize();\n \n+    /**\n+     * How to determine the size of a large result set.\n+     * \n+     * @see LRSSizes\n+     */\n     public JDBCFetchPlan setLRSSize(int lrsSize);\n \n+    /**\n+     * SQL join syntax.\n+     *\n+     * @see JoinSyntaxes\n+     */\n     public int getJoinSyntax();\n \n+    /**\n+     * SQL join syntax.\n+     *\n+     * @see JoinSyntaxes\n+     */\n     public JDBCFetchPlan setJoinSyntax(int syntax);\n }"},{"sha":"ffc0baec2287827cca8b0dcc00fb47015bf82cd1","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlanImpl.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlanImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlanImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlanImpl.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -31,7 +31,6 @@\n  *\n  * @since 0.4.0\n  * @author Abe White\n- * @published\n  */\n public class JDBCFetchPlanImpl\n     extends FetchPlanImpl"},{"sha":"b351a5c09629d0100c175df9567db805ca83e33e","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java","status":"modified","additions":0,"deletions":5,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,23 +15,18 @@\n  */\n package org.apache.openjpa.persistence;\n \n-import java.util.Iterator;\n import java.util.List;\n \n-import org.apache.openjpa.kernel.DelegatingExtent;\n-\n /**\n  * An extent is a logical view of all instances of a class.\n  *\n  * @author Abe White\n- * @author Pinaki Poddar\n  * @since 0.4.0\n  * @published\n  */\n public interface Extent<T>\n     extends Iterable<T> {\n \n-\n     /**\n      * Delegate.\n      */"},{"sha":"28b65faeaf42f3352014336a1edb4b42f40c417f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ExtentImpl.java","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ExtentImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ExtentImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ExtentImpl.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -24,7 +24,6 @@\n  * An extent is a logical view of all instances of a class.\n  *\n  * @author Abe White\n- * @author Pinaki Poddar\n  * @since 0.4.1\n  * @nojavadoc\n  */\n@@ -35,7 +34,6 @@\n     private final DelegatingExtent _extent;\n     private FetchPlan _fetch = null;\n \n-\n     /**\n      * Constructor; supply delegate.\n      */"},{"sha":"26046157933ea145bfd8cd4ec01266fd65c486fb","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java","status":"modified","additions":1,"deletions":4,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,13 +15,9 @@\n  */\n package org.apache.openjpa.persistence;\n \n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n-import java.util.Iterator;\n import javax.persistence.LockModeType;\n \n-import org.apache.openjpa.kernel.DelegatingFetchConfiguration;\n import org.apache.openjpa.kernel.FetchConfiguration;\n import org.apache.openjpa.meta.FetchGroup;\n \n@@ -120,6 +116,7 @@\n      * use when loading objects.\n      */\n     public FetchPlan addFetchGroups(String... groups);\n+\n     /**\n      * Adds <code>groups</code> to the set of fetch group names to\n      * use when loading objects."},{"sha":"e7cbee202a7a1ec165bb7175626924302766b589","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanImpl.java","status":"modified","additions":0,"deletions":153,"changes":153,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanImpl.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -23,7 +23,6 @@\n \n import org.apache.openjpa.kernel.DelegatingFetchConfiguration;\n import org.apache.openjpa.kernel.FetchConfiguration;\n-import org.apache.openjpa.meta.FetchGroup;\n \n /**\n  * Implements FetchPlan via delegation to FetchConfiguration.\n@@ -62,280 +61,148 @@ public FetchConfiguration getDelegate() {\n         return _fetch.getDelegate();\n     }\n \n-    /**\n-     * The maximum fetch depth when loading an object.\n-     */\n     public int getMaxFetchDepth() {\n         return _fetch.getMaxFetchDepth();\n     }\n \n-    /**\n-     * The maximum fetch depth when loading an object.\n-     */\n     public FetchPlan setMaxFetchDepth(int depth) {\n         _fetch.setMaxFetchDepth(depth);\n         return this;\n     }\n \n-    /**\n-     * Return the fetch batch size for large result set support.\n-     * Defaults to the\t<code>openjpa.FetchBatchSize</code> setting. Note\n-     * that this property will be ignored under some data stores.\n-     */\n     public int getFetchBatchSize() {\n         return _fetch.getFetchBatchSize();\n     }\n \n-    /**\n-     * Set the fetch batch size for large result set support.\n-     * Defaults to the\t<code>openjpa.FetchBatchSize</code> setting. Note\n-     * that this property will be ignored under some data stores.\n-     */\n     public FetchPlan setFetchBatchSize(int fetchBatchSize) {\n         _fetch.setFetchBatchSize(fetchBatchSize);\n         return this;\n     }\n \n-    /**\n-     * Return whether or not query caching is enabled. If this returns\n-     * <code>true</code> but the datacache plugin is not installed, caching\n-     * will not be enabled. If this\n-     * returns <code>false</code>, query caching will not be used\n-     * even if the datacache plugin is installed.\n-     */\n     public boolean getQueryResultCache() {\n         return _fetch.getQueryCache();\n     }\n \n-    /**\n-     * Control whether or not query caching is enabled. This has no effect\n-     * if the datacache plugin is not installed, or if the query cache size\n-     * is set to zero.\n-     */\n     public FetchPlan setQueryResultCache(boolean cache) {\n         _fetch.setQueryCache(cache);\n         return this;\n     }\n \n-    /**\n-     * Returns the names of the fetch groups that this component will use\n-     * when loading objects. Defaults to the\n-     * <code>org.apache.openjpa.FetchGroups</code> setting.\n-     */\n     public Collection<String> getFetchGroups() {\n         return _fetch.getFetchGroups();\n     }\n \n-    /**\n-     * Adds <code>group</code> to the set of fetch group to\n-     * use when loading objects.\n-     */\n     public FetchPlan addFetchGroup(String group) {\n         _fetch.addFetchGroup(group);\n         return this;\n     }\n \n-    /**\n-     * Adds <code>groups</code> to the set of fetch group names to\n-     * use when loading objects.\n-     */\n     public FetchPlan addFetchGroups(String... groups) {\n         return addFetchGroups(Arrays.asList(groups));\n     }\n \n-    /**\n-     * Adds <code>groups</code> to the set of fetch group names to\n-     * use when loading objects.\n-     */\n     public FetchPlan addFetchGroups(Collection groups) {\n         _fetch.addFetchGroups(groups);\n         return this;\n     }\n \n-    /**\n-     * Remove the given fetch group.\n-     */\n     public FetchPlan removeFetchGroup(String group) {\n         _fetch.removeFetchGroup(group);\n         return this;\n     }\n \n-    /**\n-     * Removes <code>groups</code> from the set of fetch group names\n-     * to use when loading objects.\n-     */\n     public FetchPlan removeFetchGroups(String... groups) {\n         return removeFetchGroups(Arrays.asList(groups));\n     }\n \n-    /**\n-     * Removes <code>groups</code> from the set of fetch group names\n-     * to use when loading objects.\n-     */\n     public FetchPlan removeFetchGroups(Collection groups) {\n         _fetch.removeFetchGroups(groups);\n         return this;\n     }\n \n-    /**\n-     * Clears the set of fetch group names to use wen loading\n-     * data. After this operation is invoked, only those fields in\n-     * the default fetch group (and any requested field) will be\n-     * loaded when loading an object.\n-     */\n     public FetchPlan clearFetchGroups() {\n         _fetch.clearFetchGroups();\n         return this;\n     }\n \n-    /**\n-     * Resets the set of fetch groups to the list in the global configuration.\n-     */\n     public FetchPlan resetFetchGroups() {\n         _fetch.resetFetchGroups();\n         return this;\n     }\n \n-    /**\n-     * Returns the fully qualified names of the fields that this component\n-     * will use when loading objects. Defaults to the empty set.\n-     */\n     public Collection<String> getFields() {\n         return (Collection<String>) _fetch.getFields();\n     }\n \n-    /**\n-     * Return true if the given field has been added.\n-     */\n     public boolean hasField(String field) {\n         return _fetch.hasField(field);\n     }\n \n-    /**\n-     * Return true if the given field has been added.\n-     */\n     public boolean hasField(Class cls, String field) {\n         return hasField(toFieldName(cls, field));\n     }\n \n-    /**\n-     * Adds <code>field</code> to the set of fully-qualified field names to\n-     * use when loading objects.\n-     */\n     public FetchPlan addField(String field) {\n         _fetch.addField(field);\n         return this;\n     }\n \n-    /**\n-     * Adds <code>field</code> to the set of field names to\n-     * use when loading objects.\n-     */\n     public FetchPlan addField(Class cls, String field) {\n         return addField(toFieldName(cls, field));\n     }\n \n-    /**\n-     * Adds <code>fields</code> to the set of fully-qualified field names to\n-     * use when loading objects.\n-     */\n     public FetchPlan addFields(String... fields) {\n         return addFields(Arrays.asList(fields));\n     }\n \n-    /**\n-     * Adds <code>fields</code> to the set of field names to\n-     * use when loading objects.\n-     */\n     public FetchPlan addFields(Class cls, String... fields) {\n         return addFields(cls, Arrays.asList(fields));\n     }\n \n-    /**\n-     * Adds <code>fields</code> to the set of fully-qualified field names to\n-     * use when loading objects.\n-     */\n     public FetchPlan addFields(Collection fields) {\n         _fetch.addFields(fields);\n         return this;\n     }\n \n-    /**\n-     * Adds <code>fields</code> to the set of field names to\n-     * use when loading objects.\n-     */\n     public FetchPlan addFields(Class cls, Collection fields) {\n         return addFields(toFieldNames(cls, fields));\n     }\n \n-    /**\n-     * Remove the given fully-qualified field.\n-     */\n     public FetchPlan removeField(String field) {\n         _fetch.removeField(field);\n         return this;\n     }\n \n-    /**\n-     * Remove the given field.\n-     */\n     public FetchPlan removeField(Class cls, String field) {\n         return removeField(toFieldName(cls, field));\n     }\n \n-    /**\n-     * Removes <code>fields</code> from the set of fully-qualified field names\n-     * to use when loading objects.\n-     */\n     public FetchPlan removeFields(String... fields) {\n         return removeFields(Arrays.asList(fields));\n     }\n \n-    /**\n-     * Removes <code>fields</code> from the set of field names\n-     * to use when loading objects.\n-     */\n     public FetchPlan removeFields(Class cls, String... fields) {\n         return removeFields(cls, Arrays.asList(fields));\n     }\n \n-    /**\n-     * Removes <code>fields</code> from the set of fully-qualified field names\n-     * to use when loading objects.\n-     */\n     public FetchPlan removeFields(Collection fields) {\n         _fetch.removeFields(fields);\n         return this;\n     }\n \n-    /**\n-     * Removes <code>fields</code> from the set of field names\n-     * to use when loading objects.\n-     */\n     public FetchPlan removeFields(Class cls, Collection fields) {\n         return removeFields(toFieldNames(cls, fields));\n     }\n \n-    /**\n-     * Clears the set of field names to use wen loading\n-     * data. After this operation is invoked, only those fields in\n-     * the configured fetch groups will be loaded when loading an object.\n-     */\n     public FetchPlan clearFields() {\n         _fetch.clearFields();\n         return this;\n     }\n \n-    /**\n-     * Combine the class and field to a fully-qualified field name.\n-     */\n     private static String toFieldName(Class cls, String field) {\n         return cls.getName() + \".\" + field;\n     }\n \n-    /**\n-     * Combine the class and fields to fully-qualified field names.\n-     */\n     private static Collection toFieldNames(Class cls, Collection fields) {\n         if (fields.isEmpty())\n             return fields;\n@@ -345,48 +212,28 @@ private static Collection toFieldNames(Class cls, Collection fields) {\n         return names;\n     }\n \n-    /**\n-     * The number of milliseconds to wait for an object lock, or -1 for no\n-     * limit.\n-     */\n     public int getLockTimeout() {\n         return _fetch.getLockTimeout();\n     }\n \n-    /**\n-     * The number of milliseconds to wait for an object lock, or -1 for no\n-     * limit.\n-     */\n     public FetchPlan setLockTimeout(int timeout) {\n         _fetch.setLockTimeout(timeout);\n         return this;\n     }\n \n-    /**\n-     * The lock level to use for locking loaded objects.\n-     */\n     public LockModeType getReadLockMode() {\n         return EntityManagerImpl.fromLockLevel(_fetch.getReadLockLevel());\n     }\n \n-    /**\n-     * The lock level to use for locking loaded objects.\n-     */\n     public FetchPlan setReadLockMode(LockModeType mode) {\n         _fetch.setReadLockLevel(EntityManagerImpl.toLockLevel(mode));\n         return this;\n     }\n \n-    /**\n-     * The lock level to use for locking dirtied objects.\n-     */\n     public LockModeType getWriteLockMode() {\n         return EntityManagerImpl.fromLockLevel(_fetch.getWriteLockLevel());\n     }\n \n-    /**\n-     * The lock level to use for locking dirtied objects.\n-     */\n     public FetchPlan setWriteLockMode(LockModeType mode) {\n         _fetch.setWriteLockLevel(EntityManagerImpl.toLockLevel(mode));\n         return this;"},{"sha":"5616f0ea0c3ba29bbaf8197177cfa79eb99b3213","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Generator.java","status":"modified","additions":0,"deletions":4,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Generator.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Generator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Generator.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,16 +15,12 @@\n  */\n package org.apache.openjpa.persistence;\n \n-import org.apache.openjpa.kernel.DelegatingSeq;\n import org.apache.openjpa.kernel.Seq;\n-import org.apache.openjpa.kernel.StoreContext;\n-import org.apache.openjpa.meta.ClassMetaData;\n \n /**\n  * Represents a store sequence.\n  *\n  * @author Abe White\n- * @author Pinaki Poddar\n  * @since 0.4.1\n  * @published\n  */"},{"sha":"7ec07bf29708687be1ca8b0b60cca97e8d8d6309","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/GeneratorImpl.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/GeneratorImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/GeneratorImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/GeneratorImpl.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -24,7 +24,6 @@\n  * Represents a store sequence.\n  *\n  * @author Abe White\n- * @author Pinaki Poddar\n  * @since 0.4.1\n  * @nojavadoc\n  */"},{"sha":"cfeb7ebacd54bf680d40b4dd681ea1a79a508d2d","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java","status":"modified","additions":3,"deletions":6,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -152,8 +152,7 @@ public static OpenJPAEntityManagerFactory cast(EntityManagerFactory emf) {\n     public static OpenJPAEntityManager cast(EntityManager em) {\n         if (em instanceof OpenJPAEntityManager)\n             return (OpenJPAEntityManager) em;\n-        else\n-            return (OpenJPAEntityManager) em.getDelegate();\n+        return (OpenJPAEntityManager) em.getDelegate();\n     }\n \n     /**\n@@ -181,8 +180,7 @@ public static OpenJPAEntityManagerFactory getEntityManagerFactory() {\n     public static OpenJPAEntityManagerFactory getEntityManagerFactory(Map map) {\n         ConfigurationProvider cp = new MapConfigurationProvider(map);\n         try {\n-            return toEntityManagerFactory(Bootstrap.getBrokerFactory\n-                (cp, null));\n+            return toEntityManagerFactory(Bootstrap.getBrokerFactory(cp, null));\n         } catch (Exception e) {\n             throw PersistenceExceptions.toPersistenceException(e);\n         }\n@@ -257,8 +255,7 @@ public static OpenJPAEntityManager getEntityManager(Object o) {\n             if (o instanceof PersistenceCapable)\n                 return toEntityManager((Broker) ((PersistenceCapable) o).\n                     pcGetGenericContext());\n-            else\n-                return null;\n+            return null;\n         } catch (Exception e) {\n             throw PersistenceExceptions.toPersistenceException(e);\n         }"},{"sha":"5b5c6aa5966d5268221956756e2c60125613f50a","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderExtension.java","status":"modified","additions":1,"deletions":3,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderExtension.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderExtension.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderExtension.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -11,16 +11,14 @@\n  * @nojavadoc\r\n  */\r\n public interface PersistenceProviderExtension {\r\n+\r\n \t/**\r\n \t * Gets the Configuration Provider implementation for this receiver.\r\n-\t * \r\n \t */\r\n \tpublic ConfigurationProviderImpl newConfigurationProviderImpl();\r\n \t\r\n \t/**\r\n \t * Gets the EntityManagerFactory given a Broker Factory.\r\n-\t * @param factory\r\n-\r\n \t */\r\n \tpublic OpenJPAEntityManagerFactory toEntityManagerFactory(BrokerFactory \r\n \t\tfactory);\r"},{"sha":"f6d1c920c9f4ce9fa89d45ecf0fabb678b0b8253","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCache.java","status":"modified","additions":0,"deletions":4,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCache.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCache.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,13 +15,9 @@\n  */\n package org.apache.openjpa.persistence;\n \n-import java.util.Collections;\n import javax.persistence.Query;\n \n-import org.apache.openjpa.datacache.DelegatingQueryCache;\n import org.apache.openjpa.datacache.QueryCache;\n-import org.apache.openjpa.datacache.QueryKey;\n-import org.apache.openjpa.datacache.TypesChangedEvent;\n \n /**\n  * Query result cache."},{"sha":"662530d9953ae95087719c3f450c69358ca7230f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCacheImpl.java","status":"modified","additions":0,"deletions":19,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCacheImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCacheImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCacheImpl.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -27,7 +27,6 @@\n  * Implements Query result cache via delegation to QueryCache.\n  *\n  * @author Abe White\n- * @author Pinaki Poddar\n  * @since 0.4.1\n  * @nojavadoc\n  */\n@@ -44,47 +43,29 @@ public QueryResultCacheImpl(QueryCache cache) {\n             PersistenceExceptions.TRANSLATOR);\n     }\n \n-    /**\n-     * Delegate.\n-     */\n     public QueryCache getDelegate() {\n         return _cache.getDelegate();\n     }\n \n-    /**\n-     * Pin the given query's result to the cache.\n-     */\n     public void pin(Query q) {\n         if (_cache.getDelegate() != null)\n             _cache.pin(toQueryKey(q));\n     }\n \n-    /**\n-     * Unpin a previously-pinned query result.\n-     */\n     public void unpin(Query q) {\n         if (_cache.getDelegate() != null)\n             _cache.unpin(toQueryKey(q));\n     }\n \n-    /**\n-     * Evict a query result from the cache.\n-     */\n     public void evict(Query q) {\n         if (_cache.getDelegate() != null)\n             _cache.remove(toQueryKey(q));\n     }\n \n-    /**\n-     * Clear the cache.\n-     */\n     public void evictAll() {\n         _cache.clear();\n     }\n \n-    /**\n-     * Evict all result for queries involving the given class.\n-     */\n     public void evictAll(Class cls) {\n         _cache.onTypesChanged(new TypesChangedEvent(this,\n             Collections.singleton(cls)));"},{"sha":"612e42d64844b55023860c92f1531915cfd5fbde","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java","status":"modified","additions":0,"deletions":6,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -15,20 +15,14 @@\n  */\n package org.apache.openjpa.persistence;\n \n-import java.util.Arrays;\n-import java.util.BitSet;\n import java.util.Collection;\n \n import org.apache.openjpa.datacache.DataCache;\n-import org.apache.openjpa.datacache.DelegatingDataCache;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.meta.MetaDataRepository;\n \n /**\n  * Represents the L2 cache over the data store.\n  *\n  * @author Abe White\n- * @author Pinaki Poddar\n  * @since 0.4.1\n  * @published\n  */"},{"sha":"4c8c0dd0645813cecc705aa6deaffc516235af7b","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCacheImpl.java","status":"modified","additions":10,"deletions":15,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCacheImpl.java","raw_url":"https://github.com/apache/openjpa/raw/7e30623c7b5a30c2a9c9761736d8d493e2a8c968/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCacheImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCacheImpl.java?ref=7e30623c7b5a30c2a9c9761736d8d493e2a8c968","patch":"@@ -29,7 +29,6 @@\n  * Implements the L2 cache over the data store via delegation to DataCache.\n  *\n  * @author Abe White\n- * @author Pinaki Poddar\n  * @since 0.4.1\n  * @nojavadoc\n  */\n@@ -54,9 +53,8 @@ public DataCache getDelegate() {\n     }\n \n     public boolean contains(Class cls, Object oid) {\n-        return _cache.getDelegate() != null\n-            && _cache.contains(OpenJPAPersistence.toOpenJPAObjectId\n-            (getMetaData(cls), oid));\n+        return _cache.getDelegate() != null && _cache.contains\n+            (OpenJPAPersistence.toOpenJPAObjectId(getMetaData(cls), oid));\n     }\n \n     public boolean containsAll(Class cls, Object... oids) {\n@@ -77,8 +75,8 @@ public boolean containsAll(Class cls, Collection oids) {\n \n     public void pin(Class cls, Object oid) {\n         if (_cache.getDelegate() != null)\n-            _cache.pin(\n-                OpenJPAPersistence.toOpenJPAObjectId(getMetaData(cls), oid));\n+            _cache.pin(OpenJPAPersistence.toOpenJPAObjectId(getMetaData(cls), \n+                oid));\n     }\n \n     public void pinAll(Class cls, Object... oids) {\n@@ -87,9 +85,8 @@ public void pinAll(Class cls, Object... oids) {\n \n     public void pinAll(Class cls, Collection oids) {\n         if (_cache.getDelegate() != null)\n-            _cache\n-                .pinAll(OpenJPAPersistence.toOpenJPAObjectIds(getMetaData(cls),\n-                    oids));\n+            _cache.pinAll(OpenJPAPersistence.toOpenJPAObjectIds\n+                (getMetaData(cls), oids));\n     }\n \n     public void unpin(Class cls, Object oid) {\n@@ -104,9 +101,8 @@ public void unpinAll(Class cls, Object... oids) {\n \n     public void unpinAll(Class cls, Collection oids) {\n         if (_cache.getDelegate() != null)\n-            _cache.unpinAll(\n-                OpenJPAPersistence.toOpenJPAObjectIds(getMetaData(cls),\n-                    oids));\n+            _cache.unpinAll(OpenJPAPersistence.toOpenJPAObjectIds\n+                (getMetaData(cls), oids));\n     }\n \n     public void evict(Class cls, Object oid) {\n@@ -121,9 +117,8 @@ public void evictAll(Class cls, Object... oids) {\n \n     public void evictAll(Class cls, Collection oids) {\n         if (_cache.getDelegate() != null)\n-            _cache.removeAll(\n-                OpenJPAPersistence.toOpenJPAObjectIds(getMetaData(cls),\n-                    oids));\n+            _cache.removeAll(OpenJPAPersistence.toOpenJPAObjectIds\n+                (getMetaData(cls), oids));\n     }\n \n     public void evictAll() {"}]}

