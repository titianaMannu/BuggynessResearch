{"sha":"7eb317e488993e2f6e0acdd7843abb4833181b2e","node_id":"MDY6Q29tbWl0MjA2MzY0OjdlYjMxN2U0ODg5OTNlMmY2ZTBhY2RkNzg0M2FiYjQ4MzMxODFiMmU=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2011-03-22T18:23:28Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2011-03-22T18:23:28Z"},"message":"OPENJPA-1928: Fix @Factory method resolution when name is ambiguous. Patch contributed by Edward Sargisson.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@1084280 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5eea6cae9899982e3868f1947ef4975365256c1e","url":"https://api.github.com/repos/apache/openjpa/git/trees/5eea6cae9899982e3868f1947ef4975365256c1e"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/7eb317e488993e2f6e0acdd7843abb4833181b2e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/7eb317e488993e2f6e0acdd7843abb4833181b2e","html_url":"https://github.com/apache/openjpa/commit/7eb317e488993e2f6e0acdd7843abb4833181b2e","comments_url":"https://api.github.com/repos/apache/openjpa/commits/7eb317e488993e2f6e0acdd7843abb4833181b2e/comments","author":null,"committer":null,"parents":[{"sha":"2cfb4f62322444507f19bb79477fa5c85a2e78c3","url":"https://api.github.com/repos/apache/openjpa/commits/2cfb4f62322444507f19bb79477fa5c85a2e78c3","html_url":"https://github.com/apache/openjpa/commit/2cfb4f62322444507f19bb79477fa5c85a2e78c3"}],"stats":{"total":533,"additions":531,"deletions":2},"files":[{"sha":"74100a6ac3ed429d9648ad3f17c26881bb44b81d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","status":"modified","additions":148,"deletions":2,"changes":150,"blob_url":"https://github.com/apache/openjpa/blob/7eb317e488993e2f6e0acdd7843abb4833181b2e/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/7eb317e488993e2f6e0acdd7843abb4833181b2e/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java?ref=7eb317e488993e2f6e0acdd7843abb4833181b2e","patch":"@@ -1571,7 +1571,7 @@ public Member getFactoryMethod() {\n                         _factMethod = getDeclaredType().getConstructor\n                             (new Class[]{ getType() });\n                     else\n-                        _factMethod = findMethod(_factName);\n+                    \t_factMethod = findMethodByNameAndType(_factName, getType());\n                 } catch (OpenJPAException ke) {\n                     throw ke;\n                 } catch (Exception e) {\n@@ -1597,6 +1597,22 @@ public Member getFactoryMethod() {\n      * @return the method for invocation\n      */\n     private Method findMethod(String method) {\n+    \treturn findMethodByNameAndType(method, null);\n+    }\n+    \n+    /**\n+     * Find the method for the specified name and type. Possible forms are:\n+     * <ul>\n+     * <li>toExternalString</li>\n+     * <li>MyFactoryClass.toExternalString</li>\n+     * <li>com.company.MyFactoryClass.toExternalString</li>\n+     * </ul>\n+     *\n+     * @param method the name of the method to locate\n+     * @param type The type of the parameter which will pass the object from the database.\n+     * @return the method for invocation\n+     */\n+    private Method findMethodByNameAndType(String method, Class<?> type) {\n         if (StringUtils.isEmpty(method))\n             return null;\n \n@@ -1629,7 +1645,12 @@ else if (clsName.equals(owner.getName())\n                 if (Modifier.isStatic(methods[i].getModifiers())\n                     && (params.length == 1 || (params.length == 2\n                     && isStoreContextParameter(params[1]))))\n-                    return methods[i];\n+                \t\n+                \tif (type == null) {\n+                \t\treturn methods[i];\n+                \t} else if (isConvertibleToByMethodInvocationConversion(type, params[0])) {\n+                \t\treturn methods[i];\n+                \t}\n                 if (!Modifier.isStatic(methods[i].getModifiers())\n                     && (params.length == 0 || (params.length == 1\n                     && isStoreContextParameter(params[0]))))\n@@ -1640,6 +1661,131 @@ else if (clsName.equals(owner.getName())\n         return null;\n     }\n \n+\t/**\n+\t * Test if the {@code sourceType} is convertible to the {@code destType}.\n+\t * Convertible follows the rules in Java Language Specification, 3rd Ed, s5.3 and means that:\n+\t * <ul>\n+\t * <li>{@code sourceType} and {@code destType} are the same type (identity conversion)</li>\n+\t * <li>For primitive types: that {@code sourceType} can be widened into {@code destType} \n+\t * or that {@code sourceType} can be boxed into a class assignable to {@code destType}.</li>\n+\t * <li>For non-primitive types: that the {@code sourceType} can be unboxed into a primitive\n+\t *  that is the same as, or can be widened into,\n+\t * {@code destType} or {@code sourceType} can be assigned to {@code destType}.</li> \n+\t * \n+\t * @return True iff the conditions above are true.\n+\t */\n+\tprivate boolean isConvertibleToByMethodInvocationConversion(Class<?> sourceType, Class<?> destType) {\n+\t\t// Note that class.isAssignableFrom is a widening reference conversion test\n+\t\tif (sourceType.isPrimitive()) {\n+\t\t\treturn isConvertibleToByIdentityPrimitiveConversion(sourceType, destType) \n+\t\t\t\t|| isConvertibleToByWideningPrimitive(sourceType, destType) \n+\t\t\t\t|| destType.isAssignableFrom(box(sourceType));\n+\t\t} else {\n+\t\t\t// Note that unbox will return null if the sourceType is not a wrapper.  \n+\t\t\t// The identity primitive conversion and widening primitive handle this.\n+\t\t\treturn isConvertibleToByIdentityPrimitiveConversion(unbox(sourceType), destType) \n+\t\t\t|| isConvertibleToByWideningPrimitive(unbox(sourceType), destType) \n+\t\t\t|| destType.isAssignableFrom(sourceType);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * @return The results of unboxing {@code sourceType} following Java Language Specification, 3rd Ed, s5.1.8 \n+\t */\n+\tprivate Class<?> unbox(Class<?> sourceType) {\n+\t\tif (sourceType == java.lang.Boolean.class) {\n+\t\t\treturn java.lang.Boolean.TYPE;\n+\t\t} else if (sourceType == java.lang.Byte.class) {\n+\t\t\treturn java.lang.Byte.TYPE;\n+\t\t} else if (sourceType == java.lang.Short.class) {\n+\t\t\treturn java.lang.Short.TYPE;\n+\t\t} else if (sourceType == java.lang.Character.class) {\n+\t\t\treturn java.lang.Character.TYPE;\n+\t\t} else if (sourceType == java.lang.Integer.class) {\n+\t\t\treturn java.lang.Integer.TYPE;\n+\t\t} else if (sourceType == java.lang.Long.class) {\n+\t\t\treturn java.lang.Long.TYPE;\n+\t\t} else if (sourceType == java.lang.Float.class) {\n+\t\t\treturn java.lang.Float.TYPE;\n+\t\t} else if (sourceType == java.lang.Double.class) {\n+\t\t\treturn java.lang.Double.TYPE;\n+\t\t} else {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @return The results of unboxing {@code sourceType} following Java Language Specification, 3rd Ed, s5.1.7 \n+\t */\n+\tprivate Class<?> box(Class<?> sourceType) {\n+\t\tif (sourceType.isPrimitive()) {\n+\t\t\tif (sourceType == java.lang.Boolean.TYPE) {\n+\t\t\t\treturn java.lang.Boolean.class;\n+\t\t\t} else if (sourceType == java.lang.Byte.TYPE) {\n+\t\t\t\treturn java.lang.Byte.class;\n+\t\t\t} else if (sourceType == java.lang.Short.TYPE) {\n+\t\t\t\treturn java.lang.Short.class;\n+\t\t\t} else if (sourceType == java.lang.Character.TYPE) {\n+\t\t\t\treturn java.lang.Character.class;\n+\t\t\t} else if (sourceType == java.lang.Integer.TYPE) {\n+\t\t\t\treturn java.lang.Integer.class;\n+\t\t\t} else if (sourceType == java.lang.Long.TYPE) {\n+\t\t\t\treturn java.lang.Long.class;\n+\t\t\t} else if (sourceType == java.lang.Float.TYPE) {\n+\t\t\t\treturn java.lang.Float.class;\n+\t\t\t} else if (sourceType == java.lang.Double.TYPE) {\n+\t\t\t\treturn java.lang.Double.class;\n+\t\t\t} \n+\t\t\treturn null;  // Should never be reached because all primitives are accounted for above.\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\"Cannot box a type that is not a primitive.\");\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * @return true iff {@sourceType} can be converted by a widening primitive conversion\n+\t *  following Java Language Specification, 3rd Ed, s5.1.2 \n+\t */\n+\tprivate boolean isConvertibleToByWideningPrimitive(Class<?> sourceType, Class<?> destType) {\n+\t\t// Widening conversion following Java Language Specification, s5.1.2.\n+\t\tif (sourceType == java.lang.Byte.TYPE) {\n+\t\t\treturn destType == java.lang.Short.TYPE ||\n+\t\t\t    destType == java.lang.Integer.TYPE ||\n+\t\t\t    destType == java.lang.Long.TYPE ||\n+\t\t\t    destType == java.lang.Float.TYPE ||\n+\t\t\t    destType == java.lang.Double.TYPE;\n+\t\t} else if (sourceType == java.lang.Short.TYPE) {\n+\t\t\treturn destType == java.lang.Integer.TYPE ||\n+\t\t\t\tdestType == java.lang.Long.TYPE ||\n+\t\t\t\tdestType == java.lang.Float.TYPE ||\n+\t\t\t\tdestType == java.lang.Double.TYPE;\n+\t\t} else if (sourceType == java.lang.Character.TYPE) {\n+\t\t\treturn destType == java.lang.Integer.TYPE || \n+\t\t\t  \tdestType == java.lang.Long.TYPE || \n+\t\t\t  \tdestType == java.lang.Float.TYPE || \n+\t\t\t  \tdestType == java.lang.Double.TYPE;\n+\t\t} else if (sourceType == java.lang.Integer.TYPE) {\n+\t\t\treturn destType == java.lang.Long.TYPE ||\n+\t\t\t  \tdestType == java.lang.Float.TYPE ||\n+\t\t\t  \tdestType == java.lang.Double.TYPE;\n+\t\t} else if (sourceType == java.lang.Long.TYPE) {\n+\t\t\treturn destType == java.lang.Float.TYPE ||\n+\t\t\t  \tdestType == java.lang.Double.TYPE;\n+\t\t} else if (sourceType == java.lang.Float.TYPE) {\n+\t\t\treturn destType == java.lang.Double.TYPE;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Returns true iff the sourceType is a primitive that can be converted to \n+\t * destType using an identity conversion - i.e. sourceType and destType are the same type.\n+\t * following Java Language Specification, 3rd Ed, s5.1.1 \n+\t */\n+\tprivate boolean isConvertibleToByIdentityPrimitiveConversion(Class<?> sourceType, Class<?> destType) {\n+\t\treturn sourceType != null && sourceType.isPrimitive() && sourceType == destType;\n+\t}\n+\t\n     /**\n      * Return true if the given type is a store context type; we can't\n      * use the standard <code>isAssignableFrom</code> because of classloader"},{"sha":"3f96b83cfd67f56f1b6ee60c8330e1778cbcca0f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/TestFactoryMethod.java","status":"added","additions":181,"deletions":0,"changes":181,"blob_url":"https://github.com/apache/openjpa/blob/7eb317e488993e2f6e0acdd7843abb4833181b2e/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/TestFactoryMethod.java","raw_url":"https://github.com/apache/openjpa/raw/7eb317e488993e2f6e0acdd7843abb4833181b2e/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/TestFactoryMethod.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/TestFactoryMethod.java?ref=7eb317e488993e2f6e0acdd7843abb4833181b2e","patch":"@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.meta;\n+\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+\n+import javax.persistence.EntityManager;\n+\n+import org.apache.openjpa.kernel.Broker;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.persistence.JPAFacadeHelper;\n+import org.apache.openjpa.persistence.common.utils.AbstractTestCase;\n+import org.apache.openjpa.persistence.meta.common.apps.MetaTest7;\n+\n+/**\n+ * <p>\n+ * Tests the {@code getFactoryMethod} method\n+ * </p>\n+ * \n+ */\n+public class TestFactoryMethod extends AbstractTestCase {\n+\n+    private MetaDataRepository _repos = null;\n+    private ClassMetaData _metaTest7 = null;\n+\n+    public TestFactoryMethod(String test) {\n+        super(test, \"metacactusapp\");\n+    }\n+\n+    public void setUp() throws Exception {\n+        _repos = getRepository();\n+        _metaTest7 = _repos.getMetaData(MetaTest7.class, null, true);\n+    }\n+\n+    protected MetaDataRepository getRepository() throws Exception {\n+        // return new OpenJPAConfigurationImpl().newMetaDataRepositoryInstance();\n+        // return getConfiguration().newMetaDataRepositoryInstance();\n+        EntityManager em = currentEntityManager();\n+        Broker broker = JPAFacadeHelper.toBroker(em);\n+        return broker.getConfiguration().newMetaDataRepositoryInstance();\n+    }\n+\n+    /**\n+     * Tests that getFactoryMethod() identifies the method using both the name and the type. This is required when the\n+     * factory method is overloaded - i.e. same name but different types.\n+     */\n+    public void testFactoryMatchesByType() {\n+        FieldMetaData fieldMetaData = _metaTest7.getField(\"status\");\n+\n+        Member factoryMember = fieldMetaData.getFactoryMethod();\n+\n+        assertEquals(\"valueOf\", factoryMember.getName());\n+\n+        Method factoryMethod = (Method) factoryMember;\n+\n+        Class<?>[] parameterTypes = factoryMethod.getParameterTypes();\n+        assertEquals(\"Both valueOf methods take just 1 parameter\", 1, parameterTypes.length);\n+        assertEquals(\"Need to match the type of the underlying field \" + \"or the factory method will fail when called\",\n+            String.class, parameterTypes[0]);\n+    }\n+\n+    /**\n+     * Tests that getFactoryMethod() identifies the method using both the name and the type. This is required when the\n+     * factory method is overloaded - i.e. same name but different types. This tests that an Externalizer returning int\n+     * can be matched with a Factory taking long (a widening conversion).\n+     */\n+    public void testFactoryMatchesByTypeWidening() {\n+        FieldMetaData fieldMetaData = _metaTest7.getField(\"intLongStatus\");\n+\n+        Member factoryMember = fieldMetaData.getFactoryMethod();\n+\n+        assertEquals(\"valueOf\", factoryMember.getName());\n+\n+        Method factoryMethod = (Method) factoryMember;\n+\n+        Class<?>[] parameterTypes = factoryMethod.getParameterTypes();\n+        assertEquals(\"Both valueOf methods take just 1 parameter\", 1, parameterTypes.length);\n+        assertEquals(\"Need to match the type of the underlying field \" + \"or the factory method will fail when called\",\n+            long.class, parameterTypes[0]);\n+    }\n+\n+    /**\n+     * Tests that getFactoryMethod() identifies the method using both the name and the type. This is required when the\n+     * factory method is overloaded - i.e. same name but different types. This tests that an Externalizer returning int\n+     * can be matched with a Factory taking Integer (a boxing conversion).\n+     */\n+    public void testFactoryMatchesByTypeBoxing() {\n+        FieldMetaData fieldMetaData = _metaTest7.getField(\"intIntegerStatus\");\n+\n+        Member factoryMember = fieldMetaData.getFactoryMethod();\n+\n+        assertEquals(\"valueOf\", factoryMember.getName());\n+\n+        Method factoryMethod = (Method) factoryMember;\n+\n+        Class<?>[] parameterTypes = factoryMethod.getParameterTypes();\n+        assertEquals(\"Both valueOf methods take just 1 parameter\", 1, parameterTypes.length);\n+        assertEquals(\"Need to match the type of the underlying field \" + \"or the factory method will fail when called\",\n+            Integer.class, parameterTypes[0]);\n+    }\n+\n+    /**\n+     * Tests that getFactoryMethod() identifies the method using both the name and the type. This is required when the\n+     * factory method is overloaded - i.e. same name but different types. This tests that an Externalizer returning\n+     * Integer can be matched with a Factory taking Integer (an identity conversion).\n+     */\n+    public void testFactoryMatchesByTypeWrapper() {\n+        FieldMetaData fieldMetaData = _metaTest7.getField(\"integerIntegerStatus\");\n+\n+        Member factoryMember = fieldMetaData.getFactoryMethod();\n+\n+        assertEquals(\"valueOf\", factoryMember.getName());\n+\n+        Method factoryMethod = (Method) factoryMember;\n+\n+        Class<?>[] parameterTypes = factoryMethod.getParameterTypes();\n+        assertEquals(\"Both valueOf methods take just 1 parameter\", 1, parameterTypes.length);\n+        assertEquals(\"Need to match the type of the underlying field \" + \"or the factory method will fail when called\",\n+            Integer.class, parameterTypes[0]);\n+    }\n+\n+    /**\n+     * Tests that getFactoryMethod() identifies the method using both the name and the type. This is required when the\n+     * factory method is overloaded - i.e. same name but different types. This tests that an Externalizer returning\n+     * Integer can be matched with a Factory taking int (an unboxing conversion).\n+     */\n+    public void testFactoryMatchesByTypeUnboxing() {\n+        FieldMetaData fieldMetaData = _metaTest7.getField(\"integerIntStatus\");\n+\n+        Member factoryMember = fieldMetaData.getFactoryMethod();\n+\n+        assertEquals(\"valueOf\", factoryMember.getName());\n+\n+        Method factoryMethod = (Method) factoryMember;\n+\n+        Class<?>[] parameterTypes = factoryMethod.getParameterTypes();\n+        assertEquals(\"Both valueOf methods take just 1 parameter\", 1, parameterTypes.length);\n+        assertEquals(\"Need to match the type of the underlying field \" + \"or the factory method will fail when called\",\n+            int.class, parameterTypes[0]);\n+    }\n+\n+    /**\n+     * Tests that getFactoryMethod() identifies the method using both the name and the type. This is required when the\n+     * factory method is overloaded - i.e. same name but different types. This tests that an Externalizer returning\n+     * Integer can be matched with a Factory taking long (an unboxing conversion following by a widening primitive\n+     * conversion).\n+     */\n+    public void testFactoryMatchesByTypeUnboxingWidening() {\n+        FieldMetaData fieldMetaData = _metaTest7.getField(\"integerLongStatus\");\n+\n+        Member factoryMember = fieldMetaData.getFactoryMethod();\n+\n+        assertEquals(\"valueOf\", factoryMember.getName());\n+\n+        Method factoryMethod = (Method) factoryMember;\n+\n+        Class<?>[] parameterTypes = factoryMethod.getParameterTypes();\n+        assertEquals(\"Both valueOf methods take just 1 parameter\", 1, parameterTypes.length);\n+        assertEquals(\"Need to match the type of the underlying field \" + \"or the factory method will fail when called\",\n+            long.class, parameterTypes[0]);\n+    }\n+}"},{"sha":"fdbab9f3a16cefb75587eae385363e51c0ca30e8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/common/apps/MetaTest7.java","status":"added","additions":202,"deletions":0,"changes":202,"blob_url":"https://github.com/apache/openjpa/blob/7eb317e488993e2f6e0acdd7843abb4833181b2e/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/common/apps/MetaTest7.java","raw_url":"https://github.com/apache/openjpa/raw/7eb317e488993e2f6e0acdd7843abb4833181b2e/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/common/apps/MetaTest7.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/common/apps/MetaTest7.java?ref=7eb317e488993e2f6e0acdd7843abb4833181b2e","patch":"@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.meta.common.apps;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.Table;\n+\n+import org.apache.openjpa.persistence.Externalizer;\n+import org.apache.openjpa.persistence.Factory;\n+import org.apache.openjpa.persistence.Persistent;\n+\n+@Entity\n+@Table(name = \"PER_JDBC_KERN_EMP\")\n+public class MetaTest7 {\n+\n+    public long id;\n+    private MetaTest7Status status;\n+    private MetaTest7IntLongStatus intLongStatus;\n+    private MetaTest7IntIntegerStatus intIntegerStatus;\n+    private MetaTest7IntegerIntegerStatus integerIntegerStatus;\n+    private MetaTest7IntegerIntStatus integerIntStatus;\n+    private MetaTest7IntegerLongStatus integerLongStatus;\n+\n+    @Externalizer(\"getName\")\n+    @Persistent(optional = false)\n+    @Column(name = \"status\")\n+    @Factory(\"valueOf\")\n+    public MetaTest7Status getStatus() {\n+        return status;\n+    }\n+\n+    public void setStatus(MetaTest7Status status) {\n+        this.status = status;\n+    }\n+\n+    @Externalizer(\"getName\")\n+    @Persistent(optional = false)\n+    @Column(name = \"intLongStatus\")\n+    @Factory(\"valueOf\")\n+    public MetaTest7IntLongStatus getIntLongStatus() {\n+        return intLongStatus;\n+    }\n+\n+    public void setIntLongStatus(MetaTest7IntLongStatus status) {\n+        this.intLongStatus = status;\n+    }\n+\n+    @Externalizer(\"getName\")\n+    @Persistent(optional = false)\n+    @Column(name = \"intIntegerStatus\")\n+    @Factory(\"valueOf\")\n+    public MetaTest7IntIntegerStatus getIntIntegerStatus() {\n+        return intIntegerStatus;\n+    }\n+\n+    public void setIntIntegerStatus(MetaTest7IntIntegerStatus status) {\n+        this.intIntegerStatus = status;\n+    }\n+\n+    @Externalizer(\"getName\")\n+    @Persistent(optional = false)\n+    @Column(name = \"integerIntegerStatus\")\n+    @Factory(\"valueOf\")\n+    public MetaTest7IntegerIntegerStatus getIntegerIntegerStatus() {\n+        return integerIntegerStatus;\n+    }\n+\n+    public void setIntegerIntegerStatus(MetaTest7IntegerIntegerStatus status) {\n+        this.integerIntegerStatus = status;\n+    }\n+\n+    @Externalizer(\"getName\")\n+    @Persistent(optional = false)\n+    @Column(name = \"integerIntStatus\")\n+    @Factory(\"valueOf\")\n+    public MetaTest7IntegerIntStatus getIntegerIntStatus() {\n+        return integerIntStatus;\n+    }\n+\n+    public void setIntegerIntStatus(MetaTest7IntegerIntStatus status) {\n+        this.integerIntStatus = status;\n+    }\n+\n+    @Externalizer(\"getName\")\n+    @Persistent(optional = false)\n+    @Column(name = \"integerLongStatus\")\n+    @Factory(\"valueOf\")\n+    public MetaTest7IntegerLongStatus getIntegerLongStatus() {\n+        return integerLongStatus;\n+    }\n+\n+    public void setIntegerLongStatus(MetaTest7IntegerLongStatus status) {\n+        this.integerLongStatus = status;\n+    }\n+    \n+    static class MetaTest7IntegerIntegerStatus {\n+\n+        public Integer getName() {\n+            return 0;\n+        }\n+\n+        public static MetaTest7IntegerIntegerStatus valueOf(final Integer ordinal) {\n+            return null;\n+        }\n+\n+        public static MetaTest7IntegerIntegerStatus valueOf(final String name) {\n+            return null;\n+        }\n+    }\n+\n+    static class MetaTest7IntegerIntStatus {\n+\n+        public Integer getName() {\n+            return 0;\n+        }\n+\n+        public static MetaTest7IntegerIntStatus valueOf(final int ordinal) {\n+            return null;\n+        }\n+\n+        public static MetaTest7IntegerIntStatus valueOf(final String name) {\n+            return null;\n+        }\n+    }\n+\n+    static class MetaTest7IntegerLongStatus {\n+\n+        public Integer getName() {\n+            return 0;\n+        }\n+\n+        public static MetaTest7IntegerLongStatus valueOf(final long ordinal) {\n+            return null;\n+        }\n+\n+        public static MetaTest7IntegerLongStatus valueOf(final String name) {\n+            return null;\n+        }\n+    }\n+\n+    static class MetaTest7IntIntegerStatus {\n+\n+        public int getName() {\n+            return 0;\n+        }\n+\n+        public static MetaTest7IntIntegerStatus valueOf(final Integer ordinal) {\n+            return null;\n+        }\n+\n+        public static MetaTest7IntIntegerStatus valueOf(final String name) {\n+            return null;\n+        }\n+    }\n+\n+    static class MetaTest7IntLongStatus {\n+\n+        public int getName() {\n+            return 0;\n+        }\n+\n+        public static MetaTest7IntLongStatus valueOf(final long ordinal) {\n+            return null;\n+        }\n+\n+        public static MetaTest7IntLongStatus valueOf(final String name) {\n+            return null;\n+        }\n+    }\n+\n+    static class MetaTest7Status {\n+\n+        public String getName() {\n+            return null;\n+        }\n+\n+        public static MetaTest7Status valueOf(final int ordinal) {\n+            return null;\n+        }\n+\n+        public static MetaTest7Status valueOf(final String name) {\n+            return null;\n+        }\n+    }\n+}"}]}

