{"sha":"7eb91d0ec9eb7690db32f5f8cedb7f336325d2fa","node_id":"MDY6Q29tbWl0MjA2MzY0OjdlYjkxZDBlYzllYjc2OTBkYjMyZjVmOGNlZGI3ZjMzNjMyNWQyZmE=","commit":{"author":{"name":"David J. Wisneski","email":"wisneskid@apache.org","date":"2007-02-22T01:03:06Z"},"committer":{"name":"David J. Wisneski","email":"wisneskid@apache.org","date":"2007-02-22T01:03:06Z"},"message":"DB2 Optimize for clause enhancement\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@510336 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"abc67a1c44ce7ef6ffdd87407de4c7071cd0a41d","url":"https://api.github.com/repos/apache/openjpa/git/trees/abc67a1c44ce7ef6ffdd87407de4c7071cd0a41d"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/7eb91d0ec9eb7690db32f5f8cedb7f336325d2fa","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/7eb91d0ec9eb7690db32f5f8cedb7f336325d2fa","html_url":"https://github.com/apache/openjpa/commit/7eb91d0ec9eb7690db32f5f8cedb7f336325d2fa","comments_url":"https://api.github.com/repos/apache/openjpa/commits/7eb91d0ec9eb7690db32f5f8cedb7f336325d2fa/comments","author":null,"committer":null,"parents":[{"sha":"2d3871b86b89e4c19e9831f1361472d7387bda34","url":"https://api.github.com/repos/apache/openjpa/commits/2d3871b86b89e4c19e9831f1361472d7387bda34","html_url":"https://github.com/apache/openjpa/commit/2d3871b86b89e4c19e9831f1361472d7387bda34"}],"stats":{"total":421,"additions":210,"deletions":211},"files":[{"sha":"af7b00f5c839b29733a655b5a83e66f15da07d3a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","status":"modified","additions":210,"deletions":211,"changes":421,"blob_url":"https://github.com/apache/openjpa/blob/7eb91d0ec9eb7690db32f5f8cedb7f336325d2fa/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/7eb91d0ec9eb7690db32f5f8cedb7f336325d2fa/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java?ref=7eb91d0ec9eb7690db32f5f8cedb7f336325d2fa","patch":"@@ -1,211 +1,210 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.openjpa.jdbc.sql;\n-\n-import java.sql.Connection;\n-import java.sql.DatabaseMetaData;\n-import java.sql.SQLException;\n-import java.util.Arrays;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.schema.Sequence;\n-\n-/**\n- * Dictionary for IBM DB2 database.\n- */\n-public class DB2Dictionary\n-    extends AbstractDB2Dictionary {\n-\n-    public DB2Dictionary() {\n-        platform = \"DB2\";\n-        validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\n-            + \"SYSIBM.SYSTABLES\";\n-        supportsSelectEndIndex = true;\n-        optimizeClause =\"optimize for\";\n-        nextSequenceQuery = \"VALUES NEXTVAL FOR {0}\";\n-\n-        sequenceSQL = \"SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, \"\n-            + \"SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES\";\n-        sequenceSchemaSQL = \"SEQSCHEMA = ?\";\n-        sequenceNameSQL = \"SEQNAME = ?\";\n-        characterColumnSize = 254;\n-\n-        binaryTypeName = \"BLOB(1M)\";\n-        longVarbinaryTypeName = \"BLOB(1M)\";\n-        varbinaryTypeName = \"BLOB(1M)\";\n-        clobTypeName = \"CLOB(1M)\";\n-        longVarcharTypeName = \"LONG VARCHAR\";\n-\n-        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\n-            \"LONG VARCHAR FOR BIT DATA\", \"LONG VARCHAR\", \"LONG VARGRAPHIC\",\n-        }));\n-\n-        maxConstraintNameLength = 18;\n-        maxIndexNameLength = 18;\n-        maxColumnNameLength = 30;\n-        supportsDeferredConstraints = false;\n-        supportsDefaultDeleteAction = false;\n-        supportsAlterTableWithDropColumn = false;\n-\n-        supportsNullTableForGetColumns = false;\n-\n-        reservedWordSet.addAll(Arrays.asList(new String[]{\n-            \"AFTER\", \"ALIAS\", \"ALLOW\", \"APPLICATION\", \"ASSOCIATE\", \"ASUTIME\",\n-            \"AUDIT\", \"AUX\", \"AUXILIARY\", \"BEFORE\", \"BINARY\", \"BUFFERPOOL\",\n-            \"CACHE\", \"CALL\", \"CALLED\", \"CAPTURE\", \"CARDINALITY\", \"CCSID\",\n-            \"CLUSTER\", \"COLLECTION\", \"COLLID\", \"COMMENT\", \"CONCAT\",\n-            \"CONDITION\", \"CONTAINS\", \"COUNT_BIG\", \"CURRENT_LC_CTYPE\",\n-            \"CURRENT_PATH\", \"CURRENT_SERVER\", \"CURRENT_TIMEZONE\", \"CYCLE\",\n-            \"DATA\", \"DATABASE\", \"DAYS\", \"DB2GENERAL\", \"DB2GENRL\", \"DB2SQL\",\n-            \"DBINFO\", \"DEFAULTS\", \"DEFINITION\", \"DETERMINISTIC\", \"DISALLOW\",\n-            \"DO\", \"DSNHATTR\", \"DSSIZE\", \"DYNAMIC\", \"EACH\", \"EDITPROC\", \"ELSEIF\",\n-            \"ENCODING\", \"END-EXEC1\", \"ERASE\", \"EXCLUDING\", \"EXIT\", \"FENCED\",\n-            \"FIELDPROC\", \"FILE\", \"FINAL\", \"FREE\", \"FUNCTION\", \"GENERAL\",\n-            \"GENERATED\", \"GRAPHIC\", \"HANDLER\", \"HOLD\", \"HOURS\", \"IF\",\n-            \"INCLUDING\", \"INCREMENT\", \"INDEX\", \"INHERIT\", \"INOUT\", \"INTEGRITY\",\n-            \"ISOBID\", \"ITERATE\", \"JAR\", \"JAVA\", \"LABEL\", \"LC_CTYPE\", \"LEAVE\",\n-            \"LINKTYPE\", \"LOCALE\", \"LOCATOR\", \"LOCATORS\", \"LOCK\", \"LOCKMAX\",\n-            \"LOCKSIZE\", \"LONG\", \"LOOP\", \"MAXVALUE\", \"MICROSECOND\",\n-            \"MICROSECONDS\", \"MINUTES\", \"MINVALUE\", \"MODE\", \"MODIFIES\", \"MONTHS\",\n-            \"NEW\", \"NEW_TABLE\", \"NOCACHE\", \"NOCYCLE\", \"NODENAME\", \"NODENUMBER\",\n-            \"NOMAXVALUE\", \"NOMINVALUE\", \"NOORDER\", \"NULLS\", \"NUMPARTS\", \"OBID\",\n-            \"OLD\", \"OLD_TABLE\", \"OPTIMIZATION\", \"OPTIMIZE\", \"OUT\", \"OVERRIDING\",\n-            \"PACKAGE\", \"PARAMETER\", \"PART\", \"PARTITION\", \"PATH\", \"PIECESIZE\",\n-            \"PLAN\", \"PRIQTY\", \"PROGRAM\", \"PSID\", \"QUERYNO\", \"READS\", \"RECOVERY\",\n-            \"REFERENCING\", \"RELEASE\", \"RENAME\", \"REPEAT\", \"RESET\", \"RESIGNAL\",\n-            \"RESTART\", \"RESULT\", \"RESULT_SET_LOCATOR\", \"RETURN\", \"RETURNS\",\n-            \"ROUTINE\", \"ROW\", \"RRN\", \"RUN\", \"SAVEPOINT\", \"SCRATCHPAD\",\n-            \"SECONDS\", \"SECQTY\", \"SECURITY\", \"SENSITIVE\", \"SIGNAL\", \"SIMPLE\",\n-            \"SOURCE\", \"SPECIFIC\", \"SQLID\", \"STANDARD\", \"START\", \"STATIC\",\n-            \"STAY\", \"STOGROUP\", \"STORES\", \"STYLE\", \"SUBPAGES\", \"SYNONYM\",\n-            \"SYSFUN\", \"SYSIBM\", \"SYSPROC\", \"SYSTEM\", \"TABLESPACE\", \"TRIGGER\",\n-            \"TYPE\", \"UNDO\", \"UNTIL\", \"VALIDPROC\", \"VARIABLE\", \"VARIANT\", \"VCAT\",\n-            \"VOLUMES\", \"WHILE\", \"WLM\", \"YEARS\",\n-        }));\n-    }\n-\n-    public boolean supportsRandomAccessResultSet(Select sel,\n-        boolean forUpdate) {\n-        return !forUpdate\n-            && super.supportsRandomAccessResultSet(sel, forUpdate);\n-    }\n-\n-    protected void appendSelectRange(SQLBuffer buf, long start, long end) {\n-        // appends the literal range string, since DB2 is unable to handle\n-        // a bound parameter for it\n-        buf.append(\" FETCH FIRST \").append(Long.toString(end)).\n-            append(\" ROWS ONLY\");\n-    }\n-\n-    public String[] getCreateSequenceSQL(Sequence seq) {\n-        String[] sql = super.getCreateSequenceSQL(seq);\n-        if (seq.getAllocate() > 1)\n-            sql[0] += \" CACHE \" + seq.getAllocate();\n-        return sql;\n-    }\n-\n-    protected String getSequencesSQL(String schemaName, String sequenceName) {\n-        StringBuffer buf = new StringBuffer();\n-        buf.append(sequenceSQL);\n-        if (schemaName != null || sequenceName != null)\n-            buf.append(\" WHERE \");\n-        if (schemaName != null) {\n-            buf.append(sequenceSchemaSQL);\n-            if (sequenceName != null)\n-                buf.append(\" AND \");\n-        }\n-        if (sequenceName != null)\n-            buf.append(sequenceNameSQL);\n-        return buf.toString();\n-    }\n-\n-    public Connection decorate(Connection conn)\n-        throws SQLException {\n-        // some versions of the DB2 driver seem to default to\n-        // READ_UNCOMMITTED, which will prevent locking from working\n-        // (multiple SELECT ... FOR UPDATE statements are allowed on\n-        // the same instance); if we have not overridden the\n-        // transaction isolation in the configuration, default to\n-        // TRANSACTION_READ_COMMITTED\n-        conn = super.decorate(conn);\n-\n-        if (conf.getTransactionIsolationConstant() == -1\n-            && conn.getTransactionIsolation() < conn.TRANSACTION_READ_COMMITTED)\n-            conn.setTransactionIsolation(conn.TRANSACTION_READ_COMMITTED);\n-\n-        return conn;\n-    }\n-\n-    private boolean isJDBC3(DatabaseMetaData meta) {\n-        try {\n-            // JDBC3-only method, so it might throw a AbstractMethodError\n-            return meta.getJDBCMajorVersion() >= 3;\n-        } catch (Throwable t) {\n-            return false;\n-        }\n-    }\n-\n-    public void connectedConfiguration(Connection conn) throws SQLException {\n-    \tsuper.connectedConfiguration(conn);\n-\n-    \tDatabaseMetaData metaData = conn.getMetaData();\n-    \tif (isJDBC3(metaData)) {\n-\t\t\tint maj = metaData.getDatabaseMajorVersion();\n-\t    \tint min = metaData.getDatabaseMinorVersion();\n-\n-\t    \tif (maj >= 9 || (maj == 8 && min >= 2)) {\n-\t    \t\tsupportsLockingWithMultipleTables = true;\n-\t    \t\tsupportsLockingWithInnerJoin = true;\n-\t    \t\tsupportsLockingWithOuterJoin = true;\n-\t    \t\tforUpdateClause = \"WITH RR USE AND KEEP UPDATE LOCKS\";\n-\t    \t}\n-\n-            if (metaData.getDatabaseProductVersion().indexOf(\"DSN\") != -1) {\n-                // DB2 Z/OS\n-                characterColumnSize = 255;\n-                lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\n-                    + \"SYSIBM.SYSDUMMY1\";\n-                nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\n-                    + \"SYSIBM.SYSDUMMY1\";\n-                sequenceSQL = \"SELECT SCHEMA AS SEQUENCE_SCHEMA, \"\n-                    + \"NAME AS SEQUENCE_NAME FROM SYSIBM.SYSSEQUENCES\";\n-                sequenceSchemaSQL = \"SCHEMA = ?\";\n-                sequenceNameSQL = \"NAME = ?\";\n-                if (maj == 8) {\n-                    // DB2 Z/OS Version 8: no bigint support, hence map Java\n-                    // long to decimal\n-                    bigintTypeName = \"DECIMAL(31,0)\";\n-                }\n-            }\n-    \t}\n-    }\n-    \n-    public String getOptimizeClause(JDBCFetchConfiguration fetch) {\n-        Integer rows = null;\n-        StringBuffer optimizeString = null;\n-        if (fetch.getHint(\"openjpa.hint.optimize\") != null) {\n-            optimizeString = new StringBuffer();\n-            rows = (Integer)fetch.getHint(\"openjpa.hint.optimize\");\n-            optimizeString.append(\" \").append(optimizeClause).append(\" \")\n-                .append(rows).append(\" \");\n-            if(rows.intValue() > 1)\n-    \t\t    optimizeString.append(rowsClause).append(\" \");\n-            else\n-    \t\t    optimizeString.append(rowClause).append(\" \");\n-        }\n-        return optimizeString.toString();    \n-    }\n-}\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.jdbc.sql;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DatabaseMetaData;\r\n+import java.sql.SQLException;\r\n+import java.util.Arrays;\r\n+\r\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\r\n+import org.apache.openjpa.jdbc.schema.Sequence;\r\n+\r\n+/**\r\n+ * Dictionary for IBM DB2 database.\r\n+ */\r\n+public class DB2Dictionary\r\n+    extends AbstractDB2Dictionary {\r\n+\r\n+    public DB2Dictionary() {\r\n+        platform = \"DB2\";\r\n+        validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\r\n+            + \"SYSIBM.SYSTABLES\";\r\n+        supportsSelectEndIndex = true;\r\n+        optimizeClause =\"optimize for\";\r\n+        nextSequenceQuery = \"VALUES NEXTVAL FOR {0}\";\r\n+\r\n+        sequenceSQL = \"SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, \"\r\n+            + \"SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES\";\r\n+        sequenceSchemaSQL = \"SEQSCHEMA = ?\";\r\n+        sequenceNameSQL = \"SEQNAME = ?\";\r\n+        characterColumnSize = 254;\r\n+\r\n+        binaryTypeName = \"BLOB(1M)\";\r\n+        longVarbinaryTypeName = \"BLOB(1M)\";\r\n+        varbinaryTypeName = \"BLOB(1M)\";\r\n+        clobTypeName = \"CLOB(1M)\";\r\n+        longVarcharTypeName = \"LONG VARCHAR\";\r\n+\r\n+        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\r\n+            \"LONG VARCHAR FOR BIT DATA\", \"LONG VARCHAR\", \"LONG VARGRAPHIC\",\r\n+        }));\r\n+\r\n+        maxConstraintNameLength = 18;\r\n+        maxIndexNameLength = 18;\r\n+        maxColumnNameLength = 30;\r\n+        supportsDeferredConstraints = false;\r\n+        supportsDefaultDeleteAction = false;\r\n+        supportsAlterTableWithDropColumn = false;\r\n+\r\n+        supportsNullTableForGetColumns = false;\r\n+\r\n+        reservedWordSet.addAll(Arrays.asList(new String[]{\r\n+            \"AFTER\", \"ALIAS\", \"ALLOW\", \"APPLICATION\", \"ASSOCIATE\", \"ASUTIME\",\r\n+            \"AUDIT\", \"AUX\", \"AUXILIARY\", \"BEFORE\", \"BINARY\", \"BUFFERPOOL\",\r\n+            \"CACHE\", \"CALL\", \"CALLED\", \"CAPTURE\", \"CARDINALITY\", \"CCSID\",\r\n+            \"CLUSTER\", \"COLLECTION\", \"COLLID\", \"COMMENT\", \"CONCAT\",\r\n+            \"CONDITION\", \"CONTAINS\", \"COUNT_BIG\", \"CURRENT_LC_CTYPE\",\r\n+            \"CURRENT_PATH\", \"CURRENT_SERVER\", \"CURRENT_TIMEZONE\", \"CYCLE\",\r\n+            \"DATA\", \"DATABASE\", \"DAYS\", \"DB2GENERAL\", \"DB2GENRL\", \"DB2SQL\",\r\n+            \"DBINFO\", \"DEFAULTS\", \"DEFINITION\", \"DETERMINISTIC\", \"DISALLOW\",\r\n+            \"DO\", \"DSNHATTR\", \"DSSIZE\", \"DYNAMIC\", \"EACH\", \"EDITPROC\", \"ELSEIF\",\r\n+            \"ENCODING\", \"END-EXEC1\", \"ERASE\", \"EXCLUDING\", \"EXIT\", \"FENCED\",\r\n+            \"FIELDPROC\", \"FILE\", \"FINAL\", \"FREE\", \"FUNCTION\", \"GENERAL\",\r\n+            \"GENERATED\", \"GRAPHIC\", \"HANDLER\", \"HOLD\", \"HOURS\", \"IF\",\r\n+            \"INCLUDING\", \"INCREMENT\", \"INDEX\", \"INHERIT\", \"INOUT\", \"INTEGRITY\",\r\n+            \"ISOBID\", \"ITERATE\", \"JAR\", \"JAVA\", \"LABEL\", \"LC_CTYPE\", \"LEAVE\",\r\n+            \"LINKTYPE\", \"LOCALE\", \"LOCATOR\", \"LOCATORS\", \"LOCK\", \"LOCKMAX\",\r\n+            \"LOCKSIZE\", \"LONG\", \"LOOP\", \"MAXVALUE\", \"MICROSECOND\",\r\n+            \"MICROSECONDS\", \"MINUTES\", \"MINVALUE\", \"MODE\", \"MODIFIES\", \"MONTHS\",\r\n+            \"NEW\", \"NEW_TABLE\", \"NOCACHE\", \"NOCYCLE\", \"NODENAME\", \"NODENUMBER\",\r\n+            \"NOMAXVALUE\", \"NOMINVALUE\", \"NOORDER\", \"NULLS\", \"NUMPARTS\", \"OBID\",\r\n+            \"OLD\", \"OLD_TABLE\", \"OPTIMIZATION\", \"OPTIMIZE\", \"OUT\", \"OVERRIDING\",\r\n+            \"PACKAGE\", \"PARAMETER\", \"PART\", \"PARTITION\", \"PATH\", \"PIECESIZE\",\r\n+            \"PLAN\", \"PRIQTY\", \"PROGRAM\", \"PSID\", \"QUERYNO\", \"READS\", \"RECOVERY\",\r\n+            \"REFERENCING\", \"RELEASE\", \"RENAME\", \"REPEAT\", \"RESET\", \"RESIGNAL\",\r\n+            \"RESTART\", \"RESULT\", \"RESULT_SET_LOCATOR\", \"RETURN\", \"RETURNS\",\r\n+            \"ROUTINE\", \"ROW\", \"RRN\", \"RUN\", \"SAVEPOINT\", \"SCRATCHPAD\",\r\n+            \"SECONDS\", \"SECQTY\", \"SECURITY\", \"SENSITIVE\", \"SIGNAL\", \"SIMPLE\",\r\n+            \"SOURCE\", \"SPECIFIC\", \"SQLID\", \"STANDARD\", \"START\", \"STATIC\",\r\n+            \"STAY\", \"STOGROUP\", \"STORES\", \"STYLE\", \"SUBPAGES\", \"SYNONYM\",\r\n+            \"SYSFUN\", \"SYSIBM\", \"SYSPROC\", \"SYSTEM\", \"TABLESPACE\", \"TRIGGER\",\r\n+            \"TYPE\", \"UNDO\", \"UNTIL\", \"VALIDPROC\", \"VARIABLE\", \"VARIANT\", \"VCAT\",\r\n+            \"VOLUMES\", \"WHILE\", \"WLM\", \"YEARS\",\r\n+        }));\r\n+    }\r\n+\r\n+    public boolean supportsRandomAccessResultSet(Select sel,\r\n+        boolean forUpdate) {\r\n+        return !forUpdate\r\n+            && super.supportsRandomAccessResultSet(sel, forUpdate);\r\n+    }\r\n+\r\n+    protected void appendSelectRange(SQLBuffer buf, long start, long end) {\r\n+        // appends the literal range string, since DB2 is unable to handle\r\n+        // a bound parameter for it\r\n+        buf.append(\" FETCH FIRST \").append(Long.toString(end)).\r\n+            append(\" ROWS ONLY\");\r\n+    }\r\n+\r\n+    public String[] getCreateSequenceSQL(Sequence seq) {\r\n+        String[] sql = super.getCreateSequenceSQL(seq);\r\n+        if (seq.getAllocate() > 1)\r\n+            sql[0] += \" CACHE \" + seq.getAllocate();\r\n+        return sql;\r\n+    }\r\n+\r\n+    protected String getSequencesSQL(String schemaName, String sequenceName) {\r\n+        StringBuffer buf = new StringBuffer();\r\n+        buf.append(sequenceSQL);\r\n+        if (schemaName != null || sequenceName != null)\r\n+            buf.append(\" WHERE \");\r\n+        if (schemaName != null) {\r\n+            buf.append(sequenceSchemaSQL);\r\n+            if (sequenceName != null)\r\n+                buf.append(\" AND \");\r\n+        }\r\n+        if (sequenceName != null)\r\n+            buf.append(sequenceNameSQL);\r\n+        return buf.toString();\r\n+    }\r\n+\r\n+    public Connection decorate(Connection conn)\r\n+        throws SQLException {\r\n+        // some versions of the DB2 driver seem to default to\r\n+        // READ_UNCOMMITTED, which will prevent locking from working\r\n+        // (multiple SELECT ... FOR UPDATE statements are allowed on\r\n+        // the same instance); if we have not overridden the\r\n+        // transaction isolation in the configuration, default to\r\n+        // TRANSACTION_READ_COMMITTED\r\n+        conn = super.decorate(conn);\r\n+\r\n+        if (conf.getTransactionIsolationConstant() == -1\r\n+            && conn.getTransactionIsolation() < conn.TRANSACTION_READ_COMMITTED)\r\n+            conn.setTransactionIsolation(conn.TRANSACTION_READ_COMMITTED);\r\n+\r\n+        return conn;\r\n+    }\r\n+\r\n+    private boolean isJDBC3(DatabaseMetaData meta) {\r\n+        try {\r\n+            // JDBC3-only method, so it might throw a AbstractMethodError\r\n+            return meta.getJDBCMajorVersion() >= 3;\r\n+        } catch (Throwable t) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+\r\n+    public void connectedConfiguration(Connection conn) throws SQLException {\r\n+    \tsuper.connectedConfiguration(conn);\r\n+\r\n+    \tDatabaseMetaData metaData = conn.getMetaData();\r\n+    \tif (isJDBC3(metaData)) {\r\n+\t\t\tint maj = metaData.getDatabaseMajorVersion();\r\n+\t    \tint min = metaData.getDatabaseMinorVersion();\r\n+\r\n+\t    \tif (maj >= 9 || (maj == 8 && min >= 2)) {\r\n+\t    \t\tsupportsLockingWithMultipleTables = true;\r\n+\t    \t\tsupportsLockingWithInnerJoin = true;\r\n+\t    \t\tsupportsLockingWithOuterJoin = true;\r\n+\t    \t\tforUpdateClause = \"WITH RR USE AND KEEP UPDATE LOCKS\";\r\n+\t    \t}\r\n+\r\n+            if (metaData.getDatabaseProductVersion().indexOf(\"DSN\") != -1) {\r\n+                // DB2 Z/OS\r\n+                characterColumnSize = 255;\r\n+                lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\r\n+                    + \"SYSIBM.SYSDUMMY1\";\r\n+                nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\r\n+                    + \"SYSIBM.SYSDUMMY1\";\r\n+                sequenceSQL = \"SELECT SCHEMA AS SEQUENCE_SCHEMA, \"\r\n+                    + \"NAME AS SEQUENCE_NAME FROM SYSIBM.SYSSEQUENCES\";\r\n+                sequenceSchemaSQL = \"SCHEMA = ?\";\r\n+                sequenceNameSQL = \"NAME = ?\";\r\n+                if (maj == 8) {\r\n+                    // DB2 Z/OS Version 8: no bigint support, hence map Java\r\n+                    // long to decimal\r\n+                    bigintTypeName = \"DECIMAL(31,0)\";\r\n+                }\r\n+            }\r\n+    \t}\r\n+    }\r\n+\r\n+    public String getOptimizeClause(JDBCFetchConfiguration fetch) {\r\n+        Integer rows = null;\r\n+        StringBuffer optimizeString = new StringBuffer();\r\n+        if (fetch.getHint(\"openjpa.hint.optimize\") != null) {\r\n+            rows = (Integer)fetch.getHint(\"openjpa.hint.optimize\");\r\n+            optimizeString.append(\" \").append(optimizeClause).append(\" \")\r\n+                .append(rows).append(\" \");\r\n+            if (rows.intValue() > 1)\r\n+                optimizeString.append(rowsClause).append(\" \");\r\n+            else\r\n+                optimizeString.append(rowClause).append(\" \");\r\n+        }        \r\n+        return optimizeString.toString();    \r\n+    }\r\n+}\r"}]}

