{"sha":"7f6a84d433fc5a0a52cdeae06e5b7a955e59076c","node_id":"MDY6Q29tbWl0MjA2MzY0OjdmNmE4NGQ0MzNmYzVhMGE1MmNkZWFlMDZlNWI3YTk1NWU1OTA3NmM=","commit":{"author":{"name":"Marc Prud'hommeaux","email":"mprudhom@apache.org","date":"2006-07-23T19:46:08Z"},"committer":{"name":"Marc Prud'hommeaux","email":"mprudhom@apache.org","date":"2006-07-23T19:46:08Z"},"message":"Changed to use ReentrantLock so we could get rid of our last dependency on the backport-util-concurrent library.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@424790 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"caa14f8a8d746aac6ec66fa895166ad545aec0ef","url":"https://api.github.com/repos/apache/openjpa/git/trees/caa14f8a8d746aac6ec66fa895166ad545aec0ef"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/7f6a84d433fc5a0a52cdeae06e5b7a955e59076c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/7f6a84d433fc5a0a52cdeae06e5b7a955e59076c","html_url":"https://github.com/apache/openjpa/commit/7f6a84d433fc5a0a52cdeae06e5b7a955e59076c","comments_url":"https://api.github.com/repos/apache/openjpa/commits/7f6a84d433fc5a0a52cdeae06e5b7a955e59076c/comments","author":null,"committer":null,"parents":[{"sha":"ca8633ab49759e186ca79a4d9c66c394c16693f5","url":"https://api.github.com/repos/apache/openjpa/commits/ca8633ab49759e186ca79a4d9c66c394c16693f5","html_url":"https://github.com/apache/openjpa/commit/ca8633ab49759e186ca79a4d9c66c394c16693f5"}],"stats":{"total":49,"additions":11,"deletions":38},"files":[{"sha":"05b162c33daf5cbdaf7ad9d7843956222addd624","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","status":"modified","additions":11,"deletions":38,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/7f6a84d433fc5a0a52cdeae06e5b7a955e59076c/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/7f6a84d433fc5a0a52cdeae06e5b7a955e59076c/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java?ref=7f6a84d433fc5a0a52cdeae06e5b7a955e59076c","patch":"@@ -45,8 +45,8 @@\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.util.GeneralException;\n import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.lib.util.concurrent.ReentrantLock;\n \n-import edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock;\n import serp.util.Strings;\n \n /**\n@@ -84,7 +84,7 @@\n     private LinkedList _broadcastThreads = new LinkedList();\n \n     private ArrayList _addresses = new ArrayList();\n-    private ReentrantReadWriteLock _addressesLock;\n+    private ReentrantLock _addressesLock;\n \n     public TCPRemoteCommitProvider()\n         throws UnknownHostException {\n@@ -95,8 +95,7 @@ public TCPRemoteCommitProvider()\n \n         // cache the local IP address.\n         _localhost = InetAddress.getLocalHost().getAddress();\n-        _addressesLock =\n-            new edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock();\n+        _addressesLock = new ReentrantLock();\n         setNumBroadcastThreads(2);\n     }\n \n@@ -207,7 +206,7 @@ public void setAddresses(String names)\n         // NYI. Could look for equivalence of addresses and avoid\n         // changing those that didn't change.\n \n-        acquireWriteLock(_addressesLock);\n+        _addressesLock.lock();\n         try {\n             for (Iterator iter = _addresses.iterator(); iter.hasNext();) {\n                 ((HostAddress) iter.next()).close();\n@@ -257,36 +256,10 @@ public void setAddresses(String names)\n             }\n         }\n         finally {\n-            releaseWriteLock(_addressesLock);\n+            _addressesLock.unlock();\n         }\n     }\n \n-    private void acquireWriteLock(\n-        edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock lock) {\n-        try {\n-            lock.writeLock().lockInterruptibly();\n-        } catch (InterruptedException e) {\n-        }\n-    }\n-\n-    private void releaseWriteLock(\n-        edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock lock) {\n-        lock.writeLock().unlock();\n-    }\n-\n-    private void acquireReadLock(\n-        edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock lock) {\n-        try {\n-            lock.readLock().lockInterruptibly();\n-        } catch (InterruptedException e) {\n-        }\n-    }\n-\n-    private void releaseReadLock(\n-        edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock lock) {\n-        lock.readLock().unlock();\n-    }\n-\n     // ---------- Configurable implementation ----------\n \n     /**\n@@ -322,7 +295,7 @@ public void endConfiguration() {\n             _listener.addProvider(this);\n         }\n \n-        acquireWriteLock(_addressesLock);\n+        _addressesLock.lock();\n         try {\n             HostAddress curAddress;\n             for (Iterator iter = _addresses.iterator();\n@@ -333,7 +306,7 @@ public void endConfiguration() {\n             }\n         }\n         finally {\n-            releaseWriteLock(_addressesLock);\n+            _addressesLock.unlock();\n         }\n     }\n \n@@ -374,25 +347,25 @@ public void broadcast(RemoteCommitEvent event) {\n      * provider cluster.\n      */\n     private void sendUpdatePacket(byte[] bytes) {\n-        acquireReadLock(_addressesLock);\n+        _addressesLock.lock();\n         try {\n             for (Iterator iter = _addresses.iterator(); iter.hasNext();)\n                 ((HostAddress) iter.next()).sendUpdatePacket(bytes);\n         } finally {\n-            releaseReadLock(_addressesLock);\n+            _addressesLock.unlock();\n         }\n     }\n \n     public void close() {\n         if (_listener != null)\n             _listener.removeProvider(this);\n \n-        acquireWriteLock(_addressesLock);\n+        _addressesLock.lock();\n         try {\n             for (Iterator iter = _addresses.iterator(); iter.hasNext();)\n                 ((HostAddress) iter.next()).close();\n         } finally {\n-            releaseWriteLock(_addressesLock);\n+            _addressesLock.unlock();\n         }\n \n         // We are done transmitting. Interrupt any worker threads."}]}

