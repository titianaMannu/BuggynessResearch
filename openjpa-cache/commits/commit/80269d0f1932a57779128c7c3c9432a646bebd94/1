{"sha":"80269d0f1932a57779128c7c3c9432a646bebd94","node_id":"MDY6Q29tbWl0MjA2MzY0OjgwMjY5ZDBmMTkzMmE1Nzc3OTEyOGM3YzNjOTQzMmE2NDZiZWJkOTQ=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-11-12T17:57:50Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-11-12T17:57:50Z"},"message":"OPENJPA-439\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@594234 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"83d32f241ca5167ed54349d2a280e4da92e3bd8f","url":"https://api.github.com/repos/apache/openjpa/git/trees/83d32f241ca5167ed54349d2a280e4da92e3bd8f"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/80269d0f1932a57779128c7c3c9432a646bebd94","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/80269d0f1932a57779128c7c3c9432a646bebd94","html_url":"https://github.com/apache/openjpa/commit/80269d0f1932a57779128c7c3c9432a646bebd94","comments_url":"https://api.github.com/repos/apache/openjpa/commits/80269d0f1932a57779128c7c3c9432a646bebd94/comments","author":null,"committer":null,"parents":[{"sha":"2895819d406139b89d90f3a6ab650180560e03bd","url":"https://api.github.com/repos/apache/openjpa/commits/2895819d406139b89d90f3a6ab650180560e03bd","html_url":"https://github.com/apache/openjpa/commit/2895819d406139b89d90f3a6ab650180560e03bd"}],"stats":{"total":49,"additions":26,"deletions":23},"files":[{"sha":"2e02262b0f25d251e60e43fe855ffb7e75cfba25","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":26,"deletions":23,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/80269d0f1932a57779128c7c3c9432a646bebd94/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/80269d0f1932a57779128c7c3c9432a646bebd94/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=80269d0f1932a57779128c7c3c9432a646bebd94","patch":"@@ -255,8 +255,8 @@ public void initialize(AbstractBrokerFactory factory,\n         _compat = _conf.getCompatibilityInstance();\n         _factory = factory;\n         _log = _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\n-        _cache = new ManagedCache(newManagedObjectCache());\n-        _operating = MapBackedSet.decorate(new IdentityMap());\n+        _cache = new ManagedCache();\n+        initializeOperatingSet();\n         _connRetainMode = connMode;\n         _managed = managed;\n         if (managed)\n@@ -295,6 +295,10 @@ public void initialize(AbstractBrokerFactory factory,\n             beginInternal();\n     }\n \n+    private void initializeOperatingSet() {\n+        _operating = MapBackedSet.decorate(new IdentityMap());\n+    }\n+\n     public Object clone()\n         throws CloneNotSupportedException {\n         if (_initializeWasInvoked)\n@@ -1587,7 +1591,6 @@ public void rollbackToSavepoint(String savepoint) {\n                     sm.rollback();\n                     removeFromTransaction(sm);\n                 }\n-                oldTransCache.clear();\n                 _transCache = newTransCache;\n             }\n         }\n@@ -1742,7 +1745,7 @@ public boolean endOperation() {\n         } finally {\n             _operationCount--;\n             if (_operationCount == 0)\n-                _operating.clear();\n+                initializeOperatingSet();\n             unlock();\n         }\n     }\n@@ -1943,7 +1946,7 @@ protected void flush(int reason) {\n \n             // also clear derefed set; the deletes have been recorded\n             if (_derefCache != null)\n-                _derefCache.clear();\n+                _derefCache = null;\n         }\n \n         // flush to store manager\n@@ -2026,7 +2029,7 @@ private boolean flushTransAdditions(Collection transactional, int reason) {\n         // copy the change set, then clear it for the next iteration\n         StateManagerImpl[] states = (StateManagerImpl[]) _transAdditions.\n             toArray(new StateManagerImpl[_transAdditions.size()]);\n-        _transAdditions.clear();\n+        _transAdditions = null;\n \n         for (int i = 0; i < states.length; i++)\n             states[i].beforeFlush(reason, _call);\n@@ -2045,7 +2048,7 @@ private boolean deleteDerefAdditions(Collection derefs) {\n \n         StateManagerImpl[] states = (StateManagerImpl[]) _derefAdditions.\n             toArray(new StateManagerImpl[_derefAdditions.size()]);\n-        _derefAdditions.clear();\n+        _derefAdditions = null;\n \n         for (int i = 0; i < states.length; i++)\n             deleteDeref(states[i]);\n@@ -2151,11 +2154,11 @@ protected void endTransaction(int status) {\n         // reference to it below\n         _transCache = null;\n         if (_persistedClss != null)\n-            _persistedClss.clear();\n+            _persistedClss = null;\n         if (_updatedClss != null)\n-            _updatedClss.clear();\n+            _updatedClss = null;\n         if (_deletedClss != null)\n-            _deletedClss.clear();\n+            _deletedClss = null;\n \n         // new cache would get cleared anyway during transitions, but doing so\n         // immediately saves us some lookups\n@@ -2168,7 +2171,7 @@ protected void endTransaction(int status) {\n             for (Iterator itr = _derefCache.iterator(); itr.hasNext();)\n                 ((StateManagerImpl) itr.next()).setDereferencedDependent\n                     (false, false);\n-            _derefCache.clear();\n+            _derefCache = null;\n         }\n \n         // peform commit or rollback state transitions on each instance\n@@ -4357,9 +4360,9 @@ public Object processReturn(Object oid, OpenJPAStateManager sm) {\n     /**\n      * Cache of managed objects.\n      */\n-    private static class ManagedCache {\n+    private class ManagedCache {\n \n-        private final Map _main; // oid -> sm\n+        private Map _main; // oid -> sm\n         private Map _conflicts = null; // conflict oid -> new sm\n         private Map _news = null; // tmp id -> new sm\n         private Collection _embeds = null; // embedded/non-persistent sms\n@@ -4368,8 +4371,8 @@ public Object processReturn(Object oid, OpenJPAStateManager sm) {\n         /**\n          * Constructor; supply primary cache map.\n          */\n-        public ManagedCache(Map cache) {\n-            _main = cache;\n+        private ManagedCache() {\n+            _main = newManagedObjectCache();\n         }\n \n         /**\n@@ -4593,23 +4596,23 @@ public Collection copy() {\n          * Clear the cache.\n          */\n         public void clear() {\n-            _main.clear();\n+            _main = newManagedObjectCache();\n             if (_conflicts != null)\n-                _conflicts.clear();\n+                _conflicts = null;\n             if (_news != null)\n-                _news.clear();\n+                _news = null;\n             if (_embeds != null)\n-                _embeds.clear();\n+                _embeds = null;\n             if (_untracked != null)\n-                _untracked.clear();\n+                _untracked = null;\n         }\n \n         /**\n          * Clear new instances without permanent oids.\n          */\n         public void clearNew() {\n             if (_news != null)\n-                _news.clear();\n+                _news = null;\n         }\n \n         private void dirtyCheck() {\n@@ -4735,9 +4738,9 @@ public boolean containsAll(Collection coll) {\n \n         public void clear() {\n             if (_dirty != null)\n-                _dirty.clear();\n+                _dirty = null;\n             if (_clean != null)\n-                _clean.clear();\n+                _clean = null;\n         }\n \n         public boolean isEmpty() {"}]}

