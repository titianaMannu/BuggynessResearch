{"sha":"82e61ba0d578fba28ae987cafdc29e3b211a45f7","node_id":"MDY6Q29tbWl0MjA2MzY0OjgyZTYxYmEwZDU3OGZiYTI4YWU5ODdjYWZkYzI5ZTNiMjExYTQ1Zjc=","commit":{"author":{"name":"Kevin W. Sutter","email":"kwsutter@apache.org","date":"2008-06-26T19:31:20Z"},"committer":{"name":"Kevin W. Sutter","email":"kwsutter@apache.org","date":"2008-06-26T19:31:20Z"},"message":"OPENJPA-637.  Reverting ConcurrentHashMap implementation per the patch provided by Jeremy Bauer.  A more complete, configurable implementation is being tracked via the related sub-task OPENJPA-643.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@672003 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"099f95ac56067956f8ee0ac0daa07176d5a922a0","url":"https://api.github.com/repos/apache/openjpa/git/trees/099f95ac56067956f8ee0ac0daa07176d5a922a0"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/82e61ba0d578fba28ae987cafdc29e3b211a45f7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/82e61ba0d578fba28ae987cafdc29e3b211a45f7","html_url":"https://github.com/apache/openjpa/commit/82e61ba0d578fba28ae987cafdc29e3b211a45f7","comments_url":"https://api.github.com/repos/apache/openjpa/commits/82e61ba0d578fba28ae987cafdc29e3b211a45f7/comments","author":null,"committer":null,"parents":[{"sha":"976a5e1faf9df64b40ede8586c345def1454cf4e","url":"https://api.github.com/repos/apache/openjpa/commits/976a5e1faf9df64b40ede8586c345def1454cf4e","html_url":"https://github.com/apache/openjpa/commit/976a5e1faf9df64b40ede8586c345def1454cf4e"}],"stats":{"total":950,"additions":944,"deletions":6},"files":[{"sha":"123e96a3c145bcc4db5ae18b6d89ea4046682f1a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","status":"modified","additions":3,"deletions":6,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/82e61ba0d578fba28ae987cafdc29e3b211a45f7/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","raw_url":"https://github.com/apache/openjpa/raw/82e61ba0d578fba28ae987cafdc29e3b211a45f7/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java?ref=82e61ba0d578fba28ae987cafdc29e3b211a45f7","patch":"@@ -22,7 +22,6 @@\n import java.util.AbstractSet;\r\n import java.util.Collection;\r\n import java.util.Collections;\r\n-import java.util.HashMap;\r\n import java.util.Iterator;\r\n import java.util.Map;\r\n import java.util.Set;\r\n@@ -31,12 +30,10 @@\n import org.apache.commons.collections.iterators.FilterIterator;\r\n import org.apache.commons.collections.iterators.IteratorChain;\r\n import org.apache.openjpa.lib.util.LRUMap;\r\n-import org.apache.openjpa.lib.util.ReferenceHashMap;\r\n import org.apache.openjpa.lib.util.ReferenceMap;\r\n import org.apache.openjpa.lib.util.SizedMap;\r\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\r\n import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\r\n-import org.apache.openjpa.lib.util.concurrent.NullSafeConcurrentHashMap;\r\n-import org.apache.openjpa.lib.util.concurrent.SizedConcurrentHashMap;\r\n \r\n import java.util.concurrent.locks.ReentrantLock;\r\n \r\n@@ -114,10 +111,10 @@ public void valueExpired(Object key) {\n                 softMapValueExpired(key);\r\n             }\r\n         };\r\n-        pinnedMap = new NullSafeConcurrentHashMap();\r\n+        pinnedMap = new ConcurrentHashMap();\r\n \r\n         if (!lru) {\r\n-            cacheMap = new SizedConcurrentHashMap(size, load, concurrencyLevel){\r\n+            cacheMap = new ConcurrentHashMap(size, load) {\r\n                 public void overflowRemoved(Object key, Object value) {\r\n                     cacheMapOverflowRemoved(key, value);\r\n                 }\r"},{"sha":"e66adfbbca65e8f034a49e9d2e732f09d89ee13e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java","status":"added","additions":941,"deletions":0,"changes":941,"blob_url":"https://github.com/apache/openjpa/blob/82e61ba0d578fba28ae987cafdc29e3b211a45f7/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/82e61ba0d578fba28ae987cafdc29e3b211a45f7/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java?ref=82e61ba0d578fba28ae987cafdc29e3b211a45f7","patch":"@@ -0,0 +1,941 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.util.concurrent;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.AbstractCollection;\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.apache.openjpa.lib.util.SizedMap;\n+\n+/**\n+ * This class implements a HashMap which has limited synchronization.\n+ * In particular mutators are generally synchronized while accessors\n+ * are generally not. Additionally the Iterators returned by this\n+ * class are not \"fail-fast\", but instead try to continue to iterate\n+ * over the data structure after changes have been made.\n+ * The synchronization semantics are built right in to the\n+ * implementation rather than using a delegating wrapper like the\n+ * other collection classes do because it wasn't clear to me that the\n+ * how the two should be seperated or that it would be useful to do\n+ * so. This can probably be a topic for further debate in the future.\n+ * This class is based heavily on the HashMap class in the Java\n+ * collections package.\n+ */\n+public class ConcurrentHashMap extends AbstractMap\n+    implements ConcurrentMap, SizedMap, Cloneable, Serializable {\n+\n+    /**\n+     * The default initial capacity - MUST be a power of two.\n+     */\n+    private static final int DEFAULT_INITIAL_CAPACITY = 16;\n+\n+    /**\n+     * The maximum capacity, used if a higher value is implicitly specified\n+     * by either of the constructors with arguments.\n+     * MUST be a power of two <= 1<<30.\n+     */\n+    private static final int MAXIMUM_CAPACITY = 1 << 30;\n+\n+    /**\n+     * The load fast used when none specified in constructor.\n+     */\n+    private static final float DEFAULT_LOAD_FACTOR = 0.75f;\n+\n+    /**\n+     * Cache of random numbers used in \"random\" methods, since generating them\n+     * is expensive. We hope each map changes enough between cycling through\n+     * this list that the overall effect is random enough.\n+     */\n+    static final double[] RANDOMS = new double[1000];\n+\n+    static {\n+        Random random = new Random();\n+        for (int i = 0; i < RANDOMS.length; i++)\n+            RANDOMS[i] = random.nextDouble();\n+    }\n+\n+    /**\n+     * The table, resized as necessary. Length MUST Always be a power of two.\n+     */\n+    private transient Entry[] table;\n+\n+    /**\n+     * The number of key-value mappings contained in this identity hash map.\n+     */\n+    private transient int size;\n+\n+    /**\n+     * The next size value at which to resize(capacity * load factor).\n+     *\n+     * @serial\n+     */\n+    private int threshold;\n+\n+    /**\n+     * The load factor for the hash table.\n+     *\n+     * @serial\n+     */\n+    private final float loadFactor;\n+\n+    /**\n+     * Spread \"random\" removes and iteration.\n+     */\n+    private int randomEntry = 0;\n+\n+    /**\n+     * Maximum entries.\n+     */\n+    private int maxSize = Integer.MAX_VALUE;\n+\n+    /**\n+     * Constructs an empty <tt>ConcurrentHashMap</tt> with the specified initial\n+     * capacity and load factor.\n+     *\n+     * @param initialCapacity The initial capacity.\n+     * @param loadFactor The load factor.\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     * or the load factor is nonpositive.\n+     */\n+    public ConcurrentHashMap(int initialCapacity, float loadFactor) {\n+        if (initialCapacity < 0) {\n+            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n+                initialCapacity);\n+        }\n+        if (initialCapacity > MAXIMUM_CAPACITY)\n+            initialCapacity = MAXIMUM_CAPACITY;\n+        if (loadFactor <= 0 || loadFactor > 1) {\n+            throw new IllegalArgumentException(\"Illegal load factor: \" +\n+                loadFactor);\n+        }\n+\n+        // Find a power of 2 >= initialCapacity\n+        int capacity = 1;\n+        while (capacity < initialCapacity) capacity <<= 1;\n+\n+        this.loadFactor = loadFactor;\n+        threshold = (int) (capacity * loadFactor);\n+        table = new Entry[capacity];\n+    }\n+\n+    /**\n+     * Constructs an empty <tt>ConcurrentHashMap</tt> with the specified initial\n+     * capacity and the default load factor(0.75).\n+     *\n+     * @param initialCapacity the initial capacity.\n+     * @throws IllegalArgumentException if the initial capacity is negative.\n+     */\n+    public ConcurrentHashMap(int initialCapacity) {\n+        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n+    }\n+\n+    /**\n+     * Constructs an empty <tt>ConcurrentHashMap</tt> with the default initial\n+     * capacity(16) and the default load factor(0.75).\n+     */\n+    public ConcurrentHashMap() {\n+        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n+    }\n+\n+    /**\n+     * Constructs a new <tt>ConcurrentHashMap</tt> with the same mappings as the\n+     * specified <tt>Map</tt>. The <tt>ConcurrentHashMap</tt> is created with\n+     * default load factor(0.75) and an initial capacity sufficient to\n+     * hold the mappings in the specified <tt>Map</tt>.\n+     *\n+     * @param m the map whose mappings are to be placed in this map.\n+     * @throws NullPointerException if the specified map is null.\n+     */\n+    public ConcurrentHashMap(Map m) {\n+        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,\n+            DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);\n+        putAll(m);\n+    }\n+\n+    // internal utilities\n+\n+    /**\n+     * Value representing null keys inside tables.\n+     */\n+    private static final Object NULL_KEY = new Object();\n+\n+    /**\n+     * Returns internal representation for key. Use NULL_KEY if key is null.\n+     */\n+    private static Object maskNull(Object key) {\n+        return (key == null ? NULL_KEY : key);\n+    }\n+\n+    /**\n+     * Returns key represented by specified internal representation.\n+     */\n+    private static Object unmaskNull(Object key) {\n+        return (key == NULL_KEY ? null : key);\n+    }\n+\n+    /**\n+     * Returns a hash code for non-null Object x.\n+     */\n+    private static int hash(Object x) {\n+        int h = x.hashCode();\n+        return h - (h << 7); // i.e., -127 * h\n+    }\n+\n+    /**\n+     * Check for equality of non-null reference x and possibly-null y.\n+     */\n+    private static boolean eq(Object x, Object y) {\n+        return x == y || x.equals(y);\n+    }\n+\n+    /**\n+     * Returns the current capacity of backing table in this map.\n+     *\n+     * @return the current capacity of backing table in this map.\n+     */\n+    public final int capacity() {\n+        return table.length;\n+    }\n+\n+    /**\n+     * Returns the load factor for this map.\n+     *\n+     * @return the load factor for this map.\n+     */\n+    public final float loadFactor() {\n+        return loadFactor;\n+    }\n+\n+    public int getMaxSize() {\n+        return maxSize;\n+    }\n+\n+    public void setMaxSize(int maxSize) {\n+        this.maxSize = (maxSize < 0) ? Integer.MAX_VALUE : maxSize;\n+        if (this.maxSize != Integer.MAX_VALUE)\n+            removeOverflow(this.maxSize);\n+    }\n+\n+    public boolean isFull() {\n+        return maxSize != Integer.MAX_VALUE && size() >= maxSize;\n+    }\n+\n+    public void overflowRemoved(Object key, Object value) {\n+    }\n+\n+    /**\n+     * Returns the number of key-value mappings in this map.\n+     *\n+     * @return the number of key-value mappings in this map.\n+     */\n+    public final int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> if this map contains no key-value mappings.\n+     *\n+     * @return <tt>true</tt> if this map contains no key-value mappings.\n+     */\n+    public final boolean isEmpty() {\n+        return size == 0;\n+    }\n+\n+    /**\n+     * Returns the value to which the specified key is mapped in this identity\n+     * hash map, or <tt>null</tt> if the map contains no mapping for this key.\n+     * A return value of <tt>null</tt> does not <i>necessarily</i> indicate\n+     * that the map contains no mapping for the key; it is also possible that\n+     * the map explicitly maps the key to <tt>null</tt>. The\n+     * <tt>containsKey</tt> method may be used to distinguish these two cases.\n+     *\n+     * @param key the key whose associated value is to be returned.\n+     * @return the value to which this map maps the specified key, or\n+     * <tt>null</tt> if the map contains no mapping for this key.\n+     * @see #put(Object, Object)\n+     */\n+    public Object get(Object key) {\n+        Entry e = getEntry(key);\n+        return e == null ? null : e.value;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> if this map contains a mapping for the\n+     * specified key.\n+     *\n+     * @param key The key whose presence in this map is to be tested\n+     * @return <tt>true</tt> if this map contains a mapping for the specified\n+     * key.\n+     */\n+    public final boolean containsKey(Object key) {\n+        return getEntry(key) != null;\n+    }\n+\n+    /**\n+     * Returns the entry associated with the specified key in the\n+     * ConcurrentHashMap. Returns null if the ConcurrentHashMap contains no\n+     * mapping for this key.\n+     */\n+    protected Entry getEntry(Object key) {\n+        Object k = maskNull(key);\n+        int hash = hash(k);\n+        Entry[] tab = table;\n+        for (Entry e = tab[hash & (tab.length - 1)]; e != null; e = e.next) {\n+            if (e.hash == hash && eq(k, e.key)) return e;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Associates the specified value with the specified key in this map.\n+     * If the map previously contained a mapping for this key, the old\n+     * value is replaced.\n+     *\n+     * @param key key with which the specified value is to be associated.\n+     * @param value value to be associated with the specified key.\n+     * @return previous value associated with specified key, or <tt>null</tt>\n+     * if there was no mapping for key. A <tt>null</tt> return can\n+     * also indicate that the ConcurrentHashMap previously associated\n+     * <tt>null</tt> with the specified key.\n+     */\n+    public Object put(Object key, Object value) {\n+        Object k = maskNull(key);\n+        int hash = hash(k);\n+        synchronized (this) {\n+            int i = hash & (table.length - 1);\n+\n+            for (Entry e = table[i]; e != null; e = e.next) {\n+                if (e.hash == hash && eq(k, e.key)) {\n+                    Object oldValue = e.value;\n+                    e.value = value;\n+                    return oldValue;\n+                }\n+            }\n+\n+            if (maxSize != Integer.MAX_VALUE)\n+                removeOverflow(maxSize - 1);\n+            table[i] = createEntry(hash, k, value, table[i]);\n+            if (size++ >= threshold) resize(2 * table.length);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Remove any entries equal to or over the max size.\n+     */\n+    private void removeOverflow(int maxSize) {\n+        while (size > maxSize) {\n+            Map.Entry entry = removeRandom();\n+            if (entry == null)\n+                break;\n+            overflowRemoved(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    public Object putIfAbsent(Object key, Object value) {\n+        Object k = maskNull(key);\n+        int hash = hash(k);\n+        synchronized (this) {\n+            int i = hash & (table.length - 1);\n+\n+            for (Entry e = table[i]; e != null; e = e.next) {\n+                if (e.hash == hash && eq(k, e.key)) {\n+                    return e.value;\n+                }\n+            }\n+\n+            if (maxSize != Integer.MAX_VALUE)\n+                removeOverflow(maxSize - 1);\n+            table[i] = createEntry(hash, k, value, table[i]);\n+            if (size++ >= threshold) resize(2 * table.length);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Rehashes the contents of this map into a new <tt>ConcurrentHashMap</tt>\n+     * instance with a larger capacity. This method is called automatically when\n+     * the number of keys in this map exceeds its capacity and load factor.\n+     *\n+     * @param newCapacity the new capacity, MUST be a power of two.\n+     */\n+    private void resize(int newCapacity) {\n+        // assert(newCapacity & -newCapacity) == newCapacity; // power of 2\n+        Entry[] oldTable = table;\n+        int oldCapacity = oldTable.length;\n+\n+        // check if needed\n+        if (size < threshold || oldCapacity > newCapacity) return;\n+\n+        Entry[] newTable = new Entry[newCapacity];\n+        int mask = newCapacity - 1;\n+        for (int i = oldCapacity; i-- > 0;) {\n+            for (Entry e = oldTable[i]; e != null; e = e.next) {\n+                Entry clone = (Entry) e.clone();\n+                int j = clone.hash & mask;\n+                clone.next = newTable[j];\n+                newTable[j] = clone;\n+            }\n+        }\n+        table = newTable;\n+        threshold = (int) (newCapacity * loadFactor);\n+    }\n+\n+    /**\n+     * Copies all of the mappings from the specified map to this map\n+     * These mappings will replace any mappings that\n+     * this map had for any of the keys currently in the specified map.\n+     *\n+     * @param t mappings to be stored in this map.\n+     * @throws NullPointerException if the specified map is null.\n+     */\n+    public final synchronized void putAll(Map t) {\n+        // Expand enough to hold t's elements without resizing.\n+        int n = t.size();\n+        if (n == 0) return;\n+        if (n >= threshold) {\n+            n = (int) (n / loadFactor + 1);\n+            if (n > MAXIMUM_CAPACITY) n = MAXIMUM_CAPACITY;\n+            int capacity = table.length;\n+            while (capacity < n) capacity <<= 1;\n+            resize(capacity);\n+        }\n+\n+        for (Iterator i = t.entrySet().iterator(); i.hasNext();) {\n+            Map.Entry e = (Map.Entry) i.next();\n+            put(e.getKey(), e.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Removes the mapping for this key from this map if present.\n+     *\n+     * @param key key whose mapping is to be removed from the map.\n+     * @return previous value associated with specified key, or <tt>null</tt>\n+     * if there was no mapping for key. A <tt>null</tt> return can\n+     * also indicate that the map previously associated <tt>null</tt>\n+     * with the specified key.\n+     */\n+    public Object remove(Object key) {\n+        Entry e = removeEntryForKey(key);\n+        return (e == null ? e : e.value);\n+    }\n+\n+    /**\n+     * Removes and returns the entry associated with the specified key in the\n+     * ConcurrentHashMap. Returns null if the ConcurrentHashMap contains no\n+     * mapping for this key.\n+     */\n+    private Entry removeEntryForKey(Object key) {\n+        Object k = maskNull(key);\n+        int hash = hash(k);\n+        synchronized (this) {\n+            int i = hash & (table.length - 1);\n+            Entry e = table[i];\n+\n+            if (e == null) return null;\n+            if (e.hash == hash && eq(k, e.key)) {\n+                size--;\n+                table[i] = e.next;\n+                return e;\n+            }\n+\n+            Entry prev = e;\n+            for (e = e.next; e != null; prev = e, e = e.next) {\n+                if (e.hash == hash && eq(k, e.key)) {\n+                    size--;\n+                    prev.next = e.next;\n+                    return e;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Special version of remove for EntrySet.\n+     */\n+    private Entry removeMapping(Object o) {\n+        if (!(o instanceof Map.Entry)) return null;\n+\n+        Map.Entry entry = (Map.Entry) o;\n+        Object k = maskNull(entry.getKey());\n+        int hash = hash(k);\n+        synchronized (this) {\n+            int i = hash & (table.length - 1);\n+            Entry e = table[i];\n+\n+            if (e == null) return null;\n+            if (e.hash == hash && e.equals(entry)) {\n+                size--;\n+                table[i] = e.next;\n+                return e;\n+            }\n+\n+            Entry prev = e;\n+            for (e = e.next; e != null; prev = e, e = e.next) {\n+                if (e.hash == hash && e.equals(entry)) {\n+                    size--;\n+                    prev.next = e.next;\n+                    return e;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Removes all mappings from this map.\n+     */\n+    public synchronized void clear() {\n+        table = new Entry[table.length];\n+        size = 0;\n+    }\n+\n+    /**\n+     * Return an arbitrary entry index.\n+     */\n+    private int randomEntryIndex() {\n+        if (randomEntry == RANDOMS.length)\n+            randomEntry = 0;\n+        return (int) (RANDOMS[randomEntry++] * table.length);\n+    }\n+\n+    public Map.Entry removeRandom() {\n+        if (size == 0)\n+            return null;\n+\n+        synchronized (this) {\n+            int random = randomEntryIndex();\n+            int index = findEntry(random, random % 2 == 0, false);\n+            if (index == -1)\n+                return null;\n+            Entry rem = table[index];\n+            table[index] = rem.next;\n+            size--;\n+            return rem;\n+        }\n+    }\n+\n+    /**\n+     * Find the index of the entry nearest the given index, starting in the\n+     * given direction.\n+     */\n+    private int findEntry(int start, boolean forward, boolean searchedOther) {\n+        if (forward) {\n+            for (int i = start; i < table.length; i++)\n+                if (table[i] != null)\n+                    return i;\n+            return (searchedOther || start == 0) ? -1\n+                : findEntry(start - 1, false, true);\n+        } else {\n+            for (int i = start; i >= 0; i--)\n+                if (table[i] != null)\n+                    return i;\n+            return (searchedOther || start == table.length - 1) ? -1\n+                : findEntry(start + 1, true, true);\n+        }\n+    }\n+\n+    public Iterator randomEntryIterator() {\n+        // pass index so calculated before iterator refs table, in case table\n+        // gets replace with a larger one\n+        return new HashIterator(ENTRIES, randomEntryIndex());\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> if this map maps one or more keys to the\n+     * specified value.\n+     *\n+     * @param value value whose presence in this map is to be tested.\n+     * @return <tt>true</tt> if this map maps one or more keys to the\n+     * specified value.\n+     */\n+    public final boolean containsValue(Object value) {\n+        if (value == null) return containsNullValue();\n+\n+        Entry tab[] = table;\n+        for (int i = 0; i < tab.length; i++) {\n+            for (Entry e = tab[i]; e != null; e = e.next) {\n+                if (value.equals(e.value)) return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Special-case code for containsValue with null argument\n+     */\n+    private boolean containsNullValue() {\n+        Entry tab[] = table;\n+        for (int i = 0; i < tab.length; i++) {\n+            for (Entry e = tab[i]; e != null; e = e.next) {\n+                if (e.value == null) return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a shallow copy of this <tt>ConcurrentHashMap</tt> instance: the\n+     * keys and values themselves are not cloned.\n+     *\n+     * @return a shallow copy of this map.\n+     */\n+    public final Object clone() {\n+        return new ConcurrentHashMap(this);\n+    }\n+\n+    protected Entry createEntry(int h, Object k, Object v, Entry n) {\n+        return new Entry(h, k, v, n);\n+    }\n+\n+    protected static class Entry implements Map.Entry {\n+\n+        final Object key;\n+        Object value;\n+        final int hash;\n+        Entry next;\n+\n+        /**\n+         * Create new entry.\n+         */\n+        protected Entry(int h, Object k, Object v, Entry n) {\n+            value = v;\n+            next = n;\n+            key = k;\n+            hash = h;\n+        }\n+\n+        public Object getKey() {\n+            return unmaskNull(key);\n+        }\n+\n+        public Object getValue() {\n+            return value;\n+        }\n+\n+        public Object setValue(Object newValue) {\n+            Object oldValue = value;\n+            value = newValue;\n+            return oldValue;\n+        }\n+\n+        public boolean equals(Object o) {\n+            if (!(o instanceof Map.Entry)) return false;\n+            Map.Entry e = (Map.Entry) o;\n+            Object k1 = getKey();\n+            Object k2 = e.getKey();\n+            if (k1 == k2 || (k1 != null && k1.equals(k2))) {\n+                Object v1 = getValue();\n+                Object v2 = e.getValue();\n+                if (v1 == v2 || (v1 != null && v1.equals(v2)))\n+                    return true;\n+            }\n+            return false;\n+        }\n+\n+        public int hashCode() {\n+            return (key == NULL_KEY ? 0 : key.hashCode()) ^\n+                (value == null ? 0 : value.hashCode());\n+        }\n+\n+        public String toString() {\n+            return getKey() + \"=\" + getValue();\n+        }\n+\n+        protected Object clone() {\n+            // It is the callers responsibility to set the next field\n+            // correctly.\n+            return new Entry(hash, key, value, null);\n+        }\n+    }\n+\n+    // Types of Enumerations/Iterations\n+    private static final int KEYS = 0;\n+    private static final int VALUES = 1;\n+    private static final int ENTRIES = 2;\n+\n+    /**\n+     * Map iterator.\n+     */\n+    private class HashIterator implements Iterator {\n+\n+        final Entry[] table = ConcurrentHashMap.this.table;\n+        final int type;\n+        int startIndex;\n+        int stopIndex = 0;\n+        int index;\n+        Entry entry = null;\n+        Entry lastReturned = null;\n+\n+        HashIterator(int type, int startIndex) {\n+            this.type = type;\n+            this.startIndex = startIndex;\n+            index = startIndex;\n+        }\n+\n+        public boolean hasNext() {\n+            if (entry != null) {\n+                return true;\n+            }\n+            while (index >= stopIndex) {\n+                if ((entry = table[index--]) != null) {\n+                    return true;\n+                }\n+            }\n+            if (stopIndex == 0) {\n+                index = table.length - 1;\n+                stopIndex = startIndex + 1;\n+                while (index >= stopIndex) {\n+                    if ((entry = table[index--]) != null) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public Object next() {\n+            if (!hasNext())\n+                throw new NoSuchElementException();\n+            Entry e = lastReturned = entry;\n+            entry = e.next;\n+            return type == KEYS ? e.key : (type == VALUES ? e.value : e);\n+        }\n+\n+        public void remove() {\n+            if (lastReturned == null)\n+                throw new IllegalStateException();\n+            synchronized (ConcurrentHashMap.this) {\n+                Entry[] tab = ConcurrentHashMap.this.table;\n+                int index = (lastReturned.hash & 0x7FFFFFFF) % tab.length;\n+\n+                for (Entry e = tab[index], prev = null; e != null;\n+                    prev = e, e = e.next) {\n+                    if (e == lastReturned) {\n+                        if (prev == null)\n+                            tab[index] = e.next;\n+                        else\n+                            prev.next = e.next;\n+                        size--;\n+                        lastReturned = null;\n+                        return;\n+                    }\n+                }\n+                throw new Error(\"Iterated off table when doing remove\");\n+            }\n+        }\n+    }\n+\n+    // Views\n+\n+    private transient Set entrySet = null;\n+    private transient Set keySet = null;\n+    private transient Collection values = null;\n+\n+    /**\n+     * Returns a set view of the keys contained in this map. The set is\n+     * backed by the map, so changes to the map are reflected in the set, and\n+     * vice-versa. The set supports element removal, which removes the\n+     * corresponding mapping from this map, via the <tt>Iterator.remove</tt>,\n+     * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt>, and\n+     * <tt>clear</tt> operations. It does not support the <tt>add</tt> or\n+     * <tt>addAll</tt> operations.\n+     *\n+     * @return a set view of the keys contained in this map.\n+     */\n+    public final Set keySet() {\n+        Set ks = keySet;\n+        return (ks != null ? ks : (keySet = new KeySet()));\n+    }\n+\n+    private final class KeySet extends AbstractSet {\n+\n+        public Iterator iterator() {\n+            return new HashIterator(KEYS, table.length - 1);\n+        }\n+\n+        public int size() {\n+            return size;\n+        }\n+\n+        public boolean contains(Object o) {\n+            return containsKey(o);\n+        }\n+\n+        public boolean remove(Object o) {\n+            return ConcurrentHashMap.this.removeEntryForKey(o) != null;\n+        }\n+\n+        public void clear() {\n+            ConcurrentHashMap.this.clear();\n+        }\n+    }\n+\n+    /**\n+     * Returns a collection view of the values contained in this map. The\n+     * collection is backed by the map, so changes to the map are reflected in\n+     * the collection, and vice-versa. The collection supports element\n+     * removal, which removes the corresponding mapping from this map, via the\n+     * <tt>Iterator.remove</tt>, <tt>Collection.remove</tt>,\n+     * <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt> operations.\n+     * It does not support the <tt>add</tt> or <tt>addAll</tt> operations.\n+     *\n+     * @return a collection view of the values contained in this map.\n+     */\n+    public final Collection values() {\n+        Collection vs = values;\n+        return (vs != null ? vs : (values = new Values()));\n+    }\n+\n+    private final class Values extends AbstractCollection {\n+\n+        public Iterator iterator() {\n+            return new HashIterator(VALUES, table.length - 1);\n+        }\n+\n+        public int size() {\n+            return size;\n+        }\n+\n+        public boolean contains(Object o) {\n+            return containsValue(o);\n+        }\n+\n+        public void clear() {\n+            ConcurrentHashMap.this.clear();\n+        }\n+    }\n+\n+    /**\n+     * Returns a collection view of the mappings contained in this map. Each\n+     * element in the returned collection is a <tt>Map.Entry</tt>. The\n+     * collection is backed by the map, so changes to the map are reflected in\n+     * the collection, and vice-versa. The collection supports element\n+     * removal, which removes the corresponding mapping from the map, via the\n+     * <tt>Iterator.remove</tt>, <tt>Collection.remove</tt>,\n+     * <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt> operations.\n+     * It does not support the <tt>add</tt> or <tt>addAll</tt> operations.\n+     *\n+     * @return a collection view of the mappings contained in this map.\n+     * @see Map.Entry\n+     */\n+    public final Set entrySet() {\n+        Set es = entrySet;\n+        return (es != null ? es : (entrySet = new EntrySet()));\n+    }\n+\n+    private final class EntrySet extends AbstractSet {\n+\n+        public Iterator iterator() {\n+            return new HashIterator(ENTRIES, table.length - 1);\n+        }\n+\n+        public boolean contains(Object o) {\n+            if (!(o instanceof Map.Entry)) return false;\n+            Map.Entry e = (Map.Entry) o;\n+            Entry candidate = getEntry(e.getKey());\n+            return candidate != null && candidate.equals(e);\n+        }\n+\n+        public boolean remove(Object o) {\n+            return removeMapping(o) != null;\n+        }\n+\n+        public int size() {\n+            return size;\n+        }\n+\n+        public void clear() {\n+            ConcurrentHashMap.this.clear();\n+        }\n+    }\n+\n+    /**\n+     * Save the state of the <tt>ConcurrentHashMap</tt> instance to a stream\n+     * (i.e., serialize it).\n+     *\n+     * @serialData The <i>capacity</i> of the ConcurrentHashMap(the length of\n+     * the bucket array) is emitted(int), followed by the <i>size</i> of the\n+     * ConcurrentHashMap(the number of key-value mappings), followed by the key\n+     * (Object) and value(Object) for each key-value mapping represented by the\n+     * ConcurrentHashMap The key-value mappings are emitted in the order that\n+     * they are returned by <tt>entrySet().iterator()</tt>.\n+     */\n+    private void writeObject(ObjectOutputStream s) throws IOException {\n+        // Write out the threshold, loadfactor, and any hidden stuff\n+        s.defaultWriteObject();\n+\n+        // Write out number of buckets\n+        s.writeInt(table.length);\n+\n+        // Write out size(number of Mappings)\n+        s.writeInt(size);\n+        s.writeInt(maxSize);\n+\n+        // Write out keys and values(alternating)\n+        for (Iterator i = entrySet().iterator(); i.hasNext();) {\n+            Map.Entry e = (Map.Entry) i.next();\n+            s.writeObject(e.getKey());\n+            s.writeObject(e.getValue());\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -6452706556724125778L;\n+\n+    /**\n+     * Reconstitute the <tt>ConcurrentHashMap</tt> instance from a stream(i.e.,\n+     * deserialize it).\n+     */\n+    private void readObject(ObjectInputStream s)\n+        throws IOException, ClassNotFoundException {\n+        // Read in the threshold, loadfactor, and any hidden stuff\n+        s.defaultReadObject();\n+\n+        // Read in number of buckets and allocate the bucket array;\n+        int numBuckets = s.readInt();\n+        table = new Entry[numBuckets];\n+\n+        // Read in size(number of Mappings)\n+        int size = s.readInt();\n+        \n+        // read the max size\n+        maxSize = s.readInt();\n+\n+        // Read the keys and values, and put the mappings in the\n+        // ConcurrentHashMap\n+        for (int i = 0; i < size; i++) {\n+            Object key = s.readObject();\n+            Object value = s.readObject();\n+            put(key, value);\n+        }\n+    }\n+}"}]}

