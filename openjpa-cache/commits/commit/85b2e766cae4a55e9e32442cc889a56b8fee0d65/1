{"sha":"85b2e766cae4a55e9e32442cc889a56b8fee0d65","node_id":"MDY6Q29tbWl0MjA2MzY0Ojg1YjJlNzY2Y2FlNGE1NWU5ZTMyNDQyY2M4ODlhNTZiOGZlZTBkNjU=","commit":{"author":{"name":"Marc Prud'hommeaux","email":"mprudhom@apache.org","date":"2007-07-01T19:37:04Z"},"committer":{"name":"Marc Prud'hommeaux","email":"mprudhom@apache.org","date":"2007-07-01T19:37:04Z"},"message":"OPENJPA-239 Patch to support the generation of annotation mappings using the reverse mapping tool\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@552358 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"95160584bb5f2df5ee8ec661d1c3ee6eaf172bc3","url":"https://api.github.com/repos/apache/openjpa/git/trees/95160584bb5f2df5ee8ec661d1c3ee6eaf172bc3"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/85b2e766cae4a55e9e32442cc889a56b8fee0d65","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/85b2e766cae4a55e9e32442cc889a56b8fee0d65","html_url":"https://github.com/apache/openjpa/commit/85b2e766cae4a55e9e32442cc889a56b8fee0d65","comments_url":"https://api.github.com/repos/apache/openjpa/commits/85b2e766cae4a55e9e32442cc889a56b8fee0d65/comments","author":null,"committer":null,"parents":[{"sha":"0b356dfc0dc4e7e1a80e17801ded076e8173b5a7","url":"https://api.github.com/repos/apache/openjpa/commits/0b356dfc0dc4e7e1a80e17801ded076e8173b5a7","html_url":"https://github.com/apache/openjpa/commit/0b356dfc0dc4e7e1a80e17801ded076e8173b5a7"}],"stats":{"total":2894,"additions":2864,"deletions":30},"files":[{"sha":"8c3612724bc6024366d4099483b36f3e83dd5133","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/ReverseMappingToolTask.java","status":"modified","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/ReverseMappingToolTask.java","raw_url":"https://github.com/apache/openjpa/raw/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/ReverseMappingToolTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/ant/ReverseMappingToolTask.java?ref=85b2e766cae4a55e9e32442cc889a56b8fee0d65","patch":"@@ -122,6 +122,14 @@ public void setBlobAsObject(boolean blobAsObject) {\n         flags.blobAsObject = blobAsObject;\n     }\n \n+    /**\n+     * Set whether to use generic collections on one-to-many and many-to-many\n+     * relations instead of untyped collections.\n+     */\n+    public void setUseGenericCollections(boolean useGenericCollections) {\n+        flags.useGenericCollections = useGenericCollections; \n+    }\n+\n     /**\n      * Set the SQL type map overrides.\n      */\n@@ -201,6 +209,22 @@ public void setMetadata(Level level) {\n         flags.metaDataLevel = level.getValue();\n     }\n \n+    /**\n+     * Whether to generate annotations along with generated code. Defaults\n+     * to false.\n+     */\n+    public void setGenerateAnnotations(boolean genAnnotations) {\n+        flags.generateAnnotations = genAnnotations;\n+    }\n+\n+    /**\n+     * Whether to use field or property-based access on generated code.\n+     * Defaults to field-based access.\n+     */\n+    public void setAccessType(AccessType accessType) {\n+        flags.accessType = accessType.getValue();\n+    }\n+    \n     /**\n      * Set a customizer class to use.\n      */\n@@ -255,6 +279,18 @@ protected void executeOn(String[] files)\n             return new String[]{\n                 \"package\",\n                 \"class\",\n+                \"none\"\n+            };\n+        }\n+    }\n+\n+    public static class AccessType\n+        extends EnumeratedAttribute {\n+\n+        public String[] getValues() {\n+            return new String[]{\n+                \"field\",\n+                \"property\"\n             };\n         }\n     }"},{"sha":"fe6099bd6eb9c411addc47497e777630d1773040","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java","status":"modified","additions":158,"deletions":8,"changes":166,"blob_url":"https://github.com/apache/openjpa/blob/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java","raw_url":"https://github.com/apache/openjpa/raw/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java?ref=85b2e766cae4a55e9e32442cc889a56b8fee0d65","patch":"@@ -136,9 +136,16 @@\n      */\n     public static final int TABLE_SUBCLASS = 5;\n \n+    public static final String LEVEL_NONE = \"none\";\n     public static final String LEVEL_PACKAGE = \"package\";\n     public static final String LEVEL_CLASS = \"class\";\n \n+    /**\n+     * Access type for generated source, defaults to field-based access.\n+     */\n+    public static final String ACCESS_TYPE_FIELD = \"field\";\n+    public static final String ACCESS_TYPE_PROPERTY = \"property\";\n+\n     private static Localizer _loc = Localizer.forPackage\n         (ReverseMappingTool.class);\n \n@@ -176,6 +183,7 @@\n     private SchemaGroup _schema = null;\n     private boolean _nullAsObj = false;\n     private boolean _blobAsObj = false;\n+    private boolean _useGenericColl = false;\n     private Properties _typeMap = null;\n     private boolean _useFK = false;\n     private boolean _useSchema = false;\n@@ -186,6 +194,8 @@\n     private String _idSuffix = \"Id\";\n     private boolean _inverse = true;\n     private boolean _detachable = false;\n+    private boolean _genAnnotations = false;\n+    private String _accessType = ACCESS_TYPE_FIELD;\n     private CodeFormat _format = null;\n     private ReverseCustomizer _custom = null;\n     private String _discStrat = null;\n@@ -196,6 +206,9 @@\n     // mess up certain customizers (bug 881)\n     private Set _abandonedFieldNames = null;\n \n+    // generated annotations, key = metadata, val = list of annotations\n+    private Map _annos = null;\n+\n     /**\n      * Constructor. Supply configuration.\n      */\n@@ -326,6 +339,22 @@ public void setBlobAsObject(boolean blobAsObj) {\n         _blobAsObj = blobAsObj;\n     }\n \n+    /**\n+     * Whether to use generic collections on one-to-many and many-to-many\n+     * relations instead of untyped collections.\n+     */\n+    public boolean getUseGenericCollections() {\n+        return _useGenericColl;\n+    }\n+\n+    /**\n+     * Whether to use generic collections on one-to-many and many-to-many\n+     * relations instead of untyped collections.\n+     */\n+    public void setUseGenericCollections(boolean useGenericCollections) {\n+        _useGenericColl = useGenericCollections; \n+    }\n+\n     /**\n      * Map of JDBC-name to Java-type-name entries that allows customization\n      * of reverse mapping columns to field types.\n@@ -478,6 +507,39 @@ public void setVersionStrategy(String versionStrat) {\n         _versStrat = versionStrat;\n     }\n \n+    /**\n+     * Whether to generate annotations along with generated code. Defaults\n+     * to false.\n+     */\n+    public boolean getGenerateAnnotations() {\n+        return _genAnnotations;\n+    }\n+\n+    /**\n+     * Whether to generate annotations along with generated code. Defaults\n+     * to false.\n+     */\n+    public void setGenerateAnnotations(boolean genAnnotations) {\n+        _genAnnotations = genAnnotations;\n+    }\n+\n+    /**\n+     * Whether to use field or property-based access on generated code.\n+     * Defaults to field-based access.\n+     */\n+    public String getAccessType() {\n+        return _accessType;\n+    }\n+\n+    /**\n+     * Whether to use field or property-based access on generated code.\n+     * Defaults to field-based access.\n+     */\n+    public void setAccessType(String accessType) {\n+        this._accessType = ACCESS_TYPE_PROPERTY.equalsIgnoreCase(accessType) ?\n+            ACCESS_TYPE_PROPERTY : ACCESS_TYPE_FIELD;\n+    }\n+\n     /**\n      * The code formatter for the generated Java code.\n      */\n@@ -784,7 +846,11 @@ public List recordCode(Map output)\n                 _log.info(_loc.get(\"class-code\", mappings[i]));\n \n             ApplicationIdTool aid = newApplicationIdTool(mappings[i]);\n-            gen = new ReverseCodeGenerator(mappings[i], aid);\n+            if (getGenerateAnnotations())\n+                gen = new AnnotatedCodeGenerator(mappings[i], aid);\n+            else\n+                gen = new ReverseCodeGenerator(mappings[i], aid);\n+\n             gen.generateCode();\n \n             if (output == null) {\n@@ -852,6 +918,31 @@ public Collection recordMetaData(boolean perClass, Map output)\n         return files;\n     }\n \n+    public void buildAnnotations() {\n+        Map output = new HashMap();\n+        // pretend mappings are all resolved\n+        ClassMapping[] mappings = getMappings();\n+        for (int i = 0; i < mappings.length; i++)\n+            mappings[i].setResolve(MODE_META | MODE_MAPPING, true);\n+\n+        // store in user's configured IO\n+        MetaDataFactory mdf = _conf.newMetaDataFactoryInstance();\n+        mdf.setRepository(getRepository());\n+        mdf.setStoreDirectory(_dir);\n+        mdf.store(mappings, new QueryMetaData[0], new SequenceMetaData[0],\n+            MODE_META | MODE_MAPPING | MODE_ANN_MAPPING, output);\n+        _annos = output;\n+    }\n+\n+    /**\n+     * Returns a list of stringified annotations for specified meta.\n+     */\n+    protected List getAnnotationsForMeta(Object meta) {\n+        if (null == _annos)\n+            return null;\n+        return (List) _annos.get(meta);\n+    }\n+\n     /**\n      * Generate and write the application identity code.\n      */\n@@ -1619,13 +1710,15 @@ public Object clone() {\n         tool.setUseForeignKeyName(getUseForeignKeyName());\n         tool.setNullableAsObject(getNullableAsObject());\n         tool.setBlobAsObject(getBlobAsObject());\n+        tool.setUseGenericCollections(getUseGenericCollections());\n         tool.setPrimaryKeyOnJoin(getPrimaryKeyOnJoin());\n         tool.setUseDataStoreIdentity(getUseDataStoreIdentity());\n         tool.setUseBuiltinIdentityClass(getUseBuiltinIdentityClass());\n         tool.setInnerIdentityClasses(getInnerIdentityClasses());\n         tool.setIdentityClassSuffix(getIdentityClassSuffix());\n         tool.setInverseRelations(getInverseRelations());\n         tool.setDetachable(getDetachable());\n+        tool.setGenerateAnnotations(getGenerateAnnotations());\n         tool.setCustomizer(getCustomizer());\n         tool.setCodeFormat(getCodeFormat());\n         return tool;\n@@ -1667,6 +1760,9 @@ public Object clone() {\n      * type instead.</li>\n      * <li><i>-blobAsObject/-bo &lt;true/t | false/f&gt;</i>: Set to true\n      * to make all binary columns map to Object rather than byte[].</li>\n+     * <li><i>-useGenericCollections/-gc &lt;true/t | false/f&gt;</i>: Set to\n+     * true to use generic collections on OneToMany and ManyToMany relations\n+     * (requires JDK 1.5 or higher).</li>\n      * <li><i>-typeMap/-typ &lt;types&gt;</i>: Default mapping of SQL type\n      * names to Java classes.</li>\n      * <li><i>-primaryKeyOnJoin/-pkj &lt;true/t | false/f&gt;</i>: Set to true\n@@ -1690,9 +1786,13 @@ public Object clone() {\n      * discriminator strategy to place on base classes.</li>\n      * <li><i>-versionStrategy/-vs &lt;strategy&gt;</i>: The default\n      * version strategy to place on base classes.</li>\n-     * <li><i>-metadata/-md &lt;class | package&gt;</i>: Specify the level the\n-     * metadata should be generated at. Defaults to generating a\n+     * <li><i>-metadata/-md &lt;class | package | none&gt;</i>: Specify the\n+     * level the metadata should be generated at. Defaults to generating a\n      * single package-level metadata file.</li>\n+     * <li><i>-annotations/-ann &lt;true/t | false/f&gt;</i>: Set to true to\n+     * generate JPA annotations in generated code.</li>\n+     * <li><i>-accessType/-access &lt;field | property&gt;</i>: Change access\n+     * type for generated annotations. Defaults to field access.</li>\n      * <li><i>-customizerClass/-cc &lt;class name&gt;</i>: The full class\n      * name of a {@link ReverseCustomizer} implementation to use to\n      * customize the reverse mapping process. Optional.</li>\n@@ -1749,6 +1849,8 @@ public static boolean run(JDBCConfiguration conf, String[] args,\n             (\"nullableAsObject\", \"no\", flags.nullableAsObject);\n         flags.blobAsObject = opts.removeBooleanProperty\n             (\"blobAsObject\", \"bo\", flags.blobAsObject);\n+        flags.useGenericCollections = opts.removeBooleanProperty\n+            (\"useGenericCollections\", \"gc\", flags.useGenericCollections);\n         flags.primaryKeyOnJoin = opts.removeBooleanProperty\n             (\"primaryKeyOnJoin\", \"pkj\", flags.primaryKeyOnJoin);\n         flags.useDataStoreIdentity = opts.removeBooleanProperty\n@@ -1768,7 +1870,11 @@ public static boolean run(JDBCConfiguration conf, String[] args,\n         flags.versionStrategy = opts.removeProperty\n             (\"versionStrategy\", \"vs\", flags.versionStrategy);\n         flags.metaDataLevel = opts.removeProperty\n-            (\"metadata\", \"md\", flags.metaDataLevel);\n+            (\"metadata\", \"md\", flags.metaDataLevel);        \n+        flags.generateAnnotations = opts.removeBooleanProperty\n+            (\"annotations\", \"ann\", flags.generateAnnotations);\n+        flags.accessType = opts.removeProperty\n+            (\"accessType\", \"access\", flags.accessType);\n \n         String typeMap = opts.removeProperty(\"typeMap\", \"typ\", null);\n         if (typeMap != null)\n@@ -1869,6 +1975,7 @@ public static void run(JDBCConfiguration conf, String[] args,\n         tool.setUseForeignKeyName(flags.useForeignKeyName);\n         tool.setNullableAsObject(flags.nullableAsObject);\n         tool.setBlobAsObject(flags.blobAsObject);\n+        tool.setUseGenericCollections(flags.useGenericCollections);\n         tool.setTypeMap(flags.typeMap);\n         tool.setPrimaryKeyOnJoin(flags.primaryKeyOnJoin);\n         tool.setUseDataStoreIdentity(flags.useDataStoreIdentity);\n@@ -1877,16 +1984,24 @@ public static void run(JDBCConfiguration conf, String[] args,\n         tool.setIdentityClassSuffix(flags.identityClassSuffix);\n         tool.setInverseRelations(flags.inverseRelations);\n         tool.setDetachable(flags.detachable);\n+        tool.setGenerateAnnotations(flags.generateAnnotations);\n+        tool.setAccessType(flags.accessType);\n         tool.setCustomizer(flags.customizer);\n         tool.setCodeFormat(flags.format);\n \n         // run\n         log.info(_loc.get(\"revtool-map\"));\n         tool.run();\n+        if (flags.generateAnnotations) {\n+            log.info(_loc.get(\"revtool-gen-annos\"));\n+            tool.buildAnnotations();\n+        }\n         log.info(_loc.get(\"revtool-write-code\"));\n         tool.recordCode();\n-        log.info(_loc.get(\"revtool-write-metadata\"));\n-        tool.recordMetaData(LEVEL_CLASS.equals(flags.metaDataLevel));\n+        if (!LEVEL_NONE.equals(flags.metaDataLevel)) {\n+            log.info(_loc.get(\"revtool-write-metadata\"));\n+            tool.recordMetaData(LEVEL_CLASS.equals(flags.metaDataLevel));\n+        }\n     }\n \n     /**\n@@ -1900,6 +2015,7 @@ public static void run(JDBCConfiguration conf, String[] args,\n         public boolean useForeignKeyName = false;\n         public boolean nullableAsObject = false;\n         public boolean blobAsObject = false;\n+        public boolean useGenericCollections = false;\n         public Properties typeMap = null;\n         public boolean primaryKeyOnJoin = false;\n         public boolean useDataStoreIdentity = false;\n@@ -1908,6 +2024,8 @@ public static void run(JDBCConfiguration conf, String[] args,\n         public String identityClassSuffix = \"Id\";\n         public boolean inverseRelations = true;\n         public boolean detachable = false;\n+        public boolean generateAnnotations = false;\n+        public String accessType = ACCESS_TYPE_FIELD;\n         public String metaDataLevel = LEVEL_PACKAGE;\n         public String discriminatorStrategy = null;\n         public String versionStrategy = null;\n@@ -1983,8 +2101,8 @@ private boolean hasSubclasses(ClassMapping cls) {\n     private class ReverseCodeGenerator\n         extends CodeGenerator {\n \n-        private final ClassMapping _mapping;\n-        private final ApplicationIdTool _appid;\n+        protected final ClassMapping _mapping;\n+        protected final ApplicationIdTool _appid;\n \n         public ReverseCodeGenerator(ClassMapping mapping,\n             ApplicationIdTool aid) {\n@@ -2046,5 +2164,37 @@ protected String getFieldCode(FieldMetaData field) {\n                 return null;\n             return _custom.getFieldCode((FieldMapping) field);\n         }\n+\n+        protected boolean useGenericCollections() {\n+            return _useGenericColl;\n+        }\n+    }\n+\n+    private class AnnotatedCodeGenerator\n+        extends ReverseCodeGenerator {\n+\n+        public AnnotatedCodeGenerator (ClassMapping mapping,\n+            ApplicationIdTool aid) {\n+            super (mapping, aid);\n+        }\n+\n+        public Set getImportPackages() {\n+            Set pkgs = super.getImportPackages();\n+            pkgs.add(\"javax.persistence\");\n+            return pkgs;\n+        }\n+\n+        protected List getClassAnnotations() {\n+            return getAnnotationsForMeta(_mapping);\n+        }\n+\n+        protected List getFieldAnnotations(FieldMetaData field) {\n+            return getAnnotationsForMeta(field);\n+        }\n+\n+        protected boolean usePropertyBasedAccess () {\n+            return ACCESS_TYPE_PROPERTY.equals(_accessType);\n+        }\n+\n     }\n }"},{"sha":"8addfff9b70cb491de48485e1de7361f71ba788e","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties?ref=85b2e766cae4a55e9e32442cc889a56b8fee0d65","patch":"@@ -359,6 +359,7 @@ revtool-map: Calculating reverse mappings.\n revtool-write-code: Writing generated class source code.\n revtool-write-appid: Writing generated application identity classes.\n revtool-write-metadata: Writing generated metadata.\n+revtool-gen-annos: Generating annotations.\n revtool-usage: Usage: java org.apache.openjpa.jdbc.meta.ReverseMappingTool\\n\\\n \t\\t[-properties/-p <properties file or resource>]\\n\\\n \t\\t[-<property name> <property value>]*\\n\\\n@@ -369,6 +370,7 @@ revtool-usage: Usage: java org.apache.openjpa.jdbc.meta.ReverseMappingTool\\n\\\n \t\\t[-useForeignKeyName/-fkn <true/t | false/f>]\\n\\\n \t\\t[-nullableAsObject/-no <true/t | false/f>]\\n\\\n \t\\t[-blobAsObject/-bo <true/t | false/f>]\\n\\\n+\t\\t[-useGenericCollections/-gc <true/t | false/f>]\\n\\\n \t\\t[-typeMap/-type <types>]\\n\\\n \t\\t[-primaryKeyOnJoin/-pkj <true/t | false/f>]\\n\\\n \t\\t[-useDatastoreIdentity/-ds <true/t | false/f>]\\n\\\n@@ -379,7 +381,9 @@ revtool-usage: Usage: java org.apache.openjpa.jdbc.meta.ReverseMappingTool\\n\\\n \t\\t[-detachable/-det <true/t | false/f>]\\n\\\n \t\\t[-discriminatorStrategy/-ds <strategy>]\\n\\\n \t\\t[-versionStrategy/-vs <strategy>]\\n\\\n-\t\\t[-metadata/-md <package | class>]\\n\\\n+\t\\t[-metadata/-md <package | class | none>]\\n\\\n+\t\\t[-annotations/-ann <true/t | false/f>]\\n\\\n+\t\\t[-accessType/-access <field | property>]\\n\\\n \t\\t[-customizerClass/-cc <full class name>]\\n\\\n \t\\t[-customizerProperties/-cp <properties file or resource>]\\n\\\n \t\\t[-customizer/-c.<property name> <property value>]*\\n\\"},{"sha":"981937aa634ab3e581be80d2067968ba47b0eac5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java","status":"modified","additions":101,"deletions":13,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java?ref=85b2e766cae4a55e9e32442cc889a56b8fee0d65","patch":"@@ -24,8 +24,10 @@\n import java.util.Iterator;\n import java.util.Set;\n import java.util.TreeSet;\n+import java.util.List;\n \n import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang.WordUtils;\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.lib.util.CodeFormat;\n import org.apache.openjpa.lib.util.Files;\n@@ -307,27 +309,47 @@ private void appendFieldCode(FieldMetaData fmd, CodeFormat decs,\n             propertyName = propertyName.substring(1);\n         String fieldType = Strings.getClassName(fmd.getDeclaredType());\n \n+        String keyType = null;\n+        String elementType = null;\n+        String paramType = \"\";\n+        if (useGenericCollections()) {\n+            if (fmd.getDeclaredTypeCode() == JavaTypes.COLLECTION) {\n+                Class elmCls = fmd.getElement().getDeclaredType();\n+                elementType = Strings.getClassName(elmCls);\n+                paramType = decs.getParametrizedType(\n+                    new String[] {elementType});\n+            } else if (fmd.getDeclaredTypeCode() == JavaTypes.MAP) {\n+                Class keyCls = fmd.getKey().getDeclaredType();\n+                Class elmCls = fmd.getElement().getDeclaredType();\n+                keyType = Strings.getClassName(keyCls);\n+                elementType = Strings.getClassName(elmCls);\n+                paramType = decs.getParametrizedType(\n+                    new String[] {keyType, elementType});\n+            }\n+        }\n+\n         String fieldValue = getInitialValue(fmd);\n         if (fieldValue == null) {\n             if (\"Set\".equals(fieldType))\n-                fieldValue = \"new HashSet\" + decs.getParens();\n+                fieldValue = \"new HashSet\" + paramType + decs.getParens();\n             else if (\"TreeSet\".equals(fieldType))\n-                fieldValue = \"new TreeSet\" + decs.getParens();\n+                fieldValue = \"new TreeSet\" + paramType + decs.getParens();\n             else if (\"Collection\".equals(fieldType))\n-                fieldValue = \"new ArrayList\" + decs.getParens();\n+                fieldValue = \"new ArrayList\" + paramType + decs.getParens();\n             else if (\"Map\".equals(fieldType))\n-                fieldValue = \"new HashMap\" + decs.getParens();\n+                fieldValue = \"new HashMap\" + paramType + decs.getParens();\n             else if (\"TreeMap\".equals(fieldType))\n-                fieldValue = \"new TreeMap\" + decs.getParens();\n-            else if (fmd.getDeclaredTypeCode() == JavaTypes.COLLECTION\n-                || fmd.getDeclaredTypeCode() == JavaTypes.MAP)\n-                fieldValue = \"new \" + fieldType + decs.getParens();\n+                fieldValue = \"new TreeMap\" + paramType + decs.getParens();\n+            else if (fmd.getDeclaredTypeCode() == JavaTypes.COLLECTION ||\n+                fmd.getDeclaredTypeCode() == JavaTypes.MAP)\n+                fieldValue = \"new \" + fieldType + paramType + decs.getParens();\n             else\n                 fieldValue = \"\";\n         }\n         if (fieldValue.length() > 0)\n             fieldValue = \" = \" + fieldValue;\n \n+        boolean fieldAccess = !usePropertyBasedAccess();\n         String custom = getDeclaration(fmd);\n         if (decs.length() > 0)\n             decs.endl();\n@@ -339,12 +361,18 @@ else if (fmd.getDeclaredTypeCode() == JavaTypes.COLLECTION\n             templ.setParameter(\"capFieldName\", capFieldName);\n             templ.setParameter(\"propertyName\", propertyName);\n             templ.setParameter(\"fieldType\", fieldType);\n+            templ.setParameter(\"keyType\", keyType);\n+            templ.setParameter(\"elementType\", elementType);\n             templ.setParameter(\"fieldValue\", fieldValue);\n             decs.append(templ.toString());\n         } else {\n+            if (fieldAccess)\n+                writeAnnotations(decs, getFieldAnnotations(fmd), 1);\n             decs.tab().append(\"private \").append(fieldType).\n-                append(\" \").append(fieldName).append(fieldValue).\n-                append(\";\");\n+                append(paramType).append(\" \").append(fieldName).\n+                append(fieldValue).append(\";\");\n+            if (fieldAccess)\n+                decs.endl();\n         }\n \n         custom = getFieldCode(fmd);\n@@ -357,11 +385,16 @@ else if (fmd.getDeclaredTypeCode() == JavaTypes.COLLECTION\n             templ.setParameter(\"capFieldName\", capFieldName);\n             templ.setParameter(\"propertyName\", propertyName);\n             templ.setParameter(\"fieldType\", fieldType);\n+            templ.setParameter(\"keyType\", keyType);\n+            templ.setParameter(\"elementType\", elementType);\n             templ.setParameter(\"fieldValue\", fieldValue);\n             code.append(templ.toString());\n         } else {\n             // getter\n-            code.tab().append(\"public \").append(fieldType).append(\" \");\n+            if (!fieldAccess)\n+                writeAnnotations(code, getFieldAnnotations(fmd), 1);\n+            code.tab().append(\"public \").append(fieldType).append(paramType).\n+                 append(\" \");\n             if (\"boolean\".equalsIgnoreCase(fieldType))\n                 code.append(\"is\");\n             else\n@@ -374,8 +407,8 @@ else if (fmd.getDeclaredTypeCode() == JavaTypes.COLLECTION\n \n             // setter\n             code.tab().append(\"public void set\").append(capFieldName);\n-            code.openParen(true).append(fieldType).append(\" \").\n-                append(propertyName).closeParen();\n+            code.openParen(true).append(fieldType).append(paramType).\n+                append(\" \").append(propertyName).closeParen();\n             code.openBrace(2).endl();\n             code.tab(2);\n             if (propertyName.equals(fieldName))\n@@ -403,6 +436,7 @@ private String getClassCode(String packageDec, String imports,\n             append(\" * \").append(getClass().getName()).endl().\n             append(\" */\").endl();\n \n+        writeAnnotations(code, getClassAnnotations(), 0);\n         code.append(\"public class \").append(className);\n         if (extendsName.length() > 0)\n             code.extendsDec(1).append(\" \").append(extendsName);\n@@ -426,6 +460,21 @@ private String getClassCode(String packageDec, String imports,\n         return code.toString();\n     }\n \n+    /**\n+     * Appends the given list of annotations to code buffer.\n+     */\n+    private void writeAnnotations (CodeFormat code, List ann,\n+        int tabLevel) {\n+        if (ann == null || ann.size() == 0)\n+            return;\n+        for (Iterator i = ann.iterator(); i.hasNext();) {\n+            if (tabLevel > 0)\n+                code.tab(tabLevel);\n+            String s = (String) i.next();\n+            code.append(s).endl();\n+        }\n+    }\n+\n     /**\n      * Append the opening code-level brace to the code; this can be\n      * overridden to add code to the top of the class.\n@@ -503,6 +552,9 @@ protected String getInitialValue(FieldMetaData field) {\n      * <li>${capFieldName}: The capitalized field name.</li>\n      * <li>${propertyName}: The field name without leading '_', if any.</li>\n      * <li>${fieldType}: The field's type name.</li>\n+     * <li>${keyType}: Key type name for maps, null otherwise.</li>\n+     * <li>${elementType}: Element type name for collections, null otherwise.\n+     * </li>\n      * <li>${fieldValue}: The field's initial value, in the form\n      * \" = &lt;value&gt;\", or empty string if none.</li>\n      * </ul> Returns null by default.\n@@ -521,6 +573,9 @@ protected String getDeclaration(FieldMetaData field) {\n      * <li>${capFieldName}: The capitalized field name.</li>\n      * <li>${propertyName}: The field name without leading '_', if any.</li>\n      * <li>${fieldType}: The field's type name.</li>\n+     * <li>${keyType}: Key type name for maps, null otherwise.</li>\n+     * <li>${elementType}: Element type name for collections, null otherwise.\n+     * </li>\n      * <li>${fieldValue}: The field's initial value, in the form\n      * \"= &lt;value&gt;\", or empty string if none.</li>\n      * </ul>\n@@ -529,4 +584,37 @@ protected String getFieldCode (FieldMetaData field)\n \t{\n \t\treturn null;\n \t}\n+\n+    /**\n+     * Whether to use property-based access on generated code.\n+     * Defaults to false (field-based).\n+     */    \n+    protected boolean usePropertyBasedAccess () {\n+        return false;\n+    }\n+\n+    /**\n+     * Return class-level annotations. Returns null by default.\n+     */\n+    protected List getClassAnnotations() {\n+        return null;\n+    }\n+\n+    /**\n+     * Return field-level annotations. Returns null by default.\n+     */\n+    protected List getFieldAnnotations(FieldMetaData field) {\n+        return null;\n+    }\n+\n+    /**\n+     * Whether to use generic collections on one-to-many and many-to-many\n+     * relations instead of untyped collections.\n+     *\n+     * Override in descendants to change default behavior.\n+     */\n+    protected boolean useGenericCollections() {\n+        return false;\n+    }\n+\n }"},{"sha":"a822024a4c275a147f295563133390d55f9b158f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java","status":"modified","additions":13,"deletions":2,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java?ref=85b2e766cae4a55e9e32442cc889a56b8fee0d65","patch":"@@ -192,7 +192,10 @@ public boolean store(ClassMetaData[] metas, QueryMetaData[] queries,\n         Parser parser;\n         if (mode != MODE_QUERY) {\n             int sermode = (isMappingOnlyFactory()) ? mode : mode | MODE_META;\n-            ser = newSerializer();\n+            if ((mode & MODE_ANN_MAPPING) != 0)\n+                ser = newAnnotationSerializer();\n+            else\n+                ser = newSerializer();\n             ser.setMode(sermode);\n             if (metaFiles != null) {\n                 parser = newParser(false);\n@@ -231,7 +234,10 @@ public boolean store(ClassMetaData[] metas, QueryMetaData[] queries,\n             for (int i = 0; !qFiles && i < queries.length; i++)\n                 qFiles = queries[i].getSourceMode() == MODE_QUERY;\n             if (qFiles) {\n-                ser = newSerializer();\n+                if ((mode & MODE_ANN_MAPPING) != 0)\n+                    ser = newAnnotationSerializer();\n+                else\n+                    ser = newSerializer();\n                 ser.setMode(MODE_QUERY);\n                 if (queryFiles != null) {\n                     parser = newParser(false);\n@@ -543,6 +549,11 @@ protected abstract File defaultSourceFile(SequenceMetaData seq,\n      */\n     protected abstract Serializer newSerializer();\n \n+    /**\n+     * Create a new annotation metadata serializer.\n+     */\n+    protected abstract Serializer newAnnotationSerializer();\n+\n     /**\n      * Return the metadata that defines the given query, if any.\n      *"},{"sha":"743d903a7018558bffa8270ec76409f8765d5b4d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataModes.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataModes.java","raw_url":"https://github.com/apache/openjpa/raw/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataModes.java?ref=85b2e766cae4a55e9e32442cc889a56b8fee0d65","patch":"@@ -32,4 +32,5 @@\n     public static final int MODE_MAPPING = 2;\n     public static final int MODE_QUERY = 4;\n     public static final int MODE_MAPPING_INIT = 8;\n+    public static final int MODE_ANN_MAPPING = 16;\n }"},{"sha":"b92a59008f15341174d882083e8749f5cf0cd91a","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/CodeFormat.java","status":"modified","additions":16,"deletions":0,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/CodeFormat.java","raw_url":"https://github.com/apache/openjpa/raw/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/CodeFormat.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/CodeFormat.java?ref=85b2e766cae4a55e9e32442cc889a56b8fee0d65","patch":"@@ -308,6 +308,22 @@ public String getTab(int tabLevel) {\n         return tabs.toString();\n     }\n \n+\n+    /**\n+     * Returns parametrized type string for given type(s).\n+     */\n+    public String getParametrizedType(String[] typenames) {\n+        StringBuffer buf = new StringBuffer ();\n+        buf.append(\"<\");\n+        for (int i = 0; i < typenames.length; i++) {\n+            if (i > 0)\n+                buf.append(\", \");\n+            buf.append(typenames[i]);\n+        }\n+        buf.append(\">\");\n+        return buf.toString();\n+    }\n+\n     /**\n      * Return the field name for given suggested name, possibly adding\n      * leading underscore."},{"sha":"594f4faecba1578959fa2b6319f70876500769e3","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingSerializer.java","status":"added","additions":793,"deletions":0,"changes":793,"blob_url":"https://github.com/apache/openjpa/blob/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingSerializer.java?ref=85b2e766cae4a55e9e32442cc889a56b8fee0d65","patch":"@@ -0,0 +1,793 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.jdbc;\n+\n+import org.apache.openjpa.persistence.AnnotationPersistenceMetaDataSerializer;\n+import org.apache.openjpa.persistence.PersistenceStrategy;\n+import org.apache.openjpa.persistence.AnnotationBuilder;\n+import org.apache.openjpa.jdbc.meta.QueryResultMapping;\n+import org.apache.openjpa.jdbc.meta.MappingRepository;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.ClassMappingInfo;\n+import org.apache.openjpa.jdbc.meta.DiscriminatorMappingInfo;\n+import org.apache.openjpa.jdbc.meta.MappingInfo;\n+import org.apache.openjpa.jdbc.meta.SequenceMapping;\n+import org.apache.openjpa.jdbc.meta.ValueMappingInfo;\n+import org.apache.openjpa.jdbc.meta.strats.FlatClassStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.VerticalClassStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.FullClassStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.EnumValueHandler;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.schema.Unique;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.SequenceMetaData;\n+import org.apache.openjpa.meta.MetaDataModes;\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.sql.Types;\n+import java.lang.annotation.Annotation;\n+\n+import serp.util.Strings;\n+\n+import javax.persistence.TemporalType;\n+import javax.persistence.EnumType;\n+import javax.persistence.InheritanceType;\n+import javax.persistence.Table;\n+import javax.persistence.SecondaryTable;\n+import javax.persistence.Inheritance;\n+import javax.persistence.DiscriminatorValue;\n+import javax.persistence.DiscriminatorColumn;\n+import javax.persistence.JoinTable;\n+import javax.persistence.Lob;\n+import javax.persistence.Temporal;\n+import javax.persistence.Enumerated;\n+import javax.persistence.UniqueConstraint;\n+import javax.persistence.TableGenerator;\n+import javax.persistence.JoinColumns;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.PrimaryKeyJoinColumn;\n+import javax.persistence.PrimaryKeyJoinColumns;\n+import javax.persistence.SqlResultSetMapping;\n+import javax.persistence.EntityResult;\n+import javax.persistence.FieldResult;\n+import javax.persistence.ColumnResult;\n+\n+//@todo: javadocs\n+\n+/**\n+ * Serializes persistence mappings as annotations.\n+ *\n+ * @since 1.0.0\n+ * @author Steve Kim\n+ * @author Gokhan Ergul\n+ * @nojavadoc\n+ */\n+public class AnnotationPersistenceMappingSerializer\n+    extends AnnotationPersistenceMetaDataSerializer {\n+\n+    private static final int TYPE_RESULTMAP = TYPE_QUERY + 1;\n+\n+    private List<QueryResultMapping> _results = null;\n+    private boolean _sync = false;\n+\n+    private Map<QueryResultMapping, List<AnnotationBuilder>> _rsmAnnos = null;\n+    \n+    /**\n+     * Constructor. Supply configuration.\n+     */\n+    public AnnotationPersistenceMappingSerializer(JDBCConfiguration conf) {\n+        super(conf);\n+    }\n+\n+    /**\n+     * Whether to automatically synchronize mapping info with data available\n+     * from mapped components before serialization. Defaults to false.\n+     */\n+    public boolean getSyncMappingInfo() {\n+        return _sync;\n+    }\n+\n+    /**\n+     * Whether to automatically synchronize mapping info with data available\n+     * from mapped components before serialization. Defaults to false.\n+     */\n+    public void setSyncMappingInfo(boolean sync) {\n+        _sync = sync;\n+    }\n+\n+    /**\n+     * Adds the given result set mapping to local cache.\n+     */\n+    public void addQueryResultMapping(QueryResultMapping meta) {\n+        if (_results == null)\n+            _results = new ArrayList<QueryResultMapping>();\n+        _results.add(meta);\n+    }\n+\n+    /**\n+     * Removes given result set mapping from the local cache.\n+     */\n+    public boolean removeQueryResultMapping(QueryResultMapping meta) {\n+        return _results != null && _results.remove(meta);\n+    }\n+\n+    @Override\n+    public void addAll(MetaDataRepository repos) {\n+        super.addAll(repos);\n+        for (QueryResultMapping res : ((MappingRepository) repos)\n+            .getQueryResultMappings())\n+            addQueryResultMapping(res);\n+    }\n+\n+    @Override\n+    public boolean removeAll(MetaDataRepository repos) {\n+        boolean removed = super.removeAll(repos);\n+        for (QueryResultMapping res : ((MappingRepository) repos)\n+            .getQueryResultMappings())\n+            removed |= removeQueryResultMapping(res);\n+        return removed;\n+    }\n+\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        if (_results != null)\n+            _results.clear();\n+    }\n+\n+    /**\n+     * Add an annotation builder to list of builders for the specified\n+     * class metadata.\n+     */\n+    protected void addAnnotation(AnnotationBuilder ab, QueryResultMapping meta) {\n+        if (_rsmAnnos == null)\n+            _rsmAnnos = new HashMap<QueryResultMapping, List<AnnotationBuilder>>();\n+        List<AnnotationBuilder> list = _rsmAnnos.get(meta);\n+        if (list == null) {\n+            list = new ArrayList<AnnotationBuilder>();\n+            _rsmAnnos.put(meta, list);\n+        }\n+        list.add(ab);\n+    }\n+\n+    /**\n+     * Creates an an annotation builder for the specified class metadata\n+     * and adds it to list of builders.\n+     */\n+    protected AnnotationBuilder addAnnotation(\n+        Class<? extends Annotation> annType, QueryResultMapping meta) {\n+        AnnotationBuilder ab = newAnnotationBuilder(annType);\n+        if (meta == null)\n+            return ab;\n+        addAnnotation(ab, meta);\n+        return ab;\n+    }\n+\n+\n+    @Override\n+    protected void serializeClass(ClassMetaData meta) {\n+        if (_sync && isMappingMode() && meta instanceof ClassMapping) {\n+            // sync if resolved and mapped\n+            ClassMapping cls = (ClassMapping) meta;\n+            if ((cls.getResolve() & MetaDataModes.MODE_MAPPING) != 0 &&\n+                cls.isMapped()) {\n+                cls.syncMappingInfo();\n+                cls.getDiscriminator().syncMappingInfo();\n+                cls.getVersion().syncMappingInfo();\n+                FieldMapping[] fields;\n+                if (cls.getEmbeddingMetaData() == null)\n+                    fields = cls.getDefinedFieldMappings();\n+                else\n+                    fields = cls.getFieldMappings();\n+                for (FieldMapping f : fields)\n+                    f.syncMappingInfo();\n+            }\n+        }\n+        super.serializeClass(meta);\n+    }\n+\n+    @Override\n+    protected void serializeClassMappingContent(ClassMetaData mapping) {\n+        ClassMapping cls = (ClassMapping) mapping;\n+        ClassMappingInfo info = cls.getMappingInfo();\n+        AnnotationBuilder abTable = addAnnotation(Table.class, mapping);\n+        serializeTable(info.getTableName(), Strings\n+            .getClassName(mapping.getDescribedType()), null,\n+            info.getUniques(), abTable);\n+        serializeColumns(info, ColType.PK_JOIN, null, abTable, cls);\n+        for (String second : info.getSecondaryTableNames()) {\n+            AnnotationBuilder abSecTable =\n+                addAnnotation(SecondaryTable.class, mapping);\n+            serializeTable(second, null, info, null, abSecTable);\n+        }\n+    }\n+\n+    @Override\n+    protected void serializeInheritanceContent(ClassMetaData mapping) {\n+        ClassMapping cls = (ClassMapping) mapping;\n+        ClassMappingInfo info = cls.getMappingInfo();\n+        DiscriminatorMappingInfo dinfo = cls.getDiscriminator()\n+            .getMappingInfo();\n+        String strat = info.getHierarchyStrategy();\n+        if (null == strat)\n+            return;\n+        String itypecls = Strings.getClassName(InheritanceType.class);\n+        AnnotationBuilder abInheritance =\n+            addAnnotation(Inheritance.class, mapping);\n+        if (FlatClassStrategy.ALIAS.equals(strat))\n+            abInheritance.add(\"strategy\", itypecls + \".SINGLE_TABLE\");\n+        else if (VerticalClassStrategy.ALIAS.equals(strat))\n+            abInheritance.add(\"strategy\", itypecls + \".JOINED\");\n+        else if (FullClassStrategy.ALIAS.equals(strat))\n+            abInheritance.add(\"strategy\", itypecls + \".TABLE_PER_CLASS\");\n+        if (dinfo.getValue() != null) {\n+            AnnotationBuilder abDiscVal =\n+                addAnnotation(DiscriminatorValue.class, mapping);\n+            abDiscVal.add(null, dinfo.getValue());\n+        }\n+        AnnotationBuilder abDiscCol =\n+            addAnnotation(DiscriminatorColumn.class, mapping);\n+        serializeColumns(dinfo, ColType.DISC, null, abDiscCol, null);\n+    }\n+\n+    /**\n+     * Serialize table optionally listing primary-key-joins stored\n+     * in the given {@link org.apache.openjpa.jdbc.meta.ClassMappingInfo}.\n+     */\n+    private void serializeTable(String table, String defaultName,\n+        ClassMappingInfo secondaryInfo, Unique[] uniques,\n+        AnnotationBuilder ab) {\n+        List<Column> cols = null;\n+        if (secondaryInfo != null)\n+            cols = (List<Column>) secondaryInfo.getSecondaryTableJoinColumns\n+                (table);\n+\n+        boolean print = (cols != null && cols.size() > 0) ||\n+            (uniques != null && uniques.length > 0);\n+        if (table != null\n+            && (defaultName == null || !defaultName.equals(table))) {\n+            print = true;\n+            int index = table.indexOf('.');\n+            if (index < 0)\n+                ab.add(\"name\", table);\n+            else {\n+                ab.add(\"schema\", table.substring(0, index));\n+                ab.add(\"name\", table.substring(index + 1));\n+            }\n+        }\n+        if (print) {\n+            if (cols != null) {\n+                for (Column col : cols)\n+                    serializeColumn(col, ColType.PK_JOIN,\n+                        null, false, ab, null);\n+            }\n+            if (uniques != null) {\n+                for (Unique unique: uniques) {\n+                    AnnotationBuilder abUniqueConst =\n+                        newAnnotationBuilder(UniqueConstraint.class);\n+                    serializeUniqueConstraint(unique, abUniqueConst);\n+                    ab.add(\"uniqueConstraints\", abUniqueConst);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected boolean serializeAttributeOverride(FieldMetaData fmd,\n+        FieldMetaData orig) {\n+        if (orig == null || fmd == orig)\n+            return false;\n+\n+        FieldMapping field = (FieldMapping) fmd;\n+        FieldMapping field2 = (FieldMapping) orig;\n+        if (field.getMappingInfo().hasSchemaComponents()\n+            || field2.getMappingInfo().hasSchemaComponents())\n+            return true;\n+\n+        ValueMappingInfo info = field.getValueInfo();\n+        List<Column> cols = (List<Column>) info.getColumns();\n+        if (cols == null || cols.size() == 0)\n+            return false;\n+        ValueMappingInfo info2 = field2.getValueInfo();\n+        List<Column> cols2 = (List<Column>) info2.getColumns();\n+        if (cols2 == null || cols2.size() != cols.size())\n+            return true;\n+        if (cols.size() != 1)\n+            return true;\n+\n+        Column col;\n+        Column col2;\n+        for (int i = 0; i < cols.size(); i++) {\n+            col = cols.get(i);\n+            col2 = cols2.get(i);\n+            if (!StringUtils.equals(col.getName(), col2.getName()))\n+                return true;\n+            if (!StringUtils.equals(col.getTypeName(), col2.getTypeName()))\n+                return true;\n+            if (col.getSize() != col2.getSize())\n+                return true;\n+            if (col.getDecimalDigits() != col2.getDecimalDigits())\n+                return true;\n+            if (col.getFlag(Column.FLAG_UNINSERTABLE)\n+                != col2.getFlag(Column.FLAG_UNINSERTABLE))\n+                return true;\n+            if (col.getFlag(Column.FLAG_UNUPDATABLE)\n+                != col2.getFlag(Column.FLAG_UNUPDATABLE))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    protected void serializeAttributeOverrideMappingContent(FieldMetaData fmd,\n+        FieldMetaData orig, AnnotationBuilder ab) {\n+        FieldMapping fm = (FieldMapping) fmd;\n+        serializeColumns(fm.getValueInfo(), ColType.COL, fm.getMappingInfo()\n+            .getTableName(), ab, fmd);\n+    }\n+\n+    @Override\n+    protected PersistenceStrategy getStrategy(FieldMetaData fmd) {\n+        PersistenceStrategy strat = super.getStrategy(fmd);\n+        FieldMapping field = (FieldMapping) fmd;\n+        switch (strat) {\n+            case MANY_MANY:\n+                // we can differentiate a one-many by the fact that there is no\n+                // secondary table join, or the fk is unique\n+                if (field.getMappedBy() == null\n+                    && (field.getMappingInfo().getJoinDirection()\n+                    == MappingInfo.JOIN_NONE\n+                    || field.getElementMapping().getValueInfo().getUnique()\n+                    != null))\n+                    return PersistenceStrategy.ONE_MANY;\n+                break;\n+            case MANY_ONE:\n+                // inverse join cols or unique fk?\n+                if (field.getValueInfo().getJoinDirection()\n+                    == MappingInfo.JOIN_INVERSE\n+                    || field.getValueInfo().getUnique() != null)\n+                    return PersistenceStrategy.ONE_ONE;\n+\n+                // scan for primary-key-join-column\n+                List<Column> cols = field.getValueInfo().getColumns();\n+                boolean pkJoin = cols != null && cols.size() > 0;\n+                for (int i = 0; pkJoin && i < cols.size(); i++)\n+                    pkJoin = cols.get(i).getFlag(Column.FLAG_PK_JOIN);\n+                if (pkJoin)\n+                    return PersistenceStrategy.ONE_ONE;\n+                break;\n+        }\n+        return strat;\n+    }\n+\n+    @Override\n+    protected void serializeFieldMappingContent(FieldMetaData fmd,\n+        PersistenceStrategy strategy, AnnotationBuilder ab) {\n+        if (fmd.getMappedBy() != null)\n+            return;\n+\n+        // while I'd like to do auto detection based on join directions, etc.\n+        // the distinguished column / table / etc names forces our hand\n+        // esp for OpenJPA custom mappings.\n+        FieldMapping field = (FieldMapping) fmd;\n+        switch (strategy) {\n+            case ONE_ONE:\n+            case MANY_ONE:\n+                serializeColumns(field.getValueInfo(), ColType.JOIN,\n+                    field.getMappingInfo().getTableName(), null, fmd);\n+                return;\n+            case ONE_MANY:\n+                if (field.getMappingInfo().getJoinDirection() ==\n+                    MappingInfo.JOIN_NONE) {\n+                    serializeColumns(field.getElementMapping().getValueInfo(),\n+                        ColType.JOIN, null, null, fmd);\n+                    return;\n+                }\n+                // else no break\n+            case MANY_MANY:\n+                if (field.getMappingInfo().hasSchemaComponents()\n+                    || field.getElementMapping().getValueInfo()\n+                    .hasSchemaComponents()) {\n+                    AnnotationBuilder abJoinTbl =\n+                        addAnnotation(JoinTable.class, fmd);\n+                    String table = field.getMappingInfo().getTableName();\n+                    if (table != null) {\n+                        int index = table.indexOf('.');\n+                        if (index < 0)\n+                            abJoinTbl.add(\"name\", table);\n+                        else {\n+                            abJoinTbl.add(\"schema\", table.substring(0, index));\n+                            abJoinTbl.add(\"name\", table.substring(index + 1));\n+                        }\n+                    }\n+                    serializeColumns(field.getMappingInfo(),\n+                        ColType.JOIN, null, abJoinTbl, null);\n+                    serializeColumns(field.getElementMapping().getValueInfo(),\n+                        ColType.INVERSE, null, abJoinTbl, null);\n+                }\n+                return;\n+        }\n+\n+        serializeColumns(field.getValueInfo(), ColType.COL,\n+            field.getMappingInfo().getTableName(), null, fmd);\n+        if (strategy == PersistenceStrategy.BASIC && isLob(field)) {\n+            addAnnotation(Lob.class, fmd);\n+        }\n+        TemporalType temporal = getTemporal(field);\n+        if (temporal != null) {\n+            addAnnotation(Temporal.class, fmd).\n+                add(null, temporal);\n+        }\n+\n+        EnumType enumType = getEnumType(field);\n+        if (enumType != null && enumType != EnumType.ORDINAL) {\n+            addAnnotation(Enumerated.class, fmd).\n+                add(null, enumType);\n+        }\n+    }\n+\n+    /**\n+     * Determine if the field is a lob.\n+     */\n+    private boolean isLob(FieldMapping field) {\n+        for (Column col : (List<Column>) field.getValueInfo().getColumns())\n+            if (col.getType() == Types.BLOB || col.getType() == Types.CLOB)\n+                return true;\n+        return false;\n+    }\n+\n+    /**\n+     * Return field's temporal type.\n+     */\n+    private TemporalType getTemporal(FieldMapping field) {\n+        if (field.getDeclaredTypeCode() != JavaTypes.DATE\n+            && field.getDeclaredTypeCode() != JavaTypes.CALENDAR)\n+            return null;\n+\n+        DBDictionary dict = ((JDBCConfiguration) getConfiguration())\n+            .getDBDictionaryInstance();\n+        int def = dict.getJDBCType(field.getTypeCode(), false);\n+        for (Column col : (List<Column>) field.getValueInfo().getColumns()) {\n+            if (col.getType() == def)\n+                continue;\n+            switch (col.getType()) {\n+                case Types.DATE:\n+                    return TemporalType.DATE;\n+                case Types.TIME:\n+                    return TemporalType.TIME;\n+                case Types.TIMESTAMP:\n+                    return TemporalType.TIMESTAMP;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return enum type for the field.\n+     */\n+    protected EnumType getEnumType(FieldMapping field) {\n+        if (field.getDeclaredTypeCode() != JavaTypes.OBJECT)\n+            return null;\n+        if (!(field.getHandler() instanceof EnumValueHandler))\n+            return null;\n+        return ((EnumValueHandler) field.getHandler()).getStoreOrdinal()\n+            ? EnumType.ORDINAL : EnumType.STRING;\n+    }\n+\n+    /**\n+     * Serialize the columns in the given mapping info.\n+     */\n+    private void serializeColumns(MappingInfo info, ColType type,\n+        String secondary, AnnotationBuilder ab, Object meta) {\n+        List<Column> cols = (List<Column>) info.getColumns();\n+        if (cols == null)\n+            return;\n+        AnnotationBuilder abContainer = ab;\n+        if (cols.size() > 1) {\n+            Class grpType = type.getColumnGroupAnnotationType();\n+            if (null != grpType) {\n+                AnnotationBuilder abGrp = newAnnotationBuilder(grpType);\n+                if (null == ab)\n+                    addAnnotation(abGrp, meta);\n+                else\n+                    ab.add(null, abGrp);\n+                abContainer = abGrp;\n+            }\n+        }\n+        for (Column col : cols)\n+            serializeColumn(col, type, secondary,\n+                info.getUnique() != null, abContainer, meta);\n+    }\n+\n+    /**\n+     * Serialize a single column.\n+     */\n+    private void serializeColumn(Column col, ColType type, String secondary,\n+        boolean unique, AnnotationBuilder ab, Object meta) {\n+        FieldMetaData fmd = meta instanceof FieldMetaData ?\n+            (FieldMetaData) meta : null;\n+        AnnotationBuilder abCol = newAnnotationBuilder(\n+            type.getColumnAnnotationType());\n+        if (col.getName() != null && (null == fmd ||\n+            !col.getName().equalsIgnoreCase(fmd.getName())))\n+            abCol.add(\"name\", col.getName());\n+        if (col.getTypeName() != null)\n+            abCol.add(\"columnDefinition\", col.getTypeName());\n+        if (col.getTarget() != null\n+            && (type == ColType.JOIN || type == ColType.INVERSE\n+            || type == ColType.PK_JOIN))\n+            abCol.add(\"referencedColumnName\", col.getTarget());\n+        if (type == ColType.COL || type == ColType.JOIN\n+            || type == ColType.PK_JOIN) {\n+            if (unique)\n+                abCol.add(\"unique\", true);\n+            if (col.isNotNull())\n+                abCol.add(\"nullable\", false);\n+            if (col.getFlag(Column.FLAG_UNINSERTABLE))\n+                abCol.add(\"insertable\", false);\n+            if (col.getFlag(Column.FLAG_UNUPDATABLE))\n+                abCol.add(\"updatable\", false);\n+            if (secondary != null)\n+                abCol.add(\"table\", secondary);\n+\n+            if (type == ColType.COL) {\n+                if (col.getSize() > 0 && col.getSize() != 255)\n+                    abCol.add(\"length\", col.getSize());\n+                if (col.getDecimalDigits() != 0)\n+                    abCol.add(\"scale\", col.getDecimalDigits());\n+            }\n+        }\n+\n+        if (type != ColType.COL || abCol.hasComponents()) {\n+            if (null != ab) {\n+                String key = null;\n+                if (ab.getType() == JoinTable.class) {\n+                    switch(type) {\n+                        case JOIN:\n+                            key = \"joinColumns\";\n+                            break;\n+                        case INVERSE:\n+                            key = \"inverseJoinColumns\";\n+                            break;\n+                    }\n+                }\n+                ab.add(key, abCol);\n+            } else {\n+                addAnnotation(abCol, meta);\n+            }                \n+        }\n+    }\n+\n+    private void serializeUniqueConstraint(Unique unique,\n+        AnnotationBuilder ab) {\n+        StringBuilder sb = new StringBuilder();\n+        Column[] columns = unique.getColumns();\n+        for (Column column:columns) {\n+            if (sb.length() > 0)\n+                sb.append(\", \");\n+            sb.append(column.getName());\n+        }\n+        if (columns.length > 1)\n+            sb.insert(0, \"{\").append(\"}\");\n+        ab.add(\"columnNames\", sb.toString());\n+    }\n+\n+    @Override\n+    protected SerializationComparator newSerializationComparator() {\n+        return new AnnotationPersistenceMappingSerializer.\n+            MappingSerializationComparator();\n+    }\n+\n+    @Override\n+    protected void addSystemMappingElements(Collection toSerialize) {\n+        if (isQueryMode())\n+            toSerialize.addAll(getQueryResultMappings(null));\n+    }\n+\n+    @Override\n+    protected int type(Object o) {\n+        int type = super.type(o);\n+        if (type == -1 && o instanceof QueryResultMapping)\n+            return TYPE_RESULTMAP;\n+        return type;\n+    }\n+\n+    /**\n+     * Return the result set mappings for the given scope.\n+     */\n+    private List<QueryResultMapping> getQueryResultMappings(ClassMetaData cm) {\n+        if (_results == null || _results.isEmpty())\n+            return (List<QueryResultMapping>) Collections.EMPTY_LIST;\n+\n+        List<QueryResultMapping> result = null;\n+        for (int i = 0; i < _results.size(); i++) {\n+            QueryResultMapping element = _results.get(i);\n+            if ((cm == null && element.getSourceScope() != null) || (cm != null\n+                && element.getSourceScope() != cm.getDescribedType()))\n+                continue;\n+\n+            if (result == null)\n+                result = new ArrayList<QueryResultMapping>(_results.size() - i);\n+            result.add(element);\n+        }\n+        return (result == null)\n+            ? (List<QueryResultMapping>) Collections.EMPTY_LIST : result;\n+    }\n+\n+    @Override\n+    protected void serializeSystemMappingElement(Object obj) {\n+        if (obj instanceof QueryResultMapping)\n+            serializeQueryResultMapping((QueryResultMapping) obj, null);\n+    }\n+\n+    @Override\n+    protected void serializeQueryMappings(ClassMetaData meta) {\n+        for (QueryResultMapping res : getQueryResultMappings(meta))\n+            serializeQueryResultMapping(res, meta);\n+    }\n+\n+    /**\n+     * Serialize given result set mapping.\n+     */\n+    private void serializeQueryResultMapping(QueryResultMapping meta,\n+        ClassMetaData clsmeta) {\n+        AnnotationBuilder ab = addAnnotation(SqlResultSetMapping.class, meta);\n+        if (null != clsmeta)\n+            addAnnotation(ab, clsmeta);\n+        ab.add(\"name\", meta.getName());\n+        for (QueryResultMapping.PCResult pc : meta.getPCResults()) {\n+            AnnotationBuilder abEntRes =\n+                newAnnotationBuilder(EntityResult.class);\n+            ab.add(\"entities\", abEntRes);\n+            abEntRes.add(\"entityClass\", pc.getCandidateType());\n+            Object discrim = pc.getMapping(pc.DISCRIMINATOR);\n+            if (discrim != null)\n+                abEntRes.add(\"discriminatorColumn\", discrim.toString());\n+\n+            for (String path : pc.getMappingPaths()) {\n+                AnnotationBuilder abFldRes =\n+                    newAnnotationBuilder(FieldResult.class);\n+                abEntRes.add(\"fields\", abFldRes);\n+                abFldRes.add(\"name\", path);\n+                abFldRes.add(\"column\", pc.getMapping(path).toString());\n+            }\n+        }\n+        for (Object col : meta.getColumnResults()) {\n+            AnnotationBuilder abColRes =\n+                newAnnotationBuilder(ColumnResult.class);\n+            abColRes.add(\"name\", col.toString());\n+        }\n+    }\n+\n+    @Override\n+    protected void serializeSequence(SequenceMetaData meta) {\n+        if (SequenceMapping.IMPL_VALUE_TABLE.equals(meta.getSequencePlugin())) {\n+            super.serializeSequence(meta);\n+            return;\n+        }\n+\n+        AnnotationBuilder abTblGen = addAnnotation(TableGenerator.class, meta);\n+        SequenceMapping seq = (SequenceMapping) meta;\n+        abTblGen.add(\"name\", seq.getName());\n+        String table = seq.getTable();\n+        if (table != null) {\n+            int dotIdx = table.indexOf('.');\n+            if (dotIdx == -1)\n+                abTblGen.add(\"table\", table);\n+            else {\n+                abTblGen.add(\"table\", table.substring(dotIdx + 1));\n+                abTblGen.add(\"schema\", table.substring(0, dotIdx));\n+            }\n+        }\n+        if (!StringUtils.isEmpty(seq.getPrimaryKeyColumn()))\n+            abTblGen.add(\"pkColumnName\", seq.getPrimaryKeyColumn());\n+        if (!StringUtils.isEmpty(seq.getSequenceColumn()))\n+            abTblGen.add(\"valueColumnName\", seq.getSequenceColumn());\n+        if (!StringUtils.isEmpty(seq.getPrimaryKeyValue()))\n+            abTblGen.add(\"pkColumnValue\", seq.getPrimaryKeyValue());\n+        if (seq.getAllocate() != 50 && seq.getAllocate() != -1)\n+            abTblGen.add(\"allocationSize\", seq.getAllocate() + \"\");\n+        if (seq.getInitialValue() != 0 && seq.getInitialValue() != -1)\n+            abTblGen.add(\"initialValue\", seq.getInitialValue() + \"\");\n+    }\n+\n+    /**\n+     * Column types serialized under different names.\n+     */\n+    private static enum ColType {\n+\n+        COL,\n+        JOIN,\n+        INVERSE,\n+        PK_JOIN,\n+        DISC;\n+\n+        private Class<? extends Annotation> getColumnAnnotationType() {\n+            switch(this) {\n+                case COL:\n+                    return javax.persistence.Column.class;\n+                case JOIN:\n+                case INVERSE:\n+                    return JoinColumn.class;\n+                case PK_JOIN:\n+                    return PrimaryKeyJoinColumn.class;\n+                case DISC:\n+                    return DiscriminatorColumn.class;\n+            }\n+            return null;\n+        }\n+\n+        private Class<? extends Annotation> getColumnGroupAnnotationType() {\n+            switch(this) {\n+                case JOIN:\n+                case INVERSE:\n+                    return JoinColumns.class;\n+                case PK_JOIN:\n+                    return PrimaryKeyJoinColumns.class;\n+            }\n+            return null;\n+        }\n+\n+    }\n+\n+    /**\n+     * Extends {@link SerializationComparator} for store-specific tags such\n+     * as &lt;sql-result-set-mapping&gt;.\n+     *\n+     * @author Pinaki Poddar\n+     */\n+    protected class MappingSerializationComparator\n+        extends SerializationComparator {\n+\n+        protected int compareUnknown(Object o1, Object o2) {\n+            if (!(o1 instanceof QueryResultMapping))\n+                return super.compareUnknown(o1, o2);\n+\n+            QueryResultMapping res1 = (QueryResultMapping) o1;\n+            QueryResultMapping res2 = (QueryResultMapping) o2;\n+\n+            // system scope before class scope\n+            Object scope1 = res1.getSourceScope();\n+            Object scope2 = res2.getSourceScope();\n+            if (scope1 == null && scope2 != null)\n+                return -1;\n+            if (scope1 != null && scope2 == null)\n+                return 1;\n+\n+            // compare on listing index, or if none/same, use name\n+            int listingIndex1 = res1.getListingIndex();\n+            int listingIndex2 = res2.getListingIndex();\n+            if (listingIndex1 != listingIndex2)\n+                return listingIndex1 - listingIndex2;\n+            return res1.getName ().compareTo (res2.getName ());\n+\t\t}\n+\t}\n+}"},{"sha":"060d23d81543496b9ba7249cb871fd5234d6a800","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingFactory.java","status":"modified","additions":11,"deletions":1,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingFactory.java","raw_url":"https://github.com/apache/openjpa/raw/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingFactory.java?ref=85b2e766cae4a55e9e32442cc889a56b8fee0d65","patch":"@@ -21,10 +21,11 @@\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n import org.apache.openjpa.jdbc.meta.MappingRepository;\n import org.apache.openjpa.meta.MetaDataFactory;\n-import org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser;\n import org.apache.openjpa.persistence.PersistenceMetaDataFactory;\n import org.apache.openjpa.persistence.XMLPersistenceMetaDataParser;\n import org.apache.openjpa.persistence.XMLPersistenceMetaDataSerializer;\n+import org.apache.openjpa.persistence.AnnotationPersistenceMetaDataParser;\n+import org.apache.openjpa.persistence.AnnotationPersistenceMetaDataSerializer;\n \n /**\n  * {@link MetaDataFactory} for JPA mapping information.\n@@ -48,6 +49,15 @@ protected AnnotationPersistenceMetaDataParser newAnnotationParser() {\n         return parser;\n     }\n \n+    protected AnnotationPersistenceMetaDataSerializer newAnnotationSerializer()\n+    {\n+        AnnotationPersistenceMappingSerializer ser =\n+            new AnnotationPersistenceMappingSerializer((JDBCConfiguration)\n+            repos.getConfiguration());\n+        ser.setSyncMappingInfo(true);\n+        return ser;\n+    }\n+\n     @Override\n     protected XMLPersistenceMetaDataParser newXMLParser(boolean loading) {\n         XMLPersistenceMappingParser parser = new XMLPersistenceMappingParser"},{"sha":"383bac12482e16a20185b540b34dec948d8ad5d1","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationBuilder.java","status":"added","additions":200,"deletions":0,"changes":200,"blob_url":"https://github.com/apache/openjpa/blob/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationBuilder.java?ref=85b2e766cae4a55e9e32442cc889a56b8fee0d65","patch":"@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence;\n+\n+import serp.util.Strings;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.EnumSet;\n+import java.lang.annotation.Annotation;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+/**\n+ * Helper class to stringify annotation declarations.\n+ *\n+ * @author Gokhan Ergul\n+ * @since 1.0.0\n+ */\n+public class AnnotationBuilder {\n+\n+    private Class<? extends Annotation> type;\n+    private List<AnnotationEntry> components =\n+        new ArrayList<AnnotationEntry>();\n+\n+    protected AnnotationBuilder(Class<? extends Annotation> type) {\n+        this.type = type;\n+    }\n+\n+    public Class<? extends Annotation> getType() {\n+        return this.type;\n+    }\n+\n+    public AnnotationBuilder add(String key, String val) {\n+        return doAdd(key, val);\n+    }\n+\n+    public AnnotationBuilder add(String key, boolean val) {\n+        return doAdd(key, val);\n+    }\n+\n+    public AnnotationBuilder add(String key, int val) {\n+        return doAdd(key, val);\n+    }\n+\n+    public AnnotationBuilder add(String key, Class val) {\n+        return doAdd(key, val);\n+    }\n+\n+    public AnnotationBuilder add(String key, EnumSet val) {\n+        return doAdd(key, val);\n+    }\n+\n+    public AnnotationBuilder add(String key, Enum val) {\n+        return doAdd(key, val);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public AnnotationBuilder add(String key, AnnotationBuilder val) {\n+        if (null == val)\n+            return this;\n+        AnnotationEntry ae = find(key);\n+        if (null == ae) {\n+            doAdd(key, val);\n+        } else {\n+            List<AnnotationBuilder> list;\n+            if (ae.value instanceof List) {\n+                list = (List<AnnotationBuilder>) ae.value;\n+            } else if (ae.value instanceof AnnotationBuilder) {\n+                list = new ArrayList<AnnotationBuilder> ();\n+                list.add((AnnotationBuilder) ae.value);\n+                ae.value = list;\n+            } else {\n+                throw new IllegalArgumentException(\n+                    \"Unexpected type: \" + ae.value);\n+            }\n+            list.add(val);\n+        }\n+        return this;\n+    }\n+\n+    public boolean hasComponents() {\n+        return components.size() > 0;\n+    }\n+\n+    private AnnotationBuilder doAdd (String key, Object val) {\n+        if (null != val)\n+            components.add(new AnnotationEntry(key, val));\n+        return this;        \n+    }\n+\n+    private AnnotationEntry find(String key) {\n+        for(AnnotationEntry ae: components) {\n+            // null key references considered equal\n+            if (StringUtils.equals(ae.key, key))\n+                return ae;\n+        }\n+        return null;\n+    }\n+\n+    static String enumToString(Enum e) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(Strings.getClassName(e.getClass())).\n+            append(\".\").append(e);\n+        return sb.toString();\n+    }\n+\n+    static String enumSetToString(EnumSet set) {\n+        StringBuilder sb = new StringBuilder();\n+        for (Iterator i = set.iterator(); i.hasNext();) {\n+            Object e =  i.next();\n+            sb.append(Strings.getClassName(e.getClass())).\n+                append(\".\").append(e);\n+            if (i.hasNext())\n+                sb.append(\", \");\n+        }\n+        return sb.toString();\n+    }\n+\n+    protected void toString(StringBuilder sb) {\n+        sb.append(\"@\").append(Strings.getClassName(type));\n+        if (components.size() == 0)\n+            return;\n+        sb.append(\"(\");\n+        for (Iterator<AnnotationEntry> i = components.iterator(); i.hasNext();) \n+        {\n+            AnnotationEntry e = i.next();\n+            e.toString(sb);\n+            if (i.hasNext())\n+                sb.append(\", \");\n+        }\n+        sb.append(\")\");        \n+    }\n+\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        toString(sb);\n+        return sb.toString();\n+    }\n+\n+}\n+\n+class AnnotationEntry {\n+\n+    String key;\n+    Object value;\n+\n+    AnnotationEntry(String key, Object value) {\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    void toString(StringBuilder sb) {\n+        if (null != key)\n+            sb.append(key).append(\"=\");\n+\n+        List.class.getTypeParameters();\n+        if (value instanceof List) {\n+            sb.append(\"{\");\n+            List<AnnotationBuilder> l = (List<AnnotationBuilder>) value;\n+            for (Iterator<AnnotationBuilder> i = l.iterator(); i.hasNext();) {\n+                AnnotationBuilder ab =  i.next();\n+                sb.append(ab.toString());\n+                if (i.hasNext())\n+                    sb.append(\", \");\n+            }\n+            sb.append(\"}\");\n+        } else if (value instanceof Class) {\n+            String cls = ((Class) value).getName().replace('$', '.');\n+            sb.append(cls).append(\".class\");\n+        } else if (value instanceof String) {\n+            sb.append('\"').append(value).append('\"');\n+        } else if (value instanceof Enum) {\n+            sb.append(AnnotationBuilder.enumToString((Enum) value));\n+        } else if (value instanceof EnumSet) {\n+            sb.append(AnnotationBuilder.enumSetToString((EnumSet) value));\n+        } else {\n+            sb.append(value);\n+        }\n+    }\n+\n+}"},{"sha":"1f09abbd703312663f78264ca45200c502e99334","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataSerializer.java","status":"added","additions":1488,"deletions":0,"changes":1488,"blob_url":"https://github.com/apache/openjpa/blob/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataSerializer.java?ref=85b2e766cae4a55e9e32442cc889a56b8fee0d65","patch":"@@ -0,0 +1,1488 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence;\n+\n+import org.apache.openjpa.lib.meta.SourceTracker;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.JavaVersions;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.meta.*;\n+import org.apache.openjpa.kernel.QueryLanguages;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.util.*;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.io.FileWriter;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.annotation.Annotation;\n+\n+import serp.util.Strings;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Embeddable;\n+import javax.persistence.MappedSuperclass;\n+import javax.persistence.NamedNativeQuery;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.QueryHint;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Id;\n+import javax.persistence.IdClass;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Version;\n+import javax.persistence.Transient;\n+import javax.persistence.Basic;\n+import javax.persistence.Embedded;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.ManyToMany;\n+import javax.persistence.OrderBy;\n+import javax.persistence.MapKey;\n+import javax.persistence.AttributeOverride;\n+import javax.persistence.CascadeType;\n+import javax.persistence.FetchType;\n+\n+//@todo: javadocs\n+\n+/**\n+ * Serializes persistence metadata as annotations.\n+ * This class processes all object level tags that are store-agnostic.\n+ * However, it provides hooks for the subclasses to include store-specific\n+ * tags to be serialized both at &lt;entity-mappings&gt; and\n+ * &lt;entity&gt; level.\n+ *\n+ * @since 1.0.0\n+ * @author Steve Kim\n+ * @author Gokhan Ergul\n+ * @nojavadoc\n+ */\n+public class AnnotationPersistenceMetaDataSerializer\n+    implements PersistenceMetaDataFactory.Serializer {\n+\n+    // NOTE: order is important! these constants must be maintained in\n+    // serialization order. constants are spaced so that subclasses can\n+    // slip tags in-between\n+    protected static final int TYPE_SEQ = 10;\n+    protected static final int TYPE_QUERY = 20;\n+    protected static final int TYPE_META = 30;\n+    protected static final int TYPE_CLASS_SEQS = 40;\n+    protected static final int TYPE_CLASS_QUERIES = 50;\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (AnnotationPersistenceMetaDataSerializer.class);\n+\n+    private Log _log = null;\n+    \n+    private final OpenJPAConfiguration _conf;\n+    private Map<String, ClassMetaData> _metas = null;\n+    private Map<String, List> _queries = null;\n+    private Map<String, List> _seqs = null;\n+    private int _mode = MetaDataModes.MODE_NONE;\n+    private SerializationComparator _comp = null;\n+\n+    private Map<ClassMetaData, List<AnnotationBuilder>> _clsAnnos = null;\n+    private Map<FieldMetaData, List<AnnotationBuilder>> _fldAnnos = null;\n+    private Map<SequenceMetaData, List<AnnotationBuilder>> _seqAnnos = null;\n+    private Map<QueryMetaData, List<AnnotationBuilder>> _qryAnnos = null; \n+\n+    /**\n+     * Constructor. Supply configuration.\n+     */\n+    public AnnotationPersistenceMetaDataSerializer(OpenJPAConfiguration conf) {\n+        _conf = conf;\n+        setLog(conf.getLog(OpenJPAConfiguration.LOG_METADATA));\n+        setMode(MetaDataModes.MODE_META | MetaDataModes.MODE_MAPPING |\n+            MetaDataModes.MODE_QUERY);\n+    }\n+\n+    /**\n+     * Configuration.\n+     */\n+    public OpenJPAConfiguration getConfiguration() {\n+        return _conf;\n+    }\n+\n+    /**\n+     * The log to write to.\n+     */\n+    public Log getLog() {\n+        return _log;\n+    }\n+\n+    /**\n+     * The log to write to.\n+     */\n+    public void setLog(Log log) {\n+        _log = log;\n+    }\n+    \n+    /**\n+     * The serialization mode according to the expected document type. The\n+     * mode constants act as bit flags, and therefore can be combined.\n+     */\n+    public int getMode() {\n+        return _mode;\n+    }\n+\n+    /**\n+     * The serialization mode according to the expected document type. The\n+     * mode constants act as bit flags, and therefore can be combined.\n+     */\n+    public void setMode(int mode) {\n+        _mode = mode;\n+    }\n+\n+    /**\n+     * The serialization mode according to the expected document type.\n+     */\n+    public void setMode(int mode, boolean on) {\n+        if (mode == MetaDataModes.MODE_NONE)\n+            setMode(MetaDataModes.MODE_NONE);\n+        else if (on)\n+            setMode(_mode | mode);\n+        else\n+            setMode(_mode & ~mode);\n+    }\n+\n+    /**\n+     * Convenience method for interpreting {@link #getMode}.\n+     */\n+    protected boolean isMetaDataMode() {\n+        return (_mode & MetaDataModes.MODE_META) != 0;\n+    }\n+\n+    /**\n+     * Convenience method for interpreting {@link #getMode}.\n+     */\n+    protected boolean isQueryMode() {\n+        return (_mode & MetaDataModes.MODE_QUERY) != 0;\n+    }\n+\n+    /**\n+     * Convenience method for interpreting {@link #getMode}.\n+     */\n+    protected boolean isMappingMode() {\n+        return (_mode & MetaDataModes.MODE_MAPPING) != 0;\n+    }\n+\n+    /**\n+     * Convenience method for interpreting {@link #getMode}. Takes into\n+     * account whether mapping information is loaded for the given instance.\n+     */\n+    protected boolean isMappingMode(ClassMetaData meta) {\n+        return isMappingMode() && (meta.getSourceMode()\n+            & MetaDataModes.MODE_MAPPING) != 0\n+            && (meta.getEmbeddingMetaData() != null\n+            || !meta.isEmbeddedOnly())\n+            && (meta.getEmbeddingMetaData() == null\n+            || isMappingMode(meta.getEmbeddingMetaData()));\n+    }\n+\n+    /**\n+     * Convenience method for interpreting {@link #getMode}. Takes into\n+     * account whether mapping information is loaded for the given instance.\n+     */\n+    protected boolean isMappingMode(ValueMetaData vmd) {\n+        return isMappingMode(vmd.getFieldMetaData().getDefiningMetaData());\n+    }\n+\n+    /**\n+     * Add a class meta data to the set to be serialized.\n+     */\n+    public void addMetaData(ClassMetaData meta) {\n+        if (meta == null)\n+            return;\n+\n+        if (_metas == null)\n+            _metas = new HashMap<String, ClassMetaData>();\n+        _metas.put(meta.getDescribedType().getName(), meta);\n+    }\n+\n+    /**\n+     * Add a sequence meta data to the set to be serialized.\n+     */\n+    public void addSequenceMetaData(SequenceMetaData meta) {\n+        if (meta == null)\n+            return;\n+\n+        List seqs = null;\n+        String defName = null;\n+        if (meta.getSourceScope() instanceof Class)\n+            defName = ((Class) meta.getSourceScope()).getName();\n+        if (_seqs == null)\n+            _seqs = new HashMap<String, List>();\n+        else\n+            seqs = _seqs.get(defName);\n+\n+        if (seqs == null) {\n+            seqs = new ArrayList(3); // don't expect many seqs / class\n+            seqs.add(meta);\n+            _seqs.put(defName, seqs);\n+        } else if (!seqs.contains(meta))\n+            seqs.add(meta);\n+    }\n+\n+    /**\n+     * Add a query meta data to the set to be serialized.\n+     */\n+    public void addQueryMetaData(QueryMetaData meta) {\n+        if (meta == null)\n+            return;\n+\n+        List queries = null;\n+        String defName = null;\n+        if (meta.getSourceScope() instanceof Class)\n+            defName = ((Class) meta.getSourceScope()).getName();\n+        if (_queries == null)\n+            _queries = new HashMap<String, List>();\n+        else\n+            queries = _queries.get(defName);\n+\n+        if (queries == null) {\n+            queries = new ArrayList(3); // don't expect many queries / class\n+            queries.add(meta);\n+            _queries.put(defName, queries);\n+        } else if (!queries.contains(meta))\n+            queries.add(meta);\n+    }\n+\n+    /**\n+     * Add all components in the given repository to the set to be serialized.\n+     */\n+    public void addAll(MetaDataRepository repos) {\n+        if (repos == null)\n+            return;\n+\n+        for (ClassMetaData meta : repos.getMetaDatas())\n+            addMetaData(meta);\n+        for (SequenceMetaData seq : repos.getSequenceMetaDatas())\n+            addSequenceMetaData(seq);\n+        for (QueryMetaData query : repos.getQueryMetaDatas())\n+            addQueryMetaData(query);\n+    }\n+\n+    /**\n+     * Remove a metadata from the set to be serialized.\n+     *\n+     * @return true if removed, false if not in set\n+     */\n+    public boolean removeMetaData(ClassMetaData meta) {\n+        return _metas != null && meta != null\n+            && _metas.remove(meta.getDescribedType().getName()) != null;\n+    }\n+\n+    /**\n+     * Remove a sequence metadata from the set to be serialized.\n+     *\n+     * @return true if removed, false if not in set\n+     */\n+    public boolean removeSequenceMetaData(SequenceMetaData meta) {\n+        if (_seqs == null || meta == null)\n+            return false;\n+        String defName = null;\n+        if (meta.getSourceScope() instanceof Class)\n+            defName = ((Class) meta.getSourceScope()).getName();\n+        List seqs = _seqs.get(defName);\n+        if (seqs == null)\n+            return false;\n+        if (!seqs.remove(meta))\n+            return false;\n+        if (seqs.isEmpty())\n+            _seqs.remove(defName);\n+        return true;\n+    }\n+\n+    /**\n+     * Remove a query metadata from the set to be serialized.\n+     *\n+     * @return true if removed, false if not in set\n+     */\n+    public boolean removeQueryMetaData(QueryMetaData meta) {\n+        if (_queries == null || meta == null)\n+            return false;\n+        String defName = null;\n+        if (meta.getSourceScope() instanceof Class)\n+            defName = ((Class) meta.getSourceScope()).getName();\n+        List queries = _queries.get(defName);\n+        if (queries == null)\n+            return false;\n+        if (!queries.remove(meta))\n+            return false;\n+        if (queries.isEmpty())\n+            _queries.remove(defName);\n+        return true;\n+    }\n+\n+    /**\n+     * Remove all the components in the given repository from the set to be\n+     * serialized.\n+     *\n+     * @return true if any components removed, false if none in set\n+     */\n+    public boolean removeAll(MetaDataRepository repos) {\n+        if (repos == null)\n+            return false;\n+\n+        boolean removed = false;\n+        ClassMetaData[] metas = repos.getMetaDatas();\n+        for (int i = 0; i < metas.length; i++)\n+            removed |= removeMetaData(metas[i]);\n+        SequenceMetaData[] seqs = repos.getSequenceMetaDatas();\n+        for (int i = 0; i < seqs.length; i++)\n+            removed |= removeSequenceMetaData(seqs[i]);\n+        QueryMetaData[] queries = repos.getQueryMetaDatas();\n+        for (int i = 0; i < queries.length; i++)\n+            removed |= removeQueryMetaData(queries[i]);\n+        return removed;\n+    }\n+\n+    /**\n+     * Clear the set of metadatas to be serialized.\n+     */\n+    public void clear() {\n+        if (_metas != null)\n+            _metas.clear();\n+        if (_seqs != null)\n+            _seqs.clear();\n+        if (_queries != null)\n+            _queries.clear();\n+    }\n+\n+    /**\n+     * Add system-level mapping elements to be serialized. Does nothing\n+     * by default.\n+     */\n+    protected void addSystemMappingElements(Collection toSerialize) {\n+    }\n+\n+    /**\n+     * Sort the given collection of objects to be serialized.\n+     */\n+    private void serializationSort(List objs) {\n+        if (objs == null || objs.isEmpty())\n+            return;\n+        if (_comp == null)\n+            _comp = newSerializationComparator();\n+        Collections.sort(objs, _comp);\n+    }\n+\n+    /**\n+     * Create a new comparator for ordering objects that are to be serialized.\n+     */\n+    protected SerializationComparator newSerializationComparator() {\n+        return _comp;\n+    }\n+\n+    /**\n+     * Add sequence metadata to the given metadatas collection.\n+     */\n+    private void addSequenceMetaDatas(Collection all) {\n+        if (_seqs == null)\n+            return;\n+\n+        for (Map.Entry entry : _seqs.entrySet()) {\n+            if (entry.getKey() == null)\n+                all.addAll((List) entry.getValue());\n+            else if (_metas == null || !_metas.containsKey(entry.getKey()))\n+                all.add(new ClassSeqs((List<SequenceMetaData>)\n+                    entry.getValue()));\n+        }\n+    }\n+\n+    /**\n+     * Add query metadata to the given metadatas collection.\n+     */\n+    private void addQueryMetaDatas(Collection all) {\n+        if (_queries == null)\n+            return;\n+\n+        for (Map.Entry entry : _queries.entrySet()) {\n+            if (entry.getKey() == null)\n+                all.addAll((List) entry.getValue());\n+            else if (_mode == MetaDataModes.MODE_QUERY || _metas == null\n+                || !_metas.containsKey(entry.getKey()))\n+                all.add(new ClassQueries((List<QueryMetaData>)\n+                    entry.getValue()));\n+        }\n+    }\n+\n+    /**\n+     * Creates a new annotation builder for the specified annotation type.\n+     * @return\n+     */\n+    protected AnnotationBuilder newAnnotationBuilder(\n+        Class<? extends Annotation> annType) {\n+        return new AnnotationBuilder(annType);        \n+    }\n+\n+    protected void addAnnotation(AnnotationBuilder ab, Object meta) {\n+        if (meta instanceof ClassMetaData)\n+            addAnnotation(ab, (ClassMetaData) meta);\n+        else if (meta instanceof FieldMetaData)\n+            addAnnotation(ab, (FieldMetaData) meta);\n+        else if (meta instanceof SequenceMetaData)\n+            addAnnotation(ab, (SequenceMetaData) meta);\n+        else if (meta instanceof QueryMetaData)\n+            addAnnotation(ab, (QueryMetaData) meta);\n+    }\n+\n+    /**\n+     * Add an annotation builder to list of builders for the specified\n+     * class metadata.\n+     */\n+    protected void addAnnotation(AnnotationBuilder ab, ClassMetaData meta) {\n+        if (_clsAnnos == null)\n+            _clsAnnos = new HashMap<ClassMetaData, List<AnnotationBuilder>>();\n+        List<AnnotationBuilder> list = _clsAnnos.get(meta);\n+        if (list == null) {\n+            list = new ArrayList<AnnotationBuilder>();\n+            _clsAnnos.put(meta, list);\n+        }\n+        list.add(ab);        \n+    }\n+\n+    /**\n+     * Add an annotation builder to list of builders for the specified\n+     * field metadata.\n+     */\n+    protected void addAnnotation(AnnotationBuilder ab, FieldMetaData meta) {\n+        if (_fldAnnos == null)\n+            _fldAnnos = new HashMap<FieldMetaData, List<AnnotationBuilder>>();\n+        List<AnnotationBuilder> list = _fldAnnos.get(meta);\n+        if (list == null) {\n+            list = new ArrayList<AnnotationBuilder>();\n+            _fldAnnos.put(meta, list);\n+        }\n+        list.add(ab);\n+    }\n+\n+    /**\n+     * Add an annotation builder to list of builders for the specified\n+     * sequence metadata.\n+     */\n+    protected void addAnnotation(AnnotationBuilder ab, SequenceMetaData meta) {\n+        if (_seqAnnos == null)\n+            _seqAnnos = new HashMap<SequenceMetaData, List<AnnotationBuilder>>();\n+        List<AnnotationBuilder> list = _seqAnnos.get(meta);\n+        if (list == null) {\n+            list = new ArrayList<AnnotationBuilder>();\n+            _seqAnnos.put(meta, list);\n+        }\n+        list.add(ab);\n+    }\n+\n+    /**\n+     * Add an annotation builder to list of builders for the specified\n+     * query metadata.\n+     */\n+    protected void addAnnotation(AnnotationBuilder ab, QueryMetaData meta) {\n+        if (_qryAnnos == null)\n+            _qryAnnos = new HashMap<QueryMetaData, List<AnnotationBuilder>>();\n+        List<AnnotationBuilder> list = _qryAnnos.get(meta);\n+        if (list == null) {\n+            list = new ArrayList<AnnotationBuilder>();\n+            _qryAnnos.put(meta, list);\n+        }\n+        list.add(ab);\n+    }\n+\n+    /**\n+     * Creates an an annotation builder for the specified class metadata\n+     * and adds it to list of builders.\n+     */\n+    protected AnnotationBuilder addAnnotation(\n+        Class<? extends Annotation> annType, ClassMetaData meta) {\n+        AnnotationBuilder ab = newAnnotationBuilder(annType);\n+        if (meta == null)\n+            return ab;\n+        addAnnotation(ab, meta);\n+        return ab;\n+    }\n+\n+    /**\n+     * Creates an an annotation builder for the specified class metadata\n+     * and adds it to list of builders.\n+     */\n+    protected AnnotationBuilder addAnnotation(\n+        Class<? extends Annotation> annType, FieldMetaData meta) {\n+        AnnotationBuilder ab = newAnnotationBuilder(annType);\n+        if (meta == null)\n+            return ab;\n+        addAnnotation(ab, meta);\n+        return ab;\n+    }\n+\n+    /**\n+     * Creates an an annotation builder for the specified class metadata\n+     * and adds it to list of builders.\n+     */\n+    protected AnnotationBuilder addAnnotation(\n+        Class<? extends Annotation> annType, SequenceMetaData meta) {\n+        AnnotationBuilder ab = newAnnotationBuilder(annType);\n+        if (meta == null)\n+            return ab;\n+        addAnnotation(ab, meta);\n+        return ab;\n+    }\n+\n+    /**\n+     * Creates an an annotation builder for the specified class metadata\n+     * and adds it to list of builders.\n+     */\n+    protected AnnotationBuilder addAnnotation(\n+        Class<? extends Annotation> annType, QueryMetaData meta) {\n+        AnnotationBuilder ab = newAnnotationBuilder(annType);\n+        if (meta == null)\n+            return ab;\n+        addAnnotation(ab, meta);\n+        return ab;\n+    }\n+    \n+    protected void serialize(Collection objects) {\n+        for (Object obj : objects) {\n+            int type = type(obj);\n+            switch (type) {\n+                case TYPE_META:\n+                    serializeClass((ClassMetaData) obj);\n+                    break;\n+                case TYPE_SEQ:\n+                    if (isMappingMode())\n+                        serializeSequence((SequenceMetaData) obj);\n+                case TYPE_QUERY:\n+                    serializeQuery((QueryMetaData) obj);\n+                    break;\n+                case TYPE_CLASS_QUERIES:\n+                    for (QueryMetaData query : ((ClassQueries) obj)\n+                        .getQueries())\n+                        serializeQuery(query);\n+                    break;\n+                case TYPE_CLASS_SEQS:\n+                    if (isMappingMode())\n+                        for (SequenceMetaData seq : ((ClassSeqs) obj)\n+                            .getSequences())\n+                            serializeSequence(seq);\n+                    break;\n+                default:\n+                    if (isMappingMode())\n+                        serializeSystemMappingElement(obj);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return the type constant for the given object based on its runtime\n+     * class. If the runtime class does not correspond to any of the known\n+     * types then returns -1. This can happen for tags\n+     * that are not handled at this store-agnostic level.\n+     */\n+    protected int type(Object o) {\n+        if (o instanceof ClassMetaData)\n+            return TYPE_META;\n+        if (o instanceof QueryMetaData)\n+            return TYPE_QUERY;\n+        if (o instanceof SequenceMetaData)\n+            return TYPE_SEQ;\n+        if (o instanceof ClassQueries)\n+            return TYPE_CLASS_QUERIES;\n+        if (o instanceof ClassSeqs)\n+            return TYPE_CLASS_SEQS;\n+        return -1;\n+    }\n+\n+    /**\n+     * Serialize unknown mapping element at system level.\n+     */\n+    protected void serializeSystemMappingElement(Object obj) {\n+    }\n+\n+    /**\n+     * Serialize query metadata.\n+     */\n+    private void serializeQuery(QueryMetaData meta) {\n+        Log log = getLog();\n+        if (log.isInfoEnabled()) {\n+            if (meta.getSourceScope() instanceof Class)\n+                log.info(_loc.get(\"ser-cls-query\",\n+                    meta.getSourceScope(), meta.getName()));\n+            else\n+                log.info(_loc.get(\"ser-query\", meta.getName()));\n+        }\n+\n+        Class<? extends Annotation> ann =\n+            QueryLanguages.LANG_SQL.equals(meta.getLanguage()) ?\n+            NamedNativeQuery.class : NamedQuery.class;\n+        AnnotationBuilder abQry = addAnnotation(ann, meta);\n+        abQry.add(\"name\", meta.getName());\n+        abQry.add(\"query\", meta.getQueryString());\n+        if (QueryLanguages.LANG_SQL.equals(meta.getLanguage())) {\n+            if (meta.getResultType() != null)\n+                abQry.add(\"resultClass\", meta.getResultType());\n+        }\n+        serializeQueryHints(meta, abQry);\n+    }\n+\n+    /**\n+     * Serialize query hints.\n+     */\n+    private void serializeQueryHints(QueryMetaData meta, AnnotationBuilder ab) {\n+        String[] hints = meta.getHintKeys();\n+        Object[] values = meta.getHintValues();\n+        for (int i = 0; i < hints.length; i++) {\n+            AnnotationBuilder abHint = newAnnotationBuilder(QueryHint.class);\n+            abHint.add(\"name\", hints[i]);\n+            abHint.add(\"value\", String.valueOf(values[i]));\n+            ab.add(\"hints\", abHint);\n+        }\n+    }\n+\n+    /**\n+     * Serialize sequence metadata.\n+     */\n+    protected void serializeSequence(SequenceMetaData meta) {\n+        Log log = getLog();\n+        if (log.isInfoEnabled())\n+            log.info(_loc.get(\"ser-sequence\", meta.getName()));\n+\n+        AnnotationBuilder ab = addAnnotation(SequenceGenerator.class, meta);\n+        ab.add(\"name\", meta.getName());\n+\n+        // parse out the datastore sequence name, if any\n+        String plugin = meta.getSequencePlugin();\n+        String clsName = Configurations.getClassName(plugin);\n+        String props = Configurations.getProperties(plugin);\n+        String ds = null;\n+        if (props != null) {\n+            Properties map = Configurations.parseProperties(props);\n+            ds = (String) map.remove(\"Sequence\");\n+            if (ds != null) {\n+                props = Configurations.serializeProperties(map);\n+                plugin = Configurations.getPlugin(clsName, props);\n+            }\n+        }\n+\n+        if (ds != null)\n+            ab.add(\"sequenceName\", ds);\n+        else if (plugin != null && !SequenceMetaData.IMPL_NATIVE.equals\n+            (plugin))\n+            ab.add(\"sequenceName\", plugin);\n+        if (meta.getInitialValue() != 0 && meta.getInitialValue() != -1)\n+            ab.add(\"initialValue\", meta.getInitialValue());\n+        if (meta.getAllocate() != 50 && meta.getAllocate() != -1)\n+            ab.add(\"allocationSize\", meta.getAllocate());\n+    }\n+\n+    /**\n+     * Serialize class metadata.\n+     */\n+    protected void serializeClass(ClassMetaData meta) {\n+        Log log = getLog();\n+        if (log.isInfoEnabled())\n+            log.info(_loc.get(\"ser-class\", meta));\n+\n+        AnnotationBuilder abEntity = addAnnotation(\n+            getEntityAnnotationType(meta), meta);\n+        if (isMetaDataMode()\n+            && !meta.getTypeAlias().equals(Strings.getClassName(meta.\n+            getDescribedType())))\n+            abEntity.add(\"name\", meta.getTypeAlias());\n+        \n+        if (isMappingMode())\n+            addClassMappingAnnotations(meta);\n+\n+        if (isMappingMode())\n+            serializeClassMappingContent(meta);\n+        if (isMetaDataMode())\n+            serializeIdClass(meta);\n+        if (isMappingMode())\n+            serializeInheritanceContent(meta);\n+\n+        if (isMappingMode()) {\n+            List seqs = (_seqs == null) ? null : _seqs.get\n+                (meta.getDescribedType().getName());\n+            if (seqs != null) {\n+                serializationSort(seqs);\n+                for (int i = 0; i < seqs.size(); i++)\n+                    serializeSequence((SequenceMetaData) seqs.get(i));\n+            }\n+        }\n+\n+        if (isQueryMode()) {\n+            List queries = (_queries == null) ? null : _queries.get\n+                (meta.getDescribedType().getName());\n+            if (queries != null) {\n+                serializationSort(queries);\n+                for (int i = 0; i < queries.size(); i++)\n+                    serializeQuery((QueryMetaData) queries.get(i));\n+            }\n+            if (isMappingMode())\n+                serializeQueryMappings(meta);\n+        }\n+\n+        List<FieldMetaData> fields = new ArrayList(Arrays.asList\n+            (meta.getDefinedFieldsInListingOrder()));\n+        Collections.sort(fields, new FieldComparator());\n+\n+        // serialize attr-override\n+        if (isMappingMode()) {\n+            FieldMetaData fmd;\n+            FieldMetaData orig;\n+            for (Iterator<FieldMetaData> it = fields.iterator(); it.hasNext();)\n+            {\n+                fmd = it.next();\n+                if (meta.getDefinedSuperclassField(fmd.getName()) == null)\n+                    continue;\n+                orig = meta.getPCSuperclassMetaData().getField(fmd.getName());\n+                if (serializeAttributeOverride(fmd, orig))\n+                    serializeAttributeOverrideContent(fmd, orig);\n+                it.remove();\n+            }\n+        }\n+\n+        if (fields.size() > 0 && (isMetaDataMode() || isMappingMode())) {\n+            FieldMetaData orig;\n+            for (FieldMetaData fmd : fields) {\n+                if (fmd.getDeclaringType() != fmd.getDefiningMetaData().\n+                    getDescribedType()) {\n+                    orig = fmd.getDeclaringMetaData().getDeclaredField\n+                        (fmd.getName());\n+                } else\n+                    orig = null;\n+                serializeField(fmd, orig);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return entity annotation type.\n+     */\n+    private static Class<? extends Annotation> getEntityAnnotationType(\n+        ClassMetaData meta) {\n+        switch (getEntityTag(meta)) {\n+            case ENTITY:\n+                return Entity.class;\n+            case EMBEDDABLE:\n+                return Embeddable.class;\n+            case MAPPED_SUPERCLASS:\n+                return MappedSuperclass.class;\n+            default:\n+                throw new IllegalStateException();\n+        }\n+    }\n+\n+    /**\n+     * Return field annotation type.\n+     */\n+    private static Class<? extends Annotation> getFieldAnnotationType (\n+        FieldMetaData fmd, PersistenceStrategy strat) {\n+        Class<? extends Annotation> ann = null;\n+        if (fmd.isPrimaryKey() && strat == PersistenceStrategy.EMBEDDED)\n+            ann = EmbeddedId.class;\n+        else if (fmd.isPrimaryKey())\n+            ann = Id.class;\n+        else if (fmd.isVersion())\n+            ann = Version.class;\n+        else {\n+            switch (strat) {\n+                case TRANSIENT:\n+                    ann = Transient.class;\n+                    break;\n+                case BASIC:\n+                    ann = Basic.class;\n+                    break;\n+                case EMBEDDED:\n+                    ann = Embedded.class;\n+                    break;\n+                case MANY_ONE:\n+                    ann = ManyToOne.class;\n+                    break;\n+                case ONE_ONE:\n+                    ann = OneToOne.class;\n+                    break;\n+                case ONE_MANY:\n+                    ann = OneToMany.class;\n+                    break;\n+                case MANY_MANY:\n+                    ann = ManyToMany.class;\n+                    break;\n+            }\n+        }\n+        return ann;\n+    }\n+\n+    /**\n+     * Return the MetaDataTag for the given class meta data.\n+     */\n+    private static MetaDataTag getEntityTag(ClassMetaData meta) {\n+        // @Embeddable classes can't declare Id fields\n+        if (meta.isEmbeddedOnly() && meta.getPrimaryKeyFields().length == 0)\n+            return MetaDataTag.EMBEDDABLE;\n+        if (meta.isMapped())\n+            return MetaDataTag.ENTITY;\n+        return MetaDataTag.MAPPED_SUPERCLASS;\n+    }\n+\n+    /**\n+     * Add mapping attributes for the given class. Does nothing by default\n+     */\n+    protected void addClassMappingAnnotations(ClassMetaData mapping) {\n+    }\n+\n+    /**\n+     * Serialize id-class.\n+     */\n+    private void serializeIdClass(ClassMetaData meta) {\n+        if (meta.getIdentityType() != ClassMetaData.ID_APPLICATION\n+            || meta.isOpenJPAIdentity())\n+            return;\n+\n+        ClassMetaData sup = meta.getPCSuperclassMetaData();\n+        Class oid = meta.getObjectIdType();\n+        if (oid != null && (sup == null || oid != sup.getObjectIdType())) {\n+            AnnotationBuilder ab = addAnnotation(IdClass.class, meta);\n+            ab.add(null, oid);\n+        }\n+    }\n+\n+    /**\n+     * Serialize class mapping content. Does nothing by default.\n+     */\n+    protected void serializeClassMappingContent(ClassMetaData mapping) {\n+    }\n+\n+    /**\n+     * Serialize inheritance content. Does nothing by default.\n+     */\n+    protected void serializeInheritanceContent(ClassMetaData mapping) {\n+    }\n+\n+    /**\n+     * Serialize query mappings. Does nothing by default.\n+     */\n+    protected void serializeQueryMappings(ClassMetaData meta) {\n+    }\n+\n+    /**\n+     * Serialize the given field.\n+     */\n+    private void serializeField(FieldMetaData fmd, FieldMetaData orig) {\n+        if (fmd.getManagement() != FieldMetaData.MANAGE_PERSISTENT\n+            && !fmd.isExplicit())\n+            return;\n+\n+        PersistenceStrategy strat = getStrategy(fmd);\n+        ValueMetaData cascades = null;\n+        AnnotationBuilder ab = addAnnotation(\n+            getFieldAnnotationType (fmd, strat), fmd);        \n+        if (fmd.isPrimaryKey() && strat == PersistenceStrategy.EMBEDDED)\n+            ; // noop\n+        else if (fmd.isPrimaryKey())\n+            ; // noop\n+        else if (fmd.isVersion())\n+            ; // noop\n+        else {\n+            switch (strat) {\n+                case BASIC:\n+                    if (isMetaDataMode())\n+                        addBasicAttributes(fmd, ab);\n+                    break;\n+                case MANY_ONE:\n+                    if (isMetaDataMode())\n+                        addManyToOneAttributes(fmd, ab);\n+                    cascades = fmd;\n+                    break;\n+                case ONE_ONE:\n+                    if (isMetaDataMode())\n+                        addOneToOneAttributes(fmd, ab);\n+                    cascades = fmd;\n+                    break;\n+                case ONE_MANY:\n+                    if (isMetaDataMode())\n+                        addOneToManyAttributes(fmd, ab);\n+                    cascades = fmd.getElement();\n+                    break;\n+                case MANY_MANY:\n+                    if (isMetaDataMode())\n+                        addManyToManyAttributes(fmd, ab);\n+                    cascades = fmd.getElement();\n+                    break;\n+            }\n+            if (isMappingMode())\n+                addStrategyMappingAttributes(fmd, ab);\n+        }\n+        if (isMappingMode(fmd))\n+            addFieldMappingAttributes(fmd, orig, ab);\n+\n+        if (fmd.getOrderDeclaration() != null) {\n+            if (!(Order.ELEMENT + \" asc\").equals(fmd.getOrderDeclaration()))\n+                addAnnotation(OrderBy.class, fmd).\n+                    add (null, fmd.getOrderDeclaration());\n+        }\n+        if (isMappingMode() && fmd.getKey().getValueMappedBy() != null) {\n+            AnnotationBuilder abMapKey = addAnnotation(MapKey.class, fmd);\n+            FieldMetaData mapBy = fmd.getKey().getValueMappedByMetaData();\n+            if (!mapBy.isPrimaryKey() ||\n+                mapBy.getDefiningMetaData().getPrimaryKeyFields().length != 1) {\n+                abMapKey.add(\"name\", fmd.getKey().getValueMappedBy());\n+            }\n+        }\n+        if (isMappingMode(fmd))\n+            serializeFieldMappingContent(fmd, strat, ab);\n+        if (cascades != null && isMetaDataMode())\n+            serializeCascades(cascades, ab);\n+    }\n+\n+    /**\n+     * Add mapping attributes for the given field. Does nothing by default.\n+     */\n+    protected void addFieldMappingAttributes(FieldMetaData fmd,\n+        FieldMetaData orig, AnnotationBuilder ab) {\n+    }\n+    \n+    /**\n+     * Always returns false by default.\n+     */\n+    protected boolean serializeAttributeOverride(FieldMetaData fmd,\n+        FieldMetaData orig) {\n+        return false;\n+    }\n+\n+    /**\n+     * Serialize attribute override content.\n+     */\n+    private void serializeAttributeOverrideContent(FieldMetaData fmd,\n+        FieldMetaData orig) {\n+        AnnotationBuilder ab = addAnnotation(AttributeOverride.class, fmd);\n+        ab.add(\"name\", fmd.getName());\n+        serializeAttributeOverrideMappingContent(fmd, orig, ab);\n+    }\n+\n+    /**\n+     * Serialize attribute override mapping content. Does nothing by default,\n+     */\n+    protected void serializeAttributeOverrideMappingContent\n+        (FieldMetaData fmd, FieldMetaData orig, AnnotationBuilder ab) {\n+    }\n+\n+\n+    /**\n+     * Serialize cascades.\n+     */\n+    private void serializeCascades(ValueMetaData vmd, AnnotationBuilder ab) {\n+        EnumSet<CascadeType> cascades = EnumSet.noneOf(CascadeType.class);\n+        if (vmd.getCascadePersist() == ValueMetaData.CASCADE_IMMEDIATE) {\n+            cascades.add(CascadeType.PERSIST);\n+        }\n+        if (vmd.getCascadeAttach() == ValueMetaData.CASCADE_IMMEDIATE) {\n+            cascades.add(CascadeType.MERGE);\n+        }\n+        if (vmd.getCascadeDelete() == ValueMetaData.CASCADE_IMMEDIATE) {\n+            cascades.add(CascadeType.REMOVE);\n+        }\n+        if (vmd.getCascadeRefresh() == ValueMetaData.CASCADE_IMMEDIATE) {\n+            cascades.add(CascadeType.REFRESH);\n+        }\n+        if (cascades.size() == 4) // ALL\n+        {\n+            cascades.clear();\n+            cascades.add(CascadeType.ALL);\n+        }\n+        if (!cascades.isEmpty()) {\n+            ab.add(\"cascade\", cascades);\n+        }\n+    }\n+\n+    /**\n+     * Return the serialized strategy name.\n+     */\n+    protected PersistenceStrategy getStrategy(FieldMetaData fmd) {\n+        if (fmd.getManagement() == fmd.MANAGE_NONE)\n+            return PersistenceStrategy.TRANSIENT;\n+\n+        if (fmd.isSerialized()\n+            || fmd.getDeclaredType() == byte[].class\n+            || fmd.getDeclaredType() == Byte[].class\n+            || fmd.getDeclaredType() == char[].class\n+            || fmd.getDeclaredType() == Character[].class)\n+            return PersistenceStrategy.BASIC;\n+\n+        FieldMetaData mappedBy;\n+        switch (fmd.getDeclaredTypeCode()) {\n+            case JavaTypes.PC:\n+                if (fmd.isEmbedded())\n+                    return PersistenceStrategy.EMBEDDED;\n+                if (fmd.getMappedBy() != null)\n+                    return PersistenceStrategy.ONE_ONE;\n+                FieldMetaData[] inverses = fmd.getInverseMetaDatas();\n+                if (inverses.length == 1 &&\n+                    inverses[0].getTypeCode() == JavaTypes.PC &&\n+                    inverses[0].getMappedByMetaData() == fmd) {\n+                    return PersistenceStrategy.ONE_ONE;\n+                }\n+                return PersistenceStrategy.MANY_ONE;\n+            case JavaTypes.ARRAY:\n+            case JavaTypes.COLLECTION:\n+            case JavaTypes.MAP:\n+                mappedBy = fmd.getMappedByMetaData();\n+                if (mappedBy == null || mappedBy.getTypeCode() != JavaTypes.PC)\n+                    return PersistenceStrategy.MANY_MANY;\n+                return PersistenceStrategy.ONE_MANY;\n+            case JavaTypes.OID:\n+                return PersistenceStrategy.EMBEDDED;\n+            default:\n+                return PersistenceStrategy.BASIC;\n+        }\n+    }\n+\n+    /**\n+     * Add basic attributes.\n+     */\n+    private void addBasicAttributes(FieldMetaData fmd, AnnotationBuilder ab) {\n+        if (!fmd.isInDefaultFetchGroup())\n+            ab.add(\"fetch\", FetchType.LAZY);\n+        if (fmd.getNullValue() == FieldMetaData.NULL_EXCEPTION)\n+            ab.add(\"optional\", false);\n+    }\n+\n+    /**\n+     * Add many-to-one attributes.\n+     */\n+    private void addManyToOneAttributes(FieldMetaData fmd,\n+        AnnotationBuilder ab) {\n+        if (!fmd.isInDefaultFetchGroup())\n+            ab.add(\"fetch\", FetchType.LAZY);\n+        if (fmd.getNullValue() == FieldMetaData.NULL_EXCEPTION)\n+            ab.add(\"optional\", false);\n+    }\n+\n+    /**\n+     * Add one-to-one attributes.\n+     */\n+    private void addOneToOneAttributes(FieldMetaData fmd,\n+        AnnotationBuilder ab) {\n+        if (!fmd.isInDefaultFetchGroup())\n+            ab.add(\"fetch\", FetchType.LAZY);\n+        if (fmd.getNullValue() == FieldMetaData.NULL_EXCEPTION)\n+            ab.add(\"optional\", false);\n+    }\n+\n+    /**\n+     * Add one-to-many attributes.\n+     */\n+    private void addOneToManyAttributes(FieldMetaData fmd,\n+        AnnotationBuilder ab) {\n+        if (fmd.isInDefaultFetchGroup())\n+            ab.add(\"fetch\", FetchType.EAGER);\n+        addTargetEntityAttribute(fmd, ab);\n+    }\n+\n+    /**\n+     * Add many-to-many attributes.\n+     */\n+    private void addManyToManyAttributes(FieldMetaData fmd,\n+        AnnotationBuilder ab) {\n+        if (fmd.isInDefaultFetchGroup())\n+            ab.add(\"fetch\", FetchType.EAGER);\n+        addTargetEntityAttribute(fmd, ab);\n+    }\n+\n+    /**\n+     * Add a target-entity attribute to collection and map fields that do\n+     * not use generics.\n+     */\n+    private void addTargetEntityAttribute(FieldMetaData fmd,\n+        AnnotationBuilder ab) {\n+        Member member = fmd.getBackingMember();\n+        Class[] types;\n+        if (member instanceof Field)\n+            types = JavaVersions.getParameterizedTypes((Field) member);\n+        else if (member instanceof Method)\n+            types = JavaVersions.getParameterizedTypes((Method) member);\n+        else\n+            types = new Class[0];\n+\n+        switch (fmd.getDeclaredTypeCode()) {\n+            case JavaTypes.COLLECTION:\n+                if (types.length != 1)\n+                    ab.add(\"targetEntity\", fmd.getElement().getDeclaredType());\n+                break;\n+            case JavaTypes.MAP:\n+                if (types.length != 2)\n+                    ab.add(\"targetEntity\", fmd.getElement().getDeclaredType());\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Serialize field mapping content; this will be called before\n+     * {@link #serializeValueMappingContent}. Does nothing by default.\n+     */\n+    protected void serializeFieldMappingContent(FieldMetaData fmd,\n+        PersistenceStrategy strategy, AnnotationBuilder ab) {\n+    }\n+\n+    /**\n+     * Set mapping attributes for strategy. Sets mapped-by by default.\n+     */\n+    protected void addStrategyMappingAttributes(FieldMetaData fmd,\n+        AnnotationBuilder ab) {\n+        if (fmd.getMappedBy() != null)\n+            ab.add(\"mappedBy\", fmd.getMappedBy());\n+    }\n+    \n+    protected Collection getObjects() {\n+        List all = new ArrayList();\n+        if (isQueryMode())\n+            addQueryMetaDatas(all);\n+        if (isMappingMode())\n+            addSequenceMetaDatas(all);\n+        if ((isMetaDataMode() || isMappingMode()) && _metas != null)\n+            all.addAll(_metas.values());\n+        if (isMappingMode())\n+            addSystemMappingElements(all);\n+        serializationSort(all);\n+        return all;\n+    }\n+\n+    protected void writeAnnotations(Object meta,\n+        List<AnnotationBuilder> builders, Map output) {\n+        List<String> annos = new ArrayList<String>();\n+        for(AnnotationBuilder ab: builders)\n+            annos.add(ab.toString());\n+        output.put(meta, annos);        \n+    }\n+\n+    public void serialize(Map output, int flags) throws IOException {\n+        Collection all = getObjects();\n+        serialize(all);\n+\n+        if (_clsAnnos != null)\n+            for (ClassMetaData meta : _clsAnnos.keySet())\n+                writeAnnotations(meta, _clsAnnos.get(meta), output);\n+        if (_fldAnnos != null)\n+            for (FieldMetaData meta : _fldAnnos.keySet())\n+                writeAnnotations(meta, _fldAnnos.get(meta), output);\n+        if (_seqAnnos != null)\n+            for (SequenceMetaData meta : _seqAnnos.keySet())\n+                writeAnnotations(meta, _seqAnnos.get(meta), output);\n+        if (_qryAnnos != null)\n+            for (QueryMetaData meta : _qryAnnos.keySet())\n+                writeAnnotations(meta, _qryAnnos.get(meta), output);\n+    }\n+\n+    public void serialize(File file, int flags) throws IOException {\n+        FileWriter out = new FileWriter(file.getCanonicalPath(),\n+            (flags & APPEND) > 0);\n+        serialize(out, flags);\n+        out.close();\n+    }\n+\n+    public void serialize(Writer out, int flags) throws IOException {\n+        Map output = new HashMap();\n+        serialize(output, flags);\n+\n+        for(Object meta: output.keySet()) {\n+            out.write(\"--\"+meta.toString());\n+            out.write(\"\\n\");\n+            List<String> annos = (List<String>) output.get(meta);\n+            for(String ann: annos) {\n+                out.write(\"\\t\");\n+                out.write(ann);\n+                out.write(\"\\n\");\n+            }\n+        }\n+    }\n+\n+    public void serialize(int flags) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Represents ordered set of {@link org.apache.openjpa.meta.SequenceMetaData}s with a\n+     * common class scope.\n+     *\n+     * @author Stephen Kim\n+     * @author Pinaki Poddar\n+     */\n+    private static class ClassSeqs\n+        implements SourceTracker, Comparable<ClassSeqs>,\n+        Comparator<SequenceMetaData> {\n+\n+        private final SequenceMetaData[] _seqs;\n+\n+        public ClassSeqs(List<SequenceMetaData> seqs) {\n+            if (seqs == null || seqs.isEmpty())\n+                throw new InternalException();\n+\n+            _seqs = (SequenceMetaData[]) seqs.toArray\n+                (new SequenceMetaData[seqs.size()]);\n+            Arrays.sort(_seqs, this);\n+        }\n+\n+        public SequenceMetaData[] getSequences() {\n+            return _seqs;\n+        }\n+\n+        /**\n+         * Compare sequence metadata on name.\n+         */\n+        public int compare(SequenceMetaData o1, SequenceMetaData o2) {\n+            return o1.getName().compareTo(o2.getName());\n+        }\n+\n+        public File getSourceFile() {\n+            return _seqs[0].getSourceFile();\n+        }\n+\n+        public Object getSourceScope() {\n+            return _seqs[0].getSourceScope();\n+        }\n+\n+        public int getSourceType() {\n+            return _seqs[0].getSourceType();\n+        }\n+\n+        public String getResourceName() {\n+            return _seqs[0].getResourceName();\n+        }\n+\n+        public int compareTo(ClassSeqs other) {\n+            if (other == this)\n+                return 0;\n+            if (other == null)\n+                return -1;\n+            Class scope = (Class) getSourceScope();\n+            Class oscope = (Class) other.getSourceScope();\n+            return scope.getName().compareTo(oscope.getName());\n+        }\n+    }\n+\n+    /**\n+     * Represents ordered set of {@link org.apache.openjpa.meta.QueryMetaData}s with a\n+     * common class scope.\n+     *\n+     * @author Stephen Kim\n+     * @author Pinaki Poddar\n+     */\n+    private static class ClassQueries\n+        implements SourceTracker, Comparable<ClassQueries>,\n+        Comparator<QueryMetaData> {\n+\n+        private final QueryMetaData[] _queries;\n+\n+        public ClassQueries(List<QueryMetaData> queries) {\n+            if (queries == null || queries.isEmpty())\n+                throw new InternalException();\n+\n+            _queries = (QueryMetaData[]) queries.toArray\n+                (new QueryMetaData[queries.size()]);\n+            Arrays.sort(_queries, this);\n+        }\n+\n+        public QueryMetaData[] getQueries() {\n+            return _queries;\n+        }\n+\n+        /**\n+         * Compare query metadata. Normal queries appear before native queries.\n+         * If the given queries use same language, then their names are\n+         * compared.\n+         */\n+        public int compare(QueryMetaData o1, QueryMetaData o2) {\n+            // normal queries before native\n+            if (!StringUtils.equals(o1.getLanguage(), o2.getLanguage())) {\n+                if (QueryLanguages.LANG_SQL.equals(o1.getLanguage()))\n+                    return 1;\n+                else\n+                    return -1;\n+            }\n+            return o1.getName().compareTo(o2.getName());\n+        }\n+\n+        public File getSourceFile() {\n+            return _queries[0].getSourceFile();\n+        }\n+\n+        public Object getSourceScope() {\n+            return _queries[0].getSourceScope();\n+        }\n+\n+        public int getSourceType() {\n+            return _queries[0].getSourceType();\n+        }\n+\n+        public String getResourceName() {\n+            return _queries[0].getResourceName();\n+        }\n+\n+        public int compareTo(ClassQueries other) {\n+            if (other == this)\n+                return 0;\n+            if (other == null)\n+                return -1;\n+            Class scope = (Class) getSourceScope();\n+            Class oscope = (Class) other.getSourceScope();\n+            return scope.getName().compareTo(oscope.getName());\n+        }\n+    }\n+\n+    /**\n+     * Compares clases, sequences, and queries to order them for serialization.\n+     * Places sequences first, then classes, then queries. Sequences and\n+     * queries are ordered alphabetically by name. Classes are placed in\n+     * listing order, in inheritance order within that, and in alphabetical\n+     * order within that.\n+     *\n+     * @author Stephen Kim\n+     */\n+    protected class SerializationComparator\n+        extends MetaDataInheritanceComparator {\n+\n+        public int compare(Object o1, Object o2) {\n+            if (o1 == o2)\n+                return 0;\n+            if (o1 == null)\n+                return 1;\n+            if (o2 == null)\n+                return -1;\n+\n+            int t1 = type(o1);\n+            int t2 = type(o2);\n+            if (t1 != t2)\n+                return t1 - t2;\n+\n+            switch (t1) {\n+                case TYPE_META:\n+                    return compare((ClassMetaData) o1, (ClassMetaData) o2);\n+                case TYPE_QUERY:\n+                    return compare((QueryMetaData) o1, (QueryMetaData) o2);\n+                case TYPE_SEQ:\n+                    return compare((SequenceMetaData) o1,\n+                        (SequenceMetaData) o2);\n+                case TYPE_CLASS_QUERIES:\n+                    return ((Comparable) o1).compareTo(o2);\n+                case TYPE_CLASS_SEQS:\n+                    return ((Comparable) o1).compareTo(o2);\n+                default:\n+                    return compareUnknown(o1, o2);\n+            }\n+        }\n+\n+        /**\n+         * Compare two unrecognized elements of the same type. Throws\n+         * exception by default.\n+         */\n+        protected int compareUnknown(Object o1, Object o2) {\n+            throw new InternalException();\n+        }\n+\n+        /**\n+         * Compare between two class metadata.\n+         */\n+        private int compare(ClassMetaData o1, ClassMetaData o2) {\n+            int li1 = o1.getListingIndex();\n+            int li2 = o2.getListingIndex();\n+            if (li1 == -1 && li2 == -1) {\n+                MetaDataTag t1 = getEntityTag(o1);\n+                MetaDataTag t2 = getEntityTag(o2);\n+                if (t1.compareTo(t2) != 0)\n+                    return t1.compareTo(t2);\n+                int inher = super.compare(o1, o2);\n+                if (inher != 0)\n+                    return inher;\n+                return o1.getDescribedType().getName().compareTo\n+                    (o2.getDescribedType().getName());\n+            }\n+\n+            if (li1 == -1)\n+                return 1;\n+            if (li2 == -1)\n+                return -1;\n+            return li1 - li2;\n+        }\n+\n+        /**\n+         * Compare query metadata.\n+         */\n+        private int compare(QueryMetaData o1, QueryMetaData o2) {\n+            // normal queries before native\n+            if (!StringUtils.equals(o1.getLanguage(), o2.getLanguage())) {\n+                if (QueryLanguages.LANG_SQL.equals(o1.getLanguage()))\n+                    return 1;\n+                else\n+                    return -1;\n+            }\n+            return o1.getName().compareTo(o2.getName());\n+        }\n+\n+        /**\n+         * Compare sequence metadata.\n+         */\n+        private int compare(SequenceMetaData o1, SequenceMetaData o2) {\n+            return o1.getName().compareTo(o2.getName());\n+        }\n+    }\n+\n+    /**\n+     * Sorts fields according to listing order, then XSD strategy order,\n+     * then name order.\n+     */\n+    private class FieldComparator\n+        implements Comparator {\n+\n+        public int compare(Object o1, Object o2) {\n+            FieldMetaData fmd1 = (FieldMetaData) o1;\n+            FieldMetaData fmd2 = (FieldMetaData) o2;\n+            if (fmd1.isPrimaryKey()) {\n+                if (fmd2.isPrimaryKey())\n+                    return fmd1.compareTo(fmd2);\n+                return -1;\n+            }\n+            if (fmd2.isPrimaryKey())\n+                return 1;\n+\n+            if (fmd1.isVersion()) {\n+                if (fmd2.isVersion())\n+                    return compareListingOrder(fmd1, fmd2);\n+\t\t\t\treturn getStrategy(fmd2) == PersistenceStrategy.BASIC ? 1 : -1;\n+\t\t\t}\n+\t\t\tif (fmd2.isVersion())\n+\t\t\t\treturn getStrategy(fmd1) == PersistenceStrategy.BASIC ? -1 : 1;\n+\n+\t\t\tint stcmp = getStrategy(fmd1).compareTo(getStrategy(fmd2));\n+            if (stcmp != 0)\n+                return stcmp;\n+            return compareListingOrder(fmd1, fmd2);\n+        }\n+\n+        private int compareListingOrder(FieldMetaData fmd1, FieldMetaData fmd2){\n+            int lcmp = fmd1.getListingIndex() - fmd2.getListingIndex();\n+            if (lcmp != 0)\n+                return lcmp;\n+            return fmd1.compareTo(fmd2);\n+\t\t}\n+\t}\n+}"},{"sha":"7437db04c3b995794798552f3073d0dacf2f921c","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java?ref=85b2e766cae4a55e9e32442cc889a56b8fee0d65","patch":"@@ -125,6 +125,15 @@ protected AnnotationPersistenceMetaDataParser newAnnotationParser() {\n             (repos.getConfiguration());\n     }\n \n+    /**\n+     * Create a new annotation serializer.\n+     */\n+    protected AnnotationPersistenceMetaDataSerializer\n+        newAnnotationSerializer() {\n+        return new AnnotationPersistenceMetaDataSerializer\n+            (repos.getConfiguration());\n+    }\n+\n     /**\n      * Return XML metadata parser, creating it if it does not already exist.\n      */"},{"sha":"7547ebddeb62a3bd4b2adb73977215da2bfe0529","filename":"openjpa-project/src/doc/manual/ref_guide_mapping.xml","status":"modified","additions":33,"deletions":5,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-project/src/doc/manual/ref_guide_mapping.xml","raw_url":"https://github.com/apache/openjpa/raw/85b2e766cae4a55e9e32442cc889a56b8fee0d65/openjpa-project/src/doc/manual/ref_guide_mapping.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_mapping.xml?ref=85b2e766cae4a55e9e32442cc889a56b8fee0d65","patch":"@@ -539,6 +539,26 @@ directory. Defaults to the current directory.\n                     </listitem>\n                     <listitem>\n                         <para>\n+<literal>-metadata/-md &lt;class | package | none&gt;</literal>: Specify the\n+level the metadata should be generated at. Defaults to generating a single\n+package-level metadata file. Set to <literal>none</literal> to disable orm.xml\n+generation.\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>-annotations/-ann &lt;true/t | false/f&gt;</literal>: Set to true to\n+generate JPA annotations in generated java classes. \n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>-accessType/-access &lt;field | property&gt;</literal>: Change access\n+type for generated annotations. Defaults to field access.\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n <literal>-useSchemaName/-sn &lt;true/t | false/f&gt;</literal>: Set this flag\n to <literal>true</literal> to include the schema as well as table name in the\n name of each generated class. This can be useful when dealing with multiple\n@@ -588,6 +608,13 @@ for every many-1/1-1 relation detected.\n                     </listitem>\n                     <listitem>\n                         <para>\n+<literal>-useGenericCollections/-gc &lt;true/t | false/f&gt;</literal>: Set to\n+true to use generic collections on OneToMany and ManyToMany relations (requires\n+JDK 1.5 or higher).\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n <literal>-useDatastoreIdentity/-ds &lt;true/t | false/f&gt;</literal>: Set to\n <literal>true</literal> to use datastore identity for tables that have single\n numeric primary key columns. The tool typically uses application identity for\n@@ -672,8 +699,9 @@ property in the specified reverse customizer, and set to the given value.\n                 <para>\n Running the tool will generate <filename>.java</filename> files for each\n generated class (and its application identity class, if applicable), along with\n-an <filename>orm.xml</filename> file containing the corresponding persistence \n-metadata.\n+JPA annotations (if enabled by setting <literal>-annotations true</literal>),\n+or an <filename>orm.xml</filename> file (if not disabled with <literal>\n+-metadata none</literal>) containing the corresponding persistence metadata.\n                 </para>\n             </listitem>\n             <listitem>\n@@ -688,9 +716,9 @@ After you are satisfied with the generated classes and their mappings, you\n should first compile the classes with <literal>javac</literal>, <literal>\n jikes</literal>, or your favorite Java compiler. Make sure the classes are \n located in the directory corresponding to the <literal>-package</literal> flag \n-you gave the reverse mapping tool.  Next, move the generated <filename>\n-orm.xml</filename> file to a <filename>META-INF</filename> directory within a\n-directory in your classpath.  Finally, enhance the classes\n+you gave the reverse mapping tool.  Next, if you have generated an <filename>\n+orm.xml</filename>, move that file to a <filename>META-INF</filename> directory\n+within a directory in your classpath.  Finally, enhance the classes\n if necessary (see <xref linkend=\"ref_guide_pc_enhance\"/> ).\n                 </para>\n             </listitem>"}]}

