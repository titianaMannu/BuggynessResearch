{"sha":"884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","node_id":"MDY6Q29tbWl0MjA2MzY0Ojg4NGZmMWI4NjM5M2I0OWQwZDg4ZmM5NWE3YjgwNTExZGQ5Y2I3YzM=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2006-07-25T07:10:26Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2006-07-25T07:10:26Z"},"message":"FetchPlan with recursive scheme.\n- modified select building and load cycles in JDBCStoreManager with FetchState traversal \n- loadAll(), findAll() methods reverted to their method signature with FetchConfiguration instead of FetchState\n- StateManager.postLoad checks for fetch group with postload set to true \n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@425312 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"483995b08a3843d26ecc6af4d81d312df0cfc79f","url":"https://api.github.com/repos/apache/openjpa/git/trees/483995b08a3843d26ecc6af4d81d312df0cfc79f"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","html_url":"https://github.com/apache/openjpa/commit/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","comments_url":"https://api.github.com/repos/apache/openjpa/commits/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/comments","author":null,"committer":null,"parents":[{"sha":"98e8533cb0c6418329cb9a7b1d4514fbeca4720e","url":"https://api.github.com/repos/apache/openjpa/commits/98e8533cb0c6418329cb9a7b1d4514fbeca4720e","html_url":"https://github.com/apache/openjpa/commit/98e8533cb0c6418329cb9a7b1d4514fbeca4720e"}],"stats":{"total":1271,"additions":661,"deletions":610},"files":[{"sha":"4f646c21b749919a2b8753ace708dffb0800ff33","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","status":"modified","additions":40,"deletions":34,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -441,10 +441,7 @@ private boolean selectPrimaryKey(OpenJPAStateManager sm,\n \n     public boolean load(OpenJPAStateManager sm, BitSet fields,\n         FetchState fetchState, int lockLevel, Object context) {\n-        JDBCFetchState jfetchState = (fetchState == null) ? (JDBCFetchState) getFetchConfiguration()\n-            .newFetchState()\n-            : (JDBCFetchState) fetchState;\n-\n+        JDBCFetchState jfetchState = (JDBCFetchState) fetchState;\n         JDBCFetchConfiguration jfetch = getFetchConfiguration(jfetchState);\n \n         // get a connection, or reuse current one\n@@ -492,9 +489,10 @@ public boolean load(OpenJPAStateManager sm, BitSet fields,\n \n             // now allow the fields to load themselves individually too\n             for (int i = 0, len = fields.length(); i < len; i++)\n-                if (fields.get(i) && !sm.getLoaded().get(i))\n-                    mapping.getFieldMapping(i).load(sm, this, jfetchState);\n-\n+                if (fields.get(i) && !sm.getLoaded().get(i)) {\n+                \tFieldMapping fm = mapping.getFieldMapping(i);\n+                    fm.load(sm, this, (JDBCFetchState)jfetchState.traverse(fm));\n+                }\n             mapping.getVersion().afterLoad(sm, this);\n             return true;\n         } catch (ClassNotFoundException cnfe) {\n@@ -514,8 +512,8 @@ private void removeLoadedFields(OpenJPAStateManager sm, BitSet fields) {\n     }\n \n     public Collection loadAll(Collection sms, PCState state, int load,\n-        FetchState fetchState, Object context) {\n-        return ImplHelper.loadAll(sms, this, state, load, fetchState, context);\n+        FetchConfiguration fetch, Object context) {\n+        return ImplHelper.loadAll(sms, this, state, load, fetch, context);\n     }\n \n     public void beforeStateChange(OpenJPAStateManager sm, PCState fromState,\n@@ -829,23 +827,25 @@ else if (sm.getVersion() == null)\n         for (int i = 0; i < fms.length; i++) {\n             if (fms[i].isPrimaryKey() || sm.getLoaded().get(fms[i].getIndex()))\n                 continue;\n-\n+            \n             // check for eager result, and if not present do standard load\n             eres = res.getEager(fms[i]);\n             res.startDataRequest(fms[i]);\n             try {\n-                if (eres == res) {\n+               if (eres == res) {\n                     if (eagerToMany == null && fms[i].isEagerSelectToMany())\n                         eagerToMany = fms[i];\n                     else\n-                        fms[i].loadEagerJoin(sm, this, fetchState, res);\n+                        fms[i].loadEagerJoin(sm, this, \n+                        \t(JDBCFetchState)fetchState.traverse(fms[i]), res);\n                 } else if (eres != null) {\n-                    processed = fms[i].loadEagerParallel(sm, this, fetchState,\n-                        eres);\n+                    processed = fms[i].loadEagerParallel(sm, this, \n+                    \t(JDBCFetchState)fetchState.traverse(fms[i]), eres);\n                     if (processed != eres)\n                         res.putEager(fms[i], processed);\n                 } else\n-                    fms[i].load(sm, this, fetchState, res);\n+                    fms[i].load(sm, this, \n+                    \t(JDBCFetchState)fetchState.traverse(fms[i]), res);\n             } finally {\n                 res.endDataRequest();\n             }\n@@ -931,11 +931,11 @@ private FieldMapping createEagerSelects(Select sel, ClassMapping mapping,\n         int jtype;\n         int mode;\n         for (int i = 0; i < fms.length; i++) {\n-            if (!requiresSelect(fms[i], sm, fields, fetchState))\n-                continue;\n             mode = fms[i].getEagerFetchMode();\n             if (mode == fetch.EAGER_NONE)\n                 continue;\n+            if (!requiresSelect(fms[i], sm, fields, fetchState))\n+                continue;\n \n             // try to select with join first\n             jtype = (fms[i].getNullValue() == fms[i].NULL_EXCEPTION) ? sel.EAGER_INNER\n@@ -985,7 +985,7 @@ private static boolean requiresSelect(FieldMapping fm,\n         if (sm != null && sm.getPCState() != PCState.TRANSIENT\n             && sm.getLoaded().get(fm.getIndex()))\n             return false;\n-        return fetchState.requiresSelect(fm, true);\n+        return fetchState.requiresFetch(fm);\n     }\n \n     /**\n@@ -1059,17 +1059,19 @@ private int selectBaseMappings(Select sel, ClassMapping mapping,\n             esel = sel.getEager(fms[i]);\n             if (esel != null) {\n                 if (esel == sel)\n-                    fms[i].selectEagerJoin(sel, sm, this, fetchState, eager);\n+                    fms[i].selectEagerJoin(sel, sm, this, \n+                    \t(JDBCFetchState)fetchState.traverse(fms[i]), eager);\n                 else\n-                    fms[i].selectEagerParallel(esel, sm, this, fetchState,\n-                        eager);\n+                    fms[i].selectEagerParallel(esel, sm, this, \n+                    \t(JDBCFetchState)fetchState.traverse(fms[i]), eager);\n                 seld = Math.max(0, seld);\n             } else if (requiresSelect(fms[i], sm, fields, fetchState)) {\n-                fseld = fms[i].select(sel, sm, this, fetchState, eager);\n+                fseld = fms[i].select(sel, sm, this, \n+                \t(JDBCFetchState)fetchState.traverse(fms[i]), eager);\n                 seld = Math.max(fseld, seld);\n             } else if (optSelect(fms[i], sel, sm, fetchState)) {\n-                fseld = fms[i].select(sel, sm, this, fetchState,\n-                    fetch.EAGER_NONE);\n+                fseld = fms[i].select(sel, sm, this, \n+                \t(JDBCFetchState)fetchState.traverse(fms[i]), fetch.EAGER_NONE);\n \n                 // don't upgrade seld to > 0 based on these fields, since\n                 // they're not in the calculated field set\n@@ -1100,7 +1102,7 @@ private boolean optSelect(FieldMapping fm, Select sel,\n                 .getLoaded().get(fm.getIndex()))\n             && fm.supportsSelect(sel, sel.TYPE_TWO_PART, sm, this,\n                 getFetchConfiguration(fetchState)) > 0\n-            && fetchState.requiresSelect(fm, true);\n+            && fetchState.requiresFetch(fm);\n     }\n \n     /**\n@@ -1141,12 +1143,15 @@ private void selectSubclassMappings(Select sel, ClassMapping mapping,\n             fms = subMappings[i].getDefinedFieldMappings();\n             for (int j = 0; j < fms.length; j++) {\n                 // make sure in one of configured fetch groups\n-                if (!fms[j].isInDefaultFetchGroup()\n-                    && !fetch.hasFetchGroup(fms[j].getFetchGroups())\n-                    && !fetch.hasField(fms[j].getFullName())\n-                    && (fms[j].isDefaultFetchGroupExplicit() || fms[j]\n-                        .supportsSelect(sel, sel.TYPE_TWO_PART, sm, this, fetch) <= 0))\n-                    continue;\n+            \tif (fetchState.requiresFetch(fms[j]) \n+            \t  || fms[j].supportsSelect(sel, sel.TYPE_TWO_PART, sm, this, fetch) <= 0) \n+            \t\tcontinue;\n+//                if (!fms[j].isInDefaultFetchGroup()\n+//                    && !fetch.hasAnyFetchGroup(fms[j].getFetchGroups())\n+//                    && !fetch.hasField(fms[j].getFullName())\n+//                    && (fms[j].isDefaultFetchGroupExplicit() || fms[j]\n+//                        .supportsSelect(sel, sel.TYPE_TWO_PART, sm, this, fetch) <= 0))\n+//                    continue;\n \n                 // if we can join to the subclass, do so; much better chance\n                 // that the field will be able to select itself without joins\n@@ -1159,9 +1164,10 @@ private void selectSubclassMappings(Select sel, ClassMapping mapping,\n \n                 // if can select with tables already selected, do it\n                 if (fms[j].supportsSelect(sel, sel.TYPE_JOINLESS, sm, this,\n-                    fetch) > 0)\n-                    fms[j]\n-                        .select(sel, null, this, fetchState, fetch.EAGER_NONE);\n+                    fetch) > 0 && fetchState.requiresFetch(fms[j]))\n+                    fms[j].select(sel, null, this, \n+                        \t(JDBCFetchState)fetchState.traverse(fms[j]), \n+                        \tfetch.EAGER_NONE);\n             }\n         }\n     }"},{"sha":"a63eaee3f617897e4207aad9087bf2403c0c1359","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PagingResultObjectProvider.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PagingResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PagingResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PagingResultObjectProvider.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -92,7 +92,7 @@ public static BitSet getPagedFields(Select sel, ClassMapping mapping,\n         BitSet paged = null;\n         for (int i = 0; i < fms.length; i++) {\n             if (fetchState != null\n-                && !fetchState.requiresSelect(fms[i], false))\n+                && !fetchState.requiresFetch(fms[i]))\n                 continue;\n \n             if (fms[i].supportsSelect(sel, sel.EAGER_PARALLEL, null, store,"},{"sha":"a2a369766ad3574ed7683f8ca4c1aedd986bddfc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -233,8 +233,8 @@ public abstract boolean load(OpenJPAStateManager sm, BitSet fields,\n      * advantageous.\n      */\n     public Collection loadAll(Collection sms, PCState state, int load,\n-        FetchState fetchState, Object context) {\n-        return ImplHelper.loadAll(sms, this, state, load, fetchState, context);\n+        FetchConfiguration fetch, Object context) {\n+        return ImplHelper.loadAll(sms, this, state, load, fetch, context);\n     }\n \n     /**"},{"sha":"170951fb8b59defdca9bedbb05beb86b7382876d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","status":"modified","additions":5,"deletions":7,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -408,12 +408,9 @@ public boolean load(OpenJPAStateManager sm, BitSet fields,\n     }\n \n     public Collection loadAll(Collection sms, PCState state, int load,\n-        FetchState fetchState, Object edata) {\n-        FetchConfiguration fetch = (fetchState == null)\n-            ? _ctx.getFetchConfiguration()\n-            : fetchState.getFetchConfiguration();\n+    \t\tFetchConfiguration fetch, Object edata) {\n         if (isLocking(fetch))\n-            return super.loadAll(sms, state, load, fetchState, edata);\n+            return super.loadAll(sms, state, load, fetch, edata);\n \n         Map unloaded = null;\n         OpenJPAStateManager sm;\n@@ -435,14 +432,15 @@ public Collection loadAll(Collection sms, PCState state, int load,\n                     //### the 'data.type' access here probably needs\n                     //### to be addressed for bug 511\n                     sm.initialize(data.getType(), state);\n-                    data.load(sm, fetchState, edata);\n+                    data.load(sm, fetch.newFetchState(), edata);\n                 } else\n                     unloaded = addUnloaded(sm, null, unloaded);\n             } else if (load != FORCE_LOAD_NONE\n                 || sm.getPCState() == PCState.HOLLOW) {\n                 data = cache.get(sm.getObjectId());\n                 if (data != null) {\n                     // load unloaded fields\n+                \tFetchState fetchState = fetch.newFetchState();\n                     fields = sm.getUnloaded(fetchState);\n                     data.load(sm, fields, fetchState, edata);\n                     if (fields.length() > 0)\n@@ -458,7 +456,7 @@ public Collection loadAll(Collection sms, PCState state, int load,\n \n         // load with delegate\n         Collection failed = super.loadAll(unloaded.keySet(), state, load,\n-            fetchState, edata);\n+            fetch, edata);\n         if (!_ctx.getPopulateDataCache())\n             return failed;\n "},{"sha":"ed3d93e7cde94a86de5c5a8a82c0a3660bee6e71","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -575,7 +575,7 @@ private void addLoadMethod(BCClass bc, ClassMetaData meta) {\n                 code.invokevirtual().setMethod(FieldMetaData.class,\n                     \"getFetchGroups\", Set.class, null);\n                 code.invokeinterface().setMethod\n-                    (FetchConfiguration.class, \"hasFetchGroup\",\n+                    (FetchConfiguration.class, \"hasAnyFetchGroup\",\n                         boolean.class, new Class[]{ Set.class });\n                 JumpInstruction ifins = code.ifne();\n                 code.aload().setLocal(fetch);"},{"sha":"f6ff065473790a40d6f6d45a06fc91fa6d665d67","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":14,"deletions":18,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -694,11 +694,13 @@ public Object find(Object oid, boolean validate, FindCallbacks call) {\n         int flags = OID_COPY | OID_ALLOW_NEW | OID_NODELETED;\n         if (!validate)\n             flags |= OID_NOVALIDATE;\n-        return find(oid, null, null, null, flags, call);\n+        return find(oid, _fc.newFetchState (), null, null, flags, call);\n     }\n \n     public Object find(Object oid, FetchState fetchState, BitSet exclude,\n         Object edata, int flags) {\n+    \tif (fetchState == null)\n+    \t\tfetchState = _fc.newFetchState ();\n         return find(oid, fetchState, exclude, edata, flags, null);\n     }\n \n@@ -717,8 +719,6 @@ protected Object find(Object oid, FetchState fetchState, BitSet exclude,\n         }\n \n         beginOperation(true);\n-        if (fetchState == null)\n-            fetchState = _fc.newFetchState();\n         try {\n             assertNontransactionalRead();\n \n@@ -842,18 +842,18 @@ protected StateManagerImpl initialize(StateManagerImpl sm, boolean load,\n         int flags = OID_COPY | OID_ALLOW_NEW | OID_NODELETED;\n         if (!validate)\n             flags |= OID_NOVALIDATE;\n-        return findAll(oids, null, null, null, flags, call);\n+        return findAll(oids, _fc, null, null, flags, call);\n     }\n \n-    public Object[] findAll(Collection oids, FetchState fetchState,\n+    public Object[] findAll(Collection oids, FetchConfiguration fetch,\n         BitSet exclude, Object edata, int flags) {\n-        return findAll(oids, fetchState, exclude, edata, flags, null);\n+        return findAll(oids, fetch, exclude, edata, flags, null);\n     }\n \n     /**\n      * Internal finder.\n      */\n-    protected Object[] findAll(Collection oids, FetchState fetchState,\n+    protected Object[] findAll(Collection oids, FetchConfiguration fetch,\n         BitSet exclude, Object edata, int flags, FindCallbacks call) {\n         // throw any exceptions for null oids up immediately\n         if (oids == null)\n@@ -867,9 +867,6 @@ protected StateManagerImpl initialize(StateManagerImpl sm, boolean load,\n         _loading = new HashMap((int) (oids.size() * 1.33 + 1));\n         if (call == null)\n             call = this;\n-        if (fetchState == null)\n-            fetchState = _fc.newFetchState();\n-        FetchConfiguration fetch = fetchState.getFetchConfiguration();\n         beginOperation(true);\n         try {\n             assertNontransactionalRead();\n@@ -915,7 +912,7 @@ protected StateManagerImpl initialize(StateManagerImpl sm, boolean load,\n                 PCState state = (transState) ? PCState.PCLEAN\n                     : PCState.PNONTRANS;\n                 Collection failed = _store.loadAll(load, state,\n-                    StoreManager.FORCE_LOAD_NONE, fetchState, edata);\n+                    StoreManager.FORCE_LOAD_NONE, _fc, edata);\n \n                 // set failed instances to null\n                 if (failed != null && !failed.isEmpty()) {\n@@ -937,8 +934,8 @@ protected StateManagerImpl initialize(StateManagerImpl sm, boolean load,\n                 sm = (StateManagerImpl) _loading.get(oid);\n                 if (sm != null && requiresLoad(sm, true, edata, flags)) {\n                     try {\n-                        sm.load(fetchState, StateManagerImpl.LOAD_FGS, exclude,\n-                            edata, false);\n+                        sm.load(fetch.newFetchState(), StateManagerImpl.LOAD_FGS, \n+                        \texclude, edata, false);\n                         if (active) {\n                             _lm.lock(sm, level, fetch.getLockTimeout(), edata);\n                             sm.readLocked(level, fetch.getWriteLockLevel());\n@@ -2687,7 +2684,7 @@ else if (sm.beforeRefresh(true)) {\n             // refresh all\n             if (load != null) {\n                 Collection failed = _store.loadAll(load, null,\n-                    _store.FORCE_LOAD_REFRESH, _fc.newFetchState(), null);\n+                    _store.FORCE_LOAD_REFRESH, _fc, null);\n                 if (failed != null && !failed.isEmpty())\n                     exceps = add(exceps, newObjectNotFoundException(failed));\n \n@@ -2812,8 +2809,7 @@ public void retrieveAll(Collection objs, boolean dfgOnly,\n             if (load != null) {\n                 int mode = (dfgOnly) ? _store.FORCE_LOAD_DFG\n                     : _store.FORCE_LOAD_ALL;\n-                failed = _store.loadAll(load, null, mode, _fc.newFetchState(),\n-                    null);\n+                failed = _store.loadAll(load, null, mode, _fc, null);\n                 if (failed != null && !failed.isEmpty())\n                     exceps = add(exceps, newObjectNotFoundException(failed));\n             }\n@@ -3196,7 +3192,7 @@ public void transactionalAll(Collection objs, boolean updateVersion,\n             Collection failed = null;\n             if (load != null) {\n                 failed = _store.loadAll(load, null, _store.FORCE_LOAD_NONE,\n-                    _fc.newFetchState(), null);\n+                    _fc, null);\n                 if (failed != null && !failed.isEmpty())\n                     exceps = add(exceps,\n                         newObjectNotFoundException(failed));\n@@ -4087,7 +4083,7 @@ public boolean isDetached(Object obj) {\n         Object oid = ApplicationIds.create(pc, meta);\n         if (oid == null)\n             return false;\n-        return find(oid, _fc.newFetchState(), EXCLUDE_ALL, null, 0) != null;\n+        return find(oid, null, EXCLUDE_ALL, null, 0) != null;\n     }\n \n     public OpenJPAStateManager getStateManager(Object obj) {"},{"sha":"7e04d5d58513afa17d60a453837c35a02192841a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -198,10 +198,10 @@ public Object find(Object oid, FetchState fetchState, BitSet exclude,\n         }\n     }\n \n-    public Object[] findAll(Collection oids, FetchState fetchState,\n+    public Object[] findAll(Collection oids, FetchConfiguration fetch,\n         BitSet exclude, Object edata, int flags) {\n         try {\n-            return _broker.findAll(oids, fetchState, exclude, edata, flags);\n+            return _broker.findAll(oids, fetch, exclude, edata, flags);\n         } catch (RuntimeException re) {\n             throw translate(re);\n         }"},{"sha":"b9c6ad7a6bd0041466a0877267d7eb5f3e17cefc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -229,9 +229,9 @@ public boolean hasFetchGroup(String group) {\n         }\n     }\n \n-    public boolean hasFetchGroup(Set groups) {\n+    public boolean hasAnyFetchGroup(Set groups) {\n         try {\n-            return _fetch.hasFetchGroup(groups);\n+            return _fetch.hasAnyFetchGroup(groups);\n         } catch (RuntimeException re) {\n             throw translate(re);\n         }"},{"sha":"43a672f26ae5b81663fcae76aaafe3e3185ad668","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -114,8 +114,8 @@ public boolean load(OpenJPAStateManager sm, BitSet fields,\n     }\n \n     public Collection loadAll(Collection sms, PCState state, int load,\n-        FetchState fetchState, Object context) {\n-        return _store.loadAll(sms, state, load, fetchState, context);\n+        FetchConfiguration fetch, Object context) {\n+        return _store.loadAll(sms, state, load, fetch, context);\n     }\n \n     public void beforeStateChange(OpenJPAStateManager sm, PCState fromState,"},{"sha":"0e71c66e4ac048ec06f3456eba28f7975b94dfb2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -223,7 +223,7 @@ private static void setFetchGroupFields(Broker broker,\n         FieldMetaData[] fmds = sm.getMetaData().getFields();\n         for (int i = 0; i < fmds.length; i++) {\n             if (fmds[i].isPrimaryKey() || fmds[i].isInDefaultFetchGroup()\n-                || fetch.hasFetchGroup(fmds[i].getFetchGroups())\n+                || fetch.hasAnyFetchGroup(fmds[i].getFetchGroups())\n                 || fetch.hasField(fmds[i].getFullName()))\n                 idxs.set(i);\n         }"},{"sha":"3a73d1e227f85aff6588f7fb2e6e80bf4c944b8f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -136,9 +136,10 @@ public Object attach(AttachManager manager, Object toAttach,\n                             load.set(i);\n                 }\n             }\n-\n-            sm.loadFields(load, null, broker.getFetchConfiguration().\n-                getWriteLockLevel(), null, true);\n+            FetchConfiguration fc = broker.getFetchConfiguration();\n+            FetchState fetchState = fc.newFetchState();\n+            sm.loadFields(load, fetchState, fc.getWriteLockLevel(), null, true);\n+                \n         }\n         sm.setVersion(_version);\n "},{"sha":"e925ae316478de5bd438e1ca40bba1639da311b8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -45,6 +45,7 @@\n     public static final String FETCH_GROUP_ALL =\n         \"org.apache.openjpa.kernel.FetchConfiguration.FETCH_GROUP_ALL\";\n \n+    public static final String FETCH_GROUP_DEFAULT = \"default\";\n     /**\n      * Return the context assiciated with this configuration;\n      * may be null if it has not been set or this object has been serialized.\n@@ -144,7 +145,7 @@\n      *\n      * @since 4.1\n      */\n-    public boolean hasFetchGroup(Set groups);\n+    public boolean hasAnyFetchGroup(Set groups);\n \n     /**\n      * Adds <code>group</code> to the set of fetch group names to"},{"sha":"03f4c1909a33a3571b5e2ae0a7c473d344a627bb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -108,6 +108,7 @@ protected FetchConfigurationImpl newInstance() {\n \n     public void copy(FetchConfiguration fetch) {\n         setFetchBatchSize(fetch.getFetchBatchSize());\n+        setMaxFetchDepth(fetch.getMaxFetchDepth());\n         setQueryCache(fetch.getQueryCache());\n         setFlushBeforeQueries(fetch.getFlushBeforeQueries());\n         setLockTimeout(fetch.getLockTimeout());\n@@ -172,11 +173,11 @@ public synchronized Set getFetchGroups() {\n \n     public synchronized boolean hasFetchGroup(String group) {\n         return _fetchGroups != null\n-            && ((group != null && _fetchGroups.contains(group))\n+            && (_fetchGroups.contains(group)\n             || _fetchGroups.contains(FETCH_GROUP_ALL));\n     }\n \n-    public synchronized boolean hasFetchGroup(Set groups) {\n+    public synchronized boolean hasAnyFetchGroup(Set groups) {\n         if (_fetchGroups != null && groups != null) {\n             Iterator iter = groups.iterator();\n             while (iter.hasNext()) {"},{"sha":"57a1c3c93fc3e02a1845d181fd9eb8b6b845a207","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchState.java","status":"modified","additions":135,"deletions":68,"changes":203,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchState.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchState.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -1,68 +1,135 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.openjpa.kernel;\n-\n-import org.apache.openjpa.meta.FieldMetaData;\n-\n-/**\n- * Defines the decision to include fields for selection or loading during\n- * a fetch operation.\n- *\n- * @author <A HREF=\"mailto:pinaki.poddar@gmail.com>Pinaki Poddar</A>\n- * @since 4.1\n- */\n-public interface FetchState {\n-\n-    /**\n-     * Returns the immutable fetch configuration this receiver is based on.\n-     */\n-    public FetchConfiguration getFetchConfiguration();\n-\n-    /**\n-     * Affirms if the given field requires to be selected in the context\n-     * of current fetch operation.\n-     * The response can be stateful as the same field argument would generate\n-     * different responses on different invocation based on the current\n-     * state of this receiver if changeState flag is true.\n-     *\n-     * @param fm field metadata. must not be null.\n-     * @param changeState true implies that the state of the receiver will\n-     * change due to invocation.\n-     */\n-    public boolean requiresSelect(FieldMetaData fm, boolean changeState);\n-\n-    /**\n-     * Affirms if the given field of the given instance requires to be loaded\n-     * in the context of current fetch operation.\n-     * The response is stateful as the same arguments would generate different\n-     * responses on different invocation based on the current state of this\n-     * receiver.\n-     *\n-     * @param sm state manager being populated\n-     * @param fm field metadata\n-     */\n-    public boolean requiresLoad(OpenJPAStateManager sm, FieldMetaData fm);\n-\n-    /**\n-     * Affirms if the given field is to be loaded as default. The field itself\n-     * is aware of whether it belongs to the default fetch group. This method\n-     * adds an extra constraint to verify that current configuration includes\n-     * default fetch group.\n-     *\n-     * @param fm field metadata\n-     */\n-    public boolean isDefault(FieldMetaData fm);\n-}\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.io.Serializable;\r\n+import java.util.List;\r\n+\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+\r\n+/**\r\n+ * Defines the decision to include fields for selection or loading during\r\n+ * a fetch operation.\r\n+ * A state is resulted by traversal of a relationship except the <em>root</em>\r\n+ * state. \r\n+ *\r\n+ * @author <A HREF=\"mailto:pinaki.poddar@gmail.com>Pinaki Poddar</A>\r\n+ * @since 4.1\r\n+ */\r\n+public interface FetchState \r\n+\textends Serializable, Cloneable {\r\n+    \r\n+\tpublic static final int INFINITE_DEPTH = -1;\r\n+\r\n+    /**\r\n+     * Returns the immutable fetch configuration this receiver is based on.\r\n+     */\r\n+    public FetchConfiguration getFetchConfiguration();\r\n+\r\n+    /**\r\n+     * Affirms if the given field requires to be fetched in the context\r\n+     * of current fetch operation.\r\n+     *\r\n+     * @param fm          field metadata. must not be null.\r\n+     */\r\n+    public boolean requiresFetch(FieldMetaData fm);\r\n+\r\n+    /**\r\n+     * Affirms if the given field of the given instance requires to be loaded\r\n+     * in the context of current fetch operation.\r\n+     *\r\n+     * @param sm state manager being populated\r\n+     * @param fm field metadata\r\n+     */\r\n+    public boolean requiresLoad(OpenJPAStateManager sm, FieldMetaData fm);\r\n+    \r\n+    /**\r\n+     * Traverse the given field to generate (possibly) a new state.\r\n+     * \r\n+     * @param fm\r\n+     * @return a new state resulting out of traversal. If the given field is\r\n+     * not a relation then return itself.\r\n+     */\r\n+    public FetchState traverse (FieldMetaData fm);\r\n+\r\n+    /**\r\n+     * Gets the available depth i.e. number of relations that can be traveresed\r\n+     * from this receiver. \r\n+     * \r\n+     * @return a positive integer with positive infinity designated as \r\n+     * <code>-1</code>.\r\n+     */\r\n+    public int getAvailableFetchDepth ();\r\n+    \r\n+    /**\r\n+     * Gets the root state where this receiver is derived from.\r\n+     * @return itself if the state is not derived from another state.\r\n+     * \r\n+     */\r\n+    public FetchState getRoot ();\r\n+    \r\n+    /**\r\n+     * Affirms if this receiver is the root state i.e. not derived as a result\r\n+     * of traversing a relationship.\r\n+     *  \r\n+     */\r\n+    public boolean isRoot ();\r\n+    \r\n+    /**\r\n+     * Gets the parent state.\r\n+     * @return can be null for the root state.\r\n+     */\r\n+    public FetchState getParent ();\r\n+    \r\n+    \r\n+    /** \r\n+     * Gets an ordered list of states from this receiver to its root.\r\n+     * \r\n+     * @return the order starts from this receiver and ends in the \r\n+     * root. An empty list if this receiver is the root. \r\n+     */ \r\n+    public List getPath ();\r\n+    \r\n+    /** \r\n+     * Gets an ordered list of relation fields from this receiver to its root.\r\n+     * These relations denote the path traversals from the root that resulted \r\n+     * in the current state.\r\n+     * \r\n+     * @return the list starts from relation traversal of which resulted in this\r\n+     * receiver and ends in the relation traversed from the root. \r\n+     * An empty list, if this receiver itself is the root. \r\n+     */ \r\n+    public List getRelationPath ();\r\n+    \r\n+    /**\r\n+     * Gets the number of times the given field is traversed to arrive\r\n+     * at this state.\r\n+     * \r\n+     * @param fm\r\n+     * @return\r\n+     */\r\n+    public int getCurrentRecursionDepth (FieldMetaData fm);\r\n+    \r\n+    /**\r\n+     * Gets the recursion depth of the given field. \r\n+     * \r\n+     * @param fm a relation field\r\n+     * @return If the field has multiple fetch groups in the current \r\n+     * configuration, then the recursion depth is maximum of all the recursion \r\n+     * depths.\r\n+     * The default recursion depth, if none is explictly specified, is 1.\r\n+     * The infinite i.e. unlimited recursion depth is designated as \r\n+     * <code>-1</code> \r\n+     */\r\n+    public int getRecursionDepth (FieldMetaData fm);\r\n+}\r"},{"sha":"3ac577761a8be2a16f2b7a4a0caf280e89549c39","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchStateImpl.java","status":"modified","additions":234,"deletions":205,"changes":439,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchStateImpl.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchStateImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchStateImpl.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -1,205 +1,234 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-/**\n- * \n- */\n-package org.apache.openjpa.kernel;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.meta.FetchGroup;\n-import org.apache.openjpa.meta.FieldMetaData;\n-import org.apache.openjpa.meta.JavaTypes;\n-\n-/**\n- * Holds dynamic status of fetch operation. Decides whether a field\n- * requires to be selected/loaded under present condition.\n- *\n- * @author <A HREF=\"mailto:pinaki.poddar@gmail.com>Pinaki Poddar</A>\n- * @nojavadoc\n- */\n-public class FetchStateImpl\n-    implements FetchState, Serializable {\n-\n-    private final FetchConfiguration _config;\n-\n-    private Map _selectTraversals;\n-    private Map _loadTraversals;\n-    private Map _recursionDepths;\n-    private Map _depths;\n-    private int _depth;\n-    private final Set _knownExcludes;\n-    private static final int INFINITE_DEPTH = -1;\n-\n-    /**\n-     * Supply configuration.\n-     *\n-     * @param fc must not be null.\n-     */\n-    public FetchStateImpl(FetchConfiguration fc) {\n-        super();\n-        _config = fc;\n-        _knownExcludes = new HashSet();\n-        _selectTraversals = new HashMap();\n-        _loadTraversals = new HashMap();\n-        _depths = new HashMap();\n-        _recursionDepths = new HashMap();\n-    }\n-\n-    public FetchConfiguration getFetchConfiguration() {\n-        return _config;\n-    }\n-\n-    public boolean isDefault(FieldMetaData fm) {\n-        return _config.hasFetchGroup(FetchGroup.getDefaultGroupName())\n-            && fm.isInDefaultFetchGroup();\n-    }\n-\n-    public boolean requiresSelect(FieldMetaData fm, boolean changeState) {\n-        if (_knownExcludes.contains(fm))\n-            return false;\n-        boolean selectable = isDefault(fm)\n-            || _config.hasFetchGroup(fm.getFetchGroups())\n-            || _config.hasField(fm.getFullName());\n-        if (!selectable)\n-            _knownExcludes.add(fm);\n-\n-        if (selectable && JavaTypes.maybePC(fm)) // relation field\n-        {\n-            if (canTraverse(fm)) {\n-                if (changeState)\n-                    traverse(fm);\n-            } else\n-                selectable = false;\n-        }\n-        return selectable;\n-    }\n-\n-    public boolean requiresLoad(OpenJPAStateManager sm, FieldMetaData fm) {\n-        boolean loadable = isDefault(fm)\n-            || _config.hasFetchGroup(fm.getFetchGroups())\n-            || _config.hasField(fm.getFullName());\n-        if (!loadable)\n-            _knownExcludes.add(fm);\n-        // relation field\n-        if (loadable && JavaTypes.maybePC(fm)) {\n-            int d = getLoadCount(fm);\n-            loadable = (d < (getTraversalCount(fm) - 1));\n-            if (loadable)\n-                _loadTraversals.put(fm, new Integer(d + 1));\n-        }\n-        return loadable;\n-    }\n-\n-    /**\n-     * Get the recusion depth for the given field.\n-     *\n-     * @param fm is the field to look for\n-     * @return 0 if the field does not appear in the given map.\n-     */\n-    protected int getRecursionDepth(FieldMetaData fm) {\n-        if (_recursionDepths.containsKey(fm)) {\n-            return ((Integer) _recursionDepths.get(fm)).intValue();\n-        }\n-        return initalizeRecusrionDepth(fm);\n-    }\n-\n-    /**\n-     * Sets the recursion depth for the given field as the maximum recusion\n-     * depth among the groups common to this field and configured fetch groups.\n-     *\n-     * @param fm\n-     * @return maximum recursion depth across common fetch groups. -1 is treated\n-     * as positive infinity.\n-     */\n-    protected int initalizeRecusrionDepth(FieldMetaData fm) {\n-        Set commonFGNs = new HashSet();\n-        commonFGNs.addAll(_config.getFetchGroups());\n-        commonFGNs.retainAll(fm.getFetchGroups());\n-\n-        int dMax = (commonFGNs.isEmpty()) ? FetchGroup.DEFAULT_RECURSION_DEPTH\n-            : 0;\n-        Iterator i = commonFGNs.iterator();\n-        while (i.hasNext()) {\n-            FetchGroup fg = fm.getDeclaringMetaData()\n-                .getFetchGroup(i.next().toString(), false);\n-            int d = fg.getDepthFor(fm);\n-            if (d == INFINITE_DEPTH) {\n-                dMax = INFINITE_DEPTH;\n-                break;\n-            }\n-            dMax = Math.max(d, dMax);\n-        }\n-        _recursionDepths.put(fm, new Integer(dMax));\n-\n-        return dMax;\n-    }\n-\n-    boolean canTraverse(FieldMetaData fm) {\n-        int maxDepth = _config.getMaxFetchDepth();\n-        if (maxDepth != INFINITE_DEPTH && _depth > maxDepth)\n-            return false;\n-        int sourceDepth = getDepth(fm.getDeclaringMetaData());\n-        int traversalCount = getTraversalCount(fm);\n-        int recursionDepth = getRecursionDepth(fm);\n-        int newtargetDepth = sourceDepth + traversalCount + 1;\n-        boolean isRecursive = fm.getDeclaringMetaData() ==\n-            fm.getDeclaredTypeMetaData();\n-        boolean traversable = (maxDepth == INFINITE_DEPTH)\n-            || (recursionDepth == INFINITE_DEPTH);\n-        if (isRecursive)\n-            traversable = traversable || (traversalCount < recursionDepth);\n-        else\n-            traversable = traversable || (newtargetDepth <= maxDepth);\n-\n-        return traversable;\n-    }\n-\n-    void traverse(FieldMetaData fm) {\n-        int sourceDepth = getDepth(fm.getDeclaringMetaData());\n-        int traversalCount = getTraversalCount(fm);\n-        boolean isRecursive = fm.getDeclaringMetaData() ==\n-            fm.getDeclaredTypeMetaData();\n-        if (!isRecursive) {\n-            int newDepth = sourceDepth + traversalCount;\n-            _depths.put(fm.getDeclaredTypeMetaData(), new Integer(newDepth));\n-            _depth = Math.max(_depth, newDepth);\n-        }\n-        _selectTraversals.put(fm, new Integer(traversalCount + 1));\n-    }\n-\n-    int getTraversalCount(FieldMetaData fm) {\n-        Integer n = (Integer) _selectTraversals.get(fm);\n-        return (n == null) ? 0 : n.intValue();\n-    }\n-\n-    int getLoadCount(FieldMetaData fm) {\n-        Integer n = (Integer) _loadTraversals.get(fm);\n-        return (n == null) ? 0 : n.intValue();\n-    }\n-\n-    int getDepth(ClassMetaData cm) {\n-        if (_depths.containsKey(cm))\n-            return ((Integer) _depths.get(cm)).intValue();\n-        return 0;\n-    }\n-}\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+/**\r\n+ * \r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.util.*;\r\n+\r\n+import org.apache.openjpa.enhance.StateManager;\r\n+import org.apache.openjpa.meta.FetchGroup;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.util.InternalException;\r\n+\r\n+/**\r\n+ * Holds dynamic status of fetch operation. Decides whether a field\r\n+ * requires to be selected/loaded under present condition.\r\n+ *\r\n+ * @author <A HREF=\"mailto:pinaki.poddar@gmail.com>Pinaki Poddar</A>\r\n+ * @nojavadoc\r\n+ */\r\n+public class FetchStateImpl implements FetchState {\r\n+\r\n+    private final FetchConfiguration _config;\r\n+    private FetchState         _parent;\r\n+    private FieldMetaData      _relation;\r\n+    private int                _availableDepth;\r\n+    \r\n+    /**\r\n+     * Supply configuration.\r\n+     *\r\n+     * @param fc must not be null.\r\n+     */\r\n+    public FetchStateImpl(FetchConfiguration fc) {\r\n+     \t_config = fc;\r\n+    \t_parent = null;\r\n+    \t_relation = null;\r\n+    \t_availableDepth  = _config.getMaxFetchDepth();\r\n+    }\r\n+\r\n+    public FetchConfiguration getFetchConfiguration() {\r\n+        return _config;\r\n+    }\r\n+\r\n+    public FetchState getParent () {\r\n+    \treturn _parent;\r\n+    }\r\n+    \r\n+    public boolean isRoot () {\r\n+    \treturn _parent == null;\r\n+    }\r\n+    \r\n+    public FetchState getRoot() {\r\n+    \treturn (isRoot()) ? this : getParent().getRoot();\r\n+    }\r\n+\r\n+    public int getAvailableFetchDepth() {\r\n+        return _availableDepth;\r\n+    }\r\n+\r\n+    public List getPath () {\r\n+    \tif (isRoot())\r\n+    \t\treturn Collections.EMPTY_LIST;\r\n+    \tList result = new ArrayList();\r\n+    \tresult.add (this);\r\n+    \treturn ((FetchStateImpl)_parent).trackPath (result);\r\n+    }\r\n+    \r\n+    private List trackPath (List path) {\r\n+    \tif (isRoot())\r\n+    \t\treturn path;\r\n+    \tpath.add(this);\r\n+    \treturn ((FetchStateImpl)_parent).trackPath(path);\r\n+    }\r\n+    \r\n+    public List getRelationPath () {\r\n+    \tif (isRoot())\r\n+    \t\treturn Collections.EMPTY_LIST;\r\n+    \tList result = new ArrayList();\r\n+    \tresult.add (_relation);\r\n+    \treturn ((FetchStateImpl)_parent).trackRelationPath (result);\r\n+    }\r\n+    \r\n+    private List trackRelationPath (List path) {\r\n+    \tif (isRoot())\r\n+    \t\treturn path;\r\n+    \tpath.add(_relation);\r\n+    \treturn ((FetchStateImpl)_parent).trackRelationPath(path);\r\n+    }\r\n+    \r\n+    \r\n+    public int getCurrentRecursionDepth (FieldMetaData fm) {\r\n+    \tif (isRoot())\r\n+    \t\treturn 0;\r\n+    \tint rd = (_relation == fm) ? 1 : 0;\r\n+    \t\r\n+    \treturn rd + _parent.getCurrentRecursionDepth(fm);\r\n+    }\r\n+    \r\n+    public boolean isDefault(FieldMetaData fm) {\r\n+        return (_config.hasFetchGroup(FetchConfiguration.FETCH_GROUP_DEFAULT) \r\n+        \t\t&& fm.isInDefaultFetchGroup())\r\n+        \t\t|| _config.hasFetchGroup(FetchConfiguration.FETCH_GROUP_ALL);\r\n+    }\r\n+\r\n+    public boolean requiresFetch(FieldMetaData fm) {\r\n+        boolean selectable = isDefault(fm)\r\n+            || _config.hasAnyFetchGroup(fm.getFetchGroups())\r\n+            || _config.hasField(fm.getFullName());\r\n+        if (selectable && isRelation(fm)) {\r\n+        \tint rd  = getRecursionDepth(fm);\r\n+        \tint crd = getCurrentRecursionDepth(fm);\r\n+        \tselectable = (_availableDepth==INFINITE_DEPTH || _availableDepth>0)\r\n+        \t\t&& ( rd == INFINITE_DEPTH || crd <rd);\r\n+        }\r\n+        return selectable;\r\n+    }\r\n+\r\n+    public boolean requiresLoad(OpenJPAStateManager sm, FieldMetaData fm) {\r\n+    \tif (sm!=null && sm.getLoaded().get(fm.getIndex()))\r\n+    \t\treturn false;\r\n+        boolean loadable = isDefault(fm)\r\n+            || _config.hasAnyFetchGroup(fm.getFetchGroups())\r\n+            || _config.hasField(fm.getFullName());\r\n+        if (loadable && isRelation(fm)) {\r\n+        \tint rd  = getRecursionDepth(fm);\r\n+        \tint crd = getCurrentRecursionDepth(fm);\r\n+            loadable = (_availableDepth==INFINITE_DEPTH || _availableDepth>0)\r\n+    \t\t\t&& (rd == INFINITE_DEPTH || crd<rd);\r\n+        }\r\n+        return loadable;\r\n+    }\r\n+    \r\n+\r\n+    /**\r\n+     * Sets the recursion depth for the given field as the maximum recusion\r\n+     * depth among the groups common to this field and configured fetch groups.\r\n+     *\r\n+     * @param fm\r\n+     * @return maximum recursion depth across common fetch groups. -1 is treated\r\n+     *         as positive infinity.\r\n+     */\r\n+    public int getRecursionDepth(FieldMetaData fm) {\r\n+        Set commonFGNs = new HashSet();\r\n+        commonFGNs.addAll(_config.getFetchGroups());\r\n+        commonFGNs.retainAll(fm.getFetchGroups());\r\n+        int dMax =\r\n+            (commonFGNs.isEmpty()) ? FetchGroup.DEFAULT_RECURSION_DEPTH : 0;\r\n+        Iterator i = commonFGNs.iterator();\r\n+        while (i.hasNext()) {\r\n+            FetchGroup fg = fm.getDeclaringMetaData()\r\n+                .getFetchGroup(i.next().toString());\r\n+            int d = fg.getDepthFor(fm);\r\n+            if (d == INFINITE_DEPTH) {\r\n+                dMax = INFINITE_DEPTH;\r\n+                break;\r\n+            }\r\n+            dMax = Math.max(d, dMax);\r\n+        }\r\n+    \tint maxDepth = _config.getMaxFetchDepth();\r\n+    \tif (maxDepth != INFINITE_DEPTH)\r\n+    \t\tif (dMax != INFINITE_DEPTH)\r\n+    \t\t   dMax = Math.min (maxDepth, dMax);\r\n+    \t\telse\r\n+    \t\t   dMax = maxDepth;\r\n+\r\n+        return dMax;\r\n+    }\r\n+\r\n+\r\n+    public FetchState traverse(FieldMetaData fm) {\r\n+    \tif (isRelation(fm)) {\r\n+    \t\ttry\r\n+\t\t\t{\r\n+\t\t\t\tFetchStateImpl clone = (FetchStateImpl)clone();\r\n+\t\t\t\tclone._parent   = this;\r\n+\t\t\t\tclone._relation = fm;\r\n+\t\t\t\tclone._availableDepth  = reduce(_availableDepth);\r\n+\t\t\t\treturn clone;\r\n+\t\t\t}\r\n+\t\t\tcatch (CloneNotSupportedException e)\r\n+\t\t\t{\r\n+\t\t\t\t// ignore\r\n+\t\t\t}\r\n+    \t}\r\n+    \treturn this;\r\n+    }\r\n+\r\n+\r\n+    int reduce (int d) {\r\n+    \tif (d==0)\r\n+    \t\treturn 0;//throw new InternalException(this.toString());\r\n+    \tif (d==INFINITE_DEPTH)\r\n+   \t\t\treturn INFINITE_DEPTH;\r\n+    \t\t\t\r\n+    \treturn d-1;\r\n+    }\r\n+    \r\n+    protected boolean isRelation (FieldMetaData fm) {\r\n+    \treturn fm != null && \r\n+    \t\t(fm.isDeclaredTypePC() \r\n+    \t\t|| (fm.getElement() != null && fm.getElement().isTypePC())\r\n+    \t\t|| (fm.getKey() != null && fm.getKey().isTypePC())\r\n+    \t\t|| (fm.getValue() != null && fm.getValue().isTypePC()));\r\n+    }\r\n+    \r\n+    public String toString () {\r\n+    \treturn System.identityHashCode(this) + \"(\"+_availableDepth+\"): \" \r\n+    \t    + printPath();\r\n+    }\r\n+    \r\n+    private String printPath ()\r\n+    {\r\n+    \tList path = getRelationPath();\r\n+    \tif (path.isEmpty())\r\n+    \t\treturn \"\";\r\n+    \tStringBuffer tmp = new StringBuffer();\r\n+    \tIterator i = path.iterator();\r\n+    \ttmp.append(((FieldMetaData)i.next()).getName());\r\n+    \tfor (;i.hasNext();)\r\n+    \t\ttmp.append(\".\").append(((FieldMetaData)i.next()).getName());\r\n+    \treturn tmp.toString();\r\n+    }\r\n+}\r"},{"sha":"20f0591a360f00406edf74b5fd41b7ca7c67d7d1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -102,8 +102,7 @@ private PCState beforeWrite(StateManagerImpl context, int field,\n             if (context.getDirty().length() > 0)\n                 context.saveFields(true);\n             context.clearFields();\n-            context.load(context.getBroker().getFetchConfiguration().\n-                newFetchState(), context.LOAD_FGS, null, null, true);\n+            context.load(null, context.LOAD_FGS, null, null, true);\n         }\n         return PDIRTY;\n     }"},{"sha":"c15023eb8b8a2dfebaa612c7b45345d7edce84de","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":19,"deletions":24,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -18,14 +18,7 @@\n import java.io.IOException;\n import java.io.ObjectOutput;\n import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.BitSet;\n-import java.util.Calendar;\n-import java.util.Comparator;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.TimeZone;\n+import java.util.*;\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n@@ -325,6 +318,8 @@ protected boolean load(FetchState fetchState, int loadMode,\n         if (!forWrite && (!isPersistent() || isNew() || isDeleted()))\n             return false;\n \n+        if (fetchState==null)\n+        \tfetchState = _broker.getFetchConfiguration().newFetchState();\n         // if any fields being loaded, do state transitions for read\n         BitSet fields = getUnloadedInternal(fetchState, loadMode, exclude);\n         boolean active = _broker.isActive();\n@@ -2760,9 +2755,9 @@ boolean loadFields(BitSet fields, FetchState fetchState, int lockLevel,\n \n     protected void loadField(int field, int lockLevel, boolean forWrite,\n         boolean fgs) {\n-        loadField(field, _broker.getFetchConfiguration().newFetchState(),\n-            lockLevel, forWrite, fgs);\n-    }\n+    \tFetchConfiguration fc = _broker.getFetchConfiguration();\n+        loadField(field, fc.newFetchState(),lockLevel, forWrite, fgs);\n+     }\n \n     /**\n      * Load the given field's fetch group; the field itself may already be\n@@ -2799,7 +2794,7 @@ protected void loadField(int field, FetchState fetchState, int lockLevel,\n         // call this method even if there are no unloaded fields; loadFields\n         // takes care of things like loading version info and setting PC\n         // flags\n-        loadFields(fields, null, lockLevel, null, forWrite);\n+        loadFields(fields, fetchState, lockLevel, null, forWrite);\n     }\n \n     /**\n@@ -2869,31 +2864,31 @@ private void postLoad(int field, FetchState fetchState) {\n \n         // is this field in the dfg?\n         FieldMetaData[] fmds = _meta.getDefaultFetchGroupFields();\n-        if (fmds.length > 0 && field != -1\n-            && !requiredByDefault(_meta.getField(field), fetchState))\n-            return;\n \n-        // see if the dfg is fully loaded\n+        // see if any fetch group with postLoad=true is fully loaded\n         boolean isLoaded = true;\n         for (int i = 0; isLoaded && i < fmds.length; i++)\n             if (!_loaded.get(fmds[i].getIndex())\n-                && requiredByDefault(fmds[i], fetchState))\n+                && requiresPostLoadCallabck(fmds[i], fetchState))\n                 isLoaded = false;\n         if (isLoaded) {\n             _flags |= FLAG_DFG;\n             fireLifecycleEvent(LifecycleEvent.AFTER_LOAD);\n         }\n     }\n \n-    private boolean requiredByDefault(FieldMetaData fm, FetchState fetchState) {\n+    private boolean requiresPostLoadCallabck(FieldMetaData fm, FetchState fetchState) {\n         if (fm == null)\n             return false;\n-        if (fetchState == null)\n-            return fm.isInDefaultFetchGroup()\n-                && _broker.getFetchConfiguration().hasFetchGroup\n-                (FetchGroup.getDefaultGroupName());\n-        else\n-            return fetchState.isDefault(fm);\n+        Set fetchGroups = fm.getFetchGroups();\n+        for (Iterator i = fetchGroups.iterator(); i.hasNext();) \n+        {\n+        \tString fg = i.next().toString();\n+        \tif (_broker.getFetchConfiguration().hasFetchGroup(fg)\n+        \t\t&& fm.getDeclaringMetaData().getFetchGroup(fg).isPostLoad())\n+        \t\treturn true;\n+        }\n+        return false;\n     }\n \n     /**"},{"sha":"86772af7f15c954b638768a0cf01841df034d07b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -143,7 +143,7 @@ public Object find(Object oid, FetchState fetchState, BitSet exclude,\n      *\n      * @see #find(Object,FetchState,BitSet,Object,int)\n      */\n-    public Object[] findAll(Collection oids, FetchState fetchState,\n+    public Object[] findAll(Collection oids, FetchConfiguration fetch,\n         BitSet exclude, Object edata, int flags);\n \n     /**"},{"sha":"c1e9f9609fae568e9b9a34d24a0d323d29e93f60","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -210,7 +210,7 @@ public boolean load(OpenJPAStateManager sm, BitSet fields,\n      * @see org.apache.openjpa.util.ImplHelper#loadAll\n      */\n     public Collection loadAll(Collection sms, PCState state, int load,\n-        FetchState fetchState, Object edata);\n+        FetchConfiguration fetch, Object edata);\n \n     /**\n      * Notification that the given state manager is about to change its"},{"sha":"fbbcd41abf52ecf761827daab091c5bdd5bdd1e5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -130,7 +130,7 @@ public Object attach(AttachManager manager, Object toAttach,\n                         break;\n                     case DETACH_FGS:\n                         if (fmds[i].isInDefaultFetchGroup()\n-                            || fetch.hasFetchGroup(fmds[i].getFetchGroups())\n+                            || fetch.hasAnyFetchGroup(fmds[i].getFetchGroups())\n                             || fetch.hasField(fmds[i].getFullName()))\n                             attachField(manager, toAttach, sm, fmds[i], true);\n                         break;"},{"sha":"35b09199ab15bf73b247105bedf9c8e4574bfc81","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","status":"modified","additions":9,"deletions":21,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -1922,44 +1922,32 @@ private void validateDetachable() {\n      * the same name.\n      */\n     public synchronized FetchGroup addFetchGroup(String name) {\n+    \tif (name == null || name.trim().length()==0)\n+    \t\tthrow new MetaDataException(_loc.get(\"empty-fg-name\", this));\n         FetchGroup fg = (FetchGroup) _fgs.get(name);\n         if (fg == null) {\n-            fg = newFetchGroup(name);\n-            _fgs.put(name, fg);\n+        \tfg = new FetchGroup(this, name);\n+        \t_fgs.put(name, fg);\n         }\n \n         return fg;\n     }\n \n     /**\n      * Gets a named fecth group. If not available in this receiver then looks\n-     * up the inheritence hierarchy. Creates if it does not exist and\n-     * <code>mustBe</code> is false.\n+     * up the inheritence hierarchy. \n      *\n      * @param name name of a fetch group.\n-     * @param mustBe if true then the named group must exist in this receiver\n-     * or any of its persistent super classes.\n-     * @return an existing or newly created fecth group of the given name.\n+     * @return an existing fecth group of the given name if known to this \n+     * receiver or any of its superclasses. Otherwise null.\n      */\n-    public synchronized FetchGroup getFetchGroup(String name, boolean mustBe) {\n+    public synchronized FetchGroup getFetchGroup(String name) {\n         FetchGroup fg = (FetchGroup) _fgs.get(name);\n         if (fg == null) {\n             ClassMetaData scm = getPCSuperclassMetaData();\n             if (scm != null)\n-                fg = scm.getFetchGroup(name, false);\n+                fg = scm.getFetchGroup(name);\n         }\n-\n-        if (fg == null)\n-            if (mustBe)\n-                return null;\n-            else\n-                fg = addFetchGroup(name);\n-\n-        return fg;\n-    }\n-\n-    protected FetchGroup newFetchGroup(String name) {\n-        FetchGroup fg = new FetchGroup(this, name);\n         return fg;\n     }\n "},{"sha":"c0a4fb31db634a7cebb2222c27e41a24b3a6d41c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","status":"modified","additions":173,"deletions":205,"changes":378,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -1,205 +1,173 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-/**\n- * \n- */\n-package org.apache.openjpa.meta;\n-\n-import java.io.File;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.apache.openjpa.lib.meta.SourceTracker;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.util.MetaDataException;\n-\n-/**\n- * Captures fetch group metadata.\n- */\n-public class FetchGroup\n-    implements SourceTracker {\n-\n-    private final String _name;\n-    private final ClassMetaData _declaringClass;\n-    private List _includes;\n-    private Map _depths;\n-\n-    public static final int DEFAULT_RECURSION_DEPTH = 1;\n-    private static String DEFAULT_GROUP_NAME = \"default\";\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (FetchGroup.class);\n-\n-    /**\n-     * Supply immutable name.\n-     *\n-     * @param name must not by null or empty.\n-     */\n-    FetchGroup(ClassMetaData cm, String name) {\n-        super();\n-\n-        if (cm == null)\n-            throw new MetaDataException(_loc.get(\"null-class-fg\", name));\n-        if (StringUtils.isEmpty(name))\n-            throw new MetaDataException(_loc.get(\"invalid-fg-name\", cm,\n-                name));\n-\n-        _name = name;\n-        _declaringClass = cm;\n-    }\n-\n-    public String getName() {\n-        return _name;\n-    }\n-\n-    /**\n-     * Includes given fetch group within this receiver.\n-     *\n-     * @param fg must not be null or this receiver itself or must not include\n-     * this receiver.\n-     */\n-    public void addInclude(FetchGroup fg) {\n-        if (fg == this)\n-            throw new MetaDataException(_loc.get(\"self-include-fg\", this));\n-        if (fg == null)\n-            throw new MetaDataException(_loc.get(\"null-include-fg\", this));\n-        if (fg.includes(this, true))\n-            throw new MetaDataException(_loc.get(\"cyclic-fg\", this, fg));\n-\n-        if (_includes == null)\n-            _includes = new ArrayList();\n-        _includes.add(fg);\n-    }\n-\n-    /**\n-     * Affirms if given fetch group is included by this receiver.\n-     *\n-     * @param fg\n-     * @param recurse if true then recursively checks within the included\n-     * fecth groups. Otherwise just checks within direct includes.\n-     */\n-    public boolean includes(FetchGroup fg, boolean recurse) {\n-        if (_includes == null)\n-            return false;\n-        if (_includes.contains(fg))\n-            return true;\n-\n-        if (recurse)\n-            for (Iterator i = _includes.iterator(); i.hasNext();)\n-                if (((FetchGroup) i.next()).includes(fg, true))\n-                    return true;\n-\n-        return false;\n-    }\n-\n-    /**\n-     * Sets recursion depth for a field.\n-     *\n-     * @param fm\n-     * @param depth\n-     */\n-    public void setDepthFor(FieldMetaData fm, int depth) {\n-        if (depth < -1)\n-            throw new MetaDataException(_loc.get(\"invalid-fetch-depth\",\n-                _name, fm, new Integer(depth)));\n-\n-        if (_depths == null)\n-            _depths = new HashMap();\n-\n-        _depths.put(fm, new Integer(depth));\n-    }\n-\n-    /**\n-     * Gets recusrion depth for the given field.\n-     *\n-     * @param fm\n-     * @return defaults to 1.\n-     */\n-    public int getDepthFor(FieldMetaData fm) {\n-        if (_depths == null || !_depths.containsKey(fm))\n-            return DEFAULT_RECURSION_DEPTH;\n-\n-        return ((Integer) _depths.get(fm)).intValue();\n-    }\n-\n-    /**\n-     * Set the name for default group.\n-     * It is expected to be set only once by a compliant implementation.\n-     * If multiple attempts are made to set the <em>default</em> group name,\n-     * then an attempt will succeed only for the first time or if the given\n-     * name matches with the current name.\n-     *\n-     * @param name of the default fetch group\n-     */\n-    public static void setDefaultGroupName(String name) {\n-        //###JDO2 -- better mechanics required to set default group name\n-        DEFAULT_GROUP_NAME = name;\n-    }\n-\n-    /**\n-     * Get the name in which <em>default</em> fetch group is known.\n-     *\n-     * @return name of the default group. Can be null, if not set.\n-     */\n-    public static final String getDefaultGroupName() {\n-        return DEFAULT_GROUP_NAME;\n-    }\n-\n-    /**\n-     * Affirms equality if the other has the same name.\n-     */\n-    public boolean equals(Object other) {\n-        if (other instanceof FetchGroup) {\n-            FetchGroup that = (FetchGroup) other;\n-            return _name.equals(that._name)\n-                && _declaringClass.equals(that._declaringClass);\n-        }\n-\n-        return false;\n-    }\n-\n-    public int hashCode() {\n-        return _name.hashCode() + _declaringClass.hashCode();\n-    }\n-\n-    public String toString() {\n-        return _name;\n-    }\n-\n-    /////////////////\n-    // SourceTracker\n-    /////////////////\n-\n-    public File getSourceFile() {\n-        return _declaringClass.getSourceFile();\n-    }\n-\n-    public Object getSourceScope() {\n-        return _declaringClass;\n-    }\n-\n-    public int getSourceType() {\n-        return _declaringClass.getSourceType();\n-    }\n-\n-    public String getResourceName() {\n-        return _declaringClass.getResourceName ();\n-\t}\n-}\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+/**\r\n+ * \r\n+ */\r\n+package org.apache.openjpa.meta;\r\n+\r\n+import java.io.File;\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.apache.openjpa.lib.meta.SourceTracker;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Captures fetch group metadata.\r\n+ */\r\n+public class FetchGroup implements SourceTracker {\r\n+\r\n+    private final String _name;\r\n+    private final ClassMetaData _declaringClass;\r\n+    private List _includes;\r\n+    private Map  _depths;\r\n+    private boolean _postLoad;\r\n+    public static final int DEFAULT_RECURSION_DEPTH = 1;\r\n+    private static final Localizer _loc =\r\n+        Localizer.forPackage(FetchGroup.class);\r\n+\r\n+    /**\r\n+     * Supply immutable name.\r\n+     *\r\n+     * @param must not by null or empty.\r\n+     */\r\n+    FetchGroup(ClassMetaData cm, String name) {\r\n+        super();\r\n+        if (StringUtils.isEmpty(name))\r\n+            throw new UserException(_loc.get(\"invalid-fg-name\", cm, name));\r\n+        _name = name;\r\n+        _declaringClass = cm;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return _name;\r\n+    }\r\n+\r\n+    /**\r\n+     * Includes given fetch group within this receiver.\r\n+     *\r\n+     * @param fg must not be null or this receiver itself or must not include\r\n+     *           this receiver.\r\n+     */\r\n+    public void addInclude(FetchGroup fg) {\r\n+        if (fg == this)\r\n+            throw new UserException(_loc.get(\"self-include-fg\", this));\r\n+        if (fg == null)\r\n+            throw new UserException(_loc.get(\"null-include-fg\", this));\r\n+        if (fg.includes(this, true))\r\n+            throw new UserException(_loc.get(\"cyclic-fg\", this, fg));\r\n+        if (_includes == null)\r\n+            _includes = new ArrayList();\r\n+        _includes.add(fg);\r\n+    }\r\n+\r\n+    /**\r\n+     * Affirms if given fetch group is included by this receiver.\r\n+     *\r\n+     * @param fg\r\n+     * @param recurse if true then recursively checks within the included\r\n+     *                fecth groups. Otherwise just checks within direct includes.\r\n+     * @return\r\n+     */\r\n+    public boolean includes(FetchGroup fg, boolean recurse) {\r\n+        if (_includes == null)\r\n+            return false;\r\n+        if (_includes.contains(fg))\r\n+            return true;\r\n+        if (recurse)\r\n+            for (Iterator i = _includes.iterator(); i.hasNext();)\r\n+                if (((FetchGroup) i.next()).includes(fg, true))\r\n+                    return true;\r\n+        return false;\r\n+    }\r\n+\r\n+    /**\r\n+     * Sets recursion depth for a field.\r\n+     *\r\n+     * @param fm\r\n+     * @param depth\r\n+     */\r\n+    public void setDepthFor(FieldMetaData fm, int depth) {\r\n+        if (depth < -1)\r\n+            throw new UserException(_loc.get(\"invalid-fetch-depth\",\r\n+                _name, fm, new Integer(depth)));\r\n+        if (_depths == null)\r\n+            _depths = new HashMap();\r\n+        _depths.put(fm, new Integer(depth));\r\n+    }\r\n+\r\n+    /**\r\n+     * Gets recusrion depth for the given field.\r\n+     *\r\n+     * @param fm\r\n+     * @return defaults to 1.\r\n+     */\r\n+    public int getDepthFor(FieldMetaData fm) {\r\n+        if (_depths == null || !_depths.containsKey(fm))\r\n+            return DEFAULT_RECURSION_DEPTH;\r\n+        return ((Integer) _depths.get(fm)).intValue();\r\n+    }\r\n+\r\n+    \r\n+    public boolean isPostLoad () {\r\n+    \treturn _postLoad;\r\n+    }\r\n+\r\n+    public void setPostLoad (boolean flag) {\r\n+    \t_postLoad = flag;\r\n+    }\r\n+    \r\n+    /**\r\n+     * Affirms equality if the other has the same name.\r\n+     */\r\n+    public boolean equals(Object other) {\r\n+        if (other instanceof FetchGroup) {\r\n+            FetchGroup that = (FetchGroup) other;\r\n+            return _name.equals(that._name)\r\n+                && _declaringClass.equals(that._declaringClass);\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return _name.hashCode() + _declaringClass.hashCode();\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return _name;\r\n+    }\r\n+\r\n+    /////////////////\r\n+    // SourceTracker\r\n+    /////////////////\r\n+    public File getSourceFile() {\r\n+        return _declaringClass.getSourceFile();\r\n+    }\r\n+\r\n+    public Object getSourceScope() {\r\n+        return _declaringClass;\r\n+    }\r\n+\r\n+    public int getSourceType() {\r\n+        return _declaringClass.getSourceType();\r\n+    }\r\n+\r\n+    public String getResourceName() {\r\n+        return _declaringClass.getResourceName();\r\n+    }\r\n+}\r"},{"sha":"f3e58e962dd69d7f02bbd7b1cf9b5f1326d703fc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -39,6 +39,7 @@\n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.StoreContext;\n import org.apache.openjpa.lib.conf.Configurations;\n@@ -849,21 +850,21 @@ public Set getFetchGroups() {\n      */\n     public void addFetchGroup(String fg) {\n         if (StringUtils.isEmpty(fg))\n-            return;\n-        if (getDeclaringMetaData().getFetchGroup(fg, false) == null)\n+            throw new MetaDataException(_loc.get(\"bad-fg\", fg));\n+        if (getDeclaringMetaData().getFetchGroup(fg) == null)\n             throw new MetaDataException(_loc.get(\"unknown-fg\", fg));\n         if (_fgs == null)\n             _fgs = new HashSet();\n         _fgs.add(fg);\n-        if (fg.equals(FetchGroup.getDefaultGroupName()))\n+        if (fg.equals(FetchConfiguration.FETCH_GROUP_DEFAULT))\n             setInDefaultFetchGroup(true);\n     }\n \n     public void removeFetchGroup(String fg) {\n         if (_fgs == null)\n             return;\n         _fgs.remove(fg);\n-        if (fg != null && fg.equals(FetchGroup.getDefaultGroupName()))\n+        if (FetchConfiguration.FETCH_GROUP_DEFAULT.equals(fg))\n             setInDefaultFetchGroup(false);\n     }\n "},{"sha":"e9e46162cda1c63db63be5e66d02d160e0b2b0ab","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","raw_url":"https://github.com/apache/openjpa/raw/884ff1b86393b49d0d88fc95a7b80511dd9cb7c3/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java?ref=884ff1b86393b49d0d88fc95a7b80511dd9cb7c3","patch":"@@ -23,6 +23,7 @@\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n import org.apache.openjpa.kernel.FetchState;\n import org.apache.openjpa.kernel.LockManager;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n@@ -90,18 +91,18 @@ public static Method getSetter(Class cls, String prop) {\n      * @since 4.0\n      */\n     public static Collection loadAll(Collection sms, StoreManager store,\n-        PCState state, int load, FetchState fetchState, Object context) {\n+        PCState state, int load, FetchConfiguration fetch, Object context) {\n         Collection failed = null;\n         OpenJPAStateManager sm;\n         LockManager lm;\n         for (Iterator itr = sms.iterator(); itr.hasNext();) {\n             sm = (OpenJPAStateManager) itr.next();\n+            FetchState fetchState = fetch.newFetchState();\n             if (sm.getManagedInstance() == null) {\n                 if (!store.initialize(sm, state, fetchState, context))\n                     failed = addFailedId(sm, failed);\n             } else if (load != StoreManager.FORCE_LOAD_NONE\n                 || sm.getPCState() == PCState.HOLLOW) {\n-\n                 lm = sm.getContext().getLockManager();\n                 if (!store.load(sm, sm.getUnloaded(fetchState),\n                     fetchState, lm.getLockLevel(sm), context))"}]}

