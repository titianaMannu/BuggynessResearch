{"sha":"8987041469573f6fe9ae4a3e760081c6ec80b712","node_id":"MDY6Q29tbWl0MjA2MzY0Ojg5ODcwNDE0Njk1NzNmNmZlOWFlNGEzZTc2MDA4MWM2ZWM4MGI3MTI=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-03-25T03:55:39Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-03-25T03:55:39Z"},"message":"OPENJPA-1550:\nSet failedObject on RollbackException.\nSubmitted By: Heath Thomann\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/2.0.x@927266 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4009d1a07a9833f478cd737d3a8c438b3eca4360","url":"https://api.github.com/repos/apache/openjpa/git/trees/4009d1a07a9833f478cd737d3a8c438b3eca4360"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/8987041469573f6fe9ae4a3e760081c6ec80b712","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/8987041469573f6fe9ae4a3e760081c6ec80b712","html_url":"https://github.com/apache/openjpa/commit/8987041469573f6fe9ae4a3e760081c6ec80b712","comments_url":"https://api.github.com/repos/apache/openjpa/commits/8987041469573f6fe9ae4a3e760081c6ec80b712/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"4b45c156aa732df5c2b4eea57743dea0dcf697d9","url":"https://api.github.com/repos/apache/openjpa/commits/4b45c156aa732df5c2b4eea57743dea0dcf697d9","html_url":"https://github.com/apache/openjpa/commit/4b45c156aa732df5c2b4eea57743dea0dcf697d9"}],"stats":{"total":524,"additions":487,"deletions":37},"files":[{"sha":"1ae57aee0dcba2f69f51a1fc49e90256bc439628","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java","status":"modified","additions":9,"deletions":11,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java?ref=8987041469573f6fe9ae4a3e760081c6ec80b712","patch":"@@ -192,12 +192,11 @@ protected void flushBatch() throws SQLException {\n                 //similar to this path, or I should say, the path which is taken instead of this path when\n                 //we aren't using batching), we see that the catch block doesn't do a 'se.getNextException'.\n                 //When we do a 'getNextException', the 'next exception' doesn't contain the same message as se.\n-                //That is, 'next exception' contains a subset msg which is contained in se.  For legacy, should\n-                //we continute to use 'sqex' in the 'old path' and use 'se' in the next path/code?????\n-                //SQLException sqex = se.getNextException();\n-                //if (sqex == null)\n-                //    sqex = se;\n-                SQLException sqex = se;\n+                //That is, 'next exception' contains a subset msg which is contained in se.\n+                SQLException sqex = se.getNextException();\n+                if (sqex == null){\n+                    sqex = se;\n+                }\n                 \n                 if (se instanceof ReportingSQLException){\n                   int index = ((ReportingSQLException) se).getIndexOfFirstFailedObject();\n@@ -209,24 +208,23 @@ protected void flushBatch() throws SQLException {\n                       index = 0;\n                   }\n                   \n-                  //index should not be less than 0 this path, but if for some reason it is, lets\n+                  //index should not be less than 0 in this path, but if for some reason it is, lets\n                   //resort to the 'old way' and simply pass the 'ps' as the failed object.\n                   if (index < 0){ \n-                      throw SQLExceptions.getStore(sqex, ps, _dict);\n+                      throw SQLExceptions.getStore(se, ps, _dict);\n                   }\n                   else{\n-                      throw SQLExceptions.getStore(sqex, ((RowImpl)(_batchedRows.get(index))).getFailedObject(), _dict);\n+                      throw SQLExceptions.getStore(se, ((RowImpl)(_batchedRows.get(index))).getFailedObject(), _dict);\n                   }                    \n                 }\n                 else{\n+                \t//per comments above, use 'sqex' rather than 'se'. \n                     throw SQLExceptions.getStore(sqex, ps, _dict);\n                 }\n             } finally {\n                 _batchedSql = null;\n                 batchedRows.clear();\n                 if (ps != null) {\n-                    //Clear the Params now....should this be done above? No. \n-                    //if JDBC provider using PureQuery, ps is null\n                     ps.clearParameters();\n                     try {\n                         ps.close();"},{"sha":"d6cebf5d7cd6961a32b03cbdf3e65e93b2c1d8e5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=8987041469573f6fe9ae4a3e760081c6ec80b712","patch":"@@ -2276,8 +2276,14 @@ private OpenJPAException newFlushException(Collection<Exception> exceps) {\n         }\n         if (opt)\n             return new OptimisticException(t);\n+        \n+        Object failedObject = null;\n+        if (t[0] instanceof OpenJPAException){\n+        \tfailedObject = ((OpenJPAException)t[0]).getFailedObject();\n+        }\n+        \n         return new StoreException(_loc.get(\"rolled-back\")).\n-            setNestedThrowables(t).setFatal(true);\n+            setNestedThrowables(t).setFatal(true).setFailedObject(failedObject);\n     }\n \n     /**"},{"sha":"78f179a37f475cf5c5e425b35bb99be7cb4cd080","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","status":"modified","additions":53,"deletions":22,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java?ref=8987041469573f6fe9ae4a3e760081c6ec80b712","patch":"@@ -242,7 +242,7 @@ private SQLException wrap(SQLException sqle, Statement stmnt, String sql) {\n     }\n \n     private SQLException wrap(SQLException sqle, Statement stmnt, int indexOfFailedBatchObject) {\n-        return wrap(sqle, stmnt, null, -1);\n+        return wrap(sqle, stmnt, null, indexOfFailedBatchObject);\n     }\n \n     /**\n@@ -1114,7 +1114,7 @@ public int executeUpdate() throws SQLException {\n                     // we are tracking parameters, then set the current\n                     // parameter set to be the index of the failed\n                     // statement so that the ReportingSQLException will\n-                    // show the correct param\n+                    // show the correct param(s)\n                     if (se instanceof BatchUpdateException\n                         && _paramBatch != null && shouldTrackParameters()) {\n                         int[] count = ((BatchUpdateException) se).\n@@ -1161,7 +1161,6 @@ public int executeUpdate() throws SQLException {\n                     throw err;\n                 } finally {\n                     logTime(start);\n-                    clearLogParameters(true);\n                     handleSQLErrors(LoggingPreparedStatement.this, err);\n                 }\n             }\n@@ -1409,16 +1408,12 @@ protected void appendInfo(StringBuffer buf) {\n             }\n \n             private void clearLogParameters(boolean batch) {\n-                //Made !batch...we only want to clear if\n-                //we are NOT using batching.  If we clear now,\n-                //the _params will not be displayed in the resultant\n-                //exception message.  But when should we 'clear' them???\n-                if (!batch){                    \n-                    if (_params != null)\n-                        _params.clear();\n-                    \n-                    if (_paramBatch != null)\n-                        _paramBatch.clear();                \n+                if (_params != null) {\n+                    _params.clear();\n+                }\n+\n+                if (batch && _paramBatch != null) {\n+                    _paramBatch.clear();\n                 }\n             }\n \n@@ -1605,6 +1600,9 @@ public boolean previous() throws SQLException {\n             private final String _sql;\n             private List<String> _params = null;\n             private List<List<String>> _paramBatch = null;\n+            //When batching is used, this variable contains the index into the last\n+            //successfully executed batched statement.\n+            int batchedRowsBaseIndex = 0;            \n \n             public LoggingCallableStatement(CallableStatement stmt, String sql) \n                 throws SQLException {\n@@ -1709,11 +1707,29 @@ public int executeUpdate() throws SQLException {\n             }\n \n             public int[] executeBatch() throws SQLException {\n+                int indexOfFirstFailedObject = -1;\n+\n                 logBatchSQL(this);\n                 long start = System.currentTimeMillis();\n                 SQLException err = null;                \n                 try {\n-                    return super.executeBatch();\n+                    int[] toReturn = super.executeBatch();\n+                    //executeBatch is called any time the number of batched statements\n+                    //is equal to, or less than, batchLimit.  In the 'catch' block below, \n+                    //the logic seeks to find an index based on the current executeBatch \n+                    //results.  This is fine when executeBatch is only called once, but \n+                    //if executeBatch is called many times, the _paramsBatch will continue \n+                    //to grow, as such, to index into _paramsBatch, we need to take into \n+                    //account the number of times executeBatch is called in order to \n+                    //correctly index into _paramsBatch.  To that end, each time executeBatch \n+                    //is called, lets get the size of _paramBatch.  This will effectively \n+                    //tell us the index of the last successfully executed batch statement.  \n+                    //If an exception is caused, then we know that _paramBatch.size was \n+                    //the index of the LAST row to successfully execute.\n+                    if (_paramBatch != null){\n+                        batchedRowsBaseIndex = _paramBatch.size();                        \n+                    }\n+                    return toReturn; \n                 } catch (SQLException se) {\n                     // if the exception is a BatchUpdateException, and\n                     // we are tracking parameters, then set the current\n@@ -1726,32 +1742,47 @@ public int executeUpdate() throws SQLException {\n                             getUpdateCounts();\n                         if (count != null && count.length <= _paramBatch.size())\n                         {\n-                            int index = -1;\n                             for (int i = 0; i < count.length; i++) {\n                                 // -3 is Statement.STATEMENT_FAILED, but is\n                                 // only available in JDK 1.4+\n                                 if (count[i] == Statement.EXECUTE_FAILED) {\n-                                    index = i;\n+                                    indexOfFirstFailedObject = i;\n                                     break;\n                                 }\n                             }\n \n                             // no -3 element: it may be that the server stopped\n                             // processing, so the size of the count will be\n                             // the index\n-                            if (index == -1)\n-                                index = count.length + 1;\n+                            //See the Javadoc for 'getUpdateCounts'; a provider \n+                            //may stop processing when the first failure occurs, \n+                            //as such, it may only return 'UpdateCounts' for the \n+                            //first few which pass.  As such, the failed \n+                            //index is 'count.length', NOT count.length+1.  That\n+                            //is, if the provider ONLY returns the first few that \n+                            //passes (i.e. say an array of [1,1] is returned) then\n+                            //length is 2, and since _paramBatch starts at 0, we \n+                            //don't want to use length+1 as that will give us the \n+                            //wrong index.\n+                            if (indexOfFirstFailedObject == -1){\n+                                indexOfFirstFailedObject = count.length;\n+                            }\n+                            \n+                            //Finally, whatever the index is at this point, add batchedRowsBaseIndex\n+                            //to it to get the final index.  Recall, we need to start our index from the\n+                            //last batch which successfully executed.\n+                            indexOfFirstFailedObject += batchedRowsBaseIndex;\n \n                             // set the current params to the saved values\n-                            if (index < _paramBatch.size())\n-                                _params = (List<String>) _paramBatch.get(index);\n+                            if (indexOfFirstFailedObject < _paramBatch.size()){\n+                                _params = (List<String>) _paramBatch.get(indexOfFirstFailedObject);\n+                            }\n                         }\n                     }\n-                    err = wrap(se, LoggingCallableStatement.this);\n+                    err = wrap(se, LoggingCallableStatement.this, indexOfFirstFailedObject);\n                     throw err;\n                 } finally {\n                     logTime(start);\n-                    clearLogParameters(true);\n                     handleSQLErrors(LoggingCallableStatement.this, err);\n                 }\n             }"},{"sha":"2635ff2752dcdf20553a3e9a13718c51952e50cc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/batch/exception/Ent1.java","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/batch/exception/Ent1.java","raw_url":"https://github.com/apache/openjpa/raw/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/batch/exception/Ent1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/batch/exception/Ent1.java?ref=8987041469573f6fe9ae4a3e760081c6ec80b712","patch":"@@ -0,0 +1,73 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.batch.exception;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class Ent1 {\n+    // primary key:\n+    @Id\n+    private int pk;    \n+    public int getPk() {return pk;}\n+    public void setPk(int pk) {this.pk = pk;}\n+    \n+    private String name;\n+    public String getName(){return name;}\n+    public void setName(String str){\n+        name = str;\n+    }\n+    \n+    public Ent1() {}    \n+    public Ent1(int pk, String str) {this.pk = pk;name=str;}     \n+    \n+    public String toString(){\n+        return \"Ent1 [pk = \" + pk + \", \" + name +\"]\";\n+    }\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + ((name == null) ? 0 : name.hashCode());\n+        result = prime * result + pk;\n+        return result;\n+    }\n+    \n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (getClass() != obj.getClass())\n+            return false;\n+        Ent1 other = (Ent1) obj;\n+        if (name == null) {\n+            if (other.name != null)\n+                return false;\n+        } else if (!name.equals(other.name))\n+            return false;\n+        if (pk != other.pk)\n+            return false;\n+        return true;\n+    }\n+}\n+\n+"},{"sha":"7665469b896aa615521846833dabb36e63bf016a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/batch/exception/TestBatchLimitException.java","status":"added","additions":324,"deletions":0,"changes":324,"blob_url":"https://github.com/apache/openjpa/blob/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/batch/exception/TestBatchLimitException.java","raw_url":"https://github.com/apache/openjpa/raw/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/batch/exception/TestBatchLimitException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/batch/exception/TestBatchLimitException.java?ref=8987041469573f6fe9ae4a3e760081c6ec80b712","patch":"@@ -0,0 +1,324 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.batch.exception;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+\n+import org.apache.openjpa.persistence.test.PersistenceTestCase;\n+import org.apache.openjpa.util.ExceptionInfo;\n+\n+//This test was created for OPENJPA-1550.  In this issue the user was\n+//not able to get the 'failed object' (the object causing the failure) when\n+//batch limit was -1 or a value greater than 1.  Also, they found that the\n+//'params' listed in the prepared statement were missing.  This test will set\n+//various batch limits and verify that with the fix to 1550, the correct\n+//'failed object' and prepared statement is returned. \n+public class TestBatchLimitException extends PersistenceTestCase {\n+\n+    static Ent1 expectedFailedObject;\n+    final String expectedFailureMsg =\n+        \"INSERT INTO Ent1 (pk, name) VALUES (?, ?) [params=(int) 200, (String) twohundred]\";\n+\n+    public EntityManagerFactory newEmf(String batchLimit) {\n+        EntityManagerFactory emf =\n+            createEMF(Ent1.class, \n+                \"openjpa.jdbc.SynchronizeMappings\", \n+                \"buildSchema(ForeignKeys=true)\",\n+                \"openjpa.jdbc.DBDictionary\", batchLimit, \n+                CLEAR_TABLES);\n+\n+        assertNotNull(\"Unable to create EntityManagerFactory\", emf);\n+        return emf;\n+    }\n+\n+    public void setUp() {\n+        expectedFailedObject = null;\n+    }\n+\n+    // Test that we get the correct 'failed object' when we have a batchLimt\n+    // of X and Y rows, where X>Y. A duplicate row will be inserted\n+    // sometime within the Y rows. This will verify that we get the right\n+    // 'failed object' and message.\n+    public void testExceptionInFirstBatch() throws Throwable {\n+        EntityManagerFactory emf = newEmf(\"batchLimit=-1\");\n+        EntityManager em = emf.createEntityManager();\n+\n+        em.getTransaction().begin();\n+        em.persist(new Ent1(1, \"one\"));\n+        expectedFailedObject = new Ent1(200, \"twohundred\");\n+        em.persist(expectedFailedObject);\n+        em.persist(new Ent1(5, \"five\"));\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        EntityManager em2 = emf.createEntityManager();\n+\n+        em2.getTransaction().begin();\n+        em2.persist(new Ent1(0, \"zero\"));\n+        em2.persist(new Ent1(2, \"two\"));\n+        em2.persist(new Ent1(200, \"twohundred\"));\n+        em2.persist(new Ent1(3, \"three\"));\n+        em2.persist(new Ent1(1, \"one\"));\n+        em2.persist(new Ent1(5, \"five\"));\n+        \n+        try {\n+            em2.getTransaction().commit();\n+        } catch (Throwable excp) {\n+            verifyExDetails(excp);\n+        }\n+        finally {\n+            if (em2.getTransaction().isActive()) {\n+                em2.getTransaction().rollback();\n+            }\n+            em2.close();\n+            emf.close();\n+        }\n+    }\n+\n+    // Test that we get the correct 'failed object' when there is only one\n+    // row in the batch. The 'batching' logic executes a different\n+    // statement when only one row is to be updated/inserted.\n+    public void testExceptionSingleBatchedRow() throws Throwable {\n+        EntityManagerFactory emf = newEmf(\"batchLimit=-1\");\n+        EntityManager em = emf.createEntityManager();\n+\n+        em.getTransaction().begin();\n+        expectedFailedObject = new Ent1(200, \"twohundred\");\n+        em.persist(expectedFailedObject);\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        EntityManager em2 = emf.createEntityManager();\n+\n+        em2.getTransaction().begin();\n+        em2.persist(new Ent1(200, \"twohundred\"));\n+        \n+        try {\n+            em2.getTransaction().commit();\n+        } catch (Throwable excp) {\n+            verifyExDetails(excp);\n+        }\n+        finally {\n+            if (em2.getTransaction().isActive()) {\n+                em2.getTransaction().rollback();\n+            }\n+            em2.close();\n+            emf.close();\n+        }\n+    }\n+\n+    // Test that we get the correct 'failed object' and message when we\n+    // have a batchLimt of X and Y rows, where Y>X. In this case, the\n+    // batch is executed every time the batchLimt is hit. A duplicate\n+    // row will be inserted sometime after X (X+1, i.e right at the\n+    // boundary of the batch) to verify that we get the right\n+    // 'failed object' and msg no matter which batch a duplicate is\n+    // contained in. This test is important because as part of the\n+    // fix to OPENJPA-1510 we had to add extra logic to keep track\n+    // of which batch the 'failed object' was in, along with the\n+    // index into that batch.\n+    public void testExceptionInSecondBatch() throws Throwable {\n+        EntityManagerFactory emf = newEmf(\"batchLimit=9\");\n+        EntityManager em = emf.createEntityManager();\n+\n+        em.getTransaction().begin();\n+        expectedFailedObject = new Ent1(200, \"twohundred\");\n+        em.persist(expectedFailedObject);\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        EntityManager em2 = emf.createEntityManager();\n+\n+        em2.getTransaction().begin();\n+\n+        // Put 9 objects/rows into the batch\n+        for (int i = 0; i < 9; i++) {\n+            em2.persist(new Ent1(i, \"name\" + i));\n+        }\n+\n+        // Put the duplicate object/row as the first element in the second batch.\n+        em2.persist(new Ent1(200, \"twohundred\"));\n+        \n+        try {\n+            em2.getTransaction().commit();\n+        } catch (Throwable excp) {\n+            verifyExDetails(excp);\n+        }\n+        finally {\n+            if (em2.getTransaction().isActive()) {\n+                em2.getTransaction().rollback();\n+            }\n+            em2.close();\n+            emf.close();\n+        }\n+    }\n+\n+    // Same as testRowsGreaterThanBatchLimit_boundaryCase, but the object to cause the failure\n+    // is in the middle of the second batch. testExceptioninSecondBatch puts\n+    // the failing object as the first element in the second batch, this test puts\n+    // it somewhere in the middle of the third batch. Again, we want to make sure our\n+    // indexing into the batch containing the 'failed object' is correct.\n+    public void testExceptionInThirdBatch() throws Throwable {\n+        EntityManagerFactory emf = newEmf(\"batchLimit=9\");\n+        EntityManager em = emf.createEntityManager();\n+\n+        em.getTransaction().begin();\n+        expectedFailedObject = new Ent1(200, \"twohundred\");\n+        em.persist(expectedFailedObject);\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        EntityManager em2 = emf.createEntityManager();\n+\n+        em2.getTransaction().begin();\n+\n+        // Persist 21 objects/rows....as such we will have two 'full'\n+        // batches (9*2=18) and 3 (21-18=3) objects/rows in the 3rd batch.\n+        for (int i = 0; i < 22; i++) {\n+            em2.persist(new Ent1(i, \"name\" + i));\n+        }\n+\n+        // Put the duplicate row in the 3rd batch.\n+        em2.persist(new Ent1(200, \"twohundred\"));\n+\n+        // Put a few more objects into the batch.\n+        for (int i = 22; i < 40; i++) {\n+            em2.persist(new Ent1(i, \"name\" + i));\n+        }\n+\n+        try {\n+            em2.getTransaction().commit();\n+        } catch (Throwable excp) {\n+            verifyExDetails(excp);\n+        }\n+        finally {\n+            if (em2.getTransaction().isActive()) {\n+                em2.getTransaction().rollback();\n+            }\n+            em2.close();\n+            emf.close();\n+        }\n+    }\n+\n+    // Similar to the previous two tests, but lets run the test with a large\n+    // batch with a failure, and then commit, then run large batches\n+    // again with failures again.....just want to make sure things are not in\n+    // some way 're-used' between the two commits as far as the indexes go.\n+    public void testSecondExceptionHasRightIndex() throws Throwable {\n+        testExceptionInThirdBatch();\n+\n+        EntityManagerFactory emf = newEmf(\"batchLimit=9\");\n+        EntityManager em = emf.createEntityManager();\n+\n+        em.getTransaction().begin();\n+\n+        for (int i = 40; i < 55; i++) {\n+            em.persist(new Ent1(i, \"name\" + i));\n+        }\n+\n+        em.persist(new Ent1(200, \"twohundred\"));\n+\n+        for (int i = 55; i < 65; i++) {\n+            em.persist(new Ent1(i, \"name\" + i));\n+        }\n+\n+        try {\n+            em.getTransaction().commit();\n+        } catch (Throwable excp) {\n+            verifyExDetails(excp);\n+        }\n+        finally {\n+            if (em.getTransaction().isActive()) {\n+                em.getTransaction().rollback();\n+            }\n+            em.close();\n+            emf.close();\n+        }\n+    }\n+\n+    public void testExceptionWithMultipleCommits() throws Throwable {\n+        EntityManagerFactory emf = newEmf(\"batchLimit=-1\");\n+        EntityManager em = emf.createEntityManager();\n+\n+        em.getTransaction().begin();\n+        em.persist(new Ent1(1, \"one\"));\n+        expectedFailedObject = new Ent1(200, \"twohundred\");\n+        em.persist(expectedFailedObject);\n+        em.persist(new Ent1(5, \"five\"));\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        EntityManager em2 = emf.createEntityManager();\n+        em2.getTransaction().begin();\n+        em2.persist(new Ent1(0, \"zero\"));\n+        em2.persist(new Ent1(2, \"two\"));\n+        em2.persist(new Ent1(3, \"three\"));\n+        em2.getTransaction().commit();\n+\n+        em2.getTransaction().begin();\n+        em2.persist(new Ent1(6, \"six\"));\n+        em2.persist(new Ent1(200, \"twohundred\"));\n+        em2.persist(new Ent1(7, \"seven\"));\n+        \n+        try {\n+            em2.getTransaction().commit();\n+        } catch (Throwable excp) {\n+            verifyExDetails(excp);\n+        }\n+        finally {\n+            if (em2.getTransaction().isActive()) {\n+                em2.getTransaction().rollback();\n+            }\n+            em2.close();\n+            emf.close();\n+        }\n+    }\n+\n+    // Verify that the resultant exception contains the correct 'failed object'\n+    // and exception message.\n+    public void verifyExDetails(Throwable excp) throws Throwable {\n+        // The exception should contain the 'failed object'\n+        verifyFailedObject(excp);\n+        // The second cause should contain the message which shows the failing prepared statement.\n+        Throwable cause = excp.getCause().getCause();\n+        verifyExMsg(cause.getMessage());\n+    }\n+\n+    public void verifyFailedObject(Throwable excp) throws Throwable {\n+        if (excp instanceof ExceptionInfo) {\n+            ExceptionInfo e = (ExceptionInfo) excp;\n+\n+            Ent1 failedObject = (Ent1) e.getFailedObject();\n+\n+            assertNotNull(\"Failed object was null.\", failedObject);\n+            assertEquals(expectedFailedObject, failedObject);\n+        }\n+        else {\n+            throw excp;\n+        }\n+    }\n+\n+    public void verifyExMsg(String msg) {\n+        assertNotNull(\"Exception message was null.\", msg);\n+        assertTrue(\"Did not see expected text in message. Expected <\" + expectedFailureMsg + \"> but was \" + msg, msg\n+            .contains(expectedFailureMsg));\n+    }\n+}\n+"},{"sha":"844d42184350fd85ed2e1d0c47187e74e627a03a","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","status":"modified","additions":10,"deletions":2,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java?ref=8987041469573f6fe9ae4a3e760081c6ec80b712","patch":"@@ -81,6 +81,7 @@\n import org.apache.openjpa.persistence.criteria.OpenJPACriteriaBuilder;\n import org.apache.openjpa.persistence.criteria.OpenJPACriteriaQuery;\n import org.apache.openjpa.persistence.validation.ValidationUtils;\n+import org.apache.openjpa.util.ExceptionInfo;\n import org.apache.openjpa.util.Exceptions;\n import org.apache.openjpa.util.ImplHelper;\n import org.apache.openjpa.util.RuntimeExceptionTranslator;\n@@ -569,8 +570,15 @@ public void commit() {\n             // normal exception translator, since the spec says they\n             // should be thrown whenever the commit fails for any reason at\n             // all, wheras the exception translator handles exceptions that\n-            // are caused for specific reasons\n-            throw new RollbackException(e);\n+            // are caused for specific reasons            \n+\n+            // pass along the failed object if one is available.\n+            Object failedObject = null;\n+            if (e instanceof ExceptionInfo){\n+            \tfailedObject = ((ExceptionInfo)e).getFailedObject();            \t\n+            }\n+            \n+            throw new RollbackException(e).setFailedObject(failedObject);\n         }\n     }\n "},{"sha":"6593e98ec60f26837e388b2a1758e278622b088e","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RollbackException.java","status":"modified","additions":8,"deletions":1,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RollbackException.java","raw_url":"https://github.com/apache/openjpa/raw/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RollbackException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RollbackException.java?ref=8987041469573f6fe9ae4a3e760081c6ec80b712","patch":"@@ -38,6 +38,8 @@\n public class RollbackException\n     extends javax.persistence.RollbackException\n     implements Serializable, ExceptionInfo {\n+\t\n+    private transient Object _failed = null;\n \n     private transient Throwable[] _nested;\n \n@@ -67,7 +69,12 @@ public Throwable getCause() {\n     }\n \n     public Object getFailedObject() {\n-        return null;\n+        return _failed;\n+    }\n+\n+    public RollbackException setFailedObject(Object failed) {\n+        _failed = failed;\n+        return this;\n     }\n \n     public String toString() {"},{"sha":"db23c35e1c9cbf3d5e17589a1e9a9042b9a0fa54","filename":"openjpa-project/CHANGES.txt","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-project/CHANGES.txt","raw_url":"https://github.com/apache/openjpa/raw/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-project/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/CHANGES.txt?ref=8987041469573f6fe9ae4a3e760081c6ec80b712","patch":"@@ -201,6 +201,7 @@ Bug\n     * [OPENJPA-1544] - Remove WebSphere version number from org/apache/ee/localizer.properties\n     * [OPENJPA-1546] - OpenJPA doesn't work as internal JPA inside web applicaion in JBoss AS\n     * [OPENJPA-1547] - NOT IN with MEMBER OF returns syntax error\n+    * [OPENJPA-1550] - When batchLimit=-1 or >1 and an exception is caused, the params and failedObject are missing from the resultant exception.\n     * [OPENJPA-1556] - Exception thrown on first use of @Strategy in @Embeddable classes\n     * [OPENJPA-1558] - Many side of a MxO relationship contains null reference if One side is loaded first.\n     * [OPENJPA-1562] - EntityManager:Refresh on Removed entity does not trigger IllegalArgumentException"},{"sha":"341e8bdd98b6d61a888a0b49643e961619067c74","filename":"openjpa-project/RELEASE-NOTES.html","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-project/RELEASE-NOTES.html","raw_url":"https://github.com/apache/openjpa/raw/8987041469573f6fe9ae4a3e760081c6ec80b712/openjpa-project/RELEASE-NOTES.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/RELEASE-NOTES.html?ref=8987041469573f6fe9ae4a3e760081c6ec80b712","patch":"@@ -296,6 +296,8 @@ <h4>Bug</h4>\n </li>\n <li>[<a href='https://issues.apache.org/jira/browse/OPENJPA-1547'>OPENJPA-1547</a>] -         NOT IN with MEMBER OF returns syntax error\n </li>\n+<li>[<a href='https://issues.apache.org/jira/browse/OPENJPA-1550'>OPENJPA-1550</a>] -         When batchLimit=-1 or >1 and an exception is caused, the params and failedObject are missing from the resultant exception.\n+</li>\n <li>[<a href='https://issues.apache.org/jira/browse/OPENJPA-1556'>OPENJPA-1556</a>] -         Exception thrown on first use of @Strategy in @Embeddable classes\n </li>\n <li>[<a href='https://issues.apache.org/jira/browse/OPENJPA-1558'>OPENJPA-1558</a>] -         Many side of a MxO relationship contains null reference if One side is loaded first."}]}

