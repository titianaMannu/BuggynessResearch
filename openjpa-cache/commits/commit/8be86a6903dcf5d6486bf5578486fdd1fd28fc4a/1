{"sha":"8be86a6903dcf5d6486bf5578486fdd1fd28fc4a","node_id":"MDY6Q29tbWl0MjA2MzY0OjhiZTg2YTY5MDNkY2Y1ZDY0ODZiZjU1Nzg0ODZmZGQxZmQyOGZjNGE=","commit":{"author":{"name":"Will Dazey","email":"dazeydev@apache.org","date":"2018-05-14T22:25:05Z"},"committer":{"name":"Will Dazey","email":"dazeydev@apache.org","date":"2018-05-14T22:25:05Z"},"message":"OPENJPA-2646: Sporadic NullPointerException and ClassCastException caused by query cache misses in multithreaded environments.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@1831596 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"024e5964a28e5651859ee65a967b38394c17b0fa","url":"https://api.github.com/repos/apache/openjpa/git/trees/024e5964a28e5651859ee65a967b38394c17b0fa"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/8be86a6903dcf5d6486bf5578486fdd1fd28fc4a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/8be86a6903dcf5d6486bf5578486fdd1fd28fc4a","html_url":"https://github.com/apache/openjpa/commit/8be86a6903dcf5d6486bf5578486fdd1fd28fc4a","comments_url":"https://api.github.com/repos/apache/openjpa/commits/8be86a6903dcf5d6486bf5578486fdd1fd28fc4a/comments","author":null,"committer":null,"parents":[{"sha":"4d577c0fd27d1fb0e37fdb44a7f355c010768a20","url":"https://api.github.com/repos/apache/openjpa/commits/4d577c0fd27d1fb0e37fdb44a7f355c010768a20","html_url":"https://github.com/apache/openjpa/commit/4d577c0fd27d1fb0e37fdb44a7f355c010768a20"}],"stats":{"total":198,"additions":145,"deletions":53},"files":[{"sha":"fe1ec2a738f9ca336e79e9570e085d1e3b78eeb3","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedQueryCacheImpl.java","status":"modified","additions":9,"deletions":1,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/8be86a6903dcf5d6486bf5578486fdd1fd28fc4a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedQueryCacheImpl.java","raw_url":"https://github.com/apache/openjpa/raw/8be86a6903dcf5d6486bf5578486fdd1fd28fc4a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedQueryCacheImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedQueryCacheImpl.java?ref=8be86a6903dcf5d6486bf5578486fdd1fd28fc4a","patch":"@@ -362,7 +362,15 @@ public void setEnableStatistics(boolean enable){\n     public boolean getEnableStatistics(){\n         return _statsEnabled;\n     }\n-        \n+\n+    public void setMaxCacheSize(int size) {\n+        ((CacheMap)_delegate).setCacheSize(size);\n+    }\n+\n+    public int getCacheSize() {\n+        return _delegate.size();\n+    }\n+\n \t//-------------------------------------------------------\n \t// Configurable contract\n \t//-------------------------------------------------------"},{"sha":"8385914e72d5de6dbc92751c096cd4745b7f0a48","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","status":"modified","additions":19,"deletions":19,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/8be86a6903dcf5d6486bf5578486fdd1fd28fc4a/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","raw_url":"https://github.com/apache/openjpa/raw/8be86a6903dcf5d6486bf5578486fdd1fd28fc4a/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java?ref=8be86a6903dcf5d6486bf5578486fdd1fd28fc4a","patch":"@@ -35,7 +35,8 @@\n import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n \n-import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n /**\n  * Fixed-size map that has ability to pin/unpin entries and move overflow to\n@@ -65,8 +66,9 @@\n     // number of pinned values (not including keys not mapped to values)\n     private int _pinnedSize = 0;\n \n-    private final ReentrantLock _writeLock = new ReentrantLock();\n-    private final ReentrantLock _readLock;\n+    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(true);\n+    private final Lock _readLock = rwl.readLock();\n+    private final Lock _writeLock = rwl.writeLock();\n \n     /**\n      * Create a non-LRU (and therefore highly concurrent) cache map with a\n@@ -128,14 +130,12 @@ public void overflowRemoved(Object key, Object value) {\n                     cacheMapOverflowRemoved(key, value);\n                 }\n             };\n-            _readLock = null;\n         } else {\n             cacheMap = new LRUMap(size, load) {\n                 public void overflowRemoved(Object key, Object value) {\n                     cacheMapOverflowRemoved(key, value);\n                 }\n             };\n-            _readLock = _writeLock;\n         }\n         if (max < 0)\n             max = Integer.MAX_VALUE;\n@@ -186,16 +186,14 @@ protected Object remove(Map map, Object key) {\n      * Acquire read lock.\n      */\n     public void readLock() {\n-        if (_readLock != null)\n-            _readLock.lock();\n+        _readLock.lock();\n     }\n \n     /**\n      * Release read lock.\n      */\n     public void readUnlock() {\n-        if (_readLock != null)\n-            _readLock.unlock();\n+        _readLock.unlock();\n     }\n \n     /**\n@@ -216,7 +214,7 @@ public void writeUnlock() {\n      * Whether this cache map uses LRU eviction.\n      */\n     public boolean isLRU() {\n-        return _readLock != null;\n+        return cacheMap instanceof LRUMap;\n     }\n \n     /**\n@@ -348,24 +346,26 @@ protected void entryAdded(Object key, Object value) {\n     }\n \n     public Object get(Object key) {\n+        boolean putcache = false;\n+        Object val = null;\n         readLock();\n         try {\n-            // Check the main map first\n-            Object  val = cacheMap.get(key);\n+            val = softMap.get(key);\n             if (val == null) {\n-                // if we find the key in the soft map, move it back into\n-                // the primary map\n-                val = softMap.get(key);\n-                if (val != null){\n-                    put(key, val);\n-                }else{\n+                val = cacheMap.get(key);\n+                if (val == null) {\n                     val = pinnedMap.get(key);\n+                } else {\n+                    putcache = true;\n                 }\n             }\n-           \n             return val;\n         } finally {\n             readUnlock();\n+            //cannot obtain a write lock while holding a read lock\n+            //doing it this way prevents a deadlock\n+            if (putcache)\n+                put(key, val);\n         }\n     }\n "},{"sha":"64f73717b0bad82e1f1d8d2b4ef1532597a0a11f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/sqlcache/TestMultithreadedReparameterization.java","status":"modified","additions":112,"deletions":29,"changes":141,"blob_url":"https://github.com/apache/openjpa/blob/8be86a6903dcf5d6486bf5578486fdd1fd28fc4a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/sqlcache/TestMultithreadedReparameterization.java","raw_url":"https://github.com/apache/openjpa/raw/8be86a6903dcf5d6486bf5578486fdd1fd28fc4a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/sqlcache/TestMultithreadedReparameterization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/sqlcache/TestMultithreadedReparameterization.java?ref=8be86a6903dcf5d6486bf5578486fdd1fd28fc4a","patch":"@@ -19,10 +19,13 @@\n \n package org.apache.openjpa.persistence.jdbc.sqlcache;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Properties;\n \n import javax.persistence.EntityManager;\n+import javax.persistence.Query;\n import javax.persistence.TypedQuery;\n \n import junit.framework.TestCase;\n@@ -41,19 +44,19 @@\n     private static String RESOURCE = \"META-INF/persistence.xml\"; \n     private static String UNIT_NAME = \"PreparedQuery\";\n     protected static OpenJPAEntityManagerFactory emf;\n-    \n+\n     public void setUp() throws Exception {\n         super.setUp();\n         if (emf == null) {\n             Properties config = new Properties();\n             config.put(\"openjpa.jdbc.SynchronizeMappings\", \"buildSchema(ForeignKeys=true,SchemaAction='drop,add')\");\n             config.put(\"openjpa.Log\", \"SQL=WARN\");\n-            config.put(\"openjpa.jdbc.QuerySQLCache\", \"true(EnableStatistics=true)\");\n+            config.put(\"openjpa.jdbc.QuerySQLCache\", \"true(EnableStatistics=true, MaxCacheSize=2)\");\n             config.put(\"openjpa.ConnectionFactoryProperties\", \"PrintParameters=true\");\n             emf = OpenJPAPersistence.createEntityManagerFactory(UNIT_NAME, RESOURCE, config);\n         }\n     }\n-    \n+\n     public void testReparameterizationUnderHeavyLoad() throws Exception {\n         long baseId = System.currentTimeMillis();\n         EntityManager em = emf.createEntityManager();\n@@ -68,14 +71,16 @@ public void testReparameterizationUnderHeavyLoad() throws Exception {\n             em.persist(p);\n         }\n         em.getTransaction().commit();\n-    \n+\n         String jpql = \"select p from Person p \" \n                     + \"where p.id=:id and p.firstName=:first and p.lastName=:last and p.age=:age\";\n         int nRepeats = 20;\n         Thread[] threads = new Thread[nThreads];\n+        final List<Throwable> exceptions = Collections.synchronizedList(new ArrayList<Throwable>());\n+\n         for (int i = 0; i < nThreads; i++) {\n             Object[] args = {\"id\", baseId+i, \"first\", \"First\"+i, \"last\", \"Last\"+i, \"age\", (short)(20+i)};\n-            QueryThread thread = new QueryThread(emf.createEntityManager(), jpql, args, nRepeats);\n+            QueryThread thread = new QueryThread(emf.createEntityManager(), jpql, args, nRepeats, exceptions);\n             threads[i] = new Thread(thread);\n         }\n         for (Thread thread : threads) {\n@@ -84,12 +89,90 @@ public void testReparameterizationUnderHeavyLoad() throws Exception {\n         for (Thread thread : threads) {\n             thread.join();\n         }\n-        QueryStatistics<String> stats = emf.getConfiguration().getQuerySQLCacheInstance().getStatistics();\n-        assertEquals(nThreads*nRepeats,stats.getExecutionCount(), stats.getExecutionCount(jpql));\n-        assertEquals(nThreads*nRepeats-1,stats.getExecutionCount(), stats.getHitCount(jpql));\n-        \n+        try {\n+            QueryStatistics<String> stats = emf.getConfiguration().getQuerySQLCacheInstance().getStatistics();\n+            for(Throwable t : exceptions) {\n+                fail((t.getCause() != null ? t.getCause().toString() : t.toString()));\n+            }\n+            assertEquals(nThreads*nRepeats,stats.getExecutionCount(), stats.getExecutionCount(jpql));\n+            assertEquals(nThreads*nRepeats-1,stats.getExecutionCount(), stats.getHitCount(jpql));\n+        } finally {\n+            //clear statistics for other tests\n+            emf.getConfiguration().getQuerySQLCacheInstance().clear();\n+        }\n+    }\n+\n+    /**\n+     *  This is a test to verify that the PreparedQueryCache correctly swaps queries between\n+     *  the hard and the soft cache maps. It is important for this test that the max cache size\n+     *  is set to a number much smaller than the default (1000) to force swapping between hard\n+     *  and soft maps. During this swapping interval, it is possible that another thread will\n+     *  attempt to read from the maps and cause either NPE or CCE. \n+     *  \n+     * @see OPENJPA-2646\n+     * @throws Exception\n+     */\n+    public void testCacheSwappingUnderHeavyLoad() throws Exception {\n+        final int nRuns = 10;\n+        final int nThreads = 20;\n+        //This value needs to be more than the max cache size to reliably cause cache\n+        //overflow to start swapping between hard -> soft cache\n+        // (\"openjpa.jdbc.QuerySQLCache\", \"true(MaxCacheSize=2\")\n+        final int nQueries = 10;\n+\n+        final List<Throwable> exceptions = Collections.synchronizedList(new ArrayList<Throwable>());\n+\n+        for (int y = 0; y < nRuns; y++) {\n+            Thread[] threads = new Thread[nThreads];\n+            for (int i = 0; i < nThreads; i++) {\n+                threads[i] = new Thread(new Runnable() {\n+                    @Override public void run() {\n+                        try {\n+                            EntityManager em = emf.createEntityManager();\n+                            // Since the cache (CacheMap) is set to a size of '2' all threads will \n+                            // fill up the cache and constantly cause query strings to move \n+                            // to/from the main cache and soft cache, eventually causing a \n+                            // \"cache miss\" by a thread.\n+                            String qStr = \"select p from Person p where p.firstName=:first and p.id = \";\n+                            for (int j = 0; j < nQueries; j++) {\n+                                Query q = em.createQuery(qStr + j);\n+                                q.setParameter(\"first\", \"test\");\n+                                q.getResultList();\n+                            }\n+                            em.close();\n+                        } catch (Throwable t) {\n+                            System.err.println(\"\\nThread (\" + Thread.currentThread().getName()\n+                                    + \"): Caught the following exception: \" + t\n+                                    + \"\\n  With cause: \" + t.getCause());\n+                            //catch the AssertionError so that we can fail the main Thread\n+                            exceptions.add(t);\n+                        }\n+                    }\n+                });\n+                threads[i].start();\n+            }\n+\n+            for (Thread thread : threads) {\n+                synchronized (thread) {\n+                    try {\n+                        thread.join();\n+                    } catch (InterruptedException e) {\n+                        e.printStackTrace();\n+                    }\n+                }\n+            }\n+\n+            try {\n+                for(Throwable t : exceptions) {\n+                    fail((t.getCause() != null ? t.getCause().toString() : t.toString()));\n+                }\n+            } finally {\n+                //clear statistics for other tests\n+                emf.getConfiguration().getQuerySQLCacheInstance().clear();\n+            }\n+        }\n     }\n-    \n+\n     /**\n      * Each thread executes same query with same parameters repeatedly.\n      * \n@@ -101,34 +184,34 @@ public void testReparameterizationUnderHeavyLoad() throws Exception {\n         public final String jpql;\n         public final Object[] args;\n         public final int nTimes;\n-        public QueryThread(EntityManager em, String jpql, Object[] args, int r) {\n+        public final List<Throwable> exceptions;\n+        public QueryThread(EntityManager em, String jpql, Object[] args, int r, List<Throwable> exceptions) {\n             this.em = em;\n             this.jpql = jpql;\n             this.args = args;\n             this.nTimes = r;\n+            this.exceptions = exceptions;\n         }\n-        \n+\n         public void run()  {\n             try {\n-            for (int i = 0; i < nTimes; i++) {\n-                TypedQuery<Person> q = em.createQuery(jpql, Person.class);\n-                for (int j = 0; j < args.length; j += 2) {\n-                    q.setParameter(args[j].toString(), args[j+1]);\n+                for (int i = 0; i < nTimes; i++) {\n+                    TypedQuery<Person> q = em.createQuery(jpql, Person.class);\n+                    for (int j = 0; j < args.length; j += 2) {\n+                        q.setParameter(args[j].toString(), args[j+1]);\n+                    }\n+                    List<Person> result = q.getResultList();\n+                    assertEquals(Thread.currentThread() + \" failed\", 1, result.size());\n+                    Person p = result.get(0);\n+                    assertEquals(args[1], p.getId());\n+                    assertEquals(args[3], p.getFirstName());\n+                    assertEquals(args[5], p.getLastName());\n+                    assertEquals(args[7], p.getAge());\n                 }\n-                List<Person> result = q.getResultList();\n-                assertEquals(Thread.currentThread() + \" failed\", 1, result.size());\n-                Person p = result.get(0);\n-                assertEquals(args[1], p.getId());\n-                assertEquals(args[3], p.getFirstName());\n-                assertEquals(args[5], p.getLastName());\n-                assertEquals(args[7], p.getAge());\n-                \n-            }\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-                fail();\n+            } catch (Throwable t) {\n+                //catch the AssertionError so that we can fail the main Thread\n+                exceptions.add(t);\n             }\n         }\n-        \n     }\n }"},{"sha":"8eaab807f68797fd7e3dfb151d00a3b5ff04f398","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/8be86a6903dcf5d6486bf5578486fdd1fd28fc4a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/8be86a6903dcf5d6486bf5578486fdd1fd28fc4a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java?ref=8be86a6903dcf5d6486bf5578486fdd1fd28fc4a","patch":"@@ -521,7 +521,7 @@ public boolean equals(Object other) {\n      * cache. \n      */\n     private boolean preExecute(Map params) {\n-    \t\n+\n         PreparedQueryCache cache = _em.getPreparedQueryCache();\n         if (cache == null) {\n             return false;\n@@ -533,20 +533,21 @@ private boolean preExecute(Map params) {\n             }\n             return false;\n         }\n-        \n+\n         // Determine if the query has NULL parameters.  If so, then do not use a PreparedQuery from the cache\n         for (Object val : params.values()) {\n             if (val == null) {\n                 ignorePreparedQuery();\n                 return false;\n             }\n         }\n-        \n+\n         Boolean registered = cache.register(_id, _query, fetch);\n         boolean alreadyCached = (registered == null);\n         String lang = _query.getLanguage();\n         QueryStatistics<String> stats = cache.getStatistics();\n         if (alreadyCached && LANG_PREPARED_SQL.equals(lang)) {\n+            //This value is expected to be non-null as it was just registered\n             PreparedQuery pq = _em.getPreparedQuery(_id);\n             if (pq.isInitialized()) {\n                 try {\n@@ -567,7 +568,7 @@ private boolean preExecute(Map params) {\n         }\n         return registered == Boolean.TRUE;\n     }\n-    \n+\n     /**\n      * Initialize the registered Prepared Query from the given opaque object.\n      * "}]}

