{"sha":"8c8636fce98d7907c444bc9f7dc2c94321163d68","node_id":"MDY6Q29tbWl0MjA2MzY0OjhjODYzNmZjZTk4ZDc5MDdjNDQ0YmM5ZjdkYzJjOTQzMjExNjNkNjg=","commit":{"author":{"name":"Albert Lee","email":"allee8285@apache.org","date":"2009-10-30T04:09:05Z"},"committer":{"name":"Albert Lee","email":"allee8285@apache.org","date":"2009-10-30T04:09:05Z"},"message":"OPENJPA-1306 - Add basic extended lock scope support, 3 junit testing basic, secondary table, join table, inheritance entity, element collections (lazy/eager), 1x1 (lazy/eager) and 1xm (lazy/eager).\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@831194 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0980c47c78c08a849ac10b666484400b705eb3d5","url":"https://api.github.com/repos/apache/openjpa/git/trees/0980c47c78c08a849ac10b666484400b705eb3d5"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/8c8636fce98d7907c444bc9f7dc2c94321163d68","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/8c8636fce98d7907c444bc9f7dc2c94321163d68","html_url":"https://github.com/apache/openjpa/commit/8c8636fce98d7907c444bc9f7dc2c94321163d68","comments_url":"https://api.github.com/repos/apache/openjpa/commits/8c8636fce98d7907c444bc9f7dc2c94321163d68/comments","author":null,"committer":null,"parents":[{"sha":"d0cf5b404e7ee3c2990d58071fb7a4da152969c3","url":"https://api.github.com/repos/apache/openjpa/commits/d0cf5b404e7ee3c2990d58071fb7a4da152969c3","html_url":"https://github.com/apache/openjpa/commit/d0cf5b404e7ee3c2990d58071fb7a4da152969c3"}],"stats":{"total":5693,"additions":5675,"deletions":18},"files":[{"sha":"f14de8f9c12e08c7589c5f7afe7c9da8e0838636","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","status":"modified","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -401,6 +401,23 @@ public FetchConfiguration setQueryTimeout(int timeout) {\n         }\n     }\n \n+    public int getLockScope() {\n+        try {\n+            return _fetch.getLockScope();\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n+    public FetchConfiguration setLockScope(int scope) {\n+        try {\n+            _fetch.setLockScope(scope);\n+            return this;\n+        } catch (RuntimeException re) {\n+            throw translate(re);\n+        }\n+    }\n+\n     public int getReadLockLevel() {\n         try {\n             return _fetch.getReadLockLevel();"},{"sha":"0d732207dec1b71ca4bc6111777e63a93176838c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","status":"modified","additions":16,"deletions":2,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -36,7 +36,7 @@\n  * @author Pinaki Poddar\n  */\n public interface FetchConfiguration\n-    extends Serializable, Cloneable, LockLevels, QueryFlushModes {\n+    extends Serializable, Cloneable, LockLevels, LockScopes, QueryFlushModes {\n \n     /**\n      * Constant to revert any setting back to its default value.\n@@ -268,7 +268,21 @@\n      * @since 0.3.1\n      */\n     public FetchConfiguration setLockTimeout(int timeout);\n-    \n+\n+    /**\n+     * The lock scope for next fetch.\n+     *\n+     * @since 2.0.0\n+     */\n+    public int getLockScope();\n+\n+    /**\n+     * The lock scope for next fetch.\n+     *\n+     * @since 2.0.0\n+     */\n+    public FetchConfiguration setLockScope(int scope);\n+\n     /**\n      * The number of milliseconds to wait for a query, or -1 for no\n      * limit."},{"sha":"c785e5f8b169e7548ee40a227b71b29bf0dac66f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","status":"modified","additions":18,"deletions":1,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -78,7 +78,7 @@\n         public int flushQuery = 0;\n         public int lockTimeout = -1;\n         public int queryTimeout = -1;\n-        public int lockMode = 0;\n+        public int lockScope = LOCKSCOPE_NORMAL;\n         public int readLockLevel = LOCK_NONE;\n         public int writeLockLevel = LOCK_NONE;\n         public Set<String> fetchGroups = null;\n@@ -168,6 +168,7 @@ public void copy(FetchConfiguration fetch) {\n         setExtendedPathLookup(fetch.getExtendedPathLookup());\n         setLockTimeout(fetch.getLockTimeout());\n         setQueryTimeout(fetch.getQueryTimeout());\n+        setLockScope(fetch.getLockScope());\n         clearFetchGroups();\n         addFetchGroups(fetch.getFetchGroups());\n         clearFields();\n@@ -482,6 +483,22 @@ else if (timeout != DEFAULT) {\n         return this;\n     }\n \n+    public int getLockScope() {\n+        return _state.lockScope;\n+    }\n+\n+    public FetchConfiguration setLockScope(int scope) {\n+        if (scope != DEFAULT\n+                && scope != LockScopes.LOCKSCOPE_NORMAL\n+                && scope != LockScopes.LOCKSCOPE_EXTENDED)\n+                throw new IllegalArgumentException(_loc.get(\n+                    \"bad-lock-scope\", new Integer(scope)).getMessage());\n+        if (scope == DEFAULT )\n+            _state.lockScope = LOCKSCOPE_NORMAL;\n+        else\n+            _state.lockScope = scope;\n+        return this;\n+    }\n \n     public int getReadLockLevel() {\n         String lockModeKey = \"openjpa.FetchPlan.ReadLockMode\";"},{"sha":"7f1ae2c5242ecaedb975556a286fae70052633e7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockScopes.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockScopes.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockScopes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockScopes.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.kernel;\n+\n+/**\n+ * Defines lock scope levels used for MixedLockManager.\n+ *\n+ * @since 2.0.0\n+ */\n+public interface LockScopes {\n+\n+    /**\n+     * Generic Normal lock scope level. Value of 0.\n+     *\n+     */\n+    public static final int LOCKSCOPE_NORMAL = 0;\n+\n+    /**\n+     * Generic extended lock scope level. Value of 10.\n+     */\n+    public static final int LOCKSCOPE_EXTENDED = 10;\n+\n+}"},{"sha":"cabe787a44e8b2e73e38f4f164140bf1becb731f","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -448,4 +448,5 @@ fill-factory-error: Error while fill data with factory strategy. The error \\\n \toccurred while invoking \"{0}\" with key \"{1}\" and value \"{2}\" of type \"{3}\". \\\n \tSee nested exception for details.\t\n writebehind-cfg-err: Missing required WriteBehind configuration parameter \"{0}\"\n+bad-lock-scope: This lock manager does not recognize lock scope \"{0}\".\n "},{"sha":"fd63ee437049106a4f6b1040b72d6d48f043075d","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1Lf.java","status":"added","additions":113,"deletions":0,"changes":113,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1Lf.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1Lf.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1Lf.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.OneToOne;\n+import javax.persistence.QueryHint;\n+import javax.persistence.Version;\n+\n+@NamedQueries ( value={\n+        @NamedQuery(\n+            name=\"findLSE1x1LfNormal\"\n+            , query=\"SELECT c FROM LSE1x1Lf c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            ),\n+        @NamedQuery(\n+            name=\"findLSE1x1LfExtended\"\n+            , query=\"SELECT c FROM LSE1x1Lf c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            , hints={@QueryHint(name=\"javax.persistence.lock.scope\",value=\"EXTENDED\")}\n+            ) \n+        }\n+    )\n+\n+@Entity\n+public class LSE1x1Lf implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+\n+    private String firstName;\n+    \n+    @OneToOne\n+    private LSE1x1Rt uniRight;\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+    \n+    public void setFirstName(String firstName) {\n+        this.firstName = firstName;\n+    }\n+    \n+    public LSE1x1Rt getUniRight() {\n+        return uniRight;\n+    }\n+\n+    public void setUniRight(LSE1x1Rt uniRight) {\n+        this.uniRight = uniRight;\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@' + Integer.toHexString(System.identityHashCode(this)) + \"[id=\" + getId()\n+                + \", ver=\" + getVersion() + \", firstName=\" + firstName + \"]\" \n+                + \" uniRight=\" + getUniRight()\n+                ;\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        firstName = in.readUTF();\n+        uniRight = (LSE1x1Rt) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeUTF(firstName);\n+        out.writeObject(uniRight);\n+    }\n+}"},{"sha":"fc780658b2d270f6deddf936354dbad77b48cc90","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1LfJT.java","status":"added","additions":115,"deletions":0,"changes":115,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1LfJT.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1LfJT.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1LfJT.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.JoinTable;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.OneToOne;\n+import javax.persistence.QueryHint;\n+import javax.persistence.Version;\n+\n+@NamedQueries ( value={\n+        @NamedQuery(\n+            name=\"findLSE1x1LfJTNormal\"\n+            , query=\"SELECT c FROM LSE1x1LfJT c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            ),\n+        @NamedQuery(\n+            name=\"findLSE1x1LfJTExtended\"\n+            , query=\"SELECT c FROM LSE1x1LfJT c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            , hints={@QueryHint(name=\"javax.persistence.lock.scope\",value=\"EXTENDED\")}\n+            ) \n+        }\n+    )\n+\n+@Entity\n+public class LSE1x1LfJT implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+\n+    private String firstName;\n+    \n+    @OneToOne\n+    @JoinTable(name=\"Uni1x1LfJT_Uni1x1RT\")\n+    private LSE1x1Rt uniRightJT;\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+    \n+    public void setFirstName(String firstName) {\n+        this.firstName = firstName;\n+    }\n+    \n+    public LSE1x1Rt getUniRightJT() {\n+        return uniRightJT;\n+    }\n+\n+    public void setUniRightJT(LSE1x1Rt uniRightJT) {\n+        this.uniRightJT = uniRightJT;\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@' + Integer.toHexString(System.identityHashCode(this)) + \"[id=\" + getId()\n+                + \", ver=\" + getVersion() + \", firstName=\" + firstName + \"]\" \n+                + \" uniRightJT=\" + getUniRightJT()\n+                ;\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        firstName = in.readUTF();\n+        uniRightJT = (LSE1x1Rt) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeUTF(firstName);\n+        out.writeObject(uniRightJT);\n+    }\n+}"},{"sha":"057d9e9009292f57e225132cf1d47a4580701da6","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1LfJTLzy.java","status":"added","additions":116,"deletions":0,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1LfJTLzy.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1LfJTLzy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1LfJTLzy.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinTable;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.OneToOne;\n+import javax.persistence.QueryHint;\n+import javax.persistence.Version;\n+\n+@NamedQueries ( value={\n+        @NamedQuery(\n+            name=\"findLSE1x1LfJTLzyNormal\"\n+            , query=\"SELECT c FROM LSE1x1LfJTLzy c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            ),\n+        @NamedQuery(\n+            name=\"findLSE1x1LfJTLzyExtended\"\n+            , query=\"SELECT c FROM LSE1x1LfJTLzy c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            , hints={@QueryHint(name=\"javax.persistence.lock.scope\",value=\"EXTENDED\")}\n+            ) \n+        }\n+    )\n+\n+@Entity\n+public class LSE1x1LfJTLzy implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+\n+    private String firstName;\n+    \n+    @OneToOne(fetch=FetchType.LAZY)\n+    @JoinTable(name=\"Uni1x1LfJT_Uni1x1RT\")\n+    private LSE1x1Rt uniRightJT;\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+    \n+    public void setFirstName(String firstName) {\n+        this.firstName = firstName;\n+    }\n+    \n+    public LSE1x1Rt getUniRightJT() {\n+        return uniRightJT;\n+    }\n+\n+    public void setUniRightJT(LSE1x1Rt uniRightJT) {\n+        this.uniRightJT = uniRightJT;\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@' + Integer.toHexString(System.identityHashCode(this)) + \"[id=\" + getId()\n+                + \", ver=\" + getVersion() + \", firstName=\" + firstName + \"]\" \n+                + \" uniRightJT=\" + getUniRightJT()\n+                ;\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        firstName = in.readUTF();\n+        uniRightJT = (LSE1x1Rt) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeUTF(firstName);\n+        out.writeObject(uniRightJT);\n+    }\n+}"},{"sha":"2826b537225865ff86a3ef5c45b207a4f5c94d83","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1LfLzy.java","status":"added","additions":114,"deletions":0,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1LfLzy.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1LfLzy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1LfLzy.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.Id;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.OneToOne;\n+import javax.persistence.QueryHint;\n+import javax.persistence.Version;\n+\n+@NamedQueries ( value={\n+        @NamedQuery(\n+            name=\"findLSE1x1LfLzyNormal\"\n+            , query=\"SELECT c FROM LSE1x1LfLzy c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            ),\n+        @NamedQuery(\n+            name=\"findLSE1x1LfLzyExtended\"\n+            , query=\"SELECT c FROM LSE1x1LfLzy c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            , hints={@QueryHint(name=\"javax.persistence.lock.scope\",value=\"EXTENDED\")}\n+            ) \n+        }\n+    )\n+\n+@Entity\n+public class LSE1x1LfLzy implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+\n+    private String firstName;\n+    \n+    @OneToOne(fetch=FetchType.LAZY)\n+    private LSE1x1Rt uniRight;\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+    \n+    public void setFirstName(String firstName) {\n+        this.firstName = firstName;\n+    }\n+    \n+    public LSE1x1Rt getUniRight() {\n+        return uniRight;\n+    }\n+\n+    public void setUniRight(LSE1x1Rt uniRight) {\n+        this.uniRight = uniRight;\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@' + Integer.toHexString(System.identityHashCode(this)) + \"[id=\" + getId()\n+                + \", ver=\" + getVersion() + \", firstName=\" + firstName + \"]\" \n+                + \" uniRight=\" + getUniRight()\n+                ;\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        firstName = in.readUTF();\n+        uniRight = (LSE1x1Rt) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeUTF(firstName);\n+        out.writeObject(uniRight);\n+    }\n+}"},{"sha":"67f178af367556144cb426c1e813a472ad21996e","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1Rt.java","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1Rt.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1Rt.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1x1Rt.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.Version;\n+\n+@Entity\n+public class LSE1x1Rt implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+    \n+    private String lastName;\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getLastName() {\n+        return lastName;\n+    }\n+    \n+    public void setLastName(String lastName) {\n+        this.lastName = lastName;\n+    }\n+    \n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@'\n+            + Integer.toHexString(System.identityHashCode(this)) + \"[id=\"\n+            + getId() + \", ver=\" + getVersion() + \", lastName=\" + lastName + \"]\";\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        lastName = in.readUTF();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeUTF(lastName);\n+    }\n+}"},{"sha":"a1f4e64bf1473591de6838eadc4597da65f57aeb","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLf.java","status":"added","additions":118,"deletions":0,"changes":118,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLf.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLf.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLf.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.OneToMany;\n+import javax.persistence.QueryHint;\n+import javax.persistence.Version;\n+\n+@NamedQueries ( value={\n+        @NamedQuery(\n+            name=\"findLSE1xmLfNormal\"\n+            , query=\"SELECT c FROM LSE1xmLf c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            ),\n+        @NamedQuery(\n+            name=\"findLSE1xmLfExtended\"\n+            , query=\"SELECT c FROM LSE1xmLf c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            , hints={@QueryHint(name=\"javax.persistence.lock.scope\",value=\"EXTENDED\")}\n+            ) \n+        }\n+    )\n+\n+@Entity\n+public class LSE1xmLf implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+\n+    private String firstName;\n+    \n+    @OneToMany // (cascade=CascadeType.ALL) (mappedBy=\"ownerOne\")\n+    private Collection<LSE1xmRt> uniRight = new HashSet<LSE1xmRt>();\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+    \n+    public void setFirstName(String firstName) {\n+        this.firstName = firstName;\n+    }\n+    \n+    public Collection<LSE1xmRt> getUniRight() {\n+        return uniRight;\n+    }\n+\n+    public void setUnitRight(Collection<LSE1xmRt> uniRight) {\n+        this.uniRight = uniRight;\n+    }\n+\n+    public void addUnitRight(LSE1xmRt uniRight) {\n+        this.uniRight.add(uniRight);\n+    }\n+    \n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@'\n+            + Integer.toHexString(System.identityHashCode(this)) + \"[id=\"\n+            + getId() + \", ver=\" + getVersion() + \", firstName=\" + firstName + \"] ownedMany=\" + getUniRight();\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        firstName = in.readUTF();\n+        uniRight = (Collection<LSE1xmRt>) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeUTF(firstName);\n+        out.writeObject(uniRight);\n+    }\n+}"},{"sha":"8c1fbf811dc0cb439d35bf531eee1ca88149e23b","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLfEgr.java","status":"added","additions":119,"deletions":0,"changes":119,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLfEgr.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLfEgr.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLfEgr.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.Id;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.OneToMany;\n+import javax.persistence.QueryHint;\n+import javax.persistence.Version;\n+\n+@NamedQueries ( value={\n+        @NamedQuery(\n+            name=\"findLSE1xmLfEgrNormal\"\n+            , query=\"SELECT c FROM LSE1xmLfEgr c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            ),\n+        @NamedQuery(\n+            name=\"findLSE1xmLfEgrExtended\"\n+            , query=\"SELECT c FROM LSE1xmLfEgr c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            , hints={@QueryHint(name=\"javax.persistence.lock.scope\",value=\"EXTENDED\")}\n+            ) \n+        }\n+    )\n+\n+@Entity\n+public class LSE1xmLfEgr implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+\n+    private String firstName;\n+    \n+    @OneToMany(fetch=FetchType.EAGER) //(mappedBy=\"ownerOne\")\n+    private Collection<LSE1xmRt> uniRight = new HashSet<LSE1xmRt>();\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+    \n+    public void setFirstName(String firstName) {\n+        this.firstName = firstName;\n+    }\n+    \n+    public Collection<LSE1xmRt> getUniRight() {\n+        return uniRight;\n+    }\n+\n+    public void setUnitRight(Collection<LSE1xmRt> uniRight) {\n+        this.uniRight = uniRight;\n+    }\n+\n+    public void addUnitRight(LSE1xmRt uniRight) {\n+        this.uniRight.add(uniRight);\n+    }\n+    \n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@'\n+            + Integer.toHexString(System.identityHashCode(this)) + \"[id=\"\n+            + getId() + \", ver=\" + getVersion() + \", firstName=\" + firstName + \"] ownedMany=\" + getUniRight();\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        firstName = in.readUTF();\n+        uniRight = (Collection<LSE1xmRt>) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeUTF(firstName);\n+        out.writeObject(uniRight);\n+    }\n+}"},{"sha":"31d00ea67655f1eaf10ffb81f11d3f6bee7ecd72","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLfJT.java","status":"added","additions":120,"deletions":0,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLfJT.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLfJT.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLfJT.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.JoinTable;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.OneToMany;\n+import javax.persistence.QueryHint;\n+import javax.persistence.Version;\n+\n+@NamedQueries ( value={\n+        @NamedQuery(\n+            name=\"findLSE1xmLfJTNormal\"\n+            , query=\"SELECT c FROM LSE1xmLfJT c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            ),\n+        @NamedQuery(\n+            name=\"findLSE1xmLfJTExtended\"\n+            , query=\"SELECT c FROM LSE1xmLfJT c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            , hints={@QueryHint(name=\"javax.persistence.lock.scope\",value=\"EXTENDED\")}\n+            ) \n+        }\n+    )\n+\n+@Entity\n+public class LSE1xmLfJT implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+\n+    private String firstName;\n+    \n+    @JoinTable\n+    @OneToMany //(mappedBy=\"ownerOne\")\n+    private Collection<LSE1xmRt> uniRight = new HashSet<LSE1xmRt>();\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+    \n+    public void setFirstName(String firstName) {\n+        this.firstName = firstName;\n+    }\n+    \n+    public Collection<LSE1xmRt> getUniRight() {\n+        return uniRight;\n+    }\n+\n+    public void setUnitRight(Collection<LSE1xmRt> uniRight) {\n+        this.uniRight = uniRight;\n+    }\n+\n+    public void addUnitRight(LSE1xmRt uniRight) {\n+        this.uniRight.add(uniRight);\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@'\n+            + Integer.toHexString(System.identityHashCode(this)) + \"[id=\"\n+            + getId() + \", ver=\" + getVersion() + \", firstName=\" + firstName + \"] ownedMany=\" + getUniRight();\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        firstName = in.readUTF();\n+        uniRight = (Collection<LSE1xmRt>) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeUTF(firstName);\n+        out.writeObject(uniRight);\n+    }\n+}"},{"sha":"91cf9dd12d07d9966942582f9da9596894183b6e","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLfJTEgr.java","status":"added","additions":119,"deletions":0,"changes":119,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLfJTEgr.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLfJTEgr.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmLfJTEgr.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.Id;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.OneToMany;\n+import javax.persistence.QueryHint;\n+import javax.persistence.Version;\n+\n+@NamedQueries ( value={\n+        @NamedQuery(\n+            name=\"findLSE1xmLfJTEgrNormal\"\n+            , query=\"SELECT c FROM LSE1xmLfJTEgr c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            ),\n+        @NamedQuery(\n+            name=\"findLSE1xmLfJTEgrExtended\"\n+            , query=\"SELECT c FROM LSE1xmLfJTEgr c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            , hints={@QueryHint(name=\"javax.persistence.lock.scope\",value=\"EXTENDED\")}\n+            ) \n+        }\n+    )\n+\n+@Entity\n+public class LSE1xmLfJTEgr implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+\n+    private String firstName;\n+\n+    @OneToMany(fetch=FetchType.EAGER)//(mappedBy=\"ownerOne\")\n+    private Collection<LSE1xmRt> uniRight = new HashSet<LSE1xmRt>();\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+\n+    public void setFirstName(String firstName) {\n+        this.firstName = firstName;\n+    }\n+\n+    public Collection<LSE1xmRt> getUniRight() {\n+        return uniRight;\n+    }\n+\n+    public void setUnitRight(Collection<LSE1xmRt> uniRight) {\n+        this.uniRight = uniRight;\n+    }\n+\n+    public void addUnitRight(LSE1xmRt uniRight) {\n+        this.uniRight.add(uniRight);\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@'\n+            + Integer.toHexString(System.identityHashCode(this)) + \"[id=\"\n+            + getId() + \", ver=\" + getVersion() + \", firstName=\" + firstName + \"] ownedMany=\" + getUniRight();\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        firstName = in.readUTF();\n+        uniRight = (Collection<LSE1xmRt>) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeUTF(firstName);\n+        out.writeObject(uniRight);\n+    }\n+}"},{"sha":"dee40b994ae9d1927acbf028156fbf581bb4efbf","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmRt.java","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmRt.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmRt.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSE1xmRt.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.Version;\n+\n+@Entity\n+public class LSE1xmRt implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+\n+    private String lastName;\n+    \n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getLastName() {\n+        return lastName;\n+    }\n+    \n+    public void setLastName(String lastName) {\n+        this.lastName = lastName;\n+    }\n+    \n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@'\n+            + Integer.toHexString(System.identityHashCode(this)) + \"[id=\"\n+            + getId() + \", ver=\" + getVersion() + \", lastName=\" + lastName + \"]\";\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        lastName = in.readUTF();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeUTF(lastName);\n+    }\n+}"},{"sha":"39a748edd45fb882f823f36f111f3215e81e61f1","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEBase.java","status":"added","additions":110,"deletions":0,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEBase.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEBase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEBase.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.QueryHint;\n+import javax.persistence.Version;\n+\n+@NamedQueries ( value={\n+    @NamedQuery(\n+        name=\"findLSEBaseNormal\"\n+        , query=\"SELECT c FROM LSEBase c WHERE c.firstName LIKE :firstName\"\n+        , lockMode=LockModeType.PESSIMISTIC_WRITE\n+        ),\n+    @NamedQuery(\n+        name=\"findLSEBaseExtended\"\n+        , query=\"SELECT c FROM LSEBase c WHERE c.firstName LIKE :firstName\"\n+        , lockMode=LockModeType.PESSIMISTIC_WRITE\n+        , hints={@QueryHint(name=\"javax.persistence.lock.scope\",value=\"EXTENDED\")}\n+        ) \n+    }\n+)\n+\n+@Entity\n+public class LSEBase implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+\n+    private String firstName;\n+    private String lastName;\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+\n+    public void setFirstName(String firstName) {\n+        this.firstName = firstName;\n+    }\n+\n+    public String getLastName() {\n+        return lastName;\n+    }\n+\n+    public void setLastName(String lastName) {\n+        this.lastName = lastName;\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@'\n+            + Integer.toHexString(System.identityHashCode(this)) + \"[id=\"\n+            + getId() + \", ver=\" + getVersion() + \"] first=\" + getFirstName()\n+            + \", last=\" + getLastName();\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        firstName = (String) in.readObject();\n+        lastName = (String) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeObject(firstName);\n+        out.writeObject(lastName);\n+    }\n+}"},{"sha":"72600f01e385f0e737cf75d2778a09b5af347cbf","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEEleCol.java","status":"added","additions":118,"deletions":0,"changes":118,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEEleCol.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEEleCol.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEEleCol.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.ElementCollection;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.QueryHint;\n+import javax.persistence.Version;\n+\n+@NamedQueries ( value={\n+        @NamedQuery(\n+            name=\"findLSEEleColNormal\"\n+            , query=\"SELECT c FROM LSEEleCol c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            ),\n+        @NamedQuery(\n+            name=\"findLSEEleColExtended\"\n+            , query=\"SELECT c FROM LSEEleCol c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            , hints={@QueryHint(name=\"javax.persistence.lock.scope\",value=\"EXTENDED\")}\n+            ) \n+        }\n+    )\n+\n+@Entity\n+public class LSEEleCol implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+\n+    private String firstName;\n+    \n+    @ElementCollection\n+    protected Set<String> collection = new HashSet<String>();\n+    \n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+\n+    public void setFirstName(String name) {\n+        this.firstName = name;\n+    }\n+\n+    public Set<String> getCollection() {\n+        return collection;\n+    }\n+\n+    public void setCollection(Set<String> collection) {\n+        this.collection = collection;\n+    }\n+\n+    public void addCollection(String element) {\n+        collection.add(element);\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@'\n+            + Integer.toHexString(System.identityHashCode(this)) + \"[id=\"\n+            + getId() + \", ver=\" + getVersion() + \", firstName=\" + getFirstName() + \"] one=\" + getCollection();\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        firstName = in.readUTF();\n+        collection = (Set<String>) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeUTF(firstName);\n+        out.writeObject(collection);\n+    }\n+}"},{"sha":"aebfbefd34d72f1cecc0f2b76a97478a86c1ffdc","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEEleColEgr.java","status":"added","additions":119,"deletions":0,"changes":119,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEEleColEgr.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEEleColEgr.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEEleColEgr.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.ElementCollection;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.Id;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.QueryHint;\n+import javax.persistence.Version;\n+\n+@NamedQueries ( value={\n+        @NamedQuery(\n+            name=\"findLSEEleColEgrNormal\"\n+            , query=\"SELECT c FROM LSEEleColEgr c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            ),\n+        @NamedQuery(\n+            name=\"findLSEEleColEgrExtended\"\n+            , query=\"SELECT c FROM LSEEleColEgr c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            , hints={@QueryHint(name=\"javax.persistence.lock.scope\",value=\"EXTENDED\")}\n+            ) \n+        }\n+    )\n+\n+@Entity\n+public class LSEEleColEgr implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+\n+    private String firstName;\n+    \n+    @ElementCollection(fetch=FetchType.EAGER)\n+    protected Set<String> collection = new HashSet<String>();\n+    \n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+\n+    public void setFirstName(String name) {\n+        this.firstName = name;\n+    }\n+\n+    public Set<String> getCollection() {\n+        return collection;\n+    }\n+\n+    public void setCollection(Set<String> collection) {\n+        this.collection = collection;\n+    }\n+\n+    public void addCollection(String element) {\n+        collection.add(element);\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@'\n+            + Integer.toHexString(System.identityHashCode(this)) + \"[id=\"\n+            + getId() + \", ver=\" + getVersion() + \", firstName=\" + getFirstName() + \"] one=\" + getCollection();\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        firstName = in.readUTF();\n+        collection = (Set<String>) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeUTF(firstName);\n+        out.writeObject(collection);\n+    }\n+}"},{"sha":"9df09c15cad078b2a03950c92129f4ae636c6940","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEJoinAbs.java","status":"added","additions":81,"deletions":0,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEJoinAbs.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEJoinAbs.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEJoinAbs.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.Inheritance;\n+import javax.persistence.InheritanceType;\n+import javax.persistence.Version;\n+\n+@Entity\n+@Inheritance(strategy=InheritanceType.JOINED)\n+public abstract class LSEJoinAbs implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+\n+    private String firstName;\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+\n+    public void setFirstName(String firstName) {\n+        this.firstName = firstName;\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@'\n+            + Integer.toHexString(System.identityHashCode(this)) + \"[id=\"\n+            + getId() + \", ver=\" + getVersion() + \"] first=\" + getFirstName();\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        firstName = (String) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeObject(firstName);\n+    }\n+}"},{"sha":"37e8fc7152d495cf8d631d5d9a4de7036146a27b","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEJoinCon.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEJoinCon.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEJoinCon.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSEJoinCon.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.QueryHint;\n+\n+@NamedQueries ( value={\n+        @NamedQuery(\n+            name=\"findLSEJoinConNormal\"\n+            , query=\"SELECT c FROM LSEJoinCon c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            ),\n+        @NamedQuery(\n+            name=\"findLSEJoinConExtended\"\n+            , query=\"SELECT c FROM LSEJoinCon c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            , hints={@QueryHint(name=\"javax.persistence.lock.scope\",value=\"EXTENDED\")}\n+            ) \n+        }\n+    )\n+\n+@Entity\n+public class LSEJoinCon extends LSEJoinAbs implements Externalizable {\n+\n+    private String lastName;\n+\n+    public String getLastName() {\n+        return lastName;\n+    }\n+\n+    public void setLastName(String lastName) {\n+        this.lastName = lastName;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@'\n+            + Integer.toHexString(System.identityHashCode(this)) + super.toString() \n+            + \", last=\" + getLastName();\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        super.readExternal(in);\n+        lastName = (String) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        super.writeExternal(out);\n+        out.writeObject(lastName);\n+    }\n+}"},{"sha":"dc0264d4f2eac84f59532d91cbbf7af18a801d56","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSESecTbl.java","status":"added","additions":112,"deletions":0,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSESecTbl.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSESecTbl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSESecTbl.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.QueryHint;\n+import javax.persistence.SecondaryTable;\n+import javax.persistence.Version;\n+\n+@NamedQueries ( value={\n+        @NamedQuery(\n+            name=\"findLSESecTblNormal\"\n+            , query=\"SELECT c FROM LSESecTbl c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            ),\n+        @NamedQuery(\n+            name=\"findLSESecTblExtended\"\n+            , query=\"SELECT c FROM LSESecTbl c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            , hints={@QueryHint(name=\"javax.persistence.lock.scope\",value=\"EXTENDED\")}\n+            ) \n+        }\n+    )\n+\n+@Entity\n+@SecondaryTable(name=\"LSESecTblDtl\")\n+public class LSESecTbl implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+\n+    private String firstName;\n+    @Column(table=\"LSESecTblDtl\")\n+    private String lastName;\n+    \n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+\n+    public void setFirstName(String firstName) {\n+        this.firstName = firstName;\n+    }\n+\n+    public String getLastName() {\n+        return lastName;\n+    }\n+\n+    public void setLastName(String lastName) {\n+        this.lastName = lastName;\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@' + Integer.toHexString(System.identityHashCode(this)) + \"[id=\" + getId()\n+                + \", ver=\" + getVersion() + \"] first=\" + getFirstName() + \", last=\" + getLastName();\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        firstName = (String) in.readObject();\n+        lastName = (String) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeObject(firstName);\n+        out.writeObject(lastName);\n+    }\n+}"},{"sha":"7c2156f0d0fbcd7091b257eae3eaad842779af79","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSESngTblAbs.java","status":"added","additions":100,"deletions":0,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSESngTblAbs.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSESngTblAbs.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSESngTblAbs.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.Inheritance;\n+import javax.persistence.InheritanceType;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.QueryHint;\n+import javax.persistence.Version;\n+\n+@NamedQueries ( value={\n+        @NamedQuery(\n+            name=\"findLSESngTblAbsNormal\"\n+            , query=\"SELECT c FROM LSESngTblAbs c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            ),\n+        @NamedQuery(\n+            name=\"findLSESngTblAbsExtended\"\n+            , query=\"SELECT c FROM LSESngTblAbs c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            , hints={@QueryHint(name=\"javax.persistence.lock.scope\",value=\"EXTENDED\")}\n+            ) \n+        }\n+    )\n+\n+@Entity\n+@Inheritance(strategy=InheritanceType.SINGLE_TABLE)\n+public abstract class LSESngTblAbs implements Externalizable {\n+\n+    @Id\n+    private int id;\n+\n+    @Version\n+    private int version;\n+\n+    private String firstName;\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getFirstName() {\n+        return firstName;\n+    }\n+\n+    public void setFirstName(String firstName) {\n+        this.firstName = firstName;\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@'\n+            + Integer.toHexString(System.identityHashCode(this)) + \"[id=\"\n+            + getId() + \", ver=\" + getVersion() + \"] first=\" + getFirstName();\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        id = in.readInt();\n+        version = in.readInt();\n+        firstName = (String) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(id);\n+        out.writeInt(version);\n+        out.writeObject(firstName);\n+    }\n+}"},{"sha":"ac0daddaa7ad166fc642d59dd68c87b39a2d72b5","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSESngTblCon.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSESngTblCon.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSESngTblCon.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LSESngTblCon.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.QueryHint;\n+\n+@NamedQueries ( value={\n+        @NamedQuery(\n+            name=\"findLSESngTblConNormal\"\n+            , query=\"SELECT c FROM LSESngTblCon c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            ),\n+        @NamedQuery(\n+            name=\"findLSESngTblConExtended\"\n+            , query=\"SELECT c FROM LSESngTblCon c WHERE c.firstName LIKE :firstName\"\n+            , lockMode=LockModeType.PESSIMISTIC_WRITE\n+            , hints={@QueryHint(name=\"javax.persistence.lock.scope\",value=\"EXTENDED\")}\n+            ) \n+        }\n+    )\n+\n+@Entity\n+public class LSESngTblCon extends LSESngTblAbs implements Externalizable {\n+\n+    private String lastName;\n+\n+    public String getLastName() {\n+        return lastName;\n+    }\n+\n+    public void setLastName(String lastName) {\n+        this.lastName = lastName;\n+    }\n+\n+    public String toString() {\n+        return this.getClass().getName() + '@'\n+            + Integer.toHexString(System.identityHashCode(this)) + super.toString() \n+            + \", last=\" + getLastName();\n+    }\n+\n+    public void readExternal(ObjectInput in) throws IOException,\n+        ClassNotFoundException {\n+        super.readExternal(in);\n+        lastName = (String) in.readObject();\n+    }\n+\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        super.writeExternal(out);\n+        out.writeObject(lastName);\n+    }\n+}"},{"sha":"cce1ec3f443bc5bf0cb6683af8e0636a592ce477","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LockScopeTestCase.java","status":"added","additions":324,"deletions":0,"changes":324,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LockScopeTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LockScopeTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LockScopeTestCase.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,324 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PessimisticLockScope;\n+import javax.persistence.Query;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.persistence.MixedLockLevelsHelper;\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\n+import org.apache.openjpa.persistence.test.SQLListenerTestCase;\n+\n+/**\n+ * Base class for locking extended scope tests.\n+ *\n+ * Test JPA 2.0 EM interface normal lock scope behaviors with \"mixed\" lock\n+ * manager. When an entity instance is locked using pessimistic locking, the\n+ * persistence provider must lock the database row(s) that correspond to the\n+ * non-collection-valued persistent state of that instance. If a joined\n+ * inheritance strategy is used, or if the entity is otherwise mapped to a\n+ * secondary table, this entails locking the row(s) for the entity instance in\n+ * the additional table(s). Entity relationships for which the locked entity\n+ * contains the foreign key will also be locked, but not the state of the\n+ * referenced entities (unless hose entities are explicitly locked). Element\n+ * collections and relationships for which the entity does not contain the\n+ * foreign key (such as relationships that are mapped to join tables or\n+ * unidirectional one-to-many relationships for which the target entity contains\n+ * the foreign key) will not be locked by default.\n+ *\n+ * Element collections and relationships owned by the entity that are contained\n+ * in join tables will be locked if the javax.persistence.lock.scope property is\n+ * specified with a value of PessimisticLockScope.EXTENDED. The state of\n+ * entities referenced by such relationships will not be locked (unless those\n+ * entities are explicitly locked). This property may be passed as an argument\n+ * to the methods of the EntityManager and Query interfaces that allow lock\n+ * modes to be specified or used with the NamedQuery annotation.\n+ * \n+ * @since 2.0\n+ */\n+public abstract class LockScopeTestCase extends SQLListenerTestCase {\n+    \n+    protected final String Select           = \"SELECT.*FROM.*\";\n+    protected final String Where            = \".*WHERE.*\";\n+    protected final String ForUpdateRex     = \"FOR UPDATE.*\";\n+    protected final String ForUpdateClause  = \"(\" + ForUpdateRex + \")\";\n+    protected final String ForUpdate        = ForUpdateClause + \"{1}\";\n+    protected final String NoForUpdate      = ForUpdateClause + \"{0}\";\n+    protected final String DB2LockClause    = \"(\" + ForUpdateRex +\n+                                              \"|FOR READ ONLY WITH R. USE AND KEEP (UPDATE|EXCLUSIVE) LOCKS)\";\n+    protected final String DB2Lock          = DB2LockClause + \"{1}\"; \n+    protected final String NoDB2Lock        = DB2LockClause + \"{0}\"; \n+\n+    protected List<String> empTableName = new ArrayList<String>();;\n+\n+    protected Map<String, Object> normalProps;\n+    protected Map<String, Object> extendedProps;\n+\n+    protected void commonSetUp(Class<?>... eClasses ) {\n+        normalProps = new HashMap<String, Object>();\n+        extendedProps = new HashMap<String, Object>();\n+        extendedProps.put(\"javax.persistence.lock.scope\", PessimisticLockScope.EXTENDED);\n+\n+        for( Class<?> eClazz : eClasses) {\n+            empTableName.add(getMapping(eClazz).getTable().getFullName());\n+        }\n+        cleanupDB();\n+    }\n+\n+    private void cleanupDB() {\n+        EntityManager em = null;\n+        try {\n+            em = emf.createEntityManager();\n+            em.getTransaction().begin();\n+            for (String tableName : empTableName.toArray(new String[empTableName.size()])) {\n+                em.createQuery(\"delete from \" + tableName).executeUpdate();\n+            }\n+            em.getTransaction().commit();\n+        } catch(Exception e) {\n+            e.printStackTrace();\n+        } finally {\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+    }\n+\n+    protected enum DBType {\n+        access, db2, derby, empress, foxpro, h2, hsql, informix, ingres, jdatastore, mysql, oracle, pointbase, postgres,\n+        sqlserver, sybase\n+    };\n+\n+    protected DBType getDBType(EntityManager em) {\n+        JDBCConfigurationImpl conf = (JDBCConfigurationImpl) getConfiguration(em);\n+        String dictClassName = getConfiguration(em).getDBDictionaryInstance().getClass().getName();\n+        String db = conf.dbdictionaryPlugin.alias(dictClassName);\n+        return DBType.valueOf(db);\n+    }\n+\n+    @SuppressWarnings( { \"unused\", \"deprecation\" })\n+    protected JDBCConfiguration getConfiguration(EntityManager em) {\n+        return ((JDBCConfiguration) ((OpenJPAEntityManager) em).getConfiguration());\n+    }\n+\n+    protected Log getLog() {\n+        return emf.getConfiguration().getLog(\"Tests\");\n+    }\n+\n+    protected Log getDumpStackLog() {\n+        return emf.getConfiguration().getLog(\"DumpStack\");\n+    }\n+\n+    /*\n+     * Set Log=LockTestSQL=TRACE to dump the SQL caught by the SQL listener but do not perform SQL assertion.\n+     */\n+    protected Log getDumpSQLLog() {\n+        return emf.getConfiguration().getLog(\"LockTestSQL\");\n+    }\n+\n+    public void assertLockTestSQLs(String... expected) {\n+        Log log = getDumpSQLLog(); \n+        if( log.isTraceEnabled()) {\n+            log.trace(\"\\r\\n\" + toString(sql));\n+            return;\n+        }\n+        assertAnySQLAnyOrder(expected);\n+    }\n+    \n+    protected void logStack(Throwable t) {\n+        StringWriter str = new StringWriter();\n+        PrintWriter print = new PrintWriter(str);\n+        t.printStackTrace(print);\n+        getDumpStackLog().trace(str.toString());\n+    }\n+\n+    // Id designation-\n+    // for basic test:\n+    //      [basic=0,sectable=1,singletable=2,join=4,eleColl=5,eleCollEager=6][normal=0|extended=1][entity#]\n+    // For 1x1/1xm tests:\n+    //      [1x1=1,1xM=2] [uni=1|bi=2] [left=1|right=2] [normal=1|join=2] [default=0|lazy=1|eager=2] \n+    //          [normal=0|extended=1] [n-th entity]\n+    protected <T> void commonLockTest(String testName, Class<T> type, int id0, boolean extended, String queryString,\n+            String namedQueryString, AssertCallback verify) {\n+        getLog().info(\"** \" + testName + \"()\");\n+        String entityName = type.getName();\n+        String scope = extended ? \"Extended\" : \"Normal\";\n+        Map<String, Object> props = extended ? extendedProps : normalProps;\n+        int id1 = id0 + 1;\n+\n+        EntityManager em = null;\n+        T e0 = null;\n+        T e1 = null;\n+        try {\n+            getLog().info(\"-- Test find with no lock in \" + scope + \" scope\");\n+            em = emf.createEntityManager();\n+            getLog().info(\" *Begin a transaction.\");\n+            em.getTransaction().begin();\n+            resetSQL();\n+            getLog().info(\" *Find \" + entityName + \"(\" + id0 + \") with no lock\");\n+            e0 = em.find(type, id0, props);\n+            getLog().info(\" *\" + (e0 != null ? \"F\" : \"Can not f\") + \"ind entity\");\n+            verify.findNoLockDbSQL(em);\n+            getLog().info(\" *Found entity:\" + e0);\n+            assertNotNull(\" *Found \" + entityName + \"(\" + id0 + \")\", e0);\n+            assertEquals(\" *Assert no lock applied\", LockModeType.NONE, em.getLockMode(e0));\n+\n+            getLog().info(\" *Find \" + entityName + \"(\" + id1 + \") with pessimistic force increment lock\");\n+            resetSQL();\n+            e1 = em.find(type, id1, LockModeType.PESSIMISTIC_FORCE_INCREMENT, props);\n+            getLog().info(\" *\" + (e1 != null ? \"F\" : \"Can not f\") + \"ind entity\");\n+            verify.findPessimisticForcIncDbSQL(em);\n+            getLog().info(\" *Found entity:\" + e1);\n+            assertNotNull(\" *Found \" + entityName + \"(\" + id1 + \")\", e1);\n+            assertEquals(\" *Assert pessimistic force increment lock applied\", LockModeType.PESSIMISTIC_FORCE_INCREMENT,\n+                    em.getLockMode(e1));\n+\n+            getLog().info(\"Committing transaction.\");\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            e0 = e1 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        try {\n+            getLog().info(\"-- Test query with pessimistic read lock in \" + scope + \" scope\");\n+            em = emf.createEntityManager();\n+            getLog().info(\" *Begin a transaction.\");\n+            em.getTransaction().begin();\n+            resetSQL();\n+            int beforeReadLevel = getConfiguration(em).getReadLockLevelConstant();\n+            LockModeType beforeReadMode = MixedLockLevelsHelper.fromLockLevel(beforeReadLevel);\n+            getLog().info(\" *Save ReadLockLevel before Query:\" + beforeReadMode);\n+            getLog().info(\" *Query \" + entityName + \"(\" + id0 + \") with PESSIMISTIC_READ lock\");\n+            Query q = em.createQuery(queryString);\n+            if (extended) {\n+                q = q.setHint(\"javax.persistence.lock.scope\", PessimisticLockScope.EXTENDED);\n+            }\n+            q = q.setLockMode(LockModeType.PESSIMISTIC_READ);\n+            q = q.setParameter(\"firstName\", \"firstName%\" + id0);\n+            List<T> es = q.getResultList();\n+            getLog().info(\" *Found \" + es.size() + \" entity\");\n+            assertEquals(\" *Should find 1 entity\", es.size(), 1);\n+            verify.queryPessimisticReadDbSQL(em);\n+            e0 = es.get(0);\n+            getLog().info(\" *Found entity:\" + e0);\n+            assertNotNull(\" *Found \" + entityName + \"(\" + id0 + \")\", e0);\n+            assertEquals(\"Assert pessimistic read lock applied\", LockModeType.PESSIMISTIC_READ, em.getLockMode(e0));\n+            assertEquals(\" *Read lock should still be \" + beforeReadMode + \"after query set lock mode\",\n+                    beforeReadLevel, getConfiguration(em).getReadLockLevelConstant());\n+\n+            getLog().info(\n+                    \" *Find \" + entityName + \"(\" + id1\n+                            + \") with no lock to verify query lock set does not affect em lock mode.\");\n+            resetSQL();\n+            e1 = em.find(type, id1);\n+            getLog().info(\" *\" + (e1 != null ? \"F\" : \"Can not f\") + \"ind entity\");\n+            verify.findNoLockAfterQueryPessimisticReadDbSQL(em);\n+            getLog().info(\" *Found entity:\" + e1);\n+            assertNotNull(\" *Found \" + entityName + \"(\" + id1 + \")\", e1);\n+            assertEquals(\" *Assert default lock applied\", LockModeType.NONE, em.getLockMode(e1));\n+\n+            getLog().info(\"Committing transaction.\");\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            e0 = e1 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        try {\n+            getLog().info(\"-- Test name query with pessimistic write lock in \" + scope + \" scope\");\n+            em = emf.createEntityManager();\n+            getLog().info(\" *Begin a transaction.\");\n+            em.getTransaction().begin();\n+            resetSQL();\n+            int beforeReadLevel = getConfiguration(em).getReadLockLevelConstant();\n+            LockModeType beforeReadMode = MixedLockLevelsHelper.fromLockLevel(beforeReadLevel);\n+            getLog().info(\" *Save ReadLockLevel before Query:\" + beforeReadMode);\n+            getLog().info(\" *Query \" + entityName + \"(\" + id0 + \") with PESSIMISTIC_WRITE lock\");\n+            Query q = em.createNamedQuery(namedQueryString);\n+            if (extended) {\n+                q = q.setHint(\"javax.persistence.lock.scope\", PessimisticLockScope.EXTENDED);\n+            }\n+            q = q.setParameter(\"firstName\", \"firstName%\" + id0);\n+            List<T> es = q.getResultList();\n+            getLog().info(\" *Found \" + es.size() + \" entity\");\n+            assertEquals(\" *Found 1 entity\", es.size(), 1);\n+            verify.namedQueryPessimisticWriteDbSql(em);\n+            e0 = es.get(0);\n+            getLog().info(\" *Found entity:\" + e0);\n+            assertNotNull(\" *Found \" + entityName + \"(\" + id0 + \")\", e0);\n+            assertEquals(\"Assert pessimistic write lock applied\", LockModeType.PESSIMISTIC_WRITE, em.getLockMode(e0));\n+\n+            getLog().info(\" *Ensure ReadLockLevel remains at level \" + beforeReadMode);\n+            assertEquals(\" *Read lock should still be \" + beforeReadMode + \"after query set lock mode\",\n+                    beforeReadLevel, getConfiguration(em).getReadLockLevelConstant());\n+\n+            getLog().info(\n+                    \" *Find \" + entityName + \"(\" + id1\n+                            + \") with no lock to verify query lock set does not affect em lock mode.\");\n+            resetSQL();\n+            e1 = em.find(type, id1);\n+            getLog().info(\" *\" + (e1 != null ? \"F\" : \"Can not f\") + \"ind an entity\");\n+            verify.findNoLockAfterNamedQueryPessimisticWriteDbSql(em);\n+            getLog().info(\" *Found entity:\" + e1);\n+            assertNotNull(\" *Found \" + entityName + \"(\" + id1 + \")\", e1);\n+            assertEquals(\" *Assert default lock applied\", LockModeType.NONE, em.getLockMode(e1));\n+\n+            getLog().info(\"Committing transaction.\");\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            e0 = e1 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+    }\n+\n+    protected interface AssertCallback {\n+        public void findNoLockDbSQL(EntityManager em);\n+\n+        public void findPessimisticForcIncDbSQL(EntityManager em);\n+\n+        public void queryPessimisticReadDbSQL(EntityManager em);\n+\n+        public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em);\n+\n+        public void namedQueryPessimisticWriteDbSql(EntityManager em);\n+\n+        public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em);\n+    }\n+}"},{"sha":"bfc602442165f28349573c09d7a77f73f8b38913","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1x1LockScope.java","status":"added","additions":937,"deletions":0,"changes":937,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1x1LockScope.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1x1LockScope.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1x1LockScope.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,937 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import javax.persistence.EntityManager;\n+\n+/**\n+ * LockScopeTestCase subclass to test entity with:\n+ * - Uni-1x1 - eager fetch (default) \n+ * - Uni-1x1 - lazy fetch \n+ * - Uni-1x1 use join table - eager fetch (default) \n+ * - Uni-1x1 use join table - lazy fetch \n+ */\n+public class Test1x1LockScope extends LockScopeTestCase {\n+\n+    public void setUp() {\n+        setUp(LSE1x1Lf.class\n+            , LSE1x1LfLzy.class\n+            , LSE1x1LfJT.class\n+            , LSE1x1LfJTLzy.class\n+            , LSE1x1Rt.class\n+            , \"openjpa.LockManager\", \"mixed\",\n+            \"openjpa.jdbc.SynchronizeMappings\", \"buildSchema(ForeignKeys=true)\"\n+        );\n+        commonSetUp(LSE1x1Lf.class\n+                , LSE1x1LfLzy.class\n+                , LSE1x1LfJT.class\n+                , LSE1x1LfJTLzy.class\n+                , LSE1x1Rt.class\n+        );\n+    }\n+\n+    public void testNormalUni1x1Lock() {\n+        common1x1Lock(\"testNormalUni1x1Lock\", 1111201, false);\n+    }\n+\n+    public void testExtendedUni1x1Lock() {\n+        common1x1Lock(\"testExtendedUni1x1Lock\", 1111211, true);\n+    }\n+\n+    private void common1x1Lock(String testName, int idLf0, boolean extended) {\n+        final String tableLfName = \"LSE1x1Lf\";\n+        final String tableRtName = \"LSE1x1Rt\";\n+        final String joinTables  = tableLfName + \".*JOIN.*\" + tableRtName;\n+        getLog().info(\"** \" + testName + \"()\");\n+        String scope = extended ? \"Extended\" : \"Normal\";\n+        int idRt0 = idLf0 + 10000; // right table\n+        int idLf1 = idLf0 + 1;\n+        int idRt1 = idRt0 + 1;\n+\n+        // create test entity.\n+        LSE1x1Lf eLf0 = new LSE1x1Lf();\n+        LSE1x1Rt eRt0 = new LSE1x1Rt();\n+        eLf0.setId(idLf0);\n+        eLf0.setFirstName(\"firstName \" + idLf0);\n+        eLf0.setUniRight(eRt0);\n+        eRt0.setId(idRt0);\n+        eRt0.setLastName(\"lastName \" + idRt0);\n+        LSE1x1Lf eLf1 = new LSE1x1Lf();\n+        LSE1x1Rt eRt1 = new LSE1x1Rt();\n+        eLf1.setId(idLf1);\n+        eLf1.setFirstName(\"firstName \" + idLf1);\n+        eLf1.setUniRight(eRt1);\n+        eRt1.setId(idRt1);\n+        eRt1.setLastName(\"lastName \" + idRt1);\n+       \n+        EntityManager em = null;\n+        try {\n+            em = emf.createEntityManager();\n+            em.getTransaction().begin();\n+            em.persist(eLf0);\n+            em.persist(eRt0);\n+            em.persist(eLf1);\n+            em.persist(eRt1);\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            eLf0 = eLf1 = null;\n+            eRt0 = eRt1 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        commonLockTest(testName, LSE1x1Lf.class, idLf0, extended,\n+                \"SELECT c FROM LSE1x1Lf c WHERE c.firstName LIKE :firstName\", \"findLSE1x1Lf\" + scope,\n+                new AssertCallback() {\n+                    public void findNoLockDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.id, t1.version, t1.lastName FROM LSE1x1Lf t0\n+                            //      LEFT OUTER JOIN LSE1x1Rt t1 ON t0.UNIRIGHT_ID = t1.id WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 1111201]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.id, t1.version, t1.lastName \n+                            //      FROM LSE1x1Lf t0, LSE1x1Rt t1 WHERE t0.id = ? AND t0.UNIRIGHT_ID = t1.id(+) \n+                            //      [params=(int) 1111201]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n+                                    + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t1.id, t1.version, t1.lastName FROM LSE1x1Lf t0\n+                            //      LEFT OUTER JOIN LSE1x1Rt t1 ON t0.UNIRIGHT_ID = t1.id WHERE t0.id = ?\n+                            //      [params=(int) 1111201]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void findPessimisticForcIncDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.id, t1.version, t1.lastName FROM LSE1x1Lf t0\n+                            //      LEFT OUTER JOIN LSE1x1Rt t1 ON t0.UNIRIGHT_ID = t1.id WHERE t0.id = ?\n+                            //      optimize for 1 row FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 1111202]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ?\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 1121202]                                                                                                                                 \n+                            // SELECT t0.version FROM LSE1x1Lf t0 WHERE t0.id = ?\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 1111202]\n+                            assertLockTestSQLs(Select + joinTables + Where + DB2Lock);\n+                            break;\n+                        case oracle:    // TODO: if jpa2, DO NOT lock LSE1x1RT using \"FOR UPDATE OF col\"\n+                            // SELECT t0.version, t0.firstName, t1.id, t1.version, t1.lastName \n+                            //      FROM LSE1x1Lf t0, LSE1x1Rt t1 WHERE t0.id = ? AND t0.UNIRIGHT_ID = t1.id(+) \n+                            //      FOR UPDATE [params=(int) 1111202]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? FOR UPDATE [params=(int) 1121202]\n+                            // SELECT t0.version FROM LSE1x1Lf t0 WHERE t0.id = ? FOR UPDATE [params=(int) 1111202]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n+                                    + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock.\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.version, t0.firstName, t1.id, t1.version, t1.lastName FROM LSE1x1Lf t0\n+                            //      LEFT OUTER JOIN LSE1x1Rt t1 ON t0.UNIRIGHT_ID = t1.id WHERE t0.id = ?\n+                            //      [params=(int) 1111202]\n+                            // SELECT t0.id FROM LSE1x1Rt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1121202]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1121202]\n+                            // SELECT t0.id FROM LSE1x1Lf t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1111202]\n+                            // SELECT t0.version FROM LSE1x1Lf t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1111202]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + tableLfName + \".*\" + Where + ForUpdate,\n+                                    Select + tableRtName + \".*\" + Where + ForUpdate\n+                                    );\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void queryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName, t1.id, t1.version, t1.lastName FROM LSE1x1Lf t0\n+                            //      LEFT OUTER JOIN LSE1x1Rt t1 ON t0.UNIRIGHT_ID = t1.id\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(String) firstName%1111201]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ?  [params=(int) 1121201]\n+                            // SELECT t0.version FROM LSE1x1Lf t0 WHERE t0.id = ?  [params=(int) 1111201]\n+                            assertLockTestSQLs(Select + joinTables + Where + DB2Lock);\n+                            break;\n+                        case oracle:    // TODO: if jpa2, DO NOT lock LSE1x1RT using \"FOR UPDATE OF col\"\n+                            // SELECT t0.id, t0.version, t0.firstName, t1.id, t1.version, t1.lastName \n+                            //      FROM LSE1x1Lf t0, LSE1x1Rt t1 \n+                            //      WHERE (t0.firstName LIKE ?) AND t0.UNIRIGHT_ID = t1.id(+) \n+                            //      FOR UPDATE [params=(String) firstName%1111201]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? [params=(int) 1121201]\n+                            // SELECT t0.version FROM LSE1x1Lf t0 WHERE t0.id = ? [params=(int) 1111201]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n+                                    + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock.\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            //SELECT t0.id, t0.version, t0.firstName, t1.id, t1.version, t1.lastName FROM LSE1x1Lf t0\n+                            //      LEFT OUTER JOIN LSE1x1Rt t1 ON t0.UNIRIGHT_ID = t1.id\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') [params=(String) firstName%1111201]\n+                            // SELECT t0.id FROM LSE1x1Rt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1121201]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? [params=(int) 1121201]\n+                            // SELECT t0.id FROM LSE1x1Lf t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1111201]\n+                            // SELECT t0.version FROM LSE1x1Lf t0 WHERE t0.id = ? [params=(int) 1111201]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + tableLfName + \".*\" + Where + ForUpdate,\n+                                    Select + tableRtName + \".*\" + Where + ForUpdate\n+                                    );\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.id, t1.version, t1.lastName FROM LSE1x1Lf t0\n+                            //      LEFT OUTER JOIN LSE1x1Rt t1 ON t0.UNIRIGHT_ID = t1.id WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 1111202]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.id, t1.version, t1.lastName \n+                            //      FROM LSE1x1Lf t0, LSE1x1Rt t1 WHERE t0.id = ? AND t0.UNIRIGHT_ID = t1.id(+) \n+                            //      [params=(int) 1111202]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n+                                    + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t1.id, t1.version, t1.lastName FROM LSE1x1Lf t0\n+                            //      LEFT OUTER JOIN LSE1x1Rt t1 ON t0.UNIRIGHT_ID = t1.id WHERE t0.id = ?\n+                            //      [params=(int) 1111202]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName, t1.id, t1.version, t1.lastName FROM LSE1x1Lf t0\n+                            //      LEFT OUTER JOIN LSE1x1Rt t1 ON t0.UNIRIGHT_ID = t1.id\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(String) firstName%1111201]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ?  [params=(int) 1121201]\n+                            // SELECT t0.version FROM LSE1x1Lf t0 WHERE t0.id = ?  [params=(int) 1111201]\n+                            assertLockTestSQLs(Select + joinTables + Where + DB2Lock);\n+                            break;\n+                        case oracle:    // TODO: if jpa2, DO NOT lock LSE1x1RT using \"FOR UPDATE OF col\"\n+                            // SELECT t0.id, t0.version, t0.firstName, t1.id, t1.version, t1.lastName \n+                            //      FROM LSE1x1Lf t0, LSE1x1Rt t1 \n+                            //      WHERE (t0.firstName LIKE ?) AND t0.UNIRIGHT_ID = t1.id(+) \n+                            //      FOR UPDATE [params=(String) firstName%1111201]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? [params=(int) 1121201]\n+                            // SELECT t0.version FROM LSE1x1Lf t0 WHERE t0.id = ? [params=(int) 1111201]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n+                                    + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock.\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName, t1.id, t1.version, t1.lastName FROM LSE1x1Lf t0\n+                            //      LEFT OUTER JOIN LSE1x1Rt t1 ON t0.UNIRIGHT_ID = t1.id\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') [params=(String) firstName%1111201]\n+                            // SELECT t0.id FROM LSE1x1Rt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1121201]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? [params=(int) 1121201]\n+                            // SELECT t0.id FROM LSE1x1Lf t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1111201]\n+                            // SELECT t0.version FROM LSE1x1Lf t0 WHERE t0.id = ? [params=(int) 1111201]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + tableLfName + \".*\" + Where + ForUpdate,\n+                                    Select + tableRtName + \".*\" + Where + ForUpdate\n+                                    );\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.id, t1.version, t1.lastName FROM LSE1x1Lf t0\n+                            //      LEFT OUTER JOIN LSE1x1Rt t1 ON t0.UNIRIGHT_ID = t1.id WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 1111202]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.id, t1.version, t1.lastName \n+                            //      FROM LSE1x1Lf t0, LSE1x1Rt t1 WHERE t0.id = ? AND t0.UNIRIGHT_ID = t1.id(+) \n+                            //      [params=(int) 1111202]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n+                                    + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t1.id, t1.version, t1.lastName FROM LSE1x1Lf t0\n+                            //      LEFT OUTER JOIN LSE1x1Rt t1 ON t0.UNIRIGHT_ID = t1.id WHERE t0.id = ?\n+                            //      [params=(int) 1111202]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    public void testNormalUni1x1LazyLock() {\n+        common1x1LazyLock(\"testNormalUni1x1LazyLock\", 1111101, false);\n+    }\n+\n+    public void testExtendedUni1x1LazyLock() {\n+        common1x1LazyLock(\"testExtendedUni1x1LazyLock\", 1111111, true);\n+    }\n+\n+    private void common1x1LazyLock(String testName, int idLf0, boolean extended) {\n+        final String tableLfName = \"LSE1x1LfLzy\";\n+//        final String tableRtName = \"LockSEUni1x1RT\";\n+        getLog().info(\"** \" + testName + \"()\");\n+        String scope = extended ? \"Extended\" : \"Normal\";\n+        int idRt0 = idLf0 + 10000; // right table\n+        int idLf1 = idLf0 + 1;\n+        int idRt1 = idRt0 + 1;\n+\n+        // create test entity.\n+        LSE1x1LfLzy eLf0 = new LSE1x1LfLzy();\n+        LSE1x1Rt eRt0 = new LSE1x1Rt();\n+        eLf0.setId(idLf0);\n+        eLf0.setFirstName(\"firstName \" + idLf0);\n+        eLf0.setUniRight(eRt0);\n+        eRt0.setId(idRt0);\n+        eRt0.setLastName(\"lastName \" + idRt0);\n+        LSE1x1LfLzy eLf1 = new LSE1x1LfLzy();\n+        LSE1x1Rt eRt1 = new LSE1x1Rt();\n+        eLf1.setId(idLf1);\n+        eLf1.setFirstName(\"firstName \" + idLf1);\n+        eLf1.setUniRight(eRt1);\n+        eRt1.setId(idRt1);\n+        eRt1.setLastName(\"lastName \" + idRt1);\n+       \n+        EntityManager em = null;\n+        try {\n+            em = emf.createEntityManager();\n+            em.getTransaction().begin();\n+            em.persist(eLf0);\n+            em.persist(eRt0);\n+            em.persist(eLf1);\n+            em.persist(eRt1);\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            eLf0 = eLf1 = null;\n+            eRt0 = eRt1 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        commonLockTest(testName, LSE1x1LfLzy.class, idLf0, extended,\n+                \"SELECT c FROM LSE1x1LfLzy c WHERE c.firstName LIKE :firstName\", \"findLSE1x1LfLzy\" + scope,\n+                new AssertCallback() {\n+                    public void findNoLockDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfLzy t0 WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 1111101]\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfLzy t0 WHERE t0.id = ? \n+                            //      [params=(int) 1111101]\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfLzy t0 WHERE t0.id = ?\n+                            //      [params=(int) 1111101]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void findPessimisticForcIncDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfLzy t0 WHERE t0.id = ?\n+                            //      optimize for 1 row FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS\n+                            //      [params=(int) 1111102]\n+                            // SELECT t0.version FROM LSE1x1LfLzy t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 1111102]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfLzy t0 WHERE t0.id = ? \n+                            //      FOR UPDATE [params=(int) 1111102]\n+                            // SELECT t0.version FROM LSE1x1LfLzy t0 WHERE t0.id = ? FOR UPDATE [params=(int) 1111102]\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfLzy t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 1111102]\n+                            // SELECT t0.version FROM LSE1x1LfLzy t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 1111102]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void queryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1x1LfLzy t0 \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(String) firstName%1111101]\n+                            // SELECT t0.version FROM LSE1x1LfLzy t0 WHERE t0.id = ?  [params=(int) 1111101]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1x1LfLzy t0 WHERE (t0.firstName LIKE ?)\n+                            //      FOR UPDATE [params=(String) firstName%1111101]\n+                            // SELECT t0.version FROM LSE1x1LfLzy t0 WHERE t0.id = ? [params=(int) 1111101]\n+                        case derby:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1x1LfLzy t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR\n+                            //      [params=(String) firstName%1111101]\n+                            // SELECT t0.version FROM LSE1x1LfLzy t0 WHERE t0.id = ? [params=(int) 1111101]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfLzy t0 WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 1111102]\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfLzy t0 WHERE t0.id = ? \n+                            //      [params=(int) 1111102]\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfLzy t0 WHERE t0.id = ?\n+                            //      [params=(int) 1111102]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1x1LfLzy t0 \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(String) firstName%1111101]\n+                            // SELECT t0.version FROM LSE1x1LfLzy t0 WHERE t0.id = ?  [params=(int) 1111101]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1x1LfLzy t0 WHERE (t0.firstName LIKE ?) \n+                            //      FOR UPDATE [params=(String) firstName%1111101]\n+                            // SELECT t0.version FROM LSE1x1LfLzy t0 WHERE t0.id = ? [params=(int) 1111101]\n+                        case derby:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1x1LfLzy t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR\n+                            //      [params=(String) firstName%1111101]\n+                            // SELECT t0.version FROM LSE1x1LfLzy t0 WHERE t0.id = ? [params=(int) 1111101]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfLzy t0 WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 1111102]\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfLzy t0 WHERE t0.id = ? \n+                            //      [params=(int) 1111102]\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfLzy t0 WHERE t0.id = ?\n+                            //      [params=(int) 1111102]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoForUpdate);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    public void testNormalUni1x1JTLock() {\n+        common1x1JTLock(\"testNormalUni1x1JTLock\", 1112201, false);\n+    }\n+\n+    public void testExtendedUni1x1JTLock() {\n+        common1x1JTLock(\"testExtendedUni1x1JTLock\", 1112211, true);\n+    }\n+\n+    private void common1x1JTLock(String testName, int idLf0, boolean extended) {\n+        final String tableLfName = \"LSE1x1LfJT\";\n+        final String tableJTName = \"Uni1x1LfJT_Uni1x1RT\";\n+        final String tableRtName = \"LSE1x1Rt\";\n+        final String joinTables  = tableLfName + \".*JOIN.*\" + tableJTName + \".*JOIN.*\" + tableRtName;\n+        \n+        getLog().info(\"** \" + testName + \"()\");\n+        String scope = extended ? \"Extended\" : \"Normal\";\n+        int idRt0 = idLf0 + 10000; // right table\n+        int idLf1 = idLf0 + 1;\n+        int idRt1 = idRt0 + 1;\n+\n+        // create test entity.\n+        LSE1x1LfJT eLf0 = new LSE1x1LfJT();\n+        LSE1x1Rt eRt0 = new LSE1x1Rt();\n+        eLf0.setId(idLf0);\n+        eLf0.setFirstName(\"firstName \" + idLf0);\n+        eLf0.setUniRightJT(eRt0);\n+        eRt0.setId(idRt0);\n+        eRt0.setLastName(\"lastName \" + idRt0);\n+        LSE1x1LfJT eLf1 = new LSE1x1LfJT();\n+        LSE1x1Rt eRt1 = new LSE1x1Rt();\n+        eLf1.setId(idLf1);\n+        eLf1.setFirstName(\"firstName \" + idLf1);\n+        eLf1.setUniRightJT(eRt1);\n+        eRt1.setId(idRt1);\n+        eRt1.setLastName(\"lastName \" + idRt1);\n+       \n+        EntityManager em = null;\n+        try {\n+            em = emf.createEntityManager();\n+            em.getTransaction().begin();\n+            em.persist(eLf0);\n+            em.persist(eRt0);\n+            em.persist(eLf1);\n+            em.persist(eRt1);\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            eLf0 = eLf1 = null;\n+            eRt0 = eRt1 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        commonLockTest(testName, LSE1x1LfJT.class, idLf0, extended,\n+                \"SELECT c FROM LSE1x1LfJT c WHERE c.firstName LIKE :firstName\", \"findLSE1x1LfJT\" + scope,\n+                new AssertCallback() {\n+                    public void findNoLockDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t2.id, t2.version, t2.lastName FROM LSE1x1LfJT t0 \n+                            //      INNER JOIN Uni1x1LfJT_Uni1x1RT t1 ON t0.id = t1.LSE1X1LFJT_ID \n+                            //      LEFT OUTER JOIN LSE1x1Rt t2 ON t1.UNIRIGHTJT_ID = t2.id WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 1112201]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1x1LfJT t0, Uni1x1LfJT_Uni1x1RT t1, LSE1x1Rt t2 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSE1X1LFJT_ID AND t1.UNIRIGHTJT_ID = t2.id(+) \n+                            //      [params=(int) 1112201]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t2.id, t2.version, t2.lastName FROM LSE1x1LfJT t0\n+                            //      INNER JOIN Uni1x1LfJT_Uni1x1RT t1 ON t0.id = t1.LSE1X1LFJT_ID \n+                            //      LEFT OUTER JOIN LSE1x1Rt t2 ON t1.UNIRIGHTJT_ID = t2.id WHERE t0.id = ?\n+                            //      [params=(int) 1112201]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void findPessimisticForcIncDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t2.id, t2.version, t2.lastName FROM LSE1x1LfJT t0 \n+                            //      INNER JOIN Uni1x1LfJT_Uni1x1RT t1 ON t0.id = t1.LSE1X1LFJT_ID \n+                            //      LEFT OUTER JOIN LSE1x1Rt t2 ON t1.UNIRIGHTJT_ID = t2.id WHERE t0.id = ?\n+                            //      optimize for 1 row FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 1112202]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ?  FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 1122202]\n+                            // SELECT t0.version FROM LSE1x1LfJT t0 WHERE t0.id = ?  FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 1112202]\n+                            assertLockTestSQLs(Select + joinTables + Where + DB2Lock);\n+                            break;\n+                        case oracle:    // TODO: If jpa2, DO NOT lock LSE1x1RT using \"FOR UDPATE OF col\"\n+                            // SELECT t0.version, t0.firstName, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1x1LfJT t0, Uni1x1LfJT_Uni1x1RT t1, LSE1x1Rt t2\n+                            //      WHERE t0.id = ? AND t0.id = t1.LSE1X1LFJT_ID AND t1.UNIRIGHTJT_ID = t2.id(+) \n+                            //      FOR UPDATE [params=(int) 1112202]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? FOR UPDATE [params=(int) 1122202]\n+                            // SELECT t0.version FROM LSE1x1LfJT t0 WHERE t0.id = ? FOR UPDATE [params=(int) 1112202]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + \"\\\\(\\\\+\\\\).*\" + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock, if jpa2/extended scope, LOCK Uni1x1LfJT_Uni1x1RT\n+                                        // DO NOT lock LSE1x1Rt\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.version, t0.firstName, t2.id, t2.version, t2.lastName FROM LSE1x1LfJT t0\n+                            //      INNER JOIN Uni1x1LfJT_Uni1x1RT t1 ON t0.id = t1.LSE1X1LFJT_ID\n+                            //      LEFT OUTER JOIN LSE1x1Rt t2 ON t1.UNIRIGHTJT_ID = t2.id WHERE t0.id = ?\n+                            //      [params=(int) 1112202]\n+                            // SELECT t0.id FROM LSE1x1Rt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1122202]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1122202]\n+                            // SELECT t0.id FROM LSE1x1LfJT t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1112202]\n+                            // SELECT t0.version FROM LSE1x1LfJT t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1112202]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + tableLfName + \".*\" + Where + ForUpdate,\n+                                    Select + tableRtName + \".*\" + Where + ForUpdate\n+                                    );\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void queryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName, t2.id, t2.version, t2.lastName FROM LSE1x1LfJT t0\n+                            //      INNER JOIN Uni1x1LfJT_Uni1x1RT t1 ON t0.id = t1.LSE1X1LFJT_ID \n+                            //      LEFT OUTER JOIN LSE1x1Rt t2 ON t1.UNIRIGHTJT_ID = t2.id \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(String) firstName%1112201]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ?  [params=(int) 1122201]\n+                            // SELECT t0.version FROM LSE1x1LfJT t0 WHERE t0.id = ?  [params=(int) 1112201]\n+                            assertLockTestSQLs(Select + joinTables + Where + DB2Lock);\n+                            break;\n+                        case oracle:    // TODO: If jpa2, DO NOT lock LSE1x1RT using \"FOR UDPATE OF col\"\n+                            // SELECT t0.id, t0.version, t0.firstName, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1x1LfJT t0, Uni1x1LfJT_Uni1x1RT t1, LSE1x1Rt t2 \n+                            //      WHERE (t0.firstName LIKE ?) AND t0.id = t1.LSE1X1LFJT_ID \n+                            //      AND t1.UNIRIGHTJT_ID = t2.id(+) FOR UPDATE [params=(String) firstName%1112201]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? [params=(int) 1122201]\n+                            // SELECT t0.version FROM LSE1x1LfJT t0 WHERE t0.id = ? [params=(int) 1112201]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + \"\\\\(\\\\+\\\\).*\" + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock, if jpa2/extended scope, LOCK Uni1x1LfJT_Uni1x1RT\n+                                        // DO NOT lock LSE1x1Rt\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName, t2.id, t2.version, t2.lastName FROM LSE1x1LfJT t0\n+                            //      INNER JOIN Uni1x1LfJT_Uni1x1RT t1 ON t0.id = t1.LSE1X1LFJT_ID \n+                            //      LEFT OUTER JOIN LSE1x1Rt t2 ON t1.UNIRIGHTJT_ID = t2.id \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') [params=(String) firstName%1112201]\n+                            // SELECT t0.id FROM LSE1x1Rt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1122201]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? [params=(int) 1122201]\n+                            // SELECT t0.id FROM LSE1x1LfJT t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1112201]\n+                            // SELECT t0.version FROM LSE1x1LfJT t0 WHERE t0.id = ? [params=(int) 1112201]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + tableLfName + \".*\" + Where + ForUpdate,\n+                                    Select + tableRtName + \".*\" + Where + ForUpdate\n+                                    );\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t2.id, t2.version, t2.lastName FROM LSE1x1LfJT t0 \n+                            //      INNER JOIN Uni1x1LfJT_Uni1x1RT t1 ON t0.id = t1.LSE1X1LFJT_ID \n+                            //      LEFT OUTER JOIN LSE1x1Rt t2 ON t1.UNIRIGHTJT_ID = t2.id WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 1112202]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1x1LfJT t0, Uni1x1LfJT_Uni1x1RT t1, LSE1x1Rt t2 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSE1X1LFJT_ID AND t1.UNIRIGHTJT_ID = t2.id(+) \n+                            //      [params=(int) 1112202]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t2.id, t2.version, t2.lastName FROM LSE1x1LfJT t0\n+                            //      INNER JOIN Uni1x1LfJT_Uni1x1RT t1 ON t0.id = t1.LSE1X1LFJT_ID\n+                            //      LEFT OUTER JOIN LSE1x1Rt t2 ON t1.UNIRIGHTJT_ID = t2.id WHERE t0.id = ?\n+                            //      [params=(int) 1112202]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {\n+                        case db2:\n+                            //SELECT t0.id, t0.version, t0.firstName, t2.id, t2.version, t2.lastName FROM LSE1x1LfJT t0\n+                            //      INNER JOIN Uni1x1LfJT_Uni1x1RT t1 ON t0.id = t1.LSE1X1LFJT_ID\n+                            //      LEFT OUTER JOIN LSE1x1Rt t2 ON t1.UNIRIGHTJT_ID = t2.id\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(String) firstName%1112201]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ?  [params=(int) 1122201]\n+                            // SELECT t0.version FROM LSE1x1LfJT t0 WHERE t0.id = ?  [params=(int) 1112201]\n+                            assertLockTestSQLs(Select + joinTables + Where + DB2Lock);\n+                            break;\n+                        case oracle:    // TODO: If jpa2, DO NOT lock LSE1x1RT using \"FOR UDPATE OF col\"\n+                            // SELECT t0.id, t0.version, t0.firstName, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1x1LfJT t0, Uni1x1LfJT_Uni1x1RT t1, LSE1x1Rt t2 \n+                            //      WHERE (t0.firstName LIKE ?) AND t0.id = t1.LSE1X1LFJT_ID \n+                            //      AND t1.UNIRIGHTJT_ID = t2.id(+) FOR UPDATE [params=(String) firstName%1112201]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? [params=(int) 1122201]\n+                            // SELECT t0.version FROM LSE1x1LfJT t0 WHERE t0.id = ? [params=(int) 1112201]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + \"\\\\(\\\\+\\\\).*\" + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock, if jpa2/extended scope, LOCK Uni1x1LfJT_Uni1x1RT\n+                                        // DO NOT lock LSE1x1Rt\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName, t2.id, t2.version, t2.lastName FROM LSE1x1LfJT t0\n+                            //      INNER JOIN Uni1x1LfJT_Uni1x1RT t1 ON t0.id = t1.LSE1X1LFJT_ID\n+                            //      LEFT OUTER JOIN LSE1x1Rt t2 ON t1.UNIRIGHTJT_ID = t2.id\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') [params=(String) firstName%1112201]\n+                            // SELECT t0.id FROM LSE1x1Rt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1122201]\n+                            // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? [params=(int) 1122201]\n+                            // SELECT t0.id FROM LSE1x1LfJT t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1112201]\n+                            // SELECT t0.version FROM LSE1x1LfJT t0 WHERE t0.id = ? [params=(int) 1112201]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + tableLfName + \".*\" + Where + ForUpdate,\n+                                    Select + tableRtName + \".*\" + Where + ForUpdate\n+                                    );\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t2.id, t2.version, t2.lastName FROM LSE1x1LfJT t0\n+                            //      INNER JOIN Uni1x1LfJT_Uni1x1RT t1 ON t0.id = t1.LSE1X1LFJT_ID \n+                            //      LEFT OUTER JOIN LSE1x1Rt t2 ON t1.UNIRIGHTJT_ID = t2.id WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 1112202]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1x1LfJT t0, Uni1x1LfJT_Uni1x1RT t1, LSE1x1Rt t2 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSE1X1LFJT_ID AND t1.UNIRIGHTJT_ID = t2.id(+) \n+                            //      [params=(int) 1112202]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t2.id, t2.version, t2.lastName FROM LSE1x1LfJT t0\n+                            //      INNER JOIN Uni1x1LfJT_Uni1x1RT t1 ON t0.id = t1.LSE1X1LFJT_ID\n+                            //      LEFT OUTER JOIN LSE1x1Rt t2 ON t1.UNIRIGHTJT_ID = t2.id \n+                            //      WHERE t0.id = ? [params=(int) 1112202]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    public void testNormalUni1x1JTLazyLock() {\n+        common1x1JTLazyLock(\"testNormalUni1x1JTLazyLock\", 1112101, false);\n+    }\n+\n+    public void testExtendedUni1x1JTLazyLock() {\n+        common1x1JTLazyLock(\"testExtendedUni1x1JTLazyLock\", 1112111, true);\n+    }\n+\n+    private void common1x1JTLazyLock(String testName, int idLf0, boolean extended) {\n+        final String tableLfName = \"LSE1x1LfJTLzy\";\n+//        final String tableRtName = \"LockSEUni1x1RT\";\n+        getLog().info(\"** \" + testName + \"()\");\n+        String scope = extended ? \"Extended\" : \"Normal\";\n+        int idRt0 = idLf0 + 10000; // right table\n+        int idLf1 = idLf0 + 1;\n+        int idRt1 = idRt0 + 1;\n+\n+        // create test entity.\n+        LSE1x1LfJTLzy eLf0 = new LSE1x1LfJTLzy();\n+        LSE1x1Rt eRt0 = new LSE1x1Rt();\n+        eLf0.setId(idLf0);\n+        eLf0.setFirstName(\"firstName \" + idLf0);\n+        eLf0.setUniRightJT(eRt0);\n+        eRt0.setId(idRt0);\n+        eRt0.setLastName(\"lastName \" + idRt0);\n+        LSE1x1LfJTLzy eLf1 = new LSE1x1LfJTLzy();\n+        LSE1x1Rt eRt1 = new LSE1x1Rt();\n+        eLf1.setId(idLf1);\n+        eLf1.setFirstName(\"firstName \" + idLf1);\n+        eLf1.setUniRightJT(eRt1);\n+        eRt1.setId(idRt1);\n+        eRt1.setLastName(\"lasttName \" + idRt1);\n+       \n+        EntityManager em = null;\n+        try {\n+            em = emf.createEntityManager();\n+            em.getTransaction().begin();\n+            em.persist(eLf0);\n+            em.persist(eRt0);\n+            em.persist(eLf1);\n+            em.persist(eRt1);\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            eLf0 = eLf1 = null;\n+            eRt0 = eRt1 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        commonLockTest(testName, LSE1x1LfJTLzy.class, idLf0, extended,\n+                \"SELECT c FROM LSE1x1LfJTLzy c WHERE c.firstName LIKE :firstName\", \"findLSE1x1LfJTLzy\" + scope,\n+                new AssertCallback() {\n+                    public void findNoLockDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfJTLzy t0 WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 1112101]\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfJTLzy t0 WHERE t0.id = ? \n+                            //  [params=(int) 1112101]\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfJTLzy t0 WHERE t0.id = ?\n+                            //      [params=(int) 1112101]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void findPessimisticForcIncDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfJTLzy t0 WHERE t0.id = ? \n+                            //      optimize for 1 row FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS\n+                            //      [params=(int) 1112102]\n+                            // SELECT t0.version FROM LSE1x1LfJTLzy t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 1112102]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfJTLzy t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 1112102]\n+                            // SELECT t0.version FROM LSE1x1LfJTLzy t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 1112102]\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfJTLzy t0 WHERE t0.id = ? FOR UPDATE \n+                            //      [params=(int) 1112102]\n+                            // SELECT t0.version FROM LSE1x1LfJTLzy t0 WHERE t0.id = ? FOR UPDATE [params=(int) 1112102]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void queryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1x1LfJTLzy t0 \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(String) firstName%1112101]\n+                            // SELECT t0.version FROM LSE1x1LfJTLzy t0 WHERE t0.id = ?  [params=(int) 1112101]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1x1LfJTLzy t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR\n+                            //      [params=(String) firstName%1112101]\n+                            // SELECT t0.version FROM LSE1x1LfJTLzy t0 WHERE t0.id = ? [params=(int) 1112101]\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1x1LfJTLzy t0 \n+                            //      WHERE (t0.firstName LIKE ?) FOR UPDATE [params=(String) firstName%1112101]\n+                            // SELECT t0.version FROM LSE1x1LfJTLzy t0 WHERE t0.id = ? [params=(int) 1112101]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfJTLzy t0 WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 1112102]\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoDB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfJTLzy t0 WHERE t0.id = ?\n+                            //      [params=(int) 1112102]\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfJTLzy t0 WHERE t0.id = ? \n+                            //      [params=(int) 1112102]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1x1LfJTLzy t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')  \n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(String) firstName%1112101]\n+                            // SELECT t0.version FROM LSE1x1LfJTLzy t0 WHERE t0.id = ?  [params=(int) 1112101]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1x1LfJTLzy t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR\n+                            //      [params=(String) firstName%1112101]\n+                            // SELECT t0.version FROM LSE1x1LfJTLzy t0 WHERE t0.id = ? [params=(int) 1112101]\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1x1LfJTLzy t0 \n+                            //      WHERE (t0.firstName LIKE ?) FOR UPDATE [params=(String) firstName%1112101]\n+                            // SELECT t0.version FROM LSE1x1LfJTLzy t0 WHERE t0.id = ? [params=(int) 1112101]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfJTLzy t0 WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 1112102]\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoDB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfJTLzy t0 WHERE t0.id = ?\n+                            //      [params=(int) 1112102]\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1x1LfJTLzy t0 WHERE t0.id = ?\n+                            //      [params=(int) 1112102]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoForUpdate);\n+                        }\n+                    }\n+                });\n+    }\n+}"},{"sha":"00b54e34d5910a7b8c63a11fc806ce64866c762e","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1xmLockScope.java","status":"added","additions":1126,"deletions":0,"changes":1126,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1xmLockScope.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1xmLockScope.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1xmLockScope.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,1126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import javax.persistence.EntityManager;\n+\n+/**\n+ * LockScopeTestCase subclass to test entity with:\n+ * - Uni-1xm - lazy fetch (default) \n+ * - Uni-1xm - eager fetch \n+ * - Uni-1xm use join table - lazy fetch (default) \n+ * - Uni-1xm use join table - eager fetch \n+ */\n+public class Test1xmLockScope extends LockScopeTestCase {\n+\n+    public void setUp() {\n+        setUp(LSE1xmLf.class\n+            , LSE1xmLfEgr.class\n+            , LSE1xmLfJT.class\n+            , LSE1xmLfJTEgr.class\n+            , LSE1xmRt.class\n+            , \"openjpa.LockManager\", \"mixed\",\n+            \"openjpa.jdbc.SynchronizeMappings\", \"buildSchema(ForeignKeys=true)\"\n+        );\n+        commonSetUp(LSE1xmLf.class\n+            , LSE1xmLfEgr.class\n+            , LSE1xmLfJT.class\n+            , LSE1xmLfJTEgr.class\n+            , LSE1xmRt.class\n+        );\n+    }\n+\n+    public void testNormalUni1xmLock() {\n+        common1xmLock(\"testNormalUni1xmLock\", 2111101, false);\n+    }\n+\n+    public void testExtendedUni1xmLock() {\n+        common1xmLock(\"testExtendedUni1xmLock\", 2111111, true);\n+    }\n+\n+    private void common1xmLock(String testName, int idLf0, boolean extended) {\n+        final String tableLfName = \"LSE1xmLf\";\n+//        final String tableRtName = \"LSE1xmRt\";\n+//        final String joinTables  = tableLfName + \".*JOIN.*\" + tableRtName;\n+        getLog().info(\"** \" + testName + \"()\");\n+        String scope = extended ? \"Extended\" : \"Normal\";\n+        int idRt00 = idLf0 + 10000; // right table\n+        int idRt01 = idRt00 + 1;\n+        int idLf1  = idLf0 + 1;\n+        int idRt10 = idLf1 + 10000 + 1; // right table\n+        int idRt11 = idRt10 + 1;\n+        // create test entity.\n+        LSE1xmLf eLf0 = new LSE1xmLf();\n+        LSE1xmRt eRt00 = new LSE1xmRt();\n+        LSE1xmRt eRt01 = new LSE1xmRt();\n+        eLf0.setId(idLf0);\n+        eLf0.setFirstName(\"firstName \" + idLf0);\n+        eLf0.addUnitRight(eRt00);\n+        eLf0.addUnitRight(eRt01);\n+        eRt00.setId(idRt00);\n+        eRt00.setLastName(\"lastName \" + idRt00);\n+        eRt01.setId(idRt01);\n+        eRt01.setLastName(\"lastName \" + idRt01);\n+        \n+        LSE1xmLf eLf1 = new LSE1xmLf();\n+        LSE1xmRt eRt10 = new LSE1xmRt();\n+        LSE1xmRt eRt11 = new LSE1xmRt();\n+        eLf1.setId(idLf1);\n+        eLf1.setFirstName(\"firstName \" + idLf1);\n+        eLf1.addUnitRight(eRt10);\n+        eLf1.addUnitRight(eRt11);\n+        eRt10.setId(idRt10);\n+        eRt10.setLastName(\"lastName \" + idRt10);\n+        eRt11.setId(idRt11);\n+        eRt11.setLastName(\"lastName \" + idRt11);\n+       \n+        EntityManager em = null;\n+        try {\n+            em = emf.createEntityManager();\n+            em.getTransaction().begin();\n+            em.persist(eRt00);\n+            em.persist(eRt01);\n+            em.persist(eLf0);\n+            em.persist(eRt10);\n+            em.persist(eRt11);\n+            em.persist(eLf1);\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            eLf0 = eLf1 = null;\n+            eRt00 = eRt01 = eRt10 = eRt11 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        commonLockTest(testName, LSE1xmLf.class, idLf0, extended,\n+                \"SELECT c FROM LSE1xmLf c WHERE c.firstName LIKE :firstName\", \"findLSE1xmLf\" + scope,\n+                new AssertCallback() {\n+                    public void findNoLockDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLf t0 WHERE t0.id = ?  \n+                            //      optimize for 1 row [params=(int) 2111101]\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLf t0 WHERE t0.id = ? [params=(int) 2111101]\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLf t0 WHERE t0.id = ? [params=(int) 2111101]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void findPessimisticForcIncDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLf t0 WHERE t0.id = ?\n+                            //      optimize for 1 row FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS \n+                            //      [params=(int) 2111102]\n+                            // SELECT t0.version FROM LSE1xmLf t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 2111102]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLf t0 WHERE t0.id = ? FOR UPDATE \n+                            //      [params=(int) 2111102]\n+                            // SELECT t0.version FROM LSE1xmLf t0 WHERE t0.id = ? FOR UPDATE [params=(int) 2111102]\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLf t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 2111102]\n+                            // SELECT t0.version FROM LSE1xmLf t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 2111102]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void queryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLf t0 \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')  \n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(String) firstName%2111101]\n+                            // SELECT t0.version FROM LSE1xmLf t0 WHERE t0.id = ?  [params=(int) 2111101]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLf t0 WHERE (t0.firstName LIKE ?) \n+                            //      FOR UPDATE [params=(String) firstName%2111101]\n+                            // SELECT t0.version FROM LSE1xmLf t0 WHERE t0.id = ? [params=(int) 2111101] \n+                        case derby:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLf t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR\n+                            //      [params=(String) firstName%2111101]\n+                            // SELECT t0.version FROM LSE1xmLf t0 WHERE t0.id = ? [params=(int) 2111101]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLf t0 WHERE t0.id = ?  \n+                            //      optimize for 1 row [params=(int) 2111102]\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLf t0 WHERE t0.id = ? [params=(int) 2111102] \n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLf t0 WHERE t0.id = ? [params=(int) 2111102]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLf t0 \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')  \n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(String) firstName%2111101]\n+                            // SELECT t0.version FROM LSE1xmLf t0 WHERE t0.id = ?  [params=(int) 2111101]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLf t0 WHERE (t0.firstName LIKE ?) \n+                            //      FOR UPDATE [params=(String) firstName%2111101]\n+                            // SELECT t0.version FROM LSE1xmLf t0 WHERE t0.id = ? [params=(int) 2111101] \n+                        case derby:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLf t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR\n+                            //      [params=(String) firstName%2111101]\n+                            // SELECT t0.version FROM LSE1xmLf t0 WHERE t0.id = ? [params=(int) 2111101]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLf t0 WHERE t0.id = ?  \n+                            //      optimize for 1 row [params=(int) 2111102]\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLf t0 WHERE t0.id = ? [params=(int) 2111102] \n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLf t0 WHERE t0.id = ? [params=(int) 2111102]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoForUpdate);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    public void testNormalUni1xmEagerLock() {\n+        common1xmEagerLock(\"testNormalUni1xmEagerLock\", 2111201, false);\n+    }\n+\n+    public void testExtendedUni1xmEagerLock() {\n+        common1xmEagerLock(\"testExtendedUni1xmEagerLock\", 2111211, true);\n+    }\n+\n+    private void common1xmEagerLock(String testName, int idLf0, boolean extended) {\n+        final String tableLfName = \"LSE1xmLfEgr\";\n+        final String tableJTName = \"LSE1xmLfEgr_LSE1xmRt\";\n+        final String tableRtName = \"LSE1xmRt\";\n+        final String joinTables  = tableLfName + \".*JOIN.*\" + tableJTName + \".*JOIN.*\" + tableRtName;\n+        getLog().info(\"** \" + testName + \"()\");\n+        String scope = extended ? \"Extended\" : \"Normal\";\n+        int idRt00 = idLf0 + 10000; // right table\n+        int idRt01 = idRt00 + 1;\n+        int idLf1  = idLf0 + 1;\n+        int idRt10 = idLf1 + 10000 + 1; // right table\n+        int idRt11 = idRt10 + 1;\n+        // create test entity.\n+        LSE1xmLfEgr eLf0 = new LSE1xmLfEgr();\n+        LSE1xmRt eRt00 = new LSE1xmRt();\n+        LSE1xmRt eRt01 = new LSE1xmRt();\n+        eLf0.setId(idLf0);\n+        eLf0.setFirstName(\"firstName \" + idLf0);\n+        eLf0.addUnitRight(eRt00);\n+        eLf0.addUnitRight(eRt01);\n+        eRt00.setId(idRt00);\n+        eRt00.setLastName(\"lastName \" + idRt00);\n+        eRt01.setId(idRt01);\n+        eRt01.setLastName(\"lastName \" + idRt01);\n+        \n+        LSE1xmLfEgr eLf1 = new LSE1xmLfEgr();\n+        LSE1xmRt eRt10 = new LSE1xmRt();\n+        LSE1xmRt eRt11 = new LSE1xmRt();\n+        eLf1.setId(idLf1);\n+        eLf1.setFirstName(\"firstName \" + idLf1);\n+        eLf1.addUnitRight(eRt10);\n+        eLf1.addUnitRight(eRt11);\n+        eRt10.setId(idRt10);\n+        eRt10.setLastName(\"lastName \" + idRt10);\n+        eRt11.setId(idRt11);\n+        eRt11.setLastName(\"lastName \" + idRt11);\n+       \n+        EntityManager em = null;\n+        try {\n+            em = emf.createEntityManager();\n+            em.getTransaction().begin();\n+            em.persist(eRt00);\n+            em.persist(eRt01);\n+            em.persist(eLf0);\n+            em.persist(eRt10);\n+            em.persist(eRt11);\n+            em.persist(eLf1);\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            eLf0 = eLf1 = null;\n+            eRt00 = eRt01 = eRt10 = eRt11 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        commonLockTest(testName, LSE1xmLfEgr.class, idLf0, extended,\n+                \"SELECT c FROM LSE1xmLfEgr c WHERE c.firstName LIKE :firstName\", \"findLSE1xmLfEgr\"\n+                        + scope,\n+                new AssertCallback() {\n+                    public void findNoLockDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfEgr t0 LEFT OUTER JOIN LSE1xmLfEgr_LSE1xmRt t1 \n+                            //      ON t0.id = t1.LSE1XMLFEGR_ID LEFT OUTER JOIN LSE1xmRt t2 \n+                            //      ON t1.UNIRIGHT_ID = t2.id WHERE t0.id = ?  [params=(int) 2111201]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfEgr t0, LSE1xmLfEgr_LSE1xmRt t1, LSE1xmRt t2 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSE1XMLFEGR_ID(+) AND t1.UNIRIGHT_ID = t2.id(+) \n+                            //      [params=(int) 2111201] \n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfEgr t0 LEFT OUTER JOIN LSE1xmLfEgr_LSE1xmRt t1 \n+                            //      ON t0.id = t1.LSE1XMLFEGR_ID LEFT OUTER JOIN LSE1xmRt t2 ON t1.UNIRIGHT_ID = t2.id\n+                            //      WHERE t0.id = ? [params=(int) 2111201]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void findPessimisticForcIncDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfEgr t0 LEFT OUTER JOIN LSE1xmLfEgr_LSE1xmRt t1 \n+                            //      ON t0.id = t1.LSE1XMLFEGR_ID LEFT OUTER JOIN LSE1xmRt t2 \n+                            //      ON t1.UNIRIGHT_ID = t2.id WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 2111202]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 2121204]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 2121203]\n+                            // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 2111202]\n+                            assertLockTestSQLs(Select + joinTables + Where + DB2Lock);\n+                            break;\n+                        case oracle:    // TODO: if jpa2, DO NOT lock LSE1xmRT using \"FOR UPDATE OF col\"\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfEgr t0, LSE1xmLfEgr_LSE1xmRt t1, LSE1xmRt t2 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSE1XMLFEGR_ID(+) AND t1.UNIRIGHT_ID = t2.id(+) \n+                            //      FOR UPDATE [params=(int) 2111202]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE [params=(int) 2121203]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE [params=(int) 2121204]\n+                            // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ? FOR UPDATE [params=(int) 2111202]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + \"\\\\(\\\\+\\\\).*\" + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock. If jpa2, DO NOT lock LSE1xmRt, \n+                                        // if jpa2/extended, LOCK LSE1xmLfEgr_LSE1xmRt\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFEGR_ID, t2.id, t2.version, t2.lastName\n+                            //      FROM LSE1xmLfEgr t0 LEFT OUTER JOIN LSE1xmLfEgr_LSE1xmRt t1\n+                            //      ON t0.id = t1.LSE1XMLFEGR_ID LEFT OUTER JOIN LSE1xmRt t2 ON t1.UNIRIGHT_ID = t2.id\n+                            //      WHERE t0.id = ? [params=(int) 2111202]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 2121203]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 2121203]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 2121204]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 2121204]\n+                            // SELECT t0.id FROM LSE1xmLfEgr t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 2111202]\n+                            // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 2111202]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + tableLfName + Where + ForUpdate,\n+                                    Select + tableRtName + Where + ForUpdate,\n+                                    Select + tableRtName + Where + ForUpdate\n+                                    );\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void queryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:       //TODO: **Non-atomic lock. if jpa2, DO NOT lock LSE1xmRt\n+                                        // if jpa2/extended, LOCK LSE1xmLfEgr_LSE1xmRt\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfEgr t0 \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')  \n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(String) firstName%2111201]\n+                            // SELECT t0.id, t2.id, t2.version, t2.lastName FROM LSE1xmLfEgr t0 \n+                            //      INNER JOIN LSE1xmLfEgr_LSE1xmRt t1 ON t0.id = t1.LSE1XMLFEGR_ID \n+                            //      INNER JOIN LSE1xmRt t2 ON t1.UNIRIGHT_ID = t2.id \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') ORDER BY t0.id ASC  \n+                            //      [params=(String) firstName%2111201]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(int) 2121201]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?  [params=(int) 2121201]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(int) 2121202]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?  [params=(int) 2121202]\n+                            // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ?  [params=(int) 2111201]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock,\n+                                    Select + joinTables + Where + NoDB2Lock,\n+                                    Select + tableRtName + Where + DB2Lock,\n+                                    Select + tableRtName + Where + DB2Lock);\n+                            break;\n+                        case oracle:    // TODO: if jpa2, DO NOT lock LSE1xmRT using \"FOR UPDATE OF col\"\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfEgr t0 WHERE (t0.firstName LIKE ?) \n+                            //      FOR UPDATE [params=(String) firstName%2111201]\n+                            // SELECT t0.id, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfEgr t0, LSE1xmLfEgr_LSE1xmRt t1, LSE1xmRt t2 \n+                            //      WHERE (t0.firstName LIKE ?) AND t0.id = t1.LSE1XMLFEGR_ID AND t1.UNIRIGHT_ID = t2.id\n+                            //      ORDER BY t0.id ASC FOR UPDATE [params=(String) firstName%2111201]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2121202]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2121201]\n+                            // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ? [params=(int) 2111201]\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate,\n+                                    Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock. If jpa2, DO NOT lock LSE1xmRt, \n+                                        // if jpa2/extended, LOCK LSE1xmLfEgr_LSE1xmRt\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfEgr t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR\n+                            //      [params=(String) firstName%2111201]\n+                            // SELECT t0.id, t2.id, t2.version, t2.lastName FROM LSE1xmLfEgr t0\n+                            //      INNER JOIN LSE1xmLfEgr_LSE1xmRt t1 ON t0.id = t1.LSE1XMLFEGR_ID\n+                            //      INNER JOIN LSE1xmRt t2 ON t1.UNIRIGHT_ID = t2.id\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') ORDER BY t0.id ASC\n+                            //      [params=(String) firstName%2111201]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 2121202]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2121202]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 2121201]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2121201]\n+                            // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ? [params=(int) 2111201]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + tableLfName + Where + ForUpdate,\n+                                    Select + tableRtName + Where + ForUpdate,\n+                                    Select + tableRtName + Where + ForUpdate\n+                                    );\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfEgr t0 LEFT OUTER JOIN LSE1xmLfEgr_LSE1xmRt t1 \n+                            //      ON t0.id = t1.LSE1XMLFEGR_ID LEFT OUTER JOIN LSE1xmRt t2 \n+                            //      ON t1.UNIRIGHT_ID = t2.id WHERE t0.id = ?  [params=(int) 2111202]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfEgr t0, LSE1xmLfEgr_LSE1xmRt t1, LSE1xmRt t2 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSE1XMLFEGR_ID(+) AND t1.UNIRIGHT_ID = t2.id(+) \n+                            //      [params=(int) 2111202] \n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFEGR_ID, t2.id, t2.version, t2.lastName\n+                            //      FROM LSE1xmLfEgr t0 LEFT OUTER JOIN LSE1xmLfEgr_LSE1xmRt t1\n+                            //      ON t0.id = t1.LSE1XMLFEGR_ID LEFT OUTER JOIN LSE1xmRt t2\n+                            //      ON t1.UNIRIGHT_ID = t2.id WHERE t0.id = ? [params=(int) 2111202]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:   //TODO: **Non-atomic lock. if jpa2, DO NOT lock LSE1xmRt\n+                                    // if jpa2/extended, LOCK LSE1xmLfEgr_LSE1xmRt\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfEgr t0 \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')  \n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(String) firstName%2111201]\n+                            // SELECT t0.id, t2.id, t2.version, t2.lastName FROM LSE1xmLfEgr t0 \n+                            //      INNER JOIN LSE1xmLfEgr_LSE1xmRt t1 ON t0.id = t1.LSE1XMLFEGR_ID \n+                            //      INNER JOIN LSE1xmRt t2 ON t1.UNIRIGHT_ID = t2.id \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') ORDER BY t0.id ASC  \n+                            //      [params=(String) firstName%2111201]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(int) 2121201]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?  [params=(int) 2121201]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(int) 2121202]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?  [params=(int) 2121202]\n+                            // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ?  [params=(int) 2111201]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock,\n+                                    Select + joinTables + Where + NoDB2Lock,\n+                                    Select + tableRtName + Where + DB2Lock,\n+                                    Select + tableRtName + Where + DB2Lock);\n+                            break;\n+                        case oracle:    // TODO: if jpa2, DO NOT lock LSE1xmRT using \"FOR UPDATE OF col\"\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfEgr t0 WHERE (t0.firstName LIKE ?) \n+                            //      FOR UPDATE [params=(String) firstName%2111201]\n+                            // SELECT t0.id, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfEgr t0, LSE1xmLfEgr_LSE1xmRt t1, LSE1xmRt t2 \n+                            //      WHERE (t0.firstName LIKE ?) AND t0.id = t1.LSE1XMLFEGR_ID AND t1.UNIRIGHT_ID = t2.id \n+                            //      ORDER BY t0.id ASC FOR UPDATE [params=(String) firstName%2111201]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2121202]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2121201]\n+                            // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ? [params=(int) 2111201]\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate,\n+                                    Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock. If jpa2, DO NOT lock LSE1xmRt, \n+                                        // if jpa2/extended, LOCK LSE1xmLfEgr_LSE1xmRt\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfEgr t0 \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR\n+                            //      [params=(String) firstName%2111201]\n+                            // SELECT t0.id, t2.id, t2.version, t2.lastName FROM LSE1xmLfEgr t0\n+                            //      INNER JOIN LSE1xmLfEgr_LSE1xmRt t1 ON t0.id = t1.LSE1XMLFEGR_ID\n+                            //      INNER JOIN LSE1xmRt t2 ON t1.UNIRIGHT_ID = t2.id\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') ORDER BY t0.id ASC\n+                            //      [params=(String) firstName%2111201]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 2121202]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2121202]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 2121201]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2121201]\n+                            // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ? [params=(int) 2111201]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + tableLfName + Where + ForUpdate,\n+                                    Select + tableRtName + Where + ForUpdate,\n+                                    Select + tableRtName + Where + ForUpdate\n+                                    );\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfEgr t0 LEFT OUTER JOIN LSE1xmLfEgr_LSE1xmRt t1 \n+                            //      ON t0.id = t1.LSE1XMLFEGR_ID LEFT OUTER JOIN LSE1xmRt t2 \n+                            //      ON t1.UNIRIGHT_ID = t2.id WHERE t0.id = ?  [params=(int) 2111202]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfEgr t0, LSE1xmLfEgr_LSE1xmRt t1, LSE1xmRt t2 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSE1XMLFEGR_ID(+) AND t1.UNIRIGHT_ID = t2.id(+) \n+                            //      [params=(int) 2111202]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFEGR_ID, t2.id, t2.version, t2.lastName\n+                            //      FROM LSE1xmLfEgr t0 LEFT OUTER JOIN LSE1xmLfEgr_LSE1xmRt t1\n+                            //      ON t0.id = t1.LSE1XMLFEGR_ID LEFT OUTER JOIN LSE1xmRt t2\n+                            //      ON t1.UNIRIGHT_ID = t2.id WHERE t0.id = ? [params=(int) 2111202]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    public void testNormalUni1xmJTLock() {\n+        common1xmJTLock(\"testNormalUni1xmJTLock\", 2112101, false);\n+    }\n+\n+    public void testExtendedUni1xmJTLock() {\n+        common1xmJTLock(\"testExtendedUni1xmJTLock\", 2112111, true);\n+    }\n+\n+    private void common1xmJTLock(String testName, int idLf0, boolean extended) {\n+        final String tableLfName = \"LSE1xmLfJT\";\n+//        final String tableRtName = \"LSE1xmRt\";\n+//        final String joinTables  = tableLfName + \".*JOIN.*\" + tableRtName;\n+        getLog().info(\"** \" + testName + \"()\");\n+        String scope = extended ? \"Extended\" : \"Normal\";\n+        int idRt00 = idLf0 + 10000; // right table\n+        int idRt01 = idRt00 + 1;\n+        int idLf1  = idLf0 + 1;\n+        int idRt10 = idLf1 + 10000 + 1; // right table\n+        int idRt11 = idRt10 + 1;\n+        // create test entity.\n+        LSE1xmLfJT eLf0 = new LSE1xmLfJT();\n+        LSE1xmRt eRt00 = new LSE1xmRt();\n+        LSE1xmRt eRt01 = new LSE1xmRt();\n+        eLf0.setId(idLf0);\n+        eLf0.setFirstName(\"firstName \" + idLf0);\n+        eLf0.addUnitRight(eRt00);\n+        eLf0.addUnitRight(eRt01);\n+        eRt00.setId(idRt00);\n+        eRt00.setLastName(\"lastName \" + idRt00);\n+        eRt01.setId(idRt01);\n+        eRt01.setLastName(\"lastName \" + idRt01);\n+        \n+        LSE1xmLfJT eLf1 = new LSE1xmLfJT();\n+        LSE1xmRt eRt10 = new LSE1xmRt();\n+        LSE1xmRt eRt11 = new LSE1xmRt();\n+        eLf1.setId(idLf1);\n+        eLf1.setFirstName(\"firstName \" + idLf1);\n+        eLf1.addUnitRight(eRt10);\n+        eLf1.addUnitRight(eRt11);\n+        eRt10.setId(idRt10);\n+        eRt10.setLastName(\"lastName \" + idRt10);\n+        eRt11.setId(idRt11);\n+        eRt11.setLastName(\"lastName \" + idRt11);\n+       \n+        EntityManager em = null;\n+        try {\n+            em = emf.createEntityManager();\n+            em.getTransaction().begin();\n+            em.persist(eRt00);\n+            em.persist(eRt01);\n+            em.persist(eLf0);\n+            em.persist(eRt10);\n+            em.persist(eRt11);\n+            em.persist(eLf1);\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            eLf0 = eLf1 = null;\n+            eRt00 = eRt01 = eRt10 = eRt11 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        commonLockTest(testName, LSE1xmLfJT.class, idLf0, extended,\n+                \"SELECT c FROM LSE1xmLfJT c WHERE c.firstName LIKE :firstName\", \"findLSE1xmLfJT\" + scope,\n+                new AssertCallback() {\n+                    public void findNoLockDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLfJT t0 WHERE t0.id = ?  \n+                            //      optimize for 1 row [params=(int) 2112101]\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLfJT t0 WHERE t0.id = ? [params=(int) 2112101]\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLfJT t0 WHERE t0.id = ? [params=(int) 2112101]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void findPessimisticForcIncDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLfJT t0 WHERE t0.id = ?  \n+                            //      optimize for 1 row FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS \n+                            //      [params=(int) 2112102]\n+                            // SELECT t0.version FROM LSE1xmLfJT t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 2112102]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLfJT t0 WHERE t0.id = ? FOR UPDATE \n+                            //      [params=(int) 2112102]\n+                            // SELECT t0.version FROM LSE1xmLfJT t0 WHERE t0.id = ? FOR UPDATE [params=(int) 2112102] \n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLfJT t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 2112102]\n+                            // SELECT t0.version FROM LSE1xmLfJT t0 WHERE t0.id = ? FOR UPDATE WITH RR \n+                            //      [params=(int) 2112102]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void queryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfJT t0 \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')  \n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(String) firstName%2112101]\n+                            // SELECT t0.version FROM LSE1xmLfJT t0 WHERE t0.id = ?  [params=(int) 2112101]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfJT t0 WHERE (t0.firstName LIKE ?) \n+                            //      FOR UPDATE [params=(String) firstName%2112101]\n+                            // SELECT t0.version FROM LSE1xmLfJT t0 WHERE t0.id = ? [params=(int) 2112101] \n+                        case derby:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfJT t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR\n+                            //      [params=(String) firstName%2112101]\n+                            // SELECT t0.version FROM LSE1xmLfJT t0 WHERE t0.id = ? [params=(int) 2112101]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLfJT t0 WHERE t0.id = ? \n+                            //      optimize for 1 row [params=(int) 2112102]\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLfJT t0 WHERE t0.id = ? [params=(int) 2112102] \n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLfJT t0 WHERE t0.id = ? [params=(int) 2112102]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfJT t0 \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')  \n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(String) firstName%2112101]\n+                            // SELECT t0.version FROM LSE1xmLfJT t0 WHERE t0.id = ?  [params=(int) 2112101]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfJT t0 WHERE (t0.firstName LIKE ?) \n+                            //      FOR UPDATE [params=(String) firstName%2112101]\n+                            // SELECT t0.version FROM LSE1xmLfJT t0 WHERE t0.id = ? [params=(int) 2112101] \n+                        case derby:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfJT t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR\n+                            //      [params=(String) firstName%2112101]\n+                            // SELECT t0.version FROM LSE1xmLfJT t0 WHERE t0.id = ? [params=(int) 2112101]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLfJT t0 WHERE t0.id = ?  \n+                            //      optimize for 1 row [params=(int) 2112102]\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLfJT t0 WHERE t0.id = ? [params=(int) 2112102] \n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSE1xmLfJT t0 WHERE t0.id = ? [params=(int) 2112102]\n+                        default:\n+                            assertLockTestSQLs(Select + tableLfName + Where + NoForUpdate);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    public void testNormalUni1xmJTEagerLock() {\n+        common1xmJTEagerLock(\"testNormalUni1xmJTEagerLock\", 2112201, false);\n+    }\n+\n+    public void testExtendedUni1xmJTEagerLock() {\n+        common1xmJTEagerLock(\"testExtendedUni1xmJTEagerLock\", 2112211, true);\n+    }\n+\n+    private void common1xmJTEagerLock(String testName, int idLf0, boolean extended) {\n+        final String tableLfName = \"LSE1xmLfJTEgr\";\n+        final String tableJTName = \"LSE1xmLfJTEgr_LSE1xmRt\";\n+        final String tableRtName = \"LSE1xmRt\";\n+        final String joinTables  = tableLfName + \".*JOIN.*\" + tableJTName + \".*JOIN.*\" + tableRtName;\n+        getLog().info(\"** \" + testName + \"()\");\n+        String scope = extended ? \"Extended\" : \"Normal\";\n+        int idRt00 = idLf0 + 10000; // right table\n+        int idRt01 = idRt00 + 1;\n+        int idLf1  = idLf0 + 1;\n+        int idRt10 = idLf1 + 10000 + 1; // right table\n+        int idRt11 = idRt10 + 1;\n+        // create test entity.\n+        LSE1xmLfJTEgr eLf0 = new LSE1xmLfJTEgr();\n+        LSE1xmRt eRt00 = new LSE1xmRt();\n+        LSE1xmRt eRt01 = new LSE1xmRt();\n+        eLf0.setId(idLf0);\n+        eLf0.setFirstName(\"firstName \" + idLf0);\n+        eLf0.addUnitRight(eRt00);\n+        eLf0.addUnitRight(eRt01);\n+        eRt00.setId(idRt00);\n+        eRt00.setLastName(\"lastName \" + idRt00);\n+        eRt01.setId(idRt01);\n+        eRt01.setLastName(\"lastName \" + idRt01);\n+        \n+        LSE1xmLfJTEgr eLf1 = new LSE1xmLfJTEgr();\n+        LSE1xmRt eRt10 = new LSE1xmRt();\n+        LSE1xmRt eRt11 = new LSE1xmRt();\n+        eLf1.setId(idLf1);\n+        eLf1.setFirstName(\"firstName \" + idLf1);\n+        eLf1.addUnitRight(eRt10);\n+        eLf1.addUnitRight(eRt11);\n+        eRt10.setId(idRt10);\n+        eRt10.setLastName(\"lastName \" + idRt10);\n+        eRt11.setId(idRt11);\n+        eRt11.setLastName(\"lastName \" + idRt11);\n+       \n+        EntityManager em = null;\n+        try {\n+            em = emf.createEntityManager();\n+            em.getTransaction().begin();\n+            em.persist(eRt00);\n+            em.persist(eRt01);\n+            em.persist(eLf0);\n+            em.persist(eRt10);\n+            em.persist(eRt11);\n+            em.persist(eLf1);\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            eLf0 = eLf1 = null;\n+            eRt00 = eRt01 = eRt10 = eRt11 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        commonLockTest(testName, LSE1xmLfJTEgr.class, idLf0, extended,\n+                \"SELECT c FROM LSE1xmLfJTEgr c WHERE c.firstName LIKE :firstName\", \"findLSE1xmLfJTEgr\"\n+                        + scope,\n+                new AssertCallback() {\n+                    public void findNoLockDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFJTEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfJTEgr t0 LEFT OUTER JOIN LSE1xmLfJTEgr_LSE1xmRt t1 \n+                            //      ON t0.id = t1.LSE1XMLFJTEGR_ID LEFT OUTER JOIN LSE1xmRt t2 \n+                            //      ON t1.UNIRIGHT_ID = t2.id WHERE t0.id = ?  [params=(int) 2112201]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFJTEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfJTEgr t0, LSE1xmLfJTEgr_LSE1xmRt t1, LSE1xmRt t2 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSE1XMLFJTEGR_ID(+) AND t1.UNIRIGHT_ID = t2.id(+) \n+                            //      [params=(int) 2112201]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFJTEGR_ID, t2.id, t2.version, t2.lastName\n+                            //      FROM LSE1xmLfJTEgr t0 LEFT OUTER JOIN LSE1xmLfJTEgr_LSE1xmRt t1\n+                            //      ON t0.id = t1.LSE1XMLFJTEGR_ID LEFT OUTER JOIN LSE1xmRt t2\n+                            //      ON t1.UNIRIGHT_ID = t2.id WHERE t0.id = ? [params=(int) 2112201]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void findPessimisticForcIncDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFJTEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfJTEgr t0 LEFT OUTER JOIN LSE1xmLfJTEgr_LSE1xmRt t1 \n+                            //      ON t0.id = t1.LSE1XMLFJTEGR_ID LEFT OUTER JOIN LSE1xmRt t2 \n+                            //      ON t1.UNIRIGHT_ID = t2.id WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 2112202]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 2122203]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?  \n+                             //     FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 2122204]\n+                            // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 2112202]\n+                            assertLockTestSQLs(Select + joinTables + Where + DB2Lock);\n+                            break;\n+                        case oracle:    // TODO: if jpa2, DO NOT lock LSE1xmRT using \"FOR UPDATE OF col\"\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFJTEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfJTEgr t0, LSE1xmLfJTEgr_LSE1xmRt t1, LSE1xmRt t2 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSE1XMLFJTEGR_ID(+) AND t1.UNIRIGHT_ID = t2.id(+) \n+                            //      FOR UPDATE [params=(int) 2112202]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE [params=(int) 2122203]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE [params=(int) 2122204]\n+                            // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ? FOR UPDATE [params=(int) 2112202]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + \"\\\\(\\\\+\\\\).*\" + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock. If jpa2, DO NOT lock LSE1xmRt, \n+                                        // if jpa2/extended, LOCK LSE1xmLfJTEgr_LSE1xmRt\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFJTEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfJTEgr t0 LEFT OUTER JOIN LSE1xmLfJTEgr_LSE1xmRt t1\n+                            //      ON t0.id = t1.LSE1XMLFJTEGR_ID LEFT OUTER JOIN LSE1xmRt t2\n+                            //      ON t1.UNIRIGHT_ID = t2.id WHERE t0.id = ? [params=(int) 2112202]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 2122203]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 2122203]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 2122204]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 2122204]\n+                            // SELECT t0.id FROM LSE1xmLfJTEgr t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 2112202]\n+                            // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 2112202]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + tableLfName + Where + ForUpdate,\n+                                    Select + tableRtName + Where + ForUpdate,\n+                                    Select + tableRtName + Where + ForUpdate\n+                                    );\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void queryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:       //TODO: **Non-atomic lock. if jpa2, DO NOT lock LSE1xmRt\n+                                        // if jpa2/extended, LOCK LSE1xmLfJTEgr_LSE1xmRt\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfJTEgr t0 \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')  \n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(String) firstName%2112201]\n+                            // SELECT t0.id, t2.id, t2.version, t2.lastName FROM LSE1xmLfJTEgr t0 \n+                            //      INNER JOIN LSE1xmLfJTEgr_LSE1xmRt t1 ON t0.id = t1.LSE1XMLFJTEGR_ID \n+                            //      INNER JOIN LSE1xmRt t2 ON t1.UNIRIGHT_ID = t2.id \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') ORDER BY t0.id ASC  \n+                            //      [params=(String) firstName%2112201]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(int) 2122201]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?  [params=(int) 2122201]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(int) 2122202]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?  [params=(int) 2122202]\n+                            // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ?  [params=(int) 2112201]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock,\n+                                    Select + joinTables + Where + NoDB2Lock,\n+                                    Select + tableRtName + Where + DB2Lock,\n+                                    Select + tableRtName + Where + DB2Lock);\n+                            break;\n+                        case oracle:    // TODO: if jpa2, DO NOT lock LSE1xmRT using \"FOR UPDATE OF col\"\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfJTEgr t0 WHERE (t0.firstName LIKE ?) \n+                            //      FOR UPDATE [params=(String) firstName%2112201]\n+                            // SELECT t0.id, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfJTEgr t0, LSE1xmLfJTEgr_LSE1xmRt t1, LSE1xmRt t2 \n+                            //      WHERE (t0.firstName LIKE ?) AND t0.id = t1.LSE1XMLFJTEGR_ID \n+                            //      AND t1.UNIRIGHT_ID = t2.id ORDER BY t0.id ASC FOR UPDATE \n+                            //      [params=(String) firstName%2112201]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2122201]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2122202]\n+                            // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ? [params=(int) 2112201]\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate,\n+                                    Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock. If jpa2, DO NOT lock LSE1xmRt, \n+                                        // if jpa2/extended, LOCK LSE1xmLfEgr_LSE1xmRt\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfJTEgr t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR\n+                            //      [params=(String) firstName%2112201]\n+                            // SELECT t0.id, t2.id, t2.version, t2.lastName FROM LSE1xmLfJTEgr t0 \n+                            //      NNER JOIN LSE1xmLfJTEgr_LSE1xmRt t1 ON t0.id = t1.LSE1XMLFJTEGR_ID\n+                            //      INNER JOIN LSE1xmRt t2 ON t1.UNIRIGHT_ID = t2.id\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') ORDER BY t0.id ASC\n+                            //      [params=(String) firstName%2112201]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 2122202]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2122202]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 2122201]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2122201]\n+                            // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ? [params=(int) 2112201]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + tableLfName + Where + ForUpdate,\n+                                    Select + tableRtName + Where + ForUpdate,\n+                                    Select + tableRtName + Where + ForUpdate\n+                                    );\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFJTEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfJTEgr t0 LEFT OUTER JOIN LSE1xmLfJTEgr_LSE1xmRt t1 \n+                            //      ON t0.id = t1.LSE1XMLFJTEGR_ID LEFT OUTER JOIN LSE1xmRt t2 \n+                            //      ON t1.UNIRIGHT_ID = t2.id WHERE t0.id = ?  [params=(int) 2112202]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFJTEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfJTEgr t0, LSE1xmLfJTEgr_LSE1xmRt t1, LSE1xmRt t2 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSE1XMLFJTEGR_ID(+) AND t1.UNIRIGHT_ID = t2.id(+) \n+                            //      [params=(int) 2112202]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFJTEGR_ID, t2.id, t2.version, t2.lastName\n+                            //      FROM LSE1xmLfJTEgr t0 LEFT OUTER JOIN LSE1xmLfJTEgr_LSE1xmRt t1\n+                            //      ON t0.id = t1.LSE1XMLFJTEGR_ID LEFT OUTER JOIN LSE1xmRt t2\n+                            //      ON t1.UNIRIGHT_ID = t2.id WHERE t0.id = ? [params=(int) 2112202]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:   //TODO: **Non-atomic lock. if jpa2, DO NOT lock LSE1xmRt\n+                                    // if jpa2/extended, LOCK LSE1xmLfJTEgr_LSE1xmRt\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfJTEgr t0 \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')  \n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(String) firstName%2112201]\n+                            // SELECT t0.id, t2.id, t2.version, t2.lastName FROM LSE1xmLfJTEgr t0 \n+                            //      INNER JOIN LSE1xmLfJTEgr_LSE1xmRt t1 ON t0.id = t1.LSE1XMLFJTEGR_ID \n+                            //      INNER JOIN LSE1xmRt t2 ON t1.UNIRIGHT_ID = t2.id \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') ORDER BY t0.id ASC  \n+                            //      [params=(String) firstName%2112201]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(int) 2122201]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?  [params=(int) 2122201]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ?  \n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(int) 2122202]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?  [params=(int) 2122202]\n+                            // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ?  [params=(int) 2112201]\n+                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock,\n+                                    Select + joinTables + Where + NoDB2Lock,\n+                                    Select + tableRtName + Where + DB2Lock,\n+                                    Select + tableRtName + Where + DB2Lock);\n+                            break;\n+                        case oracle:    // TODO: if jpa2, DO NOT lock LSE1xmRT using \"FOR UPDATE OF col\"\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfJTEgr t0 WHERE (t0.firstName LIKE ?) \n+                            //      FOR UPDATE [params=(String) firstName%2112201]\n+                            // SELECT t0.id, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfJTEgr t0, LSE1xmLfJTEgr_LSE1xmRt t1, LSE1xmRt t2 \n+                            //      WHERE (t0.firstName LIKE ?) AND t0.id = t1.LSE1XMLFJTEGR_ID \n+                            //      AND t1.UNIRIGHT_ID = t2.id ORDER BY t0.id ASC FOR UPDATE\n+                            //      [params=(String) firstName%2112201]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2122201]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2122202]\n+                            // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ? [params=(int) 2112201]\n+                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate,\n+                                    Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock. If jpa2, DO NOT lock LSE1xmRt, \n+                                        // if jpa2/extended, LOCK LSE1xmLfEgr_LSE1xmRt\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfJTEgr t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR \n+                            //      params=(String) firstName%2112201]\n+                            // SELECT t0.id, t2.id, t2.version, t2.lastName FROM LSE1xmLfJTEgr t0\n+                            //      INNER JOIN LSE1xmLfJTEgr_LSE1xmRt t1 ON t0.id = t1.LSE1XMLFJTEGR_ID\n+                            //      INNER JOIN LSE1xmRt t2 ON t1.UNIRIGHT_ID = t2.id\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') ORDER BY t0.id ASC\n+                            //      [params=(String) firstName%2112201]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 2122202]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2122202]\n+                            // SELECT t0.id FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 2122201]\n+                            // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2122201]\n+                            // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ? [params=(int) 2112201]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + tableLfName + Where + ForUpdate,\n+                                    Select + tableRtName + Where + ForUpdate,\n+                                    Select + tableRtName + Where + ForUpdate\n+                                    );\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFJTEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfJTEgr t0 LEFT OUTER JOIN LSE1xmLfJTEgr_LSE1xmRt t1 \n+                            //      ON t0.id = t1.LSE1XMLFJTEGR_ID LEFT OUTER JOIN LSE1xmRt t2 \n+                            //      ON t1.UNIRIGHT_ID = t2.id WHERE t0.id = ?  [params=(int) 2112202]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFJTEGR_ID, t2.id, t2.version, t2.lastName \n+                            //      FROM LSE1xmLfJTEgr t0, LSE1xmLfJTEgr_LSE1xmRt t1, LSE1xmRt t2 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSE1XMLFJTEGR_ID(+) AND t1.UNIRIGHT_ID = t2.id(+) \n+                            //      [params=(int) 2112202]\n+                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                                    + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t1.LSE1XMLFJTEGR_ID, t2.id, t2.version, t2.lastName\n+                            //      FROM LSE1xmLfJTEgr t0 LEFT OUTER JOIN LSE1xmLfJTEgr_LSE1xmRt t1\n+                            //      ON t0.id = t1.LSE1XMLFJTEGR_ID LEFT OUTER JOIN LSE1xmRt t2\n+                            //      ON t1.UNIRIGHT_ID = t2.id WHERE t0.id = ? [params=(int) 2112202]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+                });\n+    }\n+}"},{"sha":"2cce55bbb5d35e71b91ad7317b55478a0f427895","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/TestBasicLockScope.java","status":"added","additions":1225,"deletions":0,"changes":1225,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/TestBasicLockScope.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/TestBasicLockScope.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/TestBasicLockScope.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,1225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lock.extended;\n+\n+import javax.persistence.EntityManager;\n+\n+/**\n+ * LockScopeTestCase subclass to test entities:\n+ * - with Basic attributes \n+ * - uses secondary table\n+ * - uses inheritance in single table\n+ * - uses inheritance and join table\n+ * - uses element collection - lazy fetch (default) \n+ * - uses element collection - eager fetch \n+ */\n+public class TestBasicLockScope extends LockScopeTestCase {\n+\n+    public void setUp() {\n+        setUp(LSEBase.class\n+            , LSESecTbl.class\n+            , LSESngTblCon.class\n+            , LSESngTblAbs.class\n+            , LSEJoinCon.class\n+            , LSEJoinAbs.class\n+            , LSEEleCol.class\n+            , LSEEleColEgr.class\n+            , \"openjpa.LockManager\", \"mixed\",\n+            \"openjpa.jdbc.SynchronizeMappings\", \"buildSchema(ForeignKeys=true)\"\n+        );\n+        commonSetUp(LSEBase.class\n+            , LSESecTbl.class\n+            , LSESngTblCon.class\n+            , LSESngTblAbs.class\n+            , LSEJoinCon.class\n+            , LSEJoinAbs.class\n+            , LSEEleCol.class\n+            , LSEEleColEgr.class\n+        );\n+    }\n+\n+    public void testNormalBasicLock() {\n+        commonBasicLock(\"testNormalBasicLock\", 000, false);\n+    }\n+\n+    public void testExtendedBasicLock() {\n+        commonBasicLock(\"testExtendedBasicLock\", 010, true);\n+    }\n+\n+    private void commonBasicLock(String testName, int id0, boolean extended) {\n+        final String tableName = \"LSEBase\";\n+        getLog().info(\"** \" + testName + \"()\");\n+        String scope = extended ? \"Extended\" : \"Normal\";\n+        int id1 = id0 + 1;\n+\n+        // create test entity.\n+        LSEBase e0 = new LSEBase();\n+        e0.setId(id0);\n+        e0.setFirstName(\"firstName \" + id0);\n+        e0.setLastName(\"lastName \" + id0);\n+        LSEBase e1 = new LSEBase();\n+        e1.setId(id1);\n+        e1.setFirstName(\"firstName \" + id1);\n+        e1.setLastName(\"lastName \" + id1);\n+\n+        EntityManager em = null;\n+        try {\n+            em = emf.createEntityManager();\n+            em.getTransaction().begin();\n+            em.persist(e0);\n+            em.persist(e1);\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            e0 = e1 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        commonLockTest(testName, LSEBase.class, id0, extended,\n+                \"SELECT c FROM LSEBase c WHERE c.firstName LIKE :firstName\", \"findLSEBase\" + scope,\n+                new AssertCallback() {\n+                    public void findNoLockDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t0.lastName FROM LSEBase t0 WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 0]\n+                            assertLockTestSQLs(Select + tableName + Where + NoDB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t0.lastName FROM LSEBase t0 WHERE t0.id = ? \n+                            //      [params=(int) 0]\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t0.lastName FROM LSEBase t0 WHERE t0.id = ? \n+                            //      [params=(int) 0]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void findPessimisticForcIncDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t0.lastName FROM LSEBase t0 WHERE t0.id = ?\n+                            //      optimize for 1 row FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 1]\n+                            // SELECT t0.version FROM LSEBase t0 WHERE t0.id = ?\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 1]\n+                            assertLockTestSQLs(Select + tableName + Where + DB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t0.lastName FROM\n+                            //     LSEBase t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1]\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t0.lastName FROM LSEBase t0 WHERE t0.id = ? FOR UPDATE \n+                            //      [params=(int) 1]\n+                            // SELECT t0.version FROM LSEBase t0 WHERE t0.id = ? FOR UPDATE [params=(int) 1]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void queryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName, t0.lastName FROM LSEBase t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(String) firstName%0]\n+                            // SELECT t0.version FROM LSEBase t0 WHERE t0.id = ?  [params=(int) 0]\n+                            assertLockTestSQLs(Select + tableName + Where + DB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.id, t0.version, t0.firstName, t0.lastName FROM LSEBase t0 WHERE (t0.firstName\n+                            //      LIKE ? ESCAPE '\\') FOR UPDATE WITH RR [params=(String) firstName%0]\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName, t0.lastName FROM LSEBase t0 \n+                            //      WHERE (t0.firstName LIKE ?) FOR UPDATE [params=(String) firstName%0]\n+                            // SELECT t0.version FROM LSEBase t0 WHERE t0.id = ? [params=(int) 0]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t0.lastName FROM LSEBase t0 WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 1]\n+                            assertLockTestSQLs(Select + tableName + Where + NoDB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t0.lastName FROM LSEBase t0 WHERE t0.id = ?\n+                            //      [params=(int) 1]\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t0.lastName FROM LSEBase t0 WHERE t0.id = ? \n+                            //      [params=(int) 1]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName, t0.lastName FROM LSEBase t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(String) firstName%0]\n+                            // SELECT t0.version FROM LSEBase t0 WHERE t0.id = ?  [params=(int) 0]\n+                            assertLockTestSQLs(Select + tableName + Where + DB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.id, t0.version, t0.firstName, t0.lastName FROM LSEBase t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName, t0.lastName FROM LSEBase t0 \n+                            //      WHERE (t0.firstName LIKE ?) FOR UPDATE [params=(String) firstName%0]\n+                            // SELECT t0.version FROM LSEBase t0 WHERE t0.id = ? [params=(int) 0]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t0.lastName FROM LSEBase t0 WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 1]\n+                            assertLockTestSQLs(Select + tableName + Where + NoDB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t0.lastName FROM LSEBase t0 WHERE t0.id = ?\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t0.lastName FROM LSEBase t0 WHERE t0.id = ? \n+                            //      [params=(int) 1]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + NoForUpdate);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    public void testNormalSecTableLock() {\n+        commonSecTableLock(\"testNormalSecTableLock\", 100, false);\n+    }\n+    \n+    public void testExtendedSecTableLock() {\n+        commonSecTableLock(\"testExtendedSecTableLock\", 110, true); \n+    }\n+\n+    private void commonSecTableLock(String testName, int id0, boolean extended) {\n+        final String table1Name = \"LSESecTbl\";\n+        final String table2Name = \"LSESecTblDtl\";\n+        final String joinTables = table1Name + \".*JOIN.*\" + table2Name;\n+        getLog().info(\"** \" + testName + \"()\");\n+        String scope = extended ? \"Extended\" : \"Normal\";\n+        int id1 = id0 + 1;\n+\n+        // create test entity.\n+        LSESecTbl e0 = new LSESecTbl();\n+        e0.setId(id0);\n+        e0.setFirstName(\"firstName \" + id0);\n+        e0.setLastName(\"lastName \" + id0);\n+        LSESecTbl e1 = new LSESecTbl();\n+        e1.setId(id1);\n+        e1.setFirstName(\"firstName \" + id1);\n+        e1.setLastName(\"lastName \" + id1);\n+\n+        EntityManager em = null;\n+        try {\n+            em = emf.createEntityManager();\n+            em.getTransaction().begin();\n+            em.persist(e0);\n+            em.persist(e1);\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            e0 = e1 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        commonLockTest(testName, LSESecTbl.class, id0, extended,\n+                \"SELECT c FROM LSESecTbl c WHERE c.firstName LIKE :firstName\", \"findLSESecTbl\" + scope,\n+                new AssertCallback() {\n+                    public void findNoLockDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n+                            //      INNER JOIN LSESecTblDtl t1 ON t0.id = t1.LSESECTBL_ID WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 100]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0, LSESecTblDtl t1 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSESECTBL_ID [params=(int) 100]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n+                            //      INNER JOIN LSESecTblDtl t1 ON t0.id = t1.LSESECTBL_ID WHERE t0.id = ?\n+                            //      [params=(int) 100]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void findPessimisticForcIncDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n+                            //      INNER JOIN LSESecTblDtl t1 ON t0.id = t1.LSESECTBL_ID WHERE t0.id = ?\n+                            //      optimize for 1 row FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 101]\n+                            // SELECT t0.version FROM LSESecTbl t0 WHERE t0.id = ?\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 101]\n+                            assertLockTestSQLs(Select + joinTables + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0, LSESecTblDtl t1 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSESECTBL_ID FOR UPDATE [params=(int) 101]\n+                            // SELECT t0.version FROM LSESecTbl t0 WHERE t0.id = ? FOR UPDATE [params=(int) 101]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock, SecTblDtl NOT locked *********\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n+                            //      INNER JOIN LSESecTblDtl t1 ON t0.id = t1.LSESECTBL_ID WHERE t0.id = ?\n+                            //      [params=(int) 101]\n+                            // SELECT t0.id FROM LSESecTbl t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 101]\n+                            // SELECT t0.version FROM LSESecTbl t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 101]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + table1Name + \".*\" + Where + ForUpdate);\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void queryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n+                            //      INNER JOIN LSESecTblDtl t1 ON t0.id = t1.LSESECTBL_ID\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(String) firstName%100]\n+                            // SELECT t0.version FROM LSESecTbl t0 WHERE t0.id = ?  [params=(int) 100]\n+                            assertLockTestSQLs(Select + joinTables + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0, LSESecTblDtl t1 \n+                            //      WHERE (t0.firstName LIKE ?) AND t0.id = t1.LSESECTBL_ID FOR UPDATE \n+                            //      [params=(String) firstName%100]\n+                            // SELECT t0.version FROM LSESecTbl t0 WHERE t0.id = ? [params=(int) 100]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock, SecTblDtl NOT locked *********\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n+                            //      INNER JOIN LSESecTblDtl t1 ON t0.id = t1.LSESECTBL_ID \n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') [params=(String) firstName%100]\n+                            // SELECT t0.id FROM LSESecTbl t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 100]\n+                            // SELECT t0.version FROM LSESecTbl t0 WHERE t0.id = ? [params=(int) 100]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + table1Name + \".*\" + Where + ForUpdate);\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0 \n+                            //      INNER JOIN LSESecTblDtl t1 ON t0.id = t1.LSESECTBL_ID WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 101]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0, LSESecTblDtl t1 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSESECTBL_ID [params=(int) 101]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n+                            //      INNER JOIN LSESecTblDtl t1 ON t0.id = t1.LSESECTBL_ID WHERE t0.id = ?\n+                            //      [params=(int) 101]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n+                            //      INNER JOIN LSESecTblDtl t1 ON t0.id = t1.LSESECTBL_ID\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(String) firstName%100]\n+                            // SELECT t0.version FROM LSESecTbl t0 WHERE t0.id = ?  [params=(int) 100]\n+                            assertLockTestSQLs(Select + joinTables + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0, LSESecTblDtl t1 \n+                            //      WHERE (t0.firstName LIKE ?) AND t0.id = t1.LSESECTBL_ID FOR UPDATE \n+                            //      [params=(String) firstName%100]\n+                            // SELECT t0.version FROM LSESecTbl t0 WHERE t0.id = ? [params=(int) 100]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock, SecTblDtl NOT locked *********\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n+                            //      INNER JOIN LSESecTblDtl t1 ON t0.id = t1.LSESECTBL_ID\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') [params=(String) firstName%100]\n+                            // SELECT t0.id FROM LSESecTbl t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 100]\n+                            // SELECT t0.version FROM LSESecTbl t0 WHERE t0.id = ? [params=(int) 100]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + table1Name + \".*\" + Where + ForUpdate);\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n+                            //      INNER JOIN LSESecTblDtl t1 ON t0.id = t1.LSESECTBL_ID WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 101]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0, LSESecTblDtl t1 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSESECTBL_ID [params=(int) 101]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n+                            //      INNER JOIN LSESecTblDtl t1 ON t0.id = t1.LSESECTBL_ID WHERE t0.id = ?\n+                            //      [params=(int) 101]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    public void testNormalSingleTableLock() {\n+        commonSingleTableLock(\"testNormalSingleTableLock\", 200, false);\n+    }\n+    \n+    public void testExtendedlSingleTableLock() {\n+        commonSingleTableLock(\"testExtendedlSingleTableLock\", 210, true);\n+    }\n+    \n+    private void commonSingleTableLock(String testName, int id0, boolean extended) {\n+        final String tableName = \"LSESngTblAbs\";\n+        getLog().info(\"** \" + testName + \"()\");\n+        String scope = extended ? \"Extended\" : \"Normal\";\n+        int id1 = id0 + 1;\n+\n+        // create test entity.\n+        LSESngTblCon e0 = new LSESngTblCon();\n+        e0.setId(id0);\n+        e0.setFirstName(\"firstName \" + id0);\n+        e0.setLastName(\"lastName \" + id0);\n+        LSESngTblCon e1 = new LSESngTblCon();\n+        e1.setId(id1);\n+        e1.setFirstName(\"firstName \" + id1);\n+        e1.setLastName(\"lastName \" + id1);\n+\n+        EntityManager em = null;\n+        try {\n+            em = emf.createEntityManager();\n+            em.getTransaction().begin();\n+            em.persist(e0);\n+            em.persist(e1);\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            e0 = e1 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        commonLockTest(testName, LSESngTblCon.class, id0, extended,\n+                \"SELECT c FROM LSESngTblAbs c WHERE c.firstName LIKE :firstName\",\n+                \"findLSESngTblCon\" + scope, new AssertCallback() {\n+\n+                    public void findNoLockDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0\n+                            //      WHERE t0.DTYPE = ? AND t0.id = ?\n+                            //      optimize for 1 row [params=(String) LSESngTblCon, (int) 200]\n+                            assertLockTestSQLs(Select + tableName + Where + NoDB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0\n+                            //      WHERE t0.DTYPE = ? AND t0.id = ? [params=(String) LSESngTblCon, (int) 200]\n+                        case oracle:\n+                            // SELECT t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0 \n+                            //      WHERE t0.DTYPE = ? AND t0.id = ? [params=(String) LSESngTblCon, (int) 200]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void findPessimisticForcIncDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0\n+                            //      WHERE t0.DTYPE = ? AND t0.id = ?\n+                            //      optimize for 1 row FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS\n+                            //      [params=(String) LSESngTblCon, (int) 201]\n+                            // SELECT t0.version FROM LSESngTblAbs t0 WHERE t0.id = ?\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 201]\n+                            assertLockTestSQLs(Select + tableName + Where + DB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0 \n+                            //      WHERE t0.DTYPE = ? AND t0.id = ? FOR UPDATE WITH RR \n+                            //      [params=(String) LSESngTblCon, (int) 201]\n+                            // SELECT t0.version FROM LSESngTblAbs t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 201]\n+                        case oracle:\n+                            // SELECT t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0 \n+                            //      WHERE t0.DTYPE = ? AND t0.id = ? FOR UPDATE \n+                            //      [params=(String) LSESngTblCon, (int) 201]\n+                            // SELECT t0.version FROM LSESngTblAbs t0 WHERE t0.id = ? FOR UPDATE [params=(int) 201]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void queryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(String) firstName%200]\n+                            // SELECT t0.version FROM LSESngTblAbs t0 WHERE t0.id = ?  [params=(int) 200]\n+                            assertLockTestSQLs(Select + tableName + Where + DB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.id, t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR\n+                            //      [params=(String) firstName%200]\n+                            // SELECT t0.version FROM LSESngTblAbs t0 WHERE t0.id = ? [params=(int) 200]\n+                        case oracle:\n+                            // SELECT t0.id, t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0 \n+                            //      WHERE (t0.firstName LIKE ?) FOR UPDATE [params=(String) firstName%200]\n+                            // SELECT t0.version FROM LSESngTblAbs t0 WHERE t0.id = ? [params=(int) 200]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0\n+                            //      WHERE t0.DTYPE = ? AND t0.id = ?\n+                            //      optimize for 1 row [params=(String) LSESngTblCon, (int) 201]\n+                            assertLockTestSQLs(Select + tableName + Where + NoDB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0\n+                            //      WHERE t0.DTYPE = ? AND t0.id = ? [params=(String) LSESngTblCon, (int) 201]\n+                        case oracle:\n+                            // SELECT t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0 \n+                            //      WHERE t0.DTYPE = ? AND t0.id = ? [params=(String) LSESngTblCon, (int) 201]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') AND t0.DTYPE = ?\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(String) firstName%200, (String) LSESngTblCon]\n+                            // SELECT t0.version FROM LSESngTblAbs t0 WHERE t0.id = ?  [params=(int) 200]\n+                            assertLockTestSQLs(Select + tableName + Where + DB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.id, t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\') AND t0.DTYPE = ? FOR UPDATE WITH RR\n+                            //      [params=(String) firstName%200, (String) LSESngTblCon]\n+                            // SELECT t0.version FROM LSESngTblAbs t0 WHERE t0.id = ? [params=(int) 200]\n+                        case oracle:\n+                            // SELECT t0.id, t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0 \n+                            //      WHERE (t0.firstName LIKE ?) AND t0.DTYPE = ? FOR UPDATE \n+                            //      [params=(String) firstName%200, (String) LSESngTblCon]\n+                            // SELECT t0.version FROM LSESngTblAbs t0 WHERE t0.id = ? [params=(int) 200]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0\n+                            //      WHERE t0.DTYPE = ? AND t0.id = ?\n+                            //      optimize for 1 row [params=(String) LSESngTblCon, (int) 201]\n+                            assertLockTestSQLs(Select + tableName + Where + NoDB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0\n+                            //      WHERE t0.DTYPE = ? AND t0.id = ? [params=(String) LSESngTblCon, (int) 201]\n+                        case oracle:\n+                            // SELECT t0.DTYPE, t0.version, t0.firstName, t0.lastName FROM LSESngTblAbs t0 \n+                            //      WHERE t0.DTYPE = ? AND t0.id = ? [params=(String) LSESngTblCon, (int) 201]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + NoForUpdate);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    public void testNormalJoinedLock() {\n+        commonJoinedLock(\"testNormalJoinedLock\", 400, false);\n+    }\n+    \n+    public void testExtendedJoinedLock() {\n+        commonJoinedLock(\"testExtendedJoinedLock\", 410, true);\n+    }\n+    \n+    private void commonJoinedLock(String testName, int id0, boolean extended) {\n+        final String table1Name = \"LSEJoinCon\";\n+        final String table2Name = \"LSEJoinAbs\";\n+        final String joinTables = table1Name + \".*JOIN.*\" + table2Name;\n+        getLog().info(\"** \" + testName + \"()\");\n+        String scope = extended ? \"Extended\" : \"Normal\";\n+        int id1 = id0 + 1;\n+\n+        // create test entity.\n+        LSEJoinCon e0 = new LSEJoinCon();\n+        e0.setId(id0);\n+        e0.setFirstName(\"firstName \" + id0);\n+        e0.setLastName(\"lastName \" + id0);\n+        LSEJoinCon e1 = new LSEJoinCon();\n+        e1.setId(id1);\n+        e1.setFirstName(\"firstName \" + id1);\n+        e1.setLastName(\"lastName \" + id1);\n+\n+        EntityManager em = null;\n+        try {\n+            em = emf.createEntityManager();\n+            em.getTransaction().begin();\n+            em.persist(e0);\n+            em.persist(e1);\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            e0 = e1 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        commonLockTest(testName, LSEJoinCon.class, id0, extended,\n+                \"SELECT c FROM LSEJoinCon c WHERE c.firstName LIKE :firstName\", \"findLSEJoinCon\"\n+                        + scope, new AssertCallback() {\n+\n+                    public void findNoLockDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0\n+                            //      INNER JOIN LSEJoinAbs t1 ON t0.id = t1.id WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 400]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0, LSEJoinAbs t1 \n+                            //      WHERE t0.id = ? AND t0.id = t1.id [params=(int) 400]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0\n+                            //      INNER JOIN LSEJoinAbs t1 ON t0.id = t1.id WHERE t0.id = ? [params=(int) 400]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void findPessimisticForcIncDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0\n+                            //      INNER JOIN LSEJoinAbs t1 ON t0.id = t1.id WHERE t0.id = ?\n+                            //      optimize for 1 row FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS[params=(int) 401]\n+                            // SELECT t0.version FROM LSEJoinAbs t0 WHERE t0.id = ?\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 401]\n+                            assertLockTestSQLs(Select + joinTables + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0, LSEJoinAbs t1 \n+                            //      WHERE t0.id = ? AND t0.id = t1.id FOR UPDATE [params=(int) 401]\n+                            // SELECT t0.version FROM LSEJoinAbs t0 WHERE t0.id = ? FOR UPDATE [params=(int) 401]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock, LSEJoinCon NOT locked *********\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0\n+                            //      INNER JOIN LSEJoinAbs t1 ON t0.id = t1.id WHERE t0.id = ? [params=(int) 401]\n+                            // SELECT t0.id FROM LSEJoinAbs t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 401]\n+                            // SELECT t0.version FROM LSEJoinAbs t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 401]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + table2Name + \".*\" + Where + ForUpdate);\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void queryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t1.id, t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0\n+                            //      INNER JOIN LSEJoinAbs t1 ON t0.id = t1.id\n+                            //      WHERE (t1.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(String) firstName%400]\n+                            // SELECT t0.version FROM LSEJoinAbs t0 WHERE t0.id = ?  [params=(int) 400]\n+                            assertLockTestSQLs(Select + joinTables + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t1.id, t0.id, t1.version, t1.firstName, t0.lastName \n+                            //      FROM LSEJoinCon t0, LSEJoinAbs t1 WHERE (t1.firstName LIKE ?) AND t0.id = t1.id \n+                            //      FOR UPDATE [params=(String) firstName%400]\n+                            // SELECT t0.version FROM LSEJoinAbs t0 WHERE t0.id = ? [params=(int) 400]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock, LSEJoinCon NOT locked *********\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t1.id, t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0\n+                            //      INNER JOIN LSEJoinAbs t1 ON t0.id = t1.id WHERE (t1.firstName LIKE ? ESCAPE '\\')\n+                            //      [params=(String) firstName%400]\n+                            // SELECT t0.id FROM LSEJoinAbs t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 400]\n+                            // SELECT t0.version FROM LSEJoinAbs t0 WHERE t0.id = ? [params=(int) 400]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + table2Name + \".*\" + Where + ForUpdate);\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0\n+                            //      INNER JOIN LSEJoinAbs t1 ON t0.id = t1.id WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 401]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0, LSEJoinAbs t1 \n+                            //      WHERE t0.id = ? AND t0.id = t1.id [params=(int) 401]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0\n+                            //      INNER JOIN LSEJoinAbs t1 ON t0.id = t1.id WHERE t0.id = ? [params=(int) 401]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t1.id, t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0\n+                            //      INNER JOIN LSEJoinAbs t1 ON t0.id = t1.id\n+                            //      WHERE (t1.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(String) firstName%400]\n+                            // SELECT t0.version FROM LSEJoinAbs t0 WHERE t0.id = ?  [params=(int) 400]\n+                            assertLockTestSQLs(Select + joinTables + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t1.id, t0.id, t1.version, t1.firstName, t0.lastName \n+                            //      FROM LSEJoinCon t0, LSEJoinAbs t1 WHERE (t1.firstName LIKE ?) AND t0.id = t1.id \n+                            //      FOR UPDATE [params=(String) firstName%400]\n+                            // SELECT t0.version FROM LSEJoinAbs t0 WHERE t0.id = ? [params=(int) 400]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            break;\n+                        case derby:     //TODO: **Non-atomic lock, LSEJoinCon NOT locked *********\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t1.id, t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0\n+                            //      INNER JOIN LSEJoinAbs t1 ON t0.id = t1.id WHERE (t1.firstName LIKE ? ESCAPE '\\')\n+                            //      [params=(String) firstName%400]\n+                            // SELECT t0.id FROM LSEJoinAbs t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 400]\n+                            // SELECT t0.version FROM LSEJoinAbs t0 WHERE t0.id = ? [params=(int) 400]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + table2Name + \".*\" + Where + ForUpdate);\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0\n+                            //      INNER JOIN LSEJoinAbs t1 ON t0.id = t1.id WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 401]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0, LSEJoinAbs t1 \n+                            //      WHERE t0.id = ? AND t0.id = t1.id [params=(int) 401]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0\n+                            //      INNER JOIN LSEJoinAbs t1 ON t0.id = t1.id WHERE t0.id = ? [params=(int) 401]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    public void testNormalElementCollectionLock() {\n+        commonElementCollectionLock(\"testNormalElementCollectionLock\", 500, false);\n+    }\n+    \n+    public void testExtendedElementCollectionLock() {\n+        commonElementCollectionLock(\"testExtendedElementCollectionLock\", 510, true);\n+    }\n+    \n+    private void commonElementCollectionLock(String testName, int id0, boolean extended) {\n+        final String tableName =\"LSEEleCol\";\n+        getLog().info(\"** \" + testName + \"()\");\n+        String scope = extended ? \"Extended\" : \"Normal\";\n+        int id1 = id0 + 1;\n+        \n+        // create test entity.\n+        LSEEleCol e0 = new LSEEleCol();\n+        e0.setId(id0);\n+        e0.setFirstName(\"firstName lazy \" + id0);\n+        e0.addCollection(id0 + \"String1\");\n+        e0.addCollection(id0 + \"String2\");\n+        LSEEleCol e1 = new LSEEleCol();\n+        e1.setId(id1);\n+        e1.setFirstName(\"lazy \" + id1);\n+        e1.addCollection(id1 + \"String1\");\n+        e1.addCollection(id1 + \"String2\");\n+\n+        EntityManager em = null;\n+        try {\n+            em = emf.createEntityManager();\n+            em.getTransaction().begin();\n+            em.persist(e0);\n+            em.persist(e1);\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            e0 = e1 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        commonLockTest(testName, LSEEleCol.class, id0, extended,\n+                \"SELECT c FROM LSEEleCol c WHERE c.firstName LIKE :firstName\", \"findLSEEleCol\" + scope,\n+                new AssertCallback() {\n+\n+                    public void findNoLockDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSEEleCol t0 WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 500]\n+                            assertLockTestSQLs(Select + tableName + Where + NoDB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSEEleCol t0 WHERE t0.id = ? [params=(int) 500]\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSEEleCol t0 WHERE t0.id = ? [params=(int) 500]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void findPessimisticForcIncDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSEEleCol t0 WHERE t0.id = ?\n+                            //      optimize for 1 row FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS\n+                            //      [params=(int) 501]\n+                            // SELECT t0.version FROM LSEEleCol t0 WHERE t0.id = ?\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 501]\n+                            assertLockTestSQLs(Select + tableName + Where + DB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSEEleCol t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 501]\n+                            // SELECT t0.version FROM LSEEleCol t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 501]\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSEEleCol t0 WHERE t0.id = ? FOR UPDATE \n+                            //      [params=(int) 501]\n+                            // SELECT t0.version FROM LSEEleCol t0 WHERE t0.id = ? FOR UPDATE [params=(int) 501]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void queryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSEEleCol t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(String) firstName%500]\n+                            // SELECT t0.version FROM LSEEleCol t0 WHERE t0.id = ?  [params=(int) 500]\n+                            assertLockTestSQLs(Select + tableName + Where + DB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSEEleCol t0 WHERE\n+                            //      (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR [params=(String) firstName%500]\n+                            // SELECT t0.version FROM LSEEleCol t0 WHERE t0.id = ? [params=(int) 500]\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSEEleCol t0 WHERE (t0.firstName LIKE ?) \n+                            //      FOR UPDATE [params=(String) firstName%500]\n+                            // SELECT t0.version FROM LSEEleCol t0 WHERE t0.id = ? [params=(int) 500]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSEEleCol t0 WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 501]\n+                            assertLockTestSQLs(Select + tableName + Where + NoDB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSEEleCol t0 WHERE t0.id = ? [params=(int) 501]\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSEEleCol t0 WHERE t0.id = ? [params=(int) 501]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSEEleCol t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(String) firstName%500]\n+                            // SELECT t0.version FROM LSEEleCol t0 WHERE t0.id = ?  [params=(int) 500]\n+                            assertLockTestSQLs(Select + tableName + Where + DB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSEEleCol t0 WHERE\n+                            //      (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR [params=(String) firstName%500]\n+                            // SELECT t0.version FROM LSEEleCol t0 WHERE t0.id = ? [params=(int) 500]\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSEEleCol t0 WHERE (t0.firstName LIKE ?) \n+                            //      FOR UPDATE [params=(String) firstName%500]\n+                            // SELECT t0.version FROM LSEEleCol t0 WHERE t0.id = ? [params=(int) 500]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName FROM LSEEleCol t0 WHERE t0.id = ?\n+                            //      optimize for 1 row [params=(int) 501]\n+                            assertLockTestSQLs(Select + tableName + Where + NoDB2Lock);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName FROM LSEEleCol t0 WHERE t0.id = ? [params=(int) 501]\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName FROM LSEEleCol t0 WHERE t0.id = ? [params=(int) 501]\n+                        default:\n+                            assertLockTestSQLs(Select + tableName + Where + NoForUpdate);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    public void testNormalElementCollectionEagerLock() {\n+        commonElementCollectionEagerLock(\"testNormalElementCollectionEagerLock\", 600, false);\n+    }\n+\n+    public void testExtendedElementCollectionEagerLock() {\n+        commonElementCollectionEagerLock(\"testExtendedElementCollectionEagerLock\", 610, true);\n+    }\n+    \n+    private void commonElementCollectionEagerLock(String testName, int id0, boolean extended) {\n+        final String table1Name = \"LSEEleColEgr\";\n+        final String table2Name = \"LSEEleColEgr_collection\";\n+//        final String table2Name_oracle = table2Name;//.toUpperCase().substring(0, Math.min(table2Name.length(), 30));\n+        final String joinTables = table1Name + \".*JOIN.*\" + table2Name;\n+        getLog().info(\"** \" + testName + \"()\");\n+        String scope = extended ? \"Extended\" : \"Normal\";\n+        int id1 = id0 + 1;\n+\n+        // create test entity.\n+        LSEEleColEgr e0 = new LSEEleColEgr();\n+        e0.setId(id0);\n+        e0.setFirstName(\"firstName eager \" + id0);\n+        e0.addCollection(id0 + \"String1\");\n+        e0.addCollection(id0 + \"String2\");\n+        LSEEleColEgr e1 = new LSEEleColEgr();\n+        e1.setId(id1);\n+        e1.setFirstName(\"firstName eager \" + id1);\n+        e1.addCollection(id1 + \"String1\");\n+        e1.addCollection(id1 + \"String2\");\n+\n+        EntityManager em = null;\n+        try {\n+            em = emf.createEntityManager();\n+            em.getTransaction().begin();\n+            em.persist(e0);\n+            em.persist(e1);\n+            em.getTransaction().commit();\n+        } finally {\n+            em = null;\n+            e0 = e1 = null;\n+            if (em != null && em.isOpen()) {\n+                em.close();\n+            }\n+        }\n+\n+        commonLockTest(testName, LSEEleColEgr.class, id0, extended,\n+                \"SELECT c FROM LSEEleColEgr c WHERE c.firstName LIKE :firstName\",\n+                \"findLSEEleColEgr\" + scope, new AssertCallback() {\n+\n+                    public void findNoLockDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element FROM LSEEleColEgr t0\n+                            //      LEFT OUTER JOIN LSEEleColEgr_collection t1 ON t0.id = t1.LSEELECOLEGR_ID \n+                            //      WHERE t0.id = ?  [params=(int) 600]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element \n+                            //      FROM LSEEleColEgr t0, LSEEleColEgr_collection t1 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSEELECOLEGR_ID(+) [params=(int) 600]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + \"\\\\(\\\\+\\\\).*\"\n+                                    + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element FROM LSEEleColEgr t0\n+                            //      LEFT OUTER JOIN LSEEleColEgr_collection t1 ON t0.id = t1.LSEELECOLEGR_ID\n+                            //      WHERE t0.id = ? [params=(int) 600]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void findPessimisticForcIncDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element FROM LSEEleColEgr t0\n+                            //      LEFT OUTER JOIN LSEEleColEgr_collection t1 ON t0.id = t1.LSEELECOLEGR_ID\n+                            //      WHERE t0.id = ?  FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 601]\n+                            // SELECT t0.version FROM LSEEleColEgr t0 WHERE t0.id = ?\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(int) 601]\n+                            assertLockTestSQLs(Select + joinTables + Where + DB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element \n+                            //      FROM LSEEleColEgr t0, LSEEleColEgr_collection t1 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSEELECOLEGR_ID(+) FOR UPDATE [params=(int) 601]\n+                            // SELECT t0.version FROM LSEEleColEgr t0 WHERE t0.id = ? FOR UPDATE [params=(int) 601]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + \"\\\\(\\\\+\\\\).*\"\n+                                    + NoForUpdate);\n+                            break;\n+                        case derby:     // **Non-atomic lock, No need to lock LSEEleColEgr_collection *********\n+                            // TODO: Can do the same as query below, if extended scope. i.e. select LSEEleColEgr\n+                            //          with lock and fetch element collection without lock.\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element FROM LSEEleColEgr t0\n+                            //      LEFT OUTER JOIN LSEEleColEgr_collection t1 ON t0.id = t1.LSEELECOLEGR_ID\n+                            //      WHERE t0.id = ? [params=(int) 601]\n+                            // SELECT t0.id FROM LSEEleColEgr t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 601]\n+                            // SELECT t0.version FROM LSEEleColEgr t0 WHERE t0.id = ? FOR UPDATE WITH RR\n+                            //      [params=(int) 601]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate, \n+                                    Select + table1Name + \".*\" + Where + ForUpdate);\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void queryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:     // **Non-atomic lock, No need to lock LSEEleColEgr_collection *********   \n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSEEleColEgr t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(String) firstName%600]\n+                            // SELECT t0.id, t1.element FROM LSEEleColEgr t0 INNER JOIN LSEEleColEgr_collection t1\n+                            //      ON t0.id = t1.LSEELECOLEGR_ID WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      ORDER BY t0.id ASC  [params=(String) firstName%600]\n+                            // SELECT t0.version FROM LSEEleColEgr t0 WHERE t0.id = ?  [params=(int) 600]\n+                            assertLockTestSQLs(Select + \"LSEEleColEgr.*\" + Where + DB2Lock,\n+                                    Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSEEleColEgr t0 WHERE (t0.firstName LIKE ?) \n+                            //      FOR UPDATE [params=(String) firstName%600]\n+                            // SELECT t0.id, t1.element FROM LSEEleColEgr t0, LSEEleColEgr_collection t1 \n+                            //      WHERE (t0.firstName LIKE ?) AND t0.id = t1.LSEELECOLEGR_ID ORDER BY t0.id ASC \n+                            //      FOR UPDATE [params=(String) firstName%600]\n+                            // SELECT t0.version FROM LSEEleColEgr t0 WHERE t0.id = ? [params=(int) 600]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            break;\n+                        case derby:     //**Non-atomic lock, No need to lock LSEEleColEgr_Collection *********\n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSEEleColEgr t0 WHERE\n+                            //      (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR [params=(String) firstName%600]\n+                            // SELECT t0.id, t1.element FROM LSEEleColEgr t0 INNER JOIN LSEEleColEgr_collection t1 \n+                            //      ON t0.id = t1.LSEELECOLEGR_ID WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      ORDER BY t0.id ASC [params=(String) firstName%600]\n+                            // SELECT t0.version FROM LSEEleColEgr t0 WHERE t0.id = ? [params=(int) 600]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n+                                    Select + table1Name + \".*\" + Where + ForUpdate);\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element FROM LSEEleColEgr t0\n+                            //      LEFT OUTER JOIN LSEEleColEgr_collection t1 ON t0.id = t1.LSEELECOLEGR_ID\n+                            //      WHERE t0.id = ?  [params=(int) 601]\n+                            assertLockTestSQLs(Select + \"LSEEleColEgr.*\" + Where + DB2Lock,\n+                                    Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element \n+                            //      FROM LSEEleColEgr t0, LSEEleColEgr_collection t1 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSEELECOLEGR_ID(+) [params=(int) 601]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + \"\\\\(\\\\+\\\\).*\"\n+                                    + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element FROM LSEEleColEgr t0\n+                            //      LEFT OUTER JOIN LSEEleColEgr_collection t1 ON t0.id = t1.LSEELECOLEGR_ID\n+                            //      WHERE t0.id = ? [params=(int) 601]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+\n+                    public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {\n+                        case db2:     // **Non-atomic lock, No need to lock LSEEleColEgr_collection *********   \n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSEEleColEgr t0\n+                            //      WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      FOR READ ONLY WITH RR USE AND KEEP UPDATE LOCKS [params=(String) firstName%600]\n+                            // SELECT t0.id, t1.element FROM LSEEleColEgr t0 INNER JOIN LSEEleColEgr_collection t1\n+                            //      ON t0.id = t1.LSEELECOLEGR_ID WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      ORDER BY t0.id ASC  [params=(String) firstName%600]\n+                            // SELECT t0.version FROM LSEEleColEgr t0 WHERE t0.id = ?  [params=(int) 600]\n+                            assertLockTestSQLs(Select + \"LSEEleColEgr.*\" + Where + DB2Lock,\n+                                    Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSEEleColEgr t0 WHERE (t0.firstName LIKE ?) \n+                            //      FOR UPDATE [params=(String) firstName%600]\n+                            // SELECT t0.id, t1.element FROM LSEEleColEgr t0, LSEEleColEgr_collection t1 \n+                            //      WHERE (t0.firstName LIKE ?) AND t0.id = t1.LSEELECOLEGR_ID ORDER BY t0.id ASC \n+                            //      FOR UPDATE [params=(String) firstName%600]\n+                            // SELECT t0.version FROM LSEEleColEgr t0 WHERE t0.id = ? [params=(int) 600]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            break;\n+                        case derby:     // **Non-atomic lock, No need to lock LSEEleColEgr_collection *********   \n+                            // The database is unable to lock this query.  Each object matching the query will be \n+                            //  locked individually after it is loaded; however, it is technically possible that\n+                            //  another transaction could modify the data before the lock is obtained.\n+                            // SELECT t0.id, t0.version, t0.firstName FROM LSEEleColEgr t0 WHERE\n+                            //      (t0.firstName LIKE ? ESCAPE '\\') FOR UPDATE WITH RR [params=(String) firstName%600]\n+                            // SELECT t0.id, t1.element FROM LSEEleColEgr t0 INNER JOIN LSEEleColEgr_collection t1\n+                            //      ON t0.id = t1.LSEELECOLEGR_ID WHERE (t0.firstName LIKE ? ESCAPE '\\')\n+                            //      ORDER BY t0.id ASC [params=(String) firstName%600]\n+                            // SELECT t0.version FROM LSEEleColEgr t0 WHERE t0.id = ? [params=(int) 600]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate, \n+                                    Select + table1Name + \".*\" + Where + ForUpdate);\n+                            break;\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n+                        }\n+                    }\n+\n+                    public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n+                        switch (getDBType(em)) {    // **Check\n+                        case db2:\n+                            // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element FROM LSEEleColEgr t0 \n+                            //      LEFT OUTER JOIN LSEEleColEgr_collection t1 ON t0.id = t1.LSEELECOLEGR_ID\n+                            //      WHERE t0.id = ?  [params=(int) 601]\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n+                            break;\n+                        case oracle:\n+                            // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element \n+                            //      FROM LSEEleColEgr t0, LSEEleColEgr_collection t1 \n+                            //      WHERE t0.id = ? AND t0.id = t1.LSEELECOLEGR_ID(+) [params=(int) 601]\n+                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + \"\\\\(\\\\+\\\\).*\"\n+                                    + NoForUpdate);\n+                            break;\n+                        case derby:\n+                            // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element FROM LSEEleColEgr t0\n+                            //      LEFT OUTER JOIN LSEEleColEgr_collection t1 ON t0.id = t1.LSEELECOLEGR_ID\n+                            //      WHERE t0.id = ? [params=(int) 601]\n+                        default:\n+                            assertLockTestSQLs(Select + joinTables + Where + NoForUpdate);\n+                        }\n+                    }\n+                });\n+    }\n+}"},{"sha":"509f438865a931f725cdfec0f2ea5133b6c0b25f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -61,8 +61,6 @@\n import javax.persistence.GeneratedValue;\n import javax.persistence.GenerationType;\n \n-import javax.persistence.Access;\n-import javax.persistence.AccessType;\n import javax.persistence.Id;\n import javax.persistence.IdClass;\n import javax.persistence.Lob;\n@@ -1772,7 +1770,9 @@ private void parseNamedQueries(AnnotatedElement el, NamedQuery... queries) {\n             meta.setLanguage(JPQLParser.LANG_JPQL);\n             for (QueryHint hint : query.hints())\n                 meta.addHint(hint.name(), hint.value());\n-\n+            if (query.lockMode() != null) {\n+                meta.addHint(\"openjpa.FetchPlan.ReadLockMode\", query.lockMode());\n+            }\n             meta.setSource(getSourceFile(), (el instanceof Class) ? el : null,\n                 SourceTracker.SRC_ANNOTATIONS);\n             if (isMetaDataMode())"},{"sha":"089c330cfcdeac77d16f484475be836412f084c4","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java","status":"modified","additions":11,"deletions":1,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -20,9 +20,9 @@\n \n import java.util.Collection;\n import java.util.Map;\n-import java.util.Set;\n \n import javax.persistence.LockModeType;\n+import javax.persistence.PessimisticLockScope;\n \n import org.apache.openjpa.kernel.DataCacheRetrieveMode;\n import org.apache.openjpa.kernel.DataCacheStoreMode;\n@@ -321,6 +321,16 @@\n      */\n     public FetchPlan setLockTimeout(int timeout);\n \n+    /**\n+     * The lock scope to use for locking loaded objects.\n+     */\n+    public PessimisticLockScope getLockScope();\n+\n+    /**\n+     * The lock scope to use for locking loaded objects.\n+     */\n+    public FetchPlan setLockScope(PessimisticLockScope scope);\n+\n     /**\n      * The number of milliseconds to wait for a query, or -1 for no\n      * limit."},{"sha":"a7f50c316793a572cf282dab4702d97af04716a1","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanHintHandler.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanHintHandler.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanHintHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanHintHandler.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -59,13 +59,18 @@\n         }\n         // Initialize javax.persistence to openjpa.FetchPlan hint mapping.\n         javaxHintsMap.put(JPAProperties.LOCK_TIMEOUT,  PREFIX_FETCHPLAN + \"LockTimeout\");\n+        javaxHintsMap.put(JPAProperties.LOCK_SCOPE,    PREFIX_FETCHPLAN + \"LockScope\");\n         javaxHintsMap.put(JPAProperties.QUERY_TIMEOUT, PREFIX_FETCHPLAN + \"QueryTimeout\");\n         // Initialize hint precedence order mapping from list.\n         String[][] precedenceMapList = {\n             { JPAProperties.LOCK_TIMEOUT,\n               PREFIX_FETCHPLAN  + \"LockTimeout\",\n               PREFIX_OPENJPA    + \"LockTimeout\" },\n \n+            { JPAProperties.LOCK_SCOPE,\n+              PREFIX_FETCHPLAN  + \"LockScope\",\n+              PREFIX_OPENJPA    + \"LockScope\" },\n+\n             { JPAProperties.QUERY_TIMEOUT,\n               PREFIX_FETCHPLAN  + \"QueryTimeout\",\n               PREFIX_OPENJPA    + \"QueryTimeout\" },"},{"sha":"b08e2e0018de6530d85d59212325d57b515295ef","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanImpl.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanImpl.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanImpl.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -25,6 +25,7 @@\n import java.util.Map;\n \n import javax.persistence.LockModeType;\n+import javax.persistence.PessimisticLockScope;\n \n import org.apache.openjpa.kernel.DataCacheRetrieveMode;\n import org.apache.openjpa.kernel.DataCacheStoreMode;\n@@ -237,6 +238,15 @@ public FetchPlan setLockTimeout(int timeout) {\n         return this;\n     }\n \n+    public PessimisticLockScope getLockScope() {\n+        return LockScopesHelper.fromLockScope(_fetch.getLockScope());\n+    }\n+\n+    public FetchPlan setLockScope(PessimisticLockScope scope) {\n+        _fetch.setLockScope(LockScopesHelper.toLockScope(scope));\n+        return this;\n+    }\n+\n     public int getQueryTimeout() {\n         return _fetch.getQueryTimeout();\n     }"},{"sha":"78309e994f6d58524e4f4e329039ce56185af499","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/LockScopesHelper.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/LockScopesHelper.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/LockScopesHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/LockScopesHelper.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence;\n+\n+import javax.persistence.PessimisticLockScope;\n+\n+import org.apache.openjpa.kernel.LockScopes;\n+\n+/**\n+ * Helper methods translate between JPA-defined pessimistic lock scope and\n+ * OpenJPA internal lock scope levels.\n+ * \n+ * @since 2.0.0\n+ */\n+public class LockScopesHelper {\n+    /**\n+     * Translates javax.persistence LockModeType to internal lock level.\n+     */\n+    public static int toLockScope(PessimisticLockScope scope) {\n+        if (scope == null || scope == PessimisticLockScope.NORMAL)\n+            return LockScopes.LOCKSCOPE_NORMAL;\n+        return LockScopes.LOCKSCOPE_EXTENDED;\n+    }\n+\n+    /**\n+     * Translates internal lock level to javax.persistence LockModeType.\n+     */\n+    public static PessimisticLockScope fromLockScope(int level) {\n+        if (level < LockScopes.LOCKSCOPE_EXTENDED)\n+            return PessimisticLockScope.NORMAL;\n+        return PessimisticLockScope.EXTENDED;\n+    }\n+}"},{"sha":"1a5ce88a5414bd1ab26ebad0db63952a0439859b","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","status":"modified","additions":10,"deletions":11,"changes":21,"blob_url":"https://github.com/apache/openjpa/blob/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/8c8636fce98d7907c444bc9f7dc2c94321163d68/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java?ref=8c8636fce98d7907c444bc9f7dc2c94321163d68","patch":"@@ -31,15 +31,14 @@\n import java.util.Map;\n import java.util.Set;\n import java.util.Stack;\n+\n import javax.persistence.CascadeType;\n import javax.persistence.GenerationType;\n+import javax.persistence.LockModeType;\n \n import static javax.persistence.CascadeType.*;\n \n import org.apache.commons.lang.StringUtils;\n-import org.xml.sax.Attributes;\n-import org.xml.sax.Locator;\n-import org.xml.sax.SAXException;\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.event.BeanLifecycleCallbacks;\n@@ -61,7 +60,6 @@\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.meta.LifecycleMetaData;\n import org.apache.openjpa.meta.MetaDataContext;\n-import org.apache.openjpa.meta.MetaDataDefaults;\n import org.apache.openjpa.meta.MetaDataFactory;\n import static org.apache.openjpa.meta.MetaDataModes.*;\n import org.apache.openjpa.meta.MetaDataRepository;\n@@ -73,6 +71,9 @@\n import static org.apache.openjpa.persistence.PersistenceStrategy.*;\n import org.apache.openjpa.util.ImplHelper;\n import org.apache.openjpa.util.MetaDataException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n \n import serp.util.Numbers;\n \n@@ -1106,7 +1107,7 @@ protected boolean startLob(Attributes attrs)\n         throws SAXException {\n         FieldMetaData fmd = (FieldMetaData) currentElement();\n         int typeCode = fmd.isElementCollection() ? fmd.getElement().getDeclaredTypeCode() : fmd.getDeclaredTypeCode();\n-        Class type = fmd.isElementCollection() ? fmd.getElement().getDeclaredType() : fmd.getDeclaredType();\n+        Class<?> type = fmd.isElementCollection() ? fmd.getElement().getDeclaredType() : fmd.getDeclaredType();\n         if (typeCode != JavaTypes.STRING\n             && type != char[].class\n             && type != Character[].class\n@@ -1651,12 +1652,10 @@ protected boolean startNamedQuery(Attributes attrs)\n         meta.setDefiningType(_cls);\n         meta.setQueryString(attrs.getValue(\"query\"));\n         meta.setLanguage(JPQLParser.LANG_JPQL);\n-        /** TODO: Uncomment when orm.xsd defines lockmode\n-        LockModeType lockMode =\n-                 LockModeType.valueOf(attrs.getValue(\"lockMode\"));\n-        meta.addHint(\"openjpa.FetchPlan.ReadLockMode\",\n-            JPA2LockLevels.toLockLevel(lockMode));\n-        **/\n+        String lockModeStr = attrs.getValue(\"lock-mode\");\n+        if (lockModeStr != null) {\n+            meta.addHint(\"openjpa.FetchPlan.ReadLockMode\", LockModeType.valueOf(lockModeStr));\n+        }\n         Locator locator = getLocation().getLocator();\n         if (locator != null) {\n             meta.setLineNumber(Numbers.valueOf(locator.getLineNumber()));"}]}

