{"sha":"8d18daabd722e39dae258ab33f74c561b4965496","node_id":"MDY6Q29tbWl0MjA2MzY0OjhkMThkYWFiZDcyMmUzOWRhZTI1OGFiMzNmNzRjNTYxYjQ5NjU0OTY=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2008-01-23T23:25:56Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2008-01-23T23:25:56Z"},"message":"OPENJPA-464 committing patch provided by Teresa Kan\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@614731 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"31d86fd9095744db45249ccc43a6d536314a99d8","url":"https://api.github.com/repos/apache/openjpa/git/trees/31d86fd9095744db45249ccc43a6d536314a99d8"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/8d18daabd722e39dae258ab33f74c561b4965496","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/8d18daabd722e39dae258ab33f74c561b4965496","html_url":"https://github.com/apache/openjpa/commit/8d18daabd722e39dae258ab33f74c561b4965496","comments_url":"https://api.github.com/repos/apache/openjpa/commits/8d18daabd722e39dae258ab33f74c561b4965496/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"72aefb149b493ca812d2dd03fc555ca8b1a6e961","url":"https://api.github.com/repos/apache/openjpa/commits/72aefb149b493ca812d2dd03fc555ca8b1a6e961","html_url":"https://github.com/apache/openjpa/commit/72aefb149b493ca812d2dd03fc555ca8b1a6e961"}],"stats":{"total":571,"additions":567,"deletions":4},"files":[{"sha":"9d3aa589c73c8819ea236b3f7c9cf6e52f121502","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java?ref=8d18daabd722e39dae258ab33f74c561b4965496","patch":"@@ -24,6 +24,7 @@\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\n+import org.apache.openjpa.jdbc.kernel.BatchingConstraintUpdateManager;\n import org.apache.openjpa.jdbc.kernel.EagerFetchModes;\n import org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory;\n import org.apache.openjpa.jdbc.kernel.LRSSizes;\n@@ -214,11 +215,13 @@ public JDBCConfigurationImpl(boolean derivations, boolean loadGlobals) {\n         updateManagerPlugin = addPlugin(\"jdbc.UpdateManager\", true);\n         aliases = new String[]{\n             \"default\",\n-            \"org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager\",\n+            BatchingConstraintUpdateManager.class.getName(),\n             \"operation-order\",\n             \"org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager\",\n             \"constraint\",\n             \"org.apache.openjpa.jdbc.kernel.ConstraintUpdateManager\",\n+            \"batching-constraint\",\n+            BatchingConstraintUpdateManager.class.getName(),\n         };\n         updateManagerPlugin.setAliases(aliases);\n         updateManagerPlugin.setDefault(aliases[0]);"},{"sha":"fe8e72a79197a733fcf42239c1b4b7f63b126c0e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingConstraintUpdateManager.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingConstraintUpdateManager.java","raw_url":"https://github.com/apache/openjpa/raw/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingConstraintUpdateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingConstraintUpdateManager.java?ref=8d18daabd722e39dae258ab33f74c561b4965496","patch":"@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.sql.PrimaryRow;\n+import org.apache.openjpa.jdbc.sql.Row;\n+import org.apache.openjpa.jdbc.sql.RowImpl;\n+import org.apache.openjpa.jdbc.sql.RowManager;\n+import org.apache.openjpa.jdbc.sql.RowManagerImpl;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * <P>Batch update manager that writes the SQL in object-level operation order. \n+ * This update manager initiates a BatchPreparedStatementManagerImpl which \n+ * will utilize the JDBC addBatch() and executeBatch() APIs to batch the \n+ * statements for performance improvement.</P>\n+ * <P>This is the default plug-in class for UpdateManager to support statement \n+ * batching. You can plug-in your own statement batch implementation through \n+ * the following property: \n+ * <PRE>\n+ *   < property name=\"openjpa.jdbc.UpdateManager\" \n+ *     value=\"org.apache.openjpa.jdbc.kernel.YourOperationOrderUpdateManager\" />   \n+ * </PRE></P>\n+ * @author Teresa Kan\n+ */\n+\n+public class BatchingConstraintUpdateManager extends ConstraintUpdateManager {\n+\n+    protected PreparedStatementManager newPreparedStatementManager(\n+            JDBCStore store, Connection conn) {\n+        int batchLimit = dict.getBatchLimit();\n+        return new BatchingPreparedStatementManagerImpl(store, conn, batchLimit);\n+    }\n+}"},{"sha":"b98be57d7aaf27524876c8e7e38c4c3b4fa9f5d7","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java","status":"added","additions":302,"deletions":0,"changes":302,"blob_url":"https://github.com/apache/openjpa/blob/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/BatchingPreparedStatementManagerImpl.java?ref=8d18daabd722e39dae258ab33f74c561b4965496","patch":"@@ -0,0 +1,302 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.BatchUpdateException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.Statement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.sql.Row;\n+import org.apache.openjpa.jdbc.sql.RowImpl;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.ApplicationIds;\n+import org.apache.openjpa.util.OptimisticException;\n+\n+/**\n+ * Batch prepared statement manager implementation. This prepared statement\n+ * manager will utilize the JDBC addBatch() and exceuteBatch() to batch the SQL\n+ * statements together to improve the execution performance.\n+ * \n+ * @author Teresa Kan\n+ */\n+\n+public class BatchingPreparedStatementManagerImpl extends\n+        PreparedStatementManagerImpl {\n+\n+    private final static Localizer _loc = Localizer\n+            .forPackage(BatchingPreparedStatementManagerImpl.class);\n+\n+    private Map _cacheSql = null;\n+    private int _batchLimit;\n+    private boolean _disableBatch = false;\n+    private transient Log _log = null;\n+\n+    /**\n+     * Constructor. Supply connection.\n+     */\n+    public BatchingPreparedStatementManagerImpl(JDBCStore store,\n+            Connection conn, int batchLimit) {\n+\n+        super(store, conn);\n+        _batchLimit = batchLimit;\n+        _log = store.getConfiguration().getLog(JDBCConfiguration.LOG_JDBC);\n+        if (_log.isTraceEnabled())\n+            _log.trace(_loc.get(\"batch_limit\", String.valueOf(_batchLimit)));\n+    }\n+\n+    /**\n+     * Flush the given row. This method will cache the statement in a cache. The\n+     * statement will be executed in the flush() method.\n+     */\n+    protected void flushInternal(RowImpl row) throws SQLException {\n+        if (_batchLimit == 0 || _disableBatch) {\n+            super.flushInternal(row);\n+            return;\n+        }\n+        Column[] autoAssign = null;\n+        if (row.getAction() == Row.ACTION_INSERT)\n+            autoAssign = row.getTable().getAutoAssignedColumns();\n+\n+        // prepare statement\n+        String sql = row.getSQL(_dict);\n+        OpenJPAStateManager sm = row.getPrimaryKey();\n+        ClassMapping cmd = null;\n+        if (sm != null)\n+            cmd = (ClassMapping) sm.getMetaData();\n+        // validate batch capability\n+        _disableBatch = _dict.validateBatchProcess(row, autoAssign, sm, cmd);\n+\n+        // process the sql statement, either execute it immediately or\n+        // cache them.\n+        processSql(sql, row);\n+\n+        // set auto assign values\n+        if (autoAssign != null && autoAssign.length > 0 && sm != null) {\n+            Object val;\n+            for (int i = 0; i < autoAssign.length; i++) {\n+                val = _dict.getGeneratedKey(autoAssign[i], _conn);\n+                cmd.assertJoinable(autoAssign[i]).setAutoAssignedValue(sm,\n+                        _store, autoAssign[i], val);\n+            }\n+            sm.setObjectId(ApplicationIds.create(sm.getPersistenceCapable(),\n+                    cmd));\n+        }\n+    }\n+\n+    private void processSql(String sql, RowImpl row) throws SQLException {\n+        ArrayList temprow;\n+\n+        if (_cacheSql == null)\n+            _cacheSql = Collections.synchronizedMap(new LinkedHashMap());\n+        if (_disableBatch) {\n+            // if there were some statements batched before, then\n+            // we need to flush them out first before processing the\n+            // current non batch process.\n+            if (!_cacheSql.isEmpty())\n+                flush();\n+            execute(sql, row);\n+\n+        } else {\n+            // else start batch support. If the sql string is in the cache,\n+            // just adds the row to the cache\n+            if (_cacheSql.containsKey(sql)) {\n+                temprow = (ArrayList) _cacheSql.get(sql);\n+                temprow.add(row);\n+                _cacheSql.put(sql, temprow);\n+            } else {\n+                // no sql exists in the cache, cache the sql string and its rows\n+                ArrayList inputrow = new ArrayList();\n+                inputrow.add(row);\n+                _cacheSql.put(sql, inputrow);\n+            }\n+        } // end of batch support\n+    }\n+\n+    private void execute(String sql, RowImpl row) throws SQLException {\n+        PreparedStatement stmnt = null;\n+        try {\n+            ResultSet rs = null;\n+            stmnt = _conn.prepareStatement(sql);\n+            row.flush(stmnt, _dict, _store);\n+            int count = stmnt.executeUpdate();\n+            if (count != 1) {\n+                Object failed = row.getFailedObject();\n+                if (failed != null)\n+                    _exceptions.add(new OptimisticException(failed));\n+                else if (row.getAction() == Row.ACTION_INSERT)\n+                    throw new SQLException(_loc.get(\n+                            \"update-failed-no-failed-obj\",\n+                            String.valueOf(count), sql).getMessage());\n+            }\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, row.getFailedObject(), _dict);\n+        } finally {\n+            try {\n+                if (stmnt != null)\n+                    stmnt.close();\n+            } catch (SQLException se) {\n+                // ignore the exception for this case.\n+            }\n+        }\n+    }\n+\n+    public void flush() {\n+        PreparedStatement ps = null;\n+        ArrayList list;\n+        RowImpl onerow = null;\n+\n+        // go thru the cache to process all the sql stmt.\n+        if (_cacheSql == null || _cacheSql.isEmpty()) {\n+            super.flush();\n+            return;\n+        }\n+        Set e = _cacheSql.keySet();\n+\n+        for (Iterator itr = e.iterator(); itr.hasNext();) {\n+            String key = (String) itr.next();\n+            try {\n+                ps = _conn.prepareStatement(key);\n+            } catch (SQLException se) {\n+                throw SQLExceptions.getStore(se, ps, _dict);\n+            }\n+            list = (ArrayList) _cacheSql.get(key);\n+            if (list == null) {\n+                return;\n+            }\n+\n+            // if only 1 row for this statement, then execute it right away\n+            int rowsize = list.size();\n+\n+            try {\n+                if (rowsize == 1) {\n+                    onerow = (RowImpl) list.get(0);\n+                    onerow.flush(ps, _dict, _store);\n+                    int count = ps.executeUpdate();\n+                    if (count != 1) {\n+                        Object failed = onerow.getFailedObject();\n+                        if (failed != null)\n+                            _exceptions.add(new OptimisticException(failed));\n+                        else if (onerow.getAction() == Row.ACTION_INSERT)\n+                            throw new SQLException(_loc.get(\n+                                    \"update-failed-no-failed-obj\",\n+                                    String.valueOf(count), key).getMessage());\n+                    }\n+                } else {\n+                    // has more than one rows for this statement, use addBatch\n+                    int count = 0;\n+                    for (int i = 0; i < list.size(); i++) {\n+                        onerow = (RowImpl) list.get(i);\n+                        if (count < _batchLimit || _batchLimit == -1) {\n+                            onerow.flush(ps, _dict, _store);\n+                            ps.addBatch();\n+                            count++;\n+\n+                        } else {\n+                            // reach the batchLimit , execute it\n+                            try {\n+                                int[] rtn = ps.executeBatch();\n+                                checkUpdateCount(rtn, onerow, key);\n+                            } catch (BatchUpdateException bex) {\n+                                SQLException sqex = bex.getNextException();\n+                                if (sqex == null)\n+                                    sqex = bex;\n+                                throw SQLExceptions.getStore(sqex, ps, _dict);\n+                            }\n+                            onerow.flush(ps, _dict, _store);\n+                            ps.addBatch();\n+                            count = 1; // reset the count to 1 for new batch\n+                        }\n+                    }\n+                    // end of the loop, execute the batch\n+                    try {\n+                        int[] rtn = ps.executeBatch();\n+                        checkUpdateCount(rtn, onerow, key);\n+                    } catch (BatchUpdateException bex) {\n+                        SQLException sqex = bex.getNextException();\n+                        if (sqex == null)\n+                            sqex = bex;\n+                        throw SQLExceptions.getStore(sqex, ps, _dict);\n+                    }\n+                }\n+            } catch (SQLException se) {\n+                SQLException sqex = se.getNextException();\n+                if (sqex == null)\n+                    sqex = se;\n+                throw SQLExceptions.getStore(sqex, ps, _dict);\n+            }\n+            try {\n+                ps.close();\n+            } catch (SQLException sqex) {\n+                throw SQLExceptions.getStore(sqex, ps, _dict);\n+            }\n+        }\n+        // instead of calling _cacheSql.clear, null it out to improve the\n+        // performance.\n+        _cacheSql = null;\n+    }\n+\n+    private void checkUpdateCount(int[] count, RowImpl row, String sql)\n+            throws SQLException {\n+        int cnt = 0;\n+        Object failed = null;\n+        for (int i = 0; i < count.length; i++) {\n+            cnt = count[i];\n+            switch (cnt) {\n+            case Statement.EXECUTE_FAILED: // -3\n+                failed = row.getFailedObject();\n+                if (failed != null || row.getAction() == Row.ACTION_UPDATE)\n+                    _exceptions.add(new OptimisticException(failed));\n+                else if (row.getAction() == Row.ACTION_INSERT)\n+                    throw new SQLException(_loc.get(\n+                            \"update-failed-no-failed-obj\",\n+                            String.valueOf(count[i]), sql).getMessage());\n+                break;\n+            case Statement.SUCCESS_NO_INFO: // -2\n+                if (_log.isTraceEnabled())\n+                    _log.trace(_loc.get(\"batch_update_info\",\n+                            String.valueOf(cnt), sql).getMessage());\n+                break;\n+            case 0: // no row is inserted, treats it as failed\n+                // case\n+                failed = row.getFailedObject();\n+                if ((failed != null || row.getAction() == Row.ACTION_INSERT))\n+                    throw new SQLException(_loc.get(\n+                            \"update-failed-no-failed-obj\",\n+                            String.valueOf(count[i]), sql).getMessage());\n+            }\n+        }\n+    }\n+}"},{"sha":"1d6a40a3f9501d11f19262c87011ce0e88bd7ab8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","status":"modified","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java?ref=8d18daabd722e39dae258ab33f74c561b4965496","patch":"@@ -72,6 +72,8 @@\n     protected String databaseProductVersion = null;\r\n     protected int maj = 0;\r\n     protected int min = 0;\r\n+    \r\n+    private int defaultBatchLimit = 100;\r\n \r\n     public DB2Dictionary() {\r\n         platform = \"DB2\";\r\n@@ -144,6 +146,8 @@ public DB2Dictionary() {\n             \"TYPE\", \"UNDO\", \"UNTIL\", \"VALIDPROC\", \"VARIABLE\", \"VARIANT\", \"VCAT\",\r\n             \"VOLUMES\", \"WHILE\", \"WLM\", \"YEARS\",\r\n         }));\r\n+        \r\n+        super.setBatchLimit(defaultBatchLimit);\r\n     }\r\n \r\n     public boolean supportsRandomAccessResultSet(Select sel,\r\n@@ -690,6 +694,20 @@ public String addCastAsType(String func, Val val) {\n         return fstring;\r\n     }\r\n \r\n+    /**\r\n+     * Return the batch limit. If the batchLimit is -1, change it to 100 for\r\n+     * best performance\r\n+     */\r\n+    public int getBatchLimit() {\r\n+        int limit = super.getBatchLimit();\r\n+        if (limit == UNLIMITED) {\r\n+            limit = defaultBatchLimit;\r\n+            if (log.isTraceEnabled())\r\n+                log.trace(_loc.get(\"batch_unlimit\", String.valueOf(limit)));\r\n+        }\r\n+        return limit;\r\n+    }\r\n+\r\n     /**\r\n      * Return the correct CAST function syntax\r\n      * \r"},{"sha":"884ea93acb9b7e541758b57c951716a95fb9250c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","status":"modified","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java?ref=8d18daabd722e39dae258ab33f74c561b4965496","patch":"@@ -85,6 +85,7 @@\n import org.apache.openjpa.jdbc.schema.Table;\n import org.apache.openjpa.jdbc.schema.Unique;\n import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.exps.Path;\n import org.apache.openjpa.kernel.exps.Literal;\n import org.apache.openjpa.lib.conf.Configurable;\n@@ -94,7 +95,9 @@\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.lib.util.Localizer.Message;\n+import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.ValueStrategies;\n import org.apache.openjpa.util.GeneralException;\n import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.InvalidStateException;\n@@ -143,6 +146,9 @@\n     protected static final int NAME_ANY = 0;\n     protected static final int NAME_TABLE = 1;\n     protected static final int NAME_SEQUENCE = 2;\n+    \n+    protected static final int UNLIMITED = -1;\n+    protected static final int NO_BATCH = 0;\n \n     private static final String ZERO_DATE_STR =\n         \"'\" + new java.sql.Date(0) + \"'\";\n@@ -334,6 +340,12 @@\n     private Method _setString = null;\n     private Method _setCharStream = null;\n \n+    // batchLimit value:\n+    // -1 = unlimited\n+    // 0  = no batch\n+    // any positive number = batch limit\n+    public int batchLimit = NO_BATCH;\n+    \n     public DBDictionary() {\n         fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\n             \"BIGINT\", \"BIT\", \"BLOB\", \"CLOB\", \"DATE\", \"DECIMAL\", \"DISTINCT\",\n@@ -4216,4 +4228,53 @@ public String getCastFunction(Val val, String func) {\n     public void createIndexIfNecessary(Schema schema, String table,\n             Column pkColumn) {\n     }\n+    \n+    /**\n+     * Return the batchLimit\n+     */\n+    public int getBatchLimit(){\n+        return batchLimit;\n+    }\n+    \n+    /**\n+     * Set the batchLimit value\n+     */\n+    public void setBatchLimit(int limit){\n+        batchLimit = limit;\n+    }\n+    \n+    /**\n+     * Validate the batch process. In some cases, we can't batch the statements\n+     * due to some restrictions. For example, if the GeneratedType=IDENTITY,\n+     * we have to disable the batch process because we need to get the ID value\n+     * right away for the in-memory entity to use.\n+     */\n+    public boolean validateBatchProcess(RowImpl row, Column[] autoAssign,\n+            OpenJPAStateManager  sm, ClassMapping cmd ) {\n+        boolean disableBatch = false;\n+        if (getBatchLimit()== 0) return false;\n+        if (autoAssign != null && sm != null) {\n+            FieldMetaData[] fmd = cmd.getPrimaryKeyFields();\n+            int i = 0;\n+            while (!disableBatch && i < fmd.length) {\n+                if (fmd[i].getValueStrategy() == ValueStrategies.AUTOASSIGN)\n+                    disableBatch = true;\n+                i++;\n+            }\n+        }\n+        // go to each Dictionary to validate the batch capability\n+        if (!disableBatch)\n+            disableBatch = validateDBSpecificBatchProcess(disableBatch, row, \n+                autoAssign, sm, cmd);\n+        return disableBatch;\n+    }\n+    \n+    /**\n+     * Allow each Dictionary to validate its own batch process. \n+     */\n+    public boolean validateDBSpecificBatchProcess (boolean disableBatch, \n+            RowImpl row, Column[] autoAssign, \n+            OpenJPAStateManager  sm, ClassMapping cmd ) {\n+        return disableBatch;\n+    }\n }"},{"sha":"e9819c194562279488248e5efa9e4d8783ef1afc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java?ref=8d18daabd722e39dae258ab33f74c561b4965496","patch":"@@ -108,6 +108,9 @@\n     private Method _putBytes = null;\n     private Method _putString = null;\n     private Method _putChars = null;\n+    \n+    // batch limit\n+    private int defaultBatchLimit = 100;\n \n     public OracleDictionary() {\n         platform = \"Oracle\";\n@@ -159,6 +162,7 @@ public OracleDictionary() {\n         }));\n \n         substringFunctionName = \"SUBSTR\";\n+        super.setBatchLimit(defaultBatchLimit);\n     }\n \n     public void endConfiguration() {"},{"sha":"b259060bdb5912decdba4bd689346e5c6d4193fd","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties?ref=8d18daabd722e39dae258ab33f74c561b4965496","patch":"@@ -110,3 +110,7 @@ no-nullable-fk: No nullable foreign key found to resolve circular flush\\n\\\n \tis nullable (optional).\n graph-not-cycle-free: A circular flush dependency has been found after all \\\n     circular dependencies should have been resolved.\n+batch_limit: The batch limit is set to {0}.\n+batch_update_info: ExecuteBatch command returns update count {0} for \\\n+\tstatement {1}.\n+    "},{"sha":"b3146a4891c00f9b703bbd887b873a86da3d600d","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties?ref=8d18daabd722e39dae258ab33f74c561b4965496","patch":"@@ -169,3 +169,4 @@ millis-query-timeout: JDBC locking does not support millisecond-granularity \\\n     timeouts.  Use timeouts that are multiples of 1000 for even second values.\n db-not-supported: The database product \"{0}\", version \"{1}\" is not officially supported.\n stream-exception: Unexpected error recovering the row to stream the LOB.\n+batch_unlimit: The batch limit was changed from unlimit (-1) to {0}. \n\\ No newline at end of file"},{"sha":"b8ef9e12aba00984116d449ff1b96427d103de1b","filename":"openjpa-project/src/doc/manual/ref_guide_conf.xml","status":"modified","additions":9,"deletions":3,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-project/src/doc/manual/ref_guide_conf.xml","raw_url":"https://github.com/apache/openjpa/raw/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-project/src/doc/manual/ref_guide_conf.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_conf.xml?ref=8d18daabd722e39dae258ab33f74c561b4965496","patch":"@@ -3713,17 +3713,23 @@ openjpa.jdbc.UpdateManager</literal>\n UpdateManager</literal>\n             </para>\n             <para>\n-<emphasis role=\"bold\">Default: </emphasis><literal>default</literal>\n+<emphasis role=\"bold\">Default: </emphasis><literal>constraint-batching</literal>\n+            </para>\n+            <para>\n+            <emphasis role=\"bold\">Possible values: </emphasis><literal>default</literal>,\n+<literal>operation-order</literal>, <literal>constraint</literal>, <literal>\n+batching-constraint</literal>, <literal>batching-operation-order</literal>\n             </para>\n             <para>\n <emphasis role=\"bold\">Description:</emphasis> The full class name of the\n <ulink url=\"../javadoc/org/apache/openjpa/jdbc/kernel/UpdateManager.html\">\n <classname>org.apache.openjpa.jdbc.kernel.UpdateManager</classname></ulink> to\n use to flush persistent object changes to the datastore. The provided default\n implementation is\n-<ulink url=\"../javadoc/org/apache/openjpa/jdbc/kernel/OperationOrderUpdateManager\">\n-<classname>org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager</classname>\n+<ulink url=\"../javadoc/org/apache/openjpa/jdbc/kernel/BatchingConstraintUpdateManager\">\n+<classname>org.apache.openjpa.jdbc.kernel.BatchingConstraintUpdateManager</classname>\n </ulink>.\n+\n             </para>\n         </section>\n     </section>"},{"sha":"fec31260aa87624b25ebec14ade3a5a7008a9f51","filename":"openjpa-project/src/doc/manual/ref_guide_dbsetup.xml","status":"modified","additions":106,"deletions":0,"changes":106,"blob_url":"https://github.com/apache/openjpa/blob/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-project/src/doc/manual/ref_guide_dbsetup.xml","raw_url":"https://github.com/apache/openjpa/raw/8d18daabd722e39dae258ab33f74c561b4965496/openjpa-project/src/doc/manual/ref_guide_dbsetup.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_dbsetup.xml?ref=8d18daabd722e39dae258ab33f74c561b4965496","patch":"@@ -3060,6 +3060,112 @@ EntityManager em = emf.createEntityManager(props);\n </programlisting>\n         </example>\n     </section>\n+    <section id=\"ref_guide_dbsetup_stmtbatch\">\n+        <title>\n+            Statement Batching\n+        </title>\n+        <indexterm zone=\"ref_guide_dbsetup_stmtbatch\">\n+            <primary>\n+                Statement Batching\n+            </primary>\n+        </indexterm>\n+        <indexterm>\n+            <primary>\n+                JDBC\n+            </primary>\n+            <secondary>\n+                statement batching\n+            </secondary>\n+            <see>\n+                statement batching\n+            </see>\n+        </indexterm>\n+        <para>\n+In addition to connection pooling and prepared statement caching, OpenJPA \n+employs statement batching to speed up JDBC updates. Statement batching is \n+enabled by default for any JDBC driver that supports it. When batching is on, \n+OpenJPA automatically orders its SQL statements to maximize the size of each \n+batch. This can result in large performance gains for transactions that modify \n+a lot of data.\n+\t\t</para>\n+\t\t<para>\n+You configure statement batching through the system DBDictionary, which is \n+controlled by the openjpa.jdbc.DBDictionary configuration property. You can \n+enable the statement batching by setting the batchLimit in the value. The batch\n+limit is the maximum number of statements OpenJPA will ever batch \n+together. A value has the following meaning:\n+\t\t\t<itemizedlist>\n+            \t<listitem>\n+               \t <para>\n+<literal>-1</literal>: Unlimited number of statements for a batch. \n+                </para>\n+               </listitem>\n+               <listitem>\n+                <para>\n+<literal>0</literal>: Disable batch support. This is the default for most \n+dictionaries.\n+                </para>\n+               </listitem>\n+               <listitem>\n+                <para>\n+<literal>any positive number</literal>: Maximum number of statements for a batch.\n+                </para>\n+               </listitem>\n+\t\t\t</itemizedlist> \n+\t\t\t<note>\n+\t\t     <para>\n+By default, the batch support is based on each Dictionary to define the default \n+batch limit. Currently only DB2 and Oracle dictionaries are set the default \n+batch limit to 100. The default batch limit for the rest of the dictionaries is set \n+to zero (disabled). \n+\t\t\t</para>\n+\t\t\t</note>\n+\t\t</para>\n+\t\t<para>\n+The example below shows how to enable and disable statement batching via \n+your configuration properties. \n+        </para>\n+        <example id=\"ref_guide_dbsetup_stmtbatch_exmple1\">\n+            <title>\n+                Enable SQL statement batching\n+            </title>\n+<programlisting>\n+&lt;property name=\"openjpa.jdbc.DBDictionary\" value=\"db2(batchLimit=25)\"/&gt;\n+&lt;property name=\"openjpa.jdbc.DBDictionary\" value=\"oracle(batchLimit=-1)\"/&gt;\n+Or\n+&lt;property name=\"openjpa.jdbc.DBDictionary\" value=\"batchLimit=25\"/&gt;\n+&lt;property name=\"openjpa.jdbc.DBDictionary\" value=\"batchLimit=-1\"/&gt;\n+</programlisting>\n+        </example>\n+        <example id=\"ref_guide_dbsetup_stmtbatch_exmple2\">\n+            <title>\n+                Disable SQL statement batching\n+            </title>            \n+<programlisting>\n+&lt;property name=\"openjpa.jdbc.DBDictionary\" value=\"db2(batchLimit=0)\"/&gt;\n+Or\n+&lt;property name=\"openjpa.jdbc.DBDictionary\" value=\"batchLimit=0\"/&gt;\n+</programlisting>\n+        </example>\n+        <par>\n+By default, org.apache.openjpa.jdbc.kernel.BatchingConstraintUpdateManager \n+is the default statement batching implementation. You can plug-in your own \n+statement batching implementation by providing the implementation that extends \n+from AbstractUpdateManager or ConstraitUpdateManager. Add this implementation\n+class as a property in the persistence.xml file. For example, a custom\n+statement batching implementation mycomp.MyUpdateManager extends \n+ConstraitUpdateManager. You specify this implementation in the persistence.xml\n+file as the following example:\n+        </par>\n+         <example id=\"ref_guide_dbsetup_stmtbatch_exmple3\">\n+            <title>\n+                Plug-in custom statement batching implementation\n+            </title>            \n+<programlisting>\n+&lt;property name=\"openjpa.jdbc.UpdateManager\" value=\"mycomp.MyUpdateManager\"/&gt;\n+</programlisting>\n+        </example>        \n+    </section>\n     <section id=\"ref_guide_dbsetup_lrs\">\n         <title>\n             Large Result Sets"}]}

