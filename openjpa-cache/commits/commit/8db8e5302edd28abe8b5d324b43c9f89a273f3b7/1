{"sha":"8db8e5302edd28abe8b5d324b43c9f89a273f3b7","node_id":"MDY6Q29tbWl0MjA2MzY0OjhkYjhlNTMwMmVkZDI4YWJlOGI1ZDMyNGI0M2M5Zjg5YTI3M2YzYjc=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2008-06-11T23:27:18Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2008-06-11T23:27:18Z"},"message":"OPENJPA-544. Merge from ../active. svn merge -c 652523 ../active\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@666897 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"da9c5a72e6dd10ba82b68aef96d61dea831d9d22","url":"https://api.github.com/repos/apache/openjpa/git/trees/da9c5a72e6dd10ba82b68aef96d61dea831d9d22"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/8db8e5302edd28abe8b5d324b43c9f89a273f3b7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/8db8e5302edd28abe8b5d324b43c9f89a273f3b7","html_url":"https://github.com/apache/openjpa/commit/8db8e5302edd28abe8b5d324b43c9f89a273f3b7","comments_url":"https://api.github.com/repos/apache/openjpa/commits/8db8e5302edd28abe8b5d324b43c9f89a273f3b7/comments","author":null,"committer":null,"parents":[{"sha":"6f6634bbadcd9649e60474bce9c54473c4db34b6","url":"https://api.github.com/repos/apache/openjpa/commits/6f6634bbadcd9649e60474bce9c54473c4db34b6","html_url":"https://github.com/apache/openjpa/commit/6f6634bbadcd9649e60474bce9c54473c4db34b6"}],"stats":{"total":351,"additions":272,"deletions":79},"files":[{"sha":"d31f501d7e0b13790a6748a16062dc80c26f3a21","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","status":"modified","additions":188,"deletions":14,"changes":202,"blob_url":"https://github.com/apache/openjpa/blob/8db8e5302edd28abe8b5d324b43c9f89a273f3b7/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/8db8e5302edd28abe8b5d324b43c9f89a273f3b7/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java?ref=8db8e5302edd28abe8b5d324b43c9f89a273f3b7","patch":"@@ -19,13 +19,17 @@\n package org.apache.openjpa.lib.util.concurrent;\r\n \r\n import java.util.concurrent.ConcurrentHashMap;\r\n-import java.util.Map;\r\n import java.util.Enumeration;\r\n import java.util.Set;\r\n import java.util.Collection;\r\n import java.util.AbstractSet;\r\n import java.util.Iterator;\r\n import java.util.AbstractCollection;\r\n+import java.util.Random;\r\n+import java.util.HashSet;\r\n+import java.util.TreeSet;\r\n+\r\n+import org.apache.commons.collections.set.MapBackedSet;\r\n \r\n /**\r\n  * A subclass of {@link ConcurrentHashMap} that allows null keys and values.\r\n@@ -36,10 +40,20 @@\n  */\r\n public class NullSafeConcurrentHashMap extends ConcurrentHashMap {\r\n \r\n-    private enum Null {\r\n-        MARKER\r\n+    private enum Markers {\r\n+        NULL,\r\n+        MAP_BACKED_SET_DUMMY_VAL\r\n     }\r\n \r\n+    // The second argument is used within MapBackedSet as the value for\r\n+    // all the key-val pairs that are put into the underlying Map. This\r\n+    // is required for our usage since ConcurrentHashMap does not allow\r\n+    // null values.\r\n+    private Set randomKeys = MapBackedSet.decorate(\r\n+        new ConcurrentHashMap(), Markers.MAP_BACKED_SET_DUMMY_VAL);\r\n+\r\n+    private Random random = new Random();\r\n+\r\n     public NullSafeConcurrentHashMap(int size, float load,\r\n         int concurrencyLevel) {\r\n         super(size, load, concurrencyLevel);\r\n@@ -52,24 +66,135 @@ public NullSafeConcurrentHashMap() {\n      * Returns internal representation for object.\r\n      */\r\n     private static Object maskNull(Object o) {\r\n-        return (o == null ? Null.MARKER : o);\r\n+        return (o == null ? Markers.NULL : o);\r\n     }\r\n \r\n     /**\r\n      * Returns object represented by specified internal representation.\r\n      */\r\n     private static Object unmaskNull(Object o) {\r\n-        return (o == Null.MARKER ? null : o);\r\n+        return (o == Markers.NULL ? null : o);\r\n+    }\r\n+\r\n+    public Entry removeRandom() {\r\n+        // this doesn't just use randomEntryIterator() because that iterator\r\n+        // has weaker concurrency guarantees than this method. In particular,\r\n+        // this method will continue to attempt to remove random entries even\r\n+        // as other threads remove the same entries, whereas the random\r\n+        // iterator may return values that have been removed.\r\n+\r\n+        while (!isEmpty()) {\r\n+            while (!randomKeys.isEmpty()) {\r\n+                // randomKeys contains null-masked data\r\n+                Iterator iter = randomKeys.iterator();\r\n+                Object key = iter.next();\r\n+                if (key != null && randomKeys.remove(key)) {\r\n+                    Object val = super.remove(key);\r\n+                    if (val != null)\r\n+                        return new EntryImpl(unmaskNull(key), unmaskNull(val));\r\n+                }\r\n+            }\r\n+\r\n+            // if randomKeys is empty, fall back to non-random behavior.\r\n+            Object key = super.keySet().iterator().next();\r\n+            Object val = super.remove(key);\r\n+            if (val != null)\r\n+                return new EntryImpl(unmaskNull(key), unmaskNull(val));\r\n+        }\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * The returned data structure should not be shared among multiple\r\n+     * threads.\r\n+     */\r\n+    public Iterator<Entry> randomEntryIterator() {\r\n+        return new Iterator<Entry>() {\r\n+\r\n+            Iterator randomIter = randomKeys.iterator();\r\n+            Iterator nonRandomIter = NullSafeConcurrentHashMap.super.keySet()\r\n+                .iterator();\r\n+\r\n+            Set returned = new HashSet();\r\n+            Entry next;\r\n+            boolean nextSet = false;\r\n+\r\n+            public boolean hasNext() {\r\n+                // we've set the next value and we haven't returned it yet\r\n+                if (nextSet)\r\n+                    return true;\r\n+\r\n+                // compute the next value. If the computation returns null,\r\n+                // return false. Else, store the next value and return true.\r\n+                Object nextKey;\r\n+                Object nextValue;\r\n+                if (randomIter.hasNext()) {\r\n+                    nextKey = randomIter.next();\r\n+                    nextValue = NullSafeConcurrentHashMap.super.get(nextKey);\r\n+                    if (nextValue != null) {\r\n+                        returned.add(nextKey);\r\n+                        next = new EntryImpl(unmaskNull(nextKey),\r\n+                            unmaskNull(nextValue));\r\n+                        nextSet = true;\r\n+                        return true;\r\n+                    }\r\n+                }\r\n+\r\n+                while (nonRandomIter.hasNext()) {\r\n+                    nextKey = nonRandomIter.next();\r\n+\r\n+                    if (returned.contains(nextKey))\r\n+                        continue;\r\n+\r\n+                    nextValue = NullSafeConcurrentHashMap.super.get(nextKey);\r\n+                    if (nextValue != null) {\r\n+                        returned.add(nextKey);\r\n+                        next = new EntryImpl(unmaskNull(nextKey),\r\n+                            unmaskNull(nextValue));\r\n+                        nextSet = true;\r\n+                        return true;\r\n+                    }\r\n+                }\r\n+                return false;\r\n+            }\r\n+\r\n+            public Entry next() {\r\n+                // hasNext() will initialize this.next\r\n+                if (!nextSet && !hasNext())\r\n+                    return null;\r\n+\r\n+                // if we get here, then we're about to return a next value\r\n+                nextSet = false;\r\n+                \r\n+                if (containsKey(next.getKey()))\r\n+                    return next;\r\n+\r\n+                // something has changed since the last iteration (presumably\r\n+                // due to multi-threaded access to the underlying data\r\n+                // structure); recurse\r\n+                return next();\r\n+            }\r\n+\r\n+            public void remove() {\r\n+                throw new UnsupportedOperationException();\r\n+            }\r\n+        };\r\n     }\r\n \r\n     @Override\r\n     public Object remove(Object key) {\r\n-        return unmaskNull(super.remove(maskNull(key)));\r\n+        Object maskedKey = maskNull(key);\r\n+        Object val = unmaskNull(super.remove(maskedKey));\r\n+        randomKeys.remove(maskedKey);\r\n+        return val;\r\n     }\r\n \r\n     @Override\r\n     public boolean remove(Object key, Object value) {\r\n-        return super.remove(maskNull(key), maskNull(value));\r\n+        Object maskedKey = maskNull(key);\r\n+        boolean val = super.remove(maskedKey, maskNull(value));\r\n+        randomKeys.remove(maskedKey);\r\n+        return val;\r\n     }\r\n \r\n     @Override\r\n@@ -85,12 +210,34 @@ public Object replace(Object key, Object value) {\n \r\n     @Override\r\n     public Object putIfAbsent(Object key, Object value) {\r\n-        return unmaskNull(super.putIfAbsent(maskNull(key), maskNull(value)));\r\n+        Object maskedKey = maskNull(key);\r\n+        Object superVal = super.putIfAbsent(maskedKey, maskNull(value));\r\n+        addRandomKey(maskedKey);\r\n+        return unmaskNull(superVal);\r\n     }\r\n \r\n     @Override\r\n     public Object put(Object key, Object value) {\r\n-        return unmaskNull(super.put(maskNull(key), maskNull(value)));\r\n+        Object maskedKey = maskNull(key);\r\n+        Object superVal = super.put(maskedKey, maskNull(value));\r\n+        addRandomKey(maskedKey);\r\n+        return unmaskNull(superVal);\r\n+    }\r\n+\r\n+    /**\r\n+     * Potentially adds <code>maskedKey</ccode> to the set of random keys\r\n+     * to be removed by {@link #removeRandom()}.\r\n+     *\r\n+     * @since 1.1.0\r\n+     */\r\n+    private void addRandomKey(Object maskedKey) {\r\n+        // Add one in every three keys to the set. Only do this when\r\n+        // there are less than 16 elements in the random key set; this\r\n+        // means that the algorithm will be pseudo-random for up to\r\n+        // 16 removes (either via removeRandom() or normal remove()\r\n+        // calls) that have no intervening put() calls.\r\n+        if (random != null && randomKeys.size() < 16 && random.nextInt(10) < 3)\r\n+            randomKeys.add(maskedKey);\r\n     }\r\n \r\n     @Override\r\n@@ -160,11 +307,6 @@ protected Object unmask(Object internal) {\n         };\r\n     }\r\n \r\n-    @Override\r\n-    public void putAll(Map t) {\r\n-        super.putAll(t);\r\n-    }\r\n-\r\n     @Override\r\n     public Collection values() {\r\n         return new TranslatingCollection(super.values()) {\r\n@@ -238,4 +380,36 @@ public int size() {\n             return backingCollection.size();\r\n         }\r\n     }\r\n+\r\n+    private class EntryImpl implements Entry {\r\n+\r\n+        final Object key;\r\n+        final Object val;\r\n+\r\n+        private EntryImpl(Object key, Object val) {\r\n+            this.key = key;\r\n+            this.val = val;\r\n+        }\r\n+\r\n+        public Object getKey() {\r\n+            return key;\r\n+        }\r\n+\r\n+        public Object getValue() {\r\n+            return val;\r\n+        }\r\n+\r\n+        public Object setValue(Object value) {\r\n+            throw new UnsupportedOperationException();\r\n+        }\r\n+    }\r\n+\r\n+    public interface KeyFilter {\r\n+\r\n+        /**\r\n+         * @param key may be null\r\n+         * @return whether or not <code>key</code> shuold be excluded\r\n+         */\r\n+        public boolean exclude(Object key);\r\n+    }\r\n }\r"},{"sha":"a524bbc5fb9321f753c99e3db449ee54a3463520","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","status":"modified","additions":0,"deletions":34,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/8db8e5302edd28abe8b5d324b43c9f89a273f3b7/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/8db8e5302edd28abe8b5d324b43c9f89a273f3b7/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java?ref=8db8e5302edd28abe8b5d324b43c9f89a273f3b7","patch":"@@ -99,40 +99,6 @@ public boolean isFull() {\n         return size() >= maxSize;\r\n     }\r\n \r\n-    public Map.Entry removeRandom() {\r\n-        // this isn't really random, but is concurrent.\r\n-        while (true) {\r\n-            if (size() == 0)\r\n-                return null;\r\n-            Set entries = entrySet();\r\n-            Entry e = (Entry) entries.iterator().next();\r\n-            final Object key = e.getKey();\r\n-            final Object val = e.getValue();\r\n-            if (remove(key) != null)\r\n-                // create a new Entry instance because the ConcurrentHashMap\r\n-                // implementation's one is \"live\" so does not behave as desired\r\n-                // after removing the entry.\r\n-                return new Entry() {\r\n-                    public Object getKey() {\r\n-                        return key;\r\n-                    }\r\n-\r\n-                    public Object getValue() {\r\n-                        return val;\r\n-                    }\r\n-\r\n-                    public Object setValue(Object value) {\r\n-                        throw new UnsupportedOperationException();\r\n-                    }\r\n-                };\r\n-        }\r\n-    }\r\n-\r\n-    public Iterator randomEntryIterator() {\r\n-        // this isn't really random, but is concurrent.\r\n-        return entrySet().iterator();\r\n-    }\r\n-\r\n     /**\r\n      * This implementation does nothing.\r\n      */\r"},{"sha":"f182e714e9b2d7a986248fd3c262dfe53eb8f040","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestConcurrentMap.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/8db8e5302edd28abe8b5d324b43c9f89a273f3b7/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestConcurrentMap.java","raw_url":"https://github.com/apache/openjpa/raw/8db8e5302edd28abe8b5d324b43c9f89a273f3b7/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestConcurrentMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestConcurrentMap.java?ref=8db8e5302edd28abe8b5d324b43c9f89a273f3b7","patch":"@@ -41,7 +41,7 @@\n     private static final int SLEEP = 3;\n \n     private ConcurrentMap[] _maps = new ConcurrentMap[]{\n-        new SizedConcurrentHashMap(ENTRIES, .75f, 16),\n+        new SizedConcurrentHashMap(ENTRIES, .75f, 16), \n         new ConcurrentReferenceHashMap(ReferenceMap.HARD, ReferenceMap.HARD), };\n \n     public void setUp() throws Exception {"},{"sha":"74857be9be44fe56e21f4cf559e8858646f7aa40","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java","status":"modified","additions":83,"deletions":30,"changes":113,"blob_url":"https://github.com/apache/openjpa/blob/8db8e5302edd28abe8b5d324b43c9f89a273f3b7/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/8db8e5302edd28abe8b5d324b43c9f89a273f3b7/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java?ref=8db8e5302edd28abe8b5d324b43c9f89a273f3b7","patch":"@@ -19,34 +19,80 @@\n package org.apache.openjpa.lib.util.concurrent;\r\n \r\n import java.io.IOException;\r\n-import java.util.concurrent.ConcurrentMap;\r\n-import java.util.concurrent.ConcurrentHashMap;\r\n-import java.util.Iterator;\r\n import java.util.Set;\r\n import java.util.Collection;\r\n import java.util.Map;\r\n import java.util.HashMap;\r\n-import java.util.Enumeration;\r\n import java.util.Map.Entry;\r\n \r\n import org.apache.openjpa.lib.test.AbstractTestCase;\r\n \r\n public class TestNullSafeConcurrentHashMap extends AbstractTestCase {\r\n \r\n-    private Map newMap() {\r\n+    private NullSafeConcurrentHashMap newMap() {\r\n         return new NullSafeConcurrentHashMap();\r\n-//        return new HashMap();\r\n+    }\r\n+\r\n+    public void testRemoveRandomIsNotTotallyDeterministic() {\r\n+        removeHelper(false);\r\n+    }\r\n+\r\n+    public void testRandomIteratorIsNotTotallyDeterministic() {\r\n+        removeHelper(true);\r\n+    }\r\n+\r\n+    private void removeHelper(boolean iter) {\r\n+        Map<String,Integer> removedCounts = new HashMap();\r\n+        for (int i = 0; i < 1000; i++) {\r\n+            NullSafeConcurrentHashMap m = new NullSafeConcurrentHashMap();\r\n+            m.put(\"a\", \"A\");\r\n+            m.put(\"b\", \"B\");\r\n+            m.put(\"c\", \"C\");\r\n+            m.put(\"d\", \"D\");\r\n+            m.put(\"e\", \"E\");\r\n+            m.put(\"f\", \"F\");\r\n+            m.put(\"g\", \"G\");\r\n+\r\n+            String removed;\r\n+            if (iter) {\r\n+                removed = (String) m.removeRandom().getKey();\r\n+            } else {\r\n+                removed = (String) ((Entry) m.randomEntryIterator().next())\r\n+                    .getKey();\r\n+                m.remove(removed);\r\n+            }\r\n+\r\n+            Integer count = removedCounts.get(removed);\r\n+            if (count == null)\r\n+                removedCounts.put(removed, 1);\r\n+            else\r\n+                removedCounts.put(removed, count.intValue() + 1);\r\n+        }\r\n+\r\n+        // assume that over 1000 runs, every element should be removed at\r\n+        // least once, and no element should be removed more than 30% of\r\n+        // the time\r\n+        assertEquals(7, removedCounts.size());\r\n+        for (Entry<String,Integer> entry : removedCounts.entrySet()) {\r\n+            if (entry.getValue() == 0)\r\n+                fail(\"element \" + entry.getKey() + \" was never removed\");\r\n+            if (entry.getValue() > 500)\r\n+                fail(\"element \" + entry.getKey() + \" was removed \"\r\n+                    + entry.getValue() + \" times; this is greater than the \"\r\n+                    + \"threshold of 500.\");\r\n+        }\r\n     }\r\n \r\n     public void testNullKeys() throws ClassNotFoundException, IOException {\r\n-        Map m = newMap();\r\n-        helper(m, null, \"value 0\", \"value 1\", \"value 2\");\r\n+        helper(null, \"value 0\", \"value 1\", \"value 2\");\r\n     }\r\n \r\n-    private void helper(Map m, Object key, Object value0,\r\n+    private void helper(Object key, Object value0,\r\n         Object value1, Object value2)\r\n         throws IOException, ClassNotFoundException {\r\n \r\n+        NullSafeConcurrentHashMap m = newMap();\r\n+\r\n         // initial put\r\n         m.put(key, value0);\r\n \r\n@@ -77,50 +123,57 @@ private void helper(Map m, Object key, Object value0,\n \r\n         // put\r\n         assertEquals(value0, m.put(key, value1));\r\n-//        m.putAll(); #####\r\n \r\n         // remove\r\n         assertEquals(value1, m.put(key, value1));\r\n         assertEquals(value1, m.remove(key));\r\n         m.put(key, value1);\r\n \r\n         // ConcurrentMap stuff\r\n-        ConcurrentMap cm = (ConcurrentMap) m;\r\n-        assertFalse(cm.remove(\"invalid key\", value0));\r\n-        assertTrue(cm.remove(key, value1));\r\n-        assertNull(cm.putIfAbsent(key, value0)); // null == prev unset\r\n+        assertFalse(m.remove(\"invalid key\", value0));\r\n+        assertTrue(m.remove(key, value1));\r\n+        assertNull(m.putIfAbsent(key, value0)); // null == prev unset\r\n \r\n         // value0 might be null; can't disambiguate from above in OpenJPA\r\n         // interpretation\r\n-        assertEquals(value0, cm.putIfAbsent(key, \"invalid value\"));\r\n+        assertEquals(value0, m.putIfAbsent(key, \"invalid value\"));\r\n \r\n         // replace\r\n-        assertEquals(value0, cm.replace(key, value1));\r\n-        assertTrue(cm.replace(key, value1, value2));\r\n+        assertEquals(value0, m.replace(key, value1));\r\n+        assertTrue(m.replace(key, value1, value2));\r\n+\r\n+        // putAll. Note that ConcurrentHashMap happens to delegate to put()\r\n+        // from within putAll() calls. This test should help ensure that we\r\n+        // find out if that changes.\r\n+        m = newMap();\r\n+        Map putAllArg = new HashMap();\r\n+        putAllArg.put(key, value0);\r\n+        putAllArg.put(\"another key\", value1);\r\n+        m.putAll(putAllArg);\r\n+        assertEquals(value0, m.get(key));\r\n+        assertEquals(value1, m.get(\"another key\"));\r\n     }\r\n \r\n     public void testNullValues() throws ClassNotFoundException, IOException {\r\n-        Map m = newMap();\r\n-        nullValsHelper(m, \"foo\");\r\n+        nullValsHelper(\"foo\");\r\n     }\r\n \r\n-    private void nullValsHelper(Map m, Object key)\r\n+    private void nullValsHelper(Object key)\r\n         throws IOException, ClassNotFoundException {\r\n-        helper(m, key, null, null, null);\r\n-        helper(m, key, \"bar\", \"baz\", \"quux\");\r\n+        helper(key, null, null, null);\r\n+        helper(key, \"bar\", \"baz\", \"quux\");\r\n \r\n-        helper(m, key, \"bar\", \"baz\", null);\r\n-        helper(m, key, null, \"baz\", \"quux\");\r\n-        helper(m, key, \"bar\", null, \"quux\");\r\n+        helper(key, \"bar\", \"baz\", null);\r\n+        helper(key, null, \"baz\", \"quux\");\r\n+        helper(key, \"bar\", null, \"quux\");\r\n \r\n-        helper(m, key, \"bar\", null, null);\r\n-        helper(m, key, null, \"baz\", null);\r\n-        helper(m, key, null, null, \"quux\");\r\n+        helper(key, \"bar\", null, null);\r\n+        helper(key, null, \"baz\", null);\r\n+        helper(key, null, null, \"quux\");\r\n     }\r\n \r\n     public void testNullKeysAndValues()\r\n         throws ClassNotFoundException, IOException {\r\n-        Map m = newMap();\r\n-        nullValsHelper(m, null);\r\n+        nullValsHelper(null);\r\n     }\r\n }\r"}]}

