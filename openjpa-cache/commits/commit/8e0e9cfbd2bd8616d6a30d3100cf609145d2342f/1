{"sha":"8e0e9cfbd2bd8616d6a30d3100cf609145d2342f","node_id":"MDY6Q29tbWl0MjA2MzY0OjhlMGU5Y2ZiZDJiZDg2MTZkNmEzMGQzMTAwY2Y2MDkxNDVkMjM0MmY=","commit":{"author":{"name":"Jeremy Bauer","email":"jrbauer@apache.org","date":"2010-01-15T18:05:14Z"},"committer":{"name":"Jeremy Bauer","email":"jrbauer@apache.org","date":"2010-01-15T18:05:14Z"},"message":"OPENJPA-1115 Base identifier support\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@899738 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"2908dcf6177ae9b03fdff47c409ab7ac9b17999c","url":"https://api.github.com/repos/apache/openjpa/git/trees/2908dcf6177ae9b03fdff47c409ab7ac9b17999c"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f","html_url":"https://github.com/apache/openjpa/commit/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f","comments_url":"https://api.github.com/repos/apache/openjpa/commits/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/comments","author":null,"committer":null,"parents":[{"sha":"5a8c5de491f363c96532b7ac6522d849c04014e8","url":"https://api.github.com/repos/apache/openjpa/commits/5a8c5de491f363c96532b7ac6522d849c04014e8","html_url":"https://github.com/apache/openjpa/commit/5a8c5de491f363c96532b7ac6522d849c04014e8"}],"stats":{"total":1523,"additions":1523,"deletions":0},"files":[{"sha":"c8891ea727a5ca1d9496c46006b5521a17a5fbaa","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/Identifier.java","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/Identifier.java","raw_url":"https://github.com/apache/openjpa/raw/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/Identifier.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/Identifier.java?ref=8e0e9cfbd2bd8616d6a30d3100cf609145d2342f","patch":"@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.identifier;\n+\n+/**\n+ * Base interface for identifiers.\n+ */\n+public interface Identifier extends Comparable<Identifier>, Cloneable {\n+\n+    public String getName();\n+    public void setName(String name);\n+    public int length();\n+}"},{"sha":"f1239d6877e43e647f79a9c1e0732f6343e143cd","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierConfiguration.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/apache/openjpa/blob/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierConfiguration.java?ref=8e0e9cfbd2bd8616d6a30d3100cf609145d2342f","patch":"@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.identifier;\n+\n+import java.util.Map;\n+\n+/**\n+ * The IdentifierConfiguration interface.  Implementers of this interface supply \n+ * naming configuration information to consumers of names/identifiers.\n+ */\n+public interface IdentifierConfiguration {\n+\n+    /**\n+     * Returns the leading delimiter value to use when delimiting a name.\n+     */\n+    public String getLeadingDelimiter();\n+    \n+    /**\n+     * Returns the trailing delimiter value to use when delimiting a name.\n+     */\n+    public String getTrailingDelimiter();\n+    \n+    /**\n+     * Returns true if global name delimiting is enabled. \n+     */\n+    public boolean delimitAll();\n+    \n+    /**\n+     * Returns true if delimiting is supported\n+     */\n+    public boolean getSupportsDelimitedIdentifiers();\n+    \n+    /**\n+     * Returns the value used to concatenate multiple names together.\n+     * For example: \"_\" used in TABLE1_TABLE2\n+     */\n+    public String getIdentifierConcatenator();\n+    \n+    /**\n+     * Returns the value used to delimit between individual names.\n+     * For example: \".\" used in MYSCHEMA.MYTABLE\n+     */\n+    public String getIdentifierDelimiter();\n+    \n+    /**\n+     * Gets the default naming rule\n+     */\n+    public IdentifierRule getDefaultIdentifierRule();\n+    \n+    /**\n+     * Returns all naming rules \n+     * @return\n+     */\n+    public <T> Map<T, IdentifierRule> getIdentifierRules();\n+    \n+    /**\n+     * Returns a naming rule or null if the rule is\n+     * not found.\n+     */\n+    public <T> IdentifierRule getIdentifierRule(T t);\n+\n+    /**\n+     * Returns the case that is used when delimiting.\n+     * @return upper, lower, or preserve\n+     */\n+    public String getDelimitedCase();\n+    \n+    /**\n+     * Returns the case that is used when delimiters are not used.\n+     * @return upper, lower, or preserve\n+     */\n+    public String getSchemaCase();\n+}"},{"sha":"ad5311e5e27a80bc1708fbdf242ea14c068f5b7f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierImpl.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierImpl.java","raw_url":"https://github.com/apache/openjpa/raw/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierImpl.java?ref=8e0e9cfbd2bd8616d6a30d3100cf609145d2342f","patch":"@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.identifier;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Base identifer implementation.\n+ */\n+public class IdentifierImpl implements Identifier, Serializable {\n+    \n+    private String _name = null;\n+    \n+    protected IdentifierImpl() {}\n+    \n+    public IdentifierImpl(String name) {\n+        setName(name);\n+    }\n+\n+    public void setName(String name) {\n+        _name = name;\n+    }\n+\n+    public String getName() {\n+        return _name;\n+    }\n+    \n+    public String toString() {\n+        return getName();\n+    }\n+    \n+    public int hashCode() {\n+        if (_name == null) {\n+            return super.hashCode();\n+        }\n+        return _name.hashCode();\n+    }\n+\n+    public int length() {\n+        if (getName() == null) {\n+            return 0;\n+        }\n+        return getName().length();\n+    }\n+\n+    public int compareTo(Identifier o) {\n+        if (_name == null && (o == null || o.getName() == null)) {\n+            return 0;\n+        }\n+        if (_name == null)\n+            return 1;\n+        if (o == null || o.getName() == null)\n+            return -1;\n+        return _name.compareTo(o.getName());\n+    }\n+}"},{"sha":"04381536827d6710c01af0debe87cdd2e8c1e3ce","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierRule.java","status":"added","additions":209,"deletions":0,"changes":209,"blob_url":"https://github.com/apache/openjpa/blob/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierRule.java","raw_url":"https://github.com/apache/openjpa/raw/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierRule.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierRule.java?ref=8e0e9cfbd2bd8616d6a30d3100cf609145d2342f","patch":"@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.identifier;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.CharUtils;\n+import org.apache.commons.lang.StringUtils;\n+\n+/**\n+ * The standard identifier rule.  Rules are used for specific configuration\n+ * of identifier types.  For example.  A rule could be used to indicate that\n+ * an identifier type should not be delimited or has a max length of 255 \n+ * characters.\n+ *\n+ */\n+public class IdentifierRule {\n+    \n+    public static final Set<String> EMPTY_SET = new HashSet<String>(0);\n+    public static final String DEFAULT_RULE = \"default\";\n+    public static char UNDERSCORE = '_';\n+\n+    private String _name;\n+    private int _maxLength = 128;\n+    private boolean _nullable = false;\n+    private boolean _allowTruncation = false;\n+    private boolean _allowCompaction = true;\n+    private boolean _canDelimit = true;\n+    private boolean _mustDelimit = false;\n+    private boolean _mustBeginWithLetter = true;\n+    private boolean _onlyLettersDigitsUnderscores = true;\n+    private String _specialCharacters = \"\";\n+    private Set<String> _reservedWords = null;\n+    private boolean _delimitReservedWords = false;\n+    private String _wildcard = \"%\";\n+\n+    public void setName(String name) {\n+        _name = name;\n+    }\n+    \n+    public String getName() {\n+        return _name;\n+    }\n+\n+    public void setMaxLength(int maxLength) {\n+        _maxLength = maxLength;\n+    }\n+\n+    public int getMaxLength() {\n+        return _maxLength;\n+    }\n+\n+    public void setAllowTruncation(boolean allowTruncation) {\n+        _allowTruncation = allowTruncation;\n+    }\n+\n+    public boolean isAllowTruncation() {\n+        return _allowTruncation;\n+    }\n+\n+    public void setNullable(boolean nullable) {\n+        _nullable = nullable;\n+    }\n+\n+    public boolean isNullable() {\n+        return _nullable;\n+    }\n+\n+    public void setAllowCompaction(boolean allowCompaction) {\n+        _allowCompaction = allowCompaction;\n+    }\n+\n+    public boolean getAllowCompaction() {\n+        return _allowCompaction;\n+    }\n+\n+    public void setCanDelimit(boolean canDelimit) {\n+        _canDelimit = canDelimit;\n+    }\n+\n+    public boolean getCanDelimit() {\n+        return _canDelimit;\n+    }\n+\n+    public void setMustDelimit(boolean mustDelimit) {\n+        _mustDelimit = mustDelimit;\n+    }\n+\n+    public boolean getMustDelimit() {\n+        return _mustDelimit;\n+    }\n+\n+    public void setMustBeginWithLetter(boolean mustBeginWithLetter) {\n+        _mustBeginWithLetter = mustBeginWithLetter;\n+    }\n+\n+    public boolean isMustBeginWithLetter() {\n+        return _mustBeginWithLetter;\n+    }\n+\n+    public void setOnlyLettersDigitsUnderscores(boolean onlyLettersDigitsUnderscores) {\n+        _onlyLettersDigitsUnderscores = onlyLettersDigitsUnderscores;\n+    }\n+\n+    public boolean isOnlyLettersDigitsUnderscores() {\n+        return _onlyLettersDigitsUnderscores;\n+    }\n+\n+    public void setReservedWords(Set<String> reservedWords) {\n+        _reservedWords = reservedWords;\n+    }\n+\n+    public Set<String> getReservedWords() {\n+        if (_reservedWords == null) {\n+            _reservedWords = new HashSet<String>();\n+        }\n+        return _reservedWords;\n+    }\n+\n+    public void setSpecialCharacters(String specialCharacters) {\n+        _specialCharacters = specialCharacters;\n+    }\n+\n+    public String getSpecialCharacters() {\n+        return _specialCharacters;\n+    }\n+\n+    public void setDelimitReservedWords(boolean delimitReservedWords) {\n+        delimitReservedWords = _delimitReservedWords;\n+    }\n+\n+    public boolean getDelimitReservedWords() {\n+        return _delimitReservedWords;\n+    }\n+\n+    /**\n+     * SQL identifier rules:\n+     * 1) Can be up to 128 characters long\n+     * 2) Must begin with a letter\n+     * 3) Can contain letters, digits, and underscores\n+     * 4) Can't contain spaces or special characters such as #, $, &, %, or \n+     *    punctuation.\n+     * 5) Can't be reserved words\n+     */\n+    public boolean requiresDelimiters(String identifier) {\n+\n+        // Do not delimit single valued wildcards or \"?\" or names that have method-type\n+        // signatures (ex. getValue()).  These are considered special values in OpenJPA\n+        // and should not be delimited.\n+        if (_wildcard.equals(identifier) || \"?\".equals(identifier) ||\n+            identifier.endsWith(\"()\")) {\n+            return false;\n+        }\n+        \n+        if (getMustDelimit()) {\n+            return true;\n+        }\n+        \n+        // Assert identifier begins with a letter\n+        char[] chars = identifier.toCharArray();\n+        if (isMustBeginWithLetter()) {\n+            if (!CharUtils.isAsciiAlpha(chars[0])) {\n+                return true;\n+            }\n+        }\n+\n+        // Iterate through chars, asserting delimiting rules \n+        for (char ch : chars) {\n+            if (isOnlyLettersDigitsUnderscores()) {\n+                if (!CharUtils.isAsciiAlphanumeric(ch) && !(ch == UNDERSCORE)) {\n+                    return true;\n+                }\n+            }\n+            // Look for special characters\n+            if (StringUtils.contains(getSpecialCharacters(), ch)) {\n+                return true;\n+            }\n+        }\n+        // Finally, look for reserved words\n+        if (getDelimitReservedWords()) {\n+            if (isReservedWord(identifier)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean isReservedWord(String identifier) {\n+        return _reservedWords.contains(identifier);\n+    }\n+}"},{"sha":"1481fc7d719265cd0661d577fe9cf15c53a3d943","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierUtil.java","status":"added","additions":319,"deletions":0,"changes":319,"blob_url":"https://github.com/apache/openjpa/blob/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierUtil.java","raw_url":"https://github.com/apache/openjpa/raw/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierUtil.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierUtil.java?ref=8e0e9cfbd2bd8616d6a30d3100cf609145d2342f","patch":"@@ -0,0 +1,319 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.identifier;\n+\n+/**\n+ * Base IdentifierUtil interface.  Defines many operations for operating\n+ * on strings using identifier rules.\n+ */\n+public interface IdentifierUtil {\n+    public static final String DOUBLE_QUOTE = \"\\\"\";\n+    public static final String DOT = \".\";\n+    public static final String UNDERSCORE = \"_\";\n+    public static final String SPACE = \" \";\n+    public static final String BAR = \"|\";\n+    public static final String EMPTY = \"\";\n+    public static final String PERCENT = \"%\";\n+    \n+    public static final char DOLLAR_CHAR = '$';\n+    public static final char UNDERSCORE_CHAR = '_';\n+    \n+    public static final String CASE_UPPER = \"upper\";\n+    public static final String CASE_LOWER = \"lower\";\n+    public static final String CASE_PRESERVE = \"preserve\";\n+    /**\n+     * Get the naming configuration.\n+     */\n+    public IdentifierConfiguration getIdentifierConfiguration();\n+    \n+    /**\n+     * Set the naming configuration to use for naming operations.  A naming\n+     * configuration must be set before calling any other methods.\n+     */\n+    void setIdentifierConfiguration(IdentifierConfiguration config);\n+    \n+    /**\n+     * Delimit the name if it requires delimiters\n+     * @param the rule to use for delimiting\n+     * @param name the name to delimit\n+     * @return the delimited name, if delimiting was necessary.\n+     */\n+    public String delimit(String rule, String name);\n+\n+    /**\n+     * Delimit the name if it requires delimiters\n+     * @param the rule to use for delimiting\n+     * @param name the name to delimit\n+     * @return the delimited name, if delimiting was necessary.\n+     */\n+    public String delimit(IdentifierRule rule, String name);\n+    \n+    /**\n+     * Delimit the string with the option to force delimiting.  If force is\n+     * true, the name will delimited without checking to see if it \n+     * requires delimiters.\n+     * @param the rule to use for delimiting\n+     * @param name the name to delimit\n+     * @param force add delimiters even if delimiting is not required\n+     * @return the delimited name, if delimiting was necessary.\n+     */\n+    public String delimit(String rule, String name, boolean force);\n+\n+    /**\n+     * Delimit the string with the option to force delimiting.  If force is\n+     * true, the name will delimited without checking to see if it \n+     * requires delimiters.\n+     * @param the rule to use for delimiting\n+     * @param name the name to delimit\n+     * @param force add delimiters even if delimiting is not required\n+     * @return the delimited name, if delimiting was necessary.\n+     */\n+    public String delimit(IdentifierRule rule, String name, boolean force);\n+    \n+    \n+    /**\n+     * Remove delimiters from a delimited name \n+     * @param the rule to use for removing delimiters\n+     * @param name the name from which to remove delimiters\n+     */\n+    public String removeDelimiters(String rule, String name);\n+\n+    /**\n+     * Remove delimiters from a delimited name \n+     * @param the rule to use for removing delimiters\n+     * @param name the name from which to remove delimiters\n+     */\n+    public String removeDelimiters(IdentifierRule rule, String name);\n+    \n+    /**\n+     * Determines whether a name is delimited.\n+     * @param the rule to use for removing delimiters\n+     * @param name the name to examine for delimiters\n+     */\n+    public boolean isDelimited(String rule, String name); \n+    \n+    /**\n+     * Determines whether a name is delimited.\n+     * @param the rule to use for removing delimiters\n+     * @param name the name to examine for delimiters\n+     */\n+    public boolean isDelimited(IdentifierRule rule, String name); \n+\n+    /**\n+     * Determines whether a name requires delimiters based upon:\n+     * <ul>\n+     * <li> The SQL-92 Reference definition of a valid unquoted name</li>\n+     * <li> The naming rule specified</li> \n+     * </ul>\n+     * @param the rule to use for removing delimiters\n+     * @param name the name to examine for delimiting requirements\n+     */\n+    public boolean requiresDelimiters(String rule, String name);\n+\n+    /**\n+     * Determines whether a name requires delimiters based upon:\n+     * <ul>\n+     * <li> The SQL-92 Reference definition of a valid unquoted name</li>\n+     * <li> The naming rule specified</li> \n+     * </ul>\n+     * @param the rule to use for removing delimiters\n+     * @param name the name to examine for delimiting requirements\n+     */\n+    public boolean requiresDelimiters(IdentifierRule rule, String name);\n+    \n+    /**\n+     * Combines names using delimiting rules and appropriate separators\n+     * @return a combined name\n+     *         ex. {\"TH IS\", THAT} -> \"TH IS_THAT\" \n+     */\n+    public String combineNames(String rule, String[] rules, String[] names);\n+\n+    /**\n+     * Combines names using delimiting rules and appropriate separators\n+     * @return a combined name\n+     *         ex. {\"TH IS\", THAT} -> \"TH IS_THAT\" \n+     */\n+    public String combineNames(IdentifierRule rule, IdentifierRule[] rules, String[] names);\n+\n+    /**\n+     * Combines names using the specified delimiting rule and appropriate separators\n+     * @return a combined name\n+     *         ex. {\"TH IS\", THAT} -> \"TH IS_THAT\" \n+     */\n+    public String combineNames(String rule, String[] names);\n+\n+    /**\n+     * Combines names using the specified delimiting rule and appropriate separators\n+     * @return a combined name\n+     *         ex. {\"TH IS\", THAT} -> \"TH IS_THAT\" \n+     */\n+    public String combineNames(IdentifierRule rule, String[] names);\n+    \n+    /**\n+     * Combines two names using delimiting rules and appropriate separators\n+     */\n+    public String combineNames(String rule, String name1, String name2);\n+\n+    /**\n+     * Combines two names using delimiting rules and appropriate separators\n+     */\n+    public String combineNames(IdentifierRule rule, String name1, String name2);\n+\n+    /**\n+     * Joins several names with different naming rules into a single string\n+     * using appropriate delimiters and separators\n+     */\n+    public String joinNames(String[] rules, String[] names);\n+    \n+    /**\n+     * Joins several names with different naming rules into a single string\n+     * using appropriate delimiters and separators\n+     */\n+    public String joinNames(IdentifierRule[] rules, String[] names);\n+\n+    /**\n+     * Joins several names with different naming rules into a single string\n+     * using appropriate delimiters and separators\n+     */\n+    public String joinNames(String rule, String[] names);\n+    \n+    /**\n+     * Joins several names with different naming rules into a single string\n+     * using appropriate delimiters and separators\n+     */\n+    public String joinNames(IdentifierRule rule, String[] names);\n+\n+    /**\n+     * Joins several names with different naming rules into a single string\n+     * using the specified delimiter\n+     */\n+    public String joinNames(IdentifierRule rule, String[] names, String delimiter);\n+    /**\n+     * Joins several names with different naming rules into a single string\n+     * using the specified delimiter\n+     */\n+    public String joinNames(String rule, String[] names, String delimiter);\n+\n+    /**\n+     * Splits a combined name name using the provided naming rule\n+     * @param name  the multi-value name\n+     * @return individual components of the name\n+     *         ex. schema.table --> { schema, table }\n+     */\n+    public String[] splitName(String rule, String name);\n+    \n+    /**\n+     * Splits a combined name name using the provided naming rule\n+     * @param name  the multi-value name\n+     * @return individual components of the name\n+     *         ex. schema.table --> { schema, table }\n+     */\n+    public String[] splitName(IdentifierRule rule, String name);\n+\n+    /**\n+     * Splits a combined name name using the provided naming rule and\n+     * delimiter.\n+     * @param name  the multi-value name\n+     * @return individual components of the name\n+     *         ex. schema.table --> { schema, table }\n+     */\n+    public String[] splitName(String rule, String name, String delimiter);\n+\n+    /**\n+     * Splits a combined name name using the provided naming rule and\n+     * delimiter.\n+     * @param name  the multi-value name\n+     * @return individual components of the name\n+     *         ex. schema.table --> { schema, table }\n+     */\n+    public String[] splitName(IdentifierRule rule, String name, String delimiter);\n+\n+    /**\n+     * Returns whether a name is considered a reserved word\n+     */\n+    public boolean isReservedWord(String rule, String name);\n+    \n+    /**\n+     * Returns whether a name is considered a reserved word\n+     */\n+    public boolean isReservedWord(IdentifierRule rule, String name);\n+    \n+    /**\n+     * Convert the string using this naming configuration to the supplied\n+     * naming configuration.\n+     */\n+    public String convert(IdentifierConfiguration config, String rule, String name);\n+    \n+    /**\n+     * Truncates a name while maintaining delimiters.\n+     */\n+    public String truncateName(String rule, String name, int length);\n+\n+    /**\n+     * Truncates a name while maintaining delimiters.\n+     */\n+    public String truncateName(IdentifierRule rule, String name, int length);\n+\n+    /**\n+     * Append the names together while maintaining delimiters.\n+     */\n+    public String appendNames(IdentifierRule rule, String name1, String name2);\n+\n+    /**\n+     * Append the names together while maintaining delimiters.\n+     */\n+    public String appendNames(String rule, String name1, String name2);\n+    \n+    /**\n+     * Converts a qualified string-based name defined using the base configuration to the\n+     * specified configuration.  Returns the converted name.\n+     */\n+    public String convertFull(IdentifierConfiguration config, String rule, String fullName);\n+    \n+    /**\n+     * Removes Hungarian notation from the specified string.\n+     */\n+    public String removeHungarianNotation(String rule, String name);\n+    /**\n+     * Removes Hungarian notation from the specified string.\n+     */\n+    public String removeHungarianNotation(IdentifierRule rule, String name);\n+\n+    /**\n+     * Determines whether a name can be split into multiple components.\n+     */\n+    public boolean canSplit(String rule, String name);\n+\n+    /**\n+     * Determines whether a name can be split into multiple components.\n+     */\n+    public boolean canSplit(IdentifierRule rule, String name);\n+\n+    /**\n+     * Determines whether a name can be split into multiple components, taking\n+     * into account the specified delimiter.\n+     */\n+    public boolean canSplit(String rule, String name, String delim);\n+\n+    /**\n+     * Determines whether a name can be split into multiple components, taking\n+     * into account the specified delimiter.\n+     */\n+    public boolean canSplit(IdentifierRule rule, String name, String delim);\n+}"},{"sha":"08821dfcd03153cbd4294da73bf3e09f69b9fc49","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierUtilImpl.java","status":"added","additions":548,"deletions":0,"changes":548,"blob_url":"https://github.com/apache/openjpa/blob/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierUtilImpl.java","raw_url":"https://github.com/apache/openjpa/raw/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierUtilImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/identifier/IdentifierUtilImpl.java?ref=8e0e9cfbd2bd8616d6a30d3100cf609145d2342f","patch":"@@ -0,0 +1,548 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.identifier;\n+\n+import java.util.ArrayList;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+/**\n+ * Implementation class for the base identifier impl.\n+ *\n+ */\n+public class IdentifierUtilImpl implements IdentifierUtil, Configurable {\n+        \n+    private static final Localizer _loc = Localizer.forPackage\n+        (IdentifierUtilImpl.class);\n+    \n+    private IdentifierConfiguration _config = null;\n+    \n+    public IdentifierUtilImpl() {\n+        \n+    }\n+    \n+    public IdentifierUtilImpl(IdentifierConfiguration config) {\n+        _config = config;\n+    }\n+\n+    public void setIdentifierConfiguration(IdentifierConfiguration config) {\n+        _config = config;\n+    }    \n+\n+    public IdentifierConfiguration getIdentifierConfiguration() {\n+        return _config;\n+    }    \n+\n+    public String combineNames(IdentifierRule rule, IdentifierRule[] rules, String[] names) {\n+        boolean delimited = false;\n+        String combined = null;\n+        for (int i = 0; i < names.length; i++) {\n+            String name = names[i];\n+            if (isDelimited(rules[i], name)) {\n+                delimited = true;\n+                name = removeDelimiters(rules[i], name);\n+            }\n+            if (i == 0) {\n+                combined = name;\n+            }\n+            else {\n+                combined = combined + _config.getIdentifierConcatenator() + name;\n+            }\n+        }\n+        \n+        if (delimited) {\n+            combined = delimit(rule, combined.toString()).toString();\n+        }\n+        \n+        return combined;\n+    }\n+    \n+    public String combineNames(IdentifierRule rule, String name1, String name2) {\n+        boolean delimit = false;\n+        if (isDelimited(rule, name1)) {\n+            name1 = removeDelimiters(rule, name1);\n+            delimit = true;\n+        }\n+        if (isDelimited(rule, name2)) {\n+            name2 = removeDelimiters(rule, name2);\n+            delimit = true;\n+        }\n+        String name = name1 + _config.getIdentifierConcatenator() + name2;\n+        return delimit(rule, name, delimit).toString();\n+    }\n+\n+    public String combineNames(IdentifierRule namingRule, String[] names) {\n+        boolean delimited = false;\n+        String combined = null;\n+        for (int i = 0; i < names.length; i++) {\n+            String name = names[i];\n+            if (isDelimited(namingRule, name)) {\n+                delimited = true;\n+                name = removeDelimiters(namingRule, name);\n+            }\n+            if (i == 0) {\n+                combined = name;\n+            }\n+            else {\n+                combined = combined + _config.getIdentifierConcatenator() + name;\n+            }\n+        }\n+        if (delimited) {\n+            combined = delimit(namingRule, combined.toString()).toString();\n+        }\n+        \n+        return combined;\n+    }\n+\n+    public String appendNames(IdentifierRule rule, String name1, String name2) {\n+        if (isDelimited(rule, name1)) {\n+            name1 = removeDelimiters(rule, name1);\n+        }\n+        if (isDelimited(rule, name2)) {\n+            name2 = removeDelimiters(rule, name2);\n+        }\n+        if (name1 == null) {\n+            name1 = IdentifierUtil.EMPTY;\n+        }\n+        if (name2 == null) {\n+            name2 = IdentifierUtil.EMPTY;\n+        }\n+        String name = name1 + name2;\n+        return delimit(rule, name).toString();\n+    }\n+\n+    /**\n+     * Joins multiple names together using the standard delimiting rules\n+     * ex. ( {\"s\", \"t\", \"c\"} --> \"s\".\"t\".\"c\" }\n+     */\n+    public String joinNames(IdentifierRule[] rules, String[] names) {\n+        \n+        if (names == null || names.length == 0) {\n+            return null;\n+        }\n+        StringBuilder combinedName = new StringBuilder();\n+        for (int i = 0; i < names.length; i++) {\n+            combinedName.append(delimit(rules[i], names[i]));\n+            if (i < (names.length -1)) {\n+                combinedName.append(_config.getIdentifierDelimiter());\n+            }\n+        }\n+        return combinedName.toString();\n+    }\n+\n+    public String joinNames(String rule, String[] names) {\n+        return joinNames(_config, getNamingRule(rule), names, _config.getIdentifierDelimiter());\n+    }\n+\n+    public String joinNames(IdentifierRule rule, String[] names) {\n+        return joinNames(_config, rule, names, _config.getIdentifierDelimiter());\n+    }\n+\n+    public String joinNames(IdentifierRule rule, String[] names, String delimiter) {\n+        return joinNames(_config, rule, names, delimiter);\n+    }\n+\n+    public String joinNames(String rule, String[] names, String delimiter) {\n+        return joinNames(_config, getNamingRule(rule), names, delimiter);\n+    }\n+\n+    /**\n+     * Join names using a single naming rule and specified delimiter\n+     * @param rule\n+     * @param names\n+     * @return\n+     */\n+    public String joinNames(IdentifierConfiguration config, IdentifierRule rule, String[] names, String delimiter) {\n+        \n+        if (names == null || names.length == 0) {\n+            return null;\n+        }\n+        StringBuilder combinedName = new StringBuilder();\n+        for (int i = 0; i < names.length; i++) {\n+            if (names[i] != null) {\n+                combinedName.append(delimit(config, rule, names[i], false));\n+                if (i < (names.length -1)) {\n+                    combinedName.append(delimiter);\n+                }\n+            }\n+        }\n+        return combinedName.toString();\n+    }\n+\n+    public String[] splitName(IdentifierRule nrule, String name) {\n+        return splitName(nrule, name, _config.getIdentifierDelimiter());\n+    }\n+    \n+    \n+    /**\n+     * Splits names using single naming rule and appropriate separators\n+     * @param name  the multi-value name\n+     * @return individual components of the name\n+     *         ex. schema.table --> { schema, table }\n+     */    \n+    public String[] splitName(IdentifierRule nrule, String name, String nameDelim) {\n+        if (!canSplit(nrule, name, nameDelim) || StringUtils.isEmpty(name)) {\n+            return new String[] {name};\n+        }\n+        // \"schema\".\"table\"\n+        // \"sch.ma\".\"table\"\n+        // \"sch\"\"ma\".table\n+        \n+        // Split names by object delimiter not between name delimiters\n+        ArrayList<String> names = new ArrayList<String>(2);\n+        String pname = name;\n+\n+        // for each name\n+        int ndLen = nameDelim.length();\n+        while (!StringUtils.isEmpty(name)) {\n+            pname = splitNameCharDelimiters(name, nameDelim);\n+            names.add(pname);\n+            if ((pname.length() + ndLen) >= name.length()) {\n+                break;\n+            }\n+            name = name.substring(pname.length() + ndLen); \n+        }\n+        return names.toArray(new String[names.size()]);\n+    }\n+\n+    /**\n+     * Gets the first part of a name when single character delimiters are\n+     * in use.\n+     * @param pname\n+     * @return\n+     */\n+    private String splitNameCharDelimiters(String name, String nameDelim) {\n+        StringBuilder sname = new StringBuilder(\"\");\n+        char ld = _config.getLeadingDelimiter().charAt(0);\n+        char td = _config.getTrailingDelimiter().charAt(0);\n+        char nd = nameDelim.charAt(0);\n+        int dlvl = 0;\n+        boolean wasLd = false;\n+        for (int i = 0; i < name.length(); i++) {\n+            char c = name.charAt(i);\n+            if (c == ld) {\n+                // Handle case where delimiters are the same\n+                if (td == ld && wasLd) {\n+                    dlvl--;\n+                    wasLd = false;\n+                } else {\n+                    wasLd = true;\n+                    dlvl++;\n+                }\n+            } else if (c == td) {\n+                dlvl--;\n+            } else if (c == nd) {\n+                if (dlvl == 0  && sname.length() > 0) {\n+                    return sname.toString();\n+                }\n+            }\n+            sname.append(c);\n+        }\n+        return sname.toString();\n+    }\n+\n+    /**\n+     * Returns whether a name is double quoted\n+     * @return\n+     */\n+    public static boolean isDoubleQuoted(String name) {\n+        if (name == null || name.length() < 3) {\n+            return false;\n+        }\n+        return name.startsWith(DOUBLE_QUOTE) && \n+               name.endsWith(DOUBLE_QUOTE);\n+    }\n+\n+    \n+    public String delimit(IdentifierRule rule, String name) {\n+        return delimit(_config, rule, name, false);\n+    }\n+\n+    public String delimit(IdentifierRule rule, String name, boolean force) {\n+        return delimit(_config, rule, name, force);\n+    }\n+    \n+    public String delimit(IdentifierConfiguration config, IdentifierRule rule, String name, boolean force) {\n+        if (!rule.getCanDelimit() || StringUtils.isEmpty(name)) {\n+            return name;\n+        }\n+\n+        if ((force && !isDelimited(config, rule, name)) || requiresDelimiters(config, rule, name)) {\n+            return config.getLeadingDelimiter() + name + config.getTrailingDelimiter();\n+        }\n+        return name;\n+    }\n+\n+    public boolean isDelimited(IdentifierRule rule, String name) {\n+        return isDelimited(_config, rule, name);\n+    }\n+\n+    public boolean isDelimited(IdentifierConfiguration config, IdentifierRule rule, String name) {\n+        if (name == null || name.length() <= 3) {\n+            return false;\n+        }\n+        return name.startsWith(config.getLeadingDelimiter()) &&\n+            name.endsWith(config.getTrailingDelimiter());\n+    }\n+\n+    public String removeDelimiters(IdentifierRule rule, String name) {\n+        return removeDelimiters(rule, name, _config.getLeadingDelimiter(),\n+            _config.getTrailingDelimiter());\n+    }\n+\n+    public boolean requiresDelimiters(IdentifierRule rule, String name) {\n+        return requiresDelimiters(_config, rule, name);\n+    }\n+\n+    public boolean requiresDelimiters(IdentifierConfiguration config, IdentifierRule rule, String name) {\n+        if (rule == null) {\n+            throw new IllegalArgumentException(_loc.get(\"no-rules-provided\").getMessage());\n+        }\n+        if (rule.getCanDelimit() && !isDelimited(config, rule, name) && rule.requiresDelimiters(name)) {\n+            return true;\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Returns whether a name is considered a reserved word.\n+     */\n+    public boolean isReservedWord(IdentifierRule rule, String name) {\n+        if (rule == null) {\n+            System.out.println(\"NAmingConfig: \" + _config.getClass().getName());\n+            throw new IllegalArgumentException(\"Naming rule is null!\");\n+        }\n+        if (rule.getReservedWords() == null) {\n+            return false;\n+        }\n+        if (!isDelimited(rule, name)) {\n+            name = name.toUpperCase();\n+        }\n+        return rule.getReservedWords().contains(name);\n+    }\n+\n+    public boolean isReservedWord(String rule, String name) {\n+        return isReservedWord(_config.getIdentifierRule(rule), name);\n+    }\n+    \n+\n+    protected String removeDelimiters(IdentifierRule rule, String name, String leading,\n+        String trailing) {\n+        if (name == null) {\n+            return null;\n+        }\n+        if (isDelimited(rule, name)) {\n+            String id = name.substring(leading.length(),\n+                (name.length() - trailing.length()));\n+            return id;\n+        }\n+        return name;\n+    }\n+    \n+    public String combineNames(String rule, String[] rules, String[] names) {\n+        return combineNames(getNamingRule(rule), getNamingRules(rules), names);\n+    }\n+\n+    public String truncateName(String rule, String name, int length) {\n+        return truncateName(getNamingRule(rule), name, length);\n+    }\n+\n+    public String truncateName(IdentifierRule namingRule, String name, int length) {\n+        String tName = name;\n+        boolean delimited = isDelimited(namingRule, name);\n+        if (delimited) {\n+            tName = removeDelimiters(namingRule, name);\n+        }\n+        if (tName.length() <= length) {\n+            return name;\n+        }\n+        tName = tName.substring(0, tName.length() - length);\n+        if (delimited) {\n+            tName = delimit(namingRule, tName).toString();\n+        }\n+        return tName;\n+    }\n+\n+    public String delimit(String rule, String name) {\n+        return delimit(getNamingRule(rule), name);\n+    }\n+\n+    public String delimit(String rule, String name, boolean force) {\n+        return delimit(getNamingRule(rule), name, force);\n+    }\n+\n+    public boolean isDelimited(String rule, String name) {\n+        return isDelimited(getNamingRule(rule), name);\n+    }\n+\n+    public String removeDelimiters(String rule, String name) {\n+        return removeDelimiters(getNamingRule(rule), name);\n+    }\n+\n+    public boolean requiresDelimiters(String rule, String name) {\n+        return requiresDelimiters(getNamingRule(rule), name);\n+    }\n+\n+    public String[] splitName(String rule, String name) {\n+        return splitName(getNamingRule(rule), name);\n+    }\n+\n+    public String joinNames(String[] rules, String[] names) {\n+        return joinNames(getNamingRules(rules), names);\n+    }\n+    \n+    private IdentifierRule getNamingRule(String rule) {\n+        return _config.getIdentifierRule(rule);\n+    }\n+    \n+    public String combineNames(String rule, String name1, String name2) {\n+        return combineNames(getNamingRule(rule), name1, name2);\n+    }\n+\n+    public String combineNames(String rule, String[] names) {\n+        return combineNames(getNamingRule(rule), names);\n+    }\n+    \n+    public String appendNames(String rule, String name1, String name2) {\n+        return appendNames(getNamingRule(rule), name1, name2);\n+    }\n+\n+    public String removeHungarianNotation(IdentifierRule rule, String name) {\n+        boolean delimited = isDelimited(rule, name);\n+        if (delimited) {\n+            name = removeDelimiters(rule, name);\n+        }\n+        char[] chname = name.toCharArray();\n+        int newStart = 0;\n+\n+        for (int i = 0; i < chname.length; i++) {\n+            if (Character.isUpperCase(chname[i]))\n+            {\n+                newStart = i;\n+                break;\n+            }\n+        }\n+\n+        name = name.substring(newStart);\n+        if (delimited) {\n+            name = delimit(rule, name).toString();\n+        }\n+        return name;\n+    }\n+\n+    public String removeHungarianNotation(String rule, String name) {\n+        return removeHungarianNotation(getNamingRule(rule), name);\n+    }\n+    \n+    public String[] splitName(String nrule, String name, String nameDelim) {\n+        return splitName(getNamingRule(nrule), name, nameDelim);\n+    }\n+        \n+    public String convert(IdentifierConfiguration config, String rule, String name) {\n+        // Already using same delimiter, no need to convert\n+        if (!needsConversion(config)) {\n+            return name;\n+        }\n+        // Otherwise, remove delimiters and add appropriate delimiters\n+        IdentifierRule orule = getIdentifierConfiguration().getIdentifierRule(rule);\n+        IdentifierRule nrule = config.getIdentifierRule(rule);\n+        boolean delimit = isDelimited(orule, name);\n+        if (delimit) {\n+            name = removeDelimiters(orule, name, config.getLeadingDelimiter(), \n+                config.getTrailingDelimiter());\n+            return delimit(config, nrule, name, delimit).toString();\n+        }\n+        return name;\n+    }\n+\n+    public String convertFull(IdentifierConfiguration config, String rule, String fullName) {\n+        if (!needsConversion(config)) {\n+            return fullName;\n+        }\n+        // Split\n+        String[] names = splitName(rule, fullName);\n+        // Convert\n+        for (int i = 0; i < names.length; i++) {\n+            names[i] = convert(config, rule, names[i]);\n+        }\n+        // Join\n+        return joinNames(config, config.getIdentifierRule(rule), names, config.getIdentifierDelimiter());\n+    }    \n+\n+    public String combineFull(IdentifierConfiguration config, String rule, String fullName) {\n+        if (!needsConversion(config)) {\n+            return fullName;\n+        }\n+        // Split\n+        String[] names = splitName(rule, fullName);\n+        // Convert\n+        for (int i = 0; i < names.length; i++) {\n+            names[i] = convert(config, rule, names[i]);\n+        }\n+        // Join\n+        return joinNames(config, config.getIdentifierRule(rule), names, config.getIdentifierDelimiter());\n+    }    \n+\n+\n+    private boolean needsConversion(IdentifierConfiguration config) {\n+        return !(config.getLeadingDelimiter().equals(getIdentifierConfiguration().getLeadingDelimiter()) &&\n+                 config.getTrailingDelimiter().equals(getIdentifierConfiguration().getTrailingDelimiter()) &&\n+                 config.getIdentifierDelimiter().equals(getIdentifierConfiguration().getIdentifierDelimiter()));\n+    }\n+\n+    private IdentifierRule[] getNamingRules(String[] rules) {\n+        IdentifierRule[] nrules = new IdentifierRule[rules.length];\n+        for (int i = 0; i < rules.length; i++) {\n+            nrules[i] = _config.getIdentifierRule(rules[i]);\n+        }\n+        return nrules;\n+    }\n+\n+    public void endConfiguration() {\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public boolean canSplit(String rule, String name) {\n+        return canSplit(getNamingRule(rule), name, _config.getIdentifierDelimiter());\n+    }\n+\n+    public boolean canSplit(IdentifierRule rule, String name) {\n+        return canSplit(rule, name, _config.getIdentifierDelimiter());\n+    }\n+\n+    public boolean canSplit(String rule, String name, String delim) {\n+        return canSplit(getNamingRule(rule), name);\n+    }\n+\n+    public boolean canSplit(IdentifierRule rule, String name, String delim) {\n+        if (name == null || name.length() == 0) {\n+            return false;\n+        }\n+        return name.contains(delim);\n+    }\n+\n+}"},{"sha":"b07591d38c058d9b92cffff6ea2a5a63ddac53a9","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/DefaultTestIdRule.java","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/DefaultTestIdRule.java","raw_url":"https://github.com/apache/openjpa/raw/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/DefaultTestIdRule.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/DefaultTestIdRule.java?ref=8e0e9cfbd2bd8616d6a30d3100cf609145d2342f","patch":"@@ -0,0 +1,25 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.identifier;\n+\n+import org.apache.openjpa.lib.identifier.IdentifierRule;\n+\n+public class DefaultTestIdRule extends IdentifierRule {\n+\n+}"},{"sha":"3e103a941c85fb2fc248d939b41d5dd180a645c5","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/IdConfigurationTestImpl.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/IdConfigurationTestImpl.java","raw_url":"https://github.com/apache/openjpa/raw/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/IdConfigurationTestImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/IdConfigurationTestImpl.java?ref=8e0e9cfbd2bd8616d6a30d3100cf609145d2342f","patch":"@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.identifier;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.identifier.IdentifierConfiguration;\n+import org.apache.openjpa.lib.identifier.IdentifierRule;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n+\n+public class IdConfigurationTestImpl implements IdentifierConfiguration {\n+\n+    Map<String, IdentifierRule> _rules = new HashMap<String, IdentifierRule>();\n+    \n+    public IdConfigurationTestImpl() {\n+        _rules.put(\"DEFAULT\", _defRule);\n+    }\n+    \n+    private IdentifierRule _defRule = new IdentifierRule();\n+    \n+    public boolean delimitAll() {\n+        return false;\n+    }\n+\n+    public IdentifierRule getDefaultIdentifierRule() {\n+        return _defRule;\n+    }\n+\n+    public String getDelimitedCase() {\n+        return IdentifierUtil.CASE_PRESERVE;\n+    }\n+\n+    public String getLeadingDelimiter() {\n+        return \"`\";\n+    }\n+\n+    public String getIdentifierDelimiter() {\n+        return \":\";\n+    }\n+\n+    public String getIdentifierConcatenator() {\n+        return \"-\";\n+    }\n+\n+    public <T> IdentifierRule getIdentifierRule(T t) {\n+        IdentifierRule r =  _rules.get(t);\n+        if (r == null) {\n+            return getDefaultIdentifierRule();\n+        }\n+        return r;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> Map<T, IdentifierRule> getIdentifierRules() {\n+        return (Map<T, IdentifierRule>) _rules;\n+    }\n+\n+    public String getTrailingDelimiter() {\n+        return \"`\";\n+    }\n+\n+    public String getSchemaCase() {\n+        return IdentifierUtil.CASE_UPPER;\n+    }\n+\n+    public boolean getSupportsDelimitedIdentifiers() {\n+        return true;\n+    }\n+\n+}"},{"sha":"60f75b6f1340121faff3933e0b88261759ec678c","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/NewIdConfigurationTestImpl.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/NewIdConfigurationTestImpl.java","raw_url":"https://github.com/apache/openjpa/raw/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/NewIdConfigurationTestImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/NewIdConfigurationTestImpl.java?ref=8e0e9cfbd2bd8616d6a30d3100cf609145d2342f","patch":"@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.identifier;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.identifier.IdentifierConfiguration;\n+import org.apache.openjpa.lib.identifier.IdentifierRule;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n+\n+public class NewIdConfigurationTestImpl implements IdentifierConfiguration {\n+\n+    Map<String, IdentifierRule> _rules = new HashMap<String, IdentifierRule>();\n+    \n+    public NewIdConfigurationTestImpl() {\n+        _rules.put(\"DEFAULT\", _defRule);\n+    }\n+    \n+    private IdentifierRule _defRule = new IdentifierRule();\n+    \n+    public boolean delimitAll() {\n+        return false;\n+    }\n+\n+    public IdentifierRule getDefaultIdentifierRule() {\n+        return _defRule;\n+    }\n+\n+    public String getDelimitedCase() {\n+        return IdentifierUtil.CASE_PRESERVE;\n+    }\n+\n+    public String getLeadingDelimiter() {\n+        return \"\\\"\";\n+    }\n+\n+    public String getIdentifierDelimiter() {\n+        return \".\";\n+    }\n+\n+    public String getIdentifierConcatenator() {\n+        return \"_\";\n+    }\n+\n+    public <T> IdentifierRule getIdentifierRule(T t) {\n+        IdentifierRule r =  _rules.get(t);\n+        if (r == null) {\n+            return getDefaultIdentifierRule();\n+        }\n+        return r;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> Map<T, IdentifierRule> getIdentifierRules() {\n+        return (Map<T, IdentifierRule>) _rules;\n+    }\n+\n+    public String getTrailingDelimiter() {\n+        return \"\\\"\";\n+    }\n+\n+    public String getSchemaCase() {\n+        return IdentifierUtil.CASE_UPPER;\n+    }\n+\n+    public boolean getSupportsDelimitedIdentifiers() {\n+        return true;\n+    }\n+\n+}"},{"sha":"2c5475842678e00637b0af363181c9f6b18cc40f","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/TestIdentifiers.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/TestIdentifiers.java","raw_url":"https://github.com/apache/openjpa/raw/8e0e9cfbd2bd8616d6a30d3100cf609145d2342f/openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/TestIdentifiers.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/identifier/TestIdentifiers.java?ref=8e0e9cfbd2bd8616d6a30d3100cf609145d2342f","patch":"@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.identifier;\n+\n+import org.apache.openjpa.lib.identifier.IdentifierConfiguration;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n+import org.apache.openjpa.lib.identifier.IdentifierUtilImpl;\n+import org.apache.openjpa.lib.test.AbstractTestCase;\n+\n+public class TestIdentifiers extends AbstractTestCase {\n+\n+    public void testIdentifierConversion() {\n+        \n+        // Create a naming configs used for testing.\n+        IdentifierConfiguration defConfig = new IdConfigurationTestImpl();\n+        IdentifierConfiguration newConfig = new NewIdConfigurationTestImpl();\n+        \n+        IdentifierUtil nu = new IdentifierUtilImpl(defConfig);\n+        \n+        // Test basic name conversion with single name converter\n+        String n0 = \"`TABLE`\";\n+        String cn0 = nu.convert(newConfig, \"DEFAULT\", n0);\n+        assertEquals(\"\\\"TABLE\\\"\", cn0);\n+        \n+        // Test basic name conversion with single name converter - no \n+        // conversion\n+        String n1 = \"TABLE\";\n+        String cn1 = nu.convert(newConfig, \"DEFAULT\", n1);\n+        assertEquals(\"TABLE\", cn1);\n+\n+        // Test basic name separator conversion with compound name converter\n+        String n2 = \"TABLE:SCHEMA\";\n+        String cn2 = nu.convertFull(newConfig, \"DEFAULT\", n2);\n+        assertEquals(\"TABLE.SCHEMA\", cn2);\n+\n+        String n3 = \"`TABLE`:`SCHEMA`\";\n+        String cn3 = nu.convertFull(newConfig, \"DEFAULT\", n3);\n+        assertEquals(\"\\\"TABLE\\\".\\\"SCHEMA\\\"\", cn3);\n+    }\n+    \n+    \n+}"}]}

