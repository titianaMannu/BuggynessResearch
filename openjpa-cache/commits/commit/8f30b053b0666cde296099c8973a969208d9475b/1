{"sha":"8f30b053b0666cde296099c8973a969208d9475b","node_id":"MDY6Q29tbWl0MjA2MzY0OjhmMzBiMDUzYjA2NjZjZGUyOTYwOTljODk3M2E5NjkyMDhkOTQ3NWI=","commit":{"author":{"name":"Donald Woods","email":"dwoods@apache.org","date":"2010-04-11T16:37:46Z"},"committer":{"name":"Donald Woods","email":"dwoods@apache.org","date":"2010-04-11T16:37:46Z"},"message":"OPENJPA-1179 openjpa.jdbc.QuerySQLCache plugin no longer accepts value=all, so doc it in the Migration section.  Testcase contributed by Tim McConnell.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/2.0.x@932934 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0832170f6c5abd0713c6928ec13acf33af2886d5","url":"https://api.github.com/repos/apache/openjpa/git/trees/0832170f6c5abd0713c6928ec13acf33af2886d5"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/8f30b053b0666cde296099c8973a969208d9475b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/8f30b053b0666cde296099c8973a969208d9475b","html_url":"https://github.com/apache/openjpa/commit/8f30b053b0666cde296099c8973a969208d9475b","comments_url":"https://api.github.com/repos/apache/openjpa/commits/8f30b053b0666cde296099c8973a969208d9475b/comments","author":null,"committer":null,"parents":[{"sha":"5b1132136df3153917d71cf0c2f02330406da183","url":"https://api.github.com/repos/apache/openjpa/commits/5b1132136df3153917d71cf0c2f02330406da183","html_url":"https://github.com/apache/openjpa/commit/5b1132136df3153917d71cf0c2f02330406da183"}],"stats":{"total":332,"additions":332,"deletions":0},"files":[{"sha":"30691e538c0df99512a38f50c03bbf5a16b59b63","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestQuerySQLCache.java","status":"added","additions":272,"deletions":0,"changes":272,"blob_url":"https://github.com/apache/openjpa/blob/8f30b053b0666cde296099c8973a969208d9475b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestQuerySQLCache.java","raw_url":"https://github.com/apache/openjpa/raw/8f30b053b0666cde296099c8973a969208d9475b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestQuerySQLCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestQuerySQLCache.java?ref=8f30b053b0666cde296099c8973a969208d9475b","patch":"@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.compat;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Persistence;\n+\n+import org.apache.openjpa.persistence.EntityManagerImpl;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+import org.apache.openjpa.persistence.OpenJPAPersistence;\n+import org.apache.openjpa.persistence.relations.TblChild;\n+import org.apache.openjpa.persistence.relations.TblGrandChild;\n+import org.apache.openjpa.persistence.relations.TblParent;\n+import org.apache.openjpa.persistence.simple.Person;\n+import org.apache.openjpa.persistence.test.AllowFailure;\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+/**\n+ * <b>TestQuerySQLCache</b> is used to verify multiple permutations of openjpa.jdbc.QuerySQLCache settings that were \n+ * valid in JPA 1.2 but may not be valid in JPA 2.0\n+ */\n+public class TestQuerySQLCache extends SingleEMFTestCase {\n+    \n+    final int nThreads = 5;\n+    final int nPeople = 100;\n+    final int nIterations = 10;\n+\n+    @Override\n+    public void setUp() {\n+        // need this to cleanup existing tables as some entity names are reused\n+        setUp(DROP_TABLES, Person.class, TblChild.class, TblGrandChild.class, TblParent.class);\n+    }\n+\n+    /*\n+     * Verify an exception is thrown if a bad cache implementation class is specified\n+     */\n+    public void testBadCustomCacheSetting() {\n+        Map props = new HashMap(System.getProperties());\n+        props.put(\"openjpa.MetaDataFactory\", \"jpa(Types=\" + Person.class.getName() + \")\");\n+        props.put(\"openjpa.jdbc.QuerySQLCache\", \n+                  \"org.apache.openjpa.persistence.compatible.TestQuerySQLCache.BadCacheMap\");\n+\n+        try {\n+            OpenJPAEntityManagerFactorySPI emf = (OpenJPAEntityManagerFactorySPI)OpenJPAPersistence.\n+                                                 cast(Persistence.createEntityManagerFactory(\"test\", props));\n+            // \n+            // EMF creation must throw an exception because the cache implementation class will not be found\n+            // \n+            assertFalse(false);\n+        }\n+        catch (Exception e) {\n+            assertTrue(true);\n+        }\n+    }\n+\n+\n+    /*\n+     * Verify multi-threaded multi-entity manager finder works with the QuerySQLCache set to \"all\"\n+     */\n+    @AllowFailure(message=\"OPENJPA-1179 2.0 doesn't allow 'all' as in previous releases\")\n+    public void testMultiEMCachingAll() {\n+        Map props = new HashMap(System.getProperties());\n+        props.put(\"openjpa.MetaDataFactory\", \"jpa(Types=\" + Person.class.getName() + \")\");\n+        props.put(\"openjpa.jdbc.QuerySQLCache\", \"all\");\n+        runMultiEMCaching(props);        \n+    }\n+\n+\n+    /*\n+     * Verify multi-threaded multi-entity manager finder works with the QuerySQLCache set to \"true\"\n+     */\n+    public void testMultiEMCachingTrue() {\n+        Map props = new HashMap(System.getProperties());\n+        props.put(\"openjpa.MetaDataFactory\", \"jpa(Types=\" + Person.class.getName() + \")\");\n+        props.put(\"openjpa.jdbc.QuerySQLCache\", \"true\");\n+        runMultiEMCaching(props);\n+    }\n+\n+\n+    /*\n+     * Verify QuerySQLCacheValue setting \"true\" uses the expected cache implementation and is caching\n+     */\n+    @AllowFailure(message=\"Fails after first run with duplicate key value in a unique PK constraint or index\")\n+    public void testEagerFetch() {\n+        Map props = new HashMap(System.getProperties());\n+        props.put(\"openjpa.MetaDataFactory\", \"jpa(Types=\" + TblChild.class.getName() + \";\"\n+                                                          + TblGrandChild.class.getName() + \";\"\n+                                                          + TblParent.class.getName() + \")\");\n+        props.put(\"openjpa.jdbc.QuerySQLCache\", \"true\");\n+\n+        OpenJPAEntityManagerFactorySPI emf = (OpenJPAEntityManagerFactorySPI) OpenJPAPersistence.\n+                                             cast(Persistence.createEntityManagerFactory(\"test\", props));\n+        EntityManagerImpl em = (EntityManagerImpl)emf.createEntityManager();\n+\n+        em.getTransaction().begin();\n+\n+        for (int i = 1; i < 3; i++) {\n+            TblParent p = new TblParent();\n+            p.setParentId(i);\n+            TblChild c = new TblChild();\n+            c.setChildId(i);\n+            c.setTblParent(p);\n+            p.addTblChild(c);\n+            em.persist(p);\n+            em.persist(c);\n+\n+            TblGrandChild gc = new TblGrandChild();\n+            gc.setGrandChildId(i);\n+            gc.setTblChild(c);\n+            c.addTblGrandChild(gc);\n+\n+            em.persist(p);\n+            em.persist(c);\n+            em.persist(gc);\n+        }\n+        em.flush();\n+        em.getTransaction().commit();\n+        em.clear();\n+\n+        for (int i = 1; i < 3; i++) {\n+            TblParent p = em.find(TblParent.class, i);\n+            int pid = p.getParentId();\n+            assertEquals(pid, i);\n+            Collection<TblChild> children = p.getTblChildren();\n+            boolean hasChild = false;\n+            for (TblChild c : children) {\n+                hasChild = true;\n+                Collection<TblGrandChild> gchildren = c.getTblGrandChildren();\n+                int cid = c.getChildId();\n+                assertEquals(cid, i);\n+                boolean hasGrandChild = false;\n+                for (TblGrandChild gc : gchildren) {\n+                    hasGrandChild = true;\n+                    int gcId = gc.getGrandChildId();\n+                    assertEquals(gcId, i);\n+                }\n+                assertTrue(hasGrandChild);\n+            }\n+            assertTrue(hasChild);\n+        }\n+        em.close();\n+        emf.close();\n+    }\n+\n+\n+    private void runMultiEMCaching(Map props) {\n+        EntityManagerFactory emfac = Persistence.createEntityManagerFactory(\"test\", props);\n+        EntityManager em = emfac.createEntityManager();            \n+\n+        // \n+        // Create some entities\n+        // \n+        em.getTransaction().begin();\n+        for (int i = 0; i < nPeople; i++) {\n+            Person p = new Person();\n+            p.setId(i);\n+            em.persist(p);\n+        }\n+        em.flush();\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        Thread[] newThreads = new Thread[nThreads];\n+        FindPeople[] customer = new FindPeople[nThreads];\n+        for (int i=0; i < nThreads; i++) {\n+            customer[i] = new FindPeople(emfac, 0, nPeople, nIterations, i);\n+            newThreads[i] = new Thread(customer[i]);\n+            newThreads[i].start();\n+        }\n+\n+        // \n+        // Wait for the worker threads to complete\n+        // \n+        for (int i = 0; i < nThreads; i++) {\n+            try {\n+                newThreads[i].join();\n+            }\n+            catch (InterruptedException e) {\n+                this.fail(\"Caught Interrupted Exception: \" + e);\n+            }\n+        }   \n+\n+        // \n+        // Run through the state of all runnables to assert if any of them failed.\n+        // \n+        for (int i = 0; i < nThreads; i++) {\n+            assertFalse(customer[i].hadFailures());\n+        }\n+\n+        // \n+        // Clean up the entities used in this test\n+        // \n+        em = emfac.createEntityManager();            \n+        em.getTransaction().begin();\n+        for (int i = 0; i < nPeople; i++) {\n+            Person p = em.find(Person.class, i);\n+            em.remove(p);\n+        }\n+        em.flush();\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+    \n+    \n+    /*\n+     * Simple runnable to test finder in a tight loop.  Multiple instances of this runnable will run simultaneously\n+     */\n+    private class FindPeople implements Runnable {\n+        private int startId;\n+        private int endId;\n+        private int thread;\n+        private int iterations;\n+        private EntityManagerFactory emf;\n+        private boolean failures = false;\n+\n+        public FindPeople(EntityManagerFactory emf, int startId, int endId, int iterations, int thread) {\n+            super();\n+            this.startId = startId;\n+            this.endId = endId;\n+            this.thread = thread;\n+            this.iterations = iterations;\n+            this.emf = emf;\n+        }\n+\n+        public boolean hadFailures() {\n+            return failures;\n+        }\n+\n+        public void run() {\n+            try {\n+                EntityManager em = emf.createEntityManager();            \n+                for (int j = 0; j < iterations; j++) {\n+\n+                    for (int i = startId; i < endId; i++) {\n+                        Person p1 = em.find(Person.class, i);\n+                        if (p1.getId() != i) {\n+                            System.out.println(\"Finder failed: \" + i);\n+                            failures = true;\n+                            break;\n+                        }\n+                    }\n+                    em.clear();  \n+                }\n+                em.close();  \n+            }\n+            catch (Exception e) {\n+                failures = true;\n+                System.out.println(\"Thread \" + thread + \" exception :\" + e );\n+            }\n+        }\n+    }\n+}"},{"sha":"52debcd1bb557dad1474b9cc4e2cef9368622da9","filename":"openjpa-project/src/doc/manual/migration_considerations.xml","status":"modified","additions":16,"deletions":0,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/8f30b053b0666cde296099c8973a969208d9475b/openjpa-project/src/doc/manual/migration_considerations.xml","raw_url":"https://github.com/apache/openjpa/raw/8f30b053b0666cde296099c8973a969208d9475b/openjpa-project/src/doc/manual/migration_considerations.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/migration_considerations.xml?ref=8f30b053b0666cde296099c8973a969208d9475b","patch":"@@ -204,6 +204,22 @@\n                     </simplelist>\n                 </para>\n             </section>\n+            <section id=\"QuerySQLCache\">\n+                <title>\n+                    openjpa.jdbc.QuerySQLCache\n+                </title>\n+                <!-- See OPENJPA-1179 for details. -->\n+                <para>\n+                    In prior 1.x.x releases, the openjpa.jdbc.QuerySQLCache\n+                    configuration property for Prepared SQL Cache accepted\n+                    value <literal>all</literal> to never drop items from the\n+                    cache, but this option is no longer supported and will cause\n+                    a PersistenceException with a root cause of a ParseException\n+                    to be thrown.  See \n+                    <xref linkend=\"ref_guide_cache_querysql\"/>\n+                    for details on the available configuration values.\n+                </para>\n+            </section>\n         </section>\n         <section id=\"Disabling AutoOff Collection Tracking\">\n             <title>"},{"sha":"5ebd9de58013fa7d80a97c917ef63944cc31d471","filename":"openjpa-project/src/doc/manual/ref_guide_caching.xml","status":"modified","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/8f30b053b0666cde296099c8973a969208d9475b/openjpa-project/src/doc/manual/ref_guide_caching.xml","raw_url":"https://github.com/apache/openjpa/raw/8f30b053b0666cde296099c8973a969208d9475b/openjpa-project/src/doc/manual/ref_guide_caching.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_caching.xml?ref=8f30b053b0666cde296099c8973a969208d9475b","patch":"@@ -1166,6 +1166,50 @@ property accepts a plugin string (see <xref linkend=\"ref_guide_conf_plugins\"/>)\n with value of <literal>true</literal> or <literal>false</literal>. The default\n is <literal>true</literal>. \n </para>\n+        <table>\n+            <title>\n+                Pre-defined aliases\n+            </title>\n+            <tgroup cols=\"2\" align=\"left\" colsep=\"1\" rowsep=\"1\">\n+                <colspec colname=\"alias\"/>\n+                <colspec colname=\"value\"/>\n+                <colspec colname=\"notes\"/>\n+                <thead>\n+                    <row>\n+                        <entry colname=\"alias\">Alias</entry>\n+                        <entry colname=\"value\">Value</entry>\n+                        <entry colname=\"notes\">Notes</entry>\n+                    </row>\n+                </thead>\n+                <tbody>\n+                    <row>\n+                        <entry colname=\"alias\">\n+<literal>true</literal>\n+                        </entry>\n+                        <entry colname=\"value\">\n+<literal>org.apache.openjpa.util.CacheMap</literal>\n+                        </entry>\n+                        <entry colname=\"notes\">\n+The default option.  Uses a\n+<ulink url=\"../javadoc/org/apache/openjpa/util/CacheMap.html\">\n+<literal>CacheMap</literal></ulink> to store SQL string.\n+<literal>CacheMap</literal> maintains a fixed number of cache entries, and an\n+optional soft reference map for entries that are moved out of the LRU space.\n+So, for applications that have a monotonically increasing number of distinct\n+queries, this option can be used to ensure that a fixed amount of memory is\n+used by the cache.\n+                        </entry>\n+                    </row>\n+                    <row>\n+                        <entry colname=\"alias\"><literal>false</literal></entry>\n+                        <entry colname=\"value\"><emphasis>none</emphasis></entry>\n+                        <entry colname=\"notes\">\n+Disables the SQL cache.\n+                        </entry>\n+                    </row>\n+                </tbody>\n+            </tgroup>\n+        </table>\n <para>\n Following salient points to be noted regarding usage of Prepared Query Cache.\n <itemizedlist>"}]}

