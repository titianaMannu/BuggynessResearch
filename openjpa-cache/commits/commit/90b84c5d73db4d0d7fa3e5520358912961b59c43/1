{"sha":"90b84c5d73db4d0d7fa3e5520358912961b59c43","node_id":"MDY6Q29tbWl0MjA2MzY0OjkwYjg0YzVkNzNkYjRkMGQ3ZmEzZTU1MjAzNTg5MTI5NjFiNTljNDM=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-22T23:37:24Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-22T23:37:24Z"},"message":"OPENJPA-896. Setting eol-style:native and removing windows eol characters from source files.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@757278 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"acb22a46ce954612c3f359175e18ce97ad6ecf85","url":"https://api.github.com/repos/apache/openjpa/git/trees/acb22a46ce954612c3f359175e18ce97ad6ecf85"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/90b84c5d73db4d0d7fa3e5520358912961b59c43","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/90b84c5d73db4d0d7fa3e5520358912961b59c43","html_url":"https://github.com/apache/openjpa/commit/90b84c5d73db4d0d7fa3e5520358912961b59c43","comments_url":"https://api.github.com/repos/apache/openjpa/commits/90b84c5d73db4d0d7fa3e5520358912961b59c43/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"c3175eea3c3885286898170fae6b487b070f60b5","url":"https://api.github.com/repos/apache/openjpa/commits/c3175eea3c3885286898170fae6b487b070f60b5","html_url":"https://github.com/apache/openjpa/commit/c3175eea3c3885286898170fae6b487b070f60b5"}],"stats":{"total":382166,"additions":191083,"deletions":191083},"files":[{"sha":"607e63df617fffdc99a4bbb62612e63b2d0f9492","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","status":"modified","additions":553,"deletions":553,"changes":1106,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,554 +1,554 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import java.sql.Connection;\r\n-import java.sql.SQLException;\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\r\n-import org.apache.openjpa.jdbc.schema.Table;\r\n-import org.apache.openjpa.jdbc.sql.PrimaryRow;\r\n-import org.apache.openjpa.jdbc.sql.Row;\r\n-import org.apache.openjpa.jdbc.sql.RowImpl;\r\n-import org.apache.openjpa.jdbc.sql.RowManager;\r\n-import org.apache.openjpa.jdbc.sql.RowManagerImpl;\r\n-import org.apache.openjpa.jdbc.sql.SQLExceptions;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.lib.graph.DepthFirstAnalysis;\r\n-import org.apache.openjpa.lib.graph.Edge;\r\n-import org.apache.openjpa.lib.graph.Graph;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.OpenJPAException;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * <p>Standard update manager, capable of foreign key constraint evaluation.</p>\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ConstraintUpdateManager\r\n-    extends AbstractUpdateManager {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (ConstraintUpdateManager.class);\r\n-\r\n-    public boolean orderDirty() {\r\n-        return true;\r\n-    }\r\n-\r\n-    protected PreparedStatementManager newPreparedStatementManager\r\n-        (JDBCStore store, Connection conn) {\r\n-        return new PreparedStatementManagerImpl(store, conn);\r\n-    }\r\n-\r\n-    protected RowManager newRowManager() {\r\n-        return new RowManagerImpl(false);\r\n-    }\r\n-\r\n-    protected Collection flush(RowManager rowMgr,\r\n-        PreparedStatementManager psMgr, Collection exceps) {\r\n-        RowManagerImpl rmimpl = (RowManagerImpl) rowMgr;\r\n-\r\n-        // first take care of all secondary table deletes and 'all row' deletes\r\n-        // (which are probably secondary table deletes), since no foreign\r\n-        // keys ever rely on secondary table pks\r\n-        flush(rmimpl.getAllRowDeletes(), psMgr);\r\n-        flush(rmimpl.getSecondaryDeletes(), psMgr);\r\n-\r\n-        // now do any 'all row' updates\r\n-        flush(rmimpl.getAllRowUpdates(), psMgr);\r\n-\r\n-        // analyze foreign keys\r\n-        Collection<PrimaryRow> inserts = rmimpl.getInserts();\r\n-        Collection<PrimaryRow> updates = rmimpl.getUpdates();\r\n-        Collection<PrimaryRow> deletes = rmimpl.getDeletes();\r\n-    \r\n-        Graph[] graphs = new Graph[2];    // insert graph, delete graph\r\n-        analyzeForeignKeys(inserts, updates, deletes, rmimpl, graphs);\r\n-\r\n-        // flush insert graph, if any\r\n-        boolean autoAssign = rmimpl.hasAutoAssignConstraints();\r\n-        try {\r\n-            flushGraph(graphs[0], psMgr, autoAssign);\r\n-        } catch (SQLException se) {\r\n-            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\r\n-        } catch (OpenJPAException ke) {\r\n-            exceps = addException(exceps, ke);\r\n-        }\r\n-\r\n-        // flush the rest of the inserts and updates; inserts before updates\r\n-        // because some update fks might reference pks that have to be inserted\r\n-        flush(inserts, psMgr);\r\n-        flush(updates, psMgr);\r\n-\r\n-        // flush the delete graph, if any\r\n-        try {\r\n-            flushGraph(graphs[1], psMgr, autoAssign);\r\n-        } catch (SQLException se) {\r\n-            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\r\n-        } catch (OpenJPAException ke) {\r\n-            exceps = addException(exceps, ke);\r\n-        }\r\n-\r\n-        // put the remainder of the deletes after updates because some updates\r\n-        // may be nulling fks to rows that are going to be deleted\r\n-        flush(deletes, psMgr);\r\n-\r\n-        // take care of all secondary table inserts and updates last, since\r\n-        // they may rely on previous inserts or updates, but nothing relies\r\n-        // on them\r\n-        flush(rmimpl.getSecondaryUpdates(), psMgr);\r\n-\r\n-        // flush any left over prepared statements\r\n-        psMgr.flush();\r\n-        return exceps;\r\n-    }\r\n-\r\n-    /**\r\n-     * Analyze foreign key dependencies on the given rows\r\n-     * and create an insert and a delete graph to execute.  The insert\r\n-     * graph will be flushed before all other rows, and the delete graph will\r\n-     * be flushed after them.\r\n-     */\r\n-    private void analyzeForeignKeys(Collection inserts, Collection updates,\r\n-        Collection deletes, RowManagerImpl rowMgr, Graph[] graphs) {\r\n-        // if there are any deletes, we have to map the insert objects on their\r\n-        // oids so we'll be able to detect delete-then-insert-same-pk cases\r\n-        Map insertMap = null;\r\n-        OpenJPAStateManager sm;\r\n-        if (!deletes.isEmpty() && !inserts.isEmpty()) {\r\n-            insertMap = new HashMap((int) (inserts.size() * 1.33 + 1));\r\n-            for (Iterator itr = inserts.iterator(); itr.hasNext();) {\r\n-                sm = ((Row) itr.next()).getPrimaryKey();\r\n-                if (sm != null && sm.getObjectId() != null)\r\n-                    insertMap.put(sm.getObjectId(), sm);\r\n-            }\r\n-        }\r\n-\r\n-        // first construct the graph for deletes; this may expand to include\r\n-        // inserts and updates as well if there are any inserts that rely on\r\n-        // deletes (delete-then-insert-same-pk cases)\r\n-        PrimaryRow row;\r\n-        Row row2;\r\n-        ForeignKey[] fks;\r\n-        OpenJPAStateManager fkVal;\r\n-        boolean ignoreUpdates = true;\r\n-        for (Iterator itr = deletes.iterator(); itr.hasNext();) {\r\n-            row = (PrimaryRow) itr.next();\r\n-            if (!row.isValid())\r\n-                continue;\r\n-\r\n-            row2 = getInsertRow(insertMap, rowMgr, row);\r\n-            if (row2 != null) {\r\n-                ignoreUpdates = false;\r\n-                graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row, null);\r\n-            }\r\n-\r\n-            // now check this row's fks against other deletes\r\n-            fks = row.getTable().getForeignKeys();\r\n-            for (int j = 0; j < fks.length; j++) {\r\n-                // when deleting ref fks they'll just set a where value, so\r\n-                // check both for fk updates (relation fks) and wheres (ref fks)\r\n-                fkVal = row.getForeignKeySet(fks[j]);\r\n-                if (fkVal == null)\r\n-                    fkVal = row.getForeignKeyWhere(fks[j]);\r\n-                if (fkVal == null)\r\n-                    continue;\r\n-\r\n-                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\r\n-                    Row.ACTION_DELETE, fkVal, false);\r\n-                if (row2 != null && row2.isValid() && row2 != row)\r\n-                    graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row,\r\n-                        fks[j]);\r\n-            }\r\n-        }\r\n-\r\n-        if (ignoreUpdates)\r\n-            graphs[0] = analyzeAgainstInserts(inserts, rowMgr, graphs[0]);\r\n-        else {\r\n-            // put inserts *and updates* in the delete graph; they all rely\r\n-            // on each other\r\n-            graphs[1] = analyzeAgainstInserts(updates, rowMgr, graphs[1]);\r\n-            graphs[1] = analyzeAgainstInserts(inserts, rowMgr, graphs[1]);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if there is an insert for for the same table and primary\r\n-     * key values as the given delete row.\r\n-     */\r\n-    private Row getInsertRow(Map insertMap, RowManagerImpl rowMgr, Row row) {\r\n-        if (insertMap == null)\r\n-            return null;\r\n-\r\n-        OpenJPAStateManager sm = row.getPrimaryKey();\r\n-        if (sm == null)\r\n-            return null;\r\n-\r\n-        // look for a new object whose insert id is the same as this delete one\r\n-        Object oid = sm.getObjectId();\r\n-        OpenJPAStateManager nsm = (OpenJPAStateManager) insertMap.get(oid);\r\n-        if (nsm == null)\r\n-            return null;\r\n-\r\n-        // found new object; get its row\r\n-        row = rowMgr.getRow(row.getTable(), Row.ACTION_INSERT, nsm, false);\r\n-        return (row == null || row.isValid()) ? row : null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Analyze the given rows against the inserts, placing dependencies\r\n-     * in the given graph.\r\n-     */\r\n-    private Graph analyzeAgainstInserts(Collection rows, RowManagerImpl rowMgr,\r\n-        Graph graph) {\r\n-        PrimaryRow row;\r\n-        Row row2;\r\n-        ForeignKey[] fks;\r\n-        Column[] cols;\r\n-        for (Iterator itr = rows.iterator(); itr.hasNext();) {\r\n-            row = (PrimaryRow) itr.next();\r\n-            if (!row.isValid())\r\n-                continue;\r\n-\r\n-            // check this row's fks against inserts; a logical fk to an auto-inc\r\n-            // column is treated just as actual database fk because the result\r\n-            // is the same: the pk row has to be inserted before the fk row\r\n-            fks = row.getTable().getForeignKeys();\r\n-            for (int j = 0; j < fks.length; j++) {\r\n-                if (row.getForeignKeySet(fks[j]) == null)\r\n-                    continue;\r\n-\r\n-                // see if this row is dependent on another.  if it's only\r\n-                // depenent on itself, see if the fk is logical or deferred, in\r\n-                // which case it must be an auto-inc because otherwise we\r\n-                // wouldn't have recorded it\r\n-                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\r\n-                    Row.ACTION_INSERT, row.getForeignKeySet(fks[j]), false);\r\n-                if (row2 != null && row2.isValid() && (row2 != row\r\n-                    || fks[j].isDeferred() || fks[j].isLogical()))\r\n-                    graph = addEdge(graph, row, (PrimaryRow) row2, fks[j]);\r\n-            }\r\n-\r\n-            // see if there are any relation id columns dependent on\r\n-            // auto-inc objects\r\n-            cols = row.getTable().getRelationIdColumns();\r\n-            for (int j = 0; j < cols.length; j++) {\r\n-                OpenJPAStateManager sm = row.getRelationIdSet(cols[j]);\r\n-                if (sm == null)\r\n-                    continue;\r\n-\r\n-                row2 = rowMgr.getRow(getBaseTable(sm), Row.ACTION_INSERT,\r\n-                    sm, false);\r\n-                if (row2 != null && row2.isValid())\r\n-                    graph = addEdge(graph, row, (PrimaryRow) row2, cols[j]);\r\n-            }\r\n-        }\r\n-        return graph;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the base table for the given instance.\r\n-     */\r\n-    private static Table getBaseTable(OpenJPAStateManager sm) {\r\n-        ClassMapping cls = (ClassMapping) sm.getMetaData();\r\n-        while (cls.getJoinablePCSuperclassMapping() != null)\r\n-            cls = cls.getJoinablePCSuperclassMapping();\r\n-        return cls.getTable();\r\n-    }\r\n-\r\n-    /**\r\n-     * Add an edge between the given rows in the given foreign key graph.\r\n-     */\r\n-    private Graph addEdge(Graph graph, PrimaryRow row1, PrimaryRow row2,\r\n-        Object fk) {\r\n-        // delay creation of the graph\r\n-        if (graph == null)\r\n-            graph = new Graph();\r\n-\r\n-        row1.setDependent(true);\r\n-        row2.setDependent(true);\r\n-        graph.addNode(row1);\r\n-        graph.addNode(row2);\r\n-\r\n-        // add an edge from row1 to row2, and set the fk causing the\r\n-        // dependency as the user object so we can retrieve it when resolving\r\n-        // circular constraints\r\n-        Edge edge = new Edge(row1, row2, true);\r\n-        edge.setUserObject(fk);\r\n-        graph.addEdge(edge);\r\n-\r\n-        return graph;\r\n-    }\r\n-\r\n-    /**\r\n-     * Flush the given graph of rows in the proper order.\r\n-     * @param graph The graph of statements to be walked\r\n-     * @param psMgr The prepared statement manager to use to issue the\r\n-     * statements\r\n-     * @param autoAssign Whether any of the rows in the graph have any\r\n-     * auto-assign constraints\r\n-     */\r\n-    protected void flushGraph(Graph graph, PreparedStatementManager psMgr,\r\n-        boolean autoAssign)\r\n-        throws SQLException {\r\n-        if (graph == null)\r\n-            return;\r\n-\r\n-        DepthFirstAnalysis dfa = newDepthFirstAnalysis(graph, autoAssign);\r\n-        Collection insertUpdates = new LinkedList();\r\n-        Collection deleteUpdates = new LinkedList();\r\n-        boolean recalculate;\r\n-\r\n-        // Handle circular constraints:\r\n-        // - if deleted row A has a ciricular fk to deleted row B, \r\n-        //   then use an update statement to null A's fk to B before flushing, \r\n-        //   and then flush\r\n-        // - if inserted row A has a circular fk to updated/inserted row B,\r\n-        //   then null the fk in the B row object, then flush,\r\n-        //   and after flushing, use an update to set the fk back to A\r\n-        // Depending on where circular dependencies are broken, the  \r\n-        // topological order of the graph nodes has to be re-calculated.\r\n-        recalculate = resolveCycles(graph, dfa.getEdges(Edge.TYPE_BACK),\r\n-                deleteUpdates, insertUpdates);\r\n-        recalculate |= resolveCycles(graph, dfa.getEdges(Edge.TYPE_FORWARD),\r\n-                deleteUpdates, insertUpdates);\r\n-\r\n-        if (recalculate) {\r\n-            dfa = recalculateDepthFirstAnalysis(graph, autoAssign);\r\n-        }\r\n-\r\n-        // flush delete updates to null fks, then all rows in order, then\r\n-        // the insert updates to set circular fk values\r\n-        Collection nodes = dfa.getSortedNodes();\r\n-        flush(deleteUpdates, nodes, psMgr);\r\n-        flush(insertUpdates, psMgr);\r\n-    }\r\n-\r\n-    protected void flush(Collection deleteUpdates, Collection nodes,\r\n-    \tPreparedStatementManager psMgr) {\r\n-        flush(deleteUpdates, psMgr);\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();)\r\n-            psMgr.flush((RowImpl) itr.next());\r\n-    }\r\n-\r\n-    /**\r\n-     * Break a circular dependency caused by delete operations.\r\n-     * If deleted row A has a ciricular fk to deleted row B, then use an update \r\n-     * statement to null A's fk to B before deleting B, then delete A.\r\n-     * @param edge Edge in the dependency graph corresponding to a foreign key\r\n-     * constraint. This dependency is broken by nullifying the foreign key.\r\n-     * @param deleteUpdates Collection of update statements that are executed\r\n-     * before the delete operations are flushed \r\n-     */\r\n-    private void addDeleteUpdate(Edge edge, Collection deleteUpdates)\r\n-        throws SQLException {\r\n-        PrimaryRow row;\r\n-        RowImpl update;\r\n-        ForeignKey fk;\r\n-\r\n-        // copy where conditions into new update that nulls the fk\r\n-        row = (PrimaryRow) edge.getTo();\r\n-        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\r\n-        row.copyInto(update, true);\r\n-        if (edge.getUserObject() instanceof ForeignKey) {\r\n-            fk = (ForeignKey) edge.getUserObject();\r\n-            update.setForeignKey(fk, row.getForeignKeyIO(fk), null);\r\n-        } else\r\n-            update.setNull((Column) edge.getUserObject());\r\n-\r\n-        deleteUpdates.add(update);\r\n-    }\r\n-\r\n-    /**\r\n-     * Break a circular dependency caused by insert operations.\r\n-     * If inserted row A has a circular fk to updated/inserted row B,\r\n-     * then null the fk in the B row object, then flush,\r\n-     * and after flushing, use an update to set the fk back to A.\r\n-     * @param row Row to be flushed\r\n-     * @param edge Edge in the dependency graph corresponding to a foreign key\r\n-     * constraint. This dependency is broken by nullifying the foreign key.\r\n-     * @param insertUpdates Collection of update statements that are executed\r\n-     * after the insert/update operations are flushed \r\n-     */\r\n-    private void addInsertUpdate(PrimaryRow row, Edge edge,\r\n-        Collection insertUpdates) throws SQLException {\r\n-        RowImpl update;\r\n-        ForeignKey fk;\r\n-        Column col;\r\n-\r\n-        // copy where conditions into new update that sets the fk\r\n-        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\r\n-        if (row.getAction() == Row.ACTION_INSERT) {\r\n-            if (row.getPrimaryKey() == null)\r\n-                throw new InternalException(_loc.get(\"ref-cycle\"));\r\n-            update.wherePrimaryKey(row.getPrimaryKey());\r\n-        } else {\r\n-            // Row.ACTION_UPDATE\r\n-            row.copyInto(update, true);\r\n-        }\r\n-        if (edge.getUserObject() instanceof ForeignKey) {\r\n-            fk = (ForeignKey) edge.getUserObject();\r\n-            update.setForeignKey(fk, row.getForeignKeyIO(fk),\r\n-                row.getForeignKeySet(fk));\r\n-            row.clearForeignKey(fk);\r\n-        } else {\r\n-            col = (Column) edge.getUserObject();\r\n-            update.setRelationId(col, row.getRelationIdSet(col),\r\n-                row.getRelationIdCallback(col));\r\n-            row.clearRelationId(col);\r\n-        }\r\n-\r\n-        insertUpdates.add(update);\r\n-    }\r\n-\r\n-    /**\r\n-     * Finds a nullable foreign key by walking the dependency cycle. \r\n-     * Circular dependencies can be broken at this point.\r\n-     * @param cycle Cycle in the dependency graph.\r\n-     * @return Edge corresponding to a nullable foreign key.\r\n-     */\r\n-    private Edge findBreakableLink(List cycle) {\r\n-        Edge breakableLink = null;\r\n-        for (Iterator iter = cycle.iterator(); iter.hasNext(); ) {\r\n-            Edge edge = (Edge) iter.next();\r\n-            Object userObject = edge.getUserObject();\r\n-            if (userObject instanceof ForeignKey) {\r\n-                 if (!((ForeignKey) userObject).hasNotNullColumns()) {\r\n-                     breakableLink = edge;\r\n-                     break;\r\n-                 }\r\n-            } else if (userObject instanceof Column) {\r\n-                if (!((Column) userObject).isNotNull()) {\r\n-                    breakableLink = edge;\r\n-                    break;\r\n-                }\r\n-            }\r\n-        }\r\n-        return breakableLink;\r\n-    }\r\n-\r\n-    /**\r\n-     * Re-calculates the DepthFirstSearch analysis of the graph \r\n-     * after some of the edges have been removed. Ensures\r\n-     * that the dependency graph is cycle free.\r\n-     * @param graph The graph of statements to be walked\r\n-     * @param autoAssign Whether any of the rows in the graph have any\r\n-     * auto-assign constraints\r\n-     */\r\n-    private DepthFirstAnalysis recalculateDepthFirstAnalysis(Graph graph,\r\n-        boolean autoAssign) {\r\n-        DepthFirstAnalysis dfa;\r\n-        // clear previous traversal data\r\n-        graph.clearTraversal();\r\n-        dfa = newDepthFirstAnalysis(graph, autoAssign);\r\n-        // make sure that the graph is non-cyclic now\r\n-        assert (dfa.hasNoCycles()): _loc.get(\"graph-not-cycle-free\");\r\n-        return dfa;\r\n-    }\r\n-\r\n-    /**\r\n-     * Resolve circular dependencies by identifying and breaking\r\n-     * a nullable foreign key.\r\n-     * @param graph Dependency graph.\r\n-     * @param edges Collection of edges. Each edge indicates a possible \r\n-     * circular dependency\r\n-     * @param deleteUpdates Collection of update operations (nullifying \r\n-     * foreign keys) to be filled. These updates will be executed before \r\n-     * the rows in the dependency graph are flushed\r\n-     * @param insertUpdates CCollection of update operations (nullifying \r\n-     * foreign keys) to be filled. These updates will be executed after \r\n-     * the rows in the dependency graph are flushed\r\n-     * @return Depending on where circular dependencies are broken, the  \r\n-     * topological order of the graph nodes has to be re-calculated.\r\n-     */\r\n-    private boolean resolveCycles(Graph graph, Collection edges,\r\n-        Collection deleteUpdates, Collection insertUpdates)\r\n-        throws SQLException {\r\n-        boolean recalculate = false;\r\n-        for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n-            Edge edge = (Edge) itr.next();\r\n-            List cycle = edge.getCycle();\r\n-\r\n-            if (cycle != null) {\r\n-                // find a nullable foreign key\r\n-                Edge breakableLink = findBreakableLink(cycle);\r\n-                if (breakableLink == null) {\r\n-                    throw new UserException(_loc.get(\"no-nullable-fk\"));\r\n-                }\r\n-\r\n-                // topologic node order must be re-calculated,  if the\r\n-                // breakable link is different from the edge where\r\n-                // the circular dependency was originally detected\r\n-                if (edge != breakableLink) {\r\n-                    recalculate = true;\r\n-                }\r\n-\r\n-                if (!breakableLink.isRemovedFromGraph()) {\r\n-\r\n-                    // use a primary row update to prevent setting pk and fk values\r\n-                    // until after flush, to get latest auto-increment values\r\n-                    PrimaryRow row = (PrimaryRow) breakableLink.getFrom();\r\n-                    if (row.getAction() == Row.ACTION_DELETE) {\r\n-                        addDeleteUpdate(breakableLink, deleteUpdates);\r\n-                    } else {\r\n-                        addInsertUpdate(row, breakableLink, insertUpdates);\r\n-                    }\r\n-                    graph.removeEdge(breakableLink);\r\n-                }\r\n-            }\r\n-        }\r\n-        return recalculate;\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new {@link DepthFirstAnalysis} suitable for the given graph\r\n-     * and auto-assign settings.\r\n-     */\r\n-    protected DepthFirstAnalysis newDepthFirstAnalysis(Graph graph,\r\n-        boolean autoAssign) {\r\n-        return new DepthFirstAnalysis(graph);\r\n-    }\r\n-\r\n-    /**\r\n-     * Flush the given collection of secondary rows.\r\n-     */\r\n-    protected void flush(Collection rows, PreparedStatementManager psMgr) {\r\n-        if (rows.size() == 0)\r\n-            return;\r\n-\r\n-        RowImpl row;\r\n-        for (Iterator itr = rows.iterator(); itr.hasNext(); ) {\r\n-            row = (RowImpl) itr.next();\r\n-            if (!row.isFlushed() && row.isValid() && !row.isDependent()) {\r\n-                psMgr.flush(row);\r\n-                row.setFlushed(true);\r\n-            }\r\n-        }\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.PrimaryRow;\n+import org.apache.openjpa.jdbc.sql.Row;\n+import org.apache.openjpa.jdbc.sql.RowImpl;\n+import org.apache.openjpa.jdbc.sql.RowManager;\n+import org.apache.openjpa.jdbc.sql.RowManagerImpl;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.lib.graph.DepthFirstAnalysis;\n+import org.apache.openjpa.lib.graph.Edge;\n+import org.apache.openjpa.lib.graph.Graph;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * <p>Standard update manager, capable of foreign key constraint evaluation.</p>\n+ *\n+ * @since 1.0.0\n+ */\n+public class ConstraintUpdateManager\n+    extends AbstractUpdateManager {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ConstraintUpdateManager.class);\n+\n+    public boolean orderDirty() {\n+        return true;\n+    }\n+\n+    protected PreparedStatementManager newPreparedStatementManager\n+        (JDBCStore store, Connection conn) {\n+        return new PreparedStatementManagerImpl(store, conn);\n+    }\n+\n+    protected RowManager newRowManager() {\n+        return new RowManagerImpl(false);\n+    }\n+\n+    protected Collection flush(RowManager rowMgr,\n+        PreparedStatementManager psMgr, Collection exceps) {\n+        RowManagerImpl rmimpl = (RowManagerImpl) rowMgr;\n+\n+        // first take care of all secondary table deletes and 'all row' deletes\n+        // (which are probably secondary table deletes), since no foreign\n+        // keys ever rely on secondary table pks\n+        flush(rmimpl.getAllRowDeletes(), psMgr);\n+        flush(rmimpl.getSecondaryDeletes(), psMgr);\n+\n+        // now do any 'all row' updates\n+        flush(rmimpl.getAllRowUpdates(), psMgr);\n+\n+        // analyze foreign keys\n+        Collection<PrimaryRow> inserts = rmimpl.getInserts();\n+        Collection<PrimaryRow> updates = rmimpl.getUpdates();\n+        Collection<PrimaryRow> deletes = rmimpl.getDeletes();\n+    \n+        Graph[] graphs = new Graph[2];    // insert graph, delete graph\n+        analyzeForeignKeys(inserts, updates, deletes, rmimpl, graphs);\n+\n+        // flush insert graph, if any\n+        boolean autoAssign = rmimpl.hasAutoAssignConstraints();\n+        try {\n+            flushGraph(graphs[0], psMgr, autoAssign);\n+        } catch (SQLException se) {\n+            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\n+        } catch (OpenJPAException ke) {\n+            exceps = addException(exceps, ke);\n+        }\n+\n+        // flush the rest of the inserts and updates; inserts before updates\n+        // because some update fks might reference pks that have to be inserted\n+        flush(inserts, psMgr);\n+        flush(updates, psMgr);\n+\n+        // flush the delete graph, if any\n+        try {\n+            flushGraph(graphs[1], psMgr, autoAssign);\n+        } catch (SQLException se) {\n+            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\n+        } catch (OpenJPAException ke) {\n+            exceps = addException(exceps, ke);\n+        }\n+\n+        // put the remainder of the deletes after updates because some updates\n+        // may be nulling fks to rows that are going to be deleted\n+        flush(deletes, psMgr);\n+\n+        // take care of all secondary table inserts and updates last, since\n+        // they may rely on previous inserts or updates, but nothing relies\n+        // on them\n+        flush(rmimpl.getSecondaryUpdates(), psMgr);\n+\n+        // flush any left over prepared statements\n+        psMgr.flush();\n+        return exceps;\n+    }\n+\n+    /**\n+     * Analyze foreign key dependencies on the given rows\n+     * and create an insert and a delete graph to execute.  The insert\n+     * graph will be flushed before all other rows, and the delete graph will\n+     * be flushed after them.\n+     */\n+    private void analyzeForeignKeys(Collection inserts, Collection updates,\n+        Collection deletes, RowManagerImpl rowMgr, Graph[] graphs) {\n+        // if there are any deletes, we have to map the insert objects on their\n+        // oids so we'll be able to detect delete-then-insert-same-pk cases\n+        Map insertMap = null;\n+        OpenJPAStateManager sm;\n+        if (!deletes.isEmpty() && !inserts.isEmpty()) {\n+            insertMap = new HashMap((int) (inserts.size() * 1.33 + 1));\n+            for (Iterator itr = inserts.iterator(); itr.hasNext();) {\n+                sm = ((Row) itr.next()).getPrimaryKey();\n+                if (sm != null && sm.getObjectId() != null)\n+                    insertMap.put(sm.getObjectId(), sm);\n+            }\n+        }\n+\n+        // first construct the graph for deletes; this may expand to include\n+        // inserts and updates as well if there are any inserts that rely on\n+        // deletes (delete-then-insert-same-pk cases)\n+        PrimaryRow row;\n+        Row row2;\n+        ForeignKey[] fks;\n+        OpenJPAStateManager fkVal;\n+        boolean ignoreUpdates = true;\n+        for (Iterator itr = deletes.iterator(); itr.hasNext();) {\n+            row = (PrimaryRow) itr.next();\n+            if (!row.isValid())\n+                continue;\n+\n+            row2 = getInsertRow(insertMap, rowMgr, row);\n+            if (row2 != null) {\n+                ignoreUpdates = false;\n+                graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row, null);\n+            }\n+\n+            // now check this row's fks against other deletes\n+            fks = row.getTable().getForeignKeys();\n+            for (int j = 0; j < fks.length; j++) {\n+                // when deleting ref fks they'll just set a where value, so\n+                // check both for fk updates (relation fks) and wheres (ref fks)\n+                fkVal = row.getForeignKeySet(fks[j]);\n+                if (fkVal == null)\n+                    fkVal = row.getForeignKeyWhere(fks[j]);\n+                if (fkVal == null)\n+                    continue;\n+\n+                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\n+                    Row.ACTION_DELETE, fkVal, false);\n+                if (row2 != null && row2.isValid() && row2 != row)\n+                    graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row,\n+                        fks[j]);\n+            }\n+        }\n+\n+        if (ignoreUpdates)\n+            graphs[0] = analyzeAgainstInserts(inserts, rowMgr, graphs[0]);\n+        else {\n+            // put inserts *and updates* in the delete graph; they all rely\n+            // on each other\n+            graphs[1] = analyzeAgainstInserts(updates, rowMgr, graphs[1]);\n+            graphs[1] = analyzeAgainstInserts(inserts, rowMgr, graphs[1]);\n+        }\n+    }\n+\n+    /**\n+     * Check to see if there is an insert for for the same table and primary\n+     * key values as the given delete row.\n+     */\n+    private Row getInsertRow(Map insertMap, RowManagerImpl rowMgr, Row row) {\n+        if (insertMap == null)\n+            return null;\n+\n+        OpenJPAStateManager sm = row.getPrimaryKey();\n+        if (sm == null)\n+            return null;\n+\n+        // look for a new object whose insert id is the same as this delete one\n+        Object oid = sm.getObjectId();\n+        OpenJPAStateManager nsm = (OpenJPAStateManager) insertMap.get(oid);\n+        if (nsm == null)\n+            return null;\n+\n+        // found new object; get its row\n+        row = rowMgr.getRow(row.getTable(), Row.ACTION_INSERT, nsm, false);\n+        return (row == null || row.isValid()) ? row : null;\n+    }\n+\n+    /**\n+     * Analyze the given rows against the inserts, placing dependencies\n+     * in the given graph.\n+     */\n+    private Graph analyzeAgainstInserts(Collection rows, RowManagerImpl rowMgr,\n+        Graph graph) {\n+        PrimaryRow row;\n+        Row row2;\n+        ForeignKey[] fks;\n+        Column[] cols;\n+        for (Iterator itr = rows.iterator(); itr.hasNext();) {\n+            row = (PrimaryRow) itr.next();\n+            if (!row.isValid())\n+                continue;\n+\n+            // check this row's fks against inserts; a logical fk to an auto-inc\n+            // column is treated just as actual database fk because the result\n+            // is the same: the pk row has to be inserted before the fk row\n+            fks = row.getTable().getForeignKeys();\n+            for (int j = 0; j < fks.length; j++) {\n+                if (row.getForeignKeySet(fks[j]) == null)\n+                    continue;\n+\n+                // see if this row is dependent on another.  if it's only\n+                // depenent on itself, see if the fk is logical or deferred, in\n+                // which case it must be an auto-inc because otherwise we\n+                // wouldn't have recorded it\n+                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\n+                    Row.ACTION_INSERT, row.getForeignKeySet(fks[j]), false);\n+                if (row2 != null && row2.isValid() && (row2 != row\n+                    || fks[j].isDeferred() || fks[j].isLogical()))\n+                    graph = addEdge(graph, row, (PrimaryRow) row2, fks[j]);\n+            }\n+\n+            // see if there are any relation id columns dependent on\n+            // auto-inc objects\n+            cols = row.getTable().getRelationIdColumns();\n+            for (int j = 0; j < cols.length; j++) {\n+                OpenJPAStateManager sm = row.getRelationIdSet(cols[j]);\n+                if (sm == null)\n+                    continue;\n+\n+                row2 = rowMgr.getRow(getBaseTable(sm), Row.ACTION_INSERT,\n+                    sm, false);\n+                if (row2 != null && row2.isValid())\n+                    graph = addEdge(graph, row, (PrimaryRow) row2, cols[j]);\n+            }\n+        }\n+        return graph;\n+    }\n+\n+    /**\n+     * Return the base table for the given instance.\n+     */\n+    private static Table getBaseTable(OpenJPAStateManager sm) {\n+        ClassMapping cls = (ClassMapping) sm.getMetaData();\n+        while (cls.getJoinablePCSuperclassMapping() != null)\n+            cls = cls.getJoinablePCSuperclassMapping();\n+        return cls.getTable();\n+    }\n+\n+    /**\n+     * Add an edge between the given rows in the given foreign key graph.\n+     */\n+    private Graph addEdge(Graph graph, PrimaryRow row1, PrimaryRow row2,\n+        Object fk) {\n+        // delay creation of the graph\n+        if (graph == null)\n+            graph = new Graph();\n+\n+        row1.setDependent(true);\n+        row2.setDependent(true);\n+        graph.addNode(row1);\n+        graph.addNode(row2);\n+\n+        // add an edge from row1 to row2, and set the fk causing the\n+        // dependency as the user object so we can retrieve it when resolving\n+        // circular constraints\n+        Edge edge = new Edge(row1, row2, true);\n+        edge.setUserObject(fk);\n+        graph.addEdge(edge);\n+\n+        return graph;\n+    }\n+\n+    /**\n+     * Flush the given graph of rows in the proper order.\n+     * @param graph The graph of statements to be walked\n+     * @param psMgr The prepared statement manager to use to issue the\n+     * statements\n+     * @param autoAssign Whether any of the rows in the graph have any\n+     * auto-assign constraints\n+     */\n+    protected void flushGraph(Graph graph, PreparedStatementManager psMgr,\n+        boolean autoAssign)\n+        throws SQLException {\n+        if (graph == null)\n+            return;\n+\n+        DepthFirstAnalysis dfa = newDepthFirstAnalysis(graph, autoAssign);\n+        Collection insertUpdates = new LinkedList();\n+        Collection deleteUpdates = new LinkedList();\n+        boolean recalculate;\n+\n+        // Handle circular constraints:\n+        // - if deleted row A has a ciricular fk to deleted row B, \n+        //   then use an update statement to null A's fk to B before flushing, \n+        //   and then flush\n+        // - if inserted row A has a circular fk to updated/inserted row B,\n+        //   then null the fk in the B row object, then flush,\n+        //   and after flushing, use an update to set the fk back to A\n+        // Depending on where circular dependencies are broken, the  \n+        // topological order of the graph nodes has to be re-calculated.\n+        recalculate = resolveCycles(graph, dfa.getEdges(Edge.TYPE_BACK),\n+                deleteUpdates, insertUpdates);\n+        recalculate |= resolveCycles(graph, dfa.getEdges(Edge.TYPE_FORWARD),\n+                deleteUpdates, insertUpdates);\n+\n+        if (recalculate) {\n+            dfa = recalculateDepthFirstAnalysis(graph, autoAssign);\n+        }\n+\n+        // flush delete updates to null fks, then all rows in order, then\n+        // the insert updates to set circular fk values\n+        Collection nodes = dfa.getSortedNodes();\n+        flush(deleteUpdates, nodes, psMgr);\n+        flush(insertUpdates, psMgr);\n+    }\n+\n+    protected void flush(Collection deleteUpdates, Collection nodes,\n+    \tPreparedStatementManager psMgr) {\n+        flush(deleteUpdates, psMgr);\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();)\n+            psMgr.flush((RowImpl) itr.next());\n+    }\n+\n+    /**\n+     * Break a circular dependency caused by delete operations.\n+     * If deleted row A has a ciricular fk to deleted row B, then use an update \n+     * statement to null A's fk to B before deleting B, then delete A.\n+     * @param edge Edge in the dependency graph corresponding to a foreign key\n+     * constraint. This dependency is broken by nullifying the foreign key.\n+     * @param deleteUpdates Collection of update statements that are executed\n+     * before the delete operations are flushed \n+     */\n+    private void addDeleteUpdate(Edge edge, Collection deleteUpdates)\n+        throws SQLException {\n+        PrimaryRow row;\n+        RowImpl update;\n+        ForeignKey fk;\n+\n+        // copy where conditions into new update that nulls the fk\n+        row = (PrimaryRow) edge.getTo();\n+        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\n+        row.copyInto(update, true);\n+        if (edge.getUserObject() instanceof ForeignKey) {\n+            fk = (ForeignKey) edge.getUserObject();\n+            update.setForeignKey(fk, row.getForeignKeyIO(fk), null);\n+        } else\n+            update.setNull((Column) edge.getUserObject());\n+\n+        deleteUpdates.add(update);\n+    }\n+\n+    /**\n+     * Break a circular dependency caused by insert operations.\n+     * If inserted row A has a circular fk to updated/inserted row B,\n+     * then null the fk in the B row object, then flush,\n+     * and after flushing, use an update to set the fk back to A.\n+     * @param row Row to be flushed\n+     * @param edge Edge in the dependency graph corresponding to a foreign key\n+     * constraint. This dependency is broken by nullifying the foreign key.\n+     * @param insertUpdates Collection of update statements that are executed\n+     * after the insert/update operations are flushed \n+     */\n+    private void addInsertUpdate(PrimaryRow row, Edge edge,\n+        Collection insertUpdates) throws SQLException {\n+        RowImpl update;\n+        ForeignKey fk;\n+        Column col;\n+\n+        // copy where conditions into new update that sets the fk\n+        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\n+        if (row.getAction() == Row.ACTION_INSERT) {\n+            if (row.getPrimaryKey() == null)\n+                throw new InternalException(_loc.get(\"ref-cycle\"));\n+            update.wherePrimaryKey(row.getPrimaryKey());\n+        } else {\n+            // Row.ACTION_UPDATE\n+            row.copyInto(update, true);\n+        }\n+        if (edge.getUserObject() instanceof ForeignKey) {\n+            fk = (ForeignKey) edge.getUserObject();\n+            update.setForeignKey(fk, row.getForeignKeyIO(fk),\n+                row.getForeignKeySet(fk));\n+            row.clearForeignKey(fk);\n+        } else {\n+            col = (Column) edge.getUserObject();\n+            update.setRelationId(col, row.getRelationIdSet(col),\n+                row.getRelationIdCallback(col));\n+            row.clearRelationId(col);\n+        }\n+\n+        insertUpdates.add(update);\n+    }\n+\n+    /**\n+     * Finds a nullable foreign key by walking the dependency cycle. \n+     * Circular dependencies can be broken at this point.\n+     * @param cycle Cycle in the dependency graph.\n+     * @return Edge corresponding to a nullable foreign key.\n+     */\n+    private Edge findBreakableLink(List cycle) {\n+        Edge breakableLink = null;\n+        for (Iterator iter = cycle.iterator(); iter.hasNext(); ) {\n+            Edge edge = (Edge) iter.next();\n+            Object userObject = edge.getUserObject();\n+            if (userObject instanceof ForeignKey) {\n+                 if (!((ForeignKey) userObject).hasNotNullColumns()) {\n+                     breakableLink = edge;\n+                     break;\n+                 }\n+            } else if (userObject instanceof Column) {\n+                if (!((Column) userObject).isNotNull()) {\n+                    breakableLink = edge;\n+                    break;\n+                }\n+            }\n+        }\n+        return breakableLink;\n+    }\n+\n+    /**\n+     * Re-calculates the DepthFirstSearch analysis of the graph \n+     * after some of the edges have been removed. Ensures\n+     * that the dependency graph is cycle free.\n+     * @param graph The graph of statements to be walked\n+     * @param autoAssign Whether any of the rows in the graph have any\n+     * auto-assign constraints\n+     */\n+    private DepthFirstAnalysis recalculateDepthFirstAnalysis(Graph graph,\n+        boolean autoAssign) {\n+        DepthFirstAnalysis dfa;\n+        // clear previous traversal data\n+        graph.clearTraversal();\n+        dfa = newDepthFirstAnalysis(graph, autoAssign);\n+        // make sure that the graph is non-cyclic now\n+        assert (dfa.hasNoCycles()): _loc.get(\"graph-not-cycle-free\");\n+        return dfa;\n+    }\n+\n+    /**\n+     * Resolve circular dependencies by identifying and breaking\n+     * a nullable foreign key.\n+     * @param graph Dependency graph.\n+     * @param edges Collection of edges. Each edge indicates a possible \n+     * circular dependency\n+     * @param deleteUpdates Collection of update operations (nullifying \n+     * foreign keys) to be filled. These updates will be executed before \n+     * the rows in the dependency graph are flushed\n+     * @param insertUpdates CCollection of update operations (nullifying \n+     * foreign keys) to be filled. These updates will be executed after \n+     * the rows in the dependency graph are flushed\n+     * @return Depending on where circular dependencies are broken, the  \n+     * topological order of the graph nodes has to be re-calculated.\n+     */\n+    private boolean resolveCycles(Graph graph, Collection edges,\n+        Collection deleteUpdates, Collection insertUpdates)\n+        throws SQLException {\n+        boolean recalculate = false;\n+        for (Iterator itr = edges.iterator(); itr.hasNext();) {\n+            Edge edge = (Edge) itr.next();\n+            List cycle = edge.getCycle();\n+\n+            if (cycle != null) {\n+                // find a nullable foreign key\n+                Edge breakableLink = findBreakableLink(cycle);\n+                if (breakableLink == null) {\n+                    throw new UserException(_loc.get(\"no-nullable-fk\"));\n+                }\n+\n+                // topologic node order must be re-calculated,  if the\n+                // breakable link is different from the edge where\n+                // the circular dependency was originally detected\n+                if (edge != breakableLink) {\n+                    recalculate = true;\n+                }\n+\n+                if (!breakableLink.isRemovedFromGraph()) {\n+\n+                    // use a primary row update to prevent setting pk and fk values\n+                    // until after flush, to get latest auto-increment values\n+                    PrimaryRow row = (PrimaryRow) breakableLink.getFrom();\n+                    if (row.getAction() == Row.ACTION_DELETE) {\n+                        addDeleteUpdate(breakableLink, deleteUpdates);\n+                    } else {\n+                        addInsertUpdate(row, breakableLink, insertUpdates);\n+                    }\n+                    graph.removeEdge(breakableLink);\n+                }\n+            }\n+        }\n+        return recalculate;\n+    }\n+\n+    /**\n+     * Create a new {@link DepthFirstAnalysis} suitable for the given graph\n+     * and auto-assign settings.\n+     */\n+    protected DepthFirstAnalysis newDepthFirstAnalysis(Graph graph,\n+        boolean autoAssign) {\n+        return new DepthFirstAnalysis(graph);\n+    }\n+\n+    /**\n+     * Flush the given collection of secondary rows.\n+     */\n+    protected void flush(Collection rows, PreparedStatementManager psMgr) {\n+        if (rows.size() == 0)\n+            return;\n+\n+        RowImpl row;\n+        for (Iterator itr = rows.iterator(); itr.hasNext(); ) {\n+            row = (RowImpl) itr.next();\n+            if (!row.isFlushed() && row.isValid() && !row.isDependent()) {\n+                psMgr.flush(row);\n+                row.setFlushed(true);\n+            }\n+        }\n+    }\n }\n\\ No newline at end of file"},{"sha":"58db3b8c30eebbd6be2f2565cf9763488002a4ee","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/FinderCacheImpl.java","status":"modified","additions":420,"deletions":420,"changes":840,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/FinderCacheImpl.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/FinderCacheImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/FinderCacheImpl.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,420 +1,420 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-import java.util.TreeMap;\r\n-import java.util.concurrent.locks.ReentrantLock;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n-import org.apache.openjpa.jdbc.sql.Result;\r\n-import org.apache.openjpa.jdbc.sql.SelectExecutor;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.FinderCache;\r\n-import org.apache.openjpa.kernel.FinderQuery;\r\n-import org.apache.openjpa.kernel.QueryHints;\r\n-import org.apache.openjpa.kernel.QueryStatistics;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-\r\n-/**\r\n- * Implementation of FinderCache for JDBC.\r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- * @since 2.0.0\r\n- *\r\n- */\r\n-public class FinderCacheImpl \r\n-    implements FinderCache<ClassMapping, SelectExecutor, Result> {\r\n-    private static final String PATTERN_SEPARATOR = \"\\\\;\";\r\n-    private static final String EXLUDED_BY_USER = \"Excluded by user\";\r\n-     \r\n-    private final Map<ClassMapping, \r\n-        FinderQuery<ClassMapping, SelectExecutor, Result>> _delegate;\r\n-    // Key: class name Value: Reason why excluded\r\n-    private final Map<String, String> _uncachables;\r\n-    private List<String> _exclusionPatterns;\r\n-    private QueryStatistics<ClassMapping> _stats;\r\n-    private ReentrantLock _lock = new ReentrantLock();\r\n-    private Log _log;\r\n-    private Localizer _loc = Localizer.forPackage(FinderCacheImpl.class);\r\n-\r\n-    \r\n-    public FinderCacheImpl() {\r\n-        _delegate = new HashMap<ClassMapping, \r\n-            FinderQuery<ClassMapping, SelectExecutor, Result>>();\r\n-        _uncachables = new HashMap<String, String>();\r\n-        _stats = new QueryStatistics.Default<ClassMapping>();\r\n-    }\r\n-    \r\n-    /**\r\n-     * Get a map-oriented view of the cache.\r\n-     * \r\n-     * @return a map of the query string with class names as key. \r\n-     */\r\n-    public Map<String, String> getMapView() {\r\n-        lock();\r\n-        try {\r\n-            Map<String, String> view = new TreeMap<String, String>();\r\n-            for (ClassMapping mapping : _delegate.keySet())\r\n-                view.put(mapping.getDescribedType().getName(), \r\n-                    _delegate.get(mapping).getQueryString());\r\n-            return view;\r\n-        } finally {\r\n-            unlock();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Gets basic statistics of execution and hit count of finder queries. \r\n-     */\r\n-    public QueryStatistics<ClassMapping> getStatistics() {\r\n-        return _stats;\r\n-    }\r\n-\r\n-    /**\r\n-     * Gets the finder query for the given mapping. The get operation can be\r\n-     * controlled by FetchConfiguration hints. \r\n-     * {@link QueryHints#HINT_IGNORE_FINDER HINT_IGNORE_FINDER} will ignore\r\n-     * any cached finder that may exist in this cache and will return null.\r\n-     * {@link QueryHints#HINT_INVALIDATE_FINDER HINT_INVALIDATE_FINDER} will \r\n-     * invalidate any cached finder that may exist in this cache and will return \r\n-     * null.\r\n-     * \r\n-     */\r\n-    public FinderQuery<ClassMapping,SelectExecutor,Result> \r\n-        get(ClassMapping mapping, FetchConfiguration fetch) {\r\n-        if (fetch.getReadLockLevel() != 0)\r\n-            return null;\r\n-        boolean ignore = isHinted(fetch, QueryHints.HINT_IGNORE_FINDER);\r\n-        boolean invalidate = isHinted(fetch, QueryHints.HINT_INVALIDATE_FINDER);\r\n-        if (invalidate)\r\n-            invalidate(mapping);\r\n-        if (ignore)\r\n-            return null;\r\n-        FinderQuery<ClassMapping, SelectExecutor, Result> result = \r\n-            _delegate.get(mapping);\r\n-        _stats.recordExecution(mapping, result != null);\r\n-        return result;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Cache a Finder Query for the given mapping and select. The put operation \r\n-     * can be controlled by FetchConfiguration hints. \r\n-     * If no entry exists for the given mapping then an attempt is made to \r\n-     * create a new FinderQuery. The attempt, however, may not be successful\r\n-     * because all Selects can not be cached.\r\n-     * @see FinderQueryImpl#newFinder(ClassMapping, Select).\r\n-     *  \r\n-     * If a entry for the given mapping exists then the value of\r\n-     * {@link QueryHints#HINT_RECACHE_FINDER HINT_RECACHE_FINDER} hint \r\n-     * determines whether the existing entry is returned or a new FinderQuery \r\n-     * with the given argument overwrites the existing one.\r\n-     * \r\n-     * @param mapping the class for which the finder is to be cached\r\n-     * @param select the finder query\r\n-     * @param fetch may contain hints to control cache operation\r\n-     */\r\n-    public FinderQuery<ClassMapping, SelectExecutor, Result> cache\r\n-       (ClassMapping mapping, SelectExecutor select, FetchConfiguration fetch) {\r\n-        lock();\r\n-        try {\r\n-            if (fetch.getReadLockLevel() != 0)\r\n-                return null;\r\n-            boolean recache = isHinted(fetch, QueryHints.HINT_RECACHE_FINDER);\r\n-            if (isExcluded(mapping)) {\r\n-                return recache ? put(mapping, select) : null;\r\n-            }\r\n-            if (_delegate.containsKey(mapping)) {\r\n-                return recache ? put(mapping, select) : _delegate.get(mapping);\r\n-            }\r\n-            return put(mapping, select);\r\n-        } finally {\r\n-            unlock();\r\n-        }\r\n-    }\r\n-    \r\n-    /**\r\n-     * Creates and puts a FinderQuery in the internal map indexed by the\r\n-     * given ClassMapping.\r\n-     * If a new FinderQuery can not be created for the given Select (because\r\n-     * some Select are not cached), then the mapping is marked invalid.\r\n-     *  \r\n-    */\r\n-    private FinderQuery<ClassMapping, SelectExecutor, Result> put\r\n-       (ClassMapping mapping, SelectExecutor select) {\r\n-        FinderQuery<ClassMapping, SelectExecutor, Result> finder = \r\n-            FinderQueryImpl.newFinder(mapping, select);\r\n-        if (finder != null) {\r\n-            _delegate.put(mapping, finder);\r\n-            if (_log != null && _log.isTraceEnabled())\r\n-                _log.trace(_loc.get(\"finder-cached\", mapping, \r\n-                    finder.getQueryString())); \r\n-        } else {\r\n-            if (_log != null && _log.isWarnEnabled())\r\n-                _log.warn(_loc.get(\"finder-not-cachable\", mapping));\r\n-            invalidate(mapping);\r\n-        }\r\n-        return finder;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Affirms if the given mapping is excluded from being cached.\r\n-     */\r\n-    public boolean isExcluded(ClassMapping mapping) {\r\n-        return mapping != null && \r\n-            isExcluded(mapping.getDescribedType().getName());\r\n-    }\r\n-\r\n-    /**\r\n-     * Searches the exclusion patterns to find out if the given string matches\r\n-     * any element.\r\n-     */\r\n-    private boolean isExcluded(String target) {\r\n-        if (_exclusionPatterns != null && _exclusionPatterns.contains(target))\r\n-            return true;\r\n-        return getMatchedExclusionPattern(target) != null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Adds a pattern for exclusion. Any cached finder whose class name\r\n-     * matches the given pattern will be marked invalidated as a side-effect.\r\n-     */\r\n-    public void addExclusionPattern(String pattern) {\r\n-        lock();\r\n-        try {\r\n-            if (_exclusionPatterns == null)\r\n-                _exclusionPatterns = new ArrayList<String>();\r\n-            _exclusionPatterns.add(pattern);\r\n-            Collection<ClassMapping> invalidMappings = getMatchedKeys(pattern, \r\n-                    _delegate.keySet());\r\n-            if (!invalidMappings.isEmpty() \r\n-                && _log != null && _log.isInfoEnabled())\r\n-                _log.info(_loc.get(\"finder-add-pattern\", pattern, \r\n-                    invalidMappings.size(), invalidMappings));\r\n-            for (ClassMapping invalidMapping : invalidMappings)\r\n-                markUncachable(invalidMapping, pattern);\r\n-        } finally {\r\n-            unlock();\r\n-        }\r\n-    }\r\n-    /**\r\n-     * Removes a pattern for exclusion. Any query identifier marked as not \r\n-     * cachable due to the given pattern will now be removed from the list of\r\n-     * uncachables as a side-effect.\r\n-     */\r\n-    public void removeExclusionPattern(String pattern) {\r\n-        lock();\r\n-        try {\r\n-            if (_exclusionPatterns == null)\r\n-                return;\r\n-            _exclusionPatterns.remove(pattern);\r\n-            Collection<String> reborns = getMatchedKeys(pattern, \r\n-                _uncachables.keySet());\r\n-            if (!reborns.isEmpty() && _log != null && _log.isInfoEnabled())\r\n-                _log.info(_loc.get(\"finder-remove-pattern\", pattern, \r\n-                    reborns.size(), reborns));\r\n-            for (String rebornKey : reborns)\r\n-                _uncachables.remove(rebornKey);\r\n-        } finally {\r\n-            unlock();\r\n-        }\r\n-    }\r\n-    \r\n-    /**\r\n-     * Gets the pattern that matches the given identifier.\r\n-     */\r\n-    private String getMatchedExclusionPattern(String id) {\r\n-        if (_exclusionPatterns == null || _exclusionPatterns.isEmpty())\r\n-            return null;\r\n-        for (String pattern : _exclusionPatterns)\r\n-            if (matches(pattern, id))\r\n-                return pattern;\r\n-        return null;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Gets the elements of the given set that match the given pattern. \r\n-     */\r\n-    private Collection<ClassMapping> getMatchedKeys(String pattern, \r\n-            Set<ClassMapping> set) {\r\n-        List<ClassMapping> result = new ArrayList<ClassMapping>();\r\n-        for (ClassMapping entry : set) {\r\n-            if (matches(pattern, entry)) {\r\n-                result.add(entry);\r\n-            }\r\n-        }\r\n-        return result;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Gets the elements of the given list which match the given pattern. \r\n-     */\r\n-    private Collection<String> getMatchedKeys(String pattern, \r\n-            Collection<String> coll) {\r\n-        List<String> result = new ArrayList<String>();\r\n-        for (String key : coll) {\r\n-            if (matches(pattern, key)) {\r\n-                result.add(key);\r\n-            }\r\n-        }\r\n-        return result;\r\n-    }\r\n-\r\n-    boolean matches(String pattern, ClassMapping mapping) {\r\n-        return matches(pattern, mapping.getDescribedType().getName());\r\n-    }\r\n-    \r\n-    boolean matches(String pattern, String target) {\r\n-        return target != null && (target.equals(pattern) \r\n-          || target.matches(pattern));\r\n-    }\r\n-    \r\n-    public boolean invalidate(ClassMapping mapping) {\r\n-        lock();\r\n-        try {\r\n-            if (_log.isTraceEnabled())\r\n-                _log.trace(_loc.get(\"finder-invalidate\", mapping));\r\n-            return _delegate.remove(mapping) != null;\r\n-        } finally {\r\n-            unlock();\r\n-        }\r\n-    }\r\n-\r\n-    public FinderQuery<ClassMapping, SelectExecutor, Result> markUncachable(\r\n-        ClassMapping mapping) {\r\n-        return markUncachable(mapping.getDescribedType().getName());\r\n-    }\r\n-\r\n-    public FinderQuery<ClassMapping, SelectExecutor, Result> markUncachable(\r\n-        String id) {\r\n-        return markUncachable(id, EXLUDED_BY_USER);\r\n-    }\r\n-    \r\n-    private FinderQuery<ClassMapping, SelectExecutor, Result> markUncachable(\r\n-        String cls, String reason) {\r\n-        lock();\r\n-        try {\r\n-            boolean excludedByUser = _uncachables.get(cls) == EXLUDED_BY_USER;\r\n-            if (!excludedByUser)\r\n-                _uncachables.put(cls, reason);\r\n-            if (_log != null && _log.isInfoEnabled()) {\r\n-                if (excludedByUser) \r\n-                    _log.info(_loc.get(\"finder-uncache-strong\", cls));\r\n-                else \r\n-                    _log.info(_loc.get(\"finder-uncache-weak\", cls, \r\n-                        reason));\r\n-            }\r\n-            return _delegate.remove(searchMappingByName(cls));\r\n-        } finally {\r\n-            unlock();\r\n-        }\r\n-    }\r\n-    \r\n-    private FinderQuery<ClassMapping, SelectExecutor, Result> markUncachable(\r\n-        ClassMapping mapping, String reason) {\r\n-        lock();\r\n-        try {\r\n-            String cls = mapping.getDescribedType().getName();\r\n-            boolean excludedByUser = _uncachables.get(cls) == EXLUDED_BY_USER;\r\n-            if (!excludedByUser)\r\n-                _uncachables.put(cls, reason);\r\n-            if (_log != null && _log.isInfoEnabled()) {\r\n-                if (excludedByUser) \r\n-                    _log.info(_loc.get(\"finder-uncache-strong\", cls));\r\n-                else \r\n-                    _log.info(_loc.get(\"finder-uncache-weak\", cls, reason));\r\n-            }\r\n-            return _delegate.remove(mapping);\r\n-        } finally {\r\n-            unlock();\r\n-        }\r\n-    }\r\n-    \r\n-    ClassMapping searchMappingByName(String cls) {\r\n-        for (ClassMapping mapping : _delegate.keySet())\r\n-            if (matches(cls, mapping))\r\n-                return mapping;\r\n-        return null;\r\n-    }\r\n-\r\n-    \r\n-    public void setExcludes(String excludes) {\r\n-        lock();\r\n-        try {\r\n-            if (StringUtils.isEmpty(excludes))\r\n-                return;\r\n-            if (_exclusionPatterns == null)\r\n-                _exclusionPatterns = new ArrayList<String>();\r\n-            String[] patterns = excludes.split(PATTERN_SEPARATOR);\r\n-            for (String pattern : patterns)\r\n-                addExclusionPattern(pattern);\r\n-        } finally {\r\n-            unlock();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"unchecked\")\r\n-    public List<String> getExcludes() {\r\n-        return (List<String>)_exclusionPatterns == null \r\n-            ? Collections.EMPTY_LIST \r\n-            : Collections.unmodifiableList(_exclusionPatterns);\r\n-    }\r\n-    \r\n-    boolean isHinted(FetchConfiguration fetch, String hint) {\r\n-        if (fetch == null)\r\n-            return false;\r\n-        Object result = fetch.getHint(hint);\r\n-        return result != null && \"true\".equalsIgnoreCase(result.toString());\r\n-    }\r\n-        \r\n-    void lock() {\r\n-        if (_lock != null)\r\n-            _lock.lock();\r\n-    }\r\n-\r\n-    void unlock() {\r\n-        if (_lock != null && _lock.isLocked())\r\n-            _lock.unlock();\r\n-    }\r\n-     \r\n-    // ----------------------------------------------------\r\n-    //  Configuration contract\r\n-    // ----------------------------------------------------\r\n-    public void startConfiguration() {\r\n-    }\r\n-    \r\n-    public void setConfiguration(Configuration conf) {\r\n-        _log = conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SelectExecutor;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.FinderCache;\n+import org.apache.openjpa.kernel.FinderQuery;\n+import org.apache.openjpa.kernel.QueryHints;\n+import org.apache.openjpa.kernel.QueryStatistics;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+/**\n+ * Implementation of FinderCache for JDBC.\n+ * \n+ * @author Pinaki Poddar\n+ * \n+ * @since 2.0.0\n+ *\n+ */\n+public class FinderCacheImpl \n+    implements FinderCache<ClassMapping, SelectExecutor, Result> {\n+    private static final String PATTERN_SEPARATOR = \"\\\\;\";\n+    private static final String EXLUDED_BY_USER = \"Excluded by user\";\n+     \n+    private final Map<ClassMapping, \n+        FinderQuery<ClassMapping, SelectExecutor, Result>> _delegate;\n+    // Key: class name Value: Reason why excluded\n+    private final Map<String, String> _uncachables;\n+    private List<String> _exclusionPatterns;\n+    private QueryStatistics<ClassMapping> _stats;\n+    private ReentrantLock _lock = new ReentrantLock();\n+    private Log _log;\n+    private Localizer _loc = Localizer.forPackage(FinderCacheImpl.class);\n+\n+    \n+    public FinderCacheImpl() {\n+        _delegate = new HashMap<ClassMapping, \n+            FinderQuery<ClassMapping, SelectExecutor, Result>>();\n+        _uncachables = new HashMap<String, String>();\n+        _stats = new QueryStatistics.Default<ClassMapping>();\n+    }\n+    \n+    /**\n+     * Get a map-oriented view of the cache.\n+     * \n+     * @return a map of the query string with class names as key. \n+     */\n+    public Map<String, String> getMapView() {\n+        lock();\n+        try {\n+            Map<String, String> view = new TreeMap<String, String>();\n+            for (ClassMapping mapping : _delegate.keySet())\n+                view.put(mapping.getDescribedType().getName(), \n+                    _delegate.get(mapping).getQueryString());\n+            return view;\n+        } finally {\n+            unlock();\n+        }\n+    }\n+\n+    /**\n+     * Gets basic statistics of execution and hit count of finder queries. \n+     */\n+    public QueryStatistics<ClassMapping> getStatistics() {\n+        return _stats;\n+    }\n+\n+    /**\n+     * Gets the finder query for the given mapping. The get operation can be\n+     * controlled by FetchConfiguration hints. \n+     * {@link QueryHints#HINT_IGNORE_FINDER HINT_IGNORE_FINDER} will ignore\n+     * any cached finder that may exist in this cache and will return null.\n+     * {@link QueryHints#HINT_INVALIDATE_FINDER HINT_INVALIDATE_FINDER} will \n+     * invalidate any cached finder that may exist in this cache and will return \n+     * null.\n+     * \n+     */\n+    public FinderQuery<ClassMapping,SelectExecutor,Result> \n+        get(ClassMapping mapping, FetchConfiguration fetch) {\n+        if (fetch.getReadLockLevel() != 0)\n+            return null;\n+        boolean ignore = isHinted(fetch, QueryHints.HINT_IGNORE_FINDER);\n+        boolean invalidate = isHinted(fetch, QueryHints.HINT_INVALIDATE_FINDER);\n+        if (invalidate)\n+            invalidate(mapping);\n+        if (ignore)\n+            return null;\n+        FinderQuery<ClassMapping, SelectExecutor, Result> result = \n+            _delegate.get(mapping);\n+        _stats.recordExecution(mapping, result != null);\n+        return result;\n+    }\n+    \n+    /**\n+     * Cache a Finder Query for the given mapping and select. The put operation \n+     * can be controlled by FetchConfiguration hints. \n+     * If no entry exists for the given mapping then an attempt is made to \n+     * create a new FinderQuery. The attempt, however, may not be successful\n+     * because all Selects can not be cached.\n+     * @see FinderQueryImpl#newFinder(ClassMapping, Select).\n+     *  \n+     * If a entry for the given mapping exists then the value of\n+     * {@link QueryHints#HINT_RECACHE_FINDER HINT_RECACHE_FINDER} hint \n+     * determines whether the existing entry is returned or a new FinderQuery \n+     * with the given argument overwrites the existing one.\n+     * \n+     * @param mapping the class for which the finder is to be cached\n+     * @param select the finder query\n+     * @param fetch may contain hints to control cache operation\n+     */\n+    public FinderQuery<ClassMapping, SelectExecutor, Result> cache\n+       (ClassMapping mapping, SelectExecutor select, FetchConfiguration fetch) {\n+        lock();\n+        try {\n+            if (fetch.getReadLockLevel() != 0)\n+                return null;\n+            boolean recache = isHinted(fetch, QueryHints.HINT_RECACHE_FINDER);\n+            if (isExcluded(mapping)) {\n+                return recache ? put(mapping, select) : null;\n+            }\n+            if (_delegate.containsKey(mapping)) {\n+                return recache ? put(mapping, select) : _delegate.get(mapping);\n+            }\n+            return put(mapping, select);\n+        } finally {\n+            unlock();\n+        }\n+    }\n+    \n+    /**\n+     * Creates and puts a FinderQuery in the internal map indexed by the\n+     * given ClassMapping.\n+     * If a new FinderQuery can not be created for the given Select (because\n+     * some Select are not cached), then the mapping is marked invalid.\n+     *  \n+    */\n+    private FinderQuery<ClassMapping, SelectExecutor, Result> put\n+       (ClassMapping mapping, SelectExecutor select) {\n+        FinderQuery<ClassMapping, SelectExecutor, Result> finder = \n+            FinderQueryImpl.newFinder(mapping, select);\n+        if (finder != null) {\n+            _delegate.put(mapping, finder);\n+            if (_log != null && _log.isTraceEnabled())\n+                _log.trace(_loc.get(\"finder-cached\", mapping, \n+                    finder.getQueryString())); \n+        } else {\n+            if (_log != null && _log.isWarnEnabled())\n+                _log.warn(_loc.get(\"finder-not-cachable\", mapping));\n+            invalidate(mapping);\n+        }\n+        return finder;\n+    }\n+    \n+    /**\n+     * Affirms if the given mapping is excluded from being cached.\n+     */\n+    public boolean isExcluded(ClassMapping mapping) {\n+        return mapping != null && \n+            isExcluded(mapping.getDescribedType().getName());\n+    }\n+\n+    /**\n+     * Searches the exclusion patterns to find out if the given string matches\n+     * any element.\n+     */\n+    private boolean isExcluded(String target) {\n+        if (_exclusionPatterns != null && _exclusionPatterns.contains(target))\n+            return true;\n+        return getMatchedExclusionPattern(target) != null;\n+    }\n+\n+    /**\n+     * Adds a pattern for exclusion. Any cached finder whose class name\n+     * matches the given pattern will be marked invalidated as a side-effect.\n+     */\n+    public void addExclusionPattern(String pattern) {\n+        lock();\n+        try {\n+            if (_exclusionPatterns == null)\n+                _exclusionPatterns = new ArrayList<String>();\n+            _exclusionPatterns.add(pattern);\n+            Collection<ClassMapping> invalidMappings = getMatchedKeys(pattern, \n+                    _delegate.keySet());\n+            if (!invalidMappings.isEmpty() \n+                && _log != null && _log.isInfoEnabled())\n+                _log.info(_loc.get(\"finder-add-pattern\", pattern, \n+                    invalidMappings.size(), invalidMappings));\n+            for (ClassMapping invalidMapping : invalidMappings)\n+                markUncachable(invalidMapping, pattern);\n+        } finally {\n+            unlock();\n+        }\n+    }\n+    /**\n+     * Removes a pattern for exclusion. Any query identifier marked as not \n+     * cachable due to the given pattern will now be removed from the list of\n+     * uncachables as a side-effect.\n+     */\n+    public void removeExclusionPattern(String pattern) {\n+        lock();\n+        try {\n+            if (_exclusionPatterns == null)\n+                return;\n+            _exclusionPatterns.remove(pattern);\n+            Collection<String> reborns = getMatchedKeys(pattern, \n+                _uncachables.keySet());\n+            if (!reborns.isEmpty() && _log != null && _log.isInfoEnabled())\n+                _log.info(_loc.get(\"finder-remove-pattern\", pattern, \n+                    reborns.size(), reborns));\n+            for (String rebornKey : reborns)\n+                _uncachables.remove(rebornKey);\n+        } finally {\n+            unlock();\n+        }\n+    }\n+    \n+    /**\n+     * Gets the pattern that matches the given identifier.\n+     */\n+    private String getMatchedExclusionPattern(String id) {\n+        if (_exclusionPatterns == null || _exclusionPatterns.isEmpty())\n+            return null;\n+        for (String pattern : _exclusionPatterns)\n+            if (matches(pattern, id))\n+                return pattern;\n+        return null;\n+    }\n+    \n+    /**\n+     * Gets the elements of the given set that match the given pattern. \n+     */\n+    private Collection<ClassMapping> getMatchedKeys(String pattern, \n+            Set<ClassMapping> set) {\n+        List<ClassMapping> result = new ArrayList<ClassMapping>();\n+        for (ClassMapping entry : set) {\n+            if (matches(pattern, entry)) {\n+                result.add(entry);\n+            }\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Gets the elements of the given list which match the given pattern. \n+     */\n+    private Collection<String> getMatchedKeys(String pattern, \n+            Collection<String> coll) {\n+        List<String> result = new ArrayList<String>();\n+        for (String key : coll) {\n+            if (matches(pattern, key)) {\n+                result.add(key);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    boolean matches(String pattern, ClassMapping mapping) {\n+        return matches(pattern, mapping.getDescribedType().getName());\n+    }\n+    \n+    boolean matches(String pattern, String target) {\n+        return target != null && (target.equals(pattern) \n+          || target.matches(pattern));\n+    }\n+    \n+    public boolean invalidate(ClassMapping mapping) {\n+        lock();\n+        try {\n+            if (_log.isTraceEnabled())\n+                _log.trace(_loc.get(\"finder-invalidate\", mapping));\n+            return _delegate.remove(mapping) != null;\n+        } finally {\n+            unlock();\n+        }\n+    }\n+\n+    public FinderQuery<ClassMapping, SelectExecutor, Result> markUncachable(\n+        ClassMapping mapping) {\n+        return markUncachable(mapping.getDescribedType().getName());\n+    }\n+\n+    public FinderQuery<ClassMapping, SelectExecutor, Result> markUncachable(\n+        String id) {\n+        return markUncachable(id, EXLUDED_BY_USER);\n+    }\n+    \n+    private FinderQuery<ClassMapping, SelectExecutor, Result> markUncachable(\n+        String cls, String reason) {\n+        lock();\n+        try {\n+            boolean excludedByUser = _uncachables.get(cls) == EXLUDED_BY_USER;\n+            if (!excludedByUser)\n+                _uncachables.put(cls, reason);\n+            if (_log != null && _log.isInfoEnabled()) {\n+                if (excludedByUser) \n+                    _log.info(_loc.get(\"finder-uncache-strong\", cls));\n+                else \n+                    _log.info(_loc.get(\"finder-uncache-weak\", cls, \n+                        reason));\n+            }\n+            return _delegate.remove(searchMappingByName(cls));\n+        } finally {\n+            unlock();\n+        }\n+    }\n+    \n+    private FinderQuery<ClassMapping, SelectExecutor, Result> markUncachable(\n+        ClassMapping mapping, String reason) {\n+        lock();\n+        try {\n+            String cls = mapping.getDescribedType().getName();\n+            boolean excludedByUser = _uncachables.get(cls) == EXLUDED_BY_USER;\n+            if (!excludedByUser)\n+                _uncachables.put(cls, reason);\n+            if (_log != null && _log.isInfoEnabled()) {\n+                if (excludedByUser) \n+                    _log.info(_loc.get(\"finder-uncache-strong\", cls));\n+                else \n+                    _log.info(_loc.get(\"finder-uncache-weak\", cls, reason));\n+            }\n+            return _delegate.remove(mapping);\n+        } finally {\n+            unlock();\n+        }\n+    }\n+    \n+    ClassMapping searchMappingByName(String cls) {\n+        for (ClassMapping mapping : _delegate.keySet())\n+            if (matches(cls, mapping))\n+                return mapping;\n+        return null;\n+    }\n+\n+    \n+    public void setExcludes(String excludes) {\n+        lock();\n+        try {\n+            if (StringUtils.isEmpty(excludes))\n+                return;\n+            if (_exclusionPatterns == null)\n+                _exclusionPatterns = new ArrayList<String>();\n+            String[] patterns = excludes.split(PATTERN_SEPARATOR);\n+            for (String pattern : patterns)\n+                addExclusionPattern(pattern);\n+        } finally {\n+            unlock();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public List<String> getExcludes() {\n+        return (List<String>)_exclusionPatterns == null \n+            ? Collections.EMPTY_LIST \n+            : Collections.unmodifiableList(_exclusionPatterns);\n+    }\n+    \n+    boolean isHinted(FetchConfiguration fetch, String hint) {\n+        if (fetch == null)\n+            return false;\n+        Object result = fetch.getHint(hint);\n+        return result != null && \"true\".equalsIgnoreCase(result.toString());\n+    }\n+        \n+    void lock() {\n+        if (_lock != null)\n+            _lock.lock();\n+    }\n+\n+    void unlock() {\n+        if (_lock != null && _lock.isLocked())\n+            _lock.unlock();\n+    }\n+     \n+    // ----------------------------------------------------\n+    //  Configuration contract\n+    // ----------------------------------------------------\n+    public void startConfiguration() {\n+    }\n+    \n+    public void setConfiguration(Configuration conf) {\n+        _log = conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\n+    }\n+\n+    public void endConfiguration() {\n+    }\n+\n+}"},{"sha":"50b4f23aeb81cdb106bd7829c8ecd5da88b9c7c1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/FinderQueryImpl.java","status":"modified","additions":181,"deletions":181,"changes":362,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/FinderQueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/FinderQueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/FinderQueryImpl.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,181 +1,181 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import java.sql.Connection;\r\n-import java.sql.PreparedStatement;\r\n-import java.sql.ResultSet;\r\n-import java.sql.SQLException;\r\n-\r\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n-import org.apache.openjpa.jdbc.meta.Joinable;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\r\n-import org.apache.openjpa.jdbc.sql.LogicalUnion;\r\n-import org.apache.openjpa.jdbc.sql.Result;\r\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\r\n-import org.apache.openjpa.jdbc.sql.SelectExecutor;\r\n-import org.apache.openjpa.jdbc.sql.SelectImpl;\r\n-import org.apache.openjpa.jdbc.sql.Union;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.FinderQuery;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.StoreManager;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.util.ApplicationIds;\r\n-import org.apache.openjpa.util.Id;\r\n-\r\n-import serp.util.Numbers;\r\n-\r\n-/**\r\n- * Implements Finder Query identified by ClassMappping for SelectExecutor that \r\n- * can be executed to generate Result. \r\n- *  \r\n- * @author Pinaki Poddar\r\n- *\r\n- * @since 2.0.0\r\n- */\r\n-public class FinderQueryImpl \r\n-    implements FinderQuery<ClassMapping, SelectExecutor, Result> {\r\n-    private final ClassMapping _mapping;\r\n-    private final SelectImpl _select;\r\n-    private final Column[] _pkCols;\r\n-    private final Joinable[]  _joins;\r\n-    private final int[] _pkIndices;\r\n-    private final SQLBuffer _buffer;\r\n-    private final String _sql;\r\n-    \r\n-    /**\r\n-     * Attempts to construct a FinderQuery from the given Select for the given\r\n-     * mapping. The given Select may not be amenable for caching and then a null\r\n-     * value is returned. \r\n-     */\r\n-    static FinderQueryImpl newFinder(ClassMapping mapping,\r\n-        SelectExecutor select) {\r\n-        SelectImpl impl = extractImplementation(select);\r\n-        if (impl == null)\r\n-            return null;\r\n-        SQLBuffer buffer = impl.getSQL();\r\n-        Column[] pkCols = mapping.getPrimaryKeyColumns();\r\n-        boolean canCache = pkCols.length == buffer.getParameters().size();\r\n-        return (canCache)\r\n-            ? new FinderQueryImpl(mapping, impl, buffer) : null;\r\n-    }\r\n-\r\n-    private FinderQueryImpl(ClassMapping mapping, SelectImpl select,\r\n-        SQLBuffer buffer) {\r\n-        super();\r\n-        _mapping = mapping;\r\n-        _select = select;\r\n-        _buffer = buffer;\r\n-        _sql = _buffer.getSQL();\r\n-        _pkCols = _mapping.getPrimaryKeyColumns();\r\n-        _joins = new Joinable[_pkCols.length];\r\n-        for (int i = 0; i < _pkCols.length; i++)\r\n-            _joins[i] = _mapping.assertJoinable(_pkCols[i]);\r\n-        _pkIndices = new int[_pkCols.length];\r\n-        for (int i = 0; i < _pkCols.length; i++) {\r\n-            FieldMetaData pk = _mapping.getField(_joins[i].getFieldIndex());\r\n-            _pkIndices[i] = pk == null ? 0 : pk.getPrimaryKeyIndex();\r\n-        }\r\n-        \r\n-    }\r\n-    \r\n-    public ClassMapping getIdentifier() {\r\n-        return _mapping;\r\n-    }\r\n-    \r\n-    public SelectExecutor getDelegate() {\r\n-        return _select;\r\n-    }\r\n-    \r\n-    public String getQueryString() {\r\n-        return _sql;\r\n-    }\r\n-    \r\n-    public Column[] getPKColumns() {\r\n-        return _pkCols;\r\n-    }\r\n-    \r\n-    private Object[] getPKValues(OpenJPAStateManager sm, JDBCStore store) {\r\n-        Object[] pks = null;\r\n-        Object oid = sm.getObjectId();\r\n-        if (_mapping.getIdentityType() == ClassMapping.ID_APPLICATION)\r\n-            pks = ApplicationIds.toPKValues(oid, _mapping);\r\n-    \r\n-        Object[] val = new Object[_pkCols.length];\r\n-        int count = 0;\r\n-        for (int i = 0; i < _pkCols.length; i++, count++) {\r\n-            if (pks == null)\r\n-                val[0] = (oid == null) \r\n-                    ? null : Numbers.valueOf(((Id) oid).getId());\r\n-            else {\r\n-                val[i] = _joins[i].getJoinValue(pks[_pkIndices[i]], _pkCols[i], \r\n-                    store);\r\n-            }\r\n-        }\r\n-        return val;\r\n-    }\r\n-    \r\n-    public Result execute(OpenJPAStateManager sm, StoreManager store, \r\n-        FetchConfiguration fetch) {\r\n-        boolean forUpdate = false;\r\n-        JDBCStore jstore = (JDBCStore)store;\r\n-        Connection conn = jstore.getConnection();\r\n-        DBDictionary dict = jstore.getDBDictionary();\r\n-        PreparedStatement stmnt = null;\r\n-        ResultSet rs = null;\r\n-        try {\r\n-            stmnt = _select.prepareStatement(conn, _sql);\r\n-            Object[] params = getPKValues(sm, jstore);\r\n-            if (stmnt != null) {\r\n-                for (int i = 0; i <params.length; i++) {\r\n-                    dict.setUnknown(stmnt, i+1, params[i], _pkCols[i]);\r\n-                }\r\n-            }\r\n-            dict.setTimeouts(stmnt, (JDBCFetchConfiguration)fetch, forUpdate);\r\n-            rs = _select.executeQuery(conn, stmnt, getQueryString(), jstore,\r\n-                params, _pkCols);\r\n-            return _select.getEagerResult(conn, stmnt, rs, jstore, \r\n-                (JDBCFetchConfiguration)fetch, forUpdate, _buffer);\r\n-        } catch (SQLException se) {\r\n-            if (stmnt != null)\r\n-                try { stmnt.close(); } catch (SQLException se2) {}\r\n-            try { conn.close(); } catch (SQLException se2) {}\r\n-            throw new RuntimeException(se);\r\n-        }\r\n-    }\r\n-    \r\n-    private static SelectImpl extractImplementation(SelectExecutor selector) {\r\n-        if (selector == null || selector.hasMultipleSelects())\r\n-            return null;\r\n-        if (selector instanceof SelectImpl) \r\n-            return (SelectImpl)selector;\r\n-        if (selector instanceof LogicalUnion.UnionSelect)\r\n-            return ((LogicalUnion.UnionSelect)selector).getDelegate();\r\n-        if (selector instanceof Union) \r\n-            return extractImplementation(((Union)selector).getSelects()[0]);\r\n-        \r\n-        return null;\r\n-    }\r\n-    \r\n-    public String toString() {\r\n-        return _mapping + \": [\" + getQueryString() + \"]\";\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.Joinable;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.LogicalUnion;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.SelectExecutor;\n+import org.apache.openjpa.jdbc.sql.SelectImpl;\n+import org.apache.openjpa.jdbc.sql.Union;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.FinderQuery;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.util.ApplicationIds;\n+import org.apache.openjpa.util.Id;\n+\n+import serp.util.Numbers;\n+\n+/**\n+ * Implements Finder Query identified by ClassMappping for SelectExecutor that \n+ * can be executed to generate Result. \n+ *  \n+ * @author Pinaki Poddar\n+ *\n+ * @since 2.0.0\n+ */\n+public class FinderQueryImpl \n+    implements FinderQuery<ClassMapping, SelectExecutor, Result> {\n+    private final ClassMapping _mapping;\n+    private final SelectImpl _select;\n+    private final Column[] _pkCols;\n+    private final Joinable[]  _joins;\n+    private final int[] _pkIndices;\n+    private final SQLBuffer _buffer;\n+    private final String _sql;\n+    \n+    /**\n+     * Attempts to construct a FinderQuery from the given Select for the given\n+     * mapping. The given Select may not be amenable for caching and then a null\n+     * value is returned. \n+     */\n+    static FinderQueryImpl newFinder(ClassMapping mapping,\n+        SelectExecutor select) {\n+        SelectImpl impl = extractImplementation(select);\n+        if (impl == null)\n+            return null;\n+        SQLBuffer buffer = impl.getSQL();\n+        Column[] pkCols = mapping.getPrimaryKeyColumns();\n+        boolean canCache = pkCols.length == buffer.getParameters().size();\n+        return (canCache)\n+            ? new FinderQueryImpl(mapping, impl, buffer) : null;\n+    }\n+\n+    private FinderQueryImpl(ClassMapping mapping, SelectImpl select,\n+        SQLBuffer buffer) {\n+        super();\n+        _mapping = mapping;\n+        _select = select;\n+        _buffer = buffer;\n+        _sql = _buffer.getSQL();\n+        _pkCols = _mapping.getPrimaryKeyColumns();\n+        _joins = new Joinable[_pkCols.length];\n+        for (int i = 0; i < _pkCols.length; i++)\n+            _joins[i] = _mapping.assertJoinable(_pkCols[i]);\n+        _pkIndices = new int[_pkCols.length];\n+        for (int i = 0; i < _pkCols.length; i++) {\n+            FieldMetaData pk = _mapping.getField(_joins[i].getFieldIndex());\n+            _pkIndices[i] = pk == null ? 0 : pk.getPrimaryKeyIndex();\n+        }\n+        \n+    }\n+    \n+    public ClassMapping getIdentifier() {\n+        return _mapping;\n+    }\n+    \n+    public SelectExecutor getDelegate() {\n+        return _select;\n+    }\n+    \n+    public String getQueryString() {\n+        return _sql;\n+    }\n+    \n+    public Column[] getPKColumns() {\n+        return _pkCols;\n+    }\n+    \n+    private Object[] getPKValues(OpenJPAStateManager sm, JDBCStore store) {\n+        Object[] pks = null;\n+        Object oid = sm.getObjectId();\n+        if (_mapping.getIdentityType() == ClassMapping.ID_APPLICATION)\n+            pks = ApplicationIds.toPKValues(oid, _mapping);\n+    \n+        Object[] val = new Object[_pkCols.length];\n+        int count = 0;\n+        for (int i = 0; i < _pkCols.length; i++, count++) {\n+            if (pks == null)\n+                val[0] = (oid == null) \n+                    ? null : Numbers.valueOf(((Id) oid).getId());\n+            else {\n+                val[i] = _joins[i].getJoinValue(pks[_pkIndices[i]], _pkCols[i], \n+                    store);\n+            }\n+        }\n+        return val;\n+    }\n+    \n+    public Result execute(OpenJPAStateManager sm, StoreManager store, \n+        FetchConfiguration fetch) {\n+        boolean forUpdate = false;\n+        JDBCStore jstore = (JDBCStore)store;\n+        Connection conn = jstore.getConnection();\n+        DBDictionary dict = jstore.getDBDictionary();\n+        PreparedStatement stmnt = null;\n+        ResultSet rs = null;\n+        try {\n+            stmnt = _select.prepareStatement(conn, _sql);\n+            Object[] params = getPKValues(sm, jstore);\n+            if (stmnt != null) {\n+                for (int i = 0; i <params.length; i++) {\n+                    dict.setUnknown(stmnt, i+1, params[i], _pkCols[i]);\n+                }\n+            }\n+            dict.setTimeouts(stmnt, (JDBCFetchConfiguration)fetch, forUpdate);\n+            rs = _select.executeQuery(conn, stmnt, getQueryString(), jstore,\n+                params, _pkCols);\n+            return _select.getEagerResult(conn, stmnt, rs, jstore, \n+                (JDBCFetchConfiguration)fetch, forUpdate, _buffer);\n+        } catch (SQLException se) {\n+            if (stmnt != null)\n+                try { stmnt.close(); } catch (SQLException se2) {}\n+            try { conn.close(); } catch (SQLException se2) {}\n+            throw new RuntimeException(se);\n+        }\n+    }\n+    \n+    private static SelectImpl extractImplementation(SelectExecutor selector) {\n+        if (selector == null || selector.hasMultipleSelects())\n+            return null;\n+        if (selector instanceof SelectImpl) \n+            return (SelectImpl)selector;\n+        if (selector instanceof LogicalUnion.UnionSelect)\n+            return ((LogicalUnion.UnionSelect)selector).getDelegate();\n+        if (selector instanceof Union) \n+            return extractImplementation(((Union)selector).getSelects()[0]);\n+        \n+        return null;\n+    }\n+    \n+    public String toString() {\n+        return _mapping + \": [\" + getQueryString() + \"]\";\n+    }\n+}"},{"sha":"e27cb21330b8799c1f58c9b2c0c7808ee48f15a5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedQueryCacheImpl.java","status":"modified","additions":346,"deletions":346,"changes":692,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedQueryCacheImpl.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedQueryCacheImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedQueryCacheImpl.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,346 +1,346 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.TreeMap;\r\n-import java.util.concurrent.locks.ReentrantLock;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.PreparedQuery;\r\n-import org.apache.openjpa.kernel.PreparedQueryCache;\r\n-import org.apache.openjpa.kernel.Query;\r\n-import org.apache.openjpa.kernel.QueryHints;\r\n-import org.apache.openjpa.kernel.QueryLanguages;\r\n-import org.apache.openjpa.kernel.QueryStatistics;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-\r\n-/**\r\n- * An implementation of the cache of {@link PreparedQuery prepared queries}. \r\n- * \r\n- * @author Pinaki Poddar\r\n- *\r\n- * @since 2.0.0\r\n- * \r\n- * @nojavadoc\r\n- */\r\n-public class PreparedQueryCacheImpl implements PreparedQueryCache {\r\n-\tprivate static final String PATTERN_SEPARATOR = \"\\\\;\";\r\n-\tprivate static final String EXLUDED_BY_USER = \"Excluded by user\";\r\n-\t// Key: Query identifier \r\n-\tprivate final Map<String, PreparedQuery> _delegate;\r\n-\t// Key: Query identifier Value: Reason why excluded\r\n-\tprivate final Map<String, String> _uncachables;\r\n-\tprivate List<String> _exclusionPatterns;\r\n-\tprivate final QueryStatistics<String> _stats;\r\n-\tprivate ReentrantLock _lock = new ReentrantLock();\r\n-\tprivate Log _log;\r\n-\tprivate Localizer _loc = Localizer.forPackage(PreparedQueryCacheImpl.class);\r\n-\r\n-\tpublic PreparedQueryCacheImpl() {\r\n-\t\t_delegate = new HashMap<String, PreparedQuery>();\r\n-\t\t_uncachables = new HashMap<String, String>();\r\n-\t\t_stats = new QueryStatistics.Default<String>();\r\n-\t}\r\n-\t\r\n-\tpublic Boolean register(String id, Query query, FetchConfiguration hints) {\r\n-        if (id == null \r\n-            || query == null \r\n-            || QueryLanguages.LANG_SQL.equals(query.getLanguage()) \r\n-            || QueryLanguages.LANG_METHODQL.equals(query.getLanguage())\r\n-            || isHinted(hints, QueryHints.HINT_IGNORE_PREPARED_QUERY)\r\n-            || isHinted(hints, QueryHints.HINT_INVALIDATE_PREPARED_QUERY))\r\n-            return Boolean.FALSE;\r\n-        if (isCachable(id) == Boolean.FALSE)\r\n-            return Boolean.FALSE;\r\n-        PreparedQuery cached = get(id);\r\n-        if (cached != null)\r\n-            return null; // implies that it is already cached\r\n-        \r\n-        PreparedQuery newEntry = new PreparedQueryImpl(id, query); \r\n-        return cache(newEntry);\r\n-\t}\r\n-\t\r\n-\tpublic Map<String,String> getMapView() {\r\n-\t\tlock();\r\n-\t\ttry {\r\n-\t\t\tMap<String, String> view = new TreeMap<String, String>();\r\n-\t\t\tfor (Map.Entry<String, PreparedQuery> entry : _delegate.entrySet())\r\n-\t\t\t\tview.put(entry.getKey(), entry.getValue().getTargetQuery());\r\n-\t\t\treturn view;\r\n-\t\t} finally {\r\n-\t\t\tunlock();\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Cache the given query keyed by its identifier. Does not cache if the \r\n-\t * identifier matches any exclusion pattern or has been marked as \r\n-\t * non-cachable. Also register the identifier as not cachable against \r\n-\t * the matched exclusion pattern.\r\n-\t */\r\n-\tpublic boolean cache(PreparedQuery q) {\r\n-\t\tlock();\r\n-\t\ttry {\r\n-\t\t\tString id = q.getIdentifier();\r\n-\t\t\tif (isCachable(id) == Boolean.FALSE) {\r\n-\t\t\t\tif (_log != null && _log.isWarnEnabled())\r\n-\t\t\t\t\t_log.warn(_loc.get(\"prepared-query-not-cachable\", id));\r\n-\t\t\t\treturn false;\r\n-\t\t\t}\r\n-\t\t\tString pattern = getMatchedExclusionPattern(id);\r\n-\t\t\tif (pattern != null) {\r\n-\t\t\t\tmarkUncachable(id, pattern);\r\n-\t\t\t\treturn false;\r\n-\t\t\t}\r\n-\t\t\t_delegate.put(id, q);\r\n-            if (_log != null && _log.isTraceEnabled())\r\n-                _log.trace(_loc.get(\"prepared-query-cached\", id, \r\n-                    q.getTargetQuery()));\r\n-\t\t\treturn true;\r\n-\t\t} finally {\r\n-\t\t\tunlock();\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-    public PreparedQuery initialize(String key, Object result) {\r\n-        PreparedQuery pq = get(key);\r\n-        if (pq == null)\r\n-            return null;\r\n-        \r\n-        boolean cacheable = pq.initialize(result);\r\n-        if (!cacheable) {\r\n-            markUncachable(key);\r\n-            return null;\r\n-        } \r\n-        return pq;\r\n-    }\r\n-\t\r\n-\tpublic boolean invalidate(String id) {\r\n-\t\tlock();\r\n-\t\ttry {\r\n-\t\t\tif (_log.isTraceEnabled())\r\n-\t\t\t\t_log.trace(_loc.get(\"prepared-query-invalidate\", id));\r\n-\t\t\treturn _delegate.remove(id) != null;\r\n-\t\t} finally {\r\n-\t\t\tunlock();\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-    public PreparedQuery get(String id) {\r\n-        lock();\r\n-        try {\r\n-            return _delegate.get(id);\r\n-        } finally {\r\n-            unlock();\r\n-        }\r\n-    }\r\n-    \r\n-\tpublic Boolean isCachable(String id) {\r\n-\t\tlock();\r\n-\t\ttry {\r\n-\t\t\tif (_uncachables.containsKey(id))\r\n-\t\t\t\treturn Boolean.FALSE;\r\n-\t\t\tif (_delegate.containsKey(id))\r\n-\t\t\t\treturn Boolean.TRUE;\r\n-\t\t\treturn null;\r\n-\t\t} finally {\r\n-\t\t\tunlock();\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\tpublic PreparedQuery markUncachable(String id) {\r\n-\t\treturn markUncachable(id, EXLUDED_BY_USER);\r\n-\t}\r\n-\t\r\n-\tprivate PreparedQuery markUncachable(String id, String reason) {\r\n-\t\tlock();\r\n-\t\ttry {\r\n-\t\t\tboolean excludedByUser = _uncachables.get(id) == EXLUDED_BY_USER;\r\n-\t\t\tif (!excludedByUser)\r\n-\t\t\t\t_uncachables.put(id, reason);\r\n-\t\t\tif (_log != null && _log.isInfoEnabled()) {\r\n-\t\t\t\tif (excludedByUser) \r\n-\t\t\t\t\t_log.info(_loc.get(\"prepared-query-uncache-strong\", id));\r\n-\t\t\t\telse \r\n-\t\t\t\t\t_log.info(_loc.get(\"prepared-query-uncache-weak\", id, \r\n-\t\t\t\t\t\treason));\r\n-\t\t\t}\r\n-\t\t\treturn _delegate.remove(id);\r\n-\t\t} finally {\r\n-\t\t\tunlock();\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\tpublic boolean isExcluded(String id) {\r\n-\t\treturn getMatchedExclusionPattern(id) != null;\r\n-\t}\r\n-\t\r\n-\tpublic void setExcludes(String excludes) {\r\n-\t\tlock();\r\n-\t\ttry {\r\n-\t\t\tif (StringUtils.isEmpty(excludes))\r\n-\t\t\t\treturn;\r\n-\t\t\tif (_exclusionPatterns == null)\r\n-\t\t\t\t_exclusionPatterns = new ArrayList<String>();\r\n-\t\t\tString[] patterns = excludes.split(PATTERN_SEPARATOR);\r\n-\t\t\tfor (String pattern : patterns)\r\n-\t\t\t\taddExclusionPattern(pattern);\r\n-\t\t} finally {\r\n-\t\t\tunlock();\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tpublic List<String> getExcludes() {\r\n-\t\treturn _exclusionPatterns == null ? Collections.EMPTY_LIST : \r\n-\t\t\tCollections.unmodifiableList(_exclusionPatterns);\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Adds a pattern for exclusion. Any query cached currently whose identifier\r\n-\t * matches the given pattern will be marked invalidated as a side-effect.\r\n-\t */\r\n-\tpublic void addExclusionPattern(String pattern) {\r\n-\t\tlock();\r\n-\t\ttry {\r\n-\t\t\tif (_exclusionPatterns == null)\r\n-\t\t\t\t_exclusionPatterns = new ArrayList<String>();\r\n-\t\t\t_exclusionPatterns.add(pattern);\r\n-\t\t\tCollection<String> invalidKeys = getMatchedKeys(pattern, \r\n-\t\t\t\t\t_delegate.keySet());\r\n-\t\t\tif (!invalidKeys.isEmpty() && _log != null && _log.isInfoEnabled())\r\n-\t\t\t\t_log.info(_loc.get(\"prepared-query-add-pattern\", pattern, \r\n-\t\t\t\t\tinvalidKeys.size(), invalidKeys));\r\n-\t\t\tfor (String invalidKey : invalidKeys)\r\n-\t\t\t\tmarkUncachable(invalidKey, pattern);\r\n-\t\t} finally {\r\n-\t\t\tunlock();\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Removes a pattern for exclusion. Any query identifier marked as not \r\n-\t * cachable due to the given pattern will now be removed from the list of\r\n-\t * uncachables as a side-effect.\r\n-\t */\r\n-\tpublic void removeExclusionPattern(String pattern) {\r\n-\t\tlock();\r\n-\t\ttry {\r\n-\t\t\tif (_exclusionPatterns == null)\r\n-\t\t\t\treturn;\r\n-\t\t\t_exclusionPatterns.remove(pattern);\r\n-\t\t\tCollection<String> reborns = getMatchedKeys(pattern, _uncachables);\r\n-\t\t\tif (!reborns.isEmpty() && _log != null && _log.isInfoEnabled())\r\n-\t\t\t\t_log.info(_loc.get(\"prepared-query-remove-pattern\", pattern, \r\n-\t\t\t\t\treborns.size(), reborns));\r\n-\t\t\tfor (String rebornKey : reborns)\r\n-\t\t\t\t_uncachables.remove(rebornKey);\r\n-\t\t} finally {\r\n-\t\t\tunlock();\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\tpublic QueryStatistics<String> getStatistics() {\r\n-\t\treturn _stats;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Gets the pattern that matches the given identifier.\r\n-\t */\r\n-\tprivate String getMatchedExclusionPattern(String id) {\r\n-\t\tif (_exclusionPatterns == null || _exclusionPatterns.isEmpty())\r\n-\t\t\treturn null;\r\n-\t\tfor (String pattern : _exclusionPatterns)\r\n-\t\t\tif (matches(pattern, id))\r\n-\t\t\t\treturn pattern;\r\n-\t\treturn null;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Gets the keys of the given map whose values match the given pattern. \r\n-\t */\r\n-\tprivate Collection<String> getMatchedKeys(String pattern, \r\n-\t\t\tMap<String,String> map) {\r\n-        List<String> result = new ArrayList<String>();\r\n-\t\tfor (Map.Entry<String, String> entry : map.entrySet()) {\r\n-\t\t\tif (matches(pattern, entry.getValue())) {\r\n-\t\t\t\tresult.add(entry.getKey());\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn result;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Gets the elements of the given list which match the given pattern. \r\n-\t */\r\n-\tprivate Collection<String> getMatchedKeys(String pattern, \r\n-\t\t\tCollection<String> coll) {\r\n-\t\tList<String> result = new ArrayList<String>();\r\n-\t\tfor (String key : coll) {\r\n-\t\t\tif (matches(pattern, key)) {\r\n-\t\t\t\tresult.add(key);\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn result;\r\n-\t}\r\n-\r\n-    void lock() {\r\n-        if (_lock != null)\r\n-            _lock.lock();\r\n-    }\r\n-\r\n-    void unlock() {\r\n-        if (_lock != null && _lock.isLocked())\r\n-            _lock.unlock();\r\n-    }\r\n-    \r\n-    boolean matches(String pattern, String target) {\r\n-    \treturn target != null && (target.equals(pattern) \r\n-    \t  || target.matches(pattern));\r\n-    }\r\n-    \r\n-    boolean isHinted(FetchConfiguration fetch, String hint) {\r\n-        if (fetch == null)\r\n-            return false;\r\n-        Object result = fetch.getHint(hint);\r\n-        return result != null && \"true\".equalsIgnoreCase(result.toString());\r\n-    }\r\n-        \r\n-\t//-------------------------------------------------------\r\n-\t// Configurable contract\r\n-\t//-------------------------------------------------------\r\n-    public void setConfiguration(Configuration conf) {\r\n-    \t_log = conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.PreparedQuery;\n+import org.apache.openjpa.kernel.PreparedQueryCache;\n+import org.apache.openjpa.kernel.Query;\n+import org.apache.openjpa.kernel.QueryHints;\n+import org.apache.openjpa.kernel.QueryLanguages;\n+import org.apache.openjpa.kernel.QueryStatistics;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+/**\n+ * An implementation of the cache of {@link PreparedQuery prepared queries}. \n+ * \n+ * @author Pinaki Poddar\n+ *\n+ * @since 2.0.0\n+ * \n+ * @nojavadoc\n+ */\n+public class PreparedQueryCacheImpl implements PreparedQueryCache {\n+\tprivate static final String PATTERN_SEPARATOR = \"\\\\;\";\n+\tprivate static final String EXLUDED_BY_USER = \"Excluded by user\";\n+\t// Key: Query identifier \n+\tprivate final Map<String, PreparedQuery> _delegate;\n+\t// Key: Query identifier Value: Reason why excluded\n+\tprivate final Map<String, String> _uncachables;\n+\tprivate List<String> _exclusionPatterns;\n+\tprivate final QueryStatistics<String> _stats;\n+\tprivate ReentrantLock _lock = new ReentrantLock();\n+\tprivate Log _log;\n+\tprivate Localizer _loc = Localizer.forPackage(PreparedQueryCacheImpl.class);\n+\n+\tpublic PreparedQueryCacheImpl() {\n+\t\t_delegate = new HashMap<String, PreparedQuery>();\n+\t\t_uncachables = new HashMap<String, String>();\n+\t\t_stats = new QueryStatistics.Default<String>();\n+\t}\n+\t\n+\tpublic Boolean register(String id, Query query, FetchConfiguration hints) {\n+        if (id == null \n+            || query == null \n+            || QueryLanguages.LANG_SQL.equals(query.getLanguage()) \n+            || QueryLanguages.LANG_METHODQL.equals(query.getLanguage())\n+            || isHinted(hints, QueryHints.HINT_IGNORE_PREPARED_QUERY)\n+            || isHinted(hints, QueryHints.HINT_INVALIDATE_PREPARED_QUERY))\n+            return Boolean.FALSE;\n+        if (isCachable(id) == Boolean.FALSE)\n+            return Boolean.FALSE;\n+        PreparedQuery cached = get(id);\n+        if (cached != null)\n+            return null; // implies that it is already cached\n+        \n+        PreparedQuery newEntry = new PreparedQueryImpl(id, query); \n+        return cache(newEntry);\n+\t}\n+\t\n+\tpublic Map<String,String> getMapView() {\n+\t\tlock();\n+\t\ttry {\n+\t\t\tMap<String, String> view = new TreeMap<String, String>();\n+\t\t\tfor (Map.Entry<String, PreparedQuery> entry : _delegate.entrySet())\n+\t\t\t\tview.put(entry.getKey(), entry.getValue().getTargetQuery());\n+\t\t\treturn view;\n+\t\t} finally {\n+\t\t\tunlock();\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Cache the given query keyed by its identifier. Does not cache if the \n+\t * identifier matches any exclusion pattern or has been marked as \n+\t * non-cachable. Also register the identifier as not cachable against \n+\t * the matched exclusion pattern.\n+\t */\n+\tpublic boolean cache(PreparedQuery q) {\n+\t\tlock();\n+\t\ttry {\n+\t\t\tString id = q.getIdentifier();\n+\t\t\tif (isCachable(id) == Boolean.FALSE) {\n+\t\t\t\tif (_log != null && _log.isWarnEnabled())\n+\t\t\t\t\t_log.warn(_loc.get(\"prepared-query-not-cachable\", id));\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tString pattern = getMatchedExclusionPattern(id);\n+\t\t\tif (pattern != null) {\n+\t\t\t\tmarkUncachable(id, pattern);\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\t_delegate.put(id, q);\n+            if (_log != null && _log.isTraceEnabled())\n+                _log.trace(_loc.get(\"prepared-query-cached\", id, \n+                    q.getTargetQuery()));\n+\t\t\treturn true;\n+\t\t} finally {\n+\t\t\tunlock();\n+\t\t}\n+\t}\n+\t\n+    public PreparedQuery initialize(String key, Object result) {\n+        PreparedQuery pq = get(key);\n+        if (pq == null)\n+            return null;\n+        \n+        boolean cacheable = pq.initialize(result);\n+        if (!cacheable) {\n+            markUncachable(key);\n+            return null;\n+        } \n+        return pq;\n+    }\n+\t\n+\tpublic boolean invalidate(String id) {\n+\t\tlock();\n+\t\ttry {\n+\t\t\tif (_log.isTraceEnabled())\n+\t\t\t\t_log.trace(_loc.get(\"prepared-query-invalidate\", id));\n+\t\t\treturn _delegate.remove(id) != null;\n+\t\t} finally {\n+\t\t\tunlock();\n+\t\t}\n+\t}\n+\t\n+    public PreparedQuery get(String id) {\n+        lock();\n+        try {\n+            return _delegate.get(id);\n+        } finally {\n+            unlock();\n+        }\n+    }\n+    \n+\tpublic Boolean isCachable(String id) {\n+\t\tlock();\n+\t\ttry {\n+\t\t\tif (_uncachables.containsKey(id))\n+\t\t\t\treturn Boolean.FALSE;\n+\t\t\tif (_delegate.containsKey(id))\n+\t\t\t\treturn Boolean.TRUE;\n+\t\t\treturn null;\n+\t\t} finally {\n+\t\t\tunlock();\n+\t\t}\n+\t}\n+\t\n+\tpublic PreparedQuery markUncachable(String id) {\n+\t\treturn markUncachable(id, EXLUDED_BY_USER);\n+\t}\n+\t\n+\tprivate PreparedQuery markUncachable(String id, String reason) {\n+\t\tlock();\n+\t\ttry {\n+\t\t\tboolean excludedByUser = _uncachables.get(id) == EXLUDED_BY_USER;\n+\t\t\tif (!excludedByUser)\n+\t\t\t\t_uncachables.put(id, reason);\n+\t\t\tif (_log != null && _log.isInfoEnabled()) {\n+\t\t\t\tif (excludedByUser) \n+\t\t\t\t\t_log.info(_loc.get(\"prepared-query-uncache-strong\", id));\n+\t\t\t\telse \n+\t\t\t\t\t_log.info(_loc.get(\"prepared-query-uncache-weak\", id, \n+\t\t\t\t\t\treason));\n+\t\t\t}\n+\t\t\treturn _delegate.remove(id);\n+\t\t} finally {\n+\t\t\tunlock();\n+\t\t}\n+\t}\n+\t\n+\tpublic boolean isExcluded(String id) {\n+\t\treturn getMatchedExclusionPattern(id) != null;\n+\t}\n+\t\n+\tpublic void setExcludes(String excludes) {\n+\t\tlock();\n+\t\ttry {\n+\t\t\tif (StringUtils.isEmpty(excludes))\n+\t\t\t\treturn;\n+\t\t\tif (_exclusionPatterns == null)\n+\t\t\t\t_exclusionPatterns = new ArrayList<String>();\n+\t\t\tString[] patterns = excludes.split(PATTERN_SEPARATOR);\n+\t\t\tfor (String pattern : patterns)\n+\t\t\t\taddExclusionPattern(pattern);\n+\t\t} finally {\n+\t\t\tunlock();\n+\t\t}\n+\t}\n+\n+\tpublic List<String> getExcludes() {\n+\t\treturn _exclusionPatterns == null ? Collections.EMPTY_LIST : \n+\t\t\tCollections.unmodifiableList(_exclusionPatterns);\n+\t}\n+\t\n+\t/**\n+\t * Adds a pattern for exclusion. Any query cached currently whose identifier\n+\t * matches the given pattern will be marked invalidated as a side-effect.\n+\t */\n+\tpublic void addExclusionPattern(String pattern) {\n+\t\tlock();\n+\t\ttry {\n+\t\t\tif (_exclusionPatterns == null)\n+\t\t\t\t_exclusionPatterns = new ArrayList<String>();\n+\t\t\t_exclusionPatterns.add(pattern);\n+\t\t\tCollection<String> invalidKeys = getMatchedKeys(pattern, \n+\t\t\t\t\t_delegate.keySet());\n+\t\t\tif (!invalidKeys.isEmpty() && _log != null && _log.isInfoEnabled())\n+\t\t\t\t_log.info(_loc.get(\"prepared-query-add-pattern\", pattern, \n+\t\t\t\t\tinvalidKeys.size(), invalidKeys));\n+\t\t\tfor (String invalidKey : invalidKeys)\n+\t\t\t\tmarkUncachable(invalidKey, pattern);\n+\t\t} finally {\n+\t\t\tunlock();\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Removes a pattern for exclusion. Any query identifier marked as not \n+\t * cachable due to the given pattern will now be removed from the list of\n+\t * uncachables as a side-effect.\n+\t */\n+\tpublic void removeExclusionPattern(String pattern) {\n+\t\tlock();\n+\t\ttry {\n+\t\t\tif (_exclusionPatterns == null)\n+\t\t\t\treturn;\n+\t\t\t_exclusionPatterns.remove(pattern);\n+\t\t\tCollection<String> reborns = getMatchedKeys(pattern, _uncachables);\n+\t\t\tif (!reborns.isEmpty() && _log != null && _log.isInfoEnabled())\n+\t\t\t\t_log.info(_loc.get(\"prepared-query-remove-pattern\", pattern, \n+\t\t\t\t\treborns.size(), reborns));\n+\t\t\tfor (String rebornKey : reborns)\n+\t\t\t\t_uncachables.remove(rebornKey);\n+\t\t} finally {\n+\t\t\tunlock();\n+\t\t}\n+\t}\n+\t\n+\tpublic QueryStatistics<String> getStatistics() {\n+\t\treturn _stats;\n+\t}\n+\t\n+\t/**\n+\t * Gets the pattern that matches the given identifier.\n+\t */\n+\tprivate String getMatchedExclusionPattern(String id) {\n+\t\tif (_exclusionPatterns == null || _exclusionPatterns.isEmpty())\n+\t\t\treturn null;\n+\t\tfor (String pattern : _exclusionPatterns)\n+\t\t\tif (matches(pattern, id))\n+\t\t\t\treturn pattern;\n+\t\treturn null;\n+\t}\n+\t\n+\t/**\n+\t * Gets the keys of the given map whose values match the given pattern. \n+\t */\n+\tprivate Collection<String> getMatchedKeys(String pattern, \n+\t\t\tMap<String,String> map) {\n+        List<String> result = new ArrayList<String>();\n+\t\tfor (Map.Entry<String, String> entry : map.entrySet()) {\n+\t\t\tif (matches(pattern, entry.getValue())) {\n+\t\t\t\tresult.add(entry.getKey());\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\t\n+\t/**\n+\t * Gets the elements of the given list which match the given pattern. \n+\t */\n+\tprivate Collection<String> getMatchedKeys(String pattern, \n+\t\t\tCollection<String> coll) {\n+\t\tList<String> result = new ArrayList<String>();\n+\t\tfor (String key : coll) {\n+\t\t\tif (matches(pattern, key)) {\n+\t\t\t\tresult.add(key);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+    void lock() {\n+        if (_lock != null)\n+            _lock.lock();\n+    }\n+\n+    void unlock() {\n+        if (_lock != null && _lock.isLocked())\n+            _lock.unlock();\n+    }\n+    \n+    boolean matches(String pattern, String target) {\n+    \treturn target != null && (target.equals(pattern) \n+    \t  || target.matches(pattern));\n+    }\n+    \n+    boolean isHinted(FetchConfiguration fetch, String hint) {\n+        if (fetch == null)\n+            return false;\n+        Object result = fetch.getHint(hint);\n+        return result != null && \"true\".equalsIgnoreCase(result.toString());\n+    }\n+        \n+\t//-------------------------------------------------------\n+\t// Configurable contract\n+\t//-------------------------------------------------------\n+    public void setConfiguration(Configuration conf) {\n+    \t_log = conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+    }\n+}"},{"sha":"eaa17567d9416351a8f4607d4c646aae663977e4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedQueryImpl.java","status":"modified","additions":332,"deletions":332,"changes":664,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedQueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedQueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedQueryImpl.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,332 +1,332 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import java.util.Arrays;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n-import org.apache.openjpa.jdbc.meta.MappingRepository;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.sql.LogicalUnion;\r\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\r\n-import org.apache.openjpa.jdbc.sql.Select;\r\n-import org.apache.openjpa.jdbc.sql.SelectExecutor;\r\n-import org.apache.openjpa.jdbc.sql.SelectImpl;\r\n-import org.apache.openjpa.jdbc.sql.Union;\r\n-import org.apache.openjpa.kernel.Broker;\r\n-import org.apache.openjpa.kernel.PreparedQuery;\r\n-import org.apache.openjpa.kernel.Query;\r\n-import org.apache.openjpa.kernel.QueryImpl;\r\n-import org.apache.openjpa.kernel.QueryLanguages;\r\n-import org.apache.openjpa.lib.rop.ResultList;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * Implements {@link PreparedQuery} for SQL queries.\r\n- * \r\n- * @author Pinaki Poddar\r\n- *\r\n- */\r\n-public class PreparedQueryImpl implements PreparedQuery {\r\n-    private static Localizer _loc = \r\n-        Localizer.forPackage(PreparedQueryImpl.class);\r\n-\r\n-    private final String _id;\r\n-    private String _sql;\r\n-    private boolean _initialized;\r\n-    \r\n-    // Post-compilation state of an executable query, populated on construction\r\n-    private Class _candidate;\r\n-    private boolean _subclasses;\r\n-    private boolean _isProjection;\r\n-    \r\n-    // Position of the user defined parameters in the _params list\r\n-    private Map<Object, int[]>    _userParamPositions;\r\n-    private Map<Integer, Object> _template;\r\n-    private SelectImpl select;\r\n-\r\n-    /**\r\n-     * Construct.\r\n-     * \r\n-     * @param id an identifier for this query to be used as cache key\r\n-     * @param compiled a compiled query \r\n-     */\r\n-    public PreparedQueryImpl(String id, Query compiled) {\r\n-        this(id, null, compiled);\r\n-    }\r\n-    \r\n-    /**\r\n-     * Construct.\r\n-     * \r\n-     * @param id an identifier for this query to be used as cache key\r\n-     * @param corresponding data store language query string \r\n-     * @param compiled a compiled query \r\n-     */\r\n-    public PreparedQueryImpl(String id, String sql, Query compiled) {\r\n-        this._id = id;\r\n-        this._sql = sql;\r\n-        if (compiled != null) {\r\n-            _candidate    = compiled.getCandidateType();\r\n-            _subclasses   = compiled.hasSubclasses();\r\n-            _isProjection = compiled.getProjectionAliases().length > 0;\r\n-        }\r\n-    }\r\n-    \r\n-    public String getIdentifier() {\r\n-        return _id;\r\n-    }\r\n-    \r\n-    public String getLanguage() {\r\n-        return QueryLanguages.LANG_PREPARED_SQL;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Get the original query string which is same as the identifier of this \r\n-     * receiver.\r\n-     */\r\n-    public String getOriginalQuery() {\r\n-        return getIdentifier();\r\n-    }\r\n-    \r\n-    public String getTargetQuery() {\r\n-        return _sql;\r\n-    }\r\n-    \r\n-    void setTargetQuery(String sql) {\r\n-        _sql = sql;\r\n-    }\r\n-    \r\n-    public boolean isInitialized() {\r\n-        return _initialized;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Pours the post-compilation state held by this receiver to the given\r\n-     * query.\r\n-     */\r\n-    public void setInto(Query q) {\r\n-        if (!_isProjection)\r\n-            q.setCandidateType(_candidate, _subclasses);\r\n-    }\r\n-\r\n-    /**\r\n-     * Initialize this receiver with post-execution result.\r\n-     * The input argument is processed only if it is a {@link ResultList} with\r\n-     * an attached {@link SelectResultObjectProvider} as its\r\n-     * {@link ResultList#getUserObject() user object}. \r\n-     */\r\n-    public boolean initialize(Object result) {\r\n-        if (isInitialized())\r\n-            return true;\r\n-        SelectExecutor selector = extractSelectExecutor(result);\r\n-        if (selector == null || selector.hasMultipleSelects()\r\n-          || ((selector instanceof Union) \r\n-          && (((Union)selector).getSelects().length != 1)))\r\n-            return false;\r\n-        select = extractImplementation(selector);\r\n-        if (select == null)\r\n-            return false;\r\n-        SQLBuffer buffer = selector.getSQL();\r\n-        if (buffer == null)\r\n-            return false;\r\n-        setTargetQuery(buffer.getSQL());\r\n-        setParameters(buffer.getParameters());\r\n-        setUserParameterPositions(buffer.getUserParameters());\r\n-        _initialized = true;\r\n-        \r\n-        return true;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Extract the underlying SelectExecutor from the given argument, if \r\n-     * possible.\r\n-     */\r\n-    private SelectExecutor extractSelectExecutor(Object result) {\r\n-        if (result instanceof ResultList == false)\r\n-            return null;\r\n-        Object provider = ((ResultList)result).getUserObject();\r\n-        if (provider instanceof QueryImpl.PackingResultObjectProvider) {\r\n-            provider = ((QueryImpl.PackingResultObjectProvider)provider)\r\n-                .getDelegate();\r\n-        }\r\n-        if (provider instanceof SelectResultObjectProvider) {\r\n-            return ((SelectResultObjectProvider)provider).getSelect();\r\n-        } \r\n-        return null;\r\n-    }\r\n-    \r\n-    private SelectImpl extractImplementation(SelectExecutor selector) {\r\n-        if (selector == null)\r\n-            return null;\r\n-        if (selector instanceof SelectImpl) \r\n-            return (SelectImpl)selector;\r\n-        if (selector instanceof LogicalUnion.UnionSelect)\r\n-            return ((LogicalUnion.UnionSelect)selector).getDelegate();\r\n-        if (selector instanceof Union) \r\n-            return extractImplementation(((Union)selector).getSelects()[0]);\r\n-        \r\n-        return null;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Merge the given user parameters with its own parameter. The given map\r\n-     * must be compatible with the user parameters extracted during \r\n-     * {@link #initialize(Object) initialization}. \r\n-     * \r\n-     * @return 0-based parameter index mapped to corresponding values.\r\n-     * \r\n-     */\r\n-    public Map<Integer, Object> reparametrize(Map user, Broker broker) {\r\n-        if (!isInitialized())\r\n-            throw new InternalException(\"reparameterize() on uninitialized.\");\r\n-        if (user == null || user.isEmpty()) {\r\n-            if (!_userParamPositions.isEmpty()) {\r\n-                throw new UserException(_loc.get(\"uparam-null\", \r\n-                    _userParamPositions.keySet(), this));\r\n-            } else {\r\n-                return _template;\r\n-            }\r\n-        }\r\n-        if (!_userParamPositions.keySet().equals(user.keySet())) {\r\n-            throw new UserException(_loc.get(\"uparam-mismatch\", \r\n-                _userParamPositions.keySet(), user.keySet(), this));\r\n-        }\r\n-        Map<Integer, Object> result = new HashMap<Integer, Object>(_template);\r\n-        \r\n-        for (Object key : user.keySet()) {\r\n-            int[] indices = _userParamPositions.get(key);\r\n-            if (indices == null || indices.length == 0)\r\n-                throw new UserException(_loc.get(\"uparam-no-pos\", key, this));\r\n-            Object val = user.get(key);\r\n-            if (ImplHelper.isManageable(val)) {\r\n-                setPersistenceCapableParameter(result, val, indices, broker);\r\n-            } else if (val instanceof Collection) {\r\n-                setCollectionValuedParameter(result, (Collection)val, indices, \r\n-                    key);\r\n-            } else {\r\n-                for (int j : indices)\r\n-                    result.put(j, val);\r\n-            }\r\n-        }\r\n-        return result;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Calculate primary key identity value(s) of the given manageable instance\r\n-     * and fill in the given map.\r\n-     * \r\n-     * @param values a map of integer parameter index to parameter value\r\n-     * @param pc a manageable instance\r\n-     * @param indices the indices of the column values\r\n-     * @param broker used to obtain the primary key values\r\n-     */\r\n-    private void setPersistenceCapableParameter(Map<Integer,Object> result, \r\n-        Object pc, int[] indices, Broker broker) {\r\n-        JDBCStore store = (JDBCStore)broker.getStoreManager()\r\n-            .getInnermostDelegate();\r\n-        MappingRepository repos = store.getConfiguration()\r\n-            .getMappingRepositoryInstance();\r\n-        ClassMapping mapping = repos.getMapping(pc.getClass(), \r\n-            broker.getClassLoader(), true);\r\n-        Column[] pks = mapping.getPrimaryKeyColumns();\r\n-        Object cols = mapping.toDataStoreValue(pc, pks, store);\r\n-        if (cols instanceof Object[]) {\r\n-            Object[] array = (Object[])cols;\r\n-            int n = array.length;\r\n-            if (n > indices.length || indices.length%n != 0)\r\n-                throw new UserException(_loc.get(\"uparam-pc-key\", \r\n-                    pc.getClass(), n, Arrays.toString(indices)));\r\n-            int k = 0;\r\n-            for (int j : indices) {\r\n-                result.put(j, array[k%n]);\r\n-                k++;\r\n-            }\r\n-        } else {\r\n-            for (int j : indices) {\r\n-                result.put(j, cols);\r\n-            }\r\n-        } \r\n-    }\r\n-    \r\n-    private void setCollectionValuedParameter(Map<Integer,Object> result, \r\n-        Collection values, int[] indices, Object param) {\r\n-        int n = values.size();\r\n-        Object[] array = values.toArray();\r\n-        if (n > indices.length || indices.length%n != 0) {\r\n-            throw new UserException(_loc.get(\"uparam-coll-size\", param, values, \r\n-                Arrays.toString(indices)));\r\n-        }\r\n-        int k = 0;\r\n-        for (int j : indices) {\r\n-            result.put(j, array[k%n]);\r\n-            k++;\r\n-        }\r\n-        \r\n-    }\r\n-    /**\r\n-     * Marks the positions and keys of user parameters.\r\n-     * \r\n-     * @param list even elements are numbers representing the position of a \r\n-     * user parameter in the _param list. Odd elements are the user parameter\r\n-     * key. A user parameter key may appear more than once.\r\n-     */\r\n-    void setUserParameterPositions(List list) {\r\n-        _userParamPositions = new HashMap<Object, int[]>();\r\n-        for (int i = 1; list != null && i < list.size(); i += 2) {\r\n-            Object key = list.get(i);\r\n-            int p = (Integer)list.get(i-1);\r\n-            int[] positions = _userParamPositions.get(key);\r\n-            if (positions == null) {\r\n-                positions = new int[]{p};\r\n-            } else {\r\n-                int[] temp = new int[positions.length+1];\r\n-                System.arraycopy(positions, 0, temp, 0, positions.length);\r\n-                temp[positions.length] = p;\r\n-                positions = temp;\r\n-            }\r\n-            _userParamPositions.put(key, positions);\r\n-        }\r\n-    }\r\n-    \r\n-    void setParameters(List list) {\r\n-        Map<Integer, Object> tmp = new HashMap<Integer, Object>();\r\n-        for (int i = 0; list != null && i < list.size(); i++) {\r\n-            tmp.put(i, list.get(i));\r\n-        }\r\n-        _template = Collections.unmodifiableMap(tmp);\r\n-    }\r\n-    \r\n-    SelectImpl getSelect() {\r\n-        return select;\r\n-    }\r\n-    \r\n-    public String toString() {\r\n-        return \"PreparedQuery: [\" + getOriginalQuery() + \"] --> [\" + \r\n-               getTargetQuery() + \"]\";\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.MappingRepository;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.sql.LogicalUnion;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.jdbc.sql.SelectExecutor;\n+import org.apache.openjpa.jdbc.sql.SelectImpl;\n+import org.apache.openjpa.jdbc.sql.Union;\n+import org.apache.openjpa.kernel.Broker;\n+import org.apache.openjpa.kernel.PreparedQuery;\n+import org.apache.openjpa.kernel.Query;\n+import org.apache.openjpa.kernel.QueryImpl;\n+import org.apache.openjpa.kernel.QueryLanguages;\n+import org.apache.openjpa.lib.rop.ResultList;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Implements {@link PreparedQuery} for SQL queries.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public class PreparedQueryImpl implements PreparedQuery {\n+    private static Localizer _loc = \n+        Localizer.forPackage(PreparedQueryImpl.class);\n+\n+    private final String _id;\n+    private String _sql;\n+    private boolean _initialized;\n+    \n+    // Post-compilation state of an executable query, populated on construction\n+    private Class _candidate;\n+    private boolean _subclasses;\n+    private boolean _isProjection;\n+    \n+    // Position of the user defined parameters in the _params list\n+    private Map<Object, int[]>    _userParamPositions;\n+    private Map<Integer, Object> _template;\n+    private SelectImpl select;\n+\n+    /**\n+     * Construct.\n+     * \n+     * @param id an identifier for this query to be used as cache key\n+     * @param compiled a compiled query \n+     */\n+    public PreparedQueryImpl(String id, Query compiled) {\n+        this(id, null, compiled);\n+    }\n+    \n+    /**\n+     * Construct.\n+     * \n+     * @param id an identifier for this query to be used as cache key\n+     * @param corresponding data store language query string \n+     * @param compiled a compiled query \n+     */\n+    public PreparedQueryImpl(String id, String sql, Query compiled) {\n+        this._id = id;\n+        this._sql = sql;\n+        if (compiled != null) {\n+            _candidate    = compiled.getCandidateType();\n+            _subclasses   = compiled.hasSubclasses();\n+            _isProjection = compiled.getProjectionAliases().length > 0;\n+        }\n+    }\n+    \n+    public String getIdentifier() {\n+        return _id;\n+    }\n+    \n+    public String getLanguage() {\n+        return QueryLanguages.LANG_PREPARED_SQL;\n+    }\n+    \n+    /**\n+     * Get the original query string which is same as the identifier of this \n+     * receiver.\n+     */\n+    public String getOriginalQuery() {\n+        return getIdentifier();\n+    }\n+    \n+    public String getTargetQuery() {\n+        return _sql;\n+    }\n+    \n+    void setTargetQuery(String sql) {\n+        _sql = sql;\n+    }\n+    \n+    public boolean isInitialized() {\n+        return _initialized;\n+    }\n+    \n+    /**\n+     * Pours the post-compilation state held by this receiver to the given\n+     * query.\n+     */\n+    public void setInto(Query q) {\n+        if (!_isProjection)\n+            q.setCandidateType(_candidate, _subclasses);\n+    }\n+\n+    /**\n+     * Initialize this receiver with post-execution result.\n+     * The input argument is processed only if it is a {@link ResultList} with\n+     * an attached {@link SelectResultObjectProvider} as its\n+     * {@link ResultList#getUserObject() user object}. \n+     */\n+    public boolean initialize(Object result) {\n+        if (isInitialized())\n+            return true;\n+        SelectExecutor selector = extractSelectExecutor(result);\n+        if (selector == null || selector.hasMultipleSelects()\n+          || ((selector instanceof Union) \n+          && (((Union)selector).getSelects().length != 1)))\n+            return false;\n+        select = extractImplementation(selector);\n+        if (select == null)\n+            return false;\n+        SQLBuffer buffer = selector.getSQL();\n+        if (buffer == null)\n+            return false;\n+        setTargetQuery(buffer.getSQL());\n+        setParameters(buffer.getParameters());\n+        setUserParameterPositions(buffer.getUserParameters());\n+        _initialized = true;\n+        \n+        return true;\n+    }\n+    \n+    /**\n+     * Extract the underlying SelectExecutor from the given argument, if \n+     * possible.\n+     */\n+    private SelectExecutor extractSelectExecutor(Object result) {\n+        if (result instanceof ResultList == false)\n+            return null;\n+        Object provider = ((ResultList)result).getUserObject();\n+        if (provider instanceof QueryImpl.PackingResultObjectProvider) {\n+            provider = ((QueryImpl.PackingResultObjectProvider)provider)\n+                .getDelegate();\n+        }\n+        if (provider instanceof SelectResultObjectProvider) {\n+            return ((SelectResultObjectProvider)provider).getSelect();\n+        } \n+        return null;\n+    }\n+    \n+    private SelectImpl extractImplementation(SelectExecutor selector) {\n+        if (selector == null)\n+            return null;\n+        if (selector instanceof SelectImpl) \n+            return (SelectImpl)selector;\n+        if (selector instanceof LogicalUnion.UnionSelect)\n+            return ((LogicalUnion.UnionSelect)selector).getDelegate();\n+        if (selector instanceof Union) \n+            return extractImplementation(((Union)selector).getSelects()[0]);\n+        \n+        return null;\n+    }\n+    \n+    /**\n+     * Merge the given user parameters with its own parameter. The given map\n+     * must be compatible with the user parameters extracted during \n+     * {@link #initialize(Object) initialization}. \n+     * \n+     * @return 0-based parameter index mapped to corresponding values.\n+     * \n+     */\n+    public Map<Integer, Object> reparametrize(Map user, Broker broker) {\n+        if (!isInitialized())\n+            throw new InternalException(\"reparameterize() on uninitialized.\");\n+        if (user == null || user.isEmpty()) {\n+            if (!_userParamPositions.isEmpty()) {\n+                throw new UserException(_loc.get(\"uparam-null\", \n+                    _userParamPositions.keySet(), this));\n+            } else {\n+                return _template;\n+            }\n+        }\n+        if (!_userParamPositions.keySet().equals(user.keySet())) {\n+            throw new UserException(_loc.get(\"uparam-mismatch\", \n+                _userParamPositions.keySet(), user.keySet(), this));\n+        }\n+        Map<Integer, Object> result = new HashMap<Integer, Object>(_template);\n+        \n+        for (Object key : user.keySet()) {\n+            int[] indices = _userParamPositions.get(key);\n+            if (indices == null || indices.length == 0)\n+                throw new UserException(_loc.get(\"uparam-no-pos\", key, this));\n+            Object val = user.get(key);\n+            if (ImplHelper.isManageable(val)) {\n+                setPersistenceCapableParameter(result, val, indices, broker);\n+            } else if (val instanceof Collection) {\n+                setCollectionValuedParameter(result, (Collection)val, indices, \n+                    key);\n+            } else {\n+                for (int j : indices)\n+                    result.put(j, val);\n+            }\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Calculate primary key identity value(s) of the given manageable instance\n+     * and fill in the given map.\n+     * \n+     * @param values a map of integer parameter index to parameter value\n+     * @param pc a manageable instance\n+     * @param indices the indices of the column values\n+     * @param broker used to obtain the primary key values\n+     */\n+    private void setPersistenceCapableParameter(Map<Integer,Object> result, \n+        Object pc, int[] indices, Broker broker) {\n+        JDBCStore store = (JDBCStore)broker.getStoreManager()\n+            .getInnermostDelegate();\n+        MappingRepository repos = store.getConfiguration()\n+            .getMappingRepositoryInstance();\n+        ClassMapping mapping = repos.getMapping(pc.getClass(), \n+            broker.getClassLoader(), true);\n+        Column[] pks = mapping.getPrimaryKeyColumns();\n+        Object cols = mapping.toDataStoreValue(pc, pks, store);\n+        if (cols instanceof Object[]) {\n+            Object[] array = (Object[])cols;\n+            int n = array.length;\n+            if (n > indices.length || indices.length%n != 0)\n+                throw new UserException(_loc.get(\"uparam-pc-key\", \n+                    pc.getClass(), n, Arrays.toString(indices)));\n+            int k = 0;\n+            for (int j : indices) {\n+                result.put(j, array[k%n]);\n+                k++;\n+            }\n+        } else {\n+            for (int j : indices) {\n+                result.put(j, cols);\n+            }\n+        } \n+    }\n+    \n+    private void setCollectionValuedParameter(Map<Integer,Object> result, \n+        Collection values, int[] indices, Object param) {\n+        int n = values.size();\n+        Object[] array = values.toArray();\n+        if (n > indices.length || indices.length%n != 0) {\n+            throw new UserException(_loc.get(\"uparam-coll-size\", param, values, \n+                Arrays.toString(indices)));\n+        }\n+        int k = 0;\n+        for (int j : indices) {\n+            result.put(j, array[k%n]);\n+            k++;\n+        }\n+        \n+    }\n+    /**\n+     * Marks the positions and keys of user parameters.\n+     * \n+     * @param list even elements are numbers representing the position of a \n+     * user parameter in the _param list. Odd elements are the user parameter\n+     * key. A user parameter key may appear more than once.\n+     */\n+    void setUserParameterPositions(List list) {\n+        _userParamPositions = new HashMap<Object, int[]>();\n+        for (int i = 1; list != null && i < list.size(); i += 2) {\n+            Object key = list.get(i);\n+            int p = (Integer)list.get(i-1);\n+            int[] positions = _userParamPositions.get(key);\n+            if (positions == null) {\n+                positions = new int[]{p};\n+            } else {\n+                int[] temp = new int[positions.length+1];\n+                System.arraycopy(positions, 0, temp, 0, positions.length);\n+                temp[positions.length] = p;\n+                positions = temp;\n+            }\n+            _userParamPositions.put(key, positions);\n+        }\n+    }\n+    \n+    void setParameters(List list) {\n+        Map<Integer, Object> tmp = new HashMap<Integer, Object>();\n+        for (int i = 0; list != null && i < list.size(); i++) {\n+            tmp.put(i, list.get(i));\n+        }\n+        _template = Collections.unmodifiableMap(tmp);\n+    }\n+    \n+    SelectImpl getSelect() {\n+        return select;\n+    }\n+    \n+    public String toString() {\n+        return \"PreparedQuery: [\" + getOriginalQuery() + \"] --> [\" + \n+               getTargetQuery() + \"]\";\n+    }\n+}"},{"sha":"accf616c5a834f9d661e839a460630c31bfa9f66","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedResultObjectProvider.java","status":"modified","additions":53,"deletions":53,"changes":106,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedResultObjectProvider.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,53 +1,53 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import java.sql.SQLException;\r\n-\r\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n-import org.apache.openjpa.jdbc.sql.Result;\r\n-import org.apache.openjpa.jdbc.sql.SelectExecutor;\r\n-\r\n-/**\r\n- * A Select-oriented Result Object Provider whose Select has been executed\r\n- * outside its own scope.\r\n- *  \r\n- * @author Pinaki Poddar\r\n- *\r\n- */\r\n-public class PreparedResultObjectProvider extends InstanceResultObjectProvider {\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param sel the select to execute\r\n-     * @param store the store to delegate loading to\r\n-     * @param fetch the fetch configuration, or null for the default\r\n-     * @param res the result of the given select\r\n-     */\r\n-    public PreparedResultObjectProvider(SelectExecutor sel,\r\n-        ClassMapping mapping, JDBCStore store, JDBCFetchConfiguration fetch, \r\n-        Result res) {\r\n-        super(sel, mapping, store, fetch);\r\n-        _res = res;\r\n-    }\r\n-    \r\n-    public void open() throws SQLException {\r\n-        // do nothing\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SelectExecutor;\n+\n+/**\n+ * A Select-oriented Result Object Provider whose Select has been executed\n+ * outside its own scope.\n+ *  \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public class PreparedResultObjectProvider extends InstanceResultObjectProvider {\n+    /**\n+     * Constructor.\n+     *\n+     * @param sel the select to execute\n+     * @param store the store to delegate loading to\n+     * @param fetch the fetch configuration, or null for the default\n+     * @param res the result of the given select\n+     */\n+    public PreparedResultObjectProvider(SelectExecutor sel,\n+        ClassMapping mapping, JDBCStore store, JDBCFetchConfiguration fetch, \n+        Result res) {\n+        super(sel, mapping, store, fetch);\n+        _res = res;\n+    }\n+    \n+    public void open() throws SQLException {\n+        // do nothing\n+    }\n+}"},{"sha":"cba2c304392d77be968e0b0c6a2192dcd5bf63b8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedSQLStoreQuery.java","status":"modified","additions":147,"deletions":147,"changes":294,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedSQLStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedSQLStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedSQLStoreQuery.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,147 +1,147 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import java.sql.Connection;\r\n-import java.sql.PreparedStatement;\r\n-import java.sql.ResultSet;\r\n-import java.sql.SQLException;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\r\n-import org.apache.openjpa.jdbc.sql.Result;\r\n-import org.apache.openjpa.jdbc.sql.ResultSetResult;\r\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\r\n-import org.apache.openjpa.jdbc.sql.SQLExceptions;\r\n-import org.apache.openjpa.jdbc.sql.SelectImpl;\r\n-import org.apache.openjpa.kernel.StoreQuery;\r\n-import org.apache.openjpa.lib.rop.RangeResultObjectProvider;\r\n-import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.util.InternalException;\r\n-\r\n-/**\r\n- * A executor for Prepared SQL Query.\r\n- * \r\n- * @author Pinaki Poddar\r\n- *\r\n- */\r\n-public class PreparedSQLStoreQuery extends SQLStoreQuery {\r\n-    private PreparedQueryImpl _cached;\r\n-    public PreparedSQLStoreQuery(JDBCStore store) {\r\n-        super(store);\r\n-    }\r\n-    \r\n-    public Executor newDataStoreExecutor(ClassMetaData meta,\r\n-        boolean subclasses) {\r\n-        return new PreparedSQLExecutor(this, meta);\r\n-    }\r\n-    \r\n-    public boolean setQuery(Object query) {\r\n-        if (query instanceof PreparedQueryImpl == false) {\r\n-            throw new InternalException(query.getClass() + \" not recognized\");\r\n-        }\r\n-        _cached = (PreparedQueryImpl)query;\r\n-        return true;\r\n-    }\r\n-    \r\n-    PreparedQueryImpl getPreparedQuery() {\r\n-        return _cached;\r\n-    }\r\n-\r\n-    \r\n-    public static class PreparedSQLExecutor extends AbstractExecutor {\r\n-        private final ClassMetaData _meta;\r\n-        public PreparedSQLExecutor(PreparedSQLStoreQuery q, \r\n-            ClassMetaData candidate) {\r\n-            _meta = candidate;\r\n-        }\r\n-               \r\n-        public int getOperation(StoreQuery q) {\r\n-            return OP_SELECT;\r\n-        }\r\n-\r\n-        public ResultObjectProvider executeQuery(StoreQuery q,\r\n-            Object[] params, Range range) {\r\n-            PreparedSQLStoreQuery psq = (PreparedSQLStoreQuery) q;\r\n-            PreparedQueryImpl pq = psq.getPreparedQuery();\r\n-            JDBCStore store = psq.getStore();\r\n-            DBDictionary dict = store.getDBDictionary();\r\n-\r\n-            SQLBuffer buf = new SQLBuffer(dict).append(pq.getTargetQuery());\r\n-            Connection conn = store.getConnection();\r\n-            JDBCFetchConfiguration fetch = (JDBCFetchConfiguration)\r\n-                q.getContext().getFetchConfiguration();\r\n-\r\n-            ResultObjectProvider rop;\r\n-            PreparedStatement stmnt = null;\r\n-            try {\r\n-                stmnt = !range.lrs\r\n-                    ? buf.prepareStatement(conn)\r\n-                    : buf.prepareStatement(conn, fetch, -1, -1);\r\n-\r\n-                int index = 0;\r\n-                for (int i = 0; i < params.length; i++)\r\n-                    dict.setUnknown(stmnt, ++index, params[i], null);\r\n-\r\n-                dict.setTimeouts(stmnt, fetch, false);\r\n-\r\n-                ResultSet rs = stmnt.executeQuery();\r\n-                \r\n-                SelectImpl cachedSelect = pq.getSelect();\r\n-                Result res = cachedSelect.getEagerResult(conn, stmnt, rs, \r\n-                    store, fetch, false, null);\r\n-                if (q.getContext().getCandidateType() != null)\r\n-                    rop = new PreparedResultObjectProvider(cachedSelect, \r\n-                        (ClassMapping) _meta, store, fetch, res);\r\n-                else\r\n-                    rop = new SQLProjectionResultObjectProvider(store, fetch,\r\n-                        (ResultSetResult)res, q.getContext().getResultType());\r\n-            } catch (SQLException se) {\r\n-                if (stmnt != null)\r\n-                    try { stmnt.close(); } catch (SQLException se2) {}\r\n-                try { conn.close(); } catch (SQLException se2) {}\r\n-                throw SQLExceptions.getStore(se, dict);\r\n-            }\r\n-\r\n-            if (range.start != 0 || range.end != Long.MAX_VALUE)\r\n-                rop = new RangeResultObjectProvider(rop, range.start,range.end);\r\n-            return rop;\r\n-        }\r\n-        \r\n-        /**\r\n-         * Convert given userParams to an array whose ordering matches as \r\n-         * per expected during executeXXX() methods.\r\n-         * The given userParams is already re-parameterized, so this method have \r\n-         * to merely copy the given Map values.\r\n-         * \r\n-         * @see PreparedQueryImpl#reparametrize(Map, org.apache.openjpa.kernel.Broker)\r\n-         */\r\n-        public Object[] toParameterArray(StoreQuery q, Map userParams) {\r\n-            Object[] array = new Object[userParams.size()];\r\n-            for (Object key : userParams.keySet()) {\r\n-                int idx = ((Integer)key).intValue();\r\n-                array[idx] = userParams.get(key);\r\n-            }\r\n-            return array;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.ResultSetResult;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.jdbc.sql.SelectImpl;\n+import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.lib.rop.RangeResultObjectProvider;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.util.InternalException;\n+\n+/**\n+ * A executor for Prepared SQL Query.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public class PreparedSQLStoreQuery extends SQLStoreQuery {\n+    private PreparedQueryImpl _cached;\n+    public PreparedSQLStoreQuery(JDBCStore store) {\n+        super(store);\n+    }\n+    \n+    public Executor newDataStoreExecutor(ClassMetaData meta,\n+        boolean subclasses) {\n+        return new PreparedSQLExecutor(this, meta);\n+    }\n+    \n+    public boolean setQuery(Object query) {\n+        if (query instanceof PreparedQueryImpl == false) {\n+            throw new InternalException(query.getClass() + \" not recognized\");\n+        }\n+        _cached = (PreparedQueryImpl)query;\n+        return true;\n+    }\n+    \n+    PreparedQueryImpl getPreparedQuery() {\n+        return _cached;\n+    }\n+\n+    \n+    public static class PreparedSQLExecutor extends AbstractExecutor {\n+        private final ClassMetaData _meta;\n+        public PreparedSQLExecutor(PreparedSQLStoreQuery q, \n+            ClassMetaData candidate) {\n+            _meta = candidate;\n+        }\n+               \n+        public int getOperation(StoreQuery q) {\n+            return OP_SELECT;\n+        }\n+\n+        public ResultObjectProvider executeQuery(StoreQuery q,\n+            Object[] params, Range range) {\n+            PreparedSQLStoreQuery psq = (PreparedSQLStoreQuery) q;\n+            PreparedQueryImpl pq = psq.getPreparedQuery();\n+            JDBCStore store = psq.getStore();\n+            DBDictionary dict = store.getDBDictionary();\n+\n+            SQLBuffer buf = new SQLBuffer(dict).append(pq.getTargetQuery());\n+            Connection conn = store.getConnection();\n+            JDBCFetchConfiguration fetch = (JDBCFetchConfiguration)\n+                q.getContext().getFetchConfiguration();\n+\n+            ResultObjectProvider rop;\n+            PreparedStatement stmnt = null;\n+            try {\n+                stmnt = !range.lrs\n+                    ? buf.prepareStatement(conn)\n+                    : buf.prepareStatement(conn, fetch, -1, -1);\n+\n+                int index = 0;\n+                for (int i = 0; i < params.length; i++)\n+                    dict.setUnknown(stmnt, ++index, params[i], null);\n+\n+                dict.setTimeouts(stmnt, fetch, false);\n+\n+                ResultSet rs = stmnt.executeQuery();\n+                \n+                SelectImpl cachedSelect = pq.getSelect();\n+                Result res = cachedSelect.getEagerResult(conn, stmnt, rs, \n+                    store, fetch, false, null);\n+                if (q.getContext().getCandidateType() != null)\n+                    rop = new PreparedResultObjectProvider(cachedSelect, \n+                        (ClassMapping) _meta, store, fetch, res);\n+                else\n+                    rop = new SQLProjectionResultObjectProvider(store, fetch,\n+                        (ResultSetResult)res, q.getContext().getResultType());\n+            } catch (SQLException se) {\n+                if (stmnt != null)\n+                    try { stmnt.close(); } catch (SQLException se2) {}\n+                try { conn.close(); } catch (SQLException se2) {}\n+                throw SQLExceptions.getStore(se, dict);\n+            }\n+\n+            if (range.start != 0 || range.end != Long.MAX_VALUE)\n+                rop = new RangeResultObjectProvider(rop, range.start,range.end);\n+            return rop;\n+        }\n+        \n+        /**\n+         * Convert given userParams to an array whose ordering matches as \n+         * per expected during executeXXX() methods.\n+         * The given userParams is already re-parameterized, so this method have \n+         * to merely copy the given Map values.\n+         * \n+         * @see PreparedQueryImpl#reparametrize(Map, org.apache.openjpa.kernel.Broker)\n+         */\n+        public Object[] toParameterArray(StoreQuery q, Map userParams) {\n+            Object[] array = new Object[userParams.size()];\n+            for (Object key : userParams.keySet()) {\n+                int idx = ((Integer)key).intValue();\n+                array[idx] = userParams.get(key);\n+            }\n+            return array;\n+        }\n+    }\n+}"},{"sha":"af35d10d45415f25fdad984fd4bc8a4a48b50873","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MapEntry.java","status":"modified","additions":164,"deletions":164,"changes":328,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MapEntry.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MapEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MapEntry.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,164 +1,164 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.kernel.exps;\r\n-\r\n-import java.sql.SQLException;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.jdbc.sql.Result;\r\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\r\n-import org.apache.openjpa.jdbc.sql.Select;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-\r\n-/**\r\n- * Returns the Map.Entry<K,V> of a map value.\r\n- *\r\n- * @author Catalina Wei\r\n- * @since 2.0.0\r\n- */\r\n-public class MapEntry\r\n-    extends AbstractVal {\r\n-\r\n-    private final Val _key;\r\n-    private final Val _val;\r\n-    private ClassMetaData _meta = null;\r\n-    private Class _cast = null;\r\n-    private Class _type = null;\r\n-\r\n-    /**\r\n-     * Constructor. Provide the map value to operate on.\r\n-     */\r\n-    public MapEntry(Val key, Val val) {\r\n-        ((PCPath) key).getKey();\r\n-        _key = key;\r\n-        _val = val;\r\n-    }\r\n-\r\n-    /**\r\n-     * Expression state.\r\n-     */\r\n-    public static class EntryExpState\r\n-        extends ExpState {\r\n-        public ExpState key;\r\n-        public ExpState val;\r\n-    \r\n-        EntryExpState(ExpState key, ExpState val) {\r\n-            this.key = key;\r\n-            this.val = val;\r\n-        }\r\n-    }\r\n-\r\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state,\r\n-        SQLBuffer sql, int index) {\r\n-    }\r\n-\r\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state,\r\n-        Val other, ExpState otherState) {\r\n-        _val.calculateValue(sel, ctx, state, other, otherState);\r\n-        _key.calculateValue(sel, ctx, state, other, otherState);\r\n-    }\r\n-\r\n-    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\r\n-    }\r\n-\r\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\r\n-        ExpState val = _val.initialize(sel, ctx, flags);\r\n-        ExpState key = _key.initialize(sel, ctx, flags);\r\n-        return new EntryExpState(key, val);\r\n-    }\r\n-\r\n-    public int length(Select sel, ExpContext ctx, ExpState state) {\r\n-        return 1;\r\n-    }\r\n-\r\n-    public Object load(ExpContext ctx, ExpState state, Result res)\r\n-        throws SQLException {\r\n-        EntryExpState estate = (EntryExpState) state;\r\n-        Object key = _key.load(ctx, estate.key, res);\r\n-        Object val = _val.load(ctx, estate.val, res);\r\n-        if (key == null || val == null)\r\n-            return null;\r\n-        return new Entry(key, val);\r\n-    }\r\n-\r\n-    public void orderBy(Select sel, ExpContext ctx, ExpState state, boolean asc) {\r\n-    }\r\n-\r\n-    public void select(Select sel, ExpContext ctx, ExpState state, boolean pks) {\r\n-        selectColumns(sel, ctx, state, pks);\r\n-    }\r\n-\r\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state,\r\n-        boolean pks) {\r\n-        EntryExpState estate = (EntryExpState) state;\r\n-        _key.selectColumns(sel, ctx, estate.key, pks);\r\n-        _val.selectColumns(sel, ctx, estate.val, pks);\r\n-    }\r\n-\r\n-    public ClassMetaData getMetaData() {\r\n-        return _meta;\r\n-    }\r\n-\r\n-    public Class getType() {\r\n-        return Map.Entry.class;\r\n-    }\r\n-\r\n-    public void setImplicitType(Class type) {\r\n-    }\r\n-\r\n-    public void setMetaData(ClassMetaData meta) {\r\n-        _meta = meta;        \r\n-    }\r\n-\r\n-    private class Entry<K,V> implements Map.Entry<K, V> {\r\n-        private final K key;\r\n-        private final V value;\r\n-\r\n-        public Entry(K k, V v) {\r\n-            key = k;\r\n-            value = v;\r\n-        }\r\n-        public K getKey() {\r\n-            return key;\r\n-        }\r\n-\r\n-        public V getValue() {\r\n-            return value;\r\n-        }\r\n-\r\n-        public V setValue(V v) {\r\n-            throw new UnsupportedOperationException();\r\n-        }\r\n-\r\n-        public boolean equals(Object other) {\r\n-            if (other instanceof Map.Entry == false)\r\n-                return false;\r\n-            Map.Entry that = (Map.Entry)other;\r\n-            return (this.key == null ?\r\n-                that.getKey() == null : key.equals(that.getKey())) &&\r\n-                (value == null ?\r\n-                that.getValue() == null : value.equals(that.getValue()));\r\n-        }\r\n-\r\n-        public int hashCode() {\r\n-            return  (key == null   ? 0 : key.hashCode()) ^\r\n-            (value == null ? 0 : value.hashCode());\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.sql.SQLException;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Returns the Map.Entry<K,V> of a map value.\n+ *\n+ * @author Catalina Wei\n+ * @since 2.0.0\n+ */\n+public class MapEntry\n+    extends AbstractVal {\n+\n+    private final Val _key;\n+    private final Val _val;\n+    private ClassMetaData _meta = null;\n+    private Class _cast = null;\n+    private Class _type = null;\n+\n+    /**\n+     * Constructor. Provide the map value to operate on.\n+     */\n+    public MapEntry(Val key, Val val) {\n+        ((PCPath) key).getKey();\n+        _key = key;\n+        _val = val;\n+    }\n+\n+    /**\n+     * Expression state.\n+     */\n+    public static class EntryExpState\n+        extends ExpState {\n+        public ExpState key;\n+        public ExpState val;\n+    \n+        EntryExpState(ExpState key, ExpState val) {\n+            this.key = key;\n+            this.val = val;\n+        }\n+    }\n+\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state,\n+        SQLBuffer sql, int index) {\n+    }\n+\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state,\n+        Val other, ExpState otherState) {\n+        _val.calculateValue(sel, ctx, state, other, otherState);\n+        _key.calculateValue(sel, ctx, state, other, otherState);\n+    }\n+\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+    }\n+\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        ExpState val = _val.initialize(sel, ctx, flags);\n+        ExpState key = _key.initialize(sel, ctx, flags);\n+        return new EntryExpState(key, val);\n+    }\n+\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n+        return 1;\n+    }\n+\n+    public Object load(ExpContext ctx, ExpState state, Result res)\n+        throws SQLException {\n+        EntryExpState estate = (EntryExpState) state;\n+        Object key = _key.load(ctx, estate.key, res);\n+        Object val = _val.load(ctx, estate.val, res);\n+        if (key == null || val == null)\n+            return null;\n+        return new Entry(key, val);\n+    }\n+\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state, boolean asc) {\n+    }\n+\n+    public void select(Select sel, ExpContext ctx, ExpState state, boolean pks) {\n+        selectColumns(sel, ctx, state, pks);\n+    }\n+\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state,\n+        boolean pks) {\n+        EntryExpState estate = (EntryExpState) state;\n+        _key.selectColumns(sel, ctx, estate.key, pks);\n+        _val.selectColumns(sel, ctx, estate.val, pks);\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public Class getType() {\n+        return Map.Entry.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;        \n+    }\n+\n+    private class Entry<K,V> implements Map.Entry<K, V> {\n+        private final K key;\n+        private final V value;\n+\n+        public Entry(K k, V v) {\n+            key = k;\n+            value = v;\n+        }\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        public V getValue() {\n+            return value;\n+        }\n+\n+        public V setValue(V v) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean equals(Object other) {\n+            if (other instanceof Map.Entry == false)\n+                return false;\n+            Map.Entry that = (Map.Entry)other;\n+            return (this.key == null ?\n+                that.getKey() == null : key.equals(that.getKey())) &&\n+                (value == null ?\n+                that.getValue() == null : value.equals(that.getValue()));\n+        }\n+\n+        public int hashCode() {\n+            return  (key == null   ? 0 : key.hashCode()) ^\n+            (value == null ? 0 : value.hashCode());\n+        }\n+    }\n+}"},{"sha":"7568dcf0e2a30adcbc9e8de217ee848476fe2be3","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MapKey.java","status":"modified","additions":119,"deletions":119,"changes":238,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MapKey.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MapKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MapKey.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,119 +1,119 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.kernel.exps;\r\n-\r\n-import java.sql.SQLException;\r\n-\r\n-import org.apache.openjpa.jdbc.sql.Result;\r\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\r\n-import org.apache.openjpa.jdbc.sql.Select;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-\r\n-/**\r\n- * Returns the key of a map value.\r\n- *\r\n- * @author Catalina Wei\r\n- * @since 2.0.0\r\n- */\r\n-public class MapKey\r\n-    extends AbstractVal {\r\n-\r\n-    private final Val _key;\r\n-    private ClassMetaData _meta = null;\r\n-    private Class _cast = null;\r\n-    private Class _type = null;\r\n-\r\n-    /**\r\n-     * Constructor. Provide the map value to operate on.\r\n-     */\r\n-    public MapKey(Val key) {\r\n-        ((PCPath) key).getKey();\r\n-        _key = key;\r\n-    }\r\n-\r\n-    /**\r\n-     * Expression state.\r\n-     */\r\n-    public static class KeyExpState\r\n-        extends ExpState {\r\n-        public ExpState key;\r\n-        public ExpState val;\r\n-    \r\n-        KeyExpState(ExpState key) {\r\n-            this.key = key;\r\n-        }\r\n-    }\r\n-\r\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state,\r\n-        SQLBuffer sql, int index) {\r\n-    }\r\n-\r\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state,\r\n-        Val other, ExpState otherState) {\r\n-        _key.calculateValue(sel, ctx, state, other, otherState);\r\n-    }\r\n-\r\n-    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\r\n-    }\r\n-\r\n-    public void orderBy(Select sel, ExpContext ctx, ExpState state,\r\n-        boolean asc) {\r\n-    }\r\n-\r\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\r\n-        ExpState key = _key.initialize(sel, ctx, flags);\r\n-        return new KeyExpState(key);\r\n-    }\r\n-\r\n-    public int length(Select sel, ExpContext ctx, ExpState state) {\r\n-        return 1;\r\n-    }\r\n-\r\n-    public Object load(ExpContext ctx, ExpState state, Result res)\r\n-        throws SQLException {\r\n-        KeyExpState estate = (KeyExpState) state;\r\n-        Object key = _key.load(ctx, estate.key, res);\r\n-        return key;\r\n-    }\r\n-\r\n-    public void select(Select sel, ExpContext ctx, ExpState state, boolean pks) {\r\n-        selectColumns(sel, ctx, state, pks);\r\n-    }\r\n-\r\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state,\r\n-        boolean pks) {\r\n-        KeyExpState estate = (KeyExpState) state;\r\n-        _key.selectColumns(sel, ctx, estate.key, pks);\r\n-    }\r\n-\r\n-    public ClassMetaData getMetaData() {\r\n-        return _meta;\r\n-    }\r\n-\r\n-    public Class getType() {\r\n-        return Object.class;\r\n-    }\r\n-\r\n-    public void setImplicitType(Class type) {\r\n-    }\r\n-\r\n-    public void setMetaData(ClassMetaData meta) {\r\n-        _meta = meta;        \r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Returns the key of a map value.\n+ *\n+ * @author Catalina Wei\n+ * @since 2.0.0\n+ */\n+public class MapKey\n+    extends AbstractVal {\n+\n+    private final Val _key;\n+    private ClassMetaData _meta = null;\n+    private Class _cast = null;\n+    private Class _type = null;\n+\n+    /**\n+     * Constructor. Provide the map value to operate on.\n+     */\n+    public MapKey(Val key) {\n+        ((PCPath) key).getKey();\n+        _key = key;\n+    }\n+\n+    /**\n+     * Expression state.\n+     */\n+    public static class KeyExpState\n+        extends ExpState {\n+        public ExpState key;\n+        public ExpState val;\n+    \n+        KeyExpState(ExpState key) {\n+            this.key = key;\n+        }\n+    }\n+\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state,\n+        SQLBuffer sql, int index) {\n+    }\n+\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state,\n+        Val other, ExpState otherState) {\n+        _key.calculateValue(sel, ctx, state, other, otherState);\n+    }\n+\n+    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n+    }\n+\n+    public void orderBy(Select sel, ExpContext ctx, ExpState state,\n+        boolean asc) {\n+    }\n+\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        ExpState key = _key.initialize(sel, ctx, flags);\n+        return new KeyExpState(key);\n+    }\n+\n+    public int length(Select sel, ExpContext ctx, ExpState state) {\n+        return 1;\n+    }\n+\n+    public Object load(ExpContext ctx, ExpState state, Result res)\n+        throws SQLException {\n+        KeyExpState estate = (KeyExpState) state;\n+        Object key = _key.load(ctx, estate.key, res);\n+        return key;\n+    }\n+\n+    public void select(Select sel, ExpContext ctx, ExpState state, boolean pks) {\n+        selectColumns(sel, ctx, state, pks);\n+    }\n+\n+    public void selectColumns(Select sel, ExpContext ctx, ExpState state,\n+        boolean pks) {\n+        KeyExpState estate = (KeyExpState) state;\n+        _key.selectColumns(sel, ctx, estate.key, pks);\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public Class getType() {\n+        return Object.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;        \n+    }\n+}"},{"sha":"1f56b8cf27cec357a9b8aa2c168b8436408cc3db","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/TypeLit.java","status":"modified","additions":127,"deletions":127,"changes":254,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/TypeLit.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/TypeLit.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/TypeLit.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,127 +1,127 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.kernel.exps;\r\n-\r\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n-import org.apache.openjpa.jdbc.meta.Discriminator;\r\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\r\n-import org.apache.openjpa.jdbc.sql.Select;\r\n-import org.apache.openjpa.kernel.Filters;\r\n-import org.apache.openjpa.kernel.exps.Literal;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-\r\n-/**\r\n- * A type literal value.\r\n- *\r\n- * @author Catalina Wei\r\n- */\r\n-public class TypeLit\r\n-    extends Const\r\n-    implements Literal {\r\n-\r\n-    private Object _val;\r\n-    private int _ptype;\r\n-\r\n-    /**\r\n-     * Constructor. Supply literal value.\r\n-     */\r\n-    public TypeLit(Object val, int ptype) {\r\n-        _val = val;\r\n-        _ptype = ptype;\r\n-    }\r\n-\r\n-    public Class getType() {\r\n-        return (_val == null) ? Object.class : _val.getClass();\r\n-    }\r\n-\r\n-    public void setImplicitType(Class type) {\r\n-        _val = Filters.convert(_val, type);\r\n-    }\r\n-\r\n-    public int getParseType() {\r\n-        return _ptype;\r\n-    }\r\n-\r\n-    public Object getValue() { \r\n-        return _val;\r\n-    }\r\n-\r\n-    public void setValue(Object val) {\r\n-        _val = val;\r\n-    }\r\n-\r\n-    public Object getValue(Object[] params) {\r\n-        return getValue();\r\n-    }\r\n-\r\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\r\n-        return new LitExpState();\r\n-    }\r\n-\r\n-    /**\r\n-     * Expression state.\r\n-     */\r\n-    private static class LitExpState\r\n-        extends ConstExpState {\r\n-\r\n-        public Object sqlValue;\r\n-        public int otherLength; \r\n-        public ClassMapping mapping = null;\r\n-        public Discriminator disc = null;\r\n-        public Object discValue = null;\r\n-    } \r\n-\r\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \r\n-        Val other, ExpState otherState) {\r\n-        super.calculateValue(sel, ctx, state, other, otherState);\r\n-        LitExpState lstate = (LitExpState) state;\r\n-        lstate.mapping = (ClassMapping) getMetaData();\r\n-        lstate.disc = lstate.mapping.getDiscriminator();\r\n-        lstate.discValue = lstate.disc != null ? lstate.disc.getValue() :\r\n-            null;\r\n-        sel.select(((ClassMapping) getMetaData()).getPrimaryKeyColumns(),\r\n-            lstate.joins);\r\n-    }\r\n-\r\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \r\n-        SQLBuffer sql, int index) {\r\n-        LitExpState lstate = (LitExpState) state;\r\n-        if (lstate.otherLength > 1)\r\n-            sql.appendValue(((Object[]) lstate.sqlValue)[index], \r\n-                lstate.getColumn(index));\r\n-        else {\r\n-            if (lstate.discValue != null)                \r\n-                sql.append(getDiscriminator(lstate));\r\n-            else\r\n-                sql.append(\"1\");\r\n-        }\r\n-    }\r\n-\r\n-    private String getDiscriminator(LitExpState lstate) {\r\n-        StringBuffer disc = new StringBuffer(lstate.discValue.toString());\r\n-        switch(lstate.disc.getJavaType()) {\r\n-        case JavaTypes.INT:\r\n-            return disc.toString();\r\n-        case JavaTypes.CHAR:\r\n-        case JavaTypes.STRING:\r\n-        default:\r\n-            return disc.insert(0, \"'\").append(\"'\").toString();\r\n-        }        \r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.kernel.exps;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.Discriminator;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.exps.Literal;\n+import org.apache.openjpa.meta.JavaTypes;\n+\n+/**\n+ * A type literal value.\n+ *\n+ * @author Catalina Wei\n+ */\n+public class TypeLit\n+    extends Const\n+    implements Literal {\n+\n+    private Object _val;\n+    private int _ptype;\n+\n+    /**\n+     * Constructor. Supply literal value.\n+     */\n+    public TypeLit(Object val, int ptype) {\n+        _val = val;\n+        _ptype = ptype;\n+    }\n+\n+    public Class getType() {\n+        return (_val == null) ? Object.class : _val.getClass();\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _val = Filters.convert(_val, type);\n+    }\n+\n+    public int getParseType() {\n+        return _ptype;\n+    }\n+\n+    public Object getValue() { \n+        return _val;\n+    }\n+\n+    public void setValue(Object val) {\n+        _val = val;\n+    }\n+\n+    public Object getValue(Object[] params) {\n+        return getValue();\n+    }\n+\n+    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n+        return new LitExpState();\n+    }\n+\n+    /**\n+     * Expression state.\n+     */\n+    private static class LitExpState\n+        extends ConstExpState {\n+\n+        public Object sqlValue;\n+        public int otherLength; \n+        public ClassMapping mapping = null;\n+        public Discriminator disc = null;\n+        public Object discValue = null;\n+    } \n+\n+    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n+        Val other, ExpState otherState) {\n+        super.calculateValue(sel, ctx, state, other, otherState);\n+        LitExpState lstate = (LitExpState) state;\n+        lstate.mapping = (ClassMapping) getMetaData();\n+        lstate.disc = lstate.mapping.getDiscriminator();\n+        lstate.discValue = lstate.disc != null ? lstate.disc.getValue() :\n+            null;\n+        sel.select(((ClassMapping) getMetaData()).getPrimaryKeyColumns(),\n+            lstate.joins);\n+    }\n+\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n+        SQLBuffer sql, int index) {\n+        LitExpState lstate = (LitExpState) state;\n+        if (lstate.otherLength > 1)\n+            sql.appendValue(((Object[]) lstate.sqlValue)[index], \n+                lstate.getColumn(index));\n+        else {\n+            if (lstate.discValue != null)                \n+                sql.append(getDiscriminator(lstate));\n+            else\n+                sql.append(\"1\");\n+        }\n+    }\n+\n+    private String getDiscriminator(LitExpState lstate) {\n+        StringBuffer disc = new StringBuffer(lstate.discValue.toString());\n+        switch(lstate.disc.getJavaType()) {\n+        case JavaTypes.INT:\n+            return disc.toString();\n+        case JavaTypes.CHAR:\n+        case JavaTypes.STRING:\n+        default:\n+            return disc.insert(0, \"'\").append(\"'\").toString();\n+        }        \n+    }\n+}"},{"sha":"0559d61e68a53bf8b9035b949ec244ae7d28c8ee","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java","status":"modified","additions":183,"deletions":183,"changes":366,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,183 +1,183 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.lib.util.*;\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.util.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-\r\n-/**\r\n- * <p>Handler for embedded objects as elements of a collection or map.  For\r\n- * embedded objects as fields, use the more powerful\r\n- * {@link EmbedFieldStrategy}.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- * @nojavadoc\r\n- */\r\n-public class ElementEmbedValueHandler\r\n-    extends EmbedValueHandler\r\n-    implements RelationId {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (ElementEmbedValueHandler.class);\r\n-\r\n-    private ValueMapping _vm = null;\r\n-    private Column[] _cols = null;\r\n-    private Object[] _args = null;\r\n-    private int _nullIdx = -1;\r\n-    private boolean _synthetic = false;\r\n-\r\n-    public Column[] map(ValueMapping vm, String name, ColumnIO io,\r\n-        boolean adapt) {\r\n-        LinkedList cols = new LinkedList();\r\n-        LinkedList args = new LinkedList();\r\n-        super.map(vm, name, io, adapt, cols, args);\r\n-\r\n-        ValueMappingInfo vinfo = vm.getValueInfo();\r\n-        Column nullInd = vinfo.getNullIndicatorColumn(vm, name,\r\n-            vm.getFieldMapping().getTable(), adapt);\r\n-        if (nullInd != null)\r\n-            vm.setColumns(new Column[]{ nullInd });\r\n-\r\n-        // record index of null indicator column and whether it is synthetic\r\n-        if (nullInd != null) {\r\n-            _nullIdx = cols.indexOf(nullInd);\r\n-            if (_nullIdx == -1) {\r\n-                cols.addFirst(nullInd);\r\n-                args.addFirst(null);\r\n-                _nullIdx = 0;\r\n-                _synthetic = true;\r\n-            }\r\n-        }\r\n-\r\n-        _vm = vm;\r\n-        _cols = (Column[]) cols.toArray(new Column[cols.size()]);\r\n-        _args = args.toArray();\r\n-        return _cols;\r\n-    }\r\n-\r\n-    public boolean objectValueRequiresLoad(ValueMapping vm) {\r\n-        return true;\r\n-    }\r\n-\r\n-    public Object getResultArgument(ValueMapping vm) {\r\n-        return _args;\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(ValueMapping vm, Object val,\r\n-        JDBCStore store) {\r\n-        OpenJPAStateManager em = store.getContext().getStateManager(val);\r\n-        Object rval = null;\r\n-        if (_cols.length > 1)\r\n-            rval = new Object[_cols.length];\r\n-\r\n-        // set null indicator column\r\n-        int idx = 0;\r\n-        if (_synthetic) {\r\n-            Object cval = ((EmbeddedClassStrategy) vm.getEmbeddedMapping().\r\n-                getStrategy()).getNullIndicatorValue(em);\r\n-            if (_cols.length == 1)\r\n-                return cval;\r\n-            ((Object[]) rval)[idx++] = cval;\r\n-        }\r\n-\r\n-        return super.toDataStoreValue(em, vm, store, _cols, rval, idx);\r\n-    }\r\n-\r\n-    public Object toObjectValue(ValueMapping vm, Object val,\r\n-        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch)\r\n-        throws SQLException {\r\n-        if (sm == null)\r\n-            throw new InvalidStateException(_loc.get(\"cant-project-owned\",\r\n-                vm));\r\n-\r\n-        // check null indicator first\r\n-        if (_nullIdx != -1) {\r\n-            Object nval;\r\n-            if (_cols.length == 1)\r\n-                nval = val;\r\n-            else\r\n-                nval = ((Object[]) val)[_nullIdx];\r\n-            if (((EmbeddedClassStrategy) vm.getEmbeddedMapping().\r\n-                getStrategy()).indicatesNull(nval))\r\n-                return null;\r\n-        }\r\n-\r\n-        // create embedded instance\r\n-        OpenJPAStateManager em = store.getContext().embed(null, null, sm, vm);\r\n-        int idx = (_synthetic) ? 1 : 0;\r\n-        super.toObjectValue(em, vm, val, store, fetch, _cols, idx);\r\n-\r\n-        // after loading everything from result, load the rest of the\r\n-        // configured fields\r\n-        em.load(fetch);\r\n-        return em.getManagedInstance();\r\n-    }\r\n-\r\n-    /////////////////////////////\r\n-    // RelationId implementation\r\n-    /////////////////////////////\r\n-\r\n-    public Object toRelationDataStoreValue(OpenJPAStateManager sm, Column col) {\r\n-        return toRelationDataStoreValue(sm, col, 0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Recursive helper.\r\n-     */\r\n-    private Object toRelationDataStoreValue(OpenJPAStateManager sm, Column col,\r\n-        int idx) {\r\n-        FieldMapping field = findField(col, idx);\r\n-        if (field == null)\r\n-            throw new InternalException();\r\n-\r\n-        if (field.getHandler() instanceof RelationId)\r\n-            return ((RelationId) field.getStrategy()).\r\n-                toRelationDataStoreValue(sm, col);\r\n-        if (field.getStrategy() instanceof RelationId)\r\n-            return ((RelationId) field.getStrategy()).\r\n-                toRelationDataStoreValue(sm, col);\r\n-        return toRelationDataStoreValue(sm, col, field.getIndex() + 1);\r\n-    }\r\n-\r\n-    /**\r\n-     * Find the first field mapping that uses the given column starting with\r\n-     * the given field index.\r\n-     */\r\n-    private FieldMapping findField(Column col, int idx) {\r\n-        FieldMapping[] fms = _vm.getEmbeddedMapping().getFieldMappings();\r\n-        Column[] cols;\r\n-        for (int i = idx; i < fms.length; i++) {\r\n-            if (fms[i].getManagement() != FieldMapping.MANAGE_PERSISTENT)\r\n-                continue;\r\n-            cols = ((Embeddable) fms[i]).getColumns();\r\n-            for (int j = 0; j < cols.length; j++)\r\n-                if (cols[j] == col)\r\n-                    return fms[i];\r\n-        }\r\n-        return null;\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.util.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+\n+/**\n+ * <p>Handler for embedded objects as elements of a collection or map.  For\n+ * embedded objects as fields, use the more powerful\n+ * {@link EmbedFieldStrategy}.</p>\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ * @nojavadoc\n+ */\n+public class ElementEmbedValueHandler\n+    extends EmbedValueHandler\n+    implements RelationId {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ElementEmbedValueHandler.class);\n+\n+    private ValueMapping _vm = null;\n+    private Column[] _cols = null;\n+    private Object[] _args = null;\n+    private int _nullIdx = -1;\n+    private boolean _synthetic = false;\n+\n+    public Column[] map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt) {\n+        LinkedList cols = new LinkedList();\n+        LinkedList args = new LinkedList();\n+        super.map(vm, name, io, adapt, cols, args);\n+\n+        ValueMappingInfo vinfo = vm.getValueInfo();\n+        Column nullInd = vinfo.getNullIndicatorColumn(vm, name,\n+            vm.getFieldMapping().getTable(), adapt);\n+        if (nullInd != null)\n+            vm.setColumns(new Column[]{ nullInd });\n+\n+        // record index of null indicator column and whether it is synthetic\n+        if (nullInd != null) {\n+            _nullIdx = cols.indexOf(nullInd);\n+            if (_nullIdx == -1) {\n+                cols.addFirst(nullInd);\n+                args.addFirst(null);\n+                _nullIdx = 0;\n+                _synthetic = true;\n+            }\n+        }\n+\n+        _vm = vm;\n+        _cols = (Column[]) cols.toArray(new Column[cols.size()]);\n+        _args = args.toArray();\n+        return _cols;\n+    }\n+\n+    public boolean objectValueRequiresLoad(ValueMapping vm) {\n+        return true;\n+    }\n+\n+    public Object getResultArgument(ValueMapping vm) {\n+        return _args;\n+    }\n+\n+    public Object toDataStoreValue(ValueMapping vm, Object val,\n+        JDBCStore store) {\n+        OpenJPAStateManager em = store.getContext().getStateManager(val);\n+        Object rval = null;\n+        if (_cols.length > 1)\n+            rval = new Object[_cols.length];\n+\n+        // set null indicator column\n+        int idx = 0;\n+        if (_synthetic) {\n+            Object cval = ((EmbeddedClassStrategy) vm.getEmbeddedMapping().\n+                getStrategy()).getNullIndicatorValue(em);\n+            if (_cols.length == 1)\n+                return cval;\n+            ((Object[]) rval)[idx++] = cval;\n+        }\n+\n+        return super.toDataStoreValue(em, vm, store, _cols, rval, idx);\n+    }\n+\n+    public Object toObjectValue(ValueMapping vm, Object val,\n+        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch)\n+        throws SQLException {\n+        if (sm == null)\n+            throw new InvalidStateException(_loc.get(\"cant-project-owned\",\n+                vm));\n+\n+        // check null indicator first\n+        if (_nullIdx != -1) {\n+            Object nval;\n+            if (_cols.length == 1)\n+                nval = val;\n+            else\n+                nval = ((Object[]) val)[_nullIdx];\n+            if (((EmbeddedClassStrategy) vm.getEmbeddedMapping().\n+                getStrategy()).indicatesNull(nval))\n+                return null;\n+        }\n+\n+        // create embedded instance\n+        OpenJPAStateManager em = store.getContext().embed(null, null, sm, vm);\n+        int idx = (_synthetic) ? 1 : 0;\n+        super.toObjectValue(em, vm, val, store, fetch, _cols, idx);\n+\n+        // after loading everything from result, load the rest of the\n+        // configured fields\n+        em.load(fetch);\n+        return em.getManagedInstance();\n+    }\n+\n+    /////////////////////////////\n+    // RelationId implementation\n+    /////////////////////////////\n+\n+    public Object toRelationDataStoreValue(OpenJPAStateManager sm, Column col) {\n+        return toRelationDataStoreValue(sm, col, 0);\n+    }\n+\n+    /**\n+     * Recursive helper.\n+     */\n+    private Object toRelationDataStoreValue(OpenJPAStateManager sm, Column col,\n+        int idx) {\n+        FieldMapping field = findField(col, idx);\n+        if (field == null)\n+            throw new InternalException();\n+\n+        if (field.getHandler() instanceof RelationId)\n+            return ((RelationId) field.getStrategy()).\n+                toRelationDataStoreValue(sm, col);\n+        if (field.getStrategy() instanceof RelationId)\n+            return ((RelationId) field.getStrategy()).\n+                toRelationDataStoreValue(sm, col);\n+        return toRelationDataStoreValue(sm, col, field.getIndex() + 1);\n+    }\n+\n+    /**\n+     * Find the first field mapping that uses the given column starting with\n+     * the given field index.\n+     */\n+    private FieldMapping findField(Column col, int idx) {\n+        FieldMapping[] fms = _vm.getEmbeddedMapping().getFieldMappings();\n+        Column[] cols;\n+        for (int i = idx; i < fms.length; i++) {\n+            if (fms[i].getManagement() != FieldMapping.MANAGE_PERSISTENT)\n+                continue;\n+            cols = ((Embeddable) fms[i]).getColumns();\n+            for (int j = 0; j < cols.length; j++)\n+                if (cols[j] == col)\n+                    return fms[i];\n+        }\n+        return null;\n+\t}\n+}"},{"sha":"afaf3b68b227d67941d5b2bc9a21107f740b4464","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java","status":"modified","additions":250,"deletions":250,"changes":500,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,250 +1,250 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.lib.util.*;\r\n-\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.util.*;\r\n-import org.apache.openjpa.meta.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-import org.apache.openjpa.jdbc.sql.*;\r\n-\r\n-/**\r\n- * <p>Mapping for a collection of values in a separate table controlled by a\r\n- * {@link ValueHandler}.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- */\r\n-public class HandlerCollectionTableFieldStrategy\r\n-    extends StoreCollectionFieldStrategy\r\n-    implements LRSCollectionFieldStrategy {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (HandlerCollectionTableFieldStrategy.class);\r\n-\r\n-    private Column[] _cols = null;\r\n-    private ColumnIO _io = null;\r\n-    private boolean _load = false;\r\n-    private boolean _lob = false;\r\n-    private boolean _embed = false;\r\n-\r\n-    public FieldMapping getFieldMapping() {\r\n-        return field;\r\n-    }\r\n-\r\n-    public ClassMapping[] getIndependentElementMappings(boolean traverse) {\r\n-        return ClassMapping.EMPTY_MAPPINGS;\r\n-    }\r\n-\r\n-    public Column[] getElementColumns(ClassMapping elem) {\r\n-        return _cols;\r\n-    }\r\n-\r\n-    public ForeignKey getJoinForeignKey(ClassMapping elem) {\r\n-        return field.getJoinForeignKey();\r\n-    }\r\n-\r\n-    public void selectElement(Select sel, ClassMapping elem, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, int eagerMode, Joins joins) {\r\n-        sel.select(_cols, joins);\r\n-    }\r\n-\r\n-    public Object loadElement(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        return HandlerStrategies.loadObject(field.getElementMapping(),\r\n-            sm, store, fetch, res, joins, _cols, _load);\r\n-    }\r\n-\r\n-    protected Joins join(Joins joins, ClassMapping elem) {\r\n-        return join(joins, false);\r\n-    }\r\n-\r\n-    public Joins joinElementRelation(Joins joins, ClassMapping elem) {\r\n-        return joinRelation(joins, false, false);\r\n-    }\r\n-\r\n-    protected Proxy newLRSProxy() {\r\n-        return new LRSProxyCollection(this);\r\n-    }\r\n-\r\n-    public void map(boolean adapt) {\r\n-        if (field.getTypeCode() != JavaTypes.COLLECTION\r\n-            && field.getTypeCode() != JavaTypes.ARRAY)\r\n-            throw new MetaDataException(_loc.get(\"not-coll\", field));\r\n-\r\n-        assertNotMappedBy();\r\n-        field.getValueInfo().assertNoSchemaComponents(field, !adapt);\r\n-        field.getKeyMapping().getValueInfo().assertNoSchemaComponents\r\n-            (field.getKey(), !adapt);\r\n-\r\n-        ValueMapping elem = field.getElementMapping();\r\n-        if (elem.getHandler() == null)\r\n-            throw new MetaDataException(_loc.get(\"no-handler\", elem));\r\n-\r\n-        field.mapJoin(adapt, true);\r\n-        _io = new ColumnIO();\r\n-        _cols = HandlerStrategies.map(elem, \"element\", _io, adapt);\r\n-\r\n-        FieldMappingInfo finfo = field.getMappingInfo();\r\n-        Column orderCol = finfo.getOrderColumn(field, field.getTable(), adapt);\r\n-        field.setOrderColumn(orderCol);\r\n-        field.setOrderColumnIO(finfo.getColumnIO());\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    public void initialize() {\r\n-        for (int i = 0; !_lob && i < _cols.length; i++)\r\n-            _lob = _cols[i].isLob();\r\n-\r\n-        ValueMapping elem = field.getElementMapping();\r\n-        _embed = elem.getEmbeddedMetaData() != null;\r\n-        _load = elem.getHandler().objectValueRequiresLoad(elem);\r\n-    }\r\n-\r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        insert(sm, store, rm, sm.fetchObject(field.getIndex()));\r\n-    }\r\n-\r\n-    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\r\n-        Object vals)\r\n-        throws SQLException {\r\n-        Collection coll;\r\n-        if (field.getTypeCode() == JavaTypes.ARRAY)\r\n-            coll = JavaTypes.toList(vals, field.getElement().getType(),\r\n-                false);\r\n-        else\r\n-            coll = (Collection) vals;\r\n-        if (coll == null || coll.isEmpty())\r\n-            return;\r\n-\r\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\r\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\r\n-            sm);\r\n-\r\n-        ValueMapping elem = field.getElementMapping();\r\n-        Column order = field.getOrderColumn();\r\n-        boolean setOrder = field.getOrderColumnIO().isInsertable(order, false);        \r\n-        int idx = (setOrder && order != null) ? order.getBase() : 0;\r\n-        for (Iterator itr = coll.iterator(); itr.hasNext(); idx++) {\r\n-            HandlerStrategies.set(elem, itr.next(), store, row, _cols,\r\n-                _io, true);\r\n-            if (setOrder)\r\n-                row.setInt(order, idx);\r\n-            rm.flushSecondaryRow(row);\r\n-        }\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Object obj = sm.fetchObject(field.getIndex());\r\n-        ChangeTracker ct = null;\r\n-        if (obj instanceof Proxy) {\r\n-            Proxy proxy = (Proxy) obj;\r\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\r\n-                ct = proxy.getChangeTracker();\r\n-        }\r\n-\r\n-        // if no fine-grained change tracking then just delete and reinsert\r\n-        if (ct == null || !ct.isTracking()) {\r\n-            delete(sm, store, rm);\r\n-            insert(sm, store, rm, obj);\r\n-            return;\r\n-        }\r\n-\r\n-        // delete the removes\r\n-        ValueMapping elem = field.getElementMapping();\r\n-        Collection rem = ct.getRemoved();\r\n-        if (!rem.isEmpty()) {\r\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_DELETE);\r\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\r\n-                HandlerStrategies.where(elem, itr.next(), store, delRow,\r\n-                    _cols);\r\n-                rm.flushSecondaryRow(delRow);\r\n-            }\r\n-        }\r\n-\r\n-        // insert the adds\r\n-        Collection add = ct.getAdded();\r\n-        if (!add.isEmpty()) {\r\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_INSERT);\r\n-            addRow.setForeignKey(field.getJoinForeignKey(),\r\n-                field.getJoinColumnIO(), sm);\r\n-\r\n-            int seq = ct.getNextSequence();\r\n-            Column order = field.getOrderColumn();\r\n-            boolean setOrder = field.getOrderColumnIO().isInsertable(order,\r\n-                false);\r\n-            for (Iterator itr = add.iterator(); itr.hasNext(); seq++) {\r\n-                HandlerStrategies.set(elem, itr.next(), store, addRow, _cols,\r\n-                    _io, true);\r\n-                if (setOrder)\r\n-                    addRow.setInt(order, seq);\r\n-                rm.flushSecondaryRow(addRow);\r\n-            }\r\n-            if (order != null)\r\n-                ct.setNextSequence(seq);\r\n-        }\r\n-    }\r\n-\r\n-    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Row row = rm.getAllRows(field.getTable(), Row.ACTION_DELETE);\r\n-        row.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-        rm.flushAllRows(row);\r\n-    }\r\n-\r\n-    public int supportsSelect(Select sel, int type, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch) {\r\n-        // can't do any combined select with lobs, since they don't allow\r\n-        // select distinct.  cant select eager parallel on embedded, because\r\n-        // during parallel result processing the owning sm won't be available\r\n-        // for each elem\r\n-        if (_lob || (_embed && type == Select.EAGER_PARALLEL))\r\n-            return 0;\r\n-        return super.supportsSelect(sel, type, sm, store, fetch);\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\r\n-        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\r\n-            val, _cols, store);\r\n-    }\r\n-\r\n-    public Joins join(Joins joins, boolean forceOuter) {\r\n-        return field.join(joins, forceOuter, true);\r\n-    }\r\n-\r\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        if (traverse)\r\n-            HandlerStrategies.assertJoinable(field.getElementMapping());\r\n-        return joins;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.util.*;\n+import org.apache.openjpa.meta.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.*;\n+\n+/**\n+ * <p>Mapping for a collection of values in a separate table controlled by a\n+ * {@link ValueHandler}.</p>\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ */\n+public class HandlerCollectionTableFieldStrategy\n+    extends StoreCollectionFieldStrategy\n+    implements LRSCollectionFieldStrategy {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (HandlerCollectionTableFieldStrategy.class);\n+\n+    private Column[] _cols = null;\n+    private ColumnIO _io = null;\n+    private boolean _load = false;\n+    private boolean _lob = false;\n+    private boolean _embed = false;\n+\n+    public FieldMapping getFieldMapping() {\n+        return field;\n+    }\n+\n+    public ClassMapping[] getIndependentElementMappings(boolean traverse) {\n+        return ClassMapping.EMPTY_MAPPINGS;\n+    }\n+\n+    public Column[] getElementColumns(ClassMapping elem) {\n+        return _cols;\n+    }\n+\n+    public ForeignKey getJoinForeignKey(ClassMapping elem) {\n+        return field.getJoinForeignKey();\n+    }\n+\n+    public void selectElement(Select sel, ClassMapping elem, JDBCStore store,\n+        JDBCFetchConfiguration fetch, int eagerMode, Joins joins) {\n+        sel.select(_cols, joins);\n+    }\n+\n+    public Object loadElement(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        return HandlerStrategies.loadObject(field.getElementMapping(),\n+            sm, store, fetch, res, joins, _cols, _load);\n+    }\n+\n+    protected Joins join(Joins joins, ClassMapping elem) {\n+        return join(joins, false);\n+    }\n+\n+    public Joins joinElementRelation(Joins joins, ClassMapping elem) {\n+        return joinRelation(joins, false, false);\n+    }\n+\n+    protected Proxy newLRSProxy() {\n+        return new LRSProxyCollection(this);\n+    }\n+\n+    public void map(boolean adapt) {\n+        if (field.getTypeCode() != JavaTypes.COLLECTION\n+            && field.getTypeCode() != JavaTypes.ARRAY)\n+            throw new MetaDataException(_loc.get(\"not-coll\", field));\n+\n+        assertNotMappedBy();\n+        field.getValueInfo().assertNoSchemaComponents(field, !adapt);\n+        field.getKeyMapping().getValueInfo().assertNoSchemaComponents\n+            (field.getKey(), !adapt);\n+\n+        ValueMapping elem = field.getElementMapping();\n+        if (elem.getHandler() == null)\n+            throw new MetaDataException(_loc.get(\"no-handler\", elem));\n+\n+        field.mapJoin(adapt, true);\n+        _io = new ColumnIO();\n+        _cols = HandlerStrategies.map(elem, \"element\", _io, adapt);\n+\n+        FieldMappingInfo finfo = field.getMappingInfo();\n+        Column orderCol = finfo.getOrderColumn(field, field.getTable(), adapt);\n+        field.setOrderColumn(orderCol);\n+        field.setOrderColumnIO(finfo.getColumnIO());\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    public void initialize() {\n+        for (int i = 0; !_lob && i < _cols.length; i++)\n+            _lob = _cols[i].isLob();\n+\n+        ValueMapping elem = field.getElementMapping();\n+        _embed = elem.getEmbeddedMetaData() != null;\n+        _load = elem.getHandler().objectValueRequiresLoad(elem);\n+    }\n+\n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        insert(sm, store, rm, sm.fetchObject(field.getIndex()));\n+    }\n+\n+    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n+        Object vals)\n+        throws SQLException {\n+        Collection coll;\n+        if (field.getTypeCode() == JavaTypes.ARRAY)\n+            coll = JavaTypes.toList(vals, field.getElement().getType(),\n+                false);\n+        else\n+            coll = (Collection) vals;\n+        if (coll == null || coll.isEmpty())\n+            return;\n+\n+        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+            sm);\n+\n+        ValueMapping elem = field.getElementMapping();\n+        Column order = field.getOrderColumn();\n+        boolean setOrder = field.getOrderColumnIO().isInsertable(order, false);        \n+        int idx = (setOrder && order != null) ? order.getBase() : 0;\n+        for (Iterator itr = coll.iterator(); itr.hasNext(); idx++) {\n+            HandlerStrategies.set(elem, itr.next(), store, row, _cols,\n+                _io, true);\n+            if (setOrder)\n+                row.setInt(order, idx);\n+            rm.flushSecondaryRow(row);\n+        }\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Object obj = sm.fetchObject(field.getIndex());\n+        ChangeTracker ct = null;\n+        if (obj instanceof Proxy) {\n+            Proxy proxy = (Proxy) obj;\n+            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n+                ct = proxy.getChangeTracker();\n+        }\n+\n+        // if no fine-grained change tracking then just delete and reinsert\n+        if (ct == null || !ct.isTracking()) {\n+            delete(sm, store, rm);\n+            insert(sm, store, rm, obj);\n+            return;\n+        }\n+\n+        // delete the removes\n+        ValueMapping elem = field.getElementMapping();\n+        Collection rem = ct.getRemoved();\n+        if (!rem.isEmpty()) {\n+            Row delRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_DELETE);\n+            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+                HandlerStrategies.where(elem, itr.next(), store, delRow,\n+                    _cols);\n+                rm.flushSecondaryRow(delRow);\n+            }\n+        }\n+\n+        // insert the adds\n+        Collection add = ct.getAdded();\n+        if (!add.isEmpty()) {\n+            Row addRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_INSERT);\n+            addRow.setForeignKey(field.getJoinForeignKey(),\n+                field.getJoinColumnIO(), sm);\n+\n+            int seq = ct.getNextSequence();\n+            Column order = field.getOrderColumn();\n+            boolean setOrder = field.getOrderColumnIO().isInsertable(order,\n+                false);\n+            for (Iterator itr = add.iterator(); itr.hasNext(); seq++) {\n+                HandlerStrategies.set(elem, itr.next(), store, addRow, _cols,\n+                    _io, true);\n+                if (setOrder)\n+                    addRow.setInt(order, seq);\n+                rm.flushSecondaryRow(addRow);\n+            }\n+            if (order != null)\n+                ct.setNextSequence(seq);\n+        }\n+    }\n+\n+    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Row row = rm.getAllRows(field.getTable(), Row.ACTION_DELETE);\n+        row.whereForeignKey(field.getJoinForeignKey(), sm);\n+        rm.flushAllRows(row);\n+    }\n+\n+    public int supportsSelect(Select sel, int type, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch) {\n+        // can't do any combined select with lobs, since they don't allow\n+        // select distinct.  cant select eager parallel on embedded, because\n+        // during parallel result processing the owning sm won't be available\n+        // for each elem\n+        if (_lob || (_embed && type == Select.EAGER_PARALLEL))\n+            return 0;\n+        return super.supportsSelect(sel, type, sm, store, fetch);\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\n+            val, _cols, store);\n+    }\n+\n+    public Joins join(Joins joins, boolean forceOuter) {\n+        return field.join(joins, forceOuter, true);\n+    }\n+\n+    public Joins joinRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        if (traverse)\n+            HandlerStrategies.assertJoinable(field.getElementMapping());\n+        return joins;\n+    }\n+}"},{"sha":"6e64da60b6e4f8615b1dd54b866b673464cddd7f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","status":"modified","additions":251,"deletions":251,"changes":502,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,251 +1,251 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-import org.apache.openjpa.jdbc.sql.*;\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.lib.util.*;\r\n-import org.apache.openjpa.util.*;\r\n-\r\n-/**\r\n- * Mapping for a map of keys and values both controlled by\r\n- * {@link ValueHandler}s.\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- */\r\n-public class HandlerHandlerMapTableFieldStrategy\r\n-    extends MapTableFieldStrategy {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (HandlerHandlerMapTableFieldStrategy.class);\r\n-\r\n-    private Column[] _kcols = null;\r\n-    private ColumnIO _kio = null;\r\n-    private boolean _kload = false;\r\n-    private Column[] _vcols = null;\r\n-    private ColumnIO _vio = null;\r\n-    private boolean _vload = false;\r\n-\r\n-    public Column[] getKeyColumns(ClassMapping cls) {\r\n-        return _kcols;\r\n-    }\r\n-\r\n-    public Column[] getValueColumns(ClassMapping cls) {\r\n-        return _vcols;\r\n-    }\r\n-\r\n-    public void selectKey(Select sel, ClassMapping cls, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\r\n-        sel.select(_kcols, joins);\r\n-    }\r\n-\r\n-    public void selectValue(Select sel, ClassMapping cls,\r\n-        OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\r\n-        sel.select(_vcols, joins);\r\n-    }\r\n-\r\n-    public Result[] getResults(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, int eagerMode, Joins[] joins, boolean lrs)\r\n-        throws SQLException {\r\n-        Select sel = store.getSQLFactory().newSelect();\r\n-        sel.setLRS(lrs);\r\n-        sel.select(_kcols);\r\n-        sel.select(_vcols);\r\n-        sel.whereForeignKey(field.getJoinForeignKey(), sm.getObjectId(),\r\n-            field.getDefiningMapping(), store);\r\n-        Result res = sel.execute(store, fetch);\r\n-        return new Result[]{ res, res };\r\n-    }\r\n-\r\n-    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        return HandlerStrategies.loadObject(field.getKeyMapping(),\r\n-            sm, store, fetch, res, joins, _kcols, _kload);\r\n-    }\r\n-\r\n-    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        return HandlerStrategies.loadObject(field.getElementMapping(),\r\n-            sm, store, fetch, res, joins, _vcols, _vload);\r\n-    }\r\n-\r\n-    public void map(boolean adapt) {\r\n-        super.map(adapt);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        if (key.getHandler() == null)\r\n-            throw new MetaDataException(_loc.get(\"no-handler\", key));\r\n-        ValueMapping val = field.getElementMapping();\r\n-        if (val.getHandler() == null)\r\n-            throw new MetaDataException(_loc.get(\"no-handler\", val));\r\n-        assertNotMappedBy();\r\n-\r\n-        field.mapJoin(adapt, true);\r\n-        _kio = new ColumnIO();\r\n-        List columns = key.getValueInfo().getColumns(); \r\n-        if (columns != null && columns.size() > 0) {\r\n-            // MapKeyColumn is used\r\n-            _kcols = HandlerStrategies.map(key, \"key\", _kio, adapt);\r\n-        } else {\r\n-            DBDictionary dict = field.getMappingRepository().getDBDictionary();\r\n-            _kcols = HandlerStrategies.map(key, \r\n-                    dict.getValidColumnName(\"key\", field.getTable()), _kio, adapt);\r\n-        }\r\n-        _vio = new ColumnIO();\r\n-        _vcols = HandlerStrategies.map(val, \"value\", _vio, adapt);\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    public void initialize() {\r\n-        _kload = field.getKeyMapping().getHandler().\r\n-            objectValueRequiresLoad(field.getKeyMapping());\r\n-        _vload = field.getElementMapping().getHandler().\r\n-            objectValueRequiresLoad(field.getElementMapping());\r\n-    }\r\n-\r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\r\n-    }\r\n-\r\n-    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\r\n-        Map map)\r\n-        throws SQLException {\r\n-        if (map == null || map.isEmpty())\r\n-            return;\r\n-\r\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\r\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\r\n-            sm);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ValueMapping val = field.getElementMapping();\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            HandlerStrategies.set(key, entry.getKey(), store, row, _kcols,\r\n-                _kio, true);\r\n-            HandlerStrategies.set(val, entry.getValue(), store, row, _vcols,\r\n-                _vio, true);\r\n-            rm.flushSecondaryRow(row);\r\n-        }\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Map map = (Map) sm.fetchObject(field.getIndex());\r\n-        ChangeTracker ct = null;\r\n-        if (map instanceof Proxy) {\r\n-            Proxy proxy = (Proxy) map;\r\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\r\n-                ct = proxy.getChangeTracker();\r\n-        }\r\n-\r\n-        // if no fine-grained change tracking then just delete and reinsert\r\n-        if (ct == null || !ct.isTracking()) {\r\n-            delete(sm, store, rm);\r\n-            insert(sm, store, rm, map);\r\n-            return;\r\n-        }\r\n-\r\n-        // delete the removes\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        Collection rem = ct.getRemoved();\r\n-        if (!rem.isEmpty()) {\r\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_DELETE);\r\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\r\n-                HandlerStrategies.where(key, itr.next(), store, delRow,\r\n-                    _kcols);\r\n-                rm.flushSecondaryRow(delRow);\r\n-            }\r\n-        }\r\n-\r\n-        // insert the adds\r\n-        ValueMapping val = field.getElementMapping();\r\n-        Collection add = ct.getAdded();\r\n-        Object mkey;\r\n-        if (!add.isEmpty()) {\r\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_INSERT);\r\n-            addRow.setForeignKey(field.getJoinForeignKey(),\r\n-                field.getJoinColumnIO(), sm);\r\n-\r\n-            for (Iterator itr = add.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                HandlerStrategies.set(key, mkey, store, addRow, _kcols,\r\n-                    _kio, true);\r\n-                HandlerStrategies.set(val, map.get(mkey), store, addRow,\r\n-                    _vcols, _vio, true);\r\n-                rm.flushSecondaryRow(addRow);\r\n-            }\r\n-        }\r\n-\r\n-        // update the changes\r\n-        Collection change = ct.getChanged();\r\n-        if (!change.isEmpty()) {\r\n-            Row changeRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_UPDATE);\r\n-            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                HandlerStrategies.where(key, mkey, store, changeRow, _kcols);\r\n-                HandlerStrategies.set(val, map.get(mkey), store, changeRow,\r\n-                    _vcols, _vio, true);\r\n-                rm.flushSecondaryRow(changeRow);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\r\n-        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\r\n-            val, _vcols, store);\r\n-    }\r\n-\r\n-    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\r\n-        return HandlerStrategies.toDataStoreValue(field.getKeyMapping(), val,\r\n-            _kcols, store);\r\n-    }\r\n-\r\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        if (traverse)\r\n-            HandlerStrategies.assertJoinable(field.getElementMapping());\r\n-        return joins;\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        if (traverse)\r\n-            HandlerStrategies.assertJoinable(field.getKeyMapping());\r\n-        return joins;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.*;\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.util.*;\n+\n+/**\n+ * Mapping for a map of keys and values both controlled by\n+ * {@link ValueHandler}s.\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ */\n+public class HandlerHandlerMapTableFieldStrategy\n+    extends MapTableFieldStrategy {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (HandlerHandlerMapTableFieldStrategy.class);\n+\n+    private Column[] _kcols = null;\n+    private ColumnIO _kio = null;\n+    private boolean _kload = false;\n+    private Column[] _vcols = null;\n+    private ColumnIO _vio = null;\n+    private boolean _vload = false;\n+\n+    public Column[] getKeyColumns(ClassMapping cls) {\n+        return _kcols;\n+    }\n+\n+    public Column[] getValueColumns(ClassMapping cls) {\n+        return _vcols;\n+    }\n+\n+    public void selectKey(Select sel, ClassMapping cls, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+        sel.select(_kcols, joins);\n+    }\n+\n+    public void selectValue(Select sel, ClassMapping cls,\n+        OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+        sel.select(_vcols, joins);\n+    }\n+\n+    public Result[] getResults(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, int eagerMode, Joins[] joins, boolean lrs)\n+        throws SQLException {\n+        Select sel = store.getSQLFactory().newSelect();\n+        sel.setLRS(lrs);\n+        sel.select(_kcols);\n+        sel.select(_vcols);\n+        sel.whereForeignKey(field.getJoinForeignKey(), sm.getObjectId(),\n+            field.getDefiningMapping(), store);\n+        Result res = sel.execute(store, fetch);\n+        return new Result[]{ res, res };\n+    }\n+\n+    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        return HandlerStrategies.loadObject(field.getKeyMapping(),\n+            sm, store, fetch, res, joins, _kcols, _kload);\n+    }\n+\n+    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        return HandlerStrategies.loadObject(field.getElementMapping(),\n+            sm, store, fetch, res, joins, _vcols, _vload);\n+    }\n+\n+    public void map(boolean adapt) {\n+        super.map(adapt);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        if (key.getHandler() == null)\n+            throw new MetaDataException(_loc.get(\"no-handler\", key));\n+        ValueMapping val = field.getElementMapping();\n+        if (val.getHandler() == null)\n+            throw new MetaDataException(_loc.get(\"no-handler\", val));\n+        assertNotMappedBy();\n+\n+        field.mapJoin(adapt, true);\n+        _kio = new ColumnIO();\n+        List columns = key.getValueInfo().getColumns(); \n+        if (columns != null && columns.size() > 0) {\n+            // MapKeyColumn is used\n+            _kcols = HandlerStrategies.map(key, \"key\", _kio, adapt);\n+        } else {\n+            DBDictionary dict = field.getMappingRepository().getDBDictionary();\n+            _kcols = HandlerStrategies.map(key, \n+                    dict.getValidColumnName(\"key\", field.getTable()), _kio, adapt);\n+        }\n+        _vio = new ColumnIO();\n+        _vcols = HandlerStrategies.map(val, \"value\", _vio, adapt);\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    public void initialize() {\n+        _kload = field.getKeyMapping().getHandler().\n+            objectValueRequiresLoad(field.getKeyMapping());\n+        _vload = field.getElementMapping().getHandler().\n+            objectValueRequiresLoad(field.getElementMapping());\n+    }\n+\n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\n+    }\n+\n+    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n+        Map map)\n+        throws SQLException {\n+        if (map == null || map.isEmpty())\n+            return;\n+\n+        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+            sm);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        Map.Entry entry;\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            HandlerStrategies.set(key, entry.getKey(), store, row, _kcols,\n+                _kio, true);\n+            HandlerStrategies.set(val, entry.getValue(), store, row, _vcols,\n+                _vio, true);\n+            rm.flushSecondaryRow(row);\n+        }\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Map map = (Map) sm.fetchObject(field.getIndex());\n+        ChangeTracker ct = null;\n+        if (map instanceof Proxy) {\n+            Proxy proxy = (Proxy) map;\n+            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n+                ct = proxy.getChangeTracker();\n+        }\n+\n+        // if no fine-grained change tracking then just delete and reinsert\n+        if (ct == null || !ct.isTracking()) {\n+            delete(sm, store, rm);\n+            insert(sm, store, rm, map);\n+            return;\n+        }\n+\n+        // delete the removes\n+        ValueMapping key = field.getKeyMapping();\n+        Collection rem = ct.getRemoved();\n+        if (!rem.isEmpty()) {\n+            Row delRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_DELETE);\n+            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+                HandlerStrategies.where(key, itr.next(), store, delRow,\n+                    _kcols);\n+                rm.flushSecondaryRow(delRow);\n+            }\n+        }\n+\n+        // insert the adds\n+        ValueMapping val = field.getElementMapping();\n+        Collection add = ct.getAdded();\n+        Object mkey;\n+        if (!add.isEmpty()) {\n+            Row addRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_INSERT);\n+            addRow.setForeignKey(field.getJoinForeignKey(),\n+                field.getJoinColumnIO(), sm);\n+\n+            for (Iterator itr = add.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                HandlerStrategies.set(key, mkey, store, addRow, _kcols,\n+                    _kio, true);\n+                HandlerStrategies.set(val, map.get(mkey), store, addRow,\n+                    _vcols, _vio, true);\n+                rm.flushSecondaryRow(addRow);\n+            }\n+        }\n+\n+        // update the changes\n+        Collection change = ct.getChanged();\n+        if (!change.isEmpty()) {\n+            Row changeRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_UPDATE);\n+            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                HandlerStrategies.where(key, mkey, store, changeRow, _kcols);\n+                HandlerStrategies.set(val, map.get(mkey), store, changeRow,\n+                    _vcols, _vio, true);\n+                rm.flushSecondaryRow(changeRow);\n+            }\n+        }\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\n+            val, _vcols, store);\n+    }\n+\n+    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n+        return HandlerStrategies.toDataStoreValue(field.getKeyMapping(), val,\n+            _kcols, store);\n+    }\n+\n+    public Joins joinRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        if (traverse)\n+            HandlerStrategies.assertJoinable(field.getElementMapping());\n+        return joins;\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        if (traverse)\n+            HandlerStrategies.assertJoinable(field.getKeyMapping());\n+        return joins;\n+    }\n+}"},{"sha":"c3b1b114e11d5021c1854d4595aa91aa74951698","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","status":"modified","additions":360,"deletions":360,"changes":720,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,360 +1,360 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.lib.util.*;\r\n-import org.apache.openjpa.meta.*;\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.util.*;\r\n-import org.apache.openjpa.enhance.PersistenceCapable;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-import org.apache.openjpa.jdbc.sql.*;\r\n-\r\n-/**\r\n- * <p>Mapping for a map whose keys are controlled by a {@link ValueHandler}\r\n- * and whose values are relations to other persistent objects.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- */\r\n-public class HandlerRelationMapTableFieldStrategy\r\n-    extends MapTableFieldStrategy {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (HandlerRelationMapTableFieldStrategy.class);\r\n-\r\n-    private Column[] _kcols = null;\r\n-    private ColumnIO _kio = null;\r\n-    private boolean _kload = false;\r\n-\r\n-    public Column[] getKeyColumns(ClassMapping cls) {\r\n-        return _kcols;\r\n-    }\r\n-\r\n-    public ColumnIO getKeyColumnIO() {\r\n-        return _kio;\r\n-    }\r\n-\r\n-    public Column[] getValueColumns(ClassMapping cls) {\r\n-        return field.getElementMapping().getColumns();\r\n-    }\r\n-\r\n-    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\r\n-        sel.select(_kcols, joins);\r\n-    }\r\n-\r\n-    public void selectValue(Select sel, ClassMapping val,\r\n-        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \r\n-        Joins joins) {\r\n-        sel.select(val, field.getElementMapping().getSelectSubclasses(),\r\n-            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\r\n-    }\r\n-\r\n-    public Result[] getResults(final OpenJPAStateManager sm,\r\n-        final JDBCStore store, final JDBCFetchConfiguration fetch,\r\n-        final int eagerMode, final Joins[] resJoins, boolean lrs)\r\n-        throws SQLException {\r\n-        ValueMapping elem = field.getElementMapping();\r\n-        final ClassMapping[] vals = elem.getIndependentTypeMappings();\r\n-        Union union = store.getSQLFactory().newUnion(vals.length);\r\n-        if (fetch.getSubclassFetchMode(elem.getTypeMapping())\r\n-            != JDBCFetchConfiguration.EAGER_JOIN)\r\n-            union.abortUnion();\r\n-        union.setLRS(lrs);\r\n-        union.select(new Union.Selector() {\r\n-            public void select(Select sel, int idx) {\r\n-                sel.select(_kcols);\r\n-                sel.whereForeignKey(field.getJoinForeignKey(),\r\n-                    sm.getObjectId(), field.getDefiningMapping(), store);\r\n-                FieldMapping mapped = field.getMappedByMapping();\r\n-                Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\r\n-                \r\n-                sel.select(vals[idx], field.getElementMapping().\r\n-                    getSelectSubclasses(), store, fetch, eagerMode, joins);\r\n-\r\n-                //### cheat: result joins only care about the relation path;\r\n-                //### thus we can use first mapping of union only\r\n-                if (idx == 0)\r\n-                    resJoins[1] = joins;\r\n-            }\r\n-        });\r\n-        Result res = union.execute(store, fetch);\r\n-        return new Result[]{ res, res };\r\n-    }\r\n-\r\n-    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        return HandlerStrategies.loadObject(field.getKeyMapping(),\r\n-            sm, store, fetch, res, joins, _kcols, _kload);\r\n-    }\r\n-\r\n-    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        ClassMapping val = res.getBaseMapping();\r\n-        if (val == null)\r\n-            val = field.getElementMapping().getIndependentTypeMappings()[0];\r\n-        return res.load(val, store, fetch, joins);\r\n-    }\r\n-\r\n-    public Joins joinValueRelation(Joins joins, ClassMapping val) {\r\n-        ValueMapping vm = field.getElementMapping();\r\n-        ForeignKey fk = vm.getForeignKey(val);\r\n-        if (fk == null)\r\n-            return joins;\r\n-        return joins.joinRelation(field.getName(), fk, val,\r\n-            vm.getSelectSubclasses(), false, false);\r\n-    }\r\n-\r\n-    public void map(boolean adapt) {\r\n-        super.map(adapt);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        if (key.getHandler() == null)\r\n-            throw new MetaDataException(_loc.get(\"no-handler\", key));\r\n-        ValueMapping val = field.getElementMapping();\r\n-        if (val.getTypeCode() != JavaTypes.PC || val.isEmbeddedPC())\r\n-            throw new MetaDataException(_loc.get(\"not-relation\", val));\r\n-        FieldMapping mapped = field.getMappedByMapping();\r\n-        \r\n-        if (mapped != null) // map to the owner table\r\n-            handleMappedBy(adapt);\r\n-        else { \r\n-            // map to a separate table\r\n-            field.mapJoin(adapt, true);\r\n-            if (val.getTypeMapping().isMapped()) {\r\n-                ValueMappingInfo vinfo = val.getValueInfo();\r\n-                ForeignKey fk = vinfo.getTypeJoin(val, \"value\", false, adapt);\r\n-                val.setForeignKey(fk);\r\n-                val.setColumnIO(vinfo.getColumnIO());\r\n-            } else\r\n-                RelationStrategies.mapRelationToUnmappedPC(val, \"value\", adapt);\r\n-\r\n-            val.mapConstraints(\"value\", adapt);\r\n-        }\r\n-        _kio = new ColumnIO();\r\n-        DBDictionary dict = field.getMappingRepository().getDBDictionary();\r\n-        _kcols = HandlerStrategies.map(key, \r\n-            dict.getValidColumnName(\"key\", field.getTable()), _kio, adapt);\r\n-\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    public void initialize() {\r\n-        _kload = field.getKeyMapping().getHandler().\r\n-            objectValueRequiresLoad(field.getKeyMapping());\r\n-    }\r\n-\r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\r\n-    }\r\n-\r\n-    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\r\n-        Map map)\r\n-        throws SQLException {\r\n-        if (map == null || map.isEmpty())\r\n-            return;\r\n-        if (field.getMappedBy() != null)\r\n-            return;\r\n-\r\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\r\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\r\n-            sm);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ValueMapping val = field.getElementMapping();\r\n-        StoreContext ctx = store.getContext();\r\n-        OpenJPAStateManager valsm;\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            HandlerStrategies.set(key, entry.getKey(), store, row, _kcols,\r\n-                _kio, true);\r\n-            valsm = RelationStrategies.getStateManager(entry.getValue(),\r\n-                ctx);\r\n-            val.setForeignKey(row, valsm);\r\n-            \r\n-            // So far we poplulated the key/value of each\r\n-            // map element owned by the entity.\r\n-            // In the case of ToMany, and both sides\r\n-            // use Map to represent the relation,\r\n-            // we need to populate the key value of the owner\r\n-            // from the view point of the owned side\r\n-            PersistenceCapable obj = sm.getPersistenceCapable();\r\n-            if (!populateKey(row, valsm, obj, ctx, rm, store))\r\n-                rm.flushSecondaryRow(row);\r\n-        }\r\n-    }\r\n-    \r\n-    public void setKey(Object keyObj, JDBCStore store, Row row) \r\n-        throws SQLException {\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        HandlerStrategies.set(key, keyObj, store, row, _kcols,\r\n-            _kio, true);\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        if (field.getMappedBy() != null)\r\n-            return;\r\n-\r\n-        Map map = (Map) sm.fetchObject(field.getIndex());\r\n-        ChangeTracker ct = null;\r\n-        if (map instanceof Proxy) {\r\n-            Proxy proxy = (Proxy) map;\r\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\r\n-                ct = proxy.getChangeTracker();\r\n-        }\r\n-\r\n-        // if no fine-grained change tracking then just delete and reinsert\r\n-        if (ct == null || !ct.isTracking()) {\r\n-            delete(sm, store, rm);\r\n-            insert(sm, store, rm, map);\r\n-            return;\r\n-        }\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ValueMapping val = field.getElementMapping();\r\n-        StoreContext ctx = store.getContext();\r\n-        OpenJPAStateManager valsm;\r\n-\r\n-        // update the changes; note that we have to featureSelection changes as\r\n-        // delete-then-insert if we have a foreign key action, because\r\n-        // secondary row updates aren't part of the constraint graph\r\n-        Collection change = ct.getChanged();\r\n-        boolean canChange = val.getForeignKey().isLogical();\r\n-        Object mkey;\r\n-        if (canChange && !change.isEmpty()) {\r\n-            Row changeRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_UPDATE);\r\n-            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                HandlerStrategies.where(key, mkey, store, changeRow, _kcols);\r\n-                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\r\n-                val.setForeignKey(changeRow, valsm);\r\n-                rm.flushSecondaryRow(changeRow);\r\n-            }\r\n-        }\r\n-\r\n-        // delete the removes\r\n-        Collection rem = ct.getRemoved();\r\n-        if (!rem.isEmpty() || (!canChange && !change.isEmpty())) {\r\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_DELETE);\r\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\r\n-                HandlerStrategies.where(key, itr.next(), store, delRow,\r\n-                    _kcols);\r\n-                rm.flushSecondaryRow(delRow);\r\n-            }\r\n-            if (!canChange && !change.isEmpty()) {\r\n-                for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                    HandlerStrategies.where(key, itr.next(), store, delRow,\r\n-                        _kcols);\r\n-                    rm.flushSecondaryRow(delRow);\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        // insert the adds\r\n-        Collection add = ct.getAdded();\r\n-        if (!add.isEmpty() || (!canChange && !change.isEmpty())) {\r\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_INSERT);\r\n-            addRow.setForeignKey(field.getJoinForeignKey(),\r\n-                field.getJoinColumnIO(), sm);\r\n-\r\n-            for (Iterator itr = add.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                HandlerStrategies.set(key, mkey, store, addRow, _kcols,\r\n-                    _kio, true);\r\n-                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\r\n-                val.setForeignKey(addRow, valsm);\r\n-                rm.flushSecondaryRow(addRow);\r\n-            }\r\n-            if (!canChange && !change.isEmpty()) {\r\n-                for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                    mkey = itr.next();\r\n-                    HandlerStrategies.set(key, mkey, store, addRow, _kcols,\r\n-                        _kio, true);\r\n-                    valsm = RelationStrategies.getStateManager(map.get(mkey),\r\n-                        ctx);\r\n-                    val.setForeignKey(addRow, valsm);\r\n-                    rm.flushSecondaryRow(addRow);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        ValueMapping val = field.getElementMapping();\r\n-        ClassMapping[] clss = val.getIndependentTypeMappings();\r\n-        if (clss.length != 1) {\r\n-            if (traverse)\r\n-                throw RelationStrategies.unjoinable(val);\r\n-            return joins;\r\n-        }\r\n-        ForeignKey fk = val.getForeignKey(clss[0]);\r\n-        if (fk == null)\r\n-            return joins;\r\n-        if (forceOuter)\r\n-            return joins.outerJoinRelation(field.getName(),\r\n-                fk, clss[0], val.getSelectSubclasses(),\r\n-                false, false);\r\n-        return joins.joinRelation(field.getName(),\r\n-                fk, clss[0], val.getSelectSubclasses(), \r\n-            false, false);\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        if (traverse)\r\n-            HandlerStrategies.assertJoinable(field.getKeyMapping());\r\n-        return joins;\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\r\n-        return RelationStrategies.toDataStoreValue(field.getElementMapping(),\r\n-            val, store);\r\n-    }\r\n-\r\n-    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\r\n-        return HandlerStrategies.toDataStoreValue(field.getKeyMapping(), val,\r\n-            _kcols, store);\r\n-    }\r\n-    \r\n-    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        if (field.getMappedBy() != null)\r\n-            return;\r\n-        super.delete(sm, store, rm);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.meta.*;\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.util.*;\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.*;\n+\n+/**\n+ * <p>Mapping for a map whose keys are controlled by a {@link ValueHandler}\n+ * and whose values are relations to other persistent objects.</p>\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ */\n+public class HandlerRelationMapTableFieldStrategy\n+    extends MapTableFieldStrategy {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (HandlerRelationMapTableFieldStrategy.class);\n+\n+    private Column[] _kcols = null;\n+    private ColumnIO _kio = null;\n+    private boolean _kload = false;\n+\n+    public Column[] getKeyColumns(ClassMapping cls) {\n+        return _kcols;\n+    }\n+\n+    public ColumnIO getKeyColumnIO() {\n+        return _kio;\n+    }\n+\n+    public Column[] getValueColumns(ClassMapping cls) {\n+        return field.getElementMapping().getColumns();\n+    }\n+\n+    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+        sel.select(_kcols, joins);\n+    }\n+\n+    public void selectValue(Select sel, ClassMapping val,\n+        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \n+        Joins joins) {\n+        sel.select(val, field.getElementMapping().getSelectSubclasses(),\n+            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\n+    }\n+\n+    public Result[] getResults(final OpenJPAStateManager sm,\n+        final JDBCStore store, final JDBCFetchConfiguration fetch,\n+        final int eagerMode, final Joins[] resJoins, boolean lrs)\n+        throws SQLException {\n+        ValueMapping elem = field.getElementMapping();\n+        final ClassMapping[] vals = elem.getIndependentTypeMappings();\n+        Union union = store.getSQLFactory().newUnion(vals.length);\n+        if (fetch.getSubclassFetchMode(elem.getTypeMapping())\n+            != JDBCFetchConfiguration.EAGER_JOIN)\n+            union.abortUnion();\n+        union.setLRS(lrs);\n+        union.select(new Union.Selector() {\n+            public void select(Select sel, int idx) {\n+                sel.select(_kcols);\n+                sel.whereForeignKey(field.getJoinForeignKey(),\n+                    sm.getObjectId(), field.getDefiningMapping(), store);\n+                FieldMapping mapped = field.getMappedByMapping();\n+                Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\n+                \n+                sel.select(vals[idx], field.getElementMapping().\n+                    getSelectSubclasses(), store, fetch, eagerMode, joins);\n+\n+                //### cheat: result joins only care about the relation path;\n+                //### thus we can use first mapping of union only\n+                if (idx == 0)\n+                    resJoins[1] = joins;\n+            }\n+        });\n+        Result res = union.execute(store, fetch);\n+        return new Result[]{ res, res };\n+    }\n+\n+    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        return HandlerStrategies.loadObject(field.getKeyMapping(),\n+            sm, store, fetch, res, joins, _kcols, _kload);\n+    }\n+\n+    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        ClassMapping val = res.getBaseMapping();\n+        if (val == null)\n+            val = field.getElementMapping().getIndependentTypeMappings()[0];\n+        return res.load(val, store, fetch, joins);\n+    }\n+\n+    public Joins joinValueRelation(Joins joins, ClassMapping val) {\n+        ValueMapping vm = field.getElementMapping();\n+        ForeignKey fk = vm.getForeignKey(val);\n+        if (fk == null)\n+            return joins;\n+        return joins.joinRelation(field.getName(), fk, val,\n+            vm.getSelectSubclasses(), false, false);\n+    }\n+\n+    public void map(boolean adapt) {\n+        super.map(adapt);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        if (key.getHandler() == null)\n+            throw new MetaDataException(_loc.get(\"no-handler\", key));\n+        ValueMapping val = field.getElementMapping();\n+        if (val.getTypeCode() != JavaTypes.PC || val.isEmbeddedPC())\n+            throw new MetaDataException(_loc.get(\"not-relation\", val));\n+        FieldMapping mapped = field.getMappedByMapping();\n+        \n+        if (mapped != null) // map to the owner table\n+            handleMappedBy(adapt);\n+        else { \n+            // map to a separate table\n+            field.mapJoin(adapt, true);\n+            if (val.getTypeMapping().isMapped()) {\n+                ValueMappingInfo vinfo = val.getValueInfo();\n+                ForeignKey fk = vinfo.getTypeJoin(val, \"value\", false, adapt);\n+                val.setForeignKey(fk);\n+                val.setColumnIO(vinfo.getColumnIO());\n+            } else\n+                RelationStrategies.mapRelationToUnmappedPC(val, \"value\", adapt);\n+\n+            val.mapConstraints(\"value\", adapt);\n+        }\n+        _kio = new ColumnIO();\n+        DBDictionary dict = field.getMappingRepository().getDBDictionary();\n+        _kcols = HandlerStrategies.map(key, \n+            dict.getValidColumnName(\"key\", field.getTable()), _kio, adapt);\n+\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    public void initialize() {\n+        _kload = field.getKeyMapping().getHandler().\n+            objectValueRequiresLoad(field.getKeyMapping());\n+    }\n+\n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\n+    }\n+\n+    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n+        Map map)\n+        throws SQLException {\n+        if (map == null || map.isEmpty())\n+            return;\n+        if (field.getMappedBy() != null)\n+            return;\n+\n+        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+            sm);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        StoreContext ctx = store.getContext();\n+        OpenJPAStateManager valsm;\n+        Map.Entry entry;\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            HandlerStrategies.set(key, entry.getKey(), store, row, _kcols,\n+                _kio, true);\n+            valsm = RelationStrategies.getStateManager(entry.getValue(),\n+                ctx);\n+            val.setForeignKey(row, valsm);\n+            \n+            // So far we poplulated the key/value of each\n+            // map element owned by the entity.\n+            // In the case of ToMany, and both sides\n+            // use Map to represent the relation,\n+            // we need to populate the key value of the owner\n+            // from the view point of the owned side\n+            PersistenceCapable obj = sm.getPersistenceCapable();\n+            if (!populateKey(row, valsm, obj, ctx, rm, store))\n+                rm.flushSecondaryRow(row);\n+        }\n+    }\n+    \n+    public void setKey(Object keyObj, JDBCStore store, Row row) \n+        throws SQLException {\n+        ValueMapping key = field.getKeyMapping();\n+        HandlerStrategies.set(key, keyObj, store, row, _kcols,\n+            _kio, true);\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        if (field.getMappedBy() != null)\n+            return;\n+\n+        Map map = (Map) sm.fetchObject(field.getIndex());\n+        ChangeTracker ct = null;\n+        if (map instanceof Proxy) {\n+            Proxy proxy = (Proxy) map;\n+            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n+                ct = proxy.getChangeTracker();\n+        }\n+\n+        // if no fine-grained change tracking then just delete and reinsert\n+        if (ct == null || !ct.isTracking()) {\n+            delete(sm, store, rm);\n+            insert(sm, store, rm, map);\n+            return;\n+        }\n+\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        StoreContext ctx = store.getContext();\n+        OpenJPAStateManager valsm;\n+\n+        // update the changes; note that we have to featureSelection changes as\n+        // delete-then-insert if we have a foreign key action, because\n+        // secondary row updates aren't part of the constraint graph\n+        Collection change = ct.getChanged();\n+        boolean canChange = val.getForeignKey().isLogical();\n+        Object mkey;\n+        if (canChange && !change.isEmpty()) {\n+            Row changeRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_UPDATE);\n+            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                HandlerStrategies.where(key, mkey, store, changeRow, _kcols);\n+                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n+                val.setForeignKey(changeRow, valsm);\n+                rm.flushSecondaryRow(changeRow);\n+            }\n+        }\n+\n+        // delete the removes\n+        Collection rem = ct.getRemoved();\n+        if (!rem.isEmpty() || (!canChange && !change.isEmpty())) {\n+            Row delRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_DELETE);\n+            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+                HandlerStrategies.where(key, itr.next(), store, delRow,\n+                    _kcols);\n+                rm.flushSecondaryRow(delRow);\n+            }\n+            if (!canChange && !change.isEmpty()) {\n+                for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                    HandlerStrategies.where(key, itr.next(), store, delRow,\n+                        _kcols);\n+                    rm.flushSecondaryRow(delRow);\n+                }\n+            }\n+        }\n+\n+        // insert the adds\n+        Collection add = ct.getAdded();\n+        if (!add.isEmpty() || (!canChange && !change.isEmpty())) {\n+            Row addRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_INSERT);\n+            addRow.setForeignKey(field.getJoinForeignKey(),\n+                field.getJoinColumnIO(), sm);\n+\n+            for (Iterator itr = add.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                HandlerStrategies.set(key, mkey, store, addRow, _kcols,\n+                    _kio, true);\n+                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n+                val.setForeignKey(addRow, valsm);\n+                rm.flushSecondaryRow(addRow);\n+            }\n+            if (!canChange && !change.isEmpty()) {\n+                for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                    mkey = itr.next();\n+                    HandlerStrategies.set(key, mkey, store, addRow, _kcols,\n+                        _kio, true);\n+                    valsm = RelationStrategies.getStateManager(map.get(mkey),\n+                        ctx);\n+                    val.setForeignKey(addRow, valsm);\n+                    rm.flushSecondaryRow(addRow);\n+                }\n+            }\n+        }\n+    }\n+\n+    public Joins joinRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        ValueMapping val = field.getElementMapping();\n+        ClassMapping[] clss = val.getIndependentTypeMappings();\n+        if (clss.length != 1) {\n+            if (traverse)\n+                throw RelationStrategies.unjoinable(val);\n+            return joins;\n+        }\n+        ForeignKey fk = val.getForeignKey(clss[0]);\n+        if (fk == null)\n+            return joins;\n+        if (forceOuter)\n+            return joins.outerJoinRelation(field.getName(),\n+                fk, clss[0], val.getSelectSubclasses(),\n+                false, false);\n+        return joins.joinRelation(field.getName(),\n+                fk, clss[0], val.getSelectSubclasses(), \n+            false, false);\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        if (traverse)\n+            HandlerStrategies.assertJoinable(field.getKeyMapping());\n+        return joins;\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return RelationStrategies.toDataStoreValue(field.getElementMapping(),\n+            val, store);\n+    }\n+\n+    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n+        return HandlerStrategies.toDataStoreValue(field.getKeyMapping(), val,\n+            _kcols, store);\n+    }\n+    \n+    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        if (field.getMappedBy() != null)\n+            return;\n+        super.delete(sm, store, rm);\n+    }\n+}"},{"sha":"5af8420cd27e5f3602782dd8db5b02413212406e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java","status":"modified","additions":219,"deletions":219,"changes":438,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,219 +1,219 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.io.InputStream;\r\n-import java.io.Reader;\r\n-import java.sql.SQLException;\r\n-import java.sql.Types;\r\n-\r\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\r\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\r\n-import org.apache.openjpa.jdbc.meta.FieldMapping;\r\n-import org.apache.openjpa.jdbc.meta.ValueMappingInfo;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.sql.PostgresDictionary;\r\n-import org.apache.openjpa.jdbc.sql.Result;\r\n-import org.apache.openjpa.jdbc.sql.Row;\r\n-import org.apache.openjpa.jdbc.sql.RowManager;\r\n-import org.apache.openjpa.jdbc.sql.Select;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-\r\n-/**\r\n- * Direct mapping from a stream value to a column.\r\n- *\r\n- * @author Ignacio Andreu\r\n- * @since 1.1.0\r\n- */\r\n-public class LobFieldStrategy extends AbstractFieldStrategy {\r\n-\r\n-    private int fieldType;\r\n-    private boolean isBlob;\r\n-\r\n-    public void map(boolean adapt) {\r\n-        assertNotMappedBy();\r\n-        field.mapJoin(adapt, false);\r\n-        field.getKeyMapping().getValueInfo().assertNoSchemaComponents\r\n-            (field.getKey(), !adapt);\r\n-        field.getElementMapping().getValueInfo().assertNoSchemaComponents\r\n-            (field.getElement(), !adapt);\r\n-        field.setStream(true);\r\n-        ValueMappingInfo vinfo = field.getValueInfo();\r\n-        vinfo.assertNoJoin(field, true);\r\n-        vinfo.assertNoForeignKey(field, !adapt);\r\n-        Column tmpCol = new Column();\r\n-        tmpCol.setName(field.getName());\r\n-        tmpCol.setType(fieldType);\r\n-        tmpCol.setJavaType(field.getTypeCode());\r\n-        \r\n-        tmpCol.setSize(-1);\r\n-\r\n-        Column[] cols = vinfo.getColumns(field, field.getName(),\r\n-            new Column[]{ tmpCol }, field.getTable(), adapt);\r\n-\r\n-        field.setColumns(cols);\r\n-        field.setColumnIO(vinfo.getColumnIO());\r\n-        field.mapConstraints(field.getName(), adapt);\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    public Boolean isCustomInsert(OpenJPAStateManager sm, JDBCStore store) {\r\n-        return null;\r\n-    }\r\n-\r\n-    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Select sel = createSelect(sm, store);\r\n-        store.getDBDictionary().deleteStream(store, sel);\r\n-    }\r\n-    \r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Object ob = toDataStoreValue(sm.fetchObjectField\r\n-            (field.getIndex()), store);\r\n-        Row row = field.getRow(sm, store, rm, Row.ACTION_INSERT);\r\n-        if (field.getColumnIO().isInsertable(0, ob == null)) {\r\n-            Select sel = createSelect(sm, store);\r\n-            if (isBlob) {\r\n-                store.getDBDictionary().insertBlobForStreamingLoad\r\n-                    (row, field.getColumns()[0], store, ob, sel);\r\n-            } else {\r\n-                store.getDBDictionary().insertClobForStreamingLoad\r\n-                    (row, field.getColumns()[0], ob);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void customInsert(OpenJPAStateManager sm, JDBCStore store)\r\n-        throws SQLException {\r\n-        Object ob = toDataStoreValue(sm.fetchObjectField\r\n-            (field.getIndex()), store);\r\n-        if (field.getColumnIO().isInsertable(0, ob == null)) {\r\n-            if (ob != null) {\r\n-                Select sel = createSelect(sm, store);\r\n-                if (isBlob) {\r\n-                    store.getDBDictionary().updateBlob\r\n-                        (sel, store, (InputStream)ob);\r\n-                } else {\r\n-                    store.getDBDictionary().updateClob\r\n-                        (sel, store, (Reader)ob);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    public Boolean isCustomUpdate(OpenJPAStateManager sm, JDBCStore store) {\r\n-        return null;\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Object ob = toDataStoreValue(sm.fetchObjectField\r\n-            (field.getIndex()), store);\r\n-        if (field.getColumnIO().isUpdatable(0, ob == null)) {\r\n-            Row row = field.getRow(sm, store, rm, Row.ACTION_UPDATE);\r\n-            Select sel = createSelect(sm, store);\r\n-            if (isBlob) {\r\n-                store.getDBDictionary().insertBlobForStreamingLoad\r\n-                    (row, field.getColumns()[0], store, ob, sel);\r\n-            } else {\r\n-                store.getDBDictionary().insertClobForStreamingLoad\r\n-                    (row, field.getColumns()[0], sel);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void customUpdate(OpenJPAStateManager sm, JDBCStore store)\r\n-        throws SQLException {\r\n-        Object ob = toDataStoreValue(sm.fetchObjectField\r\n-                (field.getIndex()), store);\r\n-        if (field.getColumnIO().isUpdatable(0, ob == null)) {\r\n-            if (ob != null) {\r\n-                Select sel = createSelect(sm, store);\r\n-                if (isBlob) {\r\n-                    store.getDBDictionary().updateBlob\r\n-                        (sel, store, (InputStream)ob);\r\n-                } else {\r\n-                    store.getDBDictionary().updateClob\r\n-                        (sel, store, (Reader)ob);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public int supportsSelect(Select sel, int type, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch) {\r\n-        if (type == Select.TYPE_JOINLESS && sel.isSelected(field.getTable()))\r\n-            return 1;\r\n-        return 0;\r\n-    }\r\n-\r\n-    public int select(Select sel, OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, int eagerMode) {\r\n-        sel.select(field.getColumns()[0], field.join(sel));\r\n-        return 1;\r\n-    }\r\n-\r\n-    public void load(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res) throws SQLException {\r\n-        Column col = field.getColumns()[0];\r\n-        if (res.contains(col)) {\r\n-            if (isBlob) {\r\n-                sm.storeObject(field.getIndex(), res.getLOBStream(store, col));\r\n-            } else {\r\n-                sm.storeObject(field.getIndex(), res.getCharacterStream(col));\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    protected void assertNotMappedBy() {\r\n-        if (field != null && field.getMappedBy() != null)\r\n-            throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public void setFieldMapping(FieldMapping owner) {\r\n-        field = owner;\r\n-        if (owner.getElementMapping().getMappingRepository().getDBDictionary()\r\n-            instanceof PostgresDictionary) {\r\n-            fieldType = Types.INTEGER;\r\n-            isBlob = true;\r\n-            field.setTypeCode(JavaTypes.INT);\r\n-        } else {\r\n-            if (owner.getType().isAssignableFrom(InputStream.class)) {\r\n-                isBlob = true;\r\n-                fieldType = Types.BLOB;\r\n-            } else if (owner.getType().isAssignableFrom(Reader.class)) {\r\n-                isBlob = false;\r\n-                fieldType = Types.CLOB;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private Select createSelect(OpenJPAStateManager sm, JDBCStore store) {\r\n-        Select sel = store.getSQLFactory().newSelect();\r\n-        sel.select(field.getColumns()[0]);\r\n-        sel.selectPrimaryKey(field.getDefiningMapping());\r\n-        sel.wherePrimaryKey\r\n-            (sm.getObjectId(), field.getDefiningMapping(), store);\r\n-        sel.setLob(true);\r\n-        return sel;\r\n-    }\r\n-    \r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.ValueMappingInfo;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.sql.PostgresDictionary;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.Row;\n+import org.apache.openjpa.jdbc.sql.RowManager;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.meta.JavaTypes;\n+\n+/**\n+ * Direct mapping from a stream value to a column.\n+ *\n+ * @author Ignacio Andreu\n+ * @since 1.1.0\n+ */\n+public class LobFieldStrategy extends AbstractFieldStrategy {\n+\n+    private int fieldType;\n+    private boolean isBlob;\n+\n+    public void map(boolean adapt) {\n+        assertNotMappedBy();\n+        field.mapJoin(adapt, false);\n+        field.getKeyMapping().getValueInfo().assertNoSchemaComponents\n+            (field.getKey(), !adapt);\n+        field.getElementMapping().getValueInfo().assertNoSchemaComponents\n+            (field.getElement(), !adapt);\n+        field.setStream(true);\n+        ValueMappingInfo vinfo = field.getValueInfo();\n+        vinfo.assertNoJoin(field, true);\n+        vinfo.assertNoForeignKey(field, !adapt);\n+        Column tmpCol = new Column();\n+        tmpCol.setName(field.getName());\n+        tmpCol.setType(fieldType);\n+        tmpCol.setJavaType(field.getTypeCode());\n+        \n+        tmpCol.setSize(-1);\n+\n+        Column[] cols = vinfo.getColumns(field, field.getName(),\n+            new Column[]{ tmpCol }, field.getTable(), adapt);\n+\n+        field.setColumns(cols);\n+        field.setColumnIO(vinfo.getColumnIO());\n+        field.mapConstraints(field.getName(), adapt);\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    public Boolean isCustomInsert(OpenJPAStateManager sm, JDBCStore store) {\n+        return null;\n+    }\n+\n+    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Select sel = createSelect(sm, store);\n+        store.getDBDictionary().deleteStream(store, sel);\n+    }\n+    \n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Object ob = toDataStoreValue(sm.fetchObjectField\n+            (field.getIndex()), store);\n+        Row row = field.getRow(sm, store, rm, Row.ACTION_INSERT);\n+        if (field.getColumnIO().isInsertable(0, ob == null)) {\n+            Select sel = createSelect(sm, store);\n+            if (isBlob) {\n+                store.getDBDictionary().insertBlobForStreamingLoad\n+                    (row, field.getColumns()[0], store, ob, sel);\n+            } else {\n+                store.getDBDictionary().insertClobForStreamingLoad\n+                    (row, field.getColumns()[0], ob);\n+            }\n+        }\n+    }\n+\n+    public void customInsert(OpenJPAStateManager sm, JDBCStore store)\n+        throws SQLException {\n+        Object ob = toDataStoreValue(sm.fetchObjectField\n+            (field.getIndex()), store);\n+        if (field.getColumnIO().isInsertable(0, ob == null)) {\n+            if (ob != null) {\n+                Select sel = createSelect(sm, store);\n+                if (isBlob) {\n+                    store.getDBDictionary().updateBlob\n+                        (sel, store, (InputStream)ob);\n+                } else {\n+                    store.getDBDictionary().updateClob\n+                        (sel, store, (Reader)ob);\n+                }\n+            }\n+        }\n+    }\n+    \n+    public Boolean isCustomUpdate(OpenJPAStateManager sm, JDBCStore store) {\n+        return null;\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Object ob = toDataStoreValue(sm.fetchObjectField\n+            (field.getIndex()), store);\n+        if (field.getColumnIO().isUpdatable(0, ob == null)) {\n+            Row row = field.getRow(sm, store, rm, Row.ACTION_UPDATE);\n+            Select sel = createSelect(sm, store);\n+            if (isBlob) {\n+                store.getDBDictionary().insertBlobForStreamingLoad\n+                    (row, field.getColumns()[0], store, ob, sel);\n+            } else {\n+                store.getDBDictionary().insertClobForStreamingLoad\n+                    (row, field.getColumns()[0], sel);\n+            }\n+        }\n+    }\n+\n+    public void customUpdate(OpenJPAStateManager sm, JDBCStore store)\n+        throws SQLException {\n+        Object ob = toDataStoreValue(sm.fetchObjectField\n+                (field.getIndex()), store);\n+        if (field.getColumnIO().isUpdatable(0, ob == null)) {\n+            if (ob != null) {\n+                Select sel = createSelect(sm, store);\n+                if (isBlob) {\n+                    store.getDBDictionary().updateBlob\n+                        (sel, store, (InputStream)ob);\n+                } else {\n+                    store.getDBDictionary().updateClob\n+                        (sel, store, (Reader)ob);\n+                }\n+            }\n+        }\n+    }\n+\n+    public int supportsSelect(Select sel, int type, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch) {\n+        if (type == Select.TYPE_JOINLESS && sel.isSelected(field.getTable()))\n+            return 1;\n+        return 0;\n+    }\n+\n+    public int select(Select sel, OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, int eagerMode) {\n+        sel.select(field.getColumns()[0], field.join(sel));\n+        return 1;\n+    }\n+\n+    public void load(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res) throws SQLException {\n+        Column col = field.getColumns()[0];\n+        if (res.contains(col)) {\n+            if (isBlob) {\n+                sm.storeObject(field.getIndex(), res.getLOBStream(store, col));\n+            } else {\n+                sm.storeObject(field.getIndex(), res.getCharacterStream(col));\n+            }\n+        }\n+    }\n+\n+    protected void assertNotMappedBy() {\n+        if (field != null && field.getMappedBy() != null)\n+            throw new UnsupportedOperationException();\n+    }\n+\n+    public void setFieldMapping(FieldMapping owner) {\n+        field = owner;\n+        if (owner.getElementMapping().getMappingRepository().getDBDictionary()\n+            instanceof PostgresDictionary) {\n+            fieldType = Types.INTEGER;\n+            isBlob = true;\n+            field.setTypeCode(JavaTypes.INT);\n+        } else {\n+            if (owner.getType().isAssignableFrom(InputStream.class)) {\n+                isBlob = true;\n+                fieldType = Types.BLOB;\n+            } else if (owner.getType().isAssignableFrom(Reader.class)) {\n+                isBlob = false;\n+                fieldType = Types.CLOB;\n+            }\n+        }\n+    }\n+\n+    private Select createSelect(OpenJPAStateManager sm, JDBCStore store) {\n+        Select sel = store.getSQLFactory().newSelect();\n+        sel.select(field.getColumns()[0]);\n+        sel.selectPrimaryKey(field.getDefiningMapping());\n+        sel.wherePrimaryKey\n+            (sm.getObjectId(), field.getDefiningMapping(), store);\n+        sel.setLob(true);\n+        return sel;\n+    }\n+    \n+}"},{"sha":"90fda6709f8041b5996334d78478b7669933efcc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MultiColumnVersionStrategy.java","status":"modified","additions":110,"deletions":110,"changes":220,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MultiColumnVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MultiColumnVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MultiColumnVersionStrategy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,110 +1,110 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.schema.Schemas;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-\r\n-import serp.util.Numbers;\r\n-\r\n-/**\r\n- * Uses multiple version numbers spanning multiple columns for optimistic \r\n- * versioning.\r\n- * \r\n- * @since 1.3.0\r\n- *\r\n- * @author Pinaki Poddar\r\n- */\r\n-public class MultiColumnVersionStrategy extends NumberVersionStrategy {\r\n-\r\n-    public static final String ALIAS = \"version-numbers\";\r\n-    \r\n-    private Number[] _initials = null;\r\n-    private Integer[] _javaTypes;\r\n-    \r\n-    @Override\r\n-    public void initialize() {\r\n-    \tif (_initials == null) {\r\n-    \t\tColumn[] cols = vers.getColumns();\r\n-    \t\t_initials = new Number[cols.length];\r\n-    \t\tfor (int i = 0; i < cols.length; i++) {\r\n-    \t\t\t_initials[i] = nextValue(Numbers.valueOf(0), getJavaType(i));\r\n-    \t\t}\r\n-    \t}\r\n-    \tsuper.initialize();\r\n-    }\r\n-    \t\r\n-    /**\r\n-     * Set the initial value for version columns. Defaults to 1 for each column.\r\n-     */\r\n-    public void setInitialValues(Number[] initial) {\r\n-    \t_initials = new Number[initial.length];\r\n-    \tSystem.arraycopy(initial, 0, _initials, 0, initial.length);\r\n-    }\r\n-    \r\n-    /**\r\n-     * Return the initial values for version columns. Defaults to 1 for each \r\n-     * column.\r\n-     */\r\n-    public Number[] getInitialValues() {\r\n-    \treturn _initials;\r\n-    }\r\n-\r\n-    public String getAlias() {\r\n-        return ALIAS;\r\n-    }\r\n-    \r\n-    protected int getJavaType() {\r\n-        return JavaTypes.ARRAY;\r\n-    }\r\n-    \r\n-    protected int getJavaType(int i) {\r\n-    \tif (_javaTypes == null) {\r\n-    \t\t_javaTypes = new Integer[vers.getMappingInfo().getColumns().size()];\r\n-    \t}\r\n-    \tif (_javaTypes[i] == null) {\r\n-    \t\tColumn col = (Column)vers.getMappingInfo().getColumns().get(i);\r\n-    \t\tif (!StringUtils.isEmpty(col.getTypeName())) {\r\n-    \t\t\tClass javaType = Schemas.getJavaType(col.getType(), \r\n-    \t\t\t\t\tcol.getSize(), col.getDecimalDigits());\r\n-    \t\t\t_javaTypes[i] = JavaTypes.getTypeCode(javaType);\r\n-    \t\t} else {\r\n-    \t\t\t_javaTypes[i] = JavaTypes.INT;\r\n-    \t\t}\r\n-    \t}\r\n-    \treturn _javaTypes[i];\r\n-    }\r\n-\r\n-    protected Object nextVersion(Object version) {\r\n-        if (version == null)\r\n-            return _initials;\r\n-        Object[] values = (Object[])version;\r\n-        Number[] result = new Number[values.length];\r\n-        for (int i = 0; i < values.length; i++)\r\n-        \tresult[i] = nextValue(values[i], getJavaType(i));\r\n-        return result;\r\n-    }\r\n-    \r\n-    Number nextValue(Object number, int javaTypeCode) {\r\n-    \tNumber result = (number == null) ? 1 : ((Number)number).intValue() + 1;\r\n-    \treturn\t(Number)JavaTypes.convert(\"\"+result, javaTypeCode);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Schemas;\n+import org.apache.openjpa.meta.JavaTypes;\n+\n+import serp.util.Numbers;\n+\n+/**\n+ * Uses multiple version numbers spanning multiple columns for optimistic \n+ * versioning.\n+ * \n+ * @since 1.3.0\n+ *\n+ * @author Pinaki Poddar\n+ */\n+public class MultiColumnVersionStrategy extends NumberVersionStrategy {\n+\n+    public static final String ALIAS = \"version-numbers\";\n+    \n+    private Number[] _initials = null;\n+    private Integer[] _javaTypes;\n+    \n+    @Override\n+    public void initialize() {\n+    \tif (_initials == null) {\n+    \t\tColumn[] cols = vers.getColumns();\n+    \t\t_initials = new Number[cols.length];\n+    \t\tfor (int i = 0; i < cols.length; i++) {\n+    \t\t\t_initials[i] = nextValue(Numbers.valueOf(0), getJavaType(i));\n+    \t\t}\n+    \t}\n+    \tsuper.initialize();\n+    }\n+    \t\n+    /**\n+     * Set the initial value for version columns. Defaults to 1 for each column.\n+     */\n+    public void setInitialValues(Number[] initial) {\n+    \t_initials = new Number[initial.length];\n+    \tSystem.arraycopy(initial, 0, _initials, 0, initial.length);\n+    }\n+    \n+    /**\n+     * Return the initial values for version columns. Defaults to 1 for each \n+     * column.\n+     */\n+    public Number[] getInitialValues() {\n+    \treturn _initials;\n+    }\n+\n+    public String getAlias() {\n+        return ALIAS;\n+    }\n+    \n+    protected int getJavaType() {\n+        return JavaTypes.ARRAY;\n+    }\n+    \n+    protected int getJavaType(int i) {\n+    \tif (_javaTypes == null) {\n+    \t\t_javaTypes = new Integer[vers.getMappingInfo().getColumns().size()];\n+    \t}\n+    \tif (_javaTypes[i] == null) {\n+    \t\tColumn col = (Column)vers.getMappingInfo().getColumns().get(i);\n+    \t\tif (!StringUtils.isEmpty(col.getTypeName())) {\n+    \t\t\tClass javaType = Schemas.getJavaType(col.getType(), \n+    \t\t\t\t\tcol.getSize(), col.getDecimalDigits());\n+    \t\t\t_javaTypes[i] = JavaTypes.getTypeCode(javaType);\n+    \t\t} else {\n+    \t\t\t_javaTypes[i] = JavaTypes.INT;\n+    \t\t}\n+    \t}\n+    \treturn _javaTypes[i];\n+    }\n+\n+    protected Object nextVersion(Object version) {\n+        if (version == null)\n+            return _initials;\n+        Object[] values = (Object[])version;\n+        Number[] result = new Number[values.length];\n+        for (int i = 0; i < values.length; i++)\n+        \tresult[i] = nextValue(values[i], getJavaType(i));\n+        return result;\n+    }\n+    \n+    Number nextValue(Object number, int javaTypeCode) {\n+    \tNumber result = (number == null) ? 1 : ((Number)number).intValue() + 1;\n+    \treturn\t(Number)JavaTypes.convert(\"\"+result, javaTypeCode);\n+    }\n+}"},{"sha":"de51ad531fc306460de12f7a8f3d0513fb4aea57","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java","status":"modified","additions":41,"deletions":41,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,41 +1,41 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import org.apache.openjpa.lib.util.TimestampHelper;\r\n-\r\n-/**\r\n- * Uses a timestamp for optimistic versioning with nanosecond\r\n- * precision.\r\n- *\r\n- * @author Albert Lee\r\n- */\r\n-public class NanoPrecisionTimestampVersionStrategy\r\n-    extends TimestampVersionStrategy {\r\n-\r\n-    public static final String ALIAS = \"nano-timestamp\";\r\n-\r\n-    public String getAlias() {\r\n-        return ALIAS;\r\n-    }\r\n-\r\n-    protected Object nextVersion(Object version) {\r\n-        return TimestampHelper.getNanoPrecisionTimestamp();\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import org.apache.openjpa.lib.util.TimestampHelper;\n+\n+/**\n+ * Uses a timestamp for optimistic versioning with nanosecond\n+ * precision.\n+ *\n+ * @author Albert Lee\n+ */\n+public class NanoPrecisionTimestampVersionStrategy\n+    extends TimestampVersionStrategy {\n+\n+    public static final String ALIAS = \"nano-timestamp\";\n+\n+    public String getAlias() {\n+        return ALIAS;\n+    }\n+\n+    protected Object nextVersion(Object version) {\n+        return TimestampHelper.getNanoPrecisionTimestamp();\n+    }\n+}"},{"sha":"35a3a1c619765a5acee6dd0a3de6f37190526a75","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java","status":"modified","additions":290,"deletions":290,"changes":580,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,290 +1,290 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.lib.util.*;\r\n-import org.apache.openjpa.meta.*;\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.util.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-import org.apache.openjpa.jdbc.sql.*;\r\n-\r\n-/**\r\n- * <p>Mapping for a map whose keys are relations to other persistent objects\r\n- * and whose values are controlled by a {@link ValueHandler}.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- */\r\n-public class RelationHandlerMapTableFieldStrategy\r\n-    extends MapTableFieldStrategy {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (RelationHandlerMapTableFieldStrategy.class);\r\n-\r\n-    private Column[] _vcols = null;\r\n-    private ColumnIO _vio = null;\r\n-    private boolean _vload = false;\r\n-\r\n-    public Column[] getKeyColumns(ClassMapping cls) {\r\n-        return field.getKeyMapping().getColumns();\r\n-    }\r\n-\r\n-    public Column[] getValueColumns(ClassMapping cls) {\r\n-        return _vcols;\r\n-    }\r\n-\r\n-    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\r\n-        sel.select(key, field.getKeyMapping().getSelectSubclasses(),\r\n-            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\r\n-    }\r\n-\r\n-    public void selectValue(Select sel, ClassMapping val,\r\n-        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \r\n-        Joins joins) {\r\n-        sel.select(_vcols, joins);\r\n-    }\r\n-\r\n-    public Result[] getResults(final OpenJPAStateManager sm,\r\n-        final JDBCStore store, final JDBCFetchConfiguration fetch,\r\n-        final int eagerMode, final Joins[] resJoins, boolean lrs)\r\n-        throws SQLException {\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        final ClassMapping[] keys = key.getIndependentTypeMappings();\r\n-        Union union = store.getSQLFactory().newUnion(keys.length);\r\n-        if (fetch.getSubclassFetchMode(key.getTypeMapping()) \r\n-            != JDBCFetchConfiguration.EAGER_JOIN)\r\n-            union.abortUnion();\r\n-        union.setLRS(lrs);\r\n-        union.select(new Union.Selector() {\r\n-            public void select(Select sel, int idx) {\r\n-                sel.select(_vcols);\r\n-                sel.whereForeignKey(field.getJoinForeignKey(),\r\n-                    sm.getObjectId(), field.getDefiningMapping(), store);\r\n-\r\n-                Joins joins = joinKeyRelation(sel.newJoins(), keys[idx]);\r\n-                sel.select(keys[idx], field.getKeyMapping().\r\n-                    getSelectSubclasses(), store, fetch, eagerMode, joins);\r\n-\r\n-                //### cheat: result joins only care about the relation path;\r\n-                //### thus we can use first mapping of union only\r\n-                if (idx == 0)\r\n-                    resJoins[0] = joins;\r\n-            }\r\n-        });\r\n-        Result res = union.execute(store, fetch);\r\n-        return new Result[]{ res, res };\r\n-    }\r\n-\r\n-    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        ClassMapping key = res.getBaseMapping();\r\n-        if (key == null)\r\n-            key = field.getKeyMapping().getIndependentTypeMappings()[0];\r\n-        return res.load(key, store, fetch, joins);\r\n-    }\r\n-\r\n-    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        return HandlerStrategies.loadObject(field.getElementMapping(),\r\n-            sm, store, fetch, res, joins, _vcols, _vload);\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, ClassMapping key) {\r\n-        ValueMapping vm = field.getKeyMapping();\r\n-        return joins.joinRelation(field.getName(), vm.getForeignKey(key), key,\r\n-            vm.getSelectSubclasses(), false, false);\r\n-    }\r\n-\r\n-    public void map(boolean adapt) {\r\n-        super.map(adapt);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        if (key.getTypeCode() != JavaTypes.PC || key.isEmbeddedPC())\r\n-            throw new MetaDataException(_loc.get(\"not-relation\", key));\r\n-        ValueMapping val = field.getElementMapping();\r\n-        if (val.getHandler() == null)\r\n-            throw new MetaDataException(_loc.get(\"no-handler\", val));\r\n-        assertNotMappedBy();\r\n-\r\n-        field.mapJoin(adapt, true);\r\n-        _vio = new ColumnIO();\r\n-        _vcols = HandlerStrategies.map(val, \"value\", _vio, adapt);\r\n-\r\n-        if (key.getTypeMapping().isMapped()) {\r\n-            ValueMappingInfo vinfo = key.getValueInfo();\r\n-            ForeignKey fk = vinfo.getTypeJoin(key, \"key\", false, adapt);\r\n-            key.setForeignKey(fk);\r\n-            key.setColumnIO(vinfo.getColumnIO());\r\n-        } else\r\n-            RelationStrategies.mapRelationToUnmappedPC(key, \"key\", adapt);\r\n-\r\n-        key.mapConstraints(\"key\", adapt);\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    public void initialize() {\r\n-        _vload = field.getElementMapping().getHandler().\r\n-            objectValueRequiresLoad(field.getElementMapping());\r\n-    }\r\n-\r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\r\n-    }\r\n-\r\n-    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\r\n-        Map map)\r\n-        throws SQLException {\r\n-        if (map == null || map.isEmpty())\r\n-            return;\r\n-\r\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\r\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\r\n-            sm);\r\n-\r\n-        ValueMapping val = field.getElementMapping();\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        StoreContext ctx = store.getContext();\r\n-        OpenJPAStateManager keysm;\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            keysm = RelationStrategies.getStateManager(entry.getKey(), ctx);\r\n-            key.setForeignKey(row, keysm);\r\n-            HandlerStrategies.set(val, entry.getValue(), store, row, _vcols,\r\n-                _vio, true);\r\n-            rm.flushSecondaryRow(row);\r\n-        }\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Map map = (Map) sm.fetchObject(field.getIndex());\r\n-        ChangeTracker ct = null;\r\n-        if (map instanceof Proxy) {\r\n-            Proxy proxy = (Proxy) map;\r\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\r\n-                ct = proxy.getChangeTracker();\r\n-        }\r\n-\r\n-        // if no fine-grained change tracking then just delete and reinsert\r\n-        if (ct == null || !ct.isTracking()) {\r\n-            delete(sm, store, rm);\r\n-            insert(sm, store, rm, map);\r\n-            return;\r\n-        }\r\n-\r\n-        // delete the removes\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        StoreContext ctx = store.getContext();\r\n-        Collection rem = ct.getRemoved();\r\n-        OpenJPAStateManager keysm;\r\n-        if (!rem.isEmpty()) {\r\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_DELETE);\r\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\r\n-                keysm = RelationStrategies.getStateManager(itr.next(), ctx);\r\n-                key.whereForeignKey(delRow, keysm);\r\n-                rm.flushSecondaryRow(delRow);\r\n-            }\r\n-        }\r\n-\r\n-        // insert the adds\r\n-        ValueMapping val = field.getElementMapping();\r\n-        Collection add = ct.getAdded();\r\n-        Object mkey;\r\n-        if (!add.isEmpty()) {\r\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_INSERT);\r\n-            addRow.setForeignKey(field.getJoinForeignKey(),\r\n-                field.getJoinColumnIO(), sm);\r\n-\r\n-            for (Iterator itr = add.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                keysm = RelationStrategies.getStateManager(mkey, ctx);\r\n-                key.setForeignKey(addRow, keysm);\r\n-                HandlerStrategies.set(val, map.get(mkey), store, addRow,\r\n-                    _vcols, _vio, true);\r\n-                rm.flushSecondaryRow(addRow);\r\n-            }\r\n-        }\r\n-\r\n-        // update the changes\r\n-        Collection change = ct.getChanged();\r\n-        if (!change.isEmpty()) {\r\n-            Row changeRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_UPDATE);\r\n-            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                keysm = RelationStrategies.getStateManager(mkey, ctx);\r\n-                key.whereForeignKey(changeRow, keysm);\r\n-                HandlerStrategies.set(val, map.get(mkey), store, changeRow,\r\n-                    _vcols, _vio, true);\r\n-                rm.flushSecondaryRow(changeRow);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        if (traverse)\r\n-            HandlerStrategies.assertJoinable(field.getElementMapping());\r\n-        return joins;\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ClassMapping[] clss = key.getIndependentTypeMappings();\r\n-        if (clss.length != 1) {\r\n-            if (traverse)\r\n-                throw RelationStrategies.unjoinable(field.getKeyMapping());\r\n-            return joins;\r\n-        }\r\n-        if (forceOuter)\r\n-            return joins.outerJoinRelation(field.getName(),\r\n-                key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\r\n-                false, false);\r\n-        return joins.joinRelation(field.getName(),\r\n-            key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\r\n-            false, false);\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\r\n-        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\r\n-            val, _vcols, store);\r\n-    }\r\n-\r\n-    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\r\n-        return RelationStrategies.toDataStoreValue(field.getKeyMapping(), val,\r\n-            store);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.meta.*;\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.util.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.*;\n+\n+/**\n+ * <p>Mapping for a map whose keys are relations to other persistent objects\n+ * and whose values are controlled by a {@link ValueHandler}.</p>\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ */\n+public class RelationHandlerMapTableFieldStrategy\n+    extends MapTableFieldStrategy {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (RelationHandlerMapTableFieldStrategy.class);\n+\n+    private Column[] _vcols = null;\n+    private ColumnIO _vio = null;\n+    private boolean _vload = false;\n+\n+    public Column[] getKeyColumns(ClassMapping cls) {\n+        return field.getKeyMapping().getColumns();\n+    }\n+\n+    public Column[] getValueColumns(ClassMapping cls) {\n+        return _vcols;\n+    }\n+\n+    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+        sel.select(key, field.getKeyMapping().getSelectSubclasses(),\n+            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\n+    }\n+\n+    public void selectValue(Select sel, ClassMapping val,\n+        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \n+        Joins joins) {\n+        sel.select(_vcols, joins);\n+    }\n+\n+    public Result[] getResults(final OpenJPAStateManager sm,\n+        final JDBCStore store, final JDBCFetchConfiguration fetch,\n+        final int eagerMode, final Joins[] resJoins, boolean lrs)\n+        throws SQLException {\n+        ValueMapping key = field.getKeyMapping();\n+        final ClassMapping[] keys = key.getIndependentTypeMappings();\n+        Union union = store.getSQLFactory().newUnion(keys.length);\n+        if (fetch.getSubclassFetchMode(key.getTypeMapping()) \n+            != JDBCFetchConfiguration.EAGER_JOIN)\n+            union.abortUnion();\n+        union.setLRS(lrs);\n+        union.select(new Union.Selector() {\n+            public void select(Select sel, int idx) {\n+                sel.select(_vcols);\n+                sel.whereForeignKey(field.getJoinForeignKey(),\n+                    sm.getObjectId(), field.getDefiningMapping(), store);\n+\n+                Joins joins = joinKeyRelation(sel.newJoins(), keys[idx]);\n+                sel.select(keys[idx], field.getKeyMapping().\n+                    getSelectSubclasses(), store, fetch, eagerMode, joins);\n+\n+                //### cheat: result joins only care about the relation path;\n+                //### thus we can use first mapping of union only\n+                if (idx == 0)\n+                    resJoins[0] = joins;\n+            }\n+        });\n+        Result res = union.execute(store, fetch);\n+        return new Result[]{ res, res };\n+    }\n+\n+    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        ClassMapping key = res.getBaseMapping();\n+        if (key == null)\n+            key = field.getKeyMapping().getIndependentTypeMappings()[0];\n+        return res.load(key, store, fetch, joins);\n+    }\n+\n+    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        return HandlerStrategies.loadObject(field.getElementMapping(),\n+            sm, store, fetch, res, joins, _vcols, _vload);\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, ClassMapping key) {\n+        ValueMapping vm = field.getKeyMapping();\n+        return joins.joinRelation(field.getName(), vm.getForeignKey(key), key,\n+            vm.getSelectSubclasses(), false, false);\n+    }\n+\n+    public void map(boolean adapt) {\n+        super.map(adapt);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        if (key.getTypeCode() != JavaTypes.PC || key.isEmbeddedPC())\n+            throw new MetaDataException(_loc.get(\"not-relation\", key));\n+        ValueMapping val = field.getElementMapping();\n+        if (val.getHandler() == null)\n+            throw new MetaDataException(_loc.get(\"no-handler\", val));\n+        assertNotMappedBy();\n+\n+        field.mapJoin(adapt, true);\n+        _vio = new ColumnIO();\n+        _vcols = HandlerStrategies.map(val, \"value\", _vio, adapt);\n+\n+        if (key.getTypeMapping().isMapped()) {\n+            ValueMappingInfo vinfo = key.getValueInfo();\n+            ForeignKey fk = vinfo.getTypeJoin(key, \"key\", false, adapt);\n+            key.setForeignKey(fk);\n+            key.setColumnIO(vinfo.getColumnIO());\n+        } else\n+            RelationStrategies.mapRelationToUnmappedPC(key, \"key\", adapt);\n+\n+        key.mapConstraints(\"key\", adapt);\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    public void initialize() {\n+        _vload = field.getElementMapping().getHandler().\n+            objectValueRequiresLoad(field.getElementMapping());\n+    }\n+\n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\n+    }\n+\n+    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n+        Map map)\n+        throws SQLException {\n+        if (map == null || map.isEmpty())\n+            return;\n+\n+        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+            sm);\n+\n+        ValueMapping val = field.getElementMapping();\n+        ValueMapping key = field.getKeyMapping();\n+        StoreContext ctx = store.getContext();\n+        OpenJPAStateManager keysm;\n+        Map.Entry entry;\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            keysm = RelationStrategies.getStateManager(entry.getKey(), ctx);\n+            key.setForeignKey(row, keysm);\n+            HandlerStrategies.set(val, entry.getValue(), store, row, _vcols,\n+                _vio, true);\n+            rm.flushSecondaryRow(row);\n+        }\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Map map = (Map) sm.fetchObject(field.getIndex());\n+        ChangeTracker ct = null;\n+        if (map instanceof Proxy) {\n+            Proxy proxy = (Proxy) map;\n+            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n+                ct = proxy.getChangeTracker();\n+        }\n+\n+        // if no fine-grained change tracking then just delete and reinsert\n+        if (ct == null || !ct.isTracking()) {\n+            delete(sm, store, rm);\n+            insert(sm, store, rm, map);\n+            return;\n+        }\n+\n+        // delete the removes\n+        ValueMapping key = field.getKeyMapping();\n+        StoreContext ctx = store.getContext();\n+        Collection rem = ct.getRemoved();\n+        OpenJPAStateManager keysm;\n+        if (!rem.isEmpty()) {\n+            Row delRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_DELETE);\n+            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+                keysm = RelationStrategies.getStateManager(itr.next(), ctx);\n+                key.whereForeignKey(delRow, keysm);\n+                rm.flushSecondaryRow(delRow);\n+            }\n+        }\n+\n+        // insert the adds\n+        ValueMapping val = field.getElementMapping();\n+        Collection add = ct.getAdded();\n+        Object mkey;\n+        if (!add.isEmpty()) {\n+            Row addRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_INSERT);\n+            addRow.setForeignKey(field.getJoinForeignKey(),\n+                field.getJoinColumnIO(), sm);\n+\n+            for (Iterator itr = add.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                keysm = RelationStrategies.getStateManager(mkey, ctx);\n+                key.setForeignKey(addRow, keysm);\n+                HandlerStrategies.set(val, map.get(mkey), store, addRow,\n+                    _vcols, _vio, true);\n+                rm.flushSecondaryRow(addRow);\n+            }\n+        }\n+\n+        // update the changes\n+        Collection change = ct.getChanged();\n+        if (!change.isEmpty()) {\n+            Row changeRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_UPDATE);\n+            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                keysm = RelationStrategies.getStateManager(mkey, ctx);\n+                key.whereForeignKey(changeRow, keysm);\n+                HandlerStrategies.set(val, map.get(mkey), store, changeRow,\n+                    _vcols, _vio, true);\n+                rm.flushSecondaryRow(changeRow);\n+            }\n+        }\n+    }\n+\n+    public Joins joinRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        if (traverse)\n+            HandlerStrategies.assertJoinable(field.getElementMapping());\n+        return joins;\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        ValueMapping key = field.getKeyMapping();\n+        ClassMapping[] clss = key.getIndependentTypeMappings();\n+        if (clss.length != 1) {\n+            if (traverse)\n+                throw RelationStrategies.unjoinable(field.getKeyMapping());\n+            return joins;\n+        }\n+        if (forceOuter)\n+            return joins.outerJoinRelation(field.getName(),\n+                key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\n+                false, false);\n+        return joins.joinRelation(field.getName(),\n+            key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\n+            false, false);\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\n+            val, _vcols, store);\n+    }\n+\n+    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n+        return RelationStrategies.toDataStoreValue(field.getKeyMapping(), val,\n+            store);\n+    }\n+}"},{"sha":"d9bb92bccd6494fd4c62972e7c12c7e4bc846c1e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","status":"modified","additions":406,"deletions":406,"changes":812,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,406 +1,406 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.lib.util.*;\r\n-import org.apache.openjpa.meta.*;\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.util.*;\r\n-import org.apache.openjpa.enhance.PersistenceCapable;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-import org.apache.openjpa.jdbc.sql.*;\r\n-\r\n-/**\r\n- * <p>Mapping for a map whose keys and values are both relations to other\r\n- * persistent objects.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- */\r\n-public class RelationRelationMapTableFieldStrategy\r\n-    extends MapTableFieldStrategy {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (RelationRelationMapTableFieldStrategy.class);\r\n-\r\n-    private String _keyRelationName = null;\r\n-\r\n-    public Column[] getKeyColumns(ClassMapping cls) {\r\n-        return field.getKeyMapping().getColumns();\r\n-    }\r\n-\r\n-    public Column[] getValueColumns(ClassMapping cls) {\r\n-        return field.getElementMapping().getColumns();\r\n-    }\r\n-\r\n-    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\r\n-        sel.select(key, field.getKeyMapping().getSelectSubclasses(),\r\n-            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\r\n-    }\r\n-\r\n-    public void selectValue(Select sel, ClassMapping val,\r\n-        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \r\n-        Joins joins) {\r\n-        sel.select(val, field.getElementMapping().getSelectSubclasses(),\r\n-            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\r\n-    }\r\n-\r\n-    public Result[] getResults(final OpenJPAStateManager sm,\r\n-        final JDBCStore store, final JDBCFetchConfiguration fetch,\r\n-        final int eagerMode, final Joins[] resJoins, boolean lrs)\r\n-        throws SQLException {\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        final ClassMapping[] keys = key.getIndependentTypeMappings();\r\n-        Union kunion = store.getSQLFactory().newUnion(keys.length);\r\n-        if (fetch.getSubclassFetchMode(key.getTypeMapping())\r\n-            != JDBCFetchConfiguration.EAGER_JOIN)\r\n-            kunion.abortUnion();\r\n-        kunion.setLRS(lrs);\r\n-        kunion.select(new Union.Selector() {\r\n-            public void select(Select sel, int idx) {\r\n-                sel.whereForeignKey(field.getJoinForeignKey(),\r\n-                    sm.getObjectId(), field.getDefiningMapping(), store);\r\n-\r\n-                // order before select in case we're faking union with\r\n-                // multiple selects; order vals used to merge results\r\n-                Joins joins = joinKeyRelation(sel.newJoins(), keys[idx]);\r\n-                sel.orderBy(field.getKeyMapping().getColumns(), true, true);\r\n-                sel.select(keys[idx], field.getKeyMapping().\r\n-                    getSelectSubclasses(), store, fetch, eagerMode, joins);\r\n-\r\n-                //### cheat: result joins only care about the relation path;\r\n-                //### thus we can use first mapping of union only\r\n-                if (idx == 0)\r\n-                    resJoins[0] = joins;\r\n-            }\r\n-        });\r\n-\r\n-        ValueMapping val = field.getElementMapping();\r\n-        final ClassMapping[] vals = val.getIndependentTypeMappings();\r\n-        Union vunion = store.getSQLFactory().newUnion(vals.length);\r\n-        if (fetch.getSubclassFetchMode(val.getTypeMapping())\r\n-            != JDBCFetchConfiguration.EAGER_JOIN)\r\n-            vunion.abortUnion();\r\n-        vunion.setLRS(lrs);\r\n-        vunion.select(new Union.Selector() {\r\n-            public void select(Select sel, int idx) {\r\n-                sel.whereForeignKey(field.getJoinForeignKey(),\r\n-                    sm.getObjectId(), field.getDefiningMapping(), store);\r\n-\r\n-                // order before select in case we're faking union with\r\n-                // multiple selects; order vals used to merge results\r\n-                FieldMapping mapped = field.getMappedByMapping();\r\n-                Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\r\n-                sel.orderBy(field.getKeyMapping().getColumns(), true, true);\r\n-                sel.select(vals[idx], field.getElementMapping().\r\n-                    getSelectSubclasses(), store, fetch, eagerMode, joins);\r\n-\r\n-                //### cheat: result joins only care about the relation path;\r\n-                //### thus we can use first mapping of union only\r\n-                if (idx == 0)\r\n-                    resJoins[1] = joins;\r\n-            }\r\n-        });\r\n-\r\n-        Result kres = null;\r\n-        Result vres = null;\r\n-        try {\r\n-            kres = kunion.execute(store, fetch);\r\n-            vres = vunion.execute(store, fetch);\r\n-            return new Result[]{ kres, vres };\r\n-        } catch (SQLException se) {\r\n-            if (kres != null)\r\n-                kres.close();\r\n-            if (vres != null)\r\n-                vres.close();\r\n-            throw se;\r\n-        }\r\n-    }\r\n-\r\n-    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        ClassMapping key = res.getBaseMapping();\r\n-        if (key == null)\r\n-            key = field.getKeyMapping().getIndependentTypeMappings()[0];\r\n-        return res.load(key, store, fetch, joins);\r\n-    }\r\n-\r\n-    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        ClassMapping val = res.getBaseMapping();\r\n-        if (val == null)\r\n-            val = field.getElementMapping().getIndependentTypeMappings()[0];\r\n-        return res.load(val, store, fetch, joins);\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, ClassMapping key) {\r\n-        ValueMapping vm = field.getKeyMapping();\r\n-        return joins.joinRelation(_keyRelationName, vm.getForeignKey(key), key,\r\n-            vm.getSelectSubclasses(), false, false);\r\n-    }\r\n-\r\n-    public Joins joinValueRelation(Joins joins, ClassMapping val) {\r\n-        ValueMapping vm = field.getElementMapping();\r\n-        ForeignKey fk = vm.getForeignKey(val);\r\n-        if (fk == null)\r\n-            return joins;\r\n-        return joins.joinRelation(field.getName(), fk, val,\r\n-            vm.getSelectSubclasses(), false, false);\r\n-    }\r\n-\r\n-    public void map(boolean adapt) {\r\n-        super.map(adapt);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        if (key.getTypeCode() != JavaTypes.PC || key.isEmbeddedPC())\r\n-            throw new MetaDataException(_loc.get(\"not-relation\", key));\r\n-        ValueMapping val = field.getElementMapping();\r\n-        if (val.getTypeCode() != JavaTypes.PC || val.isEmbeddedPC())\r\n-            throw new MetaDataException(_loc.get(\"not-relation\", val));\r\n-        FieldMapping mapped = field.getMappedByMapping();\r\n-        DBDictionary dict = field.getMappingRepository().getDBDictionary();\r\n-        String keyName = null;\r\n-        if (mapped != null) {         \r\n-            handleMappedBy(adapt);\r\n-            keyName = dict.getValidColumnName(\"vkey\", field.getTable());\r\n-         } else {\r\n-            field.mapJoin(adapt, true);\r\n-            mapTypeJoin(val, \"value\", adapt);\r\n-            keyName = dict.getValidColumnName(\"key\", field.getTable());\r\n-        }\r\n-        mapTypeJoin(key, keyName, adapt);\r\n-\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    /**\r\n-     * Map the given value's join to its persistent type.\r\n-     */\r\n-    private void mapTypeJoin(ValueMapping vm, String name, boolean adapt) {\r\n-        if (vm.getTypeMapping().isMapped()) {\r\n-            ValueMappingInfo vinfo = vm.getValueInfo();\r\n-            ForeignKey fk = vinfo.getTypeJoin(vm, name, false, adapt);\r\n-            vm.setForeignKey(fk);\r\n-            vm.setColumnIO(vinfo.getColumnIO());\r\n-        } else\r\n-            RelationStrategies.mapRelationToUnmappedPC(vm, name, adapt);\r\n-        vm.mapConstraints(name, adapt);\r\n-    }\r\n-\r\n-    public void initialize() {\r\n-        _keyRelationName = field.getName() + \":key\";\r\n-    }\r\n-\r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        insert(sm, rm, (Map) sm.fetchObject(field.getIndex()), store);\r\n-    }\r\n-\r\n-    private void insert(OpenJPAStateManager sm, RowManager rm, Map map, \r\n-        JDBCStore store)\r\n-        throws SQLException {\r\n-        if (map == null || map.isEmpty())\r\n-            return;\r\n-        \r\n-        if (field.getMappedBy() != null)\r\n-            return;\r\n-\r\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\r\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\r\n-            sm);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ValueMapping val = field.getElementMapping();\r\n-        StoreContext ctx = sm.getContext();\r\n-        OpenJPAStateManager keysm, valsm;\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            keysm = RelationStrategies.getStateManager(entry.getKey(), ctx);\r\n-            valsm = RelationStrategies.getStateManager(entry.getValue(), ctx);\r\n-            key.setForeignKey(row, keysm);\r\n-            val.setForeignKey(row, valsm);\r\n-            \r\n-            // so far, we poplulated the key/value of each\r\n-            // map element owned by the entity.\r\n-            // In the case of ToMany, and both sides\r\n-            // use Map to represent the relation,\r\n-            // we need to populate the key value of the owner\r\n-            // from the view point of the owned side\r\n-            PersistenceCapable obj = sm.getPersistenceCapable();\r\n-            if (!populateKey(row, valsm, obj, ctx, rm, store))\r\n-                rm.flushSecondaryRow(row);\r\n-        }\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        if (field.getMappedBy() != null)\r\n-            return;\r\n-        \r\n-        Map map = (Map) sm.fetchObject(field.getIndex());\r\n-        ChangeTracker ct = null;\r\n-        if (map instanceof Proxy) {\r\n-            Proxy proxy = (Proxy) map;\r\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\r\n-                ct = proxy.getChangeTracker();\r\n-        }\r\n-\r\n-        // if no fine-grained change tracking then just delete and reinsert\r\n-        if (ct == null || !ct.isTracking()) {\r\n-            delete(sm, store, rm);\r\n-            insert(sm, rm, map, store);\r\n-            return;\r\n-        }\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ValueMapping val = field.getElementMapping();\r\n-        StoreContext ctx = store.getContext();\r\n-        OpenJPAStateManager keysm, valsm;\r\n-\r\n-        // update the changes; note that we have to featureSelection changes as\r\n-        // delete-then-insert if we have a foreign key action, because\r\n-        // secondary row updates aren't part of the constraint graph\r\n-        Collection change = ct.getChanged();\r\n-        boolean canChange = val.getForeignKey().isLogical();\r\n-        Object mkey;\r\n-        if (canChange && !change.isEmpty()) {\r\n-            Row changeRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_UPDATE);\r\n-            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                keysm = RelationStrategies.getStateManager(mkey, ctx);\r\n-                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\r\n-                key.whereForeignKey(changeRow, keysm);\r\n-                val.setForeignKey(changeRow, valsm);\r\n-                rm.flushSecondaryRow(changeRow);\r\n-            }\r\n-        }\r\n-\r\n-        // delete the removes\r\n-        Collection rem = ct.getRemoved();\r\n-        if (!rem.isEmpty() || (!canChange && !change.isEmpty())) {\r\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_DELETE);\r\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\r\n-                keysm = RelationStrategies.getStateManager(itr.next(), ctx);\r\n-                key.whereForeignKey(delRow, keysm);\r\n-                rm.flushSecondaryRow(delRow);\r\n-            }\r\n-            if (!canChange && !change.isEmpty()) {\r\n-                for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                    keysm = RelationStrategies.getStateManager(itr.next(),\r\n-                        ctx);\r\n-                    key.whereForeignKey(delRow, keysm);\r\n-                    rm.flushSecondaryRow(delRow);\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        // insert the adds\r\n-        Collection add = ct.getAdded();\r\n-        if (!add.isEmpty() || (!canChange && !change.isEmpty())) {\r\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_INSERT);\r\n-            addRow.setForeignKey(field.getJoinForeignKey(),\r\n-                field.getJoinColumnIO(), sm);\r\n-\r\n-            for (Iterator itr = add.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                keysm = RelationStrategies.getStateManager(mkey, ctx);\r\n-                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\r\n-                key.setForeignKey(addRow, keysm);\r\n-                val.setForeignKey(addRow, valsm);\r\n-                rm.flushSecondaryRow(addRow);\r\n-            }\r\n-            if (!canChange && !change.isEmpty()) {\r\n-                for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                    mkey = itr.next();\r\n-                    keysm = RelationStrategies.getStateManager(mkey, ctx);\r\n-                    valsm = RelationStrategies.getStateManager(map.get(mkey),\r\n-                        ctx);\r\n-                    key.setForeignKey(addRow, keysm);\r\n-                    val.setForeignKey(addRow, valsm);\r\n-                    rm.flushSecondaryRow(addRow);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        ValueMapping val = field.getElementMapping();\r\n-        ClassMapping[] clss = val.getIndependentTypeMappings();\r\n-        if (clss.length != 1) {\r\n-            if (traverse)\r\n-                throw RelationStrategies.unjoinable(val);\r\n-            return joins;\r\n-        }\r\n-        ForeignKey fk = val.getForeignKey(clss[0]);\r\n-        if (fk == null)\r\n-            return joins;\r\n-        if (forceOuter)\r\n-            return joins.outerJoinRelation(field.getName(),\r\n-                fk, clss[0], val.getSelectSubclasses(),\r\n-                false, false);\r\n-        return joins.joinRelation(field.getName(),\r\n-            fk, clss[0], val.getSelectSubclasses(),\r\n-            false, false);\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ClassMapping[] clss = key.getIndependentTypeMappings();\r\n-        if (clss.length != 1) {\r\n-            if (traverse)\r\n-                throw RelationStrategies.unjoinable(key);\r\n-            return joins;\r\n-        }\r\n-        if (forceOuter)\r\n-            return joins.outerJoinRelation(field.getName(),\r\n-                key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\r\n-                false, false);\r\n-        return joins.joinRelation(_keyRelationName,\r\n-            key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(), \r\n-            false, false);\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\r\n-        return RelationStrategies.toDataStoreValue(field.getElementMapping(),\r\n-            val, store);\r\n-    }\r\n-\r\n-    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\r\n-        return RelationStrategies.toDataStoreValue(field.getKeyMapping(),\r\n-            val, store);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.meta.*;\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.util.*;\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.*;\n+\n+/**\n+ * <p>Mapping for a map whose keys and values are both relations to other\n+ * persistent objects.</p>\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ */\n+public class RelationRelationMapTableFieldStrategy\n+    extends MapTableFieldStrategy {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (RelationRelationMapTableFieldStrategy.class);\n+\n+    private String _keyRelationName = null;\n+\n+    public Column[] getKeyColumns(ClassMapping cls) {\n+        return field.getKeyMapping().getColumns();\n+    }\n+\n+    public Column[] getValueColumns(ClassMapping cls) {\n+        return field.getElementMapping().getColumns();\n+    }\n+\n+    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+        sel.select(key, field.getKeyMapping().getSelectSubclasses(),\n+            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\n+    }\n+\n+    public void selectValue(Select sel, ClassMapping val,\n+        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \n+        Joins joins) {\n+        sel.select(val, field.getElementMapping().getSelectSubclasses(),\n+            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\n+    }\n+\n+    public Result[] getResults(final OpenJPAStateManager sm,\n+        final JDBCStore store, final JDBCFetchConfiguration fetch,\n+        final int eagerMode, final Joins[] resJoins, boolean lrs)\n+        throws SQLException {\n+        ValueMapping key = field.getKeyMapping();\n+        final ClassMapping[] keys = key.getIndependentTypeMappings();\n+        Union kunion = store.getSQLFactory().newUnion(keys.length);\n+        if (fetch.getSubclassFetchMode(key.getTypeMapping())\n+            != JDBCFetchConfiguration.EAGER_JOIN)\n+            kunion.abortUnion();\n+        kunion.setLRS(lrs);\n+        kunion.select(new Union.Selector() {\n+            public void select(Select sel, int idx) {\n+                sel.whereForeignKey(field.getJoinForeignKey(),\n+                    sm.getObjectId(), field.getDefiningMapping(), store);\n+\n+                // order before select in case we're faking union with\n+                // multiple selects; order vals used to merge results\n+                Joins joins = joinKeyRelation(sel.newJoins(), keys[idx]);\n+                sel.orderBy(field.getKeyMapping().getColumns(), true, true);\n+                sel.select(keys[idx], field.getKeyMapping().\n+                    getSelectSubclasses(), store, fetch, eagerMode, joins);\n+\n+                //### cheat: result joins only care about the relation path;\n+                //### thus we can use first mapping of union only\n+                if (idx == 0)\n+                    resJoins[0] = joins;\n+            }\n+        });\n+\n+        ValueMapping val = field.getElementMapping();\n+        final ClassMapping[] vals = val.getIndependentTypeMappings();\n+        Union vunion = store.getSQLFactory().newUnion(vals.length);\n+        if (fetch.getSubclassFetchMode(val.getTypeMapping())\n+            != JDBCFetchConfiguration.EAGER_JOIN)\n+            vunion.abortUnion();\n+        vunion.setLRS(lrs);\n+        vunion.select(new Union.Selector() {\n+            public void select(Select sel, int idx) {\n+                sel.whereForeignKey(field.getJoinForeignKey(),\n+                    sm.getObjectId(), field.getDefiningMapping(), store);\n+\n+                // order before select in case we're faking union with\n+                // multiple selects; order vals used to merge results\n+                FieldMapping mapped = field.getMappedByMapping();\n+                Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\n+                sel.orderBy(field.getKeyMapping().getColumns(), true, true);\n+                sel.select(vals[idx], field.getElementMapping().\n+                    getSelectSubclasses(), store, fetch, eagerMode, joins);\n+\n+                //### cheat: result joins only care about the relation path;\n+                //### thus we can use first mapping of union only\n+                if (idx == 0)\n+                    resJoins[1] = joins;\n+            }\n+        });\n+\n+        Result kres = null;\n+        Result vres = null;\n+        try {\n+            kres = kunion.execute(store, fetch);\n+            vres = vunion.execute(store, fetch);\n+            return new Result[]{ kres, vres };\n+        } catch (SQLException se) {\n+            if (kres != null)\n+                kres.close();\n+            if (vres != null)\n+                vres.close();\n+            throw se;\n+        }\n+    }\n+\n+    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        ClassMapping key = res.getBaseMapping();\n+        if (key == null)\n+            key = field.getKeyMapping().getIndependentTypeMappings()[0];\n+        return res.load(key, store, fetch, joins);\n+    }\n+\n+    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        ClassMapping val = res.getBaseMapping();\n+        if (val == null)\n+            val = field.getElementMapping().getIndependentTypeMappings()[0];\n+        return res.load(val, store, fetch, joins);\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, ClassMapping key) {\n+        ValueMapping vm = field.getKeyMapping();\n+        return joins.joinRelation(_keyRelationName, vm.getForeignKey(key), key,\n+            vm.getSelectSubclasses(), false, false);\n+    }\n+\n+    public Joins joinValueRelation(Joins joins, ClassMapping val) {\n+        ValueMapping vm = field.getElementMapping();\n+        ForeignKey fk = vm.getForeignKey(val);\n+        if (fk == null)\n+            return joins;\n+        return joins.joinRelation(field.getName(), fk, val,\n+            vm.getSelectSubclasses(), false, false);\n+    }\n+\n+    public void map(boolean adapt) {\n+        super.map(adapt);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        if (key.getTypeCode() != JavaTypes.PC || key.isEmbeddedPC())\n+            throw new MetaDataException(_loc.get(\"not-relation\", key));\n+        ValueMapping val = field.getElementMapping();\n+        if (val.getTypeCode() != JavaTypes.PC || val.isEmbeddedPC())\n+            throw new MetaDataException(_loc.get(\"not-relation\", val));\n+        FieldMapping mapped = field.getMappedByMapping();\n+        DBDictionary dict = field.getMappingRepository().getDBDictionary();\n+        String keyName = null;\n+        if (mapped != null) {         \n+            handleMappedBy(adapt);\n+            keyName = dict.getValidColumnName(\"vkey\", field.getTable());\n+         } else {\n+            field.mapJoin(adapt, true);\n+            mapTypeJoin(val, \"value\", adapt);\n+            keyName = dict.getValidColumnName(\"key\", field.getTable());\n+        }\n+        mapTypeJoin(key, keyName, adapt);\n+\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    /**\n+     * Map the given value's join to its persistent type.\n+     */\n+    private void mapTypeJoin(ValueMapping vm, String name, boolean adapt) {\n+        if (vm.getTypeMapping().isMapped()) {\n+            ValueMappingInfo vinfo = vm.getValueInfo();\n+            ForeignKey fk = vinfo.getTypeJoin(vm, name, false, adapt);\n+            vm.setForeignKey(fk);\n+            vm.setColumnIO(vinfo.getColumnIO());\n+        } else\n+            RelationStrategies.mapRelationToUnmappedPC(vm, name, adapt);\n+        vm.mapConstraints(name, adapt);\n+    }\n+\n+    public void initialize() {\n+        _keyRelationName = field.getName() + \":key\";\n+    }\n+\n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        insert(sm, rm, (Map) sm.fetchObject(field.getIndex()), store);\n+    }\n+\n+    private void insert(OpenJPAStateManager sm, RowManager rm, Map map, \n+        JDBCStore store)\n+        throws SQLException {\n+        if (map == null || map.isEmpty())\n+            return;\n+        \n+        if (field.getMappedBy() != null)\n+            return;\n+\n+        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+            sm);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        StoreContext ctx = sm.getContext();\n+        OpenJPAStateManager keysm, valsm;\n+        Map.Entry entry;\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            keysm = RelationStrategies.getStateManager(entry.getKey(), ctx);\n+            valsm = RelationStrategies.getStateManager(entry.getValue(), ctx);\n+            key.setForeignKey(row, keysm);\n+            val.setForeignKey(row, valsm);\n+            \n+            // so far, we poplulated the key/value of each\n+            // map element owned by the entity.\n+            // In the case of ToMany, and both sides\n+            // use Map to represent the relation,\n+            // we need to populate the key value of the owner\n+            // from the view point of the owned side\n+            PersistenceCapable obj = sm.getPersistenceCapable();\n+            if (!populateKey(row, valsm, obj, ctx, rm, store))\n+                rm.flushSecondaryRow(row);\n+        }\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        if (field.getMappedBy() != null)\n+            return;\n+        \n+        Map map = (Map) sm.fetchObject(field.getIndex());\n+        ChangeTracker ct = null;\n+        if (map instanceof Proxy) {\n+            Proxy proxy = (Proxy) map;\n+            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n+                ct = proxy.getChangeTracker();\n+        }\n+\n+        // if no fine-grained change tracking then just delete and reinsert\n+        if (ct == null || !ct.isTracking()) {\n+            delete(sm, store, rm);\n+            insert(sm, rm, map, store);\n+            return;\n+        }\n+\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        StoreContext ctx = store.getContext();\n+        OpenJPAStateManager keysm, valsm;\n+\n+        // update the changes; note that we have to featureSelection changes as\n+        // delete-then-insert if we have a foreign key action, because\n+        // secondary row updates aren't part of the constraint graph\n+        Collection change = ct.getChanged();\n+        boolean canChange = val.getForeignKey().isLogical();\n+        Object mkey;\n+        if (canChange && !change.isEmpty()) {\n+            Row changeRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_UPDATE);\n+            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                keysm = RelationStrategies.getStateManager(mkey, ctx);\n+                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n+                key.whereForeignKey(changeRow, keysm);\n+                val.setForeignKey(changeRow, valsm);\n+                rm.flushSecondaryRow(changeRow);\n+            }\n+        }\n+\n+        // delete the removes\n+        Collection rem = ct.getRemoved();\n+        if (!rem.isEmpty() || (!canChange && !change.isEmpty())) {\n+            Row delRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_DELETE);\n+            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+                keysm = RelationStrategies.getStateManager(itr.next(), ctx);\n+                key.whereForeignKey(delRow, keysm);\n+                rm.flushSecondaryRow(delRow);\n+            }\n+            if (!canChange && !change.isEmpty()) {\n+                for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                    keysm = RelationStrategies.getStateManager(itr.next(),\n+                        ctx);\n+                    key.whereForeignKey(delRow, keysm);\n+                    rm.flushSecondaryRow(delRow);\n+                }\n+            }\n+        }\n+\n+        // insert the adds\n+        Collection add = ct.getAdded();\n+        if (!add.isEmpty() || (!canChange && !change.isEmpty())) {\n+            Row addRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_INSERT);\n+            addRow.setForeignKey(field.getJoinForeignKey(),\n+                field.getJoinColumnIO(), sm);\n+\n+            for (Iterator itr = add.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                keysm = RelationStrategies.getStateManager(mkey, ctx);\n+                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n+                key.setForeignKey(addRow, keysm);\n+                val.setForeignKey(addRow, valsm);\n+                rm.flushSecondaryRow(addRow);\n+            }\n+            if (!canChange && !change.isEmpty()) {\n+                for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                    mkey = itr.next();\n+                    keysm = RelationStrategies.getStateManager(mkey, ctx);\n+                    valsm = RelationStrategies.getStateManager(map.get(mkey),\n+                        ctx);\n+                    key.setForeignKey(addRow, keysm);\n+                    val.setForeignKey(addRow, valsm);\n+                    rm.flushSecondaryRow(addRow);\n+                }\n+            }\n+        }\n+    }\n+\n+    public Joins joinRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        ValueMapping val = field.getElementMapping();\n+        ClassMapping[] clss = val.getIndependentTypeMappings();\n+        if (clss.length != 1) {\n+            if (traverse)\n+                throw RelationStrategies.unjoinable(val);\n+            return joins;\n+        }\n+        ForeignKey fk = val.getForeignKey(clss[0]);\n+        if (fk == null)\n+            return joins;\n+        if (forceOuter)\n+            return joins.outerJoinRelation(field.getName(),\n+                fk, clss[0], val.getSelectSubclasses(),\n+                false, false);\n+        return joins.joinRelation(field.getName(),\n+            fk, clss[0], val.getSelectSubclasses(),\n+            false, false);\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        ValueMapping key = field.getKeyMapping();\n+        ClassMapping[] clss = key.getIndependentTypeMappings();\n+        if (clss.length != 1) {\n+            if (traverse)\n+                throw RelationStrategies.unjoinable(key);\n+            return joins;\n+        }\n+        if (forceOuter)\n+            return joins.outerJoinRelation(field.getName(),\n+                key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\n+                false, false);\n+        return joins.joinRelation(_keyRelationName,\n+            key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(), \n+            false, false);\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return RelationStrategies.toDataStoreValue(field.getElementMapping(),\n+            val, store);\n+    }\n+\n+    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n+        return RelationStrategies.toDataStoreValue(field.getKeyMapping(),\n+            val, store);\n+    }\n+}"},{"sha":"aad556e2ad2bc4882b6738a87602c2731d8aee9f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","status":"modified","additions":854,"deletions":854,"changes":1708,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,854 +1,854 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.sql;\r\n-\r\n-import java.lang.reflect.Method;\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.SQLException;\r\n-import java.sql.Types;\r\n-import java.util.Arrays;\r\n-import java.util.Set;\r\n-import java.util.StringTokenizer;\r\n-\r\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\r\n-import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\r\n-import org.apache.openjpa.jdbc.kernel.exps.Lit;\r\n-import org.apache.openjpa.jdbc.kernel.exps.Param;\r\n-import org.apache.openjpa.jdbc.kernel.exps.Val;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.schema.Index;\r\n-import org.apache.openjpa.jdbc.schema.Schema;\r\n-import org.apache.openjpa.jdbc.schema.Sequence;\r\n-import org.apache.openjpa.jdbc.schema.Table;\r\n-import org.apache.openjpa.kernel.Filters;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.util.OpenJPAException;\r\n-import org.apache.openjpa.util.StoreException;\r\n-import org.apache.openjpa.util.UnsupportedException;\r\n-\r\n-import serp.util.Strings;\r\n-\r\n-/**\r\n- * Dictionary for IBM DB2 database.\r\n- */\r\n-public class DB2Dictionary\r\n-    extends AbstractDB2Dictionary {\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (DB2Dictionary.class);\r\n-\r\n-    public String optimizeClause = \"optimize for\";\r\n-    public String rowClause = \"row\";\r\n-    protected int db2ServerType = 0;\r\n-    public static final int db2ISeriesV5R3OrEarlier = 1;\r\n-    public static final int db2UDBV81OrEarlier = 2;\r\n-    public static final int db2ZOSV8xOrLater = 3;\r\n-    public static final int db2UDBV82OrLater = 4;\r\n-    public static final int db2ISeriesV5R4OrLater = 5;\r\n-\tprotected static final String forUpdate = \"FOR UPDATE\";\r\n-    protected static final String withURClause = \"WITH UR\";\r\n-    protected static final String withCSClause = \"WITH CS\";\r\n-    protected static final String withRSClause = \"WITH RS\";\r\n-    protected static final String withRRClause = \"WITH RR\";\r\n-    protected static final String useKeepShareLockClause\r\n-        = \"USE AND KEEP SHARE LOCKS\";\r\n-    protected static final String useKeepUpdateLockClause\r\n-        = \"USE AND KEEP UPDATE LOCKS\";\r\n-    protected static final String useKeepExclusiveLockClause\r\n-        = \"USE AND KEEP EXCLUSIVE LOCKS\";\r\n-    protected static final String forReadOnlyClause = \"FOR READ ONLY\";\r\n-    protected String databaseProductName = \"\";\r\n-    protected String databaseProductVersion = \"\";\r\n-    protected int maj = 0;\r\n-    protected int min = 0;\r\n-    \r\n-    private int defaultBatchLimit = 100;\r\n-\r\n-    public DB2Dictionary() {\r\n-        platform = \"DB2\";\r\n-        validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\r\n-            + \"SYSIBM.SYSTABLES\";\r\n-        supportsSelectEndIndex = true;\r\n-\r\n-        nextSequenceQuery = \"VALUES NEXTVAL FOR {0}\";\r\n-\r\n-        sequenceSQL = \"SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, \"\r\n-            + \"SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES\";\r\n-        sequenceSchemaSQL = \"SEQSCHEMA = ?\";\r\n-        sequenceNameSQL = \"SEQNAME = ?\";\r\n-        characterColumnSize = 254;\r\n-\r\n-        binaryTypeName = \"BLOB(1M)\";\r\n-        longVarbinaryTypeName = \"BLOB(1M)\";\r\n-        varbinaryTypeName = \"BLOB(1M)\";\r\n-        clobTypeName = \"CLOB(1M)\";\r\n-        longVarcharTypeName = \"LONG VARCHAR\";\r\n-        datePrecision = MICRO;\r\n-        storeCharsAsNumbers = false;\r\n-\r\n-        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\r\n-            \"LONG VARCHAR FOR BIT DATA\", \"LONG VARCHAR\", \"LONG VARGRAPHIC\",\r\n-        }));\r\n-        systemSchemas = new String(\r\n-                \"SYSCAT,SYSIBM,SYSSTAT,SYSIBMADM,SYSTOOLS\");\r\n-        maxConstraintNameLength = 18;\r\n-        maxIndexNameLength = 18;\r\n-        maxColumnNameLength = 30;\r\n-        supportsDeferredConstraints = false;\r\n-        supportsDefaultDeleteAction = false;\r\n-        supportsAlterTableWithDropColumn = false;\r\n-\r\n-        supportsNullTableForGetColumns = false;\r\n-        requiresCastForMathFunctions = true;\r\n-        requiresCastForComparisons = true;\r\n-\r\n-        reservedWordSet.addAll(Arrays.asList(new String[]{\r\n-            \"AFTER\", \"ALIAS\", \"ALLOW\", \"APPLICATION\", \"ASSOCIATE\", \"ASUTIME\",\r\n-            \"AUDIT\", \"AUX\", \"AUXILIARY\", \"BEFORE\", \"BINARY\", \"BUFFERPOOL\",\r\n-            \"CACHE\", \"CALL\", \"CALLED\", \"CAPTURE\", \"CARDINALITY\", \"CCSID\",\r\n-            \"CLUSTER\", \"COLLECTION\", \"COLLID\", \"COMMENT\", \"CONCAT\",\r\n-            \"CONDITION\", \"CONTAINS\", \"COUNT_BIG\", \"CURRENT_LC_CTYPE\",\r\n-            \"CURRENT_PATH\", \"CURRENT_SERVER\", \"CURRENT_TIMEZONE\", \"CYCLE\",\r\n-            \"DATA\", \"DATABASE\", \"DAYS\", \"DB2GENERAL\", \"DB2GENRL\", \"DB2SQL\",\r\n-            \"DBINFO\", \"DEFAULTS\", \"DEFINITION\", \"DETERMINISTIC\", \"DISALLOW\",\r\n-            \"DO\", \"DSNHATTR\", \"DSSIZE\", \"DYNAMIC\", \"EACH\", \"EDITPROC\", \"ELSEIF\",\r\n-            \"ENCODING\", \"END-EXEC1\", \"ERASE\", \"EXCLUDING\", \"EXIT\", \"FENCED\",\r\n-            \"FIELDPROC\", \"FILE\", \"FINAL\", \"FREE\", \"FUNCTION\", \"GENERAL\",\r\n-            \"GENERATED\", \"GRAPHIC\", \"HANDLER\", \"HOLD\", \"HOURS\", \"IF\",\r\n-            \"INCLUDING\", \"INCREMENT\", \"INDEX\", \"INHERIT\", \"INOUT\", \"INTEGRITY\",\r\n-            \"ISOBID\", \"ITERATE\", \"JAR\", \"JAVA\", \"LABEL\", \"LC_CTYPE\", \"LEAVE\",\r\n-            \"LINKTYPE\", \"LOCALE\", \"LOCATOR\", \"LOCATORS\", \"LOCK\", \"LOCKMAX\",\r\n-            \"LOCKSIZE\", \"LONG\", \"LOOP\", \"MAXVALUE\", \"MICROSECOND\",\r\n-            \"MICROSECONDS\", \"MINUTES\", \"MINVALUE\", \"MODE\", \"MODIFIES\", \"MONTHS\",\r\n-            \"NEW\", \"NEW_TABLE\", \"NOCACHE\", \"NOCYCLE\", \"NODENAME\", \"NODENUMBER\",\r\n-            \"NOMAXVALUE\", \"NOMINVALUE\", \"NOORDER\", \"NULLS\", \"NUMPARTS\", \"OBID\",\r\n-            \"OLD\", \"OLD_TABLE\", \"OPTIMIZATION\", \"OPTIMIZE\", \"OUT\", \"OVERRIDING\",\r\n-            \"PACKAGE\", \"PARAMETER\", \"PART\", \"PARTITION\", \"PATH\", \"PIECESIZE\",\r\n-            \"PLAN\", \"PRIQTY\", \"PROGRAM\", \"PSID\", \"QUERYNO\", \"READS\", \"RECOVERY\",\r\n-            \"REFERENCING\", \"RELEASE\", \"RENAME\", \"REPEAT\", \"RESET\", \"RESIGNAL\",\r\n-            \"RESTART\", \"RESULT\", \"RESULT_SET_LOCATOR\", \"RETURN\", \"RETURNS\",\r\n-            \"ROUTINE\", \"ROW\", \"RRN\", \"RUN\", \"SAVEPOINT\", \"SCRATCHPAD\",\r\n-            \"SECONDS\", \"SECQTY\", \"SECURITY\", \"SENSITIVE\", \"SIGNAL\", \"SIMPLE\",\r\n-            \"SOURCE\", \"SPECIFIC\", \"SQLID\", \"STANDARD\", \"START\", \"STATIC\",\r\n-            \"STAY\", \"STOGROUP\", \"STORES\", \"STYLE\", \"SUBPAGES\", \"SYNONYM\",\r\n-            \"SYSFUN\", \"SYSIBM\", \"SYSPROC\", \"SYSTEM\", \"TABLESPACE\", \"TRIGGER\",\r\n-            \"TYPE\", \"UNDO\", \"UNTIL\", \"VALIDPROC\", \"VARIABLE\", \"VARIANT\", \"VCAT\",\r\n-            \"VOLUMES\", \"WHILE\", \"WLM\", \"YEARS\",\r\n-        }));\r\n-        \r\n-        super.setBatchLimit(defaultBatchLimit);\r\n-        \r\n-        selectWordSet.add(\"WITH\");\r\n-    }\r\n-\r\n-    public boolean supportsRandomAccessResultSet(Select sel,\r\n-        boolean forUpdate) {\r\n-        return !forUpdate\r\n-            && super.supportsRandomAccessResultSet(sel, forUpdate);\r\n-    }\r\n-\r\n-    protected void appendSelectRange(SQLBuffer buf, long start, long end,\r\n-        boolean subselect) {\r\n-        // appends the literal range string, since DB2 is unable to handle\r\n-        // a bound parameter for it\r\n-        // do not generate FETCH FIRST clause for subselect\r\n-        if (!subselect)\r\n-            buf.append(\" FETCH FIRST \").append(Long.toString(end)).\r\n-                append(\" ROWS ONLY\");\r\n-    }\r\n-\r\n-    protected void appendSelect(SQLBuffer selectSQL, Object alias, Select sel,\r\n-        int idx) {\r\n-        // if this is a literal value, add a cast...\r\n-        Object val = sel.getSelects().get(idx);\r\n-        if (val instanceof Lit)\r\n-            selectSQL.append(\"CAST(\");\r\n-\r\n-        // ... and add the select per super's behavior...\r\n-        super.appendSelect(selectSQL, alias, sel, idx);\r\n-\r\n-        // ... and finish the cast\r\n-        if (val instanceof Lit) {\r\n-            Class c = ((Lit) val).getType();\r\n-            int javaTypeCode = JavaTypes.getTypeCode(c);\r\n-            int jdbcTypeCode = getJDBCType(javaTypeCode, false);\r\n-            String typeName = getTypeName(jdbcTypeCode);\r\n-            selectSQL.append(\" AS \" + typeName);\r\n-\r\n-            // if the literal is a string, use the default char col size\r\n-            // in the cast statement.\r\n-            if (String.class.equals(c))\r\n-                selectSQL.append(\"(\" + characterColumnSize + \")\");\r\n-\r\n-            selectSQL.append(\")\");\r\n-        }\r\n-    }\r\n-\r\n-    public String[] getCreateSequenceSQL(Sequence seq) {\r\n-        String[] sql = super.getCreateSequenceSQL(seq);\r\n-        if (seq.getAllocate() > 1)\r\n-            sql[0] += \" CACHE \" + seq.getAllocate();\r\n-        return sql;\r\n-    }\r\n-\r\n-    protected String getSequencesSQL(String schemaName, String sequenceName) {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        buf.append(sequenceSQL);\r\n-        if (schemaName != null || sequenceName != null)\r\n-            buf.append(\" WHERE \");\r\n-        if (schemaName != null) {\r\n-            buf.append(sequenceSchemaSQL);\r\n-            if (sequenceName != null)\r\n-                buf.append(\" AND \");\r\n-        }\r\n-        if (sequenceName != null)\r\n-            buf.append(sequenceNameSQL);\r\n-        return buf.toString();\r\n-    }\r\n-\r\n-    public Connection decorate(Connection conn)\r\n-        throws SQLException {\r\n-        // some versions of the DB2 driver seem to default to\r\n-        // READ_UNCOMMITTED, which will prevent locking from working\r\n-        // (multiple SELECT ... FOR UPDATE statements are allowed on\r\n-        // the same instance); if we have not overridden the\r\n-        // transaction isolation in the configuration, default to\r\n-        // TRANSACTION_READ_COMMITTED\r\n-        conn = super.decorate(conn);\r\n-\r\n-        if (conf.getTransactionIsolationConstant() == -1\r\n-            && conn.getTransactionIsolation() < Connection.TRANSACTION_READ_COMMITTED)\r\n-            conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\r\n-\r\n-        return conn;\r\n-    }\r\n-\r\n-    public void connectedConfiguration(Connection conn) throws SQLException {\r\n-    \tsuper.connectedConfiguration(conn);\r\n-\r\n-    \tDatabaseMetaData metaData = conn.getMetaData();\r\n-        databaseProductName = nullSafe(metaData.getDatabaseProductName());\r\n-        databaseProductVersion = nullSafe(metaData.getDatabaseProductVersion());\r\n-        \r\n-        // Determine the type of DB2 database\r\n-        // First check for AS/400\r\n-        getProductVersionMajorMinorForISeries();\r\n-\r\n-        if (maj > 0) {\r\n-            if (isDB2ISeriesV5R3OrEarlier())\r\n-                db2ServerType = db2ISeriesV5R3OrEarlier;\r\n-            else if (isDB2ISeriesV5R4OrLater())\r\n-                db2ServerType = db2ISeriesV5R4OrLater;\r\n-        }\r\n-        \r\n-    \tif (db2ServerType == 0) {\r\n-    \t    if (isJDBC3) {\r\n-    \t        maj = metaData.getDatabaseMajorVersion();\r\n-    \t        min = metaData.getDatabaseMinorVersion();\r\n-    \t    }\r\n-    \t    else\r\n-    \t        getProductVersionMajorMinor();\r\n-\r\n-    \t    // Determine the type of DB2 database for ZOS & UDB\r\n-    \t    if (isDB2UDBV81OrEarlier())\r\n-    \t        db2ServerType = db2UDBV81OrEarlier;\r\n-    \t    else if (isDB2ZOSV8xOrLater())\r\n-    \t        db2ServerType = db2ZOSV8xOrLater;\r\n-    \t    else if (isDB2UDBV82OrLater())\r\n-    \t        db2ServerType = db2UDBV82OrLater;\r\n-        }\r\n-\r\n-        // verify that database product is supported\r\n-        if (db2ServerType == 0 || maj == 0)\r\n-            throw new UnsupportedException(_loc.get(\"db-not-supported\",\r\n-                new Object[] {databaseProductName, databaseProductVersion }));                    \r\n-\r\n-    \tif (maj >= 9 || (maj == 8 && min >= 2)) {\r\n-    \t    supportsLockingWithMultipleTables = true;\r\n-    \t    supportsLockingWithInnerJoin = true;\r\n-    \t    supportsLockingWithOuterJoin = true;\r\n-    \t    forUpdateClause = \"WITH RR USE AND KEEP UPDATE LOCKS\";\r\n-    \t    if (maj >=9)\r\n-    \t        supportsXMLColumn = true;\r\n-    \t}\r\n-\r\n-        // platform specific settings\r\n-        switch (db2ServerType) {\r\n-        case db2UDBV82OrLater:\r\n-            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            break;\r\n-        case  db2ZOSV8xOrLater:\r\n-            // DB2 Z/OS \r\n-            characterColumnSize = 255;\r\n-            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            sequenceSQL = \"SELECT SCHEMA AS SEQUENCE_SCHEMA, \"\r\n-                + \"NAME AS SEQUENCE_NAME FROM SYSIBM.SYSSEQUENCES\";\r\n-            sequenceSchemaSQL = \"SCHEMA = ?\";\r\n-            sequenceNameSQL = \"NAME = ?\";\r\n-            if (maj == 8)\r\n-                // DB2 Z/OS Version 8: no bigint support, hence map Java\r\n-                // long to decimal\r\n-                bigintTypeName = \"DECIMAL(31,0)\";\r\n-            break;\r\n-        case db2ISeriesV5R3OrEarlier:\r\n-        case db2ISeriesV5R4OrLater:\r\n-            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\r\n-                + \"QSYS2.SYSTABLES\";\r\n-            sequenceSQL = \"SELECT SEQUENCE_SCHEMA, \"\r\n-                + \"SEQUENCE_NAME FROM QSYS2.SYSSEQUENCES\";\r\n-            sequenceSchemaSQL = \"SEQUENCE_SCHEMA = ?\";\r\n-            sequenceNameSQL = \"SEQUENCE_NAME = ?\";\r\n-            break;\r\n-        }\r\n-    }\r\n-\r\n-    public boolean supportsIsolationForUpdate() {\r\n-        return true;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get the update clause for the query based on the\r\n-     * updateClause and isolationLevel hints\r\n-     */\r\n-    protected String getForUpdateClause(JDBCFetchConfiguration fetch,\r\n-        boolean isForUpdate, Select sel) {\r\n-        int isolationLevel;\r\n-        // For db2UDBV81OrEarlier and db2ISeriesV5R3OrEarlier:\r\n-        // \"optimize for\" clause appears before \"for update\" clause.\r\n-        StringBuffer forUpdateString = new StringBuffer(getOptimizeClause(sel));\r\n-        // Determine the isolationLevel; the fetch\r\n-        // configuration data overrides the persistence.xml value\r\n-        if (fetch != null && fetch.getIsolation() != -1)\r\n-            isolationLevel = fetch.getIsolation();\r\n-        else\r\n-            isolationLevel = conf.getTransactionIsolationConstant();\r\n-\r\n-        if (isForUpdate) {\r\n-            switch (db2ServerType) {\r\n-            case db2ISeriesV5R3OrEarlier:\r\n-            case db2UDBV81OrEarlier:\r\n-                if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE)\r\n-                    forUpdateString.append(\" \").append(forUpdateClause);\r\n-                else\r\n-                    forUpdateString.append(\" \").append(forUpdate).append(\" \")\r\n-                        .append(withRSClause);\r\n-                break;\r\n-            case db2ZOSV8xOrLater:\r\n-            case db2UDBV82OrLater:\r\n-                if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\r\n-                    forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                        .append(\" \").append(withRRClause).append(\" \").append(\r\n-                            useKeepUpdateLockClause);\r\n-                } else {\r\n-                    forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                        .append(\" \").append(withRSClause).append(\" \").append(\r\n-                            useKeepUpdateLockClause);\r\n-                }\r\n-                break;\r\n-            case db2ISeriesV5R4OrLater:\r\n-                if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\r\n-                    forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                        .append(\" \").append(withRRClause).append(\" \").append(\r\n-                            useKeepExclusiveLockClause);\r\n-                } else {\r\n-                    forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                        .append(\" \").append(withRSClause).append(\" \").append(\r\n-                            useKeepExclusiveLockClause);\r\n-                }\r\n-                break;\r\n-            }\r\n-        }\r\n-   \r\n-        return forUpdateString.toString();\r\n-    }\r\n-\r\n-    public boolean isDB2UDBV82OrLater() {\r\n-        return (databaseProductVersion.indexOf(\"SQL\") != -1\r\n-             || databaseProductName.indexOf(\"DB2/\") != -1)\r\n-             && ((maj == 8 && min >= 2) || (maj >= 9));\r\n-    }\r\n-\r\n-    public boolean isDB2ZOSV8xOrLater() {\r\n-       return (databaseProductVersion.indexOf(\"DSN\") != -1\r\n-            || databaseProductName.indexOf(\"DB2/\") == -1)\r\n-            && maj >= 8;\r\n-           \r\n-    }\r\n-\r\n-    public boolean isDB2ISeriesV5R3OrEarlier() {\r\n-       return (databaseProductName.indexOf(\"AS\") != -1\r\n-           && ((maj == 5 && min <=3) || maj < 5));\r\n-    }\r\n-\r\n-    public boolean isDB2ISeriesV5R4OrLater() {\r\n-       return databaseProductName.indexOf(\"AS\") != -1\r\n-           && (maj >=6 || (maj == 5 && min >=4));\r\n-    }\r\n-\r\n-    public boolean isDB2UDBV81OrEarlier() {\r\n-        return (databaseProductVersion.indexOf(\"SQL\") != -1 \r\n-            || databaseProductName.indexOf(\"DB2/\") != -1) \r\n-            && ((maj == 8 && min <= 1) || maj < 8);\r\n-    }\r\n-\r\n-    /** Get the version Major/Minor for the ISeries\r\n-     */\r\n-    private void getProductVersionMajorMinorForISeries() {\r\n-        // ISeries    DBProdName                 DB2 UDB for AS/400\r\n-        //   (Toolbox)DBProdVersion              05.04.0000 V5R4m0\r\n-        // ISeries                               DB2 UDB for AS/400\r\n-        //   (Native)                            V5R4M0\r\n-        // new jcc    DBProdVersion              QSQ05040 or QSQ06010\r\n-        if (databaseProductName.indexOf(\"AS\") != -1) {\r\n-            // default to V5R4\r\n-            maj = 5;\r\n-            min = 4;\r\n-            int index = databaseProductVersion.indexOf('V');\r\n-            if (index != -1) {\r\n-                String s = databaseProductVersion.substring(index);\r\n-                s = s.toUpperCase();\r\n-\r\n-                StringTokenizer stringtokenizer = new StringTokenizer(s, \"VRM\"\r\n-                    , false);\r\n-                if (stringtokenizer.countTokens() == 3) {\r\n-                    String s1 = stringtokenizer.nextToken();\r\n-                    maj = Integer.parseInt(s1);\r\n-                    String s2 =  stringtokenizer.nextToken();\r\n-                    min = Integer.parseInt(s2);\r\n-                }\r\n-            } else {\r\n-                index = databaseProductVersion.indexOf('0');\r\n-                if (index != -1) {\r\n-                    String s = databaseProductVersion.substring(index);\r\n-                    s = s.toUpperCase();\r\n-\r\n-                    StringTokenizer stringtokenizer = new StringTokenizer(s, \"0\"\r\n-                        , false);                    \r\n-                    if (stringtokenizer.countTokens() == 2) {\r\n-                        String s1 = stringtokenizer.nextToken();\r\n-                        maj = Integer.parseInt(s1);\r\n-                        String s2 =  stringtokenizer.nextToken();\r\n-                        min = Integer.parseInt(s2);\r\n-                    }\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    private void getProductVersionMajorMinor() {\r\n-        // In case JDBC driver version is lower than 3\r\n-        // use following info to determine Major and Minor \r\n-        //                        CLI    vs      JCC\r\n-        // ZDBV8 DBProdName       DB2            DB2\r\n-        //       DBProdVersion    08.01.0005     DSN08015\r\n-        // ZDBV9                  DB2            DB2\r\n-        //                        09.01.0005     DSN09015\r\n-        // WinV9                  DB2/NT         DB2/NT\r\n-        //                        09.01.0000     SQL09010\r\n-        // SolarisV9                             DB2/SUN64\r\n-        //                                       SQL0901\r\n-        // Linux                  DB2/LINUX      DB2/LINUX\r\n-        //                        09.01.0000     SQL0901\r\n-        if (databaseProductVersion.indexOf(\"09\") != -1) {\r\n-            maj = 9;\r\n-            if (databaseProductVersion.indexOf(\"01\") != -1) {\r\n-                min = 1;\r\n-            }\r\n-        } else if (databaseProductVersion.indexOf(\"08\") != -1) {\r\n-            maj = 8;\r\n-            min = 2;\r\n-            if (databaseProductVersion.indexOf(\"01\") != -1) {\r\n-                min = 1;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    protected String getOptimizeClause(Select sel) {\r\n-        if (sel != null && sel.getExpectedResultCount() > 0) {\r\n-            StringBuffer buf = new StringBuffer();\r\n-            buf.append(\" \").append(optimizeClause).append(\" \")\r\n-                .append(String.valueOf(sel.getExpectedResultCount()))\r\n-                .append(\" \").append(rowClause);\r\n-            return buf.toString();\r\n-        }\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-    public OpenJPAException newStoreException(String msg, SQLException[] causes,\r\n-        Object failed) {\r\n-        if (causes != null && causes.length > 0)\r\n-            msg = appendExtendedExceptionMsg(msg, causes[0]);\r\n-        return super.newStoreException(msg, causes, failed);\r\n-    }\r\n-\r\n-    /**\r\n-     *  Append exception information from SQLCA to the existing\r\n-     *  exception message\r\n-     */\r\n-    private String appendExtendedExceptionMsg(String msg, SQLException sqle){\r\n-       final String GETSQLCA =\"getSqlca\";\r\n-       String exceptionMsg = new String();\r\n-       try {\r\n-            Method sqlcaM2 = sqle.getNextException().getClass()\r\n-                             .getMethod(GETSQLCA,null);\r\n-            Object sqlca = sqlcaM2.invoke(sqle.getNextException(),\r\n-                                          new Object[] {});\r\n-            Method  getSqlErrpMethd = sqlca.getClass().\r\n-            getMethod(\"getSqlErrp\", null);\r\n-            Method  getSqlWarnMethd = sqlca.getClass().\r\n-            getMethod(\"getSqlWarn\", null);\r\n-            Method  getSqlErrdMethd = sqlca.getClass().\r\n-            getMethod(\"getSqlErrd\", null);\r\n-            StringBuffer errdStr = new StringBuffer();\r\n-\r\n-            int[] errds = (int[]) getSqlErrdMethd.invoke(sqlca, new Object[]{});\r\n-            for (int i = 0; i < errds.length; i++)\r\n-                errdStr.append(errdStr.length() > 0 ? \", \" : \"\").\r\n-                    append(errds[i]);\r\n-            exceptionMsg = exceptionMsg.concat( \"SQLCA OUTPUT\" +\r\n-                    \"[Errp=\" + getSqlErrpMethd.invoke(sqlca, new Object[]{})\r\n-                    + \", Errd=\" + errdStr);\r\n-\r\n-            String Warn = new String((char[]) getSqlWarnMethd.\r\n-                    invoke(sqlca, new Object[]{}));\r\n-            if (Warn.trim().length() != 0)\r\n-                exceptionMsg = exceptionMsg.concat(\", Warn=\" +Warn + \"]\" );\r\n-            else\r\n-                exceptionMsg = exceptionMsg.concat( \"]\" );\r\n-            msg = msg.concat(exceptionMsg);\r\n-            \r\n-            // for batched execution failures, SQLExceptions are nested\r\n-            SQLException sqle2 = sqle.getNextException();\r\n-            while (sqle2 != null) {                \r\n-                msg = msg.concat(\"\\n\" + sqle2.getMessage());\r\n-                sqle2 = sqle2.getNextException();\r\n-            }\r\n-            \r\n-            return msg;\r\n-        } catch (Throwable t) {\r\n-            return sqle.getMessage();\r\n-        }\r\n-    }\r\n-\r\n-    public int getDb2ServerType() {\r\n-        return db2ServerType;\r\n-    }\r\n-    \r\n-    protected void appendLength(SQLBuffer buf, int type) {\r\n-        if (type == Types.VARCHAR)\r\n-            buf.append(\"(\").append(Integer.toString(characterColumnSize)).\r\n-                append(\")\");\r\n-    }\r\n-\r\n-    /**\r\n-     * If this dictionary supports XML type,\r\n-     * use this method to append xml predicate.\r\n-     * \r\n-     * @param buf the SQL buffer to write the comparison\r\n-     * @param op the comparison operation to perform\r\n-     * @param lhs the left hand side of the comparison\r\n-     * @param rhs the right hand side of the comparison\r\n-     * @param lhsxml indicates whether the left operand maps to xml\r\n-     * @param rhsxml indicates whether the right operand maps to xml\r\n-     */\r\n-    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\r\n-        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\r\n-        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\r\n-        if (lhsxml && rhsxml)\r\n-            appendXmlComparison2(buf, op, lhs, rhs);\r\n-        else if (lhsxml)\r\n-            appendXmlComparison1(buf, op, lhs, rhs);\r\n-        else \r\n-            appendXmlComparison1(buf, op, rhs, lhs);\r\n-    }\r\n-\r\n-    /**\r\n-     * Append an xml comparison predicate.\r\n-     *\r\n-     * @param buf the SQL buffer to write the comparison\r\n-     * @param op the comparison operation to perform\r\n-     * @param lhs the left hand side of the comparison (maps to xml column)\r\n-     * @param rhs the right hand side of the comparison\r\n-     */\r\n-    private void appendXmlComparison1(SQLBuffer buf, String op, \r\n-            FilterValue lhs, FilterValue rhs) {\r\n-        boolean castrhs = false;\r\n-        Class rc = Filters.wrap(rhs.getType());\r\n-        int type = 0;\r\n-        if (rhs.isConstant()) {\r\n-            type = getJDBCType(JavaTypes.getTypeCode(rc), false);\r\n-            castrhs = true;\r\n-        }\r\n-        \r\n-        appendXmlExists(buf, lhs);\r\n-\r\n-        buf.append(\" \").append(op).append(\" \");\r\n-        \r\n-        buf.append(\"$\");\r\n-        if (castrhs)\r\n-            buf.append(\"Parm\");\r\n-        else\r\n-            rhs.appendTo(buf);\r\n-        \r\n-        buf.append(\"]' PASSING \");\r\n-        appendXmlVar(buf, lhs);\r\n-        buf.append(\", \");\r\n-        \r\n-        if (castrhs)\r\n-            appendCast(buf, rhs, type);\r\n-        else\r\n-            rhs.appendTo(buf);\r\n-        \r\n-        buf.append(\" AS \\\"\");\r\n-        if (castrhs)\r\n-            buf.append(\"Parm\");\r\n-        else\r\n-            rhs.appendTo(buf);\r\n-        buf.append(\"\\\")\");\r\n-    }\r\n-    \r\n-    /**\r\n-     * Append an xml comparison predicate. (both operands map to xml column)\r\n-     *\r\n-     * @param buf the SQL buffer to write the comparison\r\n-     * @param op the comparison operation to perform\r\n-     * @param lhs the left hand side of the comparison (maps to xml column)\r\n-     * @param rhs the right hand side of the comparison (maps to xml column)\r\n-     */\r\n-    private void appendXmlComparison2(SQLBuffer buf, String op, \r\n-            FilterValue lhs, FilterValue rhs) {\r\n-        appendXmlExists(buf, lhs);\r\n-        \r\n-        buf.append(\" \").append(op).append(\" \");\r\n-        \r\n-        buf.append(\"$\").append(rhs.getColumnAlias(\r\n-            rhs.getFieldMapping().getColumns()[0])).\r\n-            append(\"/*/\");\r\n-        rhs.appendTo(buf);\r\n-        \r\n-        buf.append(\"]' PASSING \");\r\n-        appendXmlVar(buf, lhs);\r\n-        buf.append(\", \");\r\n-        appendXmlVar(buf, rhs);\r\n-        buf.append(\")\");\r\n-    }\r\n-    \r\n-    private void appendXmlVar(SQLBuffer buf, FilterValue val) {\r\n-        buf.append(val.getColumnAlias(\r\n-            val.getFieldMapping().getColumns()[0])).\r\n-            append(\" AS \").\r\n-            append(\"\\\"\").append(val.getColumnAlias(\r\n-            val.getFieldMapping().getColumns()[0])).\r\n-            append(\"\\\"\");        \r\n-    }\r\n-    \r\n-    private void appendXmlExists(SQLBuffer buf, FilterValue val) {\r\n-        buf.append(\"XMLEXISTS('\");\r\n-        buf.append(\"$\").append(val.getColumnAlias(\r\n-            val.getFieldMapping().getColumns()[0])).\r\n-            append(\"/*[\");\r\n-        val.appendTo(buf);        \r\n-    }\r\n-    \r\n-    /**\r\n-     * add CAST for a scalar function where operand is a param\r\n-     * \r\n-     * @param func original string\r\n-     * @param target substring to look for\r\n-     * @param asString \r\n-     * @return updated string (func)\r\n-     */\r\n-    private String addCastAsString(String func, String target, \r\n-            String asString) {\r\n-        String fstring = func;\r\n-        if (func.indexOf(target) != -1)\r\n-            fstring = Strings.replace(\r\n-                func, target, \"CAST(\" + target + asString + \")\");\r\n-        return fstring;\r\n-    }\r\n-\r\n-    /**\r\n-     * add CAST for a function operator where operand is a param\r\n-     * \r\n-     * @param func function name\r\n-     * @param val type\r\n-     * @return updated string (func)\r\n-     */\r\n-    public String addCastAsType(String func, Val val) {\r\n-        String fstring = null;\r\n-        String type = getTypeName(getJDBCType(JavaTypes.getTypeCode(val\r\n-            .getType()), false));\r\n-        if (String.class.equals(val.getType()))\r\n-            type = type + \"(\" + characterColumnSize + \")\";\r\n-        fstring = \"CAST(? AS \" + type + \")\";\r\n-        return fstring;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the batch limit. If the batchLimit is -1, change it to 100 for\r\n-     * best performance\r\n-     */\r\n-    public int getBatchLimit() {\r\n-        int limit = super.getBatchLimit();\r\n-        if (limit == UNLIMITED) {\r\n-            limit = defaultBatchLimit;\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(_loc.get(\"batch_unlimit\", String.valueOf(limit)));\r\n-        }\r\n-        return limit;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the correct CAST function syntax\r\n-     * \r\n-     * @param val operand of cast\r\n-     * @param func original string\r\n-     * @return a String with the correct CAST function syntax\r\n-     */\r\n-    public String getCastFunction(Val val, String func) {\r\n-        if (val instanceof Lit || val instanceof Param)\r\n-            if (func.indexOf(\"VARCHAR\") == -1)\r\n-                func = addCastAsString(func, \"{0}\", \" AS VARCHAR(1000)\");\r\n-        return func;\r\n-    }\r\n-\r\n-    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\r\n-            FilterValue start) {\r\n-        if (find.getValue() != null) { // non constants\r\n-            buf.append(\"(LOCATE(CAST((\");\r\n-            find.appendTo(buf);\r\n-            buf.append(\") AS VARCHAR(1000)), \");\r\n-        } else {\r\n-            // this is a constant\r\n-            buf.append(\"(LOCATE(\");\r\n-            find.appendTo(buf);\r\n-            buf.append(\", \");\r\n-        }\r\n-        if (str.getValue() != null) {\r\n-            buf.append(\"CAST((\");\r\n-            str.appendTo(buf);\r\n-            buf.append(\") AS VARCHAR(1000))\");\r\n-        } else {\r\n-            str.appendTo(buf);\r\n-        }\r\n-        if (start != null) {\r\n-            if (start.getValue() == null) {\r\n-                buf.append(\", CAST((\");\r\n-                start.appendTo(buf);\r\n-                buf.append(\") AS INTEGER) + 1\");\r\n-            } else {\r\n-                buf.append(\", \");\r\n-                start.appendTo(buf);\r\n-            }\r\n-        }\r\n-        buf.append(\") - 1)\");\r\n-    }\r\n-    \r\n-    /** \r\n-     * Cast the specified value to the specified type.\r\n-     *\r\n-     * @param buf the buffer to append the cast to\r\n-     * @param val the value to cast\r\n-     * @param type the type of the case, e.g. {@link Types#NUMERIC}\r\n-     */\r\n-    public void appendCast(SQLBuffer buf, FilterValue val, int type) {\r\n-\r\n-        // Convert the cast function: \"CAST({0} AS {1})\"\r\n-        int firstParam = castFunction.indexOf(\"{0}\");\r\n-        String pre = castFunction.substring(0, firstParam); // \"CAST(\"\r\n-        String mid = castFunction.substring(firstParam + 3);\r\n-        int secondParam = mid.indexOf(\"{1}\");\r\n-        String post;\r\n-        if (secondParam > -1) {\r\n-            post = mid.substring(secondParam + 3); // \")\"\r\n-            mid = mid.substring(0, secondParam); // \" AS \"\r\n-        } else\r\n-            post = \"\";\r\n-\r\n-        // No need to add CAST if the value is a constant\r\n-        if (val instanceof Lit || val instanceof Param) {\r\n-            buf.append(pre);\r\n-            val.appendTo(buf);\r\n-            buf.append(mid);\r\n-            buf.append(getTypeName(type));\r\n-            appendLength(buf, type);\r\n-            buf.append(post);\r\n-        } else {\r\n-            val.appendTo(buf);\r\n-            String sqlString = buf.getSQL(false);\r\n-            if (sqlString.endsWith(\"?\")) {\r\n-                // case \"(?\" - convert to \"CAST(? AS type\"\r\n-                String typeName = getTypeName(type);\r\n-                if (String.class.equals(val.getType()))\r\n-                    typeName = typeName + \"(\" + characterColumnSize + \")\";\r\n-                String str = \"CAST(? AS \" + typeName + \")\";\r\n-                buf.replaceSqlString(sqlString.length() - 1,\r\n-                        sqlString.length(), str);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Create an index if necessary for some database tables\r\n-     */\r\n-    public void createIndexIfNecessary(Schema schema, String table,\r\n-            Column pkColumn) {\r\n-        if (isDB2ZOSV8xOrLater()) {\r\n-            // build the index for the sequence tables\r\n-            // the index name will be the fully qualified table name + _IDX\r\n-            Table tab = schema.getTable(table);\r\n-            Index idx = tab.addIndex(tab.getFullName() + \"_IDX\");\r\n-            idx.setUnique(true);\r\n-            idx.addColumn(pkColumn);\r\n-        }\r\n-    }\r\n-    \r\n-    String nullSafe(String s) {\r\n-    \treturn s == null ? \"\" : s;\r\n-    }\r\n-\r\n-\t@Override\r\n-    protected Boolean matchErrorState(int subtype, Set<String> errorStates,\r\n-        SQLException ex) {\r\n-        Boolean recoverable = null;\r\n-        String errorState = ex.getSQLState();\r\n-        if (errorStates.contains(errorState)) {\r\n-            recoverable = Boolean.FALSE;\r\n-            if (subtype == StoreException.LOCK && errorState.equals(\"57033\")\r\n-                && ex.getMessage().indexOf(\"80\") != -1) {\r\n-                recoverable = Boolean.TRUE;\r\n-            } else if (subtype == StoreException.QUERY && errorState.equals(\"57014\")\r\n-                && ex.getMessage().indexOf(\"40001\") == -1) {\r\n-                // FIXME drwoods - OPENJPA-964 - Need to determine expected DB2 behavior for query timeouts\r\n-                recoverable = Boolean.TRUE;\r\n-            }\r\n-        }\r\n-        return recoverable;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.lang.reflect.Method;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.StringTokenizer;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.jdbc.kernel.exps.Lit;\n+import org.apache.openjpa.jdbc.kernel.exps.Param;\n+import org.apache.openjpa.jdbc.kernel.exps.Val;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Index;\n+import org.apache.openjpa.jdbc.schema.Schema;\n+import org.apache.openjpa.jdbc.schema.Sequence;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.StoreException;\n+import org.apache.openjpa.util.UnsupportedException;\n+\n+import serp.util.Strings;\n+\n+/**\n+ * Dictionary for IBM DB2 database.\n+ */\n+public class DB2Dictionary\n+    extends AbstractDB2Dictionary {\n+    private static final Localizer _loc = Localizer.forPackage\n+        (DB2Dictionary.class);\n+\n+    public String optimizeClause = \"optimize for\";\n+    public String rowClause = \"row\";\n+    protected int db2ServerType = 0;\n+    public static final int db2ISeriesV5R3OrEarlier = 1;\n+    public static final int db2UDBV81OrEarlier = 2;\n+    public static final int db2ZOSV8xOrLater = 3;\n+    public static final int db2UDBV82OrLater = 4;\n+    public static final int db2ISeriesV5R4OrLater = 5;\n+\tprotected static final String forUpdate = \"FOR UPDATE\";\n+    protected static final String withURClause = \"WITH UR\";\n+    protected static final String withCSClause = \"WITH CS\";\n+    protected static final String withRSClause = \"WITH RS\";\n+    protected static final String withRRClause = \"WITH RR\";\n+    protected static final String useKeepShareLockClause\n+        = \"USE AND KEEP SHARE LOCKS\";\n+    protected static final String useKeepUpdateLockClause\n+        = \"USE AND KEEP UPDATE LOCKS\";\n+    protected static final String useKeepExclusiveLockClause\n+        = \"USE AND KEEP EXCLUSIVE LOCKS\";\n+    protected static final String forReadOnlyClause = \"FOR READ ONLY\";\n+    protected String databaseProductName = \"\";\n+    protected String databaseProductVersion = \"\";\n+    protected int maj = 0;\n+    protected int min = 0;\n+    \n+    private int defaultBatchLimit = 100;\n+\n+    public DB2Dictionary() {\n+        platform = \"DB2\";\n+        validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\n+            + \"SYSIBM.SYSTABLES\";\n+        supportsSelectEndIndex = true;\n+\n+        nextSequenceQuery = \"VALUES NEXTVAL FOR {0}\";\n+\n+        sequenceSQL = \"SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, \"\n+            + \"SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES\";\n+        sequenceSchemaSQL = \"SEQSCHEMA = ?\";\n+        sequenceNameSQL = \"SEQNAME = ?\";\n+        characterColumnSize = 254;\n+\n+        binaryTypeName = \"BLOB(1M)\";\n+        longVarbinaryTypeName = \"BLOB(1M)\";\n+        varbinaryTypeName = \"BLOB(1M)\";\n+        clobTypeName = \"CLOB(1M)\";\n+        longVarcharTypeName = \"LONG VARCHAR\";\n+        datePrecision = MICRO;\n+        storeCharsAsNumbers = false;\n+\n+        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\n+            \"LONG VARCHAR FOR BIT DATA\", \"LONG VARCHAR\", \"LONG VARGRAPHIC\",\n+        }));\n+        systemSchemas = new String(\n+                \"SYSCAT,SYSIBM,SYSSTAT,SYSIBMADM,SYSTOOLS\");\n+        maxConstraintNameLength = 18;\n+        maxIndexNameLength = 18;\n+        maxColumnNameLength = 30;\n+        supportsDeferredConstraints = false;\n+        supportsDefaultDeleteAction = false;\n+        supportsAlterTableWithDropColumn = false;\n+\n+        supportsNullTableForGetColumns = false;\n+        requiresCastForMathFunctions = true;\n+        requiresCastForComparisons = true;\n+\n+        reservedWordSet.addAll(Arrays.asList(new String[]{\n+            \"AFTER\", \"ALIAS\", \"ALLOW\", \"APPLICATION\", \"ASSOCIATE\", \"ASUTIME\",\n+            \"AUDIT\", \"AUX\", \"AUXILIARY\", \"BEFORE\", \"BINARY\", \"BUFFERPOOL\",\n+            \"CACHE\", \"CALL\", \"CALLED\", \"CAPTURE\", \"CARDINALITY\", \"CCSID\",\n+            \"CLUSTER\", \"COLLECTION\", \"COLLID\", \"COMMENT\", \"CONCAT\",\n+            \"CONDITION\", \"CONTAINS\", \"COUNT_BIG\", \"CURRENT_LC_CTYPE\",\n+            \"CURRENT_PATH\", \"CURRENT_SERVER\", \"CURRENT_TIMEZONE\", \"CYCLE\",\n+            \"DATA\", \"DATABASE\", \"DAYS\", \"DB2GENERAL\", \"DB2GENRL\", \"DB2SQL\",\n+            \"DBINFO\", \"DEFAULTS\", \"DEFINITION\", \"DETERMINISTIC\", \"DISALLOW\",\n+            \"DO\", \"DSNHATTR\", \"DSSIZE\", \"DYNAMIC\", \"EACH\", \"EDITPROC\", \"ELSEIF\",\n+            \"ENCODING\", \"END-EXEC1\", \"ERASE\", \"EXCLUDING\", \"EXIT\", \"FENCED\",\n+            \"FIELDPROC\", \"FILE\", \"FINAL\", \"FREE\", \"FUNCTION\", \"GENERAL\",\n+            \"GENERATED\", \"GRAPHIC\", \"HANDLER\", \"HOLD\", \"HOURS\", \"IF\",\n+            \"INCLUDING\", \"INCREMENT\", \"INDEX\", \"INHERIT\", \"INOUT\", \"INTEGRITY\",\n+            \"ISOBID\", \"ITERATE\", \"JAR\", \"JAVA\", \"LABEL\", \"LC_CTYPE\", \"LEAVE\",\n+            \"LINKTYPE\", \"LOCALE\", \"LOCATOR\", \"LOCATORS\", \"LOCK\", \"LOCKMAX\",\n+            \"LOCKSIZE\", \"LONG\", \"LOOP\", \"MAXVALUE\", \"MICROSECOND\",\n+            \"MICROSECONDS\", \"MINUTES\", \"MINVALUE\", \"MODE\", \"MODIFIES\", \"MONTHS\",\n+            \"NEW\", \"NEW_TABLE\", \"NOCACHE\", \"NOCYCLE\", \"NODENAME\", \"NODENUMBER\",\n+            \"NOMAXVALUE\", \"NOMINVALUE\", \"NOORDER\", \"NULLS\", \"NUMPARTS\", \"OBID\",\n+            \"OLD\", \"OLD_TABLE\", \"OPTIMIZATION\", \"OPTIMIZE\", \"OUT\", \"OVERRIDING\",\n+            \"PACKAGE\", \"PARAMETER\", \"PART\", \"PARTITION\", \"PATH\", \"PIECESIZE\",\n+            \"PLAN\", \"PRIQTY\", \"PROGRAM\", \"PSID\", \"QUERYNO\", \"READS\", \"RECOVERY\",\n+            \"REFERENCING\", \"RELEASE\", \"RENAME\", \"REPEAT\", \"RESET\", \"RESIGNAL\",\n+            \"RESTART\", \"RESULT\", \"RESULT_SET_LOCATOR\", \"RETURN\", \"RETURNS\",\n+            \"ROUTINE\", \"ROW\", \"RRN\", \"RUN\", \"SAVEPOINT\", \"SCRATCHPAD\",\n+            \"SECONDS\", \"SECQTY\", \"SECURITY\", \"SENSITIVE\", \"SIGNAL\", \"SIMPLE\",\n+            \"SOURCE\", \"SPECIFIC\", \"SQLID\", \"STANDARD\", \"START\", \"STATIC\",\n+            \"STAY\", \"STOGROUP\", \"STORES\", \"STYLE\", \"SUBPAGES\", \"SYNONYM\",\n+            \"SYSFUN\", \"SYSIBM\", \"SYSPROC\", \"SYSTEM\", \"TABLESPACE\", \"TRIGGER\",\n+            \"TYPE\", \"UNDO\", \"UNTIL\", \"VALIDPROC\", \"VARIABLE\", \"VARIANT\", \"VCAT\",\n+            \"VOLUMES\", \"WHILE\", \"WLM\", \"YEARS\",\n+        }));\n+        \n+        super.setBatchLimit(defaultBatchLimit);\n+        \n+        selectWordSet.add(\"WITH\");\n+    }\n+\n+    public boolean supportsRandomAccessResultSet(Select sel,\n+        boolean forUpdate) {\n+        return !forUpdate\n+            && super.supportsRandomAccessResultSet(sel, forUpdate);\n+    }\n+\n+    protected void appendSelectRange(SQLBuffer buf, long start, long end,\n+        boolean subselect) {\n+        // appends the literal range string, since DB2 is unable to handle\n+        // a bound parameter for it\n+        // do not generate FETCH FIRST clause for subselect\n+        if (!subselect)\n+            buf.append(\" FETCH FIRST \").append(Long.toString(end)).\n+                append(\" ROWS ONLY\");\n+    }\n+\n+    protected void appendSelect(SQLBuffer selectSQL, Object alias, Select sel,\n+        int idx) {\n+        // if this is a literal value, add a cast...\n+        Object val = sel.getSelects().get(idx);\n+        if (val instanceof Lit)\n+            selectSQL.append(\"CAST(\");\n+\n+        // ... and add the select per super's behavior...\n+        super.appendSelect(selectSQL, alias, sel, idx);\n+\n+        // ... and finish the cast\n+        if (val instanceof Lit) {\n+            Class c = ((Lit) val).getType();\n+            int javaTypeCode = JavaTypes.getTypeCode(c);\n+            int jdbcTypeCode = getJDBCType(javaTypeCode, false);\n+            String typeName = getTypeName(jdbcTypeCode);\n+            selectSQL.append(\" AS \" + typeName);\n+\n+            // if the literal is a string, use the default char col size\n+            // in the cast statement.\n+            if (String.class.equals(c))\n+                selectSQL.append(\"(\" + characterColumnSize + \")\");\n+\n+            selectSQL.append(\")\");\n+        }\n+    }\n+\n+    public String[] getCreateSequenceSQL(Sequence seq) {\n+        String[] sql = super.getCreateSequenceSQL(seq);\n+        if (seq.getAllocate() > 1)\n+            sql[0] += \" CACHE \" + seq.getAllocate();\n+        return sql;\n+    }\n+\n+    protected String getSequencesSQL(String schemaName, String sequenceName) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(sequenceSQL);\n+        if (schemaName != null || sequenceName != null)\n+            buf.append(\" WHERE \");\n+        if (schemaName != null) {\n+            buf.append(sequenceSchemaSQL);\n+            if (sequenceName != null)\n+                buf.append(\" AND \");\n+        }\n+        if (sequenceName != null)\n+            buf.append(sequenceNameSQL);\n+        return buf.toString();\n+    }\n+\n+    public Connection decorate(Connection conn)\n+        throws SQLException {\n+        // some versions of the DB2 driver seem to default to\n+        // READ_UNCOMMITTED, which will prevent locking from working\n+        // (multiple SELECT ... FOR UPDATE statements are allowed on\n+        // the same instance); if we have not overridden the\n+        // transaction isolation in the configuration, default to\n+        // TRANSACTION_READ_COMMITTED\n+        conn = super.decorate(conn);\n+\n+        if (conf.getTransactionIsolationConstant() == -1\n+            && conn.getTransactionIsolation() < Connection.TRANSACTION_READ_COMMITTED)\n+            conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n+\n+        return conn;\n+    }\n+\n+    public void connectedConfiguration(Connection conn) throws SQLException {\n+    \tsuper.connectedConfiguration(conn);\n+\n+    \tDatabaseMetaData metaData = conn.getMetaData();\n+        databaseProductName = nullSafe(metaData.getDatabaseProductName());\n+        databaseProductVersion = nullSafe(metaData.getDatabaseProductVersion());\n+        \n+        // Determine the type of DB2 database\n+        // First check for AS/400\n+        getProductVersionMajorMinorForISeries();\n+\n+        if (maj > 0) {\n+            if (isDB2ISeriesV5R3OrEarlier())\n+                db2ServerType = db2ISeriesV5R3OrEarlier;\n+            else if (isDB2ISeriesV5R4OrLater())\n+                db2ServerType = db2ISeriesV5R4OrLater;\n+        }\n+        \n+    \tif (db2ServerType == 0) {\n+    \t    if (isJDBC3) {\n+    \t        maj = metaData.getDatabaseMajorVersion();\n+    \t        min = metaData.getDatabaseMinorVersion();\n+    \t    }\n+    \t    else\n+    \t        getProductVersionMajorMinor();\n+\n+    \t    // Determine the type of DB2 database for ZOS & UDB\n+    \t    if (isDB2UDBV81OrEarlier())\n+    \t        db2ServerType = db2UDBV81OrEarlier;\n+    \t    else if (isDB2ZOSV8xOrLater())\n+    \t        db2ServerType = db2ZOSV8xOrLater;\n+    \t    else if (isDB2UDBV82OrLater())\n+    \t        db2ServerType = db2UDBV82OrLater;\n+        }\n+\n+        // verify that database product is supported\n+        if (db2ServerType == 0 || maj == 0)\n+            throw new UnsupportedException(_loc.get(\"db-not-supported\",\n+                new Object[] {databaseProductName, databaseProductVersion }));                    \n+\n+    \tif (maj >= 9 || (maj == 8 && min >= 2)) {\n+    \t    supportsLockingWithMultipleTables = true;\n+    \t    supportsLockingWithInnerJoin = true;\n+    \t    supportsLockingWithOuterJoin = true;\n+    \t    forUpdateClause = \"WITH RR USE AND KEEP UPDATE LOCKS\";\n+    \t    if (maj >=9)\n+    \t        supportsXMLColumn = true;\n+    \t}\n+\n+        // platform specific settings\n+        switch (db2ServerType) {\n+        case db2UDBV82OrLater:\n+            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            break;\n+        case  db2ZOSV8xOrLater:\n+            // DB2 Z/OS \n+            characterColumnSize = 255;\n+            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            sequenceSQL = \"SELECT SCHEMA AS SEQUENCE_SCHEMA, \"\n+                + \"NAME AS SEQUENCE_NAME FROM SYSIBM.SYSSEQUENCES\";\n+            sequenceSchemaSQL = \"SCHEMA = ?\";\n+            sequenceNameSQL = \"NAME = ?\";\n+            if (maj == 8)\n+                // DB2 Z/OS Version 8: no bigint support, hence map Java\n+                // long to decimal\n+                bigintTypeName = \"DECIMAL(31,0)\";\n+            break;\n+        case db2ISeriesV5R3OrEarlier:\n+        case db2ISeriesV5R4OrLater:\n+            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\n+                + \"QSYS2.SYSTABLES\";\n+            sequenceSQL = \"SELECT SEQUENCE_SCHEMA, \"\n+                + \"SEQUENCE_NAME FROM QSYS2.SYSSEQUENCES\";\n+            sequenceSchemaSQL = \"SEQUENCE_SCHEMA = ?\";\n+            sequenceNameSQL = \"SEQUENCE_NAME = ?\";\n+            break;\n+        }\n+    }\n+\n+    public boolean supportsIsolationForUpdate() {\n+        return true;\n+    }\n+\n+    /**\n+     * Get the update clause for the query based on the\n+     * updateClause and isolationLevel hints\n+     */\n+    protected String getForUpdateClause(JDBCFetchConfiguration fetch,\n+        boolean isForUpdate, Select sel) {\n+        int isolationLevel;\n+        // For db2UDBV81OrEarlier and db2ISeriesV5R3OrEarlier:\n+        // \"optimize for\" clause appears before \"for update\" clause.\n+        StringBuffer forUpdateString = new StringBuffer(getOptimizeClause(sel));\n+        // Determine the isolationLevel; the fetch\n+        // configuration data overrides the persistence.xml value\n+        if (fetch != null && fetch.getIsolation() != -1)\n+            isolationLevel = fetch.getIsolation();\n+        else\n+            isolationLevel = conf.getTransactionIsolationConstant();\n+\n+        if (isForUpdate) {\n+            switch (db2ServerType) {\n+            case db2ISeriesV5R3OrEarlier:\n+            case db2UDBV81OrEarlier:\n+                if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE)\n+                    forUpdateString.append(\" \").append(forUpdateClause);\n+                else\n+                    forUpdateString.append(\" \").append(forUpdate).append(\" \")\n+                        .append(withRSClause);\n+                break;\n+            case db2ZOSV8xOrLater:\n+            case db2UDBV82OrLater:\n+                if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\n+                    forUpdateString.append(\" \").append(forReadOnlyClause)\n+                        .append(\" \").append(withRRClause).append(\" \").append(\n+                            useKeepUpdateLockClause);\n+                } else {\n+                    forUpdateString.append(\" \").append(forReadOnlyClause)\n+                        .append(\" \").append(withRSClause).append(\" \").append(\n+                            useKeepUpdateLockClause);\n+                }\n+                break;\n+            case db2ISeriesV5R4OrLater:\n+                if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\n+                    forUpdateString.append(\" \").append(forReadOnlyClause)\n+                        .append(\" \").append(withRRClause).append(\" \").append(\n+                            useKeepExclusiveLockClause);\n+                } else {\n+                    forUpdateString.append(\" \").append(forReadOnlyClause)\n+                        .append(\" \").append(withRSClause).append(\" \").append(\n+                            useKeepExclusiveLockClause);\n+                }\n+                break;\n+            }\n+        }\n+   \n+        return forUpdateString.toString();\n+    }\n+\n+    public boolean isDB2UDBV82OrLater() {\n+        return (databaseProductVersion.indexOf(\"SQL\") != -1\n+             || databaseProductName.indexOf(\"DB2/\") != -1)\n+             && ((maj == 8 && min >= 2) || (maj >= 9));\n+    }\n+\n+    public boolean isDB2ZOSV8xOrLater() {\n+       return (databaseProductVersion.indexOf(\"DSN\") != -1\n+            || databaseProductName.indexOf(\"DB2/\") == -1)\n+            && maj >= 8;\n+           \n+    }\n+\n+    public boolean isDB2ISeriesV5R3OrEarlier() {\n+       return (databaseProductName.indexOf(\"AS\") != -1\n+           && ((maj == 5 && min <=3) || maj < 5));\n+    }\n+\n+    public boolean isDB2ISeriesV5R4OrLater() {\n+       return databaseProductName.indexOf(\"AS\") != -1\n+           && (maj >=6 || (maj == 5 && min >=4));\n+    }\n+\n+    public boolean isDB2UDBV81OrEarlier() {\n+        return (databaseProductVersion.indexOf(\"SQL\") != -1 \n+            || databaseProductName.indexOf(\"DB2/\") != -1) \n+            && ((maj == 8 && min <= 1) || maj < 8);\n+    }\n+\n+    /** Get the version Major/Minor for the ISeries\n+     */\n+    private void getProductVersionMajorMinorForISeries() {\n+        // ISeries    DBProdName                 DB2 UDB for AS/400\n+        //   (Toolbox)DBProdVersion              05.04.0000 V5R4m0\n+        // ISeries                               DB2 UDB for AS/400\n+        //   (Native)                            V5R4M0\n+        // new jcc    DBProdVersion              QSQ05040 or QSQ06010\n+        if (databaseProductName.indexOf(\"AS\") != -1) {\n+            // default to V5R4\n+            maj = 5;\n+            min = 4;\n+            int index = databaseProductVersion.indexOf('V');\n+            if (index != -1) {\n+                String s = databaseProductVersion.substring(index);\n+                s = s.toUpperCase();\n+\n+                StringTokenizer stringtokenizer = new StringTokenizer(s, \"VRM\"\n+                    , false);\n+                if (stringtokenizer.countTokens() == 3) {\n+                    String s1 = stringtokenizer.nextToken();\n+                    maj = Integer.parseInt(s1);\n+                    String s2 =  stringtokenizer.nextToken();\n+                    min = Integer.parseInt(s2);\n+                }\n+            } else {\n+                index = databaseProductVersion.indexOf('0');\n+                if (index != -1) {\n+                    String s = databaseProductVersion.substring(index);\n+                    s = s.toUpperCase();\n+\n+                    StringTokenizer stringtokenizer = new StringTokenizer(s, \"0\"\n+                        , false);                    \n+                    if (stringtokenizer.countTokens() == 2) {\n+                        String s1 = stringtokenizer.nextToken();\n+                        maj = Integer.parseInt(s1);\n+                        String s2 =  stringtokenizer.nextToken();\n+                        min = Integer.parseInt(s2);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    \n+    private void getProductVersionMajorMinor() {\n+        // In case JDBC driver version is lower than 3\n+        // use following info to determine Major and Minor \n+        //                        CLI    vs      JCC\n+        // ZDBV8 DBProdName       DB2            DB2\n+        //       DBProdVersion    08.01.0005     DSN08015\n+        // ZDBV9                  DB2            DB2\n+        //                        09.01.0005     DSN09015\n+        // WinV9                  DB2/NT         DB2/NT\n+        //                        09.01.0000     SQL09010\n+        // SolarisV9                             DB2/SUN64\n+        //                                       SQL0901\n+        // Linux                  DB2/LINUX      DB2/LINUX\n+        //                        09.01.0000     SQL0901\n+        if (databaseProductVersion.indexOf(\"09\") != -1) {\n+            maj = 9;\n+            if (databaseProductVersion.indexOf(\"01\") != -1) {\n+                min = 1;\n+            }\n+        } else if (databaseProductVersion.indexOf(\"08\") != -1) {\n+            maj = 8;\n+            min = 2;\n+            if (databaseProductVersion.indexOf(\"01\") != -1) {\n+                min = 1;\n+            }\n+        }\n+    }\n+\n+    protected String getOptimizeClause(Select sel) {\n+        if (sel != null && sel.getExpectedResultCount() > 0) {\n+            StringBuffer buf = new StringBuffer();\n+            buf.append(\" \").append(optimizeClause).append(\" \")\n+                .append(String.valueOf(sel.getExpectedResultCount()))\n+                .append(\" \").append(rowClause);\n+            return buf.toString();\n+        }\n+\n+        return \"\";\n+    }\n+\n+    public OpenJPAException newStoreException(String msg, SQLException[] causes,\n+        Object failed) {\n+        if (causes != null && causes.length > 0)\n+            msg = appendExtendedExceptionMsg(msg, causes[0]);\n+        return super.newStoreException(msg, causes, failed);\n+    }\n+\n+    /**\n+     *  Append exception information from SQLCA to the existing\n+     *  exception message\n+     */\n+    private String appendExtendedExceptionMsg(String msg, SQLException sqle){\n+       final String GETSQLCA =\"getSqlca\";\n+       String exceptionMsg = new String();\n+       try {\n+            Method sqlcaM2 = sqle.getNextException().getClass()\n+                             .getMethod(GETSQLCA,null);\n+            Object sqlca = sqlcaM2.invoke(sqle.getNextException(),\n+                                          new Object[] {});\n+            Method  getSqlErrpMethd = sqlca.getClass().\n+            getMethod(\"getSqlErrp\", null);\n+            Method  getSqlWarnMethd = sqlca.getClass().\n+            getMethod(\"getSqlWarn\", null);\n+            Method  getSqlErrdMethd = sqlca.getClass().\n+            getMethod(\"getSqlErrd\", null);\n+            StringBuffer errdStr = new StringBuffer();\n+\n+            int[] errds = (int[]) getSqlErrdMethd.invoke(sqlca, new Object[]{});\n+            for (int i = 0; i < errds.length; i++)\n+                errdStr.append(errdStr.length() > 0 ? \", \" : \"\").\n+                    append(errds[i]);\n+            exceptionMsg = exceptionMsg.concat( \"SQLCA OUTPUT\" +\n+                    \"[Errp=\" + getSqlErrpMethd.invoke(sqlca, new Object[]{})\n+                    + \", Errd=\" + errdStr);\n+\n+            String Warn = new String((char[]) getSqlWarnMethd.\n+                    invoke(sqlca, new Object[]{}));\n+            if (Warn.trim().length() != 0)\n+                exceptionMsg = exceptionMsg.concat(\", Warn=\" +Warn + \"]\" );\n+            else\n+                exceptionMsg = exceptionMsg.concat( \"]\" );\n+            msg = msg.concat(exceptionMsg);\n+            \n+            // for batched execution failures, SQLExceptions are nested\n+            SQLException sqle2 = sqle.getNextException();\n+            while (sqle2 != null) {                \n+                msg = msg.concat(\"\\n\" + sqle2.getMessage());\n+                sqle2 = sqle2.getNextException();\n+            }\n+            \n+            return msg;\n+        } catch (Throwable t) {\n+            return sqle.getMessage();\n+        }\n+    }\n+\n+    public int getDb2ServerType() {\n+        return db2ServerType;\n+    }\n+    \n+    protected void appendLength(SQLBuffer buf, int type) {\n+        if (type == Types.VARCHAR)\n+            buf.append(\"(\").append(Integer.toString(characterColumnSize)).\n+                append(\")\");\n+    }\n+\n+    /**\n+     * If this dictionary supports XML type,\n+     * use this method to append xml predicate.\n+     * \n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison\n+     * @param rhs the right hand side of the comparison\n+     * @param lhsxml indicates whether the left operand maps to xml\n+     * @param rhsxml indicates whether the right operand maps to xml\n+     */\n+    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\n+        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\n+        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\n+        if (lhsxml && rhsxml)\n+            appendXmlComparison2(buf, op, lhs, rhs);\n+        else if (lhsxml)\n+            appendXmlComparison1(buf, op, lhs, rhs);\n+        else \n+            appendXmlComparison1(buf, op, rhs, lhs);\n+    }\n+\n+    /**\n+     * Append an xml comparison predicate.\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison\n+     */\n+    private void appendXmlComparison1(SQLBuffer buf, String op, \n+            FilterValue lhs, FilterValue rhs) {\n+        boolean castrhs = false;\n+        Class rc = Filters.wrap(rhs.getType());\n+        int type = 0;\n+        if (rhs.isConstant()) {\n+            type = getJDBCType(JavaTypes.getTypeCode(rc), false);\n+            castrhs = true;\n+        }\n+        \n+        appendXmlExists(buf, lhs);\n+\n+        buf.append(\" \").append(op).append(\" \");\n+        \n+        buf.append(\"$\");\n+        if (castrhs)\n+            buf.append(\"Parm\");\n+        else\n+            rhs.appendTo(buf);\n+        \n+        buf.append(\"]' PASSING \");\n+        appendXmlVar(buf, lhs);\n+        buf.append(\", \");\n+        \n+        if (castrhs)\n+            appendCast(buf, rhs, type);\n+        else\n+            rhs.appendTo(buf);\n+        \n+        buf.append(\" AS \\\"\");\n+        if (castrhs)\n+            buf.append(\"Parm\");\n+        else\n+            rhs.appendTo(buf);\n+        buf.append(\"\\\")\");\n+    }\n+    \n+    /**\n+     * Append an xml comparison predicate. (both operands map to xml column)\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison (maps to xml column)\n+     */\n+    private void appendXmlComparison2(SQLBuffer buf, String op, \n+            FilterValue lhs, FilterValue rhs) {\n+        appendXmlExists(buf, lhs);\n+        \n+        buf.append(\" \").append(op).append(\" \");\n+        \n+        buf.append(\"$\").append(rhs.getColumnAlias(\n+            rhs.getFieldMapping().getColumns()[0])).\n+            append(\"/*/\");\n+        rhs.appendTo(buf);\n+        \n+        buf.append(\"]' PASSING \");\n+        appendXmlVar(buf, lhs);\n+        buf.append(\", \");\n+        appendXmlVar(buf, rhs);\n+        buf.append(\")\");\n+    }\n+    \n+    private void appendXmlVar(SQLBuffer buf, FilterValue val) {\n+        buf.append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\" AS \").\n+            append(\"\\\"\").append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\"\\\"\");        \n+    }\n+    \n+    private void appendXmlExists(SQLBuffer buf, FilterValue val) {\n+        buf.append(\"XMLEXISTS('\");\n+        buf.append(\"$\").append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\"/*[\");\n+        val.appendTo(buf);        \n+    }\n+    \n+    /**\n+     * add CAST for a scalar function where operand is a param\n+     * \n+     * @param func original string\n+     * @param target substring to look for\n+     * @param asString \n+     * @return updated string (func)\n+     */\n+    private String addCastAsString(String func, String target, \n+            String asString) {\n+        String fstring = func;\n+        if (func.indexOf(target) != -1)\n+            fstring = Strings.replace(\n+                func, target, \"CAST(\" + target + asString + \")\");\n+        return fstring;\n+    }\n+\n+    /**\n+     * add CAST for a function operator where operand is a param\n+     * \n+     * @param func function name\n+     * @param val type\n+     * @return updated string (func)\n+     */\n+    public String addCastAsType(String func, Val val) {\n+        String fstring = null;\n+        String type = getTypeName(getJDBCType(JavaTypes.getTypeCode(val\n+            .getType()), false));\n+        if (String.class.equals(val.getType()))\n+            type = type + \"(\" + characterColumnSize + \")\";\n+        fstring = \"CAST(? AS \" + type + \")\";\n+        return fstring;\n+    }\n+\n+    /**\n+     * Return the batch limit. If the batchLimit is -1, change it to 100 for\n+     * best performance\n+     */\n+    public int getBatchLimit() {\n+        int limit = super.getBatchLimit();\n+        if (limit == UNLIMITED) {\n+            limit = defaultBatchLimit;\n+            if (log.isTraceEnabled())\n+                log.trace(_loc.get(\"batch_unlimit\", String.valueOf(limit)));\n+        }\n+        return limit;\n+    }\n+\n+    /**\n+     * Return the correct CAST function syntax\n+     * \n+     * @param val operand of cast\n+     * @param func original string\n+     * @return a String with the correct CAST function syntax\n+     */\n+    public String getCastFunction(Val val, String func) {\n+        if (val instanceof Lit || val instanceof Param)\n+            if (func.indexOf(\"VARCHAR\") == -1)\n+                func = addCastAsString(func, \"{0}\", \" AS VARCHAR(1000)\");\n+        return func;\n+    }\n+\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n+            FilterValue start) {\n+        if (find.getValue() != null) { // non constants\n+            buf.append(\"(LOCATE(CAST((\");\n+            find.appendTo(buf);\n+            buf.append(\") AS VARCHAR(1000)), \");\n+        } else {\n+            // this is a constant\n+            buf.append(\"(LOCATE(\");\n+            find.appendTo(buf);\n+            buf.append(\", \");\n+        }\n+        if (str.getValue() != null) {\n+            buf.append(\"CAST((\");\n+            str.appendTo(buf);\n+            buf.append(\") AS VARCHAR(1000))\");\n+        } else {\n+            str.appendTo(buf);\n+        }\n+        if (start != null) {\n+            if (start.getValue() == null) {\n+                buf.append(\", CAST((\");\n+                start.appendTo(buf);\n+                buf.append(\") AS INTEGER) + 1\");\n+            } else {\n+                buf.append(\", \");\n+                start.appendTo(buf);\n+            }\n+        }\n+        buf.append(\") - 1)\");\n+    }\n+    \n+    /** \n+     * Cast the specified value to the specified type.\n+     *\n+     * @param buf the buffer to append the cast to\n+     * @param val the value to cast\n+     * @param type the type of the case, e.g. {@link Types#NUMERIC}\n+     */\n+    public void appendCast(SQLBuffer buf, FilterValue val, int type) {\n+\n+        // Convert the cast function: \"CAST({0} AS {1})\"\n+        int firstParam = castFunction.indexOf(\"{0}\");\n+        String pre = castFunction.substring(0, firstParam); // \"CAST(\"\n+        String mid = castFunction.substring(firstParam + 3);\n+        int secondParam = mid.indexOf(\"{1}\");\n+        String post;\n+        if (secondParam > -1) {\n+            post = mid.substring(secondParam + 3); // \")\"\n+            mid = mid.substring(0, secondParam); // \" AS \"\n+        } else\n+            post = \"\";\n+\n+        // No need to add CAST if the value is a constant\n+        if (val instanceof Lit || val instanceof Param) {\n+            buf.append(pre);\n+            val.appendTo(buf);\n+            buf.append(mid);\n+            buf.append(getTypeName(type));\n+            appendLength(buf, type);\n+            buf.append(post);\n+        } else {\n+            val.appendTo(buf);\n+            String sqlString = buf.getSQL(false);\n+            if (sqlString.endsWith(\"?\")) {\n+                // case \"(?\" - convert to \"CAST(? AS type\"\n+                String typeName = getTypeName(type);\n+                if (String.class.equals(val.getType()))\n+                    typeName = typeName + \"(\" + characterColumnSize + \")\";\n+                String str = \"CAST(? AS \" + typeName + \")\";\n+                buf.replaceSqlString(sqlString.length() - 1,\n+                        sqlString.length(), str);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create an index if necessary for some database tables\n+     */\n+    public void createIndexIfNecessary(Schema schema, String table,\n+            Column pkColumn) {\n+        if (isDB2ZOSV8xOrLater()) {\n+            // build the index for the sequence tables\n+            // the index name will be the fully qualified table name + _IDX\n+            Table tab = schema.getTable(table);\n+            Index idx = tab.addIndex(tab.getFullName() + \"_IDX\");\n+            idx.setUnique(true);\n+            idx.addColumn(pkColumn);\n+        }\n+    }\n+    \n+    String nullSafe(String s) {\n+    \treturn s == null ? \"\" : s;\n+    }\n+\n+\t@Override\n+    protected Boolean matchErrorState(int subtype, Set<String> errorStates,\n+        SQLException ex) {\n+        Boolean recoverable = null;\n+        String errorState = ex.getSQLState();\n+        if (errorStates.contains(errorState)) {\n+            recoverable = Boolean.FALSE;\n+            if (subtype == StoreException.LOCK && errorState.equals(\"57033\")\n+                && ex.getMessage().indexOf(\"80\") != -1) {\n+                recoverable = Boolean.TRUE;\n+            } else if (subtype == StoreException.QUERY && errorState.equals(\"57014\")\n+                && ex.getMessage().indexOf(\"40001\") == -1) {\n+                // FIXME drwoods - OPENJPA-964 - Need to determine expected DB2 behavior for query timeouts\n+                recoverable = Boolean.TRUE;\n+            }\n+        }\n+        return recoverable;\n+    }\n+}"},{"sha":"d2d2b8628077f8ccf849c787d787a5249766d58f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","status":"modified","additions":155,"deletions":155,"changes":310,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,155 +1,155 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.sql;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.util.ArrayList;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import javax.xml.parsers.DocumentBuilder;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.xml.XMLFactory;\r\n-import org.apache.openjpa.util.StoreException;\r\n-import org.w3c.dom.Document;\r\n-import org.w3c.dom.Element;\r\n-import org.w3c.dom.NamedNodeMap;\r\n-import org.w3c.dom.Node;\r\n-import org.w3c.dom.NodeList;\r\n-\r\n-/**\r\n- * Parses XML content of SQL Error State codes to populate errro codes for\r\n- * a given Database Dictionary.\r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- */\r\n-public class SQLErrorCodeReader {\r\n-\tprivate Log log = null;\r\n-\tpublic static final String ERROR_CODE_DELIMITER = \",\";\r\n-\tpublic static final Map<String, Integer> storeErrorTypes = \r\n-\t\tnew HashMap<String, Integer>();\r\n-\tstatic {\r\n-\t\tstoreErrorTypes.put(\"lock\", StoreException.LOCK);\r\n-\t\tstoreErrorTypes.put(\"object-exists\", StoreException.OBJECT_EXISTS);\r\n-\t\tstoreErrorTypes\r\n-\t\t\t\t.put(\"object-not-found\", StoreException.OBJECT_NOT_FOUND);\r\n-\t\tstoreErrorTypes.put(\"optimistic\", StoreException.OPTIMISTIC);\r\n-\t\tstoreErrorTypes.put(\"referential-integrity\",\r\n-\t\t\t\tStoreException.REFERENTIAL_INTEGRITY);\r\n-\t\tstoreErrorTypes.put(\"query\", StoreException.QUERY);\r\n-\t}\r\n-\t\r\n-\tprivate static final Localizer _loc = \r\n-\t\tLocalizer.forPackage(SQLErrorCodeReader.class);\r\n-\t\r\n-\tpublic List<String> getDictionaries(InputStream in) {\r\n-\t\tList<String> result = new ArrayList<String>();\r\n-\t\tDocumentBuilder builder = XMLFactory.getDOMParser(false, false);\r\n-\t\ttry {\r\n-\t\t\tDocument doc = builder.parse(in);\r\n-\t\t\tElement root = doc.getDocumentElement();\r\n-\t\t\tNodeList nodes = root.getElementsByTagName(\"dictionary\");\r\n-\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\r\n-\t\t\t\tNode node = nodes.item(i);\r\n-\t\t\t\tNamedNodeMap attrs = node.getAttributes();\r\n-\t\t\t\tNode dictionary = attrs.getNamedItem(\"class\");\r\n-\t\t\t\tif (dictionary != null) {\r\n-\t\t\t\t   result.add(dictionary.getNodeValue());\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\tif (log.isWarnEnabled()) {\r\n-\t\t\t\tlog.error(_loc.get(\"error-code-parse-error\"));\r\n-\t\t\t}\r\n-\t\t} finally {\r\n-\t\t\ttry {\r\n-\t\t\t\tin.close();\r\n-\t\t\t} catch (IOException e) {\r\n-\t\t\t\t// ignore\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn result;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Parses given stream of XML content for error codes of the given database\r\n-\t * dictionary name. Populates the given dictionary with the error codes.\r\n-\t * \r\n-\t */\r\n-\tpublic void parse(InputStream in, String dictName, DBDictionary dict) {\r\n-\t\tif (in == null || dict == null)\r\n-\t\t\treturn;\r\n-\t\tlog = dict.conf.getLog(JDBCConfiguration.LOG_JDBC);\r\n-\t\tDocumentBuilder builder = XMLFactory.getDOMParser(false, false);\r\n-\t\ttry {\r\n-\t\t\tDocument doc = builder.parse(in);\r\n-\t\t\tElement root = doc.getDocumentElement();\r\n-\t\t\tNodeList nodes = root.getElementsByTagName(\"dictionary\");\r\n-\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\r\n-\t\t\t\tNode node = nodes.item(i);\r\n-\t\t\t\tNamedNodeMap attrs = node.getAttributes();\r\n-\t\t\t\tNode dictionary = attrs.getNamedItem(\"class\");\r\n-\t\t\t\tif (dictionary != null \r\n-\t\t\t\t && dictionary.getNodeValue().equals(dictName)) {\r\n-\t\t\t\t\treadErrorCodes(node, dict);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\tif (log.isWarnEnabled()) {\r\n-\t\t\t\tlog.error(_loc.get(\"error-code-parse-error\"));\r\n-\t\t\t}\r\n-\t\t} finally {\r\n-\t\t\ttry {\r\n-\t\t\t\tin.close();\r\n-\t\t\t} catch (IOException e) {\r\n-\t\t\t\t// ignore\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic void readErrorCodes(Node node, DBDictionary dict) {\r\n-\t\tNodeList children = node.getChildNodes();\r\n-\t\tfor (int i = 0; i < children.getLength(); i++) {\r\n-\t\t\tNode child = children.item(i);\r\n-\t\t\tshort nodeType = child.getNodeType();\r\n-\t\t\tif (nodeType == Node.ELEMENT_NODE) {\r\n-\t\t\t\tString errorType = child.getNodeName();\r\n-\t\t\t\tNode textNode = child.getFirstChild();\r\n-\t\t\t\tif (storeErrorTypes.containsKey(errorType) && textNode != null){\r\n-\t\t\t\t\tString errorCodes = textNode.getNodeValue();\r\n-\t\t\t\t\tif (!StringUtils.isEmpty(errorCodes)) {\r\n-\t\t\t\t\t\tString[] codes = errorCodes.split(ERROR_CODE_DELIMITER);\r\n-\t\t\t\t\t\tfor (String code : codes) {\r\n-\t\t\t\t\t\t\tdict.addErrorCode(storeErrorTypes.get(errorType),\r\n-\t\t\t\t\t\t\t\t\tcode.trim());\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.xml.XMLFactory;\n+import org.apache.openjpa.util.StoreException;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * Parses XML content of SQL Error State codes to populate errro codes for\n+ * a given Database Dictionary.\n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+public class SQLErrorCodeReader {\n+\tprivate Log log = null;\n+\tpublic static final String ERROR_CODE_DELIMITER = \",\";\n+\tpublic static final Map<String, Integer> storeErrorTypes = \n+\t\tnew HashMap<String, Integer>();\n+\tstatic {\n+\t\tstoreErrorTypes.put(\"lock\", StoreException.LOCK);\n+\t\tstoreErrorTypes.put(\"object-exists\", StoreException.OBJECT_EXISTS);\n+\t\tstoreErrorTypes\n+\t\t\t\t.put(\"object-not-found\", StoreException.OBJECT_NOT_FOUND);\n+\t\tstoreErrorTypes.put(\"optimistic\", StoreException.OPTIMISTIC);\n+\t\tstoreErrorTypes.put(\"referential-integrity\",\n+\t\t\t\tStoreException.REFERENTIAL_INTEGRITY);\n+\t\tstoreErrorTypes.put(\"query\", StoreException.QUERY);\n+\t}\n+\t\n+\tprivate static final Localizer _loc = \n+\t\tLocalizer.forPackage(SQLErrorCodeReader.class);\n+\t\n+\tpublic List<String> getDictionaries(InputStream in) {\n+\t\tList<String> result = new ArrayList<String>();\n+\t\tDocumentBuilder builder = XMLFactory.getDOMParser(false, false);\n+\t\ttry {\n+\t\t\tDocument doc = builder.parse(in);\n+\t\t\tElement root = doc.getDocumentElement();\n+\t\t\tNodeList nodes = root.getElementsByTagName(\"dictionary\");\n+\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\n+\t\t\t\tNode node = nodes.item(i);\n+\t\t\t\tNamedNodeMap attrs = node.getAttributes();\n+\t\t\t\tNode dictionary = attrs.getNamedItem(\"class\");\n+\t\t\t\tif (dictionary != null) {\n+\t\t\t\t   result.add(dictionary.getNodeValue());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable e) {\n+\t\t\tif (log.isWarnEnabled()) {\n+\t\t\t\tlog.error(_loc.get(\"error-code-parse-error\"));\n+\t\t\t}\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\tin.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\t/**\n+\t * Parses given stream of XML content for error codes of the given database\n+\t * dictionary name. Populates the given dictionary with the error codes.\n+\t * \n+\t */\n+\tpublic void parse(InputStream in, String dictName, DBDictionary dict) {\n+\t\tif (in == null || dict == null)\n+\t\t\treturn;\n+\t\tlog = dict.conf.getLog(JDBCConfiguration.LOG_JDBC);\n+\t\tDocumentBuilder builder = XMLFactory.getDOMParser(false, false);\n+\t\ttry {\n+\t\t\tDocument doc = builder.parse(in);\n+\t\t\tElement root = doc.getDocumentElement();\n+\t\t\tNodeList nodes = root.getElementsByTagName(\"dictionary\");\n+\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\n+\t\t\t\tNode node = nodes.item(i);\n+\t\t\t\tNamedNodeMap attrs = node.getAttributes();\n+\t\t\t\tNode dictionary = attrs.getNamedItem(\"class\");\n+\t\t\t\tif (dictionary != null \n+\t\t\t\t && dictionary.getNodeValue().equals(dictName)) {\n+\t\t\t\t\treadErrorCodes(node, dict);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable e) {\n+\t\t\tif (log.isWarnEnabled()) {\n+\t\t\t\tlog.error(_loc.get(\"error-code-parse-error\"));\n+\t\t\t}\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\tin.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tstatic void readErrorCodes(Node node, DBDictionary dict) {\n+\t\tNodeList children = node.getChildNodes();\n+\t\tfor (int i = 0; i < children.getLength(); i++) {\n+\t\t\tNode child = children.item(i);\n+\t\t\tshort nodeType = child.getNodeType();\n+\t\t\tif (nodeType == Node.ELEMENT_NODE) {\n+\t\t\t\tString errorType = child.getNodeName();\n+\t\t\t\tNode textNode = child.getFirstChild();\n+\t\t\t\tif (storeErrorTypes.containsKey(errorType) && textNode != null){\n+\t\t\t\t\tString errorCodes = textNode.getNodeValue();\n+\t\t\t\t\tif (!StringUtils.isEmpty(errorCodes)) {\n+\t\t\t\t\t\tString[] codes = errorCodes.split(ERROR_CODE_DELIMITER);\n+\t\t\t\t\t\tfor (String code : codes) {\n+\t\t\t\t\t\t\tdict.addErrorCode(storeErrorTypes.get(errorType),\n+\t\t\t\t\t\t\t\t\tcode.trim());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}"},{"sha":"c6f72508032ef3c8519795656ef15a9a6a180414","filename":"openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java","status":"modified","additions":882,"deletions":882,"changes":1764,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,882 +1,882 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.ObjectOutput;\r\n-import java.sql.CallableStatement;\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.PreparedStatement;\r\n-import java.sql.SQLException;\r\n-import java.sql.SQLWarning;\r\n-import java.sql.Savepoint;\r\n-import java.sql.Statement;\r\n-import java.util.ArrayList;\r\n-import java.util.BitSet;\r\n-import java.util.Collection;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-\r\n-import junit.framework.TestCase;\r\n-\r\n-import org.apache.openjpa.enhance.PersistenceCapable;\r\n-import org.apache.openjpa.enhance.StateManager;\r\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n-import org.apache.openjpa.jdbc.meta.Strategy;\r\n-import org.apache.openjpa.jdbc.meta.ValueMapping;\r\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\r\n-import org.apache.openjpa.jdbc.sql.RowManager;\r\n-import org.apache.openjpa.jdbc.sql.SQLFactory;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.PCState;\r\n-import org.apache.openjpa.kernel.StoreContext;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.util.Id;\r\n-\r\n-/**\r\n- * <p>\r\n- * Tests AbstractUpdateManager flush's method exception return behavior.\r\n- * </p>\r\n- * \r\n- * @author Albert Lee\r\n- */\r\n-public class TestUpdateManagerFlushException extends /* Abstract */TestCase {\r\n-\r\n-    private TestUpdateManager updMgr;\r\n-\r\n-    public void setUp() {\r\n-        updMgr = new TestUpdateManager();\r\n-    }\r\n-\r\n-    /**\r\n-     * Tests exception collection returns from UpdateManager flush method is in\r\n-     * the order the original exceptions are thrown.\r\n-     */\r\n-    public void testAddRetrieve() {\r\n-        \r\n-        Collection states = new ArrayList<OpenJPAStateManager>();\r\n-        states.add(new TestOpenJPAStateManager());\r\n-\r\n-        Collection exceps = updMgr.flush(states, new TestJDBCStore());\r\n-\r\n-        assertEquals(3, exceps.size());\r\n-        \r\n-        Iterator<Exception> itr = exceps.iterator();\r\n-        assertEquals(itr.next().getMessage(),\r\n-            \"TestUpdateManager.populateRowManager\");\r\n-        assertEquals(itr.next().getMessage(),\r\n-            \"TestUpdateManager.flush\");\r\n-        assertEquals(itr.next().getMessage(),\r\n-            \"TestUpdateManager.customInsert\");\r\n-    }\r\n-\r\n-    /*\r\n-     * Scaffolding test update manager.\r\n-     */\r\n-    class TestUpdateManager extends AbstractUpdateManager {\r\n-\r\n-        protected Collection flush(RowManager rowMgr,\r\n-            PreparedStatementManager psMgr, Collection exceps) {\r\n-\r\n-            exceps.add(new SQLException(\"TestUpdateManager.flush\"));\r\n-\r\n-            return exceps;\r\n-        }\r\n-\r\n-        protected PreparedStatementManager newPreparedStatementManager(\r\n-            JDBCStore store, Connection conn) {\r\n-            return new PreparedStatementManagerImpl(store, conn);\r\n-        }\r\n-\r\n-        protected RowManager newRowManager() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean orderDirty() {\r\n-            return false;\r\n-        }\r\n-\r\n-        protected Collection populateRowManager(OpenJPAStateManager sm,\r\n-            RowManager rowMgr, JDBCStore store, Collection exceps,\r\n-            Collection customs) {\r\n-            \r\n-            exceps.add(new SQLException(\r\n-                \"TestUpdateManager.populateRowManager\"));\r\n-            customs.add(new CustomMapping(CustomMapping.INSERT, sm,\r\n-                new Strategy() {\r\n-                    public void customDelete(OpenJPAStateManager sm,\r\n-                        JDBCStore store) throws SQLException {\r\n-                    }\r\n-\r\n-                    public void customInsert(OpenJPAStateManager sm,\r\n-                        JDBCStore store) throws SQLException {\r\n-                        throw new SQLException(\r\n-                            \"TestUpdateManager.customInsert\");\r\n-                    }\r\n-\r\n-                    public void customUpdate(OpenJPAStateManager sm,\r\n-                        JDBCStore store) throws SQLException {\r\n-                    }\r\n-\r\n-                    public void delete(OpenJPAStateManager sm, JDBCStore store,\r\n-                        RowManager rm) throws SQLException {\r\n-                    }\r\n-\r\n-                    public String getAlias() {\r\n-                        return null;\r\n-                    }\r\n-\r\n-                    public void initialize() {\r\n-                    }\r\n-\r\n-                    public void insert(OpenJPAStateManager sm, JDBCStore store,\r\n-                        RowManager rm) throws SQLException {\r\n-\r\n-                    }\r\n-\r\n-                    public Boolean isCustomDelete(OpenJPAStateManager sm,\r\n-                        JDBCStore store) {\r\n-                        return null;\r\n-                    }\r\n-\r\n-                    public Boolean isCustomInsert(OpenJPAStateManager sm,\r\n-                        JDBCStore store) {\r\n-                        return null;\r\n-                    }\r\n-\r\n-                    public Boolean isCustomUpdate(OpenJPAStateManager sm,\r\n-                        JDBCStore store) {\r\n-                        return null;\r\n-                    }\r\n-\r\n-                    public void map(boolean adapt) {\r\n-                    }\r\n-\r\n-                    public void update(OpenJPAStateManager sm, JDBCStore store,\r\n-                        RowManager rm) throws SQLException {\r\n-                    }\r\n-                }));\r\n-            return exceps;\r\n-        }\r\n-    }\r\n-\r\n-    /*\r\n-     * Scaffolding test state manager.\r\n-     */\r\n-    class TestOpenJPAStateManager implements OpenJPAStateManager {\r\n-\r\n-        public boolean assignObjectId(boolean flush) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean beforeRefresh(boolean refreshAll) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public void dirty(int field) {\r\n-        }\r\n-\r\n-        public Object fetch(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean fetchBoolean(int field) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public byte fetchByte(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public char fetchChar(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public double fetchDouble(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Object fetchField(int field, boolean transitions) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public float fetchFloat(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Object fetchInitialField(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public int fetchInt(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public long fetchLong(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Object fetchObject(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public short fetchShort(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public String fetchString(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public StoreContext getContext() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public BitSet getDirty() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public BitSet getFlushed() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getId() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getImplData() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getImplData(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getIntermediate(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public BitSet getLoaded() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getLock() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getManagedInstance() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public ClassMetaData getMetaData() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getObjectId() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public OpenJPAStateManager getOwner() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public int getOwnerIndex() {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public PCState getPCState() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PersistenceCapable getPersistenceCapable() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public BitSet getUnloaded(FetchConfiguration fetch) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getVersion() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void initialize(Class forType, PCState state) {\r\n-        }\r\n-\r\n-        public boolean isDefaultValue(int field) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isEmbedded() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isFlushed() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isFlushedDirty() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isImplDataCacheable() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isImplDataCacheable(int field) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isProvisional() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isVersionCheckRequired() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isVersionUpdateRequired() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public void load(FetchConfiguration fetch) {\r\n-        }\r\n-\r\n-        public Object newFieldProxy(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object newProxy(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void removed(int field, Object removed, boolean key) {\r\n-        }\r\n-\r\n-        public Object setImplData(Object data, boolean cacheable) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object setImplData(int field, Object data) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void setIntermediate(int field, Object value) {\r\n-        }\r\n-\r\n-        public void setLock(Object lock) {\r\n-        }\r\n-\r\n-        public void setNextVersion(Object version) {\r\n-        }\r\n-\r\n-        public void setObjectId(Object oid) {\r\n-        }\r\n-\r\n-        public void setRemote(int field, Object value) {\r\n-        }\r\n-\r\n-        public void setVersion(Object version) {\r\n-        }\r\n-\r\n-        public void store(int field, Object value) {\r\n-        }\r\n-\r\n-        public void storeBoolean(int field, boolean externalVal) {\r\n-        }\r\n-\r\n-        public void storeByte(int field, byte externalVal) {\r\n-        }\r\n-\r\n-        public void storeChar(int field, char externalVal) {\r\n-        }\r\n-\r\n-        public void storeDouble(int field, double externalVal) {\r\n-        }\r\n-\r\n-        public void storeField(int field, Object value) {\r\n-        }\r\n-\r\n-        public void storeFloat(int field, float externalVal) {\r\n-        }\r\n-\r\n-        public void storeInt(int field, int externalVal) {\r\n-        }\r\n-\r\n-        public void storeLong(int field, long externalVal) {\r\n-        }\r\n-\r\n-        public void storeObject(int field, Object externalVal) {\r\n-        }\r\n-\r\n-        public void storeShort(int field, short externalVal) {\r\n-        }\r\n-\r\n-        public void storeString(int field, String externalVal) {\r\n-        }\r\n-\r\n-        public void accessingField(int idx) {\r\n-        }\r\n-\r\n-        public void dirty(String field) {\r\n-        }\r\n-\r\n-        public Object fetchObjectId() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getGenericContext() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getPCPrimaryKey(Object oid, int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean isDeleted() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isDetached() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isDirty() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isNew() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isPersistent() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isTransactional() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public void providedBooleanField(PersistenceCapable pc, int idx,\r\n-            boolean cur) {\r\n-        }\r\n-\r\n-        public void providedByteField(PersistenceCapable pc, int idx,\r\n-            byte cur) {\r\n-        }\r\n-\r\n-        public void providedCharField(PersistenceCapable pc, int idx, \r\n-            char cur) {\r\n-        }\r\n-\r\n-        public void providedDoubleField(PersistenceCapable pc, int idx,\r\n-            double cur) {\r\n-        }\r\n-\r\n-        public void providedFloatField(PersistenceCapable pc, int idx,\r\n-            float cur) {\r\n-        }\r\n-\r\n-        public void providedIntField(PersistenceCapable pc, int idx, \r\n-            int cur) {\r\n-        }\r\n-\r\n-        public void providedLongField(PersistenceCapable pc, int idx, \r\n-            long cur) {\r\n-        }\r\n-\r\n-        public void providedObjectField(PersistenceCapable pc, int idx,\r\n-            Object cur) {\r\n-        }\r\n-\r\n-        public void providedShortField(PersistenceCapable pc, int idx, \r\n-            short cur) {\r\n-        }\r\n-\r\n-        public void providedStringField(PersistenceCapable pc, int idx,\r\n-            String cur) {\r\n-        }\r\n-\r\n-        public void proxyDetachedDeserialized(int idx) {\r\n-        }\r\n-\r\n-        public boolean replaceBooleanField(PersistenceCapable pc, int idx) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public byte replaceByteField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public char replaceCharField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public double replaceDoubleField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public float replaceFloatField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public int replaceIntField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public long replaceLongField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Object replaceObjectField(PersistenceCapable pc, int idx) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public short replaceShortField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public StateManager replaceStateManager(StateManager sm) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public String replaceStringField(PersistenceCapable pc, int idx) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean serializing() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public void settingBooleanField(PersistenceCapable pc, int idx,\r\n-            boolean cur, boolean next, int set) {\r\n-        }\r\n-\r\n-        public void settingByteField(PersistenceCapable pc, int idx, byte cur,\r\n-            byte next, int set) {\r\n-        }\r\n-\r\n-        public void settingCharField(PersistenceCapable pc, int idx, char cur,\r\n-            char next, int set) {\r\n-        }\r\n-\r\n-        public void settingDoubleField(PersistenceCapable pc, int idx,\r\n-            double cur, double next, int set) {\r\n-        }\r\n-\r\n-        public void settingFloatField(PersistenceCapable pc, int idx,\r\n-            float cur, float next, int set) {\r\n-        }\r\n-\r\n-        public void settingIntField(PersistenceCapable pc, int idx, int cur,\r\n-            int next, int set) {\r\n-        }\r\n-\r\n-        public void settingLongField(PersistenceCapable pc, int idx, long cur,\r\n-            long next, int set) {\r\n-        }\r\n-\r\n-        public void settingObjectField(PersistenceCapable pc, int idx,\r\n-            Object cur, Object next, int set) {\r\n-        }\r\n-\r\n-        public void settingShortField(PersistenceCapable pc, int idx,\r\n-            short cur, short next, int set) {\r\n-        }\r\n-\r\n-        public void settingStringField(PersistenceCapable pc, int idx,\r\n-            String cur, String next, int set) {\r\n-        }\r\n-\r\n-        public boolean writeDetached(ObjectOutput out) throws IOException {\r\n-            return false;\r\n-        }\r\n-\r\n-        public void storeBooleanField(int fieldIndex, boolean value) {\r\n-        }\r\n-\r\n-        public void storeByteField(int fieldIndex, byte value) {\r\n-        }\r\n-\r\n-        public void storeCharField(int fieldIndex, char value) {\r\n-        }\r\n-\r\n-        public void storeDoubleField(int fieldIndex, double value) {\r\n-        }\r\n-\r\n-        public void storeFloatField(int fieldIndex, float value) {\r\n-        }\r\n-\r\n-        public void storeIntField(int fieldIndex, int value) {\r\n-        }\r\n-\r\n-        public void storeLongField(int fieldIndex, long value) {\r\n-        }\r\n-\r\n-        public void storeObjectField(int fieldIndex, Object value) {\r\n-        }\r\n-\r\n-        public void storeShortField(int fieldIndex, short value) {\r\n-        }\r\n-\r\n-        public void storeStringField(int fieldIndex, String value) {\r\n-        }\r\n-\r\n-        public boolean fetchBooleanField(int fieldIndex) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public byte fetchByteField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public char fetchCharField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public double fetchDoubleField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public float fetchFloatField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public int fetchIntField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public long fetchLongField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Object fetchObjectField(int fieldIndex) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public short fetchShortField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public String fetchStringField(int fieldIndex) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    /*\r\n-     * Scaffolding test connection.\r\n-     */\r\n-    class TestConnection implements Connection {\r\n-\r\n-        public void clearWarnings() throws SQLException {\r\n-        }\r\n-\r\n-        public void close() throws SQLException {\r\n-        }\r\n-\r\n-        public void commit() throws SQLException {\r\n-        }\r\n-\r\n-        public Statement createStatement() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Statement createStatement(int resultSetType,\r\n-            int resultSetConcurrency) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Statement createStatement(int resultSetType,\r\n-            int resultSetConcurrency, int resultSetHoldability)\r\n-            throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean getAutoCommit() throws SQLException {\r\n-            return false;\r\n-        }\r\n-\r\n-        public String getCatalog() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public int getHoldability() throws SQLException {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public DatabaseMetaData getMetaData() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public int getTransactionIsolation() throws SQLException {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Map<String, Class<?>> getTypeMap() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public SQLWarning getWarnings() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean isClosed() throws SQLException {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isReadOnly() throws SQLException {\r\n-            return false;\r\n-        }\r\n-\r\n-        public String nativeSQL(String sql) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public CallableStatement prepareCall(String sql) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public CallableStatement prepareCall(String sql, int resultSetType,\r\n-            int resultSetConcurrency) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public CallableStatement prepareCall(String sql, int resultSetType,\r\n-            int resultSetConcurrency, int resultSetHoldability)\r\n-            throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql)\r\n-            throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql,\r\n-            int autoGeneratedKeys) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql,\r\n-            int[] columnIndexes) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql,\r\n-            String[] columnNames) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql,\r\n-            int resultSetType, int resultSetConcurrency) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql,\r\n-            int resultSetType, int resultSetConcurrency,\r\n-            int resultSetHoldability) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void releaseSavepoint(Savepoint savepoint) throws SQLException {\r\n-        }\r\n-\r\n-        public void rollback() throws SQLException {\r\n-        }\r\n-\r\n-        public void rollback(Savepoint savepoint) throws SQLException {\r\n-        }\r\n-\r\n-        public void setAutoCommit(boolean autoCommit) throws SQLException {\r\n-        }\r\n-\r\n-        public void setCatalog(String catalog) throws SQLException {\r\n-        }\r\n-\r\n-        public void setHoldability(int holdability) throws SQLException {\r\n-        }\r\n-\r\n-        public void setReadOnly(boolean readOnly) throws SQLException {\r\n-        }\r\n-\r\n-        public Savepoint setSavepoint() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Savepoint setSavepoint(String name) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void setTransactionIsolation(int level) throws SQLException {\r\n-        }\r\n-\r\n-        public void setTypeMap(Map<String, Class<?>> map) throws SQLException {\r\n-        }\r\n-    }\r\n-\r\n-    /*\r\n-     * Scaffolding test store manager.\r\n-     */\r\n-    class TestJDBCStore implements JDBCStore {\r\n-\r\n-        public Object find(Object oid, ValueMapping vm,\r\n-            JDBCFetchConfiguration fetch) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public JDBCConfiguration getConfiguration() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Connection getConnection() {\r\n-            return new TestConnection();\r\n-        }\r\n-\r\n-        public StoreContext getContext() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public DBDictionary getDBDictionary() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public JDBCFetchConfiguration getFetchConfiguration() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public JDBCLockManager getLockManager() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public SQLFactory getSQLFactory() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void loadSubclasses(ClassMapping mapping) {\r\n-\r\n-        }\r\n-\r\n-        public Id newDataStoreId(long id, ClassMapping mapping, boolean subs) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.io.IOException;\n+import java.io.ObjectOutput;\n+import java.sql.CallableStatement;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.SQLWarning;\n+import java.sql.Savepoint;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.enhance.StateManager;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.Strategy;\n+import org.apache.openjpa.jdbc.meta.ValueMapping;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.RowManager;\n+import org.apache.openjpa.jdbc.sql.SQLFactory;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.PCState;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.util.Id;\n+\n+/**\n+ * <p>\n+ * Tests AbstractUpdateManager flush's method exception return behavior.\n+ * </p>\n+ * \n+ * @author Albert Lee\n+ */\n+public class TestUpdateManagerFlushException extends /* Abstract */TestCase {\n+\n+    private TestUpdateManager updMgr;\n+\n+    public void setUp() {\n+        updMgr = new TestUpdateManager();\n+    }\n+\n+    /**\n+     * Tests exception collection returns from UpdateManager flush method is in\n+     * the order the original exceptions are thrown.\n+     */\n+    public void testAddRetrieve() {\n+        \n+        Collection states = new ArrayList<OpenJPAStateManager>();\n+        states.add(new TestOpenJPAStateManager());\n+\n+        Collection exceps = updMgr.flush(states, new TestJDBCStore());\n+\n+        assertEquals(3, exceps.size());\n+        \n+        Iterator<Exception> itr = exceps.iterator();\n+        assertEquals(itr.next().getMessage(),\n+            \"TestUpdateManager.populateRowManager\");\n+        assertEquals(itr.next().getMessage(),\n+            \"TestUpdateManager.flush\");\n+        assertEquals(itr.next().getMessage(),\n+            \"TestUpdateManager.customInsert\");\n+    }\n+\n+    /*\n+     * Scaffolding test update manager.\n+     */\n+    class TestUpdateManager extends AbstractUpdateManager {\n+\n+        protected Collection flush(RowManager rowMgr,\n+            PreparedStatementManager psMgr, Collection exceps) {\n+\n+            exceps.add(new SQLException(\"TestUpdateManager.flush\"));\n+\n+            return exceps;\n+        }\n+\n+        protected PreparedStatementManager newPreparedStatementManager(\n+            JDBCStore store, Connection conn) {\n+            return new PreparedStatementManagerImpl(store, conn);\n+        }\n+\n+        protected RowManager newRowManager() {\n+            return null;\n+        }\n+\n+        public boolean orderDirty() {\n+            return false;\n+        }\n+\n+        protected Collection populateRowManager(OpenJPAStateManager sm,\n+            RowManager rowMgr, JDBCStore store, Collection exceps,\n+            Collection customs) {\n+            \n+            exceps.add(new SQLException(\n+                \"TestUpdateManager.populateRowManager\"));\n+            customs.add(new CustomMapping(CustomMapping.INSERT, sm,\n+                new Strategy() {\n+                    public void customDelete(OpenJPAStateManager sm,\n+                        JDBCStore store) throws SQLException {\n+                    }\n+\n+                    public void customInsert(OpenJPAStateManager sm,\n+                        JDBCStore store) throws SQLException {\n+                        throw new SQLException(\n+                            \"TestUpdateManager.customInsert\");\n+                    }\n+\n+                    public void customUpdate(OpenJPAStateManager sm,\n+                        JDBCStore store) throws SQLException {\n+                    }\n+\n+                    public void delete(OpenJPAStateManager sm, JDBCStore store,\n+                        RowManager rm) throws SQLException {\n+                    }\n+\n+                    public String getAlias() {\n+                        return null;\n+                    }\n+\n+                    public void initialize() {\n+                    }\n+\n+                    public void insert(OpenJPAStateManager sm, JDBCStore store,\n+                        RowManager rm) throws SQLException {\n+\n+                    }\n+\n+                    public Boolean isCustomDelete(OpenJPAStateManager sm,\n+                        JDBCStore store) {\n+                        return null;\n+                    }\n+\n+                    public Boolean isCustomInsert(OpenJPAStateManager sm,\n+                        JDBCStore store) {\n+                        return null;\n+                    }\n+\n+                    public Boolean isCustomUpdate(OpenJPAStateManager sm,\n+                        JDBCStore store) {\n+                        return null;\n+                    }\n+\n+                    public void map(boolean adapt) {\n+                    }\n+\n+                    public void update(OpenJPAStateManager sm, JDBCStore store,\n+                        RowManager rm) throws SQLException {\n+                    }\n+                }));\n+            return exceps;\n+        }\n+    }\n+\n+    /*\n+     * Scaffolding test state manager.\n+     */\n+    class TestOpenJPAStateManager implements OpenJPAStateManager {\n+\n+        public boolean assignObjectId(boolean flush) {\n+            return false;\n+        }\n+\n+        public boolean beforeRefresh(boolean refreshAll) {\n+            return false;\n+        }\n+\n+        public void dirty(int field) {\n+        }\n+\n+        public Object fetch(int field) {\n+            return null;\n+        }\n+\n+        public boolean fetchBoolean(int field) {\n+            return false;\n+        }\n+\n+        public byte fetchByte(int field) {\n+            return 0;\n+        }\n+\n+        public char fetchChar(int field) {\n+            return 0;\n+        }\n+\n+        public double fetchDouble(int field) {\n+            return 0;\n+        }\n+\n+        public Object fetchField(int field, boolean transitions) {\n+            return null;\n+        }\n+\n+        public float fetchFloat(int field) {\n+            return 0;\n+        }\n+\n+        public Object fetchInitialField(int field) {\n+            return null;\n+        }\n+\n+        public int fetchInt(int field) {\n+            return 0;\n+        }\n+\n+        public long fetchLong(int field) {\n+            return 0;\n+        }\n+\n+        public Object fetchObject(int field) {\n+            return null;\n+        }\n+\n+        public short fetchShort(int field) {\n+            return 0;\n+        }\n+\n+        public String fetchString(int field) {\n+            return null;\n+        }\n+\n+        public StoreContext getContext() {\n+            return null;\n+        }\n+\n+        public BitSet getDirty() {\n+            return null;\n+        }\n+\n+        public BitSet getFlushed() {\n+            return null;\n+        }\n+\n+        public Object getId() {\n+            return null;\n+        }\n+\n+        public Object getImplData() {\n+            return null;\n+        }\n+\n+        public Object getImplData(int field) {\n+            return null;\n+        }\n+\n+        public Object getIntermediate(int field) {\n+            return null;\n+        }\n+\n+        public BitSet getLoaded() {\n+            return null;\n+        }\n+\n+        public Object getLock() {\n+            return null;\n+        }\n+\n+        public Object getManagedInstance() {\n+            return null;\n+        }\n+\n+        public ClassMetaData getMetaData() {\n+            return null;\n+        }\n+\n+        public Object getObjectId() {\n+            return null;\n+        }\n+\n+        public OpenJPAStateManager getOwner() {\n+            return null;\n+        }\n+\n+        public int getOwnerIndex() {\n+            return 0;\n+        }\n+\n+        public PCState getPCState() {\n+            return null;\n+        }\n+\n+        public PersistenceCapable getPersistenceCapable() {\n+            return null;\n+        }\n+\n+        public BitSet getUnloaded(FetchConfiguration fetch) {\n+            return null;\n+        }\n+\n+        public Object getVersion() {\n+            return null;\n+        }\n+\n+        public void initialize(Class forType, PCState state) {\n+        }\n+\n+        public boolean isDefaultValue(int field) {\n+            return false;\n+        }\n+\n+        public boolean isEmbedded() {\n+            return false;\n+        }\n+\n+        public boolean isFlushed() {\n+            return false;\n+        }\n+\n+        public boolean isFlushedDirty() {\n+            return false;\n+        }\n+\n+        public boolean isImplDataCacheable() {\n+            return false;\n+        }\n+\n+        public boolean isImplDataCacheable(int field) {\n+            return false;\n+        }\n+\n+        public boolean isProvisional() {\n+            return false;\n+        }\n+\n+        public boolean isVersionCheckRequired() {\n+            return false;\n+        }\n+\n+        public boolean isVersionUpdateRequired() {\n+            return false;\n+        }\n+\n+        public void load(FetchConfiguration fetch) {\n+        }\n+\n+        public Object newFieldProxy(int field) {\n+            return null;\n+        }\n+\n+        public Object newProxy(int field) {\n+            return null;\n+        }\n+\n+        public void removed(int field, Object removed, boolean key) {\n+        }\n+\n+        public Object setImplData(Object data, boolean cacheable) {\n+            return null;\n+        }\n+\n+        public Object setImplData(int field, Object data) {\n+            return null;\n+        }\n+\n+        public void setIntermediate(int field, Object value) {\n+        }\n+\n+        public void setLock(Object lock) {\n+        }\n+\n+        public void setNextVersion(Object version) {\n+        }\n+\n+        public void setObjectId(Object oid) {\n+        }\n+\n+        public void setRemote(int field, Object value) {\n+        }\n+\n+        public void setVersion(Object version) {\n+        }\n+\n+        public void store(int field, Object value) {\n+        }\n+\n+        public void storeBoolean(int field, boolean externalVal) {\n+        }\n+\n+        public void storeByte(int field, byte externalVal) {\n+        }\n+\n+        public void storeChar(int field, char externalVal) {\n+        }\n+\n+        public void storeDouble(int field, double externalVal) {\n+        }\n+\n+        public void storeField(int field, Object value) {\n+        }\n+\n+        public void storeFloat(int field, float externalVal) {\n+        }\n+\n+        public void storeInt(int field, int externalVal) {\n+        }\n+\n+        public void storeLong(int field, long externalVal) {\n+        }\n+\n+        public void storeObject(int field, Object externalVal) {\n+        }\n+\n+        public void storeShort(int field, short externalVal) {\n+        }\n+\n+        public void storeString(int field, String externalVal) {\n+        }\n+\n+        public void accessingField(int idx) {\n+        }\n+\n+        public void dirty(String field) {\n+        }\n+\n+        public Object fetchObjectId() {\n+            return null;\n+        }\n+\n+        public Object getGenericContext() {\n+            return null;\n+        }\n+\n+        public Object getPCPrimaryKey(Object oid, int field) {\n+            return null;\n+        }\n+\n+        public boolean isDeleted() {\n+            return false;\n+        }\n+\n+        public boolean isDetached() {\n+            return false;\n+        }\n+\n+        public boolean isDirty() {\n+            return false;\n+        }\n+\n+        public boolean isNew() {\n+            return false;\n+        }\n+\n+        public boolean isPersistent() {\n+            return false;\n+        }\n+\n+        public boolean isTransactional() {\n+            return false;\n+        }\n+\n+        public void providedBooleanField(PersistenceCapable pc, int idx,\n+            boolean cur) {\n+        }\n+\n+        public void providedByteField(PersistenceCapable pc, int idx,\n+            byte cur) {\n+        }\n+\n+        public void providedCharField(PersistenceCapable pc, int idx, \n+            char cur) {\n+        }\n+\n+        public void providedDoubleField(PersistenceCapable pc, int idx,\n+            double cur) {\n+        }\n+\n+        public void providedFloatField(PersistenceCapable pc, int idx,\n+            float cur) {\n+        }\n+\n+        public void providedIntField(PersistenceCapable pc, int idx, \n+            int cur) {\n+        }\n+\n+        public void providedLongField(PersistenceCapable pc, int idx, \n+            long cur) {\n+        }\n+\n+        public void providedObjectField(PersistenceCapable pc, int idx,\n+            Object cur) {\n+        }\n+\n+        public void providedShortField(PersistenceCapable pc, int idx, \n+            short cur) {\n+        }\n+\n+        public void providedStringField(PersistenceCapable pc, int idx,\n+            String cur) {\n+        }\n+\n+        public void proxyDetachedDeserialized(int idx) {\n+        }\n+\n+        public boolean replaceBooleanField(PersistenceCapable pc, int idx) {\n+            return false;\n+        }\n+\n+        public byte replaceByteField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public char replaceCharField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public double replaceDoubleField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public float replaceFloatField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public int replaceIntField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public long replaceLongField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public Object replaceObjectField(PersistenceCapable pc, int idx) {\n+            return null;\n+        }\n+\n+        public short replaceShortField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public StateManager replaceStateManager(StateManager sm) {\n+            return null;\n+        }\n+\n+        public String replaceStringField(PersistenceCapable pc, int idx) {\n+            return null;\n+        }\n+\n+        public boolean serializing() {\n+            return false;\n+        }\n+\n+        public void settingBooleanField(PersistenceCapable pc, int idx,\n+            boolean cur, boolean next, int set) {\n+        }\n+\n+        public void settingByteField(PersistenceCapable pc, int idx, byte cur,\n+            byte next, int set) {\n+        }\n+\n+        public void settingCharField(PersistenceCapable pc, int idx, char cur,\n+            char next, int set) {\n+        }\n+\n+        public void settingDoubleField(PersistenceCapable pc, int idx,\n+            double cur, double next, int set) {\n+        }\n+\n+        public void settingFloatField(PersistenceCapable pc, int idx,\n+            float cur, float next, int set) {\n+        }\n+\n+        public void settingIntField(PersistenceCapable pc, int idx, int cur,\n+            int next, int set) {\n+        }\n+\n+        public void settingLongField(PersistenceCapable pc, int idx, long cur,\n+            long next, int set) {\n+        }\n+\n+        public void settingObjectField(PersistenceCapable pc, int idx,\n+            Object cur, Object next, int set) {\n+        }\n+\n+        public void settingShortField(PersistenceCapable pc, int idx,\n+            short cur, short next, int set) {\n+        }\n+\n+        public void settingStringField(PersistenceCapable pc, int idx,\n+            String cur, String next, int set) {\n+        }\n+\n+        public boolean writeDetached(ObjectOutput out) throws IOException {\n+            return false;\n+        }\n+\n+        public void storeBooleanField(int fieldIndex, boolean value) {\n+        }\n+\n+        public void storeByteField(int fieldIndex, byte value) {\n+        }\n+\n+        public void storeCharField(int fieldIndex, char value) {\n+        }\n+\n+        public void storeDoubleField(int fieldIndex, double value) {\n+        }\n+\n+        public void storeFloatField(int fieldIndex, float value) {\n+        }\n+\n+        public void storeIntField(int fieldIndex, int value) {\n+        }\n+\n+        public void storeLongField(int fieldIndex, long value) {\n+        }\n+\n+        public void storeObjectField(int fieldIndex, Object value) {\n+        }\n+\n+        public void storeShortField(int fieldIndex, short value) {\n+        }\n+\n+        public void storeStringField(int fieldIndex, String value) {\n+        }\n+\n+        public boolean fetchBooleanField(int fieldIndex) {\n+            return false;\n+        }\n+\n+        public byte fetchByteField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public char fetchCharField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public double fetchDoubleField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public float fetchFloatField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public int fetchIntField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public long fetchLongField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public Object fetchObjectField(int fieldIndex) {\n+            return null;\n+        }\n+\n+        public short fetchShortField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public String fetchStringField(int fieldIndex) {\n+            return null;\n+        }\n+    }\n+\n+    /*\n+     * Scaffolding test connection.\n+     */\n+    class TestConnection implements Connection {\n+\n+        public void clearWarnings() throws SQLException {\n+        }\n+\n+        public void close() throws SQLException {\n+        }\n+\n+        public void commit() throws SQLException {\n+        }\n+\n+        public Statement createStatement() throws SQLException {\n+            return null;\n+        }\n+\n+        public Statement createStatement(int resultSetType,\n+            int resultSetConcurrency) throws SQLException {\n+            return null;\n+        }\n+\n+        public Statement createStatement(int resultSetType,\n+            int resultSetConcurrency, int resultSetHoldability)\n+            throws SQLException {\n+            return null;\n+        }\n+\n+        public boolean getAutoCommit() throws SQLException {\n+            return false;\n+        }\n+\n+        public String getCatalog() throws SQLException {\n+            return null;\n+        }\n+\n+        public int getHoldability() throws SQLException {\n+            return 0;\n+        }\n+\n+        public DatabaseMetaData getMetaData() throws SQLException {\n+            return null;\n+        }\n+\n+        public int getTransactionIsolation() throws SQLException {\n+            return 0;\n+        }\n+\n+        public Map<String, Class<?>> getTypeMap() throws SQLException {\n+            return null;\n+        }\n+\n+        public SQLWarning getWarnings() throws SQLException {\n+            return null;\n+        }\n+\n+        public boolean isClosed() throws SQLException {\n+            return false;\n+        }\n+\n+        public boolean isReadOnly() throws SQLException {\n+            return false;\n+        }\n+\n+        public String nativeSQL(String sql) throws SQLException {\n+            return null;\n+        }\n+\n+        public CallableStatement prepareCall(String sql) throws SQLException {\n+            return null;\n+        }\n+\n+        public CallableStatement prepareCall(String sql, int resultSetType,\n+            int resultSetConcurrency) throws SQLException {\n+            return null;\n+        }\n+\n+        public CallableStatement prepareCall(String sql, int resultSetType,\n+            int resultSetConcurrency, int resultSetHoldability)\n+            throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql)\n+            throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql,\n+            int autoGeneratedKeys) throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql,\n+            int[] columnIndexes) throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql,\n+            String[] columnNames) throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql,\n+            int resultSetType, int resultSetConcurrency) throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql,\n+            int resultSetType, int resultSetConcurrency,\n+            int resultSetHoldability) throws SQLException {\n+            return null;\n+        }\n+\n+        public void releaseSavepoint(Savepoint savepoint) throws SQLException {\n+        }\n+\n+        public void rollback() throws SQLException {\n+        }\n+\n+        public void rollback(Savepoint savepoint) throws SQLException {\n+        }\n+\n+        public void setAutoCommit(boolean autoCommit) throws SQLException {\n+        }\n+\n+        public void setCatalog(String catalog) throws SQLException {\n+        }\n+\n+        public void setHoldability(int holdability) throws SQLException {\n+        }\n+\n+        public void setReadOnly(boolean readOnly) throws SQLException {\n+        }\n+\n+        public Savepoint setSavepoint() throws SQLException {\n+            return null;\n+        }\n+\n+        public Savepoint setSavepoint(String name) throws SQLException {\n+            return null;\n+        }\n+\n+        public void setTransactionIsolation(int level) throws SQLException {\n+        }\n+\n+        public void setTypeMap(Map<String, Class<?>> map) throws SQLException {\n+        }\n+    }\n+\n+    /*\n+     * Scaffolding test store manager.\n+     */\n+    class TestJDBCStore implements JDBCStore {\n+\n+        public Object find(Object oid, ValueMapping vm,\n+            JDBCFetchConfiguration fetch) {\n+            return null;\n+        }\n+\n+        public JDBCConfiguration getConfiguration() {\n+            return null;\n+        }\n+\n+        public Connection getConnection() {\n+            return new TestConnection();\n+        }\n+\n+        public StoreContext getContext() {\n+            return null;\n+        }\n+\n+        public DBDictionary getDBDictionary() {\n+            return null;\n+        }\n+\n+        public JDBCFetchConfiguration getFetchConfiguration() {\n+            return null;\n+        }\n+\n+        public JDBCLockManager getLockManager() {\n+            return null;\n+        }\n+\n+        public SQLFactory getSQLFactory() {\n+            return null;\n+        }\n+\n+        public void loadSubclasses(ClassMapping mapping) {\n+\n+        }\n+\n+        public Id newDataStoreId(long id, ClassMapping mapping, boolean subs) {\n+            return null;\n+        }\n+    }\n+}"},{"sha":"4f8af9f2a43dca0144219f260390eacf2f21162d","filename":"openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/sql/TestDictionaryFactory.java","status":"modified","additions":203,"deletions":203,"changes":406,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/sql/TestDictionaryFactory.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/sql/TestDictionaryFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/sql/TestDictionaryFactory.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,203 +1,203 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.sql;\r\n-\r\n-import java.lang.reflect.Method;\r\n-\r\n-import junit.framework.TestCase;\r\n-\r\n-public class TestDictionaryFactory extends TestCase {\r\n-\r\n-    private String[][] testMatrix =  {\r\n-        // Generic url\r\n-        {\"jdbc:mysql:\",                                     \r\n-         \"jdbc:mysql:\" },\r\n-        {\"jdbc:cloudscape:database\",\r\n-         \"jdbc:cloudscape:\" },           \r\n-        {\"jdbc:as400://systemname\",\r\n-         \"jdbc:as400:\" },\r\n-        {\"jdbc:Cache://host:1234/db\",\r\n-         \"jdbc:Cache:\" },\r\n-        {\"jdbc:FrontBase://host.domain.com/mydb\",\r\n-         \"jdbc:FrontBase:\" },\r\n-        {\"jdbc:sqlserver://server\\\\instance:1234;p1=v1\",\r\n-         \"jdbc:sqlserver:\"},\r\n-        {\"jdbc:interbase://win32:3/C:/fire/test.gdb\",\r\n-         \"jdbc:interbase:\"},\r\n-        {\"jdbc:firebirdsql://unix/fire/test.gdb\",\r\n-         \"jdbc:firebirdsql:\"},\r\n-        {\"jdbc:db2://localhost:5000/db2\",\r\n-         \"jdbc:db2:\" },\r\n-         \r\n-        // Oracle - Thin and OCI\r\n-        {\"jdbc:oracle:thin:@host:1234:database_sid\",\r\n-         \"jdbc:oracle:thin:\"},\r\n-        {\"jdbc:oracle:oci://host:port/service\", \r\n-         \"jdbc:oracle:oci:\"},\r\n-        {\"jdbc:oracle:thin:host:1234:sid\",      \r\n-         \"jdbc:oracle:thin:\"},\r\n-        {\"jdbc:oracle:oci:TNSName\",       \r\n-         \"jdbc:oracle:oci:\"},\r\n-         \r\n-        // MS SQLServer 2000 Driver\r\n-        {\"jdbc:microsoft:sqlserver://host:123;dbname=name;usr=u;pwd=p\",\r\n-         \"jdbc:microsoft:sqlserver:\"},\r\n-        // MS SQLServer (Sprinta)\r\n-        {\"jdbc:inetdae7:host:1234?database=DB\", \r\n-         \"jdbc:inetdae7:host:\"},\r\n-        // MS Access\r\n-        {\"jdbc:odbc:Driver=Microsoft Access Driver (*.mdb);DBQ=c:\\\\db_file;\",\r\n-         \"jdbc:odbc:Driver=Microsoft Access Driver (*.mdb);DBQ=c:\"},\r\n-         \r\n-        // jTDS JDBC Driver\r\n-        {\"jdbc:jtds:microsoft:host:1234/database\",          \r\n-         \"jdbc:jtds:microsoft:\"},\r\n-        {\"jdbc:jtds:sqlserver://server:1234/database;p=v1\",\r\n-         \"jdbc:jtds:sqlserver:\"},\r\n-         \r\n-        // mySQL\r\n-        {\"jdbc:mysql://host,failoverhost:1234/database\", \r\n-         \"jdbc:mysql:\"},\r\n-        {\"jdbc:mysql://host1:1,host2:2/database?p1=v1&p2=v2\",\r\n-         \"jdbc:mysql:\"},\r\n-         \r\n-        // PostgreSQL\r\n-        {\"jdbc:postgresql:database\",\r\n-         \"jdbc:postgresql:\"},\r\n-\r\n-        // JBOSS\r\n-        {\"jdbc:AvenirDriver://127.0.0.1:1433/master;uid=sa;pwd=sa\",\r\n-         \"jdbc:AvenirDriver:\"},\r\n-        {\"jdbc:merant:sqlserver://suresh:1433\",\r\n-         \"jdbc:merant:sqlserver:\"},\r\n-        {\"jdbc:JSQLConnect://localhost/database=Master&user=sa&password=sa\",\r\n-         \"jdbc:JSQLConnect:\"},\r\n-        {\"jdbc:weblogic:mssqlserver4:Master@suresh:1433?user=sa&password=sa\",\r\n-         \"jdbc:weblogic:mssqlserver4:\"},\r\n-\r\n-        // SyBase\r\n-        {\"jdbc:sybase:Tds:host:1234?ServiceName=database_name\",  \r\n-         \"jdbc:sybase:Tds:\"},\r\n-          \r\n-        // Hypersonic SQL (in-process)\r\n-        {\"jdbc:hsqldb:file:/opt/db/testdb\",\r\n-         \"jdbc:hsqldb:file:\"},\r\n-        // Hypersonic SQL (in-memory)\r\n-        {\"jdbc:hsqldb:mem:aname\",\r\n-         \"jdbc:hsqldb:mem:\"},\r\n-        //Hypersonic SQL (server)\r\n-        {\"jdbc:hsqldb:database\",\r\n-         \"jdbc:hsqldb:\"},\r\n-        {\"jdbc:hsqldb:hsql://host:1234\",\r\n-         \"jdbc:hsqldb:hsql:\"},\r\n-\r\n-        // Informix\r\n-        {\"jdbc:informix-sqli://host:1234/database:informixserver=dbserver.com\",\r\n-         \"jdbc:informix-sqli:\"},\r\n-\r\n-        // Derby\r\n-        {\"jdbc:derby:net://host:1527/<databaseName\",\r\n-         \"jdbc:derby:net:\"},\r\n-\r\n-        // Cloudscape\r\n-        {\"jdbc:cloudscape:MyDataBase\",\r\n-         \"jdbc:cloudscape:\"},\r\n-\r\n-        // PointBase\r\n-         {\"jdbc:pointbase:embedded:PBPUBLIC\",\r\n-          \"jdbc:pointbase:embedded:\"},\r\n-         {\"jdbc:pointbase:server://host:1234/database\",\r\n-          \"jdbc:pointbase:server:\"},\r\n-\r\n-        // Interbase\r\n-        {\"jdbc:interbase:jndi:LDAP_hostname:1234/db\",\r\n-         \"jdbc:interbase:jndi:\"},\r\n-        \r\n-        // Borland JDataStore\r\n-        {\"jdbc:borland:dsremote://hostName/path/storeName.jds\",\r\n-         \"jdbc:borland:dsremote:\"},\r\n-        {\"jdbc:borland:dslocal:storeName.jds\",\r\n-         \"jdbc:borland:dslocal:\"},\r\n-        \r\n-        // EasySoft\r\n-        {\"jdbc:easysoft://server/datasource:logonuser=user:logonpassword=pwd\",\r\n-         \"jdbc:easysoft:\"},\r\n-         \r\n-        // PointBase\r\n-        {\"jdbc:empress:DATABASE=db\",\r\n-         \"jdbc:empress:\"},\r\n-        {\"jdbc:empress://SERVER=localhost;PORT=6322\",\r\n-         \"jdbc:empress:\"},\r\n-        {\"jdbc:pointbase:embedded:sample\",\r\n-         \"jdbc:pointbase:embedded:\"},\r\n-\r\n-        // Interbase (Java driver) / FireBird\r\n-        {\"jdbc:firebirdsql:host/1234:database\",\r\n-         \"jdbc:firebirdsql:\"},\r\n-        {\"jdbc:firebirdsql:localhost/3050:/firebird/test.gdb\",\r\n-         \"jdbc:firebirdsql:\"},\r\n-        \r\n-        // H2 Database (embedded)\r\n-        {\"jdbc:h2:test\",\r\n-         \"jdbc:h2:\"},\r\n-        // H2 Database (Client Server)\r\n-        {\"jdbc:h2:tcp://localhost:9092/test\",\r\n-         \"jdbc:h2:tcp:\"},\r\n-        // H2 Database (In Memory)\r\n-        {\"jdbc:h2:mem:name;key=value\",\r\n-         \"jdbc:h2:mem:\"},\r\n-        {\"jdbc:h2:file:fileName;key=value\",\r\n-         \"jdbc:h2:file:\"},\r\n-         \r\n-        // Error case\r\n-         {\"file://c:/\",\r\n-          null},\r\n-    };\r\n-    \r\n-    private static Method getProtocol;\r\n-\r\n-    public void setUp() {\r\n-        try {\r\n-            getProtocol = DBDictionaryFactory.class.getDeclaredMethod(\r\n-                \"getProtocol\", String.class);\r\n-        } catch (Exception e) {\r\n-            fail(e.getMessage());\r\n-        }\r\n-    }\r\n-    \r\n-    /**\r\n-     * <p>\r\n-     * Tests calculateDBDictionary for the supported database and validate the\r\n-     * proper dictionary is selected based on the jdbc url.\r\n-     * </p>\r\n-     * \r\n-     * @author Albert Lee\r\n-     */\r\n-    public void testUrl2Dictionary() {\r\n-        for (int i = 0; i < testMatrix.length; ++i) {\r\n-            try {\r\n-                String dbType = (String) getProtocol.invoke(null,\r\n-                    testMatrix[i][0]);\r\n-                assertEquals(dbType, testMatrix[i][1]);\r\n-            } catch (Exception e) {\r\n-                fail(e.getMessage());\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.lang.reflect.Method;\n+\n+import junit.framework.TestCase;\n+\n+public class TestDictionaryFactory extends TestCase {\n+\n+    private String[][] testMatrix =  {\n+        // Generic url\n+        {\"jdbc:mysql:\",                                     \n+         \"jdbc:mysql:\" },\n+        {\"jdbc:cloudscape:database\",\n+         \"jdbc:cloudscape:\" },           \n+        {\"jdbc:as400://systemname\",\n+         \"jdbc:as400:\" },\n+        {\"jdbc:Cache://host:1234/db\",\n+         \"jdbc:Cache:\" },\n+        {\"jdbc:FrontBase://host.domain.com/mydb\",\n+         \"jdbc:FrontBase:\" },\n+        {\"jdbc:sqlserver://server\\\\instance:1234;p1=v1\",\n+         \"jdbc:sqlserver:\"},\n+        {\"jdbc:interbase://win32:3/C:/fire/test.gdb\",\n+         \"jdbc:interbase:\"},\n+        {\"jdbc:firebirdsql://unix/fire/test.gdb\",\n+         \"jdbc:firebirdsql:\"},\n+        {\"jdbc:db2://localhost:5000/db2\",\n+         \"jdbc:db2:\" },\n+         \n+        // Oracle - Thin and OCI\n+        {\"jdbc:oracle:thin:@host:1234:database_sid\",\n+         \"jdbc:oracle:thin:\"},\n+        {\"jdbc:oracle:oci://host:port/service\", \n+         \"jdbc:oracle:oci:\"},\n+        {\"jdbc:oracle:thin:host:1234:sid\",      \n+         \"jdbc:oracle:thin:\"},\n+        {\"jdbc:oracle:oci:TNSName\",       \n+         \"jdbc:oracle:oci:\"},\n+         \n+        // MS SQLServer 2000 Driver\n+        {\"jdbc:microsoft:sqlserver://host:123;dbname=name;usr=u;pwd=p\",\n+         \"jdbc:microsoft:sqlserver:\"},\n+        // MS SQLServer (Sprinta)\n+        {\"jdbc:inetdae7:host:1234?database=DB\", \n+         \"jdbc:inetdae7:host:\"},\n+        // MS Access\n+        {\"jdbc:odbc:Driver=Microsoft Access Driver (*.mdb);DBQ=c:\\\\db_file;\",\n+         \"jdbc:odbc:Driver=Microsoft Access Driver (*.mdb);DBQ=c:\"},\n+         \n+        // jTDS JDBC Driver\n+        {\"jdbc:jtds:microsoft:host:1234/database\",          \n+         \"jdbc:jtds:microsoft:\"},\n+        {\"jdbc:jtds:sqlserver://server:1234/database;p=v1\",\n+         \"jdbc:jtds:sqlserver:\"},\n+         \n+        // mySQL\n+        {\"jdbc:mysql://host,failoverhost:1234/database\", \n+         \"jdbc:mysql:\"},\n+        {\"jdbc:mysql://host1:1,host2:2/database?p1=v1&p2=v2\",\n+         \"jdbc:mysql:\"},\n+         \n+        // PostgreSQL\n+        {\"jdbc:postgresql:database\",\n+         \"jdbc:postgresql:\"},\n+\n+        // JBOSS\n+        {\"jdbc:AvenirDriver://127.0.0.1:1433/master;uid=sa;pwd=sa\",\n+         \"jdbc:AvenirDriver:\"},\n+        {\"jdbc:merant:sqlserver://suresh:1433\",\n+         \"jdbc:merant:sqlserver:\"},\n+        {\"jdbc:JSQLConnect://localhost/database=Master&user=sa&password=sa\",\n+         \"jdbc:JSQLConnect:\"},\n+        {\"jdbc:weblogic:mssqlserver4:Master@suresh:1433?user=sa&password=sa\",\n+         \"jdbc:weblogic:mssqlserver4:\"},\n+\n+        // SyBase\n+        {\"jdbc:sybase:Tds:host:1234?ServiceName=database_name\",  \n+         \"jdbc:sybase:Tds:\"},\n+          \n+        // Hypersonic SQL (in-process)\n+        {\"jdbc:hsqldb:file:/opt/db/testdb\",\n+         \"jdbc:hsqldb:file:\"},\n+        // Hypersonic SQL (in-memory)\n+        {\"jdbc:hsqldb:mem:aname\",\n+         \"jdbc:hsqldb:mem:\"},\n+        //Hypersonic SQL (server)\n+        {\"jdbc:hsqldb:database\",\n+         \"jdbc:hsqldb:\"},\n+        {\"jdbc:hsqldb:hsql://host:1234\",\n+         \"jdbc:hsqldb:hsql:\"},\n+\n+        // Informix\n+        {\"jdbc:informix-sqli://host:1234/database:informixserver=dbserver.com\",\n+         \"jdbc:informix-sqli:\"},\n+\n+        // Derby\n+        {\"jdbc:derby:net://host:1527/<databaseName\",\n+         \"jdbc:derby:net:\"},\n+\n+        // Cloudscape\n+        {\"jdbc:cloudscape:MyDataBase\",\n+         \"jdbc:cloudscape:\"},\n+\n+        // PointBase\n+         {\"jdbc:pointbase:embedded:PBPUBLIC\",\n+          \"jdbc:pointbase:embedded:\"},\n+         {\"jdbc:pointbase:server://host:1234/database\",\n+          \"jdbc:pointbase:server:\"},\n+\n+        // Interbase\n+        {\"jdbc:interbase:jndi:LDAP_hostname:1234/db\",\n+         \"jdbc:interbase:jndi:\"},\n+        \n+        // Borland JDataStore\n+        {\"jdbc:borland:dsremote://hostName/path/storeName.jds\",\n+         \"jdbc:borland:dsremote:\"},\n+        {\"jdbc:borland:dslocal:storeName.jds\",\n+         \"jdbc:borland:dslocal:\"},\n+        \n+        // EasySoft\n+        {\"jdbc:easysoft://server/datasource:logonuser=user:logonpassword=pwd\",\n+         \"jdbc:easysoft:\"},\n+         \n+        // PointBase\n+        {\"jdbc:empress:DATABASE=db\",\n+         \"jdbc:empress:\"},\n+        {\"jdbc:empress://SERVER=localhost;PORT=6322\",\n+         \"jdbc:empress:\"},\n+        {\"jdbc:pointbase:embedded:sample\",\n+         \"jdbc:pointbase:embedded:\"},\n+\n+        // Interbase (Java driver) / FireBird\n+        {\"jdbc:firebirdsql:host/1234:database\",\n+         \"jdbc:firebirdsql:\"},\n+        {\"jdbc:firebirdsql:localhost/3050:/firebird/test.gdb\",\n+         \"jdbc:firebirdsql:\"},\n+        \n+        // H2 Database (embedded)\n+        {\"jdbc:h2:test\",\n+         \"jdbc:h2:\"},\n+        // H2 Database (Client Server)\n+        {\"jdbc:h2:tcp://localhost:9092/test\",\n+         \"jdbc:h2:tcp:\"},\n+        // H2 Database (In Memory)\n+        {\"jdbc:h2:mem:name;key=value\",\n+         \"jdbc:h2:mem:\"},\n+        {\"jdbc:h2:file:fileName;key=value\",\n+         \"jdbc:h2:file:\"},\n+         \n+        // Error case\n+         {\"file://c:/\",\n+          null},\n+    };\n+    \n+    private static Method getProtocol;\n+\n+    public void setUp() {\n+        try {\n+            getProtocol = DBDictionaryFactory.class.getDeclaredMethod(\n+                \"getProtocol\", String.class);\n+        } catch (Exception e) {\n+            fail(e.getMessage());\n+        }\n+    }\n+    \n+    /**\n+     * <p>\n+     * Tests calculateDBDictionary for the supported database and validate the\n+     * proper dictionary is selected based on the jdbc url.\n+     * </p>\n+     * \n+     * @author Albert Lee\n+     */\n+    public void testUrl2Dictionary() {\n+        for (int i = 0; i < testMatrix.length; ++i) {\n+            try {\n+                String dbType = (String) getProtocol.invoke(null,\n+                    testMatrix[i][0]);\n+                assertEquals(dbType, testMatrix[i][1]);\n+            } catch (Exception e) {\n+                fail(e.getMessage());\n+            }\n+        }\n+    }\n+}"},{"sha":"8d1bf94ad53d916c4461e21230ecc51d9565ea79","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java","status":"modified","additions":91,"deletions":91,"changes":182,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,92 +1,92 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-\r\n-/**\r\n- * Responsible for marshalling and unmarshalling objects between memory and\r\n- * durable cache.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public interface CacheMarshaller {\r\n-\r\n-    /**\r\n-     * Load and return an instance of the type handled by this marshaller.\r\n-     * If the type implements {@link Configurable}, then this method will invoke\r\n-     * {@link Configurable#setConfiguration}, \r\n-     * {@link Configurable#startConfiguration()}, and\r\n-     * {@link Configurable#endConfiguration()} on the instance before returning.\r\n-     */\r\n-    public Object load();\r\n-\r\n-    /**\r\n-     * Store <code>o</code> into the cache.\r\n-     */\r\n-    public void store(Object o);\r\n-\r\n-    /**\r\n-     * The id that this marshaller is responsible for.\r\n-     * A value for this parameter is required.\r\n-     */\r\n-    public void setId(String id);\r\n-\r\n-    /**\r\n-     * The id that this marshaller is responsible for.\r\n-     */\r\n-    public String getId();\r\n-\r\n-    /**\r\n-     * The {@link ValidationPolicy} that this marshaller should use.\r\n-     * A value for this parameter is required. The class will be instantiated\r\n-     * via the {@link org.apache.openjpa.lib.conf.Configurations} mechanism, ensuring that if the class\r\n-     * implements {@link Configurable} or {@link org.apache.openjpa.lib.conf.GenericConfigurable}, it will\r\n-     * be taken through the appropriate lifecycle.\r\n-     */\r\n-    public void setValidationPolicy(String policy)\r\n-        throws InstantiationException, IllegalAccessException;\r\n-\r\n-    /**\r\n-     * Validation policies are responsible for computing whether or not a\r\n-     * cached data structure is valid for the current context.\r\n-     * <p/>\r\n-     * <code>getValidCachedData(getCacheableData(o), conf)</code> should\r\n-     * return an object equivalent to <code>o</code> in the expected case.\r\n-     * <p/>\r\n-     * Implementations of this class will often also implement\r\n-     * {@link Configurable} in order to receive the current\r\n-     * {@link Configuration}.\r\n-     */\r\n-    public interface ValidationPolicy {\r\n-        /**\r\n-         * Returns an object that this policy considers to be valid, based\r\n-         * on <code>o</code>. If <code>o</code> is not valid, this method\r\n-         * will return <code>null</code>.\r\n-         */\r\n-        public Object getValidData(Object o);\r\n-\r\n-        /**\r\n-         * Return an object that the {@link CacheMarshaller} should store.\r\n-         */\r\n-        public Object getCacheableData(Object o);\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+\n+/**\n+ * Responsible for marshalling and unmarshalling objects between memory and\n+ * durable cache.\n+ *\n+ * @since 1.1.0\n+ */\n+public interface CacheMarshaller {\n+\n+    /**\n+     * Load and return an instance of the type handled by this marshaller.\n+     * If the type implements {@link Configurable}, then this method will invoke\n+     * {@link Configurable#setConfiguration}, \n+     * {@link Configurable#startConfiguration()}, and\n+     * {@link Configurable#endConfiguration()} on the instance before returning.\n+     */\n+    public Object load();\n+\n+    /**\n+     * Store <code>o</code> into the cache.\n+     */\n+    public void store(Object o);\n+\n+    /**\n+     * The id that this marshaller is responsible for.\n+     * A value for this parameter is required.\n+     */\n+    public void setId(String id);\n+\n+    /**\n+     * The id that this marshaller is responsible for.\n+     */\n+    public String getId();\n+\n+    /**\n+     * The {@link ValidationPolicy} that this marshaller should use.\n+     * A value for this parameter is required. The class will be instantiated\n+     * via the {@link org.apache.openjpa.lib.conf.Configurations} mechanism, ensuring that if the class\n+     * implements {@link Configurable} or {@link org.apache.openjpa.lib.conf.GenericConfigurable}, it will\n+     * be taken through the appropriate lifecycle.\n+     */\n+    public void setValidationPolicy(String policy)\n+        throws InstantiationException, IllegalAccessException;\n+\n+    /**\n+     * Validation policies are responsible for computing whether or not a\n+     * cached data structure is valid for the current context.\n+     * <p/>\n+     * <code>getValidCachedData(getCacheableData(o), conf)</code> should\n+     * return an object equivalent to <code>o</code> in the expected case.\n+     * <p/>\n+     * Implementations of this class will often also implement\n+     * {@link Configurable} in order to receive the current\n+     * {@link Configuration}.\n+     */\n+    public interface ValidationPolicy {\n+        /**\n+         * Returns an object that this policy considers to be valid, based\n+         * on <code>o</code>. If <code>o</code> is not valid, this method\n+         * will return <code>null</code>.\n+         */\n+        public Object getValidData(Object o);\n+\n+        /**\n+         * Return an object that the {@link CacheMarshaller} should store.\n+         */\n+        public Object getCacheableData(Object o);\n+    }\n }\n\\ No newline at end of file"},{"sha":"40684bb0fb541b822fec70ab67d85ca4e22a14f0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java","status":"modified","additions":253,"deletions":253,"changes":506,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,253 +1,253 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.io.BufferedInputStream;\r\n-import java.io.BufferedOutputStream;\r\n-import java.io.File;\r\n-import java.io.FileOutputStream;\r\n-import java.io.IOException;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ObjectOutputStream;\r\n-import java.io.OutputStream;\r\n-import java.net.URL;\r\n-import java.util.Enumeration;\r\n-import java.util.List;\r\n-import java.util.ArrayList;\r\n-\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.Configurations;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.InternalException;\r\n-\r\n-/**\r\n- * Default {@link CacheMarshaller} implementation that writes data\r\n- * to a specified file and reads data from a specified file or URL.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class CacheMarshallerImpl\r\n-    implements CacheMarshaller, Configurable {\r\n-\r\n-    private static final Localizer _loc =\r\n-        Localizer.forPackage(CacheMarshallerImpl.class);\r\n-\r\n-    private String _id;\r\n-    private ValidationPolicy _validationPolicy;\r\n-    private OpenJPAConfiguration _conf;\r\n-    private Log _log;\r\n-    private File _outputFile;\r\n-    private URL _inputURL;\r\n-\r\n-    // temporary storage for resource location specification\r\n-    private String _inputResourceLocation;\r\n-    \r\n-    private boolean _consumeErrors = true;\r\n-\r\n-    public Object load() {\r\n-        if (_inputURL == null) {\r\n-            _log.trace(_loc.get(\"cache-marshaller-no-inputs\", getId()));\r\n-            return null;\r\n-        }\r\n-\r\n-        Object o = null;\r\n-        ObjectInputStream in = null;\r\n-        try {\r\n-            in = new ObjectInputStream(new BufferedInputStream(\r\n-                _inputURL.openStream()));\r\n-\r\n-            o = in.readObject();\r\n-            o = _validationPolicy.getValidData(o);\r\n-\r\n-            if (o != null && o.getClass().isArray()) {\r\n-                Object[] array = (Object[]) o;\r\n-                for (int i = 0; i < array.length; i++)\r\n-                    configure(array[i]);\r\n-            } else {\r\n-                configure(o);\r\n-            }\r\n-\r\n-            if (_log.isTraceEnabled())\r\n-                _log.trace(_loc.get(\"cache-marshaller-loaded\",\r\n-                    o == null ? null : o.getClass().getName(), _inputURL));\r\n-        } catch (Exception e) {\r\n-            if (_consumeErrors) {\r\n-                if (_log.isWarnEnabled())\r\n-                    _log.warn(_loc.get(\"cache-marshaller-load-exception-ignore\",\r\n-                        _inputURL), e);\r\n-            } else {\r\n-                throw new InternalException(\r\n-                    _loc.get(\"cache-marshaller-load-exception-fatal\",\r\n-                        _inputURL),\r\n-                    e);\r\n-            }\r\n-        } finally {\r\n-            if (in != null)\r\n-                try { in.close(); } catch (IOException e) { }\r\n-        }\r\n-\r\n-        return o;\r\n-    }\r\n-\r\n-    private void configure(Object o) {\r\n-        if (o instanceof Configurable) {\r\n-            ((Configurable) o).setConfiguration(_conf);\r\n-            ((Configurable) o).startConfiguration();\r\n-            ((Configurable) o).endConfiguration();\r\n-        }\r\n-    }\r\n-\r\n-    public void store(Object o) {\r\n-        if (_outputFile == null) {\r\n-            _log.trace(_loc.get(\"cache-marshaller-no-output-file\", getId()));\r\n-            return;\r\n-        }\r\n-        OutputStream out = null;\r\n-        try {\r\n-            out = new FileOutputStream(_outputFile);\r\n-            ObjectOutputStream oos =\r\n-                new ObjectOutputStream(new BufferedOutputStream(out));\r\n-            Object toStore = _validationPolicy.getCacheableData(o);\r\n-            oos.writeObject(toStore);\r\n-            oos.flush();\r\n-            out.flush();\r\n-            if (_log.isTraceEnabled())\r\n-                _log.trace(_loc.get(\"cache-marshaller-stored\",\r\n-                    o.getClass().getName(), _outputFile));\r\n-        } catch (Exception e) {\r\n-            if (_consumeErrors) {\r\n-                if (_log.isWarnEnabled())\r\n-                    _log.warn(_loc.get(\"cache-marshaller-store-exception\",\r\n-                        o.getClass().getName(), _outputFile), e);\r\n-            } else {\r\n-                throw new InternalException(\r\n-                    _loc.get(\"cache-marshaller-store-exception\",\r\n-                        o.getClass().getName(), _outputFile),\r\n-                    e);\r\n-            }\r\n-        } finally {\r\n-            if (out != null) {\r\n-                try { out.close(); } catch (IOException ioe) { }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void setOutputFile(File file) {\r\n-        _outputFile = file;\r\n-    }\r\n-\r\n-    public File getOutputFile() {\r\n-        return _outputFile;\r\n-    }\r\n-\r\n-    public void setInputURL(URL url) {\r\n-        _inputURL = url;\r\n-    }\r\n-\r\n-    public void setInputResource(String resource) {\r\n-        _inputResourceLocation = resource;\r\n-    }\r\n-\r\n-    public void setConsumeSerializationErrors(boolean consume) {\r\n-        _consumeErrors = consume;\r\n-    }\r\n-\r\n-    public String getId() {\r\n-        return _id;\r\n-    }\r\n-\r\n-    public void setId(String id) {\r\n-        _id = id;\r\n-    }\r\n-\r\n-    public void setValidationPolicy(String policy)\r\n-        throws InstantiationException, IllegalAccessException {\r\n-        String name = Configurations.getClassName(policy);\r\n-        String props = Configurations.getProperties(policy);\r\n-        _validationPolicy = (ValidationPolicy)\r\n-            Configurations.newInstance(name, _conf, props, null);\r\n-    }\r\n-\r\n-    public ValidationPolicy getValidationPolicy() {\r\n-        return _validationPolicy;\r\n-    }\r\n-\r\n-    public void setConfiguration(Configuration conf) {\r\n-        _conf = (OpenJPAConfiguration) conf;\r\n-        _log = conf.getConfigurationLog();\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-        if (_inputResourceLocation != null && _inputURL != null)\r\n-            throw new IllegalStateException(\r\n-                _loc.get(\"cache-marshaller-input-url-and-resource-specified\")\r\n-                    .getMessage());\r\n-        if (_inputResourceLocation != null)\r\n-            setInputUrlFromResourceLocation();\r\n-\r\n-        if (_validationPolicy == null)\r\n-            throw new IllegalStateException(\r\n-                _loc.get(\"cache-marshaller-null-validation-policy\",\r\n-                    getClass().getName()).getMessage());\r\n-        if (_id == null)\r\n-            throw new IllegalStateException(\r\n-                _loc.get(\"cache-marshaller-null-id\",\r\n-                    getClass().getName()).getMessage());\r\n-    }\r\n-\r\n-    private void setInputUrlFromResourceLocation() {\r\n-        try {\r\n-            ClassLoader cl = _conf.getClassResolverInstance()\r\n-                .getClassLoader(getClass(), null);\r\n-            List list = new ArrayList();\r\n-            for (Enumeration e = cl.getResources(_inputResourceLocation);\r\n-                e.hasMoreElements(); )\r\n-                list.add(e);\r\n-\r\n-            if (list.size() > 1) {\r\n-                if (_consumeErrors) {\r\n-                    if (_log.isWarnEnabled())\r\n-                        _log.warn(_loc.get(\r\n-                            \"cache-marshaller-multiple-resources-warn\",\r\n-                            getId(), _inputResourceLocation, list)\r\n-                            .getMessage());\r\n-                } else {\r\n-                    throw new IllegalStateException(\r\n-                        _loc.get(\"cache-marshaller-multiple-resources\",\r\n-                            getId(), _inputResourceLocation, list)\r\n-                            .getMessage());\r\n-                }\r\n-            }\r\n-\r\n-            if (!list.isEmpty())\r\n-                _inputURL = (URL) list.get(0);\r\n-        } catch (IOException ioe) {\r\n-            IllegalStateException ise = new IllegalStateException(\r\n-                _loc.get(\"cache-marshaller-bad-url\", getId(),\r\n-                    _inputResourceLocation).getMessage());\r\n-            ise.initCause(ioe);\r\n-            throw ise;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.net.URL;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InternalException;\n+\n+/**\n+ * Default {@link CacheMarshaller} implementation that writes data\n+ * to a specified file and reads data from a specified file or URL.\n+ *\n+ * @since 1.1.0\n+ */\n+public class CacheMarshallerImpl\n+    implements CacheMarshaller, Configurable {\n+\n+    private static final Localizer _loc =\n+        Localizer.forPackage(CacheMarshallerImpl.class);\n+\n+    private String _id;\n+    private ValidationPolicy _validationPolicy;\n+    private OpenJPAConfiguration _conf;\n+    private Log _log;\n+    private File _outputFile;\n+    private URL _inputURL;\n+\n+    // temporary storage for resource location specification\n+    private String _inputResourceLocation;\n+    \n+    private boolean _consumeErrors = true;\n+\n+    public Object load() {\n+        if (_inputURL == null) {\n+            _log.trace(_loc.get(\"cache-marshaller-no-inputs\", getId()));\n+            return null;\n+        }\n+\n+        Object o = null;\n+        ObjectInputStream in = null;\n+        try {\n+            in = new ObjectInputStream(new BufferedInputStream(\n+                _inputURL.openStream()));\n+\n+            o = in.readObject();\n+            o = _validationPolicy.getValidData(o);\n+\n+            if (o != null && o.getClass().isArray()) {\n+                Object[] array = (Object[]) o;\n+                for (int i = 0; i < array.length; i++)\n+                    configure(array[i]);\n+            } else {\n+                configure(o);\n+            }\n+\n+            if (_log.isTraceEnabled())\n+                _log.trace(_loc.get(\"cache-marshaller-loaded\",\n+                    o == null ? null : o.getClass().getName(), _inputURL));\n+        } catch (Exception e) {\n+            if (_consumeErrors) {\n+                if (_log.isWarnEnabled())\n+                    _log.warn(_loc.get(\"cache-marshaller-load-exception-ignore\",\n+                        _inputURL), e);\n+            } else {\n+                throw new InternalException(\n+                    _loc.get(\"cache-marshaller-load-exception-fatal\",\n+                        _inputURL),\n+                    e);\n+            }\n+        } finally {\n+            if (in != null)\n+                try { in.close(); } catch (IOException e) { }\n+        }\n+\n+        return o;\n+    }\n+\n+    private void configure(Object o) {\n+        if (o instanceof Configurable) {\n+            ((Configurable) o).setConfiguration(_conf);\n+            ((Configurable) o).startConfiguration();\n+            ((Configurable) o).endConfiguration();\n+        }\n+    }\n+\n+    public void store(Object o) {\n+        if (_outputFile == null) {\n+            _log.trace(_loc.get(\"cache-marshaller-no-output-file\", getId()));\n+            return;\n+        }\n+        OutputStream out = null;\n+        try {\n+            out = new FileOutputStream(_outputFile);\n+            ObjectOutputStream oos =\n+                new ObjectOutputStream(new BufferedOutputStream(out));\n+            Object toStore = _validationPolicy.getCacheableData(o);\n+            oos.writeObject(toStore);\n+            oos.flush();\n+            out.flush();\n+            if (_log.isTraceEnabled())\n+                _log.trace(_loc.get(\"cache-marshaller-stored\",\n+                    o.getClass().getName(), _outputFile));\n+        } catch (Exception e) {\n+            if (_consumeErrors) {\n+                if (_log.isWarnEnabled())\n+                    _log.warn(_loc.get(\"cache-marshaller-store-exception\",\n+                        o.getClass().getName(), _outputFile), e);\n+            } else {\n+                throw new InternalException(\n+                    _loc.get(\"cache-marshaller-store-exception\",\n+                        o.getClass().getName(), _outputFile),\n+                    e);\n+            }\n+        } finally {\n+            if (out != null) {\n+                try { out.close(); } catch (IOException ioe) { }\n+            }\n+        }\n+    }\n+\n+    public void setOutputFile(File file) {\n+        _outputFile = file;\n+    }\n+\n+    public File getOutputFile() {\n+        return _outputFile;\n+    }\n+\n+    public void setInputURL(URL url) {\n+        _inputURL = url;\n+    }\n+\n+    public void setInputResource(String resource) {\n+        _inputResourceLocation = resource;\n+    }\n+\n+    public void setConsumeSerializationErrors(boolean consume) {\n+        _consumeErrors = consume;\n+    }\n+\n+    public String getId() {\n+        return _id;\n+    }\n+\n+    public void setId(String id) {\n+        _id = id;\n+    }\n+\n+    public void setValidationPolicy(String policy)\n+        throws InstantiationException, IllegalAccessException {\n+        String name = Configurations.getClassName(policy);\n+        String props = Configurations.getProperties(policy);\n+        _validationPolicy = (ValidationPolicy)\n+            Configurations.newInstance(name, _conf, props, null);\n+    }\n+\n+    public ValidationPolicy getValidationPolicy() {\n+        return _validationPolicy;\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+        _conf = (OpenJPAConfiguration) conf;\n+        _log = conf.getConfigurationLog();\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+        if (_inputResourceLocation != null && _inputURL != null)\n+            throw new IllegalStateException(\n+                _loc.get(\"cache-marshaller-input-url-and-resource-specified\")\n+                    .getMessage());\n+        if (_inputResourceLocation != null)\n+            setInputUrlFromResourceLocation();\n+\n+        if (_validationPolicy == null)\n+            throw new IllegalStateException(\n+                _loc.get(\"cache-marshaller-null-validation-policy\",\n+                    getClass().getName()).getMessage());\n+        if (_id == null)\n+            throw new IllegalStateException(\n+                _loc.get(\"cache-marshaller-null-id\",\n+                    getClass().getName()).getMessage());\n+    }\n+\n+    private void setInputUrlFromResourceLocation() {\n+        try {\n+            ClassLoader cl = _conf.getClassResolverInstance()\n+                .getClassLoader(getClass(), null);\n+            List list = new ArrayList();\n+            for (Enumeration e = cl.getResources(_inputResourceLocation);\n+                e.hasMoreElements(); )\n+                list.add(e);\n+\n+            if (list.size() > 1) {\n+                if (_consumeErrors) {\n+                    if (_log.isWarnEnabled())\n+                        _log.warn(_loc.get(\n+                            \"cache-marshaller-multiple-resources-warn\",\n+                            getId(), _inputResourceLocation, list)\n+                            .getMessage());\n+                } else {\n+                    throw new IllegalStateException(\n+                        _loc.get(\"cache-marshaller-multiple-resources\",\n+                            getId(), _inputResourceLocation, list)\n+                            .getMessage());\n+                }\n+            }\n+\n+            if (!list.isEmpty())\n+                _inputURL = (URL) list.get(0);\n+        } catch (IOException ioe) {\n+            IllegalStateException ise = new IllegalStateException(\n+                _loc.get(\"cache-marshaller-bad-url\", getId(),\n+                    _inputResourceLocation).getMessage());\n+            ise.initCause(ioe);\n+            throw ise;\n+        }\n+    }\n+}"},{"sha":"e0efef07e32d41743f552706ff487e660d72aac0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java","status":"modified","additions":121,"deletions":121,"changes":242,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,121 +1,121 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.HashMap;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.conf.PluginListValue;\r\n-import org.apache.openjpa.conf.NoOpCacheMarshaller;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-\r\n-/**\r\n- * A configuration value for handling and accessing cache marshallers.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class CacheMarshallersValue\r\n-    extends PluginListValue {\r\n-\r\n-    private static final String KEY = \"CacheMarshallers\";\r\n-    private static final CacheMarshaller NO_OP_CACHE_MARSHALLER\r\n-        = new NoOpCacheMarshaller();\r\n-    private static final Localizer _loc =\r\n-        Localizer.forPackage(CacheMarshallersValue.class);\r\n-\r\n-    private Configuration _conf;\r\n-    private Map _marshallers;\r\n-    private boolean _initialized;\r\n-\r\n-    public CacheMarshallersValue(Configuration conf) {\r\n-        super(KEY);\r\n-        _conf = conf;\r\n-        setAlias(\"default\", CacheMarshallerImpl.class.getName());\r\n-        setAlias(\"none\", null);\r\n-        setDefault(\"none\");\r\n-        setString(\"none\");\r\n-        setScope(getClass());\r\n-    }\r\n-\r\n-    public Object instantiate(Class elemType, Configuration conf,\r\n-        boolean fatal) {\r\n-        CacheMarshaller[] ms = (CacheMarshaller[])\r\n-            super.instantiate(elemType, conf, fatal);\r\n-        if (ms != null) {\r\n-            _marshallers = new HashMap();\r\n-            for (int i = 0; i < ms.length; i++) {\r\n-                String mid = ms[i].getId();\r\n-                if (mid != null)\r\n-                    _marshallers.put(mid, ms[i]);\r\n-            }\r\n-        } else {\r\n-            _marshallers = null;\r\n-        }\r\n-        return ms;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the {@link CacheMarshaller} to use for caching metadata of id\r\n-     * <code>id</code>. If no marshaller exists for the id, returns\r\n-     * {@link NoOpCacheMarshaller}.\r\n-     */\r\n-    public CacheMarshaller getMarshallerById(String id) {\r\n-        initialize();\r\n-\r\n-        CacheMarshaller cm = (CacheMarshaller) _marshallers.get(id);\r\n-        if (cm == null) {\r\n-            if (getLog().isTraceEnabled())\r\n-                getLog().trace(_loc.get(\"cache-marshaller-not-found\", id));\r\n-            return NO_OP_CACHE_MARSHALLER;\r\n-        } else {\r\n-            if (getLog().isTraceEnabled())\r\n-                getLog().trace(_loc.get(\"cache-marshaller-found\", id,\r\n-                    cm.getClass().getName()));\r\n-            return cm;\r\n-        }\r\n-    }\r\n-\r\n-    private Log getLog() {\r\n-        return _conf.getConfigurationLog();\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the {@link CacheMarshaller} to use for caching metadata of id\r\n-     * <code>id</code>. If no marshaller exists for the id, returns\r\n-     * {@link NoOpCacheMarshaller}.\r\n-     */\r\n-    public static CacheMarshaller getMarshallerById(Configuration c, String id){\r\n-        CacheMarshallersValue v =\r\n-            ((OpenJPAConfigurationImpl) c).cacheMarshallerPlugins;\r\n-        return v.getMarshallerById(id);\r\n-    }\r\n-\r\n-    public Map getInstancesAsMap() {\r\n-        return _marshallers;\r\n-    }\r\n-\r\n-    protected synchronized void initialize() {\r\n-        if (!_initialized) {\r\n-            instantiate(CacheMarshaller.class, _conf);\r\n-            _initialized = true;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.conf.PluginListValue;\n+import org.apache.openjpa.conf.NoOpCacheMarshaller;\n+import org.apache.openjpa.lib.conf.Configuration;\n+\n+/**\n+ * A configuration value for handling and accessing cache marshallers.\n+ *\n+ * @since 1.1.0\n+ */\n+public class CacheMarshallersValue\n+    extends PluginListValue {\n+\n+    private static final String KEY = \"CacheMarshallers\";\n+    private static final CacheMarshaller NO_OP_CACHE_MARSHALLER\n+        = new NoOpCacheMarshaller();\n+    private static final Localizer _loc =\n+        Localizer.forPackage(CacheMarshallersValue.class);\n+\n+    private Configuration _conf;\n+    private Map _marshallers;\n+    private boolean _initialized;\n+\n+    public CacheMarshallersValue(Configuration conf) {\n+        super(KEY);\n+        _conf = conf;\n+        setAlias(\"default\", CacheMarshallerImpl.class.getName());\n+        setAlias(\"none\", null);\n+        setDefault(\"none\");\n+        setString(\"none\");\n+        setScope(getClass());\n+    }\n+\n+    public Object instantiate(Class elemType, Configuration conf,\n+        boolean fatal) {\n+        CacheMarshaller[] ms = (CacheMarshaller[])\n+            super.instantiate(elemType, conf, fatal);\n+        if (ms != null) {\n+            _marshallers = new HashMap();\n+            for (int i = 0; i < ms.length; i++) {\n+                String mid = ms[i].getId();\n+                if (mid != null)\n+                    _marshallers.put(mid, ms[i]);\n+            }\n+        } else {\n+            _marshallers = null;\n+        }\n+        return ms;\n+    }\n+\n+    /**\n+     * Return the {@link CacheMarshaller} to use for caching metadata of id\n+     * <code>id</code>. If no marshaller exists for the id, returns\n+     * {@link NoOpCacheMarshaller}.\n+     */\n+    public CacheMarshaller getMarshallerById(String id) {\n+        initialize();\n+\n+        CacheMarshaller cm = (CacheMarshaller) _marshallers.get(id);\n+        if (cm == null) {\n+            if (getLog().isTraceEnabled())\n+                getLog().trace(_loc.get(\"cache-marshaller-not-found\", id));\n+            return NO_OP_CACHE_MARSHALLER;\n+        } else {\n+            if (getLog().isTraceEnabled())\n+                getLog().trace(_loc.get(\"cache-marshaller-found\", id,\n+                    cm.getClass().getName()));\n+            return cm;\n+        }\n+    }\n+\n+    private Log getLog() {\n+        return _conf.getConfigurationLog();\n+    }\n+\n+    /**\n+     * Return the {@link CacheMarshaller} to use for caching metadata of id\n+     * <code>id</code>. If no marshaller exists for the id, returns\n+     * {@link NoOpCacheMarshaller}.\n+     */\n+    public static CacheMarshaller getMarshallerById(Configuration c, String id){\n+        CacheMarshallersValue v =\n+            ((OpenJPAConfigurationImpl) c).cacheMarshallerPlugins;\n+        return v.getMarshallerById(id);\n+    }\n+\n+    public Map getInstancesAsMap() {\n+        return _marshallers;\n+    }\n+\n+    protected synchronized void initialize() {\n+        if (!_initialized) {\n+            instantiate(CacheMarshaller.class, _conf);\n+            _initialized = true;\n+        }\n+    }\n+}"},{"sha":"854f1a64843d8521f52481bd35c43975ca4ce3db","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java","status":"modified","additions":202,"deletions":202,"changes":404,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,202 +1,202 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.kernel.Bootstrap;\r\n-import org.apache.openjpa.kernel.Broker;\r\n-import org.apache.openjpa.kernel.BrokerFactory;\r\n-import org.apache.openjpa.kernel.Query;\r\n-import org.apache.openjpa.lib.util.Options;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.conf.MapConfigurationProvider;\r\n-import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.meta.QueryMetaData;\r\n-import org.apache.openjpa.meta.SequenceMetaData;\r\n-\r\n-/**\r\n- * Performs maintenance tasks on the metadata caches accessible via the\r\n- * {@link CacheMarshaller} architecture.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class MetaDataCacheMaintenance {\r\n-\r\n-    private final BrokerFactory factory;\r\n-    private final OpenJPAConfiguration conf;\r\n-    private final boolean devpath;\r\n-    private Log log;\r\n-\r\n-    public static void main(String[] args) {\r\n-        Options opts = new Options();\r\n-        args = opts.setFromCmdLine(args);\r\n-        boolean devpath = opts.getBooleanProperty(\"scanDevPath\", \"ScanDevPath\",\r\n-            true);\r\n-\r\n-        ConfigurationProvider cp = new MapConfigurationProvider(opts);\r\n-        BrokerFactory factory = Bootstrap.newBrokerFactory(cp, null);\r\n-        try {\r\n-            MetaDataCacheMaintenance maint = new MetaDataCacheMaintenance(\r\n-                factory, devpath);\r\n-\r\n-            if (args.length != 1) {\r\n-                usage();\r\n-                return;\r\n-            }\r\n-\r\n-            if (\"store\".equals(args[0]))\r\n-                maint.store();\r\n-            else if (\"dump\".equals(args[0]))\r\n-                maint.dump();\r\n-            else\r\n-                usage();\r\n-        } finally {\r\n-            factory.close();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @deprecated logging is routed to the logging system now.\r\n-     */\r\n-    public MetaDataCacheMaintenance(BrokerFactory factory, boolean devpath,\r\n-        boolean verbose) {\r\n-        this(factory, devpath);\r\n-    }\r\n-\r\n-    /**\r\n-     * @param factory The {@link BrokerFactory} for which cached metadata\r\n-     * should be built.\r\n-     * @param devpath Whether or not to scan the development environment paths\r\n-     * to find persistent types to store.\r\n-     */\r\n-    public MetaDataCacheMaintenance(BrokerFactory factory, boolean devpath) {\r\n-        this.factory = factory;\r\n-        this.conf = factory.getConfiguration();\r\n-        this.devpath = devpath;\r\n-        this.log = conf.getLog(OpenJPAConfiguration.LOG_TOOL);\r\n-    }\r\n-\r\n-    public void setLog(Log log) {\r\n-        this.log = log;\r\n-    }\r\n-\r\n-    private static int usage() {\r\n-        System.err.println(\"Usage: java MetaDataCacheMaintenance \" +\r\n-            \"[-scanDevPath t|f] [-<openjpa.PropertyName> value] store | dump\");\r\n-        return -1;\r\n-    }\r\n-\r\n-    /**\r\n-     * The metadata repository for the factory that this instance was\r\n-     * constructed with will be serialized, along with any query\r\n-     * compilations etc. that have been created for the factory.\r\n-     */\r\n-    public void store() {\r\n-        MetaDataRepository repos = conf.getMetaDataRepositoryInstance();\r\n-        repos.setSourceMode(MetaDataRepository.MODE_ALL);\r\n-        Collection types = repos.loadPersistentTypes(devpath, null);\r\n-        for (Iterator iter = types.iterator(); iter.hasNext(); )\r\n-            repos.getMetaData((Class) iter.next(), null, true);\r\n-\r\n-        loadQueries();\r\n-\r\n-        log.info(\"The following data will be stored: \");\r\n-        log(repos, conf.getQueryCompilationCacheInstance());\r\n-\r\n-        CacheMarshallersValue.getMarshallerById(conf, getClass().getName())\r\n-            .store(new Object[] {\r\n-                repos, conf.getQueryCompilationCacheInstance()\r\n-            });\r\n-    }\r\n-\r\n-    private void loadQueries() {\r\n-        Broker broker = factory.newBroker();\r\n-        try {\r\n-            QueryMetaData[] qmds =\r\n-                conf.getMetaDataRepositoryInstance().getQueryMetaDatas();\r\n-            for (int i = 0; i < qmds.length; i++)\r\n-                loadQuery(broker, qmds[i]);\r\n-        } finally {\r\n-            broker.close();\r\n-        }\r\n-    }\r\n-\r\n-    private void loadQuery(Broker broker, QueryMetaData qmd) {\r\n-        try {\r\n-            Query q = broker.newQuery(qmd.getLanguage(), null);\r\n-            qmd.setInto(q);\r\n-            q.compile();\r\n-        } catch (Exception e) {\r\n-            if (log.isTraceEnabled()) {\r\n-                log.warn(\"Skipping named query \" + qmd.getName() + \": \"\r\n-                    + e.getMessage(), e);\r\n-            } else {\r\n-                log.warn(\"Skipping named query \" + qmd.getName() + \": \"\r\n-                    + e.getMessage());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void dump() {\r\n-        Object[] os = (Object[])\r\n-            CacheMarshallersValue.getMarshallerById(conf, getClass().getName())\r\n-            .load();\r\n-        if (os == null) {\r\n-            log.info(\"No cached data was found\");\r\n-            return;\r\n-        }\r\n-        MetaDataRepository repos = (MetaDataRepository) os[0];\r\n-        Map qcc = (Map) os[1];\r\n-\r\n-        log.info(\"The following data was found: \");\r\n-        log(repos, qcc);\r\n-    }\r\n-\r\n-    private void log(MetaDataRepository repos, Map qcc) {\r\n-        ClassMetaData[] metas = repos.getMetaDatas();\r\n-        log.info(\"  Types: \" + metas.length);\r\n-        if (log.isTraceEnabled())\r\n-            for (int i = 0; i < metas.length; i++)\r\n-                log.trace(\"    \" + metas[i].getDescribedType().getName());\r\n-\r\n-        QueryMetaData[] qmds = repos.getQueryMetaDatas();\r\n-        log.info(\"  Queries: \" + qmds.length);\r\n-        if (log.isTraceEnabled())\r\n-            for (int i = 0; i < qmds.length; i++)\r\n-                log.trace(\"    \" + qmds[i].getName() + \": \"\r\n-                    + qmds[i].getQueryString());\r\n-\r\n-        SequenceMetaData[] smds = repos.getSequenceMetaDatas();\r\n-        log.info(\"  Sequences: \" + smds.length);\r\n-        if (log.isTraceEnabled())\r\n-            for (int i = 0; i < smds.length; i++)\r\n-                log.trace(\"    \" + smds[i].getName());\r\n-\r\n-        log.info(\"  Compiled queries: \"\r\n-            + (qcc == null ? \"0\" : \"\" + qcc.size()));\r\n-        if (log.isTraceEnabled() && qcc != null)\r\n-            for (Iterator iter = qcc.keySet().iterator(); iter.hasNext(); )\r\n-                log.trace(\"    \" + iter.next());\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.openjpa.kernel.Bootstrap;\n+import org.apache.openjpa.kernel.Broker;\n+import org.apache.openjpa.kernel.BrokerFactory;\n+import org.apache.openjpa.kernel.Query;\n+import org.apache.openjpa.lib.util.Options;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.conf.MapConfigurationProvider;\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.meta.QueryMetaData;\n+import org.apache.openjpa.meta.SequenceMetaData;\n+\n+/**\n+ * Performs maintenance tasks on the metadata caches accessible via the\n+ * {@link CacheMarshaller} architecture.\n+ *\n+ * @since 1.1.0\n+ */\n+public class MetaDataCacheMaintenance {\n+\n+    private final BrokerFactory factory;\n+    private final OpenJPAConfiguration conf;\n+    private final boolean devpath;\n+    private Log log;\n+\n+    public static void main(String[] args) {\n+        Options opts = new Options();\n+        args = opts.setFromCmdLine(args);\n+        boolean devpath = opts.getBooleanProperty(\"scanDevPath\", \"ScanDevPath\",\n+            true);\n+\n+        ConfigurationProvider cp = new MapConfigurationProvider(opts);\n+        BrokerFactory factory = Bootstrap.newBrokerFactory(cp, null);\n+        try {\n+            MetaDataCacheMaintenance maint = new MetaDataCacheMaintenance(\n+                factory, devpath);\n+\n+            if (args.length != 1) {\n+                usage();\n+                return;\n+            }\n+\n+            if (\"store\".equals(args[0]))\n+                maint.store();\n+            else if (\"dump\".equals(args[0]))\n+                maint.dump();\n+            else\n+                usage();\n+        } finally {\n+            factory.close();\n+        }\n+    }\n+\n+    /**\n+     * @deprecated logging is routed to the logging system now.\n+     */\n+    public MetaDataCacheMaintenance(BrokerFactory factory, boolean devpath,\n+        boolean verbose) {\n+        this(factory, devpath);\n+    }\n+\n+    /**\n+     * @param factory The {@link BrokerFactory} for which cached metadata\n+     * should be built.\n+     * @param devpath Whether or not to scan the development environment paths\n+     * to find persistent types to store.\n+     */\n+    public MetaDataCacheMaintenance(BrokerFactory factory, boolean devpath) {\n+        this.factory = factory;\n+        this.conf = factory.getConfiguration();\n+        this.devpath = devpath;\n+        this.log = conf.getLog(OpenJPAConfiguration.LOG_TOOL);\n+    }\n+\n+    public void setLog(Log log) {\n+        this.log = log;\n+    }\n+\n+    private static int usage() {\n+        System.err.println(\"Usage: java MetaDataCacheMaintenance \" +\n+            \"[-scanDevPath t|f] [-<openjpa.PropertyName> value] store | dump\");\n+        return -1;\n+    }\n+\n+    /**\n+     * The metadata repository for the factory that this instance was\n+     * constructed with will be serialized, along with any query\n+     * compilations etc. that have been created for the factory.\n+     */\n+    public void store() {\n+        MetaDataRepository repos = conf.getMetaDataRepositoryInstance();\n+        repos.setSourceMode(MetaDataRepository.MODE_ALL);\n+        Collection types = repos.loadPersistentTypes(devpath, null);\n+        for (Iterator iter = types.iterator(); iter.hasNext(); )\n+            repos.getMetaData((Class) iter.next(), null, true);\n+\n+        loadQueries();\n+\n+        log.info(\"The following data will be stored: \");\n+        log(repos, conf.getQueryCompilationCacheInstance());\n+\n+        CacheMarshallersValue.getMarshallerById(conf, getClass().getName())\n+            .store(new Object[] {\n+                repos, conf.getQueryCompilationCacheInstance()\n+            });\n+    }\n+\n+    private void loadQueries() {\n+        Broker broker = factory.newBroker();\n+        try {\n+            QueryMetaData[] qmds =\n+                conf.getMetaDataRepositoryInstance().getQueryMetaDatas();\n+            for (int i = 0; i < qmds.length; i++)\n+                loadQuery(broker, qmds[i]);\n+        } finally {\n+            broker.close();\n+        }\n+    }\n+\n+    private void loadQuery(Broker broker, QueryMetaData qmd) {\n+        try {\n+            Query q = broker.newQuery(qmd.getLanguage(), null);\n+            qmd.setInto(q);\n+            q.compile();\n+        } catch (Exception e) {\n+            if (log.isTraceEnabled()) {\n+                log.warn(\"Skipping named query \" + qmd.getName() + \": \"\n+                    + e.getMessage(), e);\n+            } else {\n+                log.warn(\"Skipping named query \" + qmd.getName() + \": \"\n+                    + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void dump() {\n+        Object[] os = (Object[])\n+            CacheMarshallersValue.getMarshallerById(conf, getClass().getName())\n+            .load();\n+        if (os == null) {\n+            log.info(\"No cached data was found\");\n+            return;\n+        }\n+        MetaDataRepository repos = (MetaDataRepository) os[0];\n+        Map qcc = (Map) os[1];\n+\n+        log.info(\"The following data was found: \");\n+        log(repos, qcc);\n+    }\n+\n+    private void log(MetaDataRepository repos, Map qcc) {\n+        ClassMetaData[] metas = repos.getMetaDatas();\n+        log.info(\"  Types: \" + metas.length);\n+        if (log.isTraceEnabled())\n+            for (int i = 0; i < metas.length; i++)\n+                log.trace(\"    \" + metas[i].getDescribedType().getName());\n+\n+        QueryMetaData[] qmds = repos.getQueryMetaDatas();\n+        log.info(\"  Queries: \" + qmds.length);\n+        if (log.isTraceEnabled())\n+            for (int i = 0; i < qmds.length; i++)\n+                log.trace(\"    \" + qmds[i].getName() + \": \"\n+                    + qmds[i].getQueryString());\n+\n+        SequenceMetaData[] smds = repos.getSequenceMetaDatas();\n+        log.info(\"  Sequences: \" + smds.length);\n+        if (log.isTraceEnabled())\n+            for (int i = 0; i < smds.length; i++)\n+                log.trace(\"    \" + smds[i].getName());\n+\n+        log.info(\"  Compiled queries: \"\n+            + (qcc == null ? \"0\" : \"\" + qcc.size()));\n+        if (log.isTraceEnabled() && qcc != null)\n+            for (Iterator iter = qcc.keySet().iterator(); iter.hasNext(); )\n+                log.trace(\"    \" + iter.next());\n+    }\n+}"},{"sha":"c027a5271c0d1b73161c75f08a698830accbc227","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","status":"modified","additions":74,"deletions":74,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,74 +1,74 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.PluginValue;\r\n-import org.apache.openjpa.conf.CacheMarshallersValue;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-\r\n-/**\r\n- * A {@link PluginValue} that interacts with the {@link CacheMarshaller}\r\n- * to cache the metadata repository between executions.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class MetaDataRepositoryValue\r\n-    extends PluginValue {\r\n-\r\n-    private static final String KEY = \"MetaDataRepository\";\r\n-\r\n-    public MetaDataRepositoryValue() {\r\n-        super(KEY, false);\r\n-        String[] aliases = new String[] {\r\n-            \"default\",\r\n-            MetaDataRepository.class.getName()\r\n-        };\r\n-        setAliases(aliases);\r\n-        setDefault(aliases[0]);\r\n-        setString(aliases[0]);\r\n-    }\r\n-\r\n-    public Object instantiate(Class type, Configuration c, boolean fatal) {\r\n-        MetaDataRepository repos = null;\r\n-        OpenJPAConfiguration conf = (OpenJPAConfiguration) c;\r\n-\r\n-        Object[] os = (Object[]) CacheMarshallersValue.getMarshallerById(\r\n-            conf, MetaDataCacheMaintenance.class.getName())\r\n-            .load();\r\n-        if (os != null) {\r\n-            repos = (MetaDataRepository) os[0];\r\n-            if (os[1] != null)\r\n-                // It's a bit odd that we do this in MetaDataRepositoryValue.\r\n-                // We need to serialize all the various bits of configuration\r\n-                // together; maybe we can move the caching logic somewhere\r\n-                // else?\r\n-                conf.getQueryCompilationCacheInstance().putAll((Map) os[1]);\r\n-        }\r\n-\r\n-        if (repos == null)\r\n-            return super.instantiate(type, c, fatal);\r\n-        else\r\n-            return repos;\r\n-    }\r\n-\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.conf.CacheMarshallersValue;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+\n+/**\n+ * A {@link PluginValue} that interacts with the {@link CacheMarshaller}\n+ * to cache the metadata repository between executions.\n+ *\n+ * @since 1.1.0\n+ */\n+public class MetaDataRepositoryValue\n+    extends PluginValue {\n+\n+    private static final String KEY = \"MetaDataRepository\";\n+\n+    public MetaDataRepositoryValue() {\n+        super(KEY, false);\n+        String[] aliases = new String[] {\n+            \"default\",\n+            MetaDataRepository.class.getName()\n+        };\n+        setAliases(aliases);\n+        setDefault(aliases[0]);\n+        setString(aliases[0]);\n+    }\n+\n+    public Object instantiate(Class type, Configuration c, boolean fatal) {\n+        MetaDataRepository repos = null;\n+        OpenJPAConfiguration conf = (OpenJPAConfiguration) c;\n+\n+        Object[] os = (Object[]) CacheMarshallersValue.getMarshallerById(\n+            conf, MetaDataCacheMaintenance.class.getName())\n+            .load();\n+        if (os != null) {\n+            repos = (MetaDataRepository) os[0];\n+            if (os[1] != null)\n+                // It's a bit odd that we do this in MetaDataRepositoryValue.\n+                // We need to serialize all the various bits of configuration\n+                // together; maybe we can move the caching logic somewhere\n+                // else?\n+                conf.getQueryCompilationCacheInstance().putAll((Map) os[1]);\n+        }\n+\n+        if (repos == null)\n+            return super.instantiate(type, c, fatal);\n+        else\n+            return repos;\n+    }\n+\n+\n+}"},{"sha":"3413add2a563d0da4016caef5419766c0a5bd10f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java","status":"modified","additions":48,"deletions":48,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,48 +1,48 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-/**\r\n- * Implementation of {@link CacheMarshaller} that does nothing.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class NoOpCacheMarshaller\r\n-    implements CacheMarshaller {\r\n-\r\n-    private String id;\r\n-\r\n-    public Object load() {\r\n-        return null;\r\n-    }\r\n-\r\n-    public void setId(String id) {\r\n-        this.id = id;\r\n-    }\r\n-\r\n-    public String getId() {\r\n-        return id;\r\n-    }\r\n-\r\n-    public void setValidationPolicy(String policy) {\r\n-    }\r\n-\r\n-    public void store(Object o) {\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+/**\n+ * Implementation of {@link CacheMarshaller} that does nothing.\n+ *\n+ * @since 1.1.0\n+ */\n+public class NoOpCacheMarshaller\n+    implements CacheMarshaller {\n+\n+    private String id;\n+\n+    public Object load() {\n+        return null;\n+    }\n+\n+    public void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public void setValidationPolicy(String policy) {\n+    }\n+\n+    public void store(Object o) {\n+    }\n+}"},{"sha":"a8e5bb124bc013c11c3e4a2172f39148dd737a23","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","status":"modified","additions":43,"deletions":43,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,43 +1,43 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.lib.conf.ProductDerivation;\r\n-import java.util.Map;\r\n-\r\n-/**\r\n- * Adds datastore based extension to ProductDerivation.  \r\n- *\r\n- * @since 0.4.1\r\n- * @author Pinaki Poddar\r\n- */\r\n-public interface OpenJPAProductDerivation extends ProductDerivation {\r\n-\r\n-    public static final int TYPE_SPEC = 0;\r\n-    public static final int TYPE_STORE = 200;\r\n-    public static final int TYPE_SPEC_STORE = 300;\r\n-    public static final int TYPE_PRODUCT_STORE = 400;\r\n-\r\n-    /**\r\n-     * Load default alias options into the given map.  Each entry maps an\r\n-     * alias to a broker factory class name.  Replace anything previously \r\n-     * under the desired keys.\r\n-     */\r\n-    public void putBrokerFactoryAliases(Map aliases);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.lib.conf.ProductDerivation;\n+import java.util.Map;\n+\n+/**\n+ * Adds datastore based extension to ProductDerivation.  \n+ *\n+ * @since 0.4.1\n+ * @author Pinaki Poddar\n+ */\n+public interface OpenJPAProductDerivation extends ProductDerivation {\n+\n+    public static final int TYPE_SPEC = 0;\n+    public static final int TYPE_STORE = 200;\n+    public static final int TYPE_SPEC_STORE = 300;\n+    public static final int TYPE_PRODUCT_STORE = 400;\n+\n+    /**\n+     * Load default alias options into the given map.  Each entry maps an\n+     * alias to a broker factory class name.  Replace anything previously \n+     * under the desired keys.\n+     */\n+    public void putBrokerFactoryAliases(Map aliases);\n+}"},{"sha":"df3cd84bdb3baa1fd3f379059a7954cd65cc11aa","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java","status":"modified","additions":66,"deletions":66,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,66 +1,66 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.conf.CacheMarshaller.ValidationPolicy;\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-\r\n-/**\r\n- * Compute validity based on whether or not the cached data is from the same\r\n- * version of Kodo as the current install. This also checks OpenJPA version\r\n- * information in case the OpenJPA jars were independently updated.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class OpenJPAVersionAndConfigurationTypeValidationPolicy\r\n-    implements ValidationPolicy, Configurable {\r\n-\r\n-    private String confClassName;\r\n-\r\n-    public Object getCacheableData(Object o) {\r\n-        return new Object[] {\r\n-            OpenJPAVersion.VERSION_ID,\r\n-            confClassName,\r\n-            o,\r\n-        };\r\n-    }\r\n-\r\n-    public Object getValidData(Object o) {\r\n-        Object[] array = (Object[]) o;\r\n-        if (array.length != 3)\r\n-            return null;\r\n-\r\n-        if (OpenJPAVersion.VERSION_ID.equals(array[0])\r\n-            && confClassName.equals(array[1]))\r\n-            return array[2];\r\n-        else\r\n-            return null;\r\n-    }\r\n-\r\n-    public void setConfiguration(Configuration conf) {\r\n-        confClassName = conf.getClass().getName();\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.conf.CacheMarshaller.ValidationPolicy;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+\n+/**\n+ * Compute validity based on whether or not the cached data is from the same\n+ * version of Kodo as the current install. This also checks OpenJPA version\n+ * information in case the OpenJPA jars were independently updated.\n+ *\n+ * @since 1.1.0\n+ */\n+public class OpenJPAVersionAndConfigurationTypeValidationPolicy\n+    implements ValidationPolicy, Configurable {\n+\n+    private String confClassName;\n+\n+    public Object getCacheableData(Object o) {\n+        return new Object[] {\n+            OpenJPAVersion.VERSION_ID,\n+            confClassName,\n+            o,\n+        };\n+    }\n+\n+    public Object getValidData(Object o) {\n+        Object[] array = (Object[]) o;\n+        if (array.length != 3)\n+            return null;\n+\n+        if (OpenJPAVersion.VERSION_ID.equals(array[0])\n+            && confClassName.equals(array[1]))\n+            return array[2];\n+        else\n+            return null;\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+        confClassName = conf.getClass().getName();\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+    }\n+}"},{"sha":"c7546b4abe705c72f28028ba71ef505054f02860","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","status":"modified","additions":95,"deletions":95,"changes":190,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,95 +1,95 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.Collections;\r\n-import java.util.Hashtable;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.PluginValue;\r\n-import java.util.concurrent.ConcurrentHashMap;\r\n-import org.apache.openjpa.lib.util.ParseException;\r\n-import org.apache.openjpa.util.CacheMap;\r\n-\r\n-/**\r\n- * A cache of compiled queries.\r\n- *\r\n- * @author Abe White\r\n- * @since 0.9.6 (also existed in prior versions of Kodo)\r\n- * @nojavadoc\r\n- */\r\n-public class QueryCompilationCacheValue\r\n-    extends PluginValue {\r\n-\r\n-    public static final String[] ALIASES = {\r\n-        \"true\", CacheMap.class.getName(),\r\n-        \"all\", ConcurrentHashMap.class.getName(),\r\n-        \"false\", null,\r\n-    };\r\n-\r\n-    public QueryCompilationCacheValue(String prop) {\r\n-        super(prop, true);\r\n-        setAliases(ALIASES);\r\n-        setDefault(ALIASES[0]);\r\n-        setClassName(ALIASES[1]);\r\n-    }\r\n-\r\n-    public Object newInstance(String clsName, Class type,\r\n-        Configuration conf, boolean fatal) {\r\n-        // make sure map handles concurrency\r\n-        Map map;\r\n-        \r\n-        try {\r\n-            map = (Map) super.newInstance(clsName, type, conf, fatal);\r\n-        } catch (ParseException pe) {\r\n-            // OPENJPA256: this class differs from most plugins in that\r\n-            // the plugin type is the standard java interface Map.class (rather\r\n-            // than an openjpa-specific interface), which means that the\r\n-            // ClassLoader used to load the implementation will be the system\r\n-            // class loader; this presents a problem if OpenJPA is not in the\r\n-            // system classpath, so work around the problem by catching\r\n-            // the ParseException (which is what we wrap the\r\n-            // ClassNotFoundException in) and try again, this time using\r\n-            // this class' ClassLoader.\r\n-            map = (Map) super.newInstance(clsName,\r\n-                QueryCompilationCacheValue.class, conf, fatal);\r\n-        } catch (IllegalArgumentException iae) {\r\n-            // OPENJPA256: this class differs from most plugins in that\r\n-            // the plugin type is the standard java interface Map.class (rather\r\n-            // than an openjpa-specific interface), which means that the\r\n-            // ClassLoader used to load the implementation will be the system\r\n-            // class loader; this presents a problem if OpenJPA is not in the\r\n-            // system classpath, so work around the problem by catching\r\n-            // the IllegalArgumentException (which is what we wrap the\r\n-            // ClassNotFoundException in) and try again, this time using\r\n-            // this class' ClassLoader.\r\n-            map = (Map) super.newInstance(clsName,\r\n-                QueryCompilationCacheValue.class, conf, fatal);\r\n-        }\r\n-\r\n-        if (map != null && !(map instanceof Hashtable)\r\n-            && !(map instanceof CacheMap)\r\n-            && !(map instanceof\r\n-                    org.apache.openjpa.lib.util.concurrent.ConcurrentMap)\r\n-            && !(map instanceof java.util.concurrent.ConcurrentMap))\r\n-            map = Collections.synchronizedMap(map);\r\n-        return map;\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.Collections;\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.openjpa.lib.util.ParseException;\n+import org.apache.openjpa.util.CacheMap;\n+\n+/**\n+ * A cache of compiled queries.\n+ *\n+ * @author Abe White\n+ * @since 0.9.6 (also existed in prior versions of Kodo)\n+ * @nojavadoc\n+ */\n+public class QueryCompilationCacheValue\n+    extends PluginValue {\n+\n+    public static final String[] ALIASES = {\n+        \"true\", CacheMap.class.getName(),\n+        \"all\", ConcurrentHashMap.class.getName(),\n+        \"false\", null,\n+    };\n+\n+    public QueryCompilationCacheValue(String prop) {\n+        super(prop, true);\n+        setAliases(ALIASES);\n+        setDefault(ALIASES[0]);\n+        setClassName(ALIASES[1]);\n+    }\n+\n+    public Object newInstance(String clsName, Class type,\n+        Configuration conf, boolean fatal) {\n+        // make sure map handles concurrency\n+        Map map;\n+        \n+        try {\n+            map = (Map) super.newInstance(clsName, type, conf, fatal);\n+        } catch (ParseException pe) {\n+            // OPENJPA256: this class differs from most plugins in that\n+            // the plugin type is the standard java interface Map.class (rather\n+            // than an openjpa-specific interface), which means that the\n+            // ClassLoader used to load the implementation will be the system\n+            // class loader; this presents a problem if OpenJPA is not in the\n+            // system classpath, so work around the problem by catching\n+            // the ParseException (which is what we wrap the\n+            // ClassNotFoundException in) and try again, this time using\n+            // this class' ClassLoader.\n+            map = (Map) super.newInstance(clsName,\n+                QueryCompilationCacheValue.class, conf, fatal);\n+        } catch (IllegalArgumentException iae) {\n+            // OPENJPA256: this class differs from most plugins in that\n+            // the plugin type is the standard java interface Map.class (rather\n+            // than an openjpa-specific interface), which means that the\n+            // ClassLoader used to load the implementation will be the system\n+            // class loader; this presents a problem if OpenJPA is not in the\n+            // system classpath, so work around the problem by catching\n+            // the IllegalArgumentException (which is what we wrap the\n+            // ClassNotFoundException in) and try again, this time using\n+            // this class' ClassLoader.\n+            map = (Map) super.newInstance(clsName,\n+                QueryCompilationCacheValue.class, conf, fatal);\n+        }\n+\n+        if (map != null && !(map instanceof Hashtable)\n+            && !(map instanceof CacheMap)\n+            && !(map instanceof\n+                    org.apache.openjpa.lib.util.concurrent.ConcurrentMap)\n+            && !(map instanceof java.util.concurrent.ConcurrentMap))\n+            map = Collections.synchronizedMap(map);\n+        return map;\n+\t}\n+}"},{"sha":"6f748a9f3ed636e353e222cb930ee44eb46d6b63","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/Specification.java","status":"modified","additions":147,"deletions":147,"changes":294,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Specification.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Specification.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Specification.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,147 +1,147 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.text.MessageFormat;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * An immutable representation of a Specification supported by OpenJPA.\r\n- * \r\n- * Available via {@linkplain OpenJPAConfiguration#getSpecificationInstance()()} \r\n- * for configuration that may depend on Specification version.\r\n- * \r\n- * @author Pinaki Poddar\r\n- *\r\n- */\r\n-public class Specification {\r\n-    private String _name = \"\";\r\n-    private int    _major = 1;\r\n-    private String _minor = \"0\";\r\n-    private String _description = \"\";\r\n-\r\n-    private static Localizer _loc = Localizer.forPackage(Specification.class);\r\n-    \r\n-    /**\r\n-     * Construct from a String that encodes name and version fields.\r\n-     * \r\n-     * @param fullName a encoded string in the following prescribed format.\r\n-     * <code>name major.minor</code> e.g. <code>JPA 2.0-draft</code>\r\n-     * Only the 'name' field is mandatory. \r\n-     * 'major' version defaults to 1 and must be an integer. \r\n-     * 'minor' version defaults to 0 and can be a String. \r\n-     */\r\n-    public Specification(String fullName) {\r\n-        try {\r\n-            Object[] tokens = parse(fullName);\r\n-            _name = tokens[0].toString();\r\n-            _major = tokens.length > 1 ? \r\n-                Integer.parseInt(tokens[1].toString()) : 1;\r\n-            _minor = tokens.length > 2 ? tokens[2].toString() : \"0\";\r\n-        } catch (Exception e) {\r\n-            throw new UserException(_loc.get(\"spec-wrong-format\", fullName));\r\n-        }\r\n-    }\r\n-    \r\n-    public String getName() {\r\n-        return _name;\r\n-    }\r\n-    \r\n-    public int getVersion() {\r\n-        return _major;\r\n-    }\r\n-    \r\n-    public String getMinorVersion() {\r\n-        return _minor;\r\n-    }\r\n-    \r\n-    public String getDescription() {\r\n-        return _description;\r\n-    }\r\n-    \r\n-    public Specification setDescription(String description) {\r\n-        this._description = description;\r\n-        return this;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Affirms if the given argument is equal to this receiver.\r\n-     */\r\n-    public boolean equals(Object other) {\r\n-        if (this == other)\r\n-            return true;\r\n-        if (other == null || !this.getClass().isInstance(other))\r\n-            return false;\r\n-        Specification that = (Specification)other;\r\n-        return StringUtils.equals(_name, this._name) && _major == that._major \r\n-            && StringUtils.equals(_minor, this._minor);\r\n-    }    \r\n-    \r\n-    /**\r\n-     * Affirms if the given specification has the same name of this receiver,\r\n-     * ignoring the case.\r\n-     */\r\n-    public boolean isSame(Specification other) {\r\n-        return this == other \r\n-            || (other != null && _name.equalsIgnoreCase(other._name));\r\n-    }\r\n-    \r\n-    /**\r\n-     * Affirms if the given string equals name of this receiver, ignoring the \r\n-     * case.\r\n-     */\r\n-    public boolean isSame(String other) {\r\n-        return _name.equalsIgnoreCase(other);\r\n-    }\r\n-    \r\n-    /**\r\n-     * Compares major version number of the given Specification with this \r\n-     * receiver.\r\n-\r\n-     * @return 0 if they are equal.\r\n-     *       > 0 if this receiver is higher version.\r\n-     *       < 0 if this receiver is lower version.\r\n-     */\r\n-    public int compareVersion(Specification other) {\r\n-        return _major > other._major ? 1 : _major == other._major ? 0 : -1;\r\n-    }\r\n-    \r\n-    public String toString() {\r\n-        return _name.toUpperCase() + \" \" + _major + \".\" + _minor;\r\n-    }\r\n-    \r\n-    private Object[] parse(String str) {\r\n-        int space = str.indexOf(' ');\r\n-        \r\n-        if (space == -1)\r\n-            return new Object[]{str};\r\n-        String name = str.substring(0,space);\r\n-        String version = str.substring(space+1);\r\n-        int dot = version.indexOf('.');\r\n-        if (dot == -1)\r\n-            return new Object[] {name, version};\r\n-        return new Object[] {name, \r\n-            version.substring(0,dot), version.substring(dot+1)};\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.text.MessageFormat;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * An immutable representation of a Specification supported by OpenJPA.\n+ * \n+ * Available via {@linkplain OpenJPAConfiguration#getSpecificationInstance()()} \n+ * for configuration that may depend on Specification version.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public class Specification {\n+    private String _name = \"\";\n+    private int    _major = 1;\n+    private String _minor = \"0\";\n+    private String _description = \"\";\n+\n+    private static Localizer _loc = Localizer.forPackage(Specification.class);\n+    \n+    /**\n+     * Construct from a String that encodes name and version fields.\n+     * \n+     * @param fullName a encoded string in the following prescribed format.\n+     * <code>name major.minor</code> e.g. <code>JPA 2.0-draft</code>\n+     * Only the 'name' field is mandatory. \n+     * 'major' version defaults to 1 and must be an integer. \n+     * 'minor' version defaults to 0 and can be a String. \n+     */\n+    public Specification(String fullName) {\n+        try {\n+            Object[] tokens = parse(fullName);\n+            _name = tokens[0].toString();\n+            _major = tokens.length > 1 ? \n+                Integer.parseInt(tokens[1].toString()) : 1;\n+            _minor = tokens.length > 2 ? tokens[2].toString() : \"0\";\n+        } catch (Exception e) {\n+            throw new UserException(_loc.get(\"spec-wrong-format\", fullName));\n+        }\n+    }\n+    \n+    public String getName() {\n+        return _name;\n+    }\n+    \n+    public int getVersion() {\n+        return _major;\n+    }\n+    \n+    public String getMinorVersion() {\n+        return _minor;\n+    }\n+    \n+    public String getDescription() {\n+        return _description;\n+    }\n+    \n+    public Specification setDescription(String description) {\n+        this._description = description;\n+        return this;\n+    }\n+    \n+    /**\n+     * Affirms if the given argument is equal to this receiver.\n+     */\n+    public boolean equals(Object other) {\n+        if (this == other)\n+            return true;\n+        if (other == null || !this.getClass().isInstance(other))\n+            return false;\n+        Specification that = (Specification)other;\n+        return StringUtils.equals(_name, this._name) && _major == that._major \n+            && StringUtils.equals(_minor, this._minor);\n+    }    \n+    \n+    /**\n+     * Affirms if the given specification has the same name of this receiver,\n+     * ignoring the case.\n+     */\n+    public boolean isSame(Specification other) {\n+        return this == other \n+            || (other != null && _name.equalsIgnoreCase(other._name));\n+    }\n+    \n+    /**\n+     * Affirms if the given string equals name of this receiver, ignoring the \n+     * case.\n+     */\n+    public boolean isSame(String other) {\n+        return _name.equalsIgnoreCase(other);\n+    }\n+    \n+    /**\n+     * Compares major version number of the given Specification with this \n+     * receiver.\n+\n+     * @return 0 if they are equal.\n+     *       > 0 if this receiver is higher version.\n+     *       < 0 if this receiver is lower version.\n+     */\n+    public int compareVersion(Specification other) {\n+        return _major > other._major ? 1 : _major == other._major ? 0 : -1;\n+    }\n+    \n+    public String toString() {\n+        return _name.toUpperCase() + \" \" + _major + \".\" + _minor;\n+    }\n+    \n+    private Object[] parse(String str) {\n+        int space = str.indexOf(' ');\n+        \n+        if (space == -1)\n+            return new Object[]{str};\n+        String name = str.substring(0,space);\n+        String version = str.substring(space+1);\n+        int dot = version.indexOf('.');\n+        if (dot == -1)\n+            return new Object[] {name, version};\n+        return new Object[] {name, \n+            version.substring(0,dot), version.substring(dot+1)};\n+    }\n+}"},{"sha":"f3a071d63565a831bd0a7472b0da2acb801267b7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/SpecificationPlugin.java","status":"modified","additions":117,"deletions":117,"changes":234,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/SpecificationPlugin.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/conf/SpecificationPlugin.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/SpecificationPlugin.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,117 +1,117 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.ObjectValue;\r\n-import org.apache.openjpa.lib.conf.ProductDerivations;\r\n-import org.apache.openjpa.lib.conf.Value;\r\n-import org.apache.openjpa.lib.conf.ValueListener;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * A plug-in for Specification that enforces certain overwriting rules.\r\n- * \r\n- * @author Pinaki Poddar\r\n- *\r\n- */\r\n-public class SpecificationPlugin extends ObjectValue implements ValueListener {\r\n-    private Configuration _conf;\r\n-    protected static final Localizer _loc = Localizer.forPackage\r\n-        (SpecificationPlugin.class);\r\n-    \r\n-    public SpecificationPlugin(Configuration conf, String prop) {\r\n-        super(prop);\r\n-        _conf = conf;\r\n-        addListener(this);\r\n-    }\r\n-    \r\n-    @Override\r\n-    public Class<?> getValueType() {\r\n-        return Specification.class;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Set a value from the given String after validating.\r\n-     * \r\n-     * @param str can be null to set the Specification to null.\r\n-     * If non-null, then the String must be in Specification format\r\n-     * @see Specification#create(String)  \r\n-     */\r\n-    @Override\r\n-    public void setString(String str) {\r\n-        this.set(str == null ? null : new Specification(str));\r\n-    }\r\n-    \r\n-    /**\r\n-     * Set a value from the given object after validating.\r\n-     * \r\n-     * @param obj can be null to set the Specification to null.\r\n-     */\r\n-    @Override\r\n-    public void set(Object obj) {\r\n-        if (obj == null) {\r\n-            super.set(null);\r\n-            return;\r\n-        }\r\n-        if (obj instanceof Specification == false) {\r\n-            throw new UserException(_loc.get(\"spec-wrong-obj\", obj, \r\n-                obj.getClass())).setFatal(true);\r\n-        }\r\n-        validateOverwrite((Specification)obj);\r\n-        super.set(obj);\r\n-    }\r\n-    \r\n-    /**\r\n-     * Validates if the given Specification can overwrite the current \r\n-     * Specification. If the given Specification is not same as the\r\n-     * current one, then it is valid to overwrite.\r\n-     * If the given Specification is same as the current Specification then\r\n-     * it must have a major version number equal or less than the current one.\r\n-     * \r\n-     * @exception fatal UserException if the given Specification is same as\r\n-     * the current Specification but has a higher major version.\r\n-     * \r\n-     * @see Specification#equals(Object)\r\n-     */\r\n-    protected void validateOverwrite(Specification newSpec) {\r\n-        Specification current = (Specification)get();\r\n-        if (current != null) {\r\n-            Log log = _conf.getConfigurationLog(); \r\n-            if (!current.isSame(newSpec)) {\r\n-                log.warn(_loc.get(\"spec-different\", newSpec, current));\r\n-                return;\r\n-            }\r\n-            if (current.compareVersion(newSpec) < 0) {\r\n-                throw new UserException(_loc.get(\"spec-version-higher\", \r\n-                    newSpec, current)).setFatal(true);\r\n-            }\r\n-            if (current.compareVersion(newSpec) > 0) {\r\n-                log.warn(_loc.get(\"spec-version-lower\", newSpec, current));\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    public void valueChanged(Value value) {\r\n-        if (this.getClass().isInstance(value))\r\n-            ProductDerivations.afterSpecificationSet(_conf);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.ObjectValue;\n+import org.apache.openjpa.lib.conf.ProductDerivations;\n+import org.apache.openjpa.lib.conf.Value;\n+import org.apache.openjpa.lib.conf.ValueListener;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * A plug-in for Specification that enforces certain overwriting rules.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public class SpecificationPlugin extends ObjectValue implements ValueListener {\n+    private Configuration _conf;\n+    protected static final Localizer _loc = Localizer.forPackage\n+        (SpecificationPlugin.class);\n+    \n+    public SpecificationPlugin(Configuration conf, String prop) {\n+        super(prop);\n+        _conf = conf;\n+        addListener(this);\n+    }\n+    \n+    @Override\n+    public Class<?> getValueType() {\n+        return Specification.class;\n+    }\n+    \n+    /**\n+     * Set a value from the given String after validating.\n+     * \n+     * @param str can be null to set the Specification to null.\n+     * If non-null, then the String must be in Specification format\n+     * @see Specification#create(String)  \n+     */\n+    @Override\n+    public void setString(String str) {\n+        this.set(str == null ? null : new Specification(str));\n+    }\n+    \n+    /**\n+     * Set a value from the given object after validating.\n+     * \n+     * @param obj can be null to set the Specification to null.\n+     */\n+    @Override\n+    public void set(Object obj) {\n+        if (obj == null) {\n+            super.set(null);\n+            return;\n+        }\n+        if (obj instanceof Specification == false) {\n+            throw new UserException(_loc.get(\"spec-wrong-obj\", obj, \n+                obj.getClass())).setFatal(true);\n+        }\n+        validateOverwrite((Specification)obj);\n+        super.set(obj);\n+    }\n+    \n+    /**\n+     * Validates if the given Specification can overwrite the current \n+     * Specification. If the given Specification is not same as the\n+     * current one, then it is valid to overwrite.\n+     * If the given Specification is same as the current Specification then\n+     * it must have a major version number equal or less than the current one.\n+     * \n+     * @exception fatal UserException if the given Specification is same as\n+     * the current Specification but has a higher major version.\n+     * \n+     * @see Specification#equals(Object)\n+     */\n+    protected void validateOverwrite(Specification newSpec) {\n+        Specification current = (Specification)get();\n+        if (current != null) {\n+            Log log = _conf.getConfigurationLog(); \n+            if (!current.isSame(newSpec)) {\n+                log.warn(_loc.get(\"spec-different\", newSpec, current));\n+                return;\n+            }\n+            if (current.compareVersion(newSpec) < 0) {\n+                throw new UserException(_loc.get(\"spec-version-higher\", \n+                    newSpec, current)).setFatal(true);\n+            }\n+            if (current.compareVersion(newSpec) > 0) {\n+                log.warn(_loc.get(\"spec-version-lower\", newSpec, current));\n+            }\n+        }\n+    }\n+    \n+    public void valueChanged(Value value) {\n+        if (this.getClass().isInstance(value))\n+            ProductDerivations.afterSpecificationSet(_conf);\n+    }\n+}"},{"sha":"aa6059b65c9618c9605147a0eae002cad5b7e49e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","status":"modified","additions":464,"deletions":464,"changes":928,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,464 +1,464 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.BitSet;\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.event.RemoteCommitEvent;\r\n-import org.apache.openjpa.event.RemoteCommitListener;\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n-\r\n-/**\r\n- * Abstract {@link DataCache} implementation that provides various\r\n- * statistics, logging, and timeout functionality common across cache\r\n- * implementations.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @author Abe White\r\n- */\r\n-public abstract class AbstractDataCache\r\n-    extends AbstractConcurrentEventManager\r\n-    implements DataCache, Configurable {\r\n-\t\r\n-    protected CacheStatistics.Default stats = new CacheStatistics.Default();\r\n-\r\n-    private static final BitSet EMPTY_BITSET = new BitSet(0);\r\n-\r\n-    private static final Localizer s_loc =\r\n-        Localizer.forPackage(AbstractDataCache.class);\r\n-    \r\n-\r\n-    /**\r\n-     * The configuration set by the system.\r\n-     */\r\n-    protected OpenJPAConfiguration conf;\r\n-\r\n-    /**\r\n-     * The log to use.\r\n-     */\r\n-    protected Log log;\r\n-\r\n-    private String _name = null;\r\n-    private boolean _closed = false;\r\n-    private String _schedule = null;\r\n-\r\n-    public String getName() {\r\n-        return _name;\r\n-    }\r\n-\r\n-    public void setName(String name) {\r\n-        _name = name;\r\n-    }\r\n-\r\n-    public String getEvictionSchedule() {\r\n-        return _schedule;\r\n-    }\r\n-\r\n-    public void setEvictionSchedule(String s) {\r\n-        _schedule = s;\r\n-    }\r\n-\r\n-    public void initialize(DataCacheManager manager) {\r\n-        if (_schedule != null && !\"\".equals(_schedule)) {\r\n-            DataCacheScheduler scheduler = manager.getDataCacheScheduler();\r\n-            if (scheduler != null)\r\n-                scheduler.scheduleEviction(this, _schedule);\r\n-        }\r\n-    }\r\n-\r\n-    public void commit(Collection additions, Collection newUpdates,\r\n-        Collection existingUpdates, Collection deletes) {\r\n-        // remove all objects in deletes list\r\n-        removeAllInternal(deletes);\r\n-\r\n-        // next, add all the new additions\r\n-        putAllInternal(additions);\r\n-        putAllInternal(newUpdates);\r\n-\r\n-        // possibly add the existing updates, depending on the\r\n-        // semantics of the cache, as dictated by recacheUpdates()\r\n-        if (recacheUpdates())\r\n-            putAllInternal(existingUpdates);\r\n-\r\n-        if (log.isTraceEnabled()) {\r\n-            Collection addIds = new ArrayList(additions.size());\r\n-            Collection upIds = new ArrayList(newUpdates.size());\r\n-            Collection exIds = new ArrayList(existingUpdates.size());\r\n-\r\n-            for (Iterator iter = additions.iterator(); iter.hasNext();)\r\n-                addIds.add(((DataCachePCData) iter.next()).getId());\r\n-            for (Iterator iter = newUpdates.iterator(); iter.hasNext();)\r\n-                upIds.add(((DataCachePCData) iter.next()).getId());\r\n-            for (Iterator iter = existingUpdates.iterator(); iter.hasNext();)\r\n-                exIds.add(((DataCachePCData) iter.next()).getId());\r\n-\r\n-            log.trace(s_loc.get(\"cache-commit\",\r\n-                new Object[]{ addIds, upIds, exIds, deletes }));\r\n-        }\r\n-    }\r\n-\r\n-    public boolean contains(Object key) {\r\n-        DataCachePCData o = getInternal(key);\r\n-        if (o != null && o.isTimedOut()) {\r\n-            o = null;\r\n-            removeInternal(key);\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-timeout\", key));\r\n-        }\r\n-        return o != null;\r\n-    }\r\n-\r\n-    public BitSet containsAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (contains(iter.next()))\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    public DataCachePCData get(Object key) {\r\n-        DataCachePCData o = getInternal(key);\r\n-        if (o != null && o.isTimedOut()) {\r\n-            o = null;\r\n-            removeInternal(key);\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-timeout\", key));\r\n-        }\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-miss\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-hit\", key));\r\n-        }\r\n-        stats.newGet((o == null) ? null : o.getType(), o != null);\r\n-        return o;\r\n-    }\r\n-\r\n-\r\n-    /**\r\n-     * Returns the objects for the given key List.\r\n-     */\r\n-    public Map getAll(List keys) {\r\n-        Map resultMap = new HashMap(keys.size());\r\n-        for(Object key : keys)\r\n-            resultMap.put(key, get(key));\r\n-        return resultMap;\r\n-    }\r\n-\r\n-    public DataCachePCData put(DataCachePCData data) {\r\n-        DataCachePCData o = putInternal(data.getId(), data);\r\n-    \tstats.newPut((o == null) ? null : o.getType());\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-put\", data.getId()));\r\n-        return (o == null || o.isTimedOut()) ? null : o;\r\n-    }\r\n-\r\n-    public void update(DataCachePCData data) {\r\n-        if (recacheUpdates())\r\n-            putInternal(data.getId(), data);\r\n-    }\r\n-\r\n-    public DataCachePCData remove(Object key) {\r\n-        DataCachePCData o = removeInternal(key);\r\n-        if (o != null && o.isTimedOut())\r\n-            o = null;\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-remove-miss\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-remove-hit\", key));\r\n-        }\r\n-        return o;\r\n-    }\r\n-\r\n-    public BitSet removeAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (remove(iter.next()) != null)\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove the objects of the given class from the cache.\r\n-     */\r\n-    public void removeAll(Class cls, boolean subClasses) {\r\n-        removeAllInternal(cls, subClasses);\r\n-    }\r\n-\r\n-    public boolean pin(Object key) {\r\n-        boolean bool = pinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-pin-hit\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-pin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public BitSet pinAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (pin(iter.next()))\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    public void pinAll(Class<?> cls, boolean subs) {\r\n-        if (log.isWarnEnabled())\r\n-            log.warn(s_loc.get(\"cache-class-pin\", getName()));\r\n-    }\r\n-\r\n-    public boolean unpin(Object key) {\r\n-        boolean bool = unpinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-unpin-hit\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-unpin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public BitSet unpinAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (unpin(iter.next()))\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    public void unpinAll(Class<?> cls, boolean subs) {\r\n-        if (log.isWarnEnabled())\r\n-            log.warn(s_loc.get(\"cache-class-unpin\", getName()));\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        clearInternal();\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-clear\", getName()));\r\n-    }\r\n-\r\n-    public void close() {\r\n-        close(true);\r\n-    }\r\n-\r\n-    protected void close(boolean clear) {\r\n-        if (!_closed) {\r\n-            if (clear)\r\n-                clearInternal();\r\n-            _closed = true;\r\n-        }\r\n-    }\r\n-\r\n-    public boolean isClosed() {\r\n-        return _closed;\r\n-    }\r\n-\r\n-    public void addExpirationListener(ExpirationListener listen) {\r\n-        addListener(listen);\r\n-    }\r\n-\r\n-    public boolean removeExpirationListener(ExpirationListener listen) {\r\n-        return removeListener(listen);\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return \"[\" + super.toString() + \":\" + _name + \"]\";\r\n-    }\r\n-\r\n-    /**\r\n-     * This method is part of the {@link RemoteCommitListener} interface. If\r\n-     * your cache subclass relies on OpenJPA for clustering support, make it\r\n-     * implement <code>RemoteCommitListener</code>. This method will take\r\n-     * care of invalidating entries from remote commits.\r\n-     */\r\n-    public void afterCommit(RemoteCommitEvent event) {\r\n-        if (_closed)\r\n-            return;\r\n-\r\n-        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\r\n-            removeAllTypeNamesInternal(event.getUpdatedTypeNames());\r\n-            removeAllTypeNamesInternal(event.getDeletedTypeNames());\r\n-        } else {\r\n-            // drop all the committed OIDs, excepting brand\r\n-            // new OIDs. brand new OIDs either won't be in\r\n-            // the cache, or if they are, will be more up to date\r\n-            removeAllInternal(event.getUpdatedObjectIds());\r\n-            removeAllInternal(event.getDeletedObjectIds());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Invoke when a key is removed from this cache. Propagates the\r\n-     * expiration event on to all expiration listeners registered\r\n-     * with this class.\r\n-     */\r\n-    protected void keyRemoved(Object key, boolean expired) {\r\n-        // Notify any expiration listeners of the expiration.\r\n-        if (hasListeners())\r\n-            fireEvent(new ExpirationEvent(this, key, expired));\r\n-\r\n-        if (expired && log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-expired\", key));\r\n-    }\r\n-\r\n-    /**\r\n-     * Return <code>true</code> if updates to data already in the\r\n-     * cache (either in {@link #commit} or the {@link #update})\r\n-     * should be put back into the cache. Returns false by default.\r\n-     */\r\n-    protected boolean recacheUpdates() {\r\n-        return false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the object for the given oid.\r\n-     */\r\n-    protected abstract DataCachePCData getInternal(Object oid);\r\n-\r\n-    /**\r\n-     * Add the given object to the cache, returning the old object under the\r\n-     * given oid.\r\n-     */\r\n-    protected abstract DataCachePCData putInternal(Object oid,\r\n-            DataCachePCData pc);\r\n-    \r\n-    /**\r\n-     * Add all of the given objects to the cache.\r\n-     */\r\n-    protected void putAllInternal(Collection pcs) {\r\n-        DataCachePCData pc;\r\n-        for (Iterator iter = pcs.iterator(); iter.hasNext();) {\r\n-            pc = (DataCachePCData) iter.next();\r\n-            stats.newPut(pc.getType());\r\n-            putInternal(pc.getId(), pc);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove the object under the given oid from the cache.\r\n-     */\r\n-    protected abstract DataCachePCData removeInternal(Object oid);\r\n-\r\n-    /**\r\n-     * Evict objects in cache by class.\r\n-     */\r\n-    protected abstract void removeAllInternal(Class<?> cls, boolean subclasses);\r\n-\r\n-    /**\r\n-     * Remove all objects under the given oids from the cache.\r\n-     */\r\n-    protected void removeAllInternal(Collection oids) {\r\n-        for (Iterator iter = oids.iterator(); iter.hasNext();)\r\n-            removeInternal(iter.next());\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove all objects of the given class names from the cache.\r\n-     */\r\n-    protected void removeAllTypeNamesInternal(Collection classNames) {\r\n-        Collection classes = Caches.addTypesByName(conf, classNames, null);\r\n-        if (classes == null)\r\n-            return;\r\n-\r\n-        Class cls;\r\n-        for (Iterator iter = classes.iterator(); iter.hasNext();) {\r\n-            cls = (Class) iter.next();\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-removeclass\", cls.getName()));\r\n-            removeAllInternal(cls, false);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Clear the cache.\r\n-     */\r\n-    protected abstract void clearInternal();\r\n-\r\n-    /**\r\n-     * Pin an object to the cache.\r\n-     */\r\n-    protected abstract boolean pinInternal(Object oid);\r\n-\r\n-    /**\r\n-     * Unpin an object from the cache.\r\n-     */\r\n-    protected abstract boolean unpinInternal(Object oid);\r\n-    \r\n-    public CacheStatistics getStatistics() {\r\n-    \treturn stats;\r\n-    }\r\n-\r\n-    // ---------- Configurable implementation ----------\r\n-\r\n-    public void setConfiguration(Configuration conf) {\r\n-        this.conf = (OpenJPAConfiguration) conf;\r\n-        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-        if (_name == null)\r\n-            setName(NAME_DEFAULT);\r\n-    }\r\n-\r\n-    // ---------- AbstractEventManager implementation ----------\r\n-\r\n-    protected void fireEvent(Object event, Object listener) {\r\n-        ExpirationListener listen = (ExpirationListener) listener;\r\n-        ExpirationEvent ev = (ExpirationEvent) event;\r\n-        try {\r\n-            listen.onExpire(ev);\r\n-        } catch (Exception e) {\r\n-            if (log.isWarnEnabled())\r\n-                log.warn(s_loc.get(\"exp-listener-ex\"), e);\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.event.RemoteCommitEvent;\n+import org.apache.openjpa.event.RemoteCommitListener;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\n+\n+/**\n+ * Abstract {@link DataCache} implementation that provides various\n+ * statistics, logging, and timeout functionality common across cache\n+ * implementations.\n+ *\n+ * @author Patrick Linskey\n+ * @author Abe White\n+ */\n+public abstract class AbstractDataCache\n+    extends AbstractConcurrentEventManager\n+    implements DataCache, Configurable {\n+\t\n+    protected CacheStatistics.Default stats = new CacheStatistics.Default();\n+\n+    private static final BitSet EMPTY_BITSET = new BitSet(0);\n+\n+    private static final Localizer s_loc =\n+        Localizer.forPackage(AbstractDataCache.class);\n+    \n+\n+    /**\n+     * The configuration set by the system.\n+     */\n+    protected OpenJPAConfiguration conf;\n+\n+    /**\n+     * The log to use.\n+     */\n+    protected Log log;\n+\n+    private String _name = null;\n+    private boolean _closed = false;\n+    private String _schedule = null;\n+\n+    public String getName() {\n+        return _name;\n+    }\n+\n+    public void setName(String name) {\n+        _name = name;\n+    }\n+\n+    public String getEvictionSchedule() {\n+        return _schedule;\n+    }\n+\n+    public void setEvictionSchedule(String s) {\n+        _schedule = s;\n+    }\n+\n+    public void initialize(DataCacheManager manager) {\n+        if (_schedule != null && !\"\".equals(_schedule)) {\n+            DataCacheScheduler scheduler = manager.getDataCacheScheduler();\n+            if (scheduler != null)\n+                scheduler.scheduleEviction(this, _schedule);\n+        }\n+    }\n+\n+    public void commit(Collection additions, Collection newUpdates,\n+        Collection existingUpdates, Collection deletes) {\n+        // remove all objects in deletes list\n+        removeAllInternal(deletes);\n+\n+        // next, add all the new additions\n+        putAllInternal(additions);\n+        putAllInternal(newUpdates);\n+\n+        // possibly add the existing updates, depending on the\n+        // semantics of the cache, as dictated by recacheUpdates()\n+        if (recacheUpdates())\n+            putAllInternal(existingUpdates);\n+\n+        if (log.isTraceEnabled()) {\n+            Collection addIds = new ArrayList(additions.size());\n+            Collection upIds = new ArrayList(newUpdates.size());\n+            Collection exIds = new ArrayList(existingUpdates.size());\n+\n+            for (Iterator iter = additions.iterator(); iter.hasNext();)\n+                addIds.add(((DataCachePCData) iter.next()).getId());\n+            for (Iterator iter = newUpdates.iterator(); iter.hasNext();)\n+                upIds.add(((DataCachePCData) iter.next()).getId());\n+            for (Iterator iter = existingUpdates.iterator(); iter.hasNext();)\n+                exIds.add(((DataCachePCData) iter.next()).getId());\n+\n+            log.trace(s_loc.get(\"cache-commit\",\n+                new Object[]{ addIds, upIds, exIds, deletes }));\n+        }\n+    }\n+\n+    public boolean contains(Object key) {\n+        DataCachePCData o = getInternal(key);\n+        if (o != null && o.isTimedOut()) {\n+            o = null;\n+            removeInternal(key);\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-timeout\", key));\n+        }\n+        return o != null;\n+    }\n+\n+    public BitSet containsAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (contains(iter.next()))\n+                set.set(i);\n+        return set;\n+    }\n+\n+    public DataCachePCData get(Object key) {\n+        DataCachePCData o = getInternal(key);\n+        if (o != null && o.isTimedOut()) {\n+            o = null;\n+            removeInternal(key);\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-timeout\", key));\n+        }\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-hit\", key));\n+        }\n+        stats.newGet((o == null) ? null : o.getType(), o != null);\n+        return o;\n+    }\n+\n+\n+    /**\n+     * Returns the objects for the given key List.\n+     */\n+    public Map getAll(List keys) {\n+        Map resultMap = new HashMap(keys.size());\n+        for(Object key : keys)\n+            resultMap.put(key, get(key));\n+        return resultMap;\n+    }\n+\n+    public DataCachePCData put(DataCachePCData data) {\n+        DataCachePCData o = putInternal(data.getId(), data);\n+    \tstats.newPut((o == null) ? null : o.getType());\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-put\", data.getId()));\n+        return (o == null || o.isTimedOut()) ? null : o;\n+    }\n+\n+    public void update(DataCachePCData data) {\n+        if (recacheUpdates())\n+            putInternal(data.getId(), data);\n+    }\n+\n+    public DataCachePCData remove(Object key) {\n+        DataCachePCData o = removeInternal(key);\n+        if (o != null && o.isTimedOut())\n+            o = null;\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-remove-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-remove-hit\", key));\n+        }\n+        return o;\n+    }\n+\n+    public BitSet removeAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (remove(iter.next()) != null)\n+                set.set(i);\n+        return set;\n+    }\n+\n+    /**\n+     * Remove the objects of the given class from the cache.\n+     */\n+    public void removeAll(Class cls, boolean subClasses) {\n+        removeAllInternal(cls, subClasses);\n+    }\n+\n+    public boolean pin(Object key) {\n+        boolean bool = pinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-pin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-pin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public BitSet pinAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (pin(iter.next()))\n+                set.set(i);\n+        return set;\n+    }\n+\n+    public void pinAll(Class<?> cls, boolean subs) {\n+        if (log.isWarnEnabled())\n+            log.warn(s_loc.get(\"cache-class-pin\", getName()));\n+    }\n+\n+    public boolean unpin(Object key) {\n+        boolean bool = unpinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-unpin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-unpin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public BitSet unpinAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (unpin(iter.next()))\n+                set.set(i);\n+        return set;\n+    }\n+\n+    public void unpinAll(Class<?> cls, boolean subs) {\n+        if (log.isWarnEnabled())\n+            log.warn(s_loc.get(\"cache-class-unpin\", getName()));\n+    }\n+\n+    public void clear() {\n+        clearInternal();\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-clear\", getName()));\n+    }\n+\n+    public void close() {\n+        close(true);\n+    }\n+\n+    protected void close(boolean clear) {\n+        if (!_closed) {\n+            if (clear)\n+                clearInternal();\n+            _closed = true;\n+        }\n+    }\n+\n+    public boolean isClosed() {\n+        return _closed;\n+    }\n+\n+    public void addExpirationListener(ExpirationListener listen) {\n+        addListener(listen);\n+    }\n+\n+    public boolean removeExpirationListener(ExpirationListener listen) {\n+        return removeListener(listen);\n+    }\n+\n+    public String toString() {\n+        return \"[\" + super.toString() + \":\" + _name + \"]\";\n+    }\n+\n+    /**\n+     * This method is part of the {@link RemoteCommitListener} interface. If\n+     * your cache subclass relies on OpenJPA for clustering support, make it\n+     * implement <code>RemoteCommitListener</code>. This method will take\n+     * care of invalidating entries from remote commits.\n+     */\n+    public void afterCommit(RemoteCommitEvent event) {\n+        if (_closed)\n+            return;\n+\n+        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\n+            removeAllTypeNamesInternal(event.getUpdatedTypeNames());\n+            removeAllTypeNamesInternal(event.getDeletedTypeNames());\n+        } else {\n+            // drop all the committed OIDs, excepting brand\n+            // new OIDs. brand new OIDs either won't be in\n+            // the cache, or if they are, will be more up to date\n+            removeAllInternal(event.getUpdatedObjectIds());\n+            removeAllInternal(event.getDeletedObjectIds());\n+        }\n+    }\n+\n+    /**\n+     * Invoke when a key is removed from this cache. Propagates the\n+     * expiration event on to all expiration listeners registered\n+     * with this class.\n+     */\n+    protected void keyRemoved(Object key, boolean expired) {\n+        // Notify any expiration listeners of the expiration.\n+        if (hasListeners())\n+            fireEvent(new ExpirationEvent(this, key, expired));\n+\n+        if (expired && log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-expired\", key));\n+    }\n+\n+    /**\n+     * Return <code>true</code> if updates to data already in the\n+     * cache (either in {@link #commit} or the {@link #update})\n+     * should be put back into the cache. Returns false by default.\n+     */\n+    protected boolean recacheUpdates() {\n+        return false;\n+    }\n+\n+    /**\n+     * Return the object for the given oid.\n+     */\n+    protected abstract DataCachePCData getInternal(Object oid);\n+\n+    /**\n+     * Add the given object to the cache, returning the old object under the\n+     * given oid.\n+     */\n+    protected abstract DataCachePCData putInternal(Object oid,\n+            DataCachePCData pc);\n+    \n+    /**\n+     * Add all of the given objects to the cache.\n+     */\n+    protected void putAllInternal(Collection pcs) {\n+        DataCachePCData pc;\n+        for (Iterator iter = pcs.iterator(); iter.hasNext();) {\n+            pc = (DataCachePCData) iter.next();\n+            stats.newPut(pc.getType());\n+            putInternal(pc.getId(), pc);\n+        }\n+    }\n+\n+    /**\n+     * Remove the object under the given oid from the cache.\n+     */\n+    protected abstract DataCachePCData removeInternal(Object oid);\n+\n+    /**\n+     * Evict objects in cache by class.\n+     */\n+    protected abstract void removeAllInternal(Class<?> cls, boolean subclasses);\n+\n+    /**\n+     * Remove all objects under the given oids from the cache.\n+     */\n+    protected void removeAllInternal(Collection oids) {\n+        for (Iterator iter = oids.iterator(); iter.hasNext();)\n+            removeInternal(iter.next());\n+    }\n+\n+    /**\n+     * Remove all objects of the given class names from the cache.\n+     */\n+    protected void removeAllTypeNamesInternal(Collection classNames) {\n+        Collection classes = Caches.addTypesByName(conf, classNames, null);\n+        if (classes == null)\n+            return;\n+\n+        Class cls;\n+        for (Iterator iter = classes.iterator(); iter.hasNext();) {\n+            cls = (Class) iter.next();\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-removeclass\", cls.getName()));\n+            removeAllInternal(cls, false);\n+        }\n+    }\n+\n+    /**\n+     * Clear the cache.\n+     */\n+    protected abstract void clearInternal();\n+\n+    /**\n+     * Pin an object to the cache.\n+     */\n+    protected abstract boolean pinInternal(Object oid);\n+\n+    /**\n+     * Unpin an object from the cache.\n+     */\n+    protected abstract boolean unpinInternal(Object oid);\n+    \n+    public CacheStatistics getStatistics() {\n+    \treturn stats;\n+    }\n+\n+    // ---------- Configurable implementation ----------\n+\n+    public void setConfiguration(Configuration conf) {\n+        this.conf = (OpenJPAConfiguration) conf;\n+        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+        if (_name == null)\n+            setName(NAME_DEFAULT);\n+    }\n+\n+    // ---------- AbstractEventManager implementation ----------\n+\n+    protected void fireEvent(Object event, Object listener) {\n+        ExpirationListener listen = (ExpirationListener) listener;\n+        ExpirationEvent ev = (ExpirationEvent) event;\n+        try {\n+            listen.onExpire(ev);\n+        } catch (Exception e) {\n+            if (log.isWarnEnabled())\n+                log.warn(s_loc.get(\"exp-listener-ex\"), e);\n+\t\t}\n+\t}\n+}"},{"sha":"0bd3736842e7dc513d619e756d5498beb078e3f9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","status":"modified","additions":408,"deletions":408,"changes":816,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,408 +1,408 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.security.AccessController;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-import java.util.concurrent.ConcurrentHashMap;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.event.RemoteCommitEvent;\r\n-import org.apache.openjpa.event.RemoteCommitListener;\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.J2DoPrivHelper;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.util.Id;\r\n-\r\n-/**\r\n- * Abstract {@link QueryCache} implementation that provides various\r\n- * statistics, logging, and timeout functionality common across cache\r\n- * implementations.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @author Abe White\r\n- */\r\n-public abstract class AbstractQueryCache\r\n-    extends AbstractConcurrentEventManager \r\n-    implements QueryCache, Configurable {\r\n-\r\n-    private static final Localizer s_loc =\r\n-        Localizer.forPackage(AbstractQueryCache.class);\r\n-\r\n-    private static final String TIMESTAMP = \"timestamp\";\r\n-    public enum EvictPolicy {DEFAULT, TIMESTAMP};\r\n-    /**\r\n-     * The configuration set by the system.\r\n-     */\r\n-    protected OpenJPAConfiguration conf;\r\n-\r\n-    /**\r\n-     * The log to use.\r\n-     */\r\n-    protected Log log;\r\n-\r\n-    protected ConcurrentHashMap<String,Long> entityTimestampMap = null;\r\n-    private boolean _closed = false;\r\n-    // default evict policy\r\n-    public EvictPolicy evictPolicy = EvictPolicy.DEFAULT;\r\n-\r\n-    public void initialize(DataCacheManager manager) {\r\n-        if (evictPolicy == EvictPolicy.TIMESTAMP) {\r\n-            entityTimestampMap = new ConcurrentHashMap<String,Long>();\r\n-        \r\n-            // Get all persistence types to pre-load the entityTimestamp Map\r\n-            Collection perTypes =\r\n-                conf.getMetaDataRepositoryInstance().getPersistentTypeNames(\r\n-                    false,\r\n-                    AccessController.doPrivileged(J2DoPrivHelper\r\n-                        .getContextClassLoaderAction()));\r\n-            \r\n-            // Pre-load all the entity types into the HashMap to handle \r\n-            // synchronization on the map efficiently\r\n-            for (Object o : perTypes)\r\n-                entityTimestampMap.put((String)o, new Long(0));\r\n-        }\r\n-    }\r\n-\r\n-    public void onTypesChanged(TypesChangedEvent ev) {\r\n-        writeLock();\r\n-        Collection keys = null;\r\n-        if (evictPolicy == EvictPolicy.DEFAULT) {\r\n-            try {\r\n-                if (hasListeners())\r\n-                    fireEvent(ev);\r\n-                keys = keySet();\r\n-            } finally {\r\n-                writeUnlock();\r\n-            }\r\n-    \r\n-            QueryKey qk;\r\n-                List<QueryKey> removes = null;\r\n-                for (Object o: keys) {\r\n-                    qk = (QueryKey) o;\r\n-                if (qk.changeInvalidatesQuery(ev.getTypes())) {\r\n-                    if (removes == null)\r\n-                        removes = new ArrayList<QueryKey>();\r\n-                    removes.add(qk);\r\n-                }\r\n-            }\r\n-            if (removes != null)\r\n-                removeAllInternal(removes);\r\n-        } else {\r\n-            Collection changedTypes = ev.getTypes();\r\n-            HashMap<String,Long> changedClasses = \r\n-                new HashMap<String,Long>(); \r\n-            for (Object o: changedTypes) {\r\n-                String name = ((Class) o).getName();\r\n-                if(!changedClasses.containsKey(name))\r\n-                    changedClasses.put(name, \r\n-                        new Long(System.currentTimeMillis()));\r\n-            }           \r\n-            // Now update entity timestamp map\r\n-            updateEntityTimestamp(changedClasses);\r\n-        }\r\n-    }\r\n-\r\n-    public QueryResult get(QueryKey key) {\r\n-        QueryResult o = getInternal(key);\r\n-        if (o != null && o.isTimedOut()) {\r\n-            o = null;\r\n-            removeInternal(key);\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-timeout\", key));\r\n-        }\r\n-\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-miss\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-hit\", key));\r\n-        }\r\n-        return o;\r\n-    }\r\n-\r\n-    public QueryResult put(QueryKey qk, QueryResult oids) {\r\n-        QueryResult o = putInternal(qk, oids);\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-put\", qk));\r\n-        return (o == null || o.isTimedOut()) ? null : o;\r\n-    }\r\n-\r\n-    public QueryResult remove(QueryKey key) {\r\n-        QueryResult o = removeInternal(key);\r\n-        if (o != null && o.isTimedOut())\r\n-            o = null;\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-remove-miss\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-remove-hit\", key));\r\n-        }\r\n-        return o;\r\n-    }\r\n-\r\n-    public boolean pin(QueryKey key) {\r\n-        boolean bool = pinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-pin-hit\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-pin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public boolean unpin(QueryKey key) {\r\n-        boolean bool = unpinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-unpin-hit\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-unpin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        clearInternal();\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-clear\", \"<query-cache>\"));\r\n-    }\r\n-\r\n-    public void close() {\r\n-        close(true);\r\n-    }\r\n-\r\n-    protected void close(boolean clear) {\r\n-        if (!_closed) {\r\n-            if (clear)\r\n-                clearInternal();\r\n-            _closed = true;\r\n-        }\r\n-    }\r\n-\r\n-    public boolean isClosed() {\r\n-        return _closed;\r\n-    }\r\n-\r\n-    public void addTypesChangedListener(TypesChangedListener listen) {\r\n-        addListener(listen);\r\n-    }\r\n-\r\n-    public boolean removeTypesChangedListener(TypesChangedListener listen) {\r\n-        return removeListener(listen);\r\n-    }\r\n-\r\n-    /**\r\n-     * This method is part of the {@link RemoteCommitListener} interface. If\r\n-     * your cache subclass relies on OpenJPA for clustering support, make it\r\n-     * implement <code>RemoteCommitListener</code>. This method will take\r\n-     * care of invalidating entries from remote commits, by delegating to\r\n-     * {@link #onTypesChanged}.\r\n-     */\r\n-    public void afterCommit(RemoteCommitEvent event) {\r\n-        if (_closed)\r\n-            return;\r\n-\r\n-        // drop all committed classes\r\n-        Set classes = Caches.addTypesByName(conf,\r\n-            event.getPersistedTypeNames(), null);\r\n-        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\r\n-            classes = Caches.addTypesByName(conf, event.getUpdatedTypeNames(),\r\n-                classes);\r\n-            classes = Caches.addTypesByName(conf, event.getDeletedTypeNames(),\r\n-                classes);\r\n-        } else {\r\n-            classes = addTypes(event.getUpdatedObjectIds(), classes);\r\n-            classes = addTypes(event.getDeletedObjectIds(), classes);\r\n-        }\r\n-        if (classes != null)\r\n-            onTypesChanged(new TypesChangedEvent(this, classes));\r\n-    }\r\n-\r\n-    /**\r\n-     * Build up a set of classes for the given oids.\r\n-     */\r\n-    private Set addTypes(Collection oids, Set classes) {\r\n-        if (oids.isEmpty())\r\n-            return classes;\r\n-        if (classes == null)\r\n-            classes = new HashSet();\r\n-\r\n-        MetaDataRepository repos = conf.getMetaDataRepositoryInstance();\r\n-        ClassMetaData meta;\r\n-        Object oid;\r\n-        for (Iterator itr = oids.iterator(); itr.hasNext();) {\r\n-            oid = itr.next();\r\n-            if (oid instanceof Id)\r\n-                classes.add(((Id) oid).getType());\r\n-            else {\r\n-                // ok if no metadata for oid; that just means the pc type\r\n-                // probably hasn't been loaded into this JVM yet, and therefore\r\n-                // there's no chance that it's in the cache anyway\r\n-                meta = repos.getMetaData(oid, null, false);\r\n-                if (meta != null)\r\n-                    classes.add(meta.getDescribedType());\r\n-            }\r\n-        }\r\n-        return classes;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a threadsafe view of the keys in this cache. This collection\r\n-     * must be iterable without risk of concurrent modification exceptions.\r\n-     * It does not have to implement contains() efficiently or use set\r\n-     * semantics.\r\n-     */\r\n-    protected abstract Collection keySet();\r\n-\r\n-    /**\r\n-     * Return the list for the given key.\r\n-     */\r\n-    protected abstract QueryResult getInternal(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Add the given result to the cache, returning the old result under the\r\n-     * given key.\r\n-     */\r\n-    protected abstract QueryResult putInternal(QueryKey qk, QueryResult oids);\r\n-\r\n-    /**\r\n-     * Remove the result under the given key from the cache.\r\n-     */\r\n-    protected abstract QueryResult removeInternal(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Remove all results under the given keys from the cache.\r\n-     */\r\n-    protected void removeAllInternal(Collection qks) {\r\n-        for (Iterator iter = qks.iterator(); iter.hasNext();)\r\n-            removeInternal((QueryKey) iter.next());\r\n-    }\r\n-\r\n-    /**\r\n-     * Clear the cache.\r\n-     */\r\n-    protected abstract void clearInternal();\r\n-\r\n-    /**\r\n-     * Pin an object to the cache.\r\n-     */\r\n-    protected abstract boolean pinInternal(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Unpin an object from the cache.\r\n-     */\r\n-    protected abstract boolean unpinInternal(QueryKey qk);\r\n-\r\n-    // ---------- Configurable implementation ----------\r\n-\r\n-    public void setConfiguration(Configuration conf) {\r\n-        this.conf = (OpenJPAConfiguration) conf;\r\n-        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-    }\r\n-\r\n-    // ---------- AbstractEventManager implementation ----------\r\n-\r\n-    protected void fireEvent(Object event, Object listener) {\r\n-        TypesChangedListener listen = (TypesChangedListener) listener;\r\n-        TypesChangedEvent ev = (TypesChangedEvent) event;\r\n-        try {\r\n-            listen.onTypesChanged(ev);\r\n-        } catch (Exception e) {\r\n-            if (log.isWarnEnabled())\r\n-                log.warn(s_loc.get(\"exp-listener-ex\"), e);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Individual query results will be registered as types changed\r\n-     * listeners. We want such query results to be gc'd once\r\n-     * the only reference is held by the list of expiration listeners.\r\n-     */\r\n-    protected Collection newListenerCollection() {\r\n-        return new ConcurrentReferenceHashSet (ConcurrentReferenceHashSet.WEAK);\r\n-\t}\r\n-\r\n-    /**\r\n-     * Sets the eviction policy for the query cache\r\n-     * @param evictPolicy -- String value that specifies the eviction policy\r\n-     */\r\n-    public void setEvictPolicy(String evictPolicy) {\r\n-        if (evictPolicy.equalsIgnoreCase(TIMESTAMP))\r\n-            this.evictPolicy = EvictPolicy.TIMESTAMP;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the evictionPolicy for QueryCache\r\n-     * @return -- returns a String value of evictPolicy attribute\r\n-     */\r\n-    public EvictPolicy getEvictPolicy() {\r\n-        return this.evictPolicy;\r\n-    }\r\n-\r\n-    /**\r\n-     * Updates the entity timestamp map with the current time in milliseconds\r\n-     * @param timestampMap -- a map that contains entityname and its last updated timestamp\r\n-     */\r\n-    protected void updateEntityTimestamp(Map<String,Long> timestampMap) {\r\n-        if (entityTimestampMap != null)\r\n-            entityTimestampMap.putAll(timestampMap);\r\n-     }\r\n-\r\n-    /**\r\n-     * Returns a list of timestamps in the form of Long objects\r\n-     * which are the last updated time stamps for the given entities in the\r\n-     * keylist.\r\n-     * @param keyList -- List of entity names \r\n-     * @return -- Returns a list that has the timestamp for the given entities\r\n-     */\r\n-    public List<Long> getAllEntityTimestamp(List<String> keyList) { \r\n-        ArrayList<Long> tmval = null;\r\n-        if (entityTimestampMap != null) {\r\n-            for (String s: keyList) {\r\n-                if (entityTimestampMap.containsKey(s)) {\r\n-                    if(tmval == null)\r\n-                        tmval = new ArrayList<Long>();\r\n-                    tmval.add(entityTimestampMap.get(s));\r\n-                }\r\n-            }\r\n-        }\r\n-        return tmval;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.security.AccessController;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.event.RemoteCommitEvent;\n+import org.apache.openjpa.event.RemoteCommitListener;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.util.Id;\n+\n+/**\n+ * Abstract {@link QueryCache} implementation that provides various\n+ * statistics, logging, and timeout functionality common across cache\n+ * implementations.\n+ *\n+ * @author Patrick Linskey\n+ * @author Abe White\n+ */\n+public abstract class AbstractQueryCache\n+    extends AbstractConcurrentEventManager \n+    implements QueryCache, Configurable {\n+\n+    private static final Localizer s_loc =\n+        Localizer.forPackage(AbstractQueryCache.class);\n+\n+    private static final String TIMESTAMP = \"timestamp\";\n+    public enum EvictPolicy {DEFAULT, TIMESTAMP};\n+    /**\n+     * The configuration set by the system.\n+     */\n+    protected OpenJPAConfiguration conf;\n+\n+    /**\n+     * The log to use.\n+     */\n+    protected Log log;\n+\n+    protected ConcurrentHashMap<String,Long> entityTimestampMap = null;\n+    private boolean _closed = false;\n+    // default evict policy\n+    public EvictPolicy evictPolicy = EvictPolicy.DEFAULT;\n+\n+    public void initialize(DataCacheManager manager) {\n+        if (evictPolicy == EvictPolicy.TIMESTAMP) {\n+            entityTimestampMap = new ConcurrentHashMap<String,Long>();\n+        \n+            // Get all persistence types to pre-load the entityTimestamp Map\n+            Collection perTypes =\n+                conf.getMetaDataRepositoryInstance().getPersistentTypeNames(\n+                    false,\n+                    AccessController.doPrivileged(J2DoPrivHelper\n+                        .getContextClassLoaderAction()));\n+            \n+            // Pre-load all the entity types into the HashMap to handle \n+            // synchronization on the map efficiently\n+            for (Object o : perTypes)\n+                entityTimestampMap.put((String)o, new Long(0));\n+        }\n+    }\n+\n+    public void onTypesChanged(TypesChangedEvent ev) {\n+        writeLock();\n+        Collection keys = null;\n+        if (evictPolicy == EvictPolicy.DEFAULT) {\n+            try {\n+                if (hasListeners())\n+                    fireEvent(ev);\n+                keys = keySet();\n+            } finally {\n+                writeUnlock();\n+            }\n+    \n+            QueryKey qk;\n+                List<QueryKey> removes = null;\n+                for (Object o: keys) {\n+                    qk = (QueryKey) o;\n+                if (qk.changeInvalidatesQuery(ev.getTypes())) {\n+                    if (removes == null)\n+                        removes = new ArrayList<QueryKey>();\n+                    removes.add(qk);\n+                }\n+            }\n+            if (removes != null)\n+                removeAllInternal(removes);\n+        } else {\n+            Collection changedTypes = ev.getTypes();\n+            HashMap<String,Long> changedClasses = \n+                new HashMap<String,Long>(); \n+            for (Object o: changedTypes) {\n+                String name = ((Class) o).getName();\n+                if(!changedClasses.containsKey(name))\n+                    changedClasses.put(name, \n+                        new Long(System.currentTimeMillis()));\n+            }           \n+            // Now update entity timestamp map\n+            updateEntityTimestamp(changedClasses);\n+        }\n+    }\n+\n+    public QueryResult get(QueryKey key) {\n+        QueryResult o = getInternal(key);\n+        if (o != null && o.isTimedOut()) {\n+            o = null;\n+            removeInternal(key);\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-timeout\", key));\n+        }\n+\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-hit\", key));\n+        }\n+        return o;\n+    }\n+\n+    public QueryResult put(QueryKey qk, QueryResult oids) {\n+        QueryResult o = putInternal(qk, oids);\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-put\", qk));\n+        return (o == null || o.isTimedOut()) ? null : o;\n+    }\n+\n+    public QueryResult remove(QueryKey key) {\n+        QueryResult o = removeInternal(key);\n+        if (o != null && o.isTimedOut())\n+            o = null;\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-remove-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-remove-hit\", key));\n+        }\n+        return o;\n+    }\n+\n+    public boolean pin(QueryKey key) {\n+        boolean bool = pinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-pin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-pin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public boolean unpin(QueryKey key) {\n+        boolean bool = unpinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-unpin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-unpin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public void clear() {\n+        clearInternal();\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-clear\", \"<query-cache>\"));\n+    }\n+\n+    public void close() {\n+        close(true);\n+    }\n+\n+    protected void close(boolean clear) {\n+        if (!_closed) {\n+            if (clear)\n+                clearInternal();\n+            _closed = true;\n+        }\n+    }\n+\n+    public boolean isClosed() {\n+        return _closed;\n+    }\n+\n+    public void addTypesChangedListener(TypesChangedListener listen) {\n+        addListener(listen);\n+    }\n+\n+    public boolean removeTypesChangedListener(TypesChangedListener listen) {\n+        return removeListener(listen);\n+    }\n+\n+    /**\n+     * This method is part of the {@link RemoteCommitListener} interface. If\n+     * your cache subclass relies on OpenJPA for clustering support, make it\n+     * implement <code>RemoteCommitListener</code>. This method will take\n+     * care of invalidating entries from remote commits, by delegating to\n+     * {@link #onTypesChanged}.\n+     */\n+    public void afterCommit(RemoteCommitEvent event) {\n+        if (_closed)\n+            return;\n+\n+        // drop all committed classes\n+        Set classes = Caches.addTypesByName(conf,\n+            event.getPersistedTypeNames(), null);\n+        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\n+            classes = Caches.addTypesByName(conf, event.getUpdatedTypeNames(),\n+                classes);\n+            classes = Caches.addTypesByName(conf, event.getDeletedTypeNames(),\n+                classes);\n+        } else {\n+            classes = addTypes(event.getUpdatedObjectIds(), classes);\n+            classes = addTypes(event.getDeletedObjectIds(), classes);\n+        }\n+        if (classes != null)\n+            onTypesChanged(new TypesChangedEvent(this, classes));\n+    }\n+\n+    /**\n+     * Build up a set of classes for the given oids.\n+     */\n+    private Set addTypes(Collection oids, Set classes) {\n+        if (oids.isEmpty())\n+            return classes;\n+        if (classes == null)\n+            classes = new HashSet();\n+\n+        MetaDataRepository repos = conf.getMetaDataRepositoryInstance();\n+        ClassMetaData meta;\n+        Object oid;\n+        for (Iterator itr = oids.iterator(); itr.hasNext();) {\n+            oid = itr.next();\n+            if (oid instanceof Id)\n+                classes.add(((Id) oid).getType());\n+            else {\n+                // ok if no metadata for oid; that just means the pc type\n+                // probably hasn't been loaded into this JVM yet, and therefore\n+                // there's no chance that it's in the cache anyway\n+                meta = repos.getMetaData(oid, null, false);\n+                if (meta != null)\n+                    classes.add(meta.getDescribedType());\n+            }\n+        }\n+        return classes;\n+    }\n+\n+    /**\n+     * Return a threadsafe view of the keys in this cache. This collection\n+     * must be iterable without risk of concurrent modification exceptions.\n+     * It does not have to implement contains() efficiently or use set\n+     * semantics.\n+     */\n+    protected abstract Collection keySet();\n+\n+    /**\n+     * Return the list for the given key.\n+     */\n+    protected abstract QueryResult getInternal(QueryKey qk);\n+\n+    /**\n+     * Add the given result to the cache, returning the old result under the\n+     * given key.\n+     */\n+    protected abstract QueryResult putInternal(QueryKey qk, QueryResult oids);\n+\n+    /**\n+     * Remove the result under the given key from the cache.\n+     */\n+    protected abstract QueryResult removeInternal(QueryKey qk);\n+\n+    /**\n+     * Remove all results under the given keys from the cache.\n+     */\n+    protected void removeAllInternal(Collection qks) {\n+        for (Iterator iter = qks.iterator(); iter.hasNext();)\n+            removeInternal((QueryKey) iter.next());\n+    }\n+\n+    /**\n+     * Clear the cache.\n+     */\n+    protected abstract void clearInternal();\n+\n+    /**\n+     * Pin an object to the cache.\n+     */\n+    protected abstract boolean pinInternal(QueryKey qk);\n+\n+    /**\n+     * Unpin an object from the cache.\n+     */\n+    protected abstract boolean unpinInternal(QueryKey qk);\n+\n+    // ---------- Configurable implementation ----------\n+\n+    public void setConfiguration(Configuration conf) {\n+        this.conf = (OpenJPAConfiguration) conf;\n+        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+    }\n+\n+    // ---------- AbstractEventManager implementation ----------\n+\n+    protected void fireEvent(Object event, Object listener) {\n+        TypesChangedListener listen = (TypesChangedListener) listener;\n+        TypesChangedEvent ev = (TypesChangedEvent) event;\n+        try {\n+            listen.onTypesChanged(ev);\n+        } catch (Exception e) {\n+            if (log.isWarnEnabled())\n+                log.warn(s_loc.get(\"exp-listener-ex\"), e);\n+        }\n+    }\n+\n+    /**\n+     * Individual query results will be registered as types changed\n+     * listeners. We want such query results to be gc'd once\n+     * the only reference is held by the list of expiration listeners.\n+     */\n+    protected Collection newListenerCollection() {\n+        return new ConcurrentReferenceHashSet (ConcurrentReferenceHashSet.WEAK);\n+\t}\n+\n+    /**\n+     * Sets the eviction policy for the query cache\n+     * @param evictPolicy -- String value that specifies the eviction policy\n+     */\n+    public void setEvictPolicy(String evictPolicy) {\n+        if (evictPolicy.equalsIgnoreCase(TIMESTAMP))\n+            this.evictPolicy = EvictPolicy.TIMESTAMP;\n+    }\n+\n+    /**\n+     * Returns the evictionPolicy for QueryCache\n+     * @return -- returns a String value of evictPolicy attribute\n+     */\n+    public EvictPolicy getEvictPolicy() {\n+        return this.evictPolicy;\n+    }\n+\n+    /**\n+     * Updates the entity timestamp map with the current time in milliseconds\n+     * @param timestampMap -- a map that contains entityname and its last updated timestamp\n+     */\n+    protected void updateEntityTimestamp(Map<String,Long> timestampMap) {\n+        if (entityTimestampMap != null)\n+            entityTimestampMap.putAll(timestampMap);\n+     }\n+\n+    /**\n+     * Returns a list of timestamps in the form of Long objects\n+     * which are the last updated time stamps for the given entities in the\n+     * keylist.\n+     * @param keyList -- List of entity names \n+     * @return -- Returns a list that has the timestamp for the given entities\n+     */\n+    public List<Long> getAllEntityTimestamp(List<String> keyList) { \n+        ArrayList<Long> tmval = null;\n+        if (entityTimestampMap != null) {\n+            for (String s: keyList) {\n+                if (entityTimestampMap.containsKey(s)) {\n+                    if(tmval == null)\n+                        tmval = new ArrayList<Long>();\n+                    tmval.add(entityTimestampMap.get(s));\n+                }\n+            }\n+        }\n+        return tmval;\n+    }\n+}"},{"sha":"c4aed291323bf02ff2c7a405fd6fd0a861dd0b07","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/CacheStatistics.java","status":"modified","additions":233,"deletions":233,"changes":466,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/CacheStatistics.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/CacheStatistics.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/CacheStatistics.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,233 +1,233 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.io.Serializable;\r\n-import java.util.Date;\r\n-import java.util.HashMap;\r\n-import java.util.Map;\r\n-\r\n-/**\r\n- * Counts number of read/write requests and hit ratio for a cache in total and\r\n- * per-class basis.\r\n- * \r\n- * All methods with Class as input argument treats null as \r\n- * <code>java.lang.Object</code>. All per-class statistics  depends on \r\n- * determining the runtime type of the instance being cached. If it is not\r\n- * possible to determine the runtime type from the given context, the statistics\r\n- * is registered under generic <code>java.lang.Object</code>. \r\n- * \r\n- * @since 1.3.0\r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- */\r\n-public interface CacheStatistics extends Serializable {\r\n-\t/**\r\n-\t * Gets number of total read requests since last reset.\r\n-\t */\r\n-\tpublic long getReadCount();\r\n-\r\n-\t/**\r\n-\t * Gets number of total read requests that has been found in cache since\r\n-\t * last reset.\r\n-\t */\r\n-\tpublic long getHitCount();\r\n-\r\n-\t/**\r\n-\t * Gets number of total write requests since last reset.\r\n-\t */\r\n-\tpublic long getWriteCount();\r\n-\r\n-\t/**\r\n-\t * Gets number of total read requests since start.\r\n-\t */\r\n-\tpublic long getTotalReadCount();\r\n-\r\n-\t/**\r\n-\t * Gets number of total read requests that has been found in cache since\r\n-\t * start.\r\n-\t */\r\n-\tpublic long getTotalHitCount();\r\n-\r\n-\t/**\r\n-\t * Gets number of total write requests since start.\r\n-\t */\r\n-\tpublic long getTotalWriteCount();\r\n-\r\n-\t/**\r\n-\t * Gets number of total read requests for the given class since last reset.\r\n-\t */\r\n-\tpublic long getReadCount(Class c);\r\n-\r\n-\t/**\r\n-\t * Gets number of total read requests that has been found in cache for the\r\n-\t * given class since last reset.\r\n-\t */\r\n-\tpublic long getHitCount(Class c);\r\n-\r\n-\t/**\r\n-\t * Gets number of total write requests for the given class since last reset.\r\n-\t */\r\n-\tpublic long getWriteCount(Class c);\r\n-\r\n-\t/**\r\n-\t * Gets number of total read requests for the given class since start.\r\n-\t */\r\n-\tpublic long getTotalReadCount(Class c);\r\n-\r\n-\t/**\r\n-\t * Gets number of total read requests that has been found in cache for the\r\n-\t * given class since start.\r\n-\t */\r\n-\tpublic long getTotalHitCount(Class c);\r\n-\r\n-\t/**\r\n-\t * Gets number of total write requests for the given class since start.\r\n-\t */\r\n-\tpublic long getTotalWriteCount(Class c);\r\n-\r\n-\t/**\r\n-\t * Gets the time of last reset.\r\n-\t */\r\n-\tpublic Date since();\r\n-\r\n-\t/**\r\n-\t * Gets the time of start.\r\n-\t */\r\n-\tpublic Date start();\r\n-\r\n-\t/**\r\n-\t * Clears all accumulated statistics.\r\n-\t */\r\n-\tpublic void reset();\r\n-\t\r\n-\t/**\r\n-\t * A default implementation.\r\n-\t *\r\n-\t */\r\n-\tpublic static class Default implements CacheStatistics {\r\n-\t\tprivate long[] astat = new long[3];\r\n-\t\tprivate long[] stat  = new long[3];\r\n-\t\tprivate Map<Class, long[]> stats  = new HashMap<Class, long[]>();\r\n-\t\tprivate Map<Class, long[]> astats = new HashMap<Class, long[]>();\r\n-\t\tprivate Date start = new Date();\r\n-\t\tprivate Date since = new Date();\r\n-\r\n-\t\tprivate static final int READ  = 0;\r\n-\t\tprivate static final int HIT   = 1;\r\n-\t\tprivate static final int WRITE = 2;\r\n-\r\n-\t\tpublic long getReadCount() {\r\n-\t\t\treturn stat[READ];\r\n-\t\t}\r\n-\r\n-\t\tpublic long getHitCount() {\r\n-\t\t\treturn stat[HIT];\r\n-\t\t}\r\n-\r\n-\t\tpublic long getWriteCount() {\r\n-\t\t\treturn stat[WRITE];\r\n-\t\t}\r\n-\r\n-\t\tpublic long getTotalReadCount() {\r\n-\t\t\treturn astat[READ];\r\n-\t\t}\r\n-\r\n-\t\tpublic long getTotalHitCount() {\r\n-\t\t\treturn astat[HIT];\r\n-\t\t}\r\n-\r\n-\t\tpublic long getTotalWriteCount() {\r\n-\t\t\treturn astat[WRITE];\r\n-\t\t}\r\n-\r\n-\t\tpublic long getReadCount(Class c) {\r\n-\t\t\treturn getCount(stats, c, READ);\r\n-\t\t}\r\n-\r\n-\t\tpublic long getHitCount(Class c) {\r\n-\t\t\treturn getCount(stats, c, HIT);\r\n-\t\t}\r\n-\r\n-\t\tpublic long getWriteCount(Class c) {\r\n-\t\t\treturn getCount(stats, c, WRITE);\r\n-\t\t}\r\n-\r\n-\t\tpublic long getTotalReadCount(Class c) {\r\n-\t\t\treturn getCount(astats, c, READ);\r\n-\t\t}\r\n-\r\n-\t\tpublic long getTotalHitCount(Class c) {\r\n-\t\t\treturn getCount(astats, c, HIT);\r\n-\t\t}\r\n-\r\n-\t\tpublic long getTotalWriteCount(Class c) {\r\n-\t\t\treturn getCount(astats, c, WRITE);\r\n-\t\t}\r\n-\t\t\r\n-\t\tprivate long getCount(Map<Class, long[]> target, Class c, int index) {\r\n-\t\t\tlong[] row = target.get(c);\r\n-\t\t\treturn (row == null) ? 0 : row[index];\r\n-\t\t}\r\n-\r\n-\t\tpublic Date since() {\r\n-\t\t\treturn since;\r\n-\t\t}\r\n-\r\n-\t\tpublic Date start() {\r\n-\t\t\treturn start;\r\n-\t\t}\r\n-\r\n-\t\tpublic void reset() {\r\n-\t\t\tstat = new long[3];\r\n-\t\t\tstats.clear();\r\n-\t\t\tsince = new Date();\r\n-\t\t}\r\n-\r\n-\t\tvoid newGet(Class cls, boolean hit) {\r\n-\t\t\tcls = (cls == null) ? Object.class : cls;\r\n-\t\t\taddSample(cls, READ);\r\n-\t\t\tif (hit) {\r\n-\t\t\t\taddSample(cls, HIT);\r\n-\t\t\t}\r\n-\t\t}\r\n-\r\n-\t\tvoid newPut(Class cls) {\r\n-\t\t\tcls = (cls == null) ? Object.class : cls;\r\n-\t\t\taddSample(cls, WRITE);\r\n-\t\t}\r\n-\t\t\r\n-\t\tprivate void addSample(Class c, int index) {\r\n-\t\t\tstat[index]++;\r\n-\t\t\tastat[index]++;\r\n-\t\t\taddSample(stats, c, index);\r\n-\t\t\taddSample(astats, c, index);\r\n-\t\t}\r\n-\t\t\r\n-\t\tprivate void addSample(Map<Class, long[]> target, Class c, int index) {\r\n-\t\t\tlong[] row = target.get(c);\r\n-\t\t\tif (row == null) {\r\n-\t\t\t\trow = new long[3];\r\n-\t\t\t}\r\n-\t\t\trow[index]++;\r\n-\t\t\ttarget.put(c, row);\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.io.Serializable;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Counts number of read/write requests and hit ratio for a cache in total and\n+ * per-class basis.\n+ * \n+ * All methods with Class as input argument treats null as \n+ * <code>java.lang.Object</code>. All per-class statistics  depends on \n+ * determining the runtime type of the instance being cached. If it is not\n+ * possible to determine the runtime type from the given context, the statistics\n+ * is registered under generic <code>java.lang.Object</code>. \n+ * \n+ * @since 1.3.0\n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+public interface CacheStatistics extends Serializable {\n+\t/**\n+\t * Gets number of total read requests since last reset.\n+\t */\n+\tpublic long getReadCount();\n+\n+\t/**\n+\t * Gets number of total read requests that has been found in cache since\n+\t * last reset.\n+\t */\n+\tpublic long getHitCount();\n+\n+\t/**\n+\t * Gets number of total write requests since last reset.\n+\t */\n+\tpublic long getWriteCount();\n+\n+\t/**\n+\t * Gets number of total read requests since start.\n+\t */\n+\tpublic long getTotalReadCount();\n+\n+\t/**\n+\t * Gets number of total read requests that has been found in cache since\n+\t * start.\n+\t */\n+\tpublic long getTotalHitCount();\n+\n+\t/**\n+\t * Gets number of total write requests since start.\n+\t */\n+\tpublic long getTotalWriteCount();\n+\n+\t/**\n+\t * Gets number of total read requests for the given class since last reset.\n+\t */\n+\tpublic long getReadCount(Class c);\n+\n+\t/**\n+\t * Gets number of total read requests that has been found in cache for the\n+\t * given class since last reset.\n+\t */\n+\tpublic long getHitCount(Class c);\n+\n+\t/**\n+\t * Gets number of total write requests for the given class since last reset.\n+\t */\n+\tpublic long getWriteCount(Class c);\n+\n+\t/**\n+\t * Gets number of total read requests for the given class since start.\n+\t */\n+\tpublic long getTotalReadCount(Class c);\n+\n+\t/**\n+\t * Gets number of total read requests that has been found in cache for the\n+\t * given class since start.\n+\t */\n+\tpublic long getTotalHitCount(Class c);\n+\n+\t/**\n+\t * Gets number of total write requests for the given class since start.\n+\t */\n+\tpublic long getTotalWriteCount(Class c);\n+\n+\t/**\n+\t * Gets the time of last reset.\n+\t */\n+\tpublic Date since();\n+\n+\t/**\n+\t * Gets the time of start.\n+\t */\n+\tpublic Date start();\n+\n+\t/**\n+\t * Clears all accumulated statistics.\n+\t */\n+\tpublic void reset();\n+\t\n+\t/**\n+\t * A default implementation.\n+\t *\n+\t */\n+\tpublic static class Default implements CacheStatistics {\n+\t\tprivate long[] astat = new long[3];\n+\t\tprivate long[] stat  = new long[3];\n+\t\tprivate Map<Class, long[]> stats  = new HashMap<Class, long[]>();\n+\t\tprivate Map<Class, long[]> astats = new HashMap<Class, long[]>();\n+\t\tprivate Date start = new Date();\n+\t\tprivate Date since = new Date();\n+\n+\t\tprivate static final int READ  = 0;\n+\t\tprivate static final int HIT   = 1;\n+\t\tprivate static final int WRITE = 2;\n+\n+\t\tpublic long getReadCount() {\n+\t\t\treturn stat[READ];\n+\t\t}\n+\n+\t\tpublic long getHitCount() {\n+\t\t\treturn stat[HIT];\n+\t\t}\n+\n+\t\tpublic long getWriteCount() {\n+\t\t\treturn stat[WRITE];\n+\t\t}\n+\n+\t\tpublic long getTotalReadCount() {\n+\t\t\treturn astat[READ];\n+\t\t}\n+\n+\t\tpublic long getTotalHitCount() {\n+\t\t\treturn astat[HIT];\n+\t\t}\n+\n+\t\tpublic long getTotalWriteCount() {\n+\t\t\treturn astat[WRITE];\n+\t\t}\n+\n+\t\tpublic long getReadCount(Class c) {\n+\t\t\treturn getCount(stats, c, READ);\n+\t\t}\n+\n+\t\tpublic long getHitCount(Class c) {\n+\t\t\treturn getCount(stats, c, HIT);\n+\t\t}\n+\n+\t\tpublic long getWriteCount(Class c) {\n+\t\t\treturn getCount(stats, c, WRITE);\n+\t\t}\n+\n+\t\tpublic long getTotalReadCount(Class c) {\n+\t\t\treturn getCount(astats, c, READ);\n+\t\t}\n+\n+\t\tpublic long getTotalHitCount(Class c) {\n+\t\t\treturn getCount(astats, c, HIT);\n+\t\t}\n+\n+\t\tpublic long getTotalWriteCount(Class c) {\n+\t\t\treturn getCount(astats, c, WRITE);\n+\t\t}\n+\t\t\n+\t\tprivate long getCount(Map<Class, long[]> target, Class c, int index) {\n+\t\t\tlong[] row = target.get(c);\n+\t\t\treturn (row == null) ? 0 : row[index];\n+\t\t}\n+\n+\t\tpublic Date since() {\n+\t\t\treturn since;\n+\t\t}\n+\n+\t\tpublic Date start() {\n+\t\t\treturn start;\n+\t\t}\n+\n+\t\tpublic void reset() {\n+\t\t\tstat = new long[3];\n+\t\t\tstats.clear();\n+\t\t\tsince = new Date();\n+\t\t}\n+\n+\t\tvoid newGet(Class cls, boolean hit) {\n+\t\t\tcls = (cls == null) ? Object.class : cls;\n+\t\t\taddSample(cls, READ);\n+\t\t\tif (hit) {\n+\t\t\t\taddSample(cls, HIT);\n+\t\t\t}\n+\t\t}\n+\n+\t\tvoid newPut(Class cls) {\n+\t\t\tcls = (cls == null) ? Object.class : cls;\n+\t\t\taddSample(cls, WRITE);\n+\t\t}\n+\t\t\n+\t\tprivate void addSample(Class c, int index) {\n+\t\t\tstat[index]++;\n+\t\t\tastat[index]++;\n+\t\t\taddSample(stats, c, index);\n+\t\t\taddSample(astats, c, index);\n+\t\t}\n+\t\t\n+\t\tprivate void addSample(Map<Class, long[]> target, Class c, int index) {\n+\t\t\tlong[] row = target.get(c);\n+\t\t\tif (row == null) {\n+\t\t\t\trow = new long[3];\n+\t\t\t}\n+\t\t\trow[index]++;\n+\t\t\ttarget.put(c, row);\n+\t\t}\n+\t}\n+}"},{"sha":"b17c02fdec1307587e5974b4e9e1783fe30bde02","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","status":"modified","additions":249,"deletions":249,"changes":498,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,249 +1,249 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.security.AccessController;\r\n-import java.text.DateFormat;\r\n-import java.text.SimpleDateFormat;\r\n-import java.util.Calendar;\r\n-import java.util.Date;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-import java.util.StringTokenizer;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.J2DoPrivHelper;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import java.util.concurrent.ConcurrentHashMap;\r\n-import org.apache.openjpa.util.InvalidStateException;\r\n-import org.apache.openjpa.util.UserException;\r\n-import serp.util.Strings;\r\n-\r\n-/**\r\n- * Cron-style cache eviction. Understands schedules based on cron format:\r\n- * <code>minute hour mday month wday</code>\r\n- * For example:\r\n- * <code>15,30 6,19 2,10 1 2 </code>\r\n- * Would run at 15 and 30 past the 6AM and 7PM, on the 2nd and 10th\r\n- * of January when its a Monday.\r\n- *\r\n- * @author Steve Kim\r\n- */\r\n-public class DataCacheScheduler\r\n-    implements Runnable {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (DataCacheScheduler.class);\r\n-\r\n-    private Map _caches = new ConcurrentHashMap();\r\n-    private boolean _stop = false;\r\n-    private int _interval = 2;\r\n-    private Log _log;\r\n-    private Thread _thread;\r\n-\r\n-    public DataCacheScheduler(OpenJPAConfiguration conf) {\r\n-        _log = conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n-    }\r\n-\r\n-    /**\r\n-     * The interval time in minutes between cache checks. Defaults to 2.\r\n-     */\r\n-    public int getInterval() {\r\n-        return _interval;\r\n-    }\r\n-\r\n-    /**\r\n-     * The interval time in minutes between cache checks. Defaults to 2.\r\n-     */\r\n-    public void setInterval(int interval) {\r\n-        _interval = interval;\r\n-    }\r\n-\r\n-    /**\r\n-     * Stop the associated thread if there and stop the current runnable.\r\n-     */\r\n-    public synchronized void stop() {\r\n-        _stop = true;\r\n-    }\r\n-\r\n-    private boolean isStopped() {\r\n-        return _stop;\r\n-    }\r\n-\r\n-    /**\r\n-     * Schedule the given cache for eviction. Starts the scheduling thread\r\n-     * if not started.\r\n-     */\r\n-    public synchronized void scheduleEviction(DataCache cache, String times) {\r\n-        if (times == null)\r\n-            return;\r\n-\r\n-        Schedule schedule = new Schedule(times);\r\n-        _caches.put(cache, schedule);\r\n-        _stop = false;\r\n-        if (_thread == null) {\r\n-            _thread =\r\n-                AccessController.doPrivileged(J2DoPrivHelper\r\n-                    .newDaemonThreadAction(this, _loc.get(\"scheduler-name\")\r\n-                        .getMessage()));\r\n-            _thread.start();\r\n-            if (_log.isTraceEnabled())\r\n-                _log.trace(_loc.get(\"scheduler-start\", _thread.getName()));\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove the given cache from scheduling.\r\n-     */\r\n-    public synchronized void removeFromSchedule(DataCache cache) {\r\n-        _caches.remove(cache);\r\n-        if (_caches.size() == 0)\r\n-            stop();\r\n-    }\r\n-\r\n-    public void run() {\r\n-        if (_log.isTraceEnabled())\r\n-            _log.trace(_loc.get(\"scheduler-interval\", _interval + \"\"));\r\n-\r\n-        Date lastRun = new Date();\r\n-        DateFormat fom = new SimpleDateFormat(\"E HH:mm:ss\");\r\n-        while (!isStopped()) {\r\n-            try {\r\n-                Thread.sleep(_interval * 60 * 1000);\r\n-\r\n-                Date now = new Date();\r\n-                DataCache cache;\r\n-                Schedule schedule;\r\n-                Map.Entry entry;\r\n-                for (Iterator i = _caches.entrySet().iterator(); i.hasNext();) {\r\n-                    entry = (Map.Entry) i.next();\r\n-                    cache = (DataCache) entry.getKey();\r\n-                    schedule = (Schedule) entry.getValue();\r\n-                    if (schedule.matches(lastRun, now)) {\r\n-                        if (_log.isTraceEnabled())\r\n-                            _log.trace(_loc.get(\"scheduler-clear\",\r\n-                                cache.getName(), fom.format(now)));\r\n-                        evict(cache);\r\n-                    }\r\n-                }\r\n-                lastRun = now;\r\n-            } catch (Exception e) {\r\n-                throw new InvalidStateException(_loc.get(\"scheduler-fail\"), e).\r\n-                    setFatal(true);\r\n-            }\r\n-        }\r\n-\r\n-        _log.info(_loc.get(\"scheduler-stop\"));\r\n-        synchronized (this) {\r\n-            if (isStopped())\r\n-                _thread = null; // be sure to deref the thread so it can restart\r\n-        }\r\n-    }\r\n-\r\n-    protected void evict(DataCache cache) {\r\n-        cache.clear();\r\n-    }\r\n-\r\n-    /**\r\n-     * Simple class which represents the given time schedule.\r\n-     */\r\n-    private static class Schedule {\r\n-\r\n-        static final int[] WILDCARD = new int[0];\r\n-        static final int[] UNITS = {\r\n-            Calendar.MONTH,\r\n-            Calendar.DAY_OF_MONTH,\r\n-            Calendar.DAY_OF_WEEK,\r\n-            Calendar.HOUR_OF_DAY,\r\n-            Calendar.MINUTE\r\n-        };\r\n-        final int[] month;\r\n-        final int[] dayOfMonth;\r\n-        final int[] dayOfWeek;\r\n-        final int[] hour;\r\n-        final int[] min;\r\n-\r\n-        public Schedule(String date) {\r\n-            StringTokenizer token = new StringTokenizer(date, \" \\t\");\r\n-            if (token.countTokens() != 5)\r\n-                throw new UserException(_loc.get(\"bad-count\", date)).\r\n-                    setFatal(true);\r\n-            try {\r\n-                min = parse(token.nextToken(), 0, 60);\r\n-                hour = parse(token.nextToken(), 0, 24);\r\n-                dayOfMonth = parse(token.nextToken(), 1, 31);\r\n-                month = parse(token.nextToken(), 1, 13);\r\n-                dayOfWeek = parse(token.nextToken(), 1, 8);\r\n-            } catch (Throwable t) {\r\n-                throw new UserException(_loc.get(\"bad-schedule\", date), t).\r\n-                    setFatal(true);\r\n-            }\r\n-        }\r\n-\r\n-        private int[] parse(String token, int min, int max) {\r\n-            if (\"*\".equals(token.trim()))\r\n-                return WILDCARD;\r\n-            String[] tokens = Strings.split(token, \",\", 0);\r\n-            int [] times = new int[tokens.length];\r\n-            for (int i = 0; i < tokens.length; i++) {\r\n-                try {\r\n-                    times[i] = Integer.parseInt(tokens[i]);\r\n-                } catch (Throwable t) {\r\n-                    throw new UserException(_loc.get(\"not-number\", token)).\r\n-                        setFatal(true);\r\n-                }\r\n-                if (times[i] < min || times[i] >= max)\r\n-                    throw new UserException(_loc.get(\"not-range\", token,\r\n-                        String.valueOf(min), String.valueOf(max))).\r\n-                        setFatal(true);\r\n-            }\r\n-            return times;\r\n-        }\r\n-\r\n-        boolean matches(Date last, Date now) {\r\n-            Calendar time = Calendar.getInstance();\r\n-            time.setTime(now);\r\n-            time.set(Calendar.SECOND, 0);\r\n-            time.set(Calendar.MILLISECOND, 0);\r\n-\r\n-            int[][] all =\r\n-                new int[][]{ month, dayOfMonth, dayOfWeek, hour, min };\r\n-            return matches(last, now, time, all, 0);\r\n-        }\r\n-\r\n-        private boolean matches(Date last, Date now, Calendar time,\r\n-            int[][] times, int depth) {\r\n-            if (depth == UNITS.length) {\r\n-                Date compare = time.getTime();\r\n-                return compare.compareTo(last) >= 0 &&\r\n-                    compare.compareTo(now) < 0;\r\n-            }\r\n-\r\n-            if (times[depth] != WILDCARD) {\r\n-                for (int i = 0; i < times[depth].length; i++) {\r\n-                    time.set(UNITS[depth], times[depth][i]);\r\n-                    if (matches(last, now, time, times, depth + 1))\r\n-                        return true;\r\n-                }\r\n-            }\r\n-            return matches(last, now, time, times, depth + 1);\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.security.AccessController;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.StringTokenizer;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n+import org.apache.openjpa.lib.util.Localizer;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.openjpa.util.InvalidStateException;\n+import org.apache.openjpa.util.UserException;\n+import serp.util.Strings;\n+\n+/**\n+ * Cron-style cache eviction. Understands schedules based on cron format:\n+ * <code>minute hour mday month wday</code>\n+ * For example:\n+ * <code>15,30 6,19 2,10 1 2 </code>\n+ * Would run at 15 and 30 past the 6AM and 7PM, on the 2nd and 10th\n+ * of January when its a Monday.\n+ *\n+ * @author Steve Kim\n+ */\n+public class DataCacheScheduler\n+    implements Runnable {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (DataCacheScheduler.class);\n+\n+    private Map _caches = new ConcurrentHashMap();\n+    private boolean _stop = false;\n+    private int _interval = 2;\n+    private Log _log;\n+    private Thread _thread;\n+\n+    public DataCacheScheduler(OpenJPAConfiguration conf) {\n+        _log = conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_DATACACHE);\n+    }\n+\n+    /**\n+     * The interval time in minutes between cache checks. Defaults to 2.\n+     */\n+    public int getInterval() {\n+        return _interval;\n+    }\n+\n+    /**\n+     * The interval time in minutes between cache checks. Defaults to 2.\n+     */\n+    public void setInterval(int interval) {\n+        _interval = interval;\n+    }\n+\n+    /**\n+     * Stop the associated thread if there and stop the current runnable.\n+     */\n+    public synchronized void stop() {\n+        _stop = true;\n+    }\n+\n+    private boolean isStopped() {\n+        return _stop;\n+    }\n+\n+    /**\n+     * Schedule the given cache for eviction. Starts the scheduling thread\n+     * if not started.\n+     */\n+    public synchronized void scheduleEviction(DataCache cache, String times) {\n+        if (times == null)\n+            return;\n+\n+        Schedule schedule = new Schedule(times);\n+        _caches.put(cache, schedule);\n+        _stop = false;\n+        if (_thread == null) {\n+            _thread =\n+                AccessController.doPrivileged(J2DoPrivHelper\n+                    .newDaemonThreadAction(this, _loc.get(\"scheduler-name\")\n+                        .getMessage()));\n+            _thread.start();\n+            if (_log.isTraceEnabled())\n+                _log.trace(_loc.get(\"scheduler-start\", _thread.getName()));\n+        }\n+    }\n+\n+    /**\n+     * Remove the given cache from scheduling.\n+     */\n+    public synchronized void removeFromSchedule(DataCache cache) {\n+        _caches.remove(cache);\n+        if (_caches.size() == 0)\n+            stop();\n+    }\n+\n+    public void run() {\n+        if (_log.isTraceEnabled())\n+            _log.trace(_loc.get(\"scheduler-interval\", _interval + \"\"));\n+\n+        Date lastRun = new Date();\n+        DateFormat fom = new SimpleDateFormat(\"E HH:mm:ss\");\n+        while (!isStopped()) {\n+            try {\n+                Thread.sleep(_interval * 60 * 1000);\n+\n+                Date now = new Date();\n+                DataCache cache;\n+                Schedule schedule;\n+                Map.Entry entry;\n+                for (Iterator i = _caches.entrySet().iterator(); i.hasNext();) {\n+                    entry = (Map.Entry) i.next();\n+                    cache = (DataCache) entry.getKey();\n+                    schedule = (Schedule) entry.getValue();\n+                    if (schedule.matches(lastRun, now)) {\n+                        if (_log.isTraceEnabled())\n+                            _log.trace(_loc.get(\"scheduler-clear\",\n+                                cache.getName(), fom.format(now)));\n+                        evict(cache);\n+                    }\n+                }\n+                lastRun = now;\n+            } catch (Exception e) {\n+                throw new InvalidStateException(_loc.get(\"scheduler-fail\"), e).\n+                    setFatal(true);\n+            }\n+        }\n+\n+        _log.info(_loc.get(\"scheduler-stop\"));\n+        synchronized (this) {\n+            if (isStopped())\n+                _thread = null; // be sure to deref the thread so it can restart\n+        }\n+    }\n+\n+    protected void evict(DataCache cache) {\n+        cache.clear();\n+    }\n+\n+    /**\n+     * Simple class which represents the given time schedule.\n+     */\n+    private static class Schedule {\n+\n+        static final int[] WILDCARD = new int[0];\n+        static final int[] UNITS = {\n+            Calendar.MONTH,\n+            Calendar.DAY_OF_MONTH,\n+            Calendar.DAY_OF_WEEK,\n+            Calendar.HOUR_OF_DAY,\n+            Calendar.MINUTE\n+        };\n+        final int[] month;\n+        final int[] dayOfMonth;\n+        final int[] dayOfWeek;\n+        final int[] hour;\n+        final int[] min;\n+\n+        public Schedule(String date) {\n+            StringTokenizer token = new StringTokenizer(date, \" \\t\");\n+            if (token.countTokens() != 5)\n+                throw new UserException(_loc.get(\"bad-count\", date)).\n+                    setFatal(true);\n+            try {\n+                min = parse(token.nextToken(), 0, 60);\n+                hour = parse(token.nextToken(), 0, 24);\n+                dayOfMonth = parse(token.nextToken(), 1, 31);\n+                month = parse(token.nextToken(), 1, 13);\n+                dayOfWeek = parse(token.nextToken(), 1, 8);\n+            } catch (Throwable t) {\n+                throw new UserException(_loc.get(\"bad-schedule\", date), t).\n+                    setFatal(true);\n+            }\n+        }\n+\n+        private int[] parse(String token, int min, int max) {\n+            if (\"*\".equals(token.trim()))\n+                return WILDCARD;\n+            String[] tokens = Strings.split(token, \",\", 0);\n+            int [] times = new int[tokens.length];\n+            for (int i = 0; i < tokens.length; i++) {\n+                try {\n+                    times[i] = Integer.parseInt(tokens[i]);\n+                } catch (Throwable t) {\n+                    throw new UserException(_loc.get(\"not-number\", token)).\n+                        setFatal(true);\n+                }\n+                if (times[i] < min || times[i] >= max)\n+                    throw new UserException(_loc.get(\"not-range\", token,\n+                        String.valueOf(min), String.valueOf(max))).\n+                        setFatal(true);\n+            }\n+            return times;\n+        }\n+\n+        boolean matches(Date last, Date now) {\n+            Calendar time = Calendar.getInstance();\n+            time.setTime(now);\n+            time.set(Calendar.SECOND, 0);\n+            time.set(Calendar.MILLISECOND, 0);\n+\n+            int[][] all =\n+                new int[][]{ month, dayOfMonth, dayOfWeek, hour, min };\n+            return matches(last, now, time, all, 0);\n+        }\n+\n+        private boolean matches(Date last, Date now, Calendar time,\n+            int[][] times, int depth) {\n+            if (depth == UNITS.length) {\n+                Date compare = time.getTime();\n+                return compare.compareTo(last) >= 0 &&\n+                    compare.compareTo(now) < 0;\n+            }\n+\n+            if (times[depth] != WILDCARD) {\n+                for (int i = 0; i < times[depth].length; i++) {\n+                    time.set(UNITS[depth], times[depth][i]);\n+                    if (matches(last, now, time, times, depth + 1))\n+                        return true;\n+                }\n+            }\n+            return matches(last, now, time, times, depth + 1);\n+\t\t}\n+\t}\n+}"},{"sha":"18ab1227c2e90b60a333252b5bf31284192eb027","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","status":"modified","additions":701,"deletions":701,"changes":1402,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,701 +1,701 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.io.Serializable;\r\n-import java.util.AbstractList;\r\n-import java.util.ArrayList;\r\n-import java.util.BitSet;\r\n-import java.util.Collections;\r\n-import java.util.Date;\r\n-import java.util.List;\r\n-import java.util.Locale;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-import java.util.TreeMap;\r\n-\r\n-import org.apache.commons.collections.map.LinkedMap;\r\n-import org.apache.openjpa.datacache.AbstractQueryCache.EvictPolicy;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.LockLevels;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.QueryContext;\r\n-import org.apache.openjpa.kernel.StoreContext;\r\n-import org.apache.openjpa.kernel.StoreQuery;\r\n-import org.apache.openjpa.kernel.exps.AggregateListener;\r\n-import org.apache.openjpa.kernel.exps.FilterListener;\r\n-import org.apache.openjpa.lib.rop.ListResultObjectProvider;\r\n-import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.util.ObjectNotFoundException;\r\n-\r\n-import serp.util.Numbers;\r\n-\r\n-/**\r\n- * A {@link StoreQuery} implementation that caches the OIDs involved in\r\n- * the query, and can determine whether or not the query has been dirtied.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @since 0.2.5.0\r\n- */\r\n-public class QueryCacheStoreQuery\r\n-    implements StoreQuery {\r\n-\r\n-    private final StoreQuery _query;\r\n-    private final QueryCache _cache;\r\n-    private StoreContext _sctx;\r\n-    private MetaDataRepository _repos;\r\n-\r\n-    /**\r\n-     * Create a new instance that delegates to <code>query</code> if no\r\n-     * cached results are available.\r\n-     */\r\n-    public QueryCacheStoreQuery(StoreQuery query, QueryCache cache) {\r\n-        _query = query;\r\n-        _cache = cache;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the {@link QueryCache} that this object is associated with.\r\n-     */\r\n-    public QueryCache getCache() {\r\n-        return _cache;\r\n-    }\r\n-\r\n-    /**\r\n-     * Delegate.\r\n-     */\r\n-    public StoreQuery getDelegate() {\r\n-        return _query;\r\n-    }\r\n-\r\n-    /**\r\n-     * Look in the query cache for a result for the given query\r\n-     * key. Only look if this query is being executed outside a\r\n-     * transaction or in a transaction with IgnoreChanges set to true\r\n-     * or in a transaction with IgnoreChanges set to false but in which\r\n-     * none of the classes involved in this query have been touched.\r\n-     *  Caching is not used when using object locking.\r\n-     * This is because we must obtain locks on the\r\n-     * data, and it is likely that making n trips to the database to\r\n-     * make the locks will be slower than running the query against\r\n-     * the database.\r\n-     *  If the fetch configuration has query caching disabled,\r\n-     * then this method returns <code>null</code>.\r\n-     *  Return the list if we meet the above criteria and if a list\r\n-     * is found for <code>qk</code>. Else, return\r\n-     * <code>null</code>.\r\n-     *  This implementation means that queries against the cache\r\n-     * are of READ_COMMITTED isolation level. It'd be nice to support\r\n-     * READ_SERIALIZABLE -- to do so, we'd just return false when in\r\n-     * a transaction.\r\n-     */\r\n-    private List checkCache(QueryKey qk) {\r\n-        if (qk == null)\r\n-            return null;\r\n-        FetchConfiguration fetch = getContext().getFetchConfiguration();\r\n-        if (!fetch.getQueryCacheEnabled())\r\n-            return null;\r\n-        if (fetch.getReadLockLevel() > LockLevels.LOCK_NONE)\r\n-            return null;\r\n-\r\n-        // get the cached data\r\n-        QueryResult res = _cache.get(qk);\r\n-        if (res == null)\r\n-            return null;        \r\n-        if (res.isEmpty())\r\n-            return Collections.EMPTY_LIST;\r\n-\r\n-        // this if block is invoked if the evictOnTimestamp is set to true\r\n-        if (_cache instanceof AbstractQueryCache) {\r\n-            AbstractQueryCache qcache = (AbstractQueryCache) _cache;\r\n-            if (qcache.getEvictPolicy() == EvictPolicy.TIMESTAMP) {\r\n-                Set<String> classNames = qk.getAcessPathClassNames();\r\n-                List<String> keyList = new ArrayList<String>();      \r\n-                keyList.addAll(classNames);\r\n-\r\n-                List<Long> timestamps = \r\n-                    qcache.getAllEntityTimestamp(keyList);\r\n-                long queryTS = res.getTimestamp();\r\n-                if (timestamps != null) {\r\n-                    for (Long ts: timestamps) {\r\n-                        // if this is true we have to evict the query \r\n-                        // from cache\r\n-                        if (queryTS < ts) { \r\n-                            qcache.remove(qk);\r\n-                            return null;\r\n-                        }\r\n-                    }\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        int projs = getContext().getProjectionAliases().length;\r\n-        if (projs == 0) {\r\n-            // make sure the data cache contains the oids for the query result;\r\n-            // if it doesn't, then using the result could be slower than not\r\n-            // using it because of the individual by-oid lookups\r\n-            ClassMetaData meta = _repos.getMetaData(getContext().\r\n-                getCandidateType(), _sctx.getClassLoader(), true);\r\n-            if (meta.getDataCache() == null)\r\n-                return null;\r\n-\r\n-            BitSet idxs = meta.getDataCache().containsAll(res);\r\n-\r\n-            // eventually we should optimize this to figure out how many objects\r\n-            // the cache is missing and if only a few do a bulk fetch for them\r\n-            int len = idxs.length();\r\n-            if (len < res.size())\r\n-                return null;\r\n-            for (int i = 0; i < len; i++)\r\n-                if (!idxs.get(i))\r\n-                    return null;\r\n-        }\r\n-        return new CachedList(res, projs != 0, _sctx);\r\n-    }\r\n-\r\n-    /**\r\n-     * Wrap the result object provider returned by our delegate in a\r\n-     * caching provider.\r\n-     */\r\n-    private ResultObjectProvider wrapResult(ResultObjectProvider rop,\r\n-        QueryKey key) {\r\n-        if (key == null)\r\n-            return rop;\r\n-        return new CachingResultObjectProvider(rop, getContext().\r\n-            getProjectionAliases().length > 0, key);\r\n-    }\r\n-\r\n-    /**\r\n-     * Copy a projection element for caching / returning.\r\n-     */\r\n-    private static Object copyProjection(Object obj, StoreContext ctx) {\r\n-        if (obj == null)\r\n-            return null;\r\n-        switch (JavaTypes.getTypeCode(obj.getClass())) {\r\n-            case JavaTypes.STRING:\r\n-            case JavaTypes.BOOLEAN_OBJ:\r\n-            case JavaTypes.BYTE_OBJ:\r\n-            case JavaTypes.CHAR_OBJ:\r\n-            case JavaTypes.DOUBLE_OBJ:\r\n-            case JavaTypes.FLOAT_OBJ:\r\n-            case JavaTypes.INT_OBJ:\r\n-            case JavaTypes.LONG_OBJ:\r\n-            case JavaTypes.SHORT_OBJ:\r\n-            case JavaTypes.BIGDECIMAL:\r\n-            case JavaTypes.BIGINTEGER:\r\n-            case JavaTypes.OID:\r\n-                return obj;\r\n-            case JavaTypes.DATE:\r\n-                return ((Date) obj).clone();\r\n-            case JavaTypes.LOCALE:\r\n-                return ((Locale) obj).clone();\r\n-            default:\r\n-                if (obj instanceof CachedObjectId)\r\n-                    return fromObjectId(((CachedObjectId) obj).oid, ctx);\r\n-                Object oid = ctx.getObjectId(obj);\r\n-                if (oid != null)\r\n-                    return new CachedObjectId(oid);\r\n-                return obj;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the result object based on its cached oid.\r\n-     */\r\n-    private static Object fromObjectId(Object oid, StoreContext sctx) {\r\n-        if (oid == null)\r\n-            return null;\r\n-\r\n-        Object obj = sctx.find(oid, null, null, null, 0);\r\n-        if (obj == null)\r\n-            throw new ObjectNotFoundException(oid);\r\n-        return obj;\r\n-    }\r\n-\r\n-    public Object writeReplace()\r\n-        throws ObjectStreamException {\r\n-        return _query;\r\n-    }\r\n-\r\n-    public QueryContext getContext() {\r\n-        return _query.getContext();\r\n-    }\r\n-\r\n-    public void setContext(QueryContext qctx) {\r\n-        _query.setContext(qctx);\r\n-        _sctx = qctx.getStoreContext();\r\n-        _repos = _sctx.getConfiguration().getMetaDataRepositoryInstance();\r\n-    }\r\n-\r\n-    public boolean setQuery(Object query) {\r\n-        return _query.setQuery(query);\r\n-    }\r\n-\r\n-    public FilterListener getFilterListener(String tag) {\r\n-        return _query.getFilterListener(tag);\r\n-    }\r\n-\r\n-    public AggregateListener getAggregateListener(String tag) {\r\n-        return _query.getAggregateListener(tag);\r\n-    }\r\n-\r\n-    public Object newCompilationKey() {\r\n-        return _query.newCompilationKey();\r\n-    }\r\n-\r\n-    public Object newCompilation() {\r\n-        return _query.newCompilation();\r\n-    }\r\n-\r\n-    public void populateFromCompilation(Object comp) {\r\n-        _query.populateFromCompilation(comp);\r\n-    }\r\n-\r\n-    public void invalidateCompilation() {\r\n-        _query.invalidateCompilation();\r\n-    }\r\n-\r\n-    public boolean supportsDataStoreExecution() {\r\n-        return _query.supportsDataStoreExecution();\r\n-    }\r\n-\r\n-    public boolean supportsInMemoryExecution() {\r\n-        return _query.supportsInMemoryExecution();\r\n-    }\r\n-\r\n-    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs) {\r\n-        return _query.newInMemoryExecutor(meta, subs);\r\n-    }\r\n-\r\n-    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\r\n-        Executor ex = _query.newDataStoreExecutor(meta, subs);\r\n-        return new QueryCacheExecutor(ex, meta, subs);\r\n-    }\r\n-\r\n-    public boolean supportsAbstractExecutors() {\r\n-        return _query.supportsAbstractExecutors();\r\n-    }\r\n-\r\n-    public boolean requiresCandidateType() {\r\n-        return _query.requiresCandidateType();\r\n-    }\r\n-\r\n-    public boolean requiresParameterDeclarations() {\r\n-        return _query.requiresParameterDeclarations();\r\n-    }\r\n-\r\n-    public boolean supportsParameterDeclarations() {\r\n-        return _query.supportsParameterDeclarations();\r\n-    }\r\n- \r\n-    public Object evaluate(Object value, Object ob, Object[] params,\r\n-        OpenJPAStateManager sm) {\r\n-        return _query.evaluate(value, ob, params, sm);         \r\n-    }\r\n-\r\n-    /**\r\n-     * Caching executor.\r\n-     */\r\n-    private static class QueryCacheExecutor\r\n-        implements Executor {\r\n-\r\n-        private final Executor _ex;\r\n-        private final Class _candidate;\r\n-        private final boolean _subs;\r\n-\r\n-        public QueryCacheExecutor(Executor ex, ClassMetaData meta,\r\n-            boolean subs) {\r\n-            _ex = ex;\r\n-            _candidate = (meta == null) ? null : meta.getDescribedType();\r\n-            _subs = subs;\r\n-        }\r\n-\r\n-        public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\r\n-            Range range) {\r\n-            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\r\n-            QueryKey key = QueryKey.newInstance(cq.getContext(),\r\n-                _ex.isPacking(q), params, _candidate, _subs, range.start, \r\n-                range.end);\r\n-            List cached = cq.checkCache(key);\r\n-            if (cached != null)\r\n-                return new ListResultObjectProvider(cached);\r\n-\r\n-            ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\r\n-                params, range);\r\n-            return cq.wrapResult(rop, key);\r\n-        }\r\n-\r\n-        /**\r\n-         * Clear the cached queries associated with the access path\r\n-         * classes in the query. This is done when bulk operations\r\n-         * (such as deletes or updates) are performed so that the\r\n-         * cache remains up-to-date.\r\n-         */\r\n-        private void clearAccessPath(StoreQuery q) {\r\n-            if (q == null)\r\n-                return;\r\n-\r\n-            ClassMetaData[] cmd = getAccessPathMetaDatas(q);\r\n-            if (cmd == null || cmd.length == 0)\r\n-                return;\r\n-\r\n-            List classes = new ArrayList(cmd.length);\r\n-            for (int i = 0; i < cmd.length; i++)\r\n-                classes.add(cmd[i].getDescribedType());\r\n-\r\n-            // evict from the query cache\r\n-            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\r\n-            cq.getCache().onTypesChanged(new TypesChangedEvent\r\n-                (q.getContext(), classes));\r\n-\r\n-            // evict from the data cache\r\n-            for (int i = 0; i < cmd.length; i++) {\r\n-                if (cmd[i].getDataCache() != null)\r\n-                    cmd[i].getDataCache().removeAll(\r\n-                        cmd[i].getDescribedType(), true);\r\n-            }\r\n-        }\r\n-\r\n-        public Number executeDelete(StoreQuery q, Object[] params) {\r\n-            try {\r\n-                return _ex.executeDelete(unwrap(q), params);\r\n-            } finally {\r\n-                clearAccessPath(q);\r\n-            }\r\n-        }\r\n-\r\n-        public Number executeUpdate(StoreQuery q, Object[] params) {\r\n-            try {\r\n-                return _ex.executeUpdate(unwrap(q), params);\r\n-            } finally {\r\n-                clearAccessPath(q);\r\n-            }\r\n-        }\r\n-\r\n-        public String[] getDataStoreActions(StoreQuery q, Object[] params,\r\n-            Range range) {\r\n-            return EMPTY_STRINGS;\r\n-        }\r\n-\r\n-        public void validate(StoreQuery q) {\r\n-            _ex.validate(unwrap(q));\r\n-        }\r\n-        \r\n-        public void getRange(StoreQuery q, Object[] params, Range range) {\r\n-            _ex.getRange(q, params, range); \r\n-        }\r\n-\r\n-        public Object getOrderingValue(StoreQuery q, Object[] params,\r\n-            Object resultObject, int orderIndex) {\r\n-            return _ex.getOrderingValue(unwrap(q), params, resultObject,\r\n-                orderIndex);\r\n-        }\r\n-\r\n-        public boolean[] getAscending(StoreQuery q) {\r\n-            return _ex.getAscending(unwrap(q));\r\n-        }\r\n-\r\n-        public boolean isPacking(StoreQuery q) {\r\n-            return _ex.isPacking(unwrap(q));\r\n-        }\r\n-\r\n-        public String getAlias(StoreQuery q) {\r\n-            return _ex.getAlias(unwrap(q));\r\n-        }\r\n-\r\n-        public Class getResultClass(StoreQuery q) {\r\n-            return _ex.getResultClass(unwrap(q));\r\n-        }\r\n-\r\n-        public String[] getProjectionAliases(StoreQuery q) {\r\n-            return _ex.getProjectionAliases(unwrap(q));\r\n-        }\r\n-\r\n-        public Class[] getProjectionTypes(StoreQuery q) {\r\n-            return _ex.getProjectionTypes(unwrap(q));\r\n-        }\r\n-\r\n-        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q) {\r\n-            return _ex.getAccessPathMetaDatas(unwrap(q));\r\n-        }\r\n-\r\n-        public int getOperation(StoreQuery q) {\r\n-            return _ex.getOperation(unwrap(q));\r\n-        }\r\n-\r\n-        public boolean isAggregate(StoreQuery q) {\r\n-            return _ex.isAggregate(unwrap(q));\r\n-        }\r\n-\r\n-        public boolean hasGrouping(StoreQuery q) {\r\n-            return _ex.hasGrouping(unwrap(q));\r\n-        }\r\n-\r\n-        public LinkedMap getParameterTypes(StoreQuery q) {\r\n-            return _ex.getParameterTypes(unwrap(q));\r\n-        }\r\n-        \r\n-        public Object[] toParameterArray(StoreQuery q, Map userParams) {\r\n-            return _ex.toParameterArray(q, userParams);\r\n-        }\r\n-\r\n-        public Map getUpdates(StoreQuery q) {\r\n-            return _ex.getUpdates(unwrap(q));\r\n-        }\r\n-\r\n-        private static StoreQuery unwrap(StoreQuery q) {\r\n-            return ((QueryCacheStoreQuery) q).getDelegate();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Result list implementation for a cached query result. Package-protected\r\n-     * for testing.\r\n-     */\r\n-    public static class CachedList\r\n-        extends AbstractList\r\n-        implements Serializable {\r\n-\r\n-        private final QueryResult _res;\r\n-        private final boolean _proj;\r\n-        private final StoreContext _sctx;\r\n-\r\n-        public CachedList(QueryResult res, boolean proj, StoreContext ctx) {\r\n-            _res = res;\r\n-            _proj = proj;\r\n-            _sctx = ctx;\r\n-        }\r\n-\r\n-        public Object get(int idx) {\r\n-            if (!_proj)\r\n-                return fromObjectId(_res.get(idx), _sctx);\r\n-\r\n-            Object[] cached = (Object[]) _res.get(idx);\r\n-            if (cached == null)\r\n-                return null;\r\n-            Object[] uncached = new Object[cached.length];\r\n-            for (int i = 0; i < cached.length; i++)\r\n-                uncached[i] = copyProjection(cached[i], _sctx);\r\n-            return uncached;\r\n-        }\r\n-\r\n-        public int size() {\r\n-            return _res.size();\r\n-        }\r\n-\r\n-        public Object writeReplace()\r\n-            throws ObjectStreamException {\r\n-            return new ArrayList(this);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * A wrapper around a {@link ResultObjectProvider} that builds up a list of\r\n-     * all the OIDs in this list and registers that list with the\r\n-     * query cache. Abandons monitoring and registering if one of the classes\r\n-     * in the access path is modified while the query results are being loaded.\r\n-     */\r\n-    private class CachingResultObjectProvider\r\n-        implements ResultObjectProvider, TypesChangedListener {\r\n-\r\n-        private final ResultObjectProvider _rop;\r\n-        private final boolean _proj;\r\n-        private final QueryKey _qk;\r\n-        private final TreeMap _data = new TreeMap();\r\n-        private boolean _maintainCache = true;\r\n-        private int _pos = -1;\r\n-\r\n-        // used to determine list size without necessarily calling size(),\r\n-        // which may require a DB trip or return Integer.MAX_VALUE\r\n-        private int _max = -1;\r\n-        private int _size = Integer.MAX_VALUE;\r\n-\r\n-        /**\r\n-         * Constructor. Supply delegate result provider and our query key.\r\n-         */\r\n-        public CachingResultObjectProvider(ResultObjectProvider rop,\r\n-            boolean proj, QueryKey key) {\r\n-            _rop = rop;\r\n-            _proj = proj;\r\n-            _qk = key;\r\n-            _cache.addTypesChangedListener(this);\r\n-        }\r\n-\r\n-        /**\r\n-         * Stop caching.\r\n-         */\r\n-        private void abortCaching() {\r\n-            if (!_maintainCache)\r\n-                return;\r\n-\r\n-            // this can be called via an event from another thread\r\n-            synchronized (this) {\r\n-                // it's important that we set this flag first so that any\r\n-                // subsequent calls to this object are bypassed.\r\n-                _maintainCache = false;\r\n-                _cache.removeTypesChangedListener(this);\r\n-                _data.clear();\r\n-            }\r\n-        }\r\n-\r\n-        /**\r\n-         * Check whether we've buffered all results, while optionally adding\r\n-         * the given result.\r\n-         */\r\n-        private void checkFinished(Object obj, boolean result) {\r\n-            // this can be called at the same time as abortCaching via\r\n-            // a types changed event\r\n-            boolean finished = false;\r\n-            synchronized (this) {\r\n-                if (_maintainCache) {\r\n-                    if (result) {\r\n-                        Integer index = Numbers.valueOf(_pos);\r\n-                        if (!_data.containsKey(index)) {\r\n-                            Object cached;\r\n-                            if (obj == null)\r\n-                                cached = null;\r\n-                            else if (!_proj)\r\n-                                cached = _sctx.getObjectId(obj);\r\n-                            else {\r\n-                                Object[] arr = (Object[]) obj;\r\n-                                Object[] cp = new Object[arr.length];\r\n-                                for (int i = 0; i < arr.length; i++)\r\n-                                    cp[i] = copyProjection(arr[i], _sctx);\r\n-                                cached = cp;\r\n-                            }\r\n-                            if (cached != null)\r\n-                                _data.put(index, cached);\r\n-                        }\r\n-                    }\r\n-                    finished = _size == _data.size();\r\n-                }\r\n-            }\r\n-\r\n-            if (finished) {\r\n-                // an abortCaching call can sneak in here via onExpire; the\r\n-                // cache is locked during event firings, so the lock here will\r\n-                // wait for it (or will force the next firing to wait)\r\n-                _cache.writeLock();\r\n-                try {\r\n-                    // make sure we didn't abort\r\n-                    if (_maintainCache) {\r\n-                        QueryResult res = null;\r\n-                        synchronized (this) {\r\n-                            res = new QueryResult(_qk, _data.values());\r\n-                            res.setTimestamp(System.currentTimeMillis());\r\n-                        }\r\n-                        _cache.put(_qk, res);\r\n-                        abortCaching();\r\n-                    }\r\n-                }\r\n-                finally {\r\n-                    _cache.writeUnlock();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        public boolean supportsRandomAccess() {\r\n-            return _rop.supportsRandomAccess();\r\n-        }\r\n-\r\n-        public void open()\r\n-            throws Exception {\r\n-            _rop.open();\r\n-        }\r\n-\r\n-        public Object getResultObject()\r\n-            throws Exception {\r\n-            Object obj = _rop.getResultObject();\r\n-            checkFinished(obj, true);\r\n-            return obj;\r\n-        }\r\n-\r\n-        public boolean next()\r\n-            throws Exception {\r\n-            _pos++;\r\n-            boolean next = _rop.next();\r\n-            if (!next && _pos == _max + 1) {\r\n-                _size = _pos;\r\n-                checkFinished(null, false);\r\n-            } else if (next && _pos > _max)\r\n-                _max = _pos;\r\n-            return next;\r\n-        }\r\n-\r\n-        public boolean absolute(int pos)\r\n-            throws Exception {\r\n-            _pos = pos;\r\n-            boolean valid = _rop.absolute(pos);\r\n-            if (!valid && _pos == _max + 1) {\r\n-                _size = _pos;\r\n-                checkFinished(null, false);\r\n-            } else if (valid && _pos > _max)\r\n-                _max = _pos;\r\n-            return valid;\r\n-        }\r\n-\r\n-        public int size()\r\n-            throws Exception {\r\n-            if (_size != Integer.MAX_VALUE)\r\n-                return _size;\r\n-            int size = _rop.size();\r\n-            _size = size;\r\n-            checkFinished(null, false);\r\n-            return size;\r\n-        }\r\n-\r\n-        public void reset()\r\n-            throws Exception {\r\n-            _rop.reset();\r\n-            _pos = -1;\r\n-        }\r\n-\r\n-        public void close()\r\n-            throws Exception {\r\n-            abortCaching();\r\n-            _rop.close();\r\n-        }\r\n-\r\n-        public void handleCheckedException(Exception e) {\r\n-            _rop.handleCheckedException(e);\r\n-        }\r\n-\r\n-        public void onTypesChanged(TypesChangedEvent ev) {\r\n-            if (_qk.changeInvalidatesQuery(ev.getTypes()))\r\n-                abortCaching();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Struct to recognize cached oids.\r\n-     */\r\n-    private static class CachedObjectId {\r\n-\r\n-        public final Object oid;\r\n-\r\n-        public CachedObjectId (Object oid)\r\n-\t\t{\r\n-\t\t\tthis.oid = oid;\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import java.util.AbstractList;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.map.LinkedMap;\n+import org.apache.openjpa.datacache.AbstractQueryCache.EvictPolicy;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.LockLevels;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.QueryContext;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.kernel.exps.AggregateListener;\n+import org.apache.openjpa.kernel.exps.FilterListener;\n+import org.apache.openjpa.lib.rop.ListResultObjectProvider;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.util.ObjectNotFoundException;\n+\n+import serp.util.Numbers;\n+\n+/**\n+ * A {@link StoreQuery} implementation that caches the OIDs involved in\n+ * the query, and can determine whether or not the query has been dirtied.\n+ *\n+ * @author Patrick Linskey\n+ * @since 0.2.5.0\n+ */\n+public class QueryCacheStoreQuery\n+    implements StoreQuery {\n+\n+    private final StoreQuery _query;\n+    private final QueryCache _cache;\n+    private StoreContext _sctx;\n+    private MetaDataRepository _repos;\n+\n+    /**\n+     * Create a new instance that delegates to <code>query</code> if no\n+     * cached results are available.\n+     */\n+    public QueryCacheStoreQuery(StoreQuery query, QueryCache cache) {\n+        _query = query;\n+        _cache = cache;\n+    }\n+\n+    /**\n+     * Return the {@link QueryCache} that this object is associated with.\n+     */\n+    public QueryCache getCache() {\n+        return _cache;\n+    }\n+\n+    /**\n+     * Delegate.\n+     */\n+    public StoreQuery getDelegate() {\n+        return _query;\n+    }\n+\n+    /**\n+     * Look in the query cache for a result for the given query\n+     * key. Only look if this query is being executed outside a\n+     * transaction or in a transaction with IgnoreChanges set to true\n+     * or in a transaction with IgnoreChanges set to false but in which\n+     * none of the classes involved in this query have been touched.\n+     *  Caching is not used when using object locking.\n+     * This is because we must obtain locks on the\n+     * data, and it is likely that making n trips to the database to\n+     * make the locks will be slower than running the query against\n+     * the database.\n+     *  If the fetch configuration has query caching disabled,\n+     * then this method returns <code>null</code>.\n+     *  Return the list if we meet the above criteria and if a list\n+     * is found for <code>qk</code>. Else, return\n+     * <code>null</code>.\n+     *  This implementation means that queries against the cache\n+     * are of READ_COMMITTED isolation level. It'd be nice to support\n+     * READ_SERIALIZABLE -- to do so, we'd just return false when in\n+     * a transaction.\n+     */\n+    private List checkCache(QueryKey qk) {\n+        if (qk == null)\n+            return null;\n+        FetchConfiguration fetch = getContext().getFetchConfiguration();\n+        if (!fetch.getQueryCacheEnabled())\n+            return null;\n+        if (fetch.getReadLockLevel() > LockLevels.LOCK_NONE)\n+            return null;\n+\n+        // get the cached data\n+        QueryResult res = _cache.get(qk);\n+        if (res == null)\n+            return null;        \n+        if (res.isEmpty())\n+            return Collections.EMPTY_LIST;\n+\n+        // this if block is invoked if the evictOnTimestamp is set to true\n+        if (_cache instanceof AbstractQueryCache) {\n+            AbstractQueryCache qcache = (AbstractQueryCache) _cache;\n+            if (qcache.getEvictPolicy() == EvictPolicy.TIMESTAMP) {\n+                Set<String> classNames = qk.getAcessPathClassNames();\n+                List<String> keyList = new ArrayList<String>();      \n+                keyList.addAll(classNames);\n+\n+                List<Long> timestamps = \n+                    qcache.getAllEntityTimestamp(keyList);\n+                long queryTS = res.getTimestamp();\n+                if (timestamps != null) {\n+                    for (Long ts: timestamps) {\n+                        // if this is true we have to evict the query \n+                        // from cache\n+                        if (queryTS < ts) { \n+                            qcache.remove(qk);\n+                            return null;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        int projs = getContext().getProjectionAliases().length;\n+        if (projs == 0) {\n+            // make sure the data cache contains the oids for the query result;\n+            // if it doesn't, then using the result could be slower than not\n+            // using it because of the individual by-oid lookups\n+            ClassMetaData meta = _repos.getMetaData(getContext().\n+                getCandidateType(), _sctx.getClassLoader(), true);\n+            if (meta.getDataCache() == null)\n+                return null;\n+\n+            BitSet idxs = meta.getDataCache().containsAll(res);\n+\n+            // eventually we should optimize this to figure out how many objects\n+            // the cache is missing and if only a few do a bulk fetch for them\n+            int len = idxs.length();\n+            if (len < res.size())\n+                return null;\n+            for (int i = 0; i < len; i++)\n+                if (!idxs.get(i))\n+                    return null;\n+        }\n+        return new CachedList(res, projs != 0, _sctx);\n+    }\n+\n+    /**\n+     * Wrap the result object provider returned by our delegate in a\n+     * caching provider.\n+     */\n+    private ResultObjectProvider wrapResult(ResultObjectProvider rop,\n+        QueryKey key) {\n+        if (key == null)\n+            return rop;\n+        return new CachingResultObjectProvider(rop, getContext().\n+            getProjectionAliases().length > 0, key);\n+    }\n+\n+    /**\n+     * Copy a projection element for caching / returning.\n+     */\n+    private static Object copyProjection(Object obj, StoreContext ctx) {\n+        if (obj == null)\n+            return null;\n+        switch (JavaTypes.getTypeCode(obj.getClass())) {\n+            case JavaTypes.STRING:\n+            case JavaTypes.BOOLEAN_OBJ:\n+            case JavaTypes.BYTE_OBJ:\n+            case JavaTypes.CHAR_OBJ:\n+            case JavaTypes.DOUBLE_OBJ:\n+            case JavaTypes.FLOAT_OBJ:\n+            case JavaTypes.INT_OBJ:\n+            case JavaTypes.LONG_OBJ:\n+            case JavaTypes.SHORT_OBJ:\n+            case JavaTypes.BIGDECIMAL:\n+            case JavaTypes.BIGINTEGER:\n+            case JavaTypes.OID:\n+                return obj;\n+            case JavaTypes.DATE:\n+                return ((Date) obj).clone();\n+            case JavaTypes.LOCALE:\n+                return ((Locale) obj).clone();\n+            default:\n+                if (obj instanceof CachedObjectId)\n+                    return fromObjectId(((CachedObjectId) obj).oid, ctx);\n+                Object oid = ctx.getObjectId(obj);\n+                if (oid != null)\n+                    return new CachedObjectId(oid);\n+                return obj;\n+        }\n+    }\n+\n+    /**\n+     * Return the result object based on its cached oid.\n+     */\n+    private static Object fromObjectId(Object oid, StoreContext sctx) {\n+        if (oid == null)\n+            return null;\n+\n+        Object obj = sctx.find(oid, null, null, null, 0);\n+        if (obj == null)\n+            throw new ObjectNotFoundException(oid);\n+        return obj;\n+    }\n+\n+    public Object writeReplace()\n+        throws ObjectStreamException {\n+        return _query;\n+    }\n+\n+    public QueryContext getContext() {\n+        return _query.getContext();\n+    }\n+\n+    public void setContext(QueryContext qctx) {\n+        _query.setContext(qctx);\n+        _sctx = qctx.getStoreContext();\n+        _repos = _sctx.getConfiguration().getMetaDataRepositoryInstance();\n+    }\n+\n+    public boolean setQuery(Object query) {\n+        return _query.setQuery(query);\n+    }\n+\n+    public FilterListener getFilterListener(String tag) {\n+        return _query.getFilterListener(tag);\n+    }\n+\n+    public AggregateListener getAggregateListener(String tag) {\n+        return _query.getAggregateListener(tag);\n+    }\n+\n+    public Object newCompilationKey() {\n+        return _query.newCompilationKey();\n+    }\n+\n+    public Object newCompilation() {\n+        return _query.newCompilation();\n+    }\n+\n+    public void populateFromCompilation(Object comp) {\n+        _query.populateFromCompilation(comp);\n+    }\n+\n+    public void invalidateCompilation() {\n+        _query.invalidateCompilation();\n+    }\n+\n+    public boolean supportsDataStoreExecution() {\n+        return _query.supportsDataStoreExecution();\n+    }\n+\n+    public boolean supportsInMemoryExecution() {\n+        return _query.supportsInMemoryExecution();\n+    }\n+\n+    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs) {\n+        return _query.newInMemoryExecutor(meta, subs);\n+    }\n+\n+    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\n+        Executor ex = _query.newDataStoreExecutor(meta, subs);\n+        return new QueryCacheExecutor(ex, meta, subs);\n+    }\n+\n+    public boolean supportsAbstractExecutors() {\n+        return _query.supportsAbstractExecutors();\n+    }\n+\n+    public boolean requiresCandidateType() {\n+        return _query.requiresCandidateType();\n+    }\n+\n+    public boolean requiresParameterDeclarations() {\n+        return _query.requiresParameterDeclarations();\n+    }\n+\n+    public boolean supportsParameterDeclarations() {\n+        return _query.supportsParameterDeclarations();\n+    }\n+ \n+    public Object evaluate(Object value, Object ob, Object[] params,\n+        OpenJPAStateManager sm) {\n+        return _query.evaluate(value, ob, params, sm);         \n+    }\n+\n+    /**\n+     * Caching executor.\n+     */\n+    private static class QueryCacheExecutor\n+        implements Executor {\n+\n+        private final Executor _ex;\n+        private final Class _candidate;\n+        private final boolean _subs;\n+\n+        public QueryCacheExecutor(Executor ex, ClassMetaData meta,\n+            boolean subs) {\n+            _ex = ex;\n+            _candidate = (meta == null) ? null : meta.getDescribedType();\n+            _subs = subs;\n+        }\n+\n+        public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\n+            Range range) {\n+            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\n+            QueryKey key = QueryKey.newInstance(cq.getContext(),\n+                _ex.isPacking(q), params, _candidate, _subs, range.start, \n+                range.end);\n+            List cached = cq.checkCache(key);\n+            if (cached != null)\n+                return new ListResultObjectProvider(cached);\n+\n+            ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\n+                params, range);\n+            return cq.wrapResult(rop, key);\n+        }\n+\n+        /**\n+         * Clear the cached queries associated with the access path\n+         * classes in the query. This is done when bulk operations\n+         * (such as deletes or updates) are performed so that the\n+         * cache remains up-to-date.\n+         */\n+        private void clearAccessPath(StoreQuery q) {\n+            if (q == null)\n+                return;\n+\n+            ClassMetaData[] cmd = getAccessPathMetaDatas(q);\n+            if (cmd == null || cmd.length == 0)\n+                return;\n+\n+            List classes = new ArrayList(cmd.length);\n+            for (int i = 0; i < cmd.length; i++)\n+                classes.add(cmd[i].getDescribedType());\n+\n+            // evict from the query cache\n+            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\n+            cq.getCache().onTypesChanged(new TypesChangedEvent\n+                (q.getContext(), classes));\n+\n+            // evict from the data cache\n+            for (int i = 0; i < cmd.length; i++) {\n+                if (cmd[i].getDataCache() != null)\n+                    cmd[i].getDataCache().removeAll(\n+                        cmd[i].getDescribedType(), true);\n+            }\n+        }\n+\n+        public Number executeDelete(StoreQuery q, Object[] params) {\n+            try {\n+                return _ex.executeDelete(unwrap(q), params);\n+            } finally {\n+                clearAccessPath(q);\n+            }\n+        }\n+\n+        public Number executeUpdate(StoreQuery q, Object[] params) {\n+            try {\n+                return _ex.executeUpdate(unwrap(q), params);\n+            } finally {\n+                clearAccessPath(q);\n+            }\n+        }\n+\n+        public String[] getDataStoreActions(StoreQuery q, Object[] params,\n+            Range range) {\n+            return EMPTY_STRINGS;\n+        }\n+\n+        public void validate(StoreQuery q) {\n+            _ex.validate(unwrap(q));\n+        }\n+        \n+        public void getRange(StoreQuery q, Object[] params, Range range) {\n+            _ex.getRange(q, params, range); \n+        }\n+\n+        public Object getOrderingValue(StoreQuery q, Object[] params,\n+            Object resultObject, int orderIndex) {\n+            return _ex.getOrderingValue(unwrap(q), params, resultObject,\n+                orderIndex);\n+        }\n+\n+        public boolean[] getAscending(StoreQuery q) {\n+            return _ex.getAscending(unwrap(q));\n+        }\n+\n+        public boolean isPacking(StoreQuery q) {\n+            return _ex.isPacking(unwrap(q));\n+        }\n+\n+        public String getAlias(StoreQuery q) {\n+            return _ex.getAlias(unwrap(q));\n+        }\n+\n+        public Class getResultClass(StoreQuery q) {\n+            return _ex.getResultClass(unwrap(q));\n+        }\n+\n+        public String[] getProjectionAliases(StoreQuery q) {\n+            return _ex.getProjectionAliases(unwrap(q));\n+        }\n+\n+        public Class[] getProjectionTypes(StoreQuery q) {\n+            return _ex.getProjectionTypes(unwrap(q));\n+        }\n+\n+        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q) {\n+            return _ex.getAccessPathMetaDatas(unwrap(q));\n+        }\n+\n+        public int getOperation(StoreQuery q) {\n+            return _ex.getOperation(unwrap(q));\n+        }\n+\n+        public boolean isAggregate(StoreQuery q) {\n+            return _ex.isAggregate(unwrap(q));\n+        }\n+\n+        public boolean hasGrouping(StoreQuery q) {\n+            return _ex.hasGrouping(unwrap(q));\n+        }\n+\n+        public LinkedMap getParameterTypes(StoreQuery q) {\n+            return _ex.getParameterTypes(unwrap(q));\n+        }\n+        \n+        public Object[] toParameterArray(StoreQuery q, Map userParams) {\n+            return _ex.toParameterArray(q, userParams);\n+        }\n+\n+        public Map getUpdates(StoreQuery q) {\n+            return _ex.getUpdates(unwrap(q));\n+        }\n+\n+        private static StoreQuery unwrap(StoreQuery q) {\n+            return ((QueryCacheStoreQuery) q).getDelegate();\n+        }\n+    }\n+\n+    /**\n+     * Result list implementation for a cached query result. Package-protected\n+     * for testing.\n+     */\n+    public static class CachedList\n+        extends AbstractList\n+        implements Serializable {\n+\n+        private final QueryResult _res;\n+        private final boolean _proj;\n+        private final StoreContext _sctx;\n+\n+        public CachedList(QueryResult res, boolean proj, StoreContext ctx) {\n+            _res = res;\n+            _proj = proj;\n+            _sctx = ctx;\n+        }\n+\n+        public Object get(int idx) {\n+            if (!_proj)\n+                return fromObjectId(_res.get(idx), _sctx);\n+\n+            Object[] cached = (Object[]) _res.get(idx);\n+            if (cached == null)\n+                return null;\n+            Object[] uncached = new Object[cached.length];\n+            for (int i = 0; i < cached.length; i++)\n+                uncached[i] = copyProjection(cached[i], _sctx);\n+            return uncached;\n+        }\n+\n+        public int size() {\n+            return _res.size();\n+        }\n+\n+        public Object writeReplace()\n+            throws ObjectStreamException {\n+            return new ArrayList(this);\n+        }\n+    }\n+\n+    /**\n+     * A wrapper around a {@link ResultObjectProvider} that builds up a list of\n+     * all the OIDs in this list and registers that list with the\n+     * query cache. Abandons monitoring and registering if one of the classes\n+     * in the access path is modified while the query results are being loaded.\n+     */\n+    private class CachingResultObjectProvider\n+        implements ResultObjectProvider, TypesChangedListener {\n+\n+        private final ResultObjectProvider _rop;\n+        private final boolean _proj;\n+        private final QueryKey _qk;\n+        private final TreeMap _data = new TreeMap();\n+        private boolean _maintainCache = true;\n+        private int _pos = -1;\n+\n+        // used to determine list size without necessarily calling size(),\n+        // which may require a DB trip or return Integer.MAX_VALUE\n+        private int _max = -1;\n+        private int _size = Integer.MAX_VALUE;\n+\n+        /**\n+         * Constructor. Supply delegate result provider and our query key.\n+         */\n+        public CachingResultObjectProvider(ResultObjectProvider rop,\n+            boolean proj, QueryKey key) {\n+            _rop = rop;\n+            _proj = proj;\n+            _qk = key;\n+            _cache.addTypesChangedListener(this);\n+        }\n+\n+        /**\n+         * Stop caching.\n+         */\n+        private void abortCaching() {\n+            if (!_maintainCache)\n+                return;\n+\n+            // this can be called via an event from another thread\n+            synchronized (this) {\n+                // it's important that we set this flag first so that any\n+                // subsequent calls to this object are bypassed.\n+                _maintainCache = false;\n+                _cache.removeTypesChangedListener(this);\n+                _data.clear();\n+            }\n+        }\n+\n+        /**\n+         * Check whether we've buffered all results, while optionally adding\n+         * the given result.\n+         */\n+        private void checkFinished(Object obj, boolean result) {\n+            // this can be called at the same time as abortCaching via\n+            // a types changed event\n+            boolean finished = false;\n+            synchronized (this) {\n+                if (_maintainCache) {\n+                    if (result) {\n+                        Integer index = Numbers.valueOf(_pos);\n+                        if (!_data.containsKey(index)) {\n+                            Object cached;\n+                            if (obj == null)\n+                                cached = null;\n+                            else if (!_proj)\n+                                cached = _sctx.getObjectId(obj);\n+                            else {\n+                                Object[] arr = (Object[]) obj;\n+                                Object[] cp = new Object[arr.length];\n+                                for (int i = 0; i < arr.length; i++)\n+                                    cp[i] = copyProjection(arr[i], _sctx);\n+                                cached = cp;\n+                            }\n+                            if (cached != null)\n+                                _data.put(index, cached);\n+                        }\n+                    }\n+                    finished = _size == _data.size();\n+                }\n+            }\n+\n+            if (finished) {\n+                // an abortCaching call can sneak in here via onExpire; the\n+                // cache is locked during event firings, so the lock here will\n+                // wait for it (or will force the next firing to wait)\n+                _cache.writeLock();\n+                try {\n+                    // make sure we didn't abort\n+                    if (_maintainCache) {\n+                        QueryResult res = null;\n+                        synchronized (this) {\n+                            res = new QueryResult(_qk, _data.values());\n+                            res.setTimestamp(System.currentTimeMillis());\n+                        }\n+                        _cache.put(_qk, res);\n+                        abortCaching();\n+                    }\n+                }\n+                finally {\n+                    _cache.writeUnlock();\n+                }\n+            }\n+        }\n+\n+        public boolean supportsRandomAccess() {\n+            return _rop.supportsRandomAccess();\n+        }\n+\n+        public void open()\n+            throws Exception {\n+            _rop.open();\n+        }\n+\n+        public Object getResultObject()\n+            throws Exception {\n+            Object obj = _rop.getResultObject();\n+            checkFinished(obj, true);\n+            return obj;\n+        }\n+\n+        public boolean next()\n+            throws Exception {\n+            _pos++;\n+            boolean next = _rop.next();\n+            if (!next && _pos == _max + 1) {\n+                _size = _pos;\n+                checkFinished(null, false);\n+            } else if (next && _pos > _max)\n+                _max = _pos;\n+            return next;\n+        }\n+\n+        public boolean absolute(int pos)\n+            throws Exception {\n+            _pos = pos;\n+            boolean valid = _rop.absolute(pos);\n+            if (!valid && _pos == _max + 1) {\n+                _size = _pos;\n+                checkFinished(null, false);\n+            } else if (valid && _pos > _max)\n+                _max = _pos;\n+            return valid;\n+        }\n+\n+        public int size()\n+            throws Exception {\n+            if (_size != Integer.MAX_VALUE)\n+                return _size;\n+            int size = _rop.size();\n+            _size = size;\n+            checkFinished(null, false);\n+            return size;\n+        }\n+\n+        public void reset()\n+            throws Exception {\n+            _rop.reset();\n+            _pos = -1;\n+        }\n+\n+        public void close()\n+            throws Exception {\n+            abortCaching();\n+            _rop.close();\n+        }\n+\n+        public void handleCheckedException(Exception e) {\n+            _rop.handleCheckedException(e);\n+        }\n+\n+        public void onTypesChanged(TypesChangedEvent ev) {\n+            if (_qk.changeInvalidatesQuery(ev.getTypes()))\n+                abortCaching();\n+        }\n+    }\n+\n+    /**\n+     * Struct to recognize cached oids.\n+     */\n+    private static class CachedObjectId {\n+\n+        public final Object oid;\n+\n+        public CachedObjectId (Object oid)\n+\t\t{\n+\t\t\tthis.oid = oid;\n+\t\t}\n+\t}\n+}"},{"sha":"3904232254b3c6af09c6ebad37e46f7795acdc6f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"66fa6057c6af1df883d1dd1b1114f7b6f974c7a4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","status":"modified","additions":151,"deletions":151,"changes":302,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"78614624c6c833d8ecaa23f13903ad1c11a50d5a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"478a056d80c441932c118b637462b7a70b2c8596","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","status":"modified","additions":310,"deletions":310,"changes":620,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"ebdd746c8638de5766fb5d0add78c927b6d4b0fc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"dd95fa2373bcaeb3004ad6b707946bd68f72d661","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","status":"modified","additions":1077,"deletions":1077,"changes":2154,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"454e16efb8ad24e24cc0604eef9b9b250428add6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","status":"modified","additions":288,"deletions":288,"changes":576,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"aef221a3223762557d2d3c570628c63e318767b3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","status":"modified","additions":272,"deletions":272,"changes":544,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"b49ad7e8630bddcb873e2a4747bfb1dcc6d51d94","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","status":"modified","additions":237,"deletions":237,"changes":474,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"1f84068775ccd146f4d1d810e4cc564e195fd9ac","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","status":"modified","additions":387,"deletions":387,"changes":774,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a37b53753593756a5f49f37ab603b0875a6df885","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java","status":"modified","additions":30,"deletions":30,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"41848ae2942c0d72bac8123c2663ba6124caaa31","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","status":"modified","additions":31,"deletions":31,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"4c2ba87e2c6a9ef03124fb598aae0218f6e25e95","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"183e7ebf4084b11e2a3b6588a4bbe9abcccdeb35","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","status":"modified","additions":53,"deletions":53,"changes":106,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"35f129c5d49ba00ddd51f06f3bfb309fe75488a8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","status":"modified","additions":35,"deletions":35,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a0525a0537b3f5e769415a113612e75d39d3d540","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"7af19bb90d32c6ac853a103a4fb374285a9a3383","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"3168a6b6aa71e54c4b4400dfbb1b1a75c2efe179","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","status":"modified","additions":253,"deletions":253,"changes":506,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"b796f26cf675ee1a52718f0b65dcd5c1c88ffb5c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","status":"modified","additions":65,"deletions":65,"changes":130,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"fbc8720f4aa8705e841f6a5d55f18b4daf7ac280","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","status":"modified","additions":948,"deletions":948,"changes":1896,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"b8062348dc244aba3751546c022e54e4afe13b42","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","status":"modified","additions":129,"deletions":129,"changes":258,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a9f24b061c04bc6b2fa11379e73d520eb16548ad","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"d4cebf697b1d953add8b4f41147f211eef1bde88","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"modified","additions":881,"deletions":881,"changes":1762,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"273fdbb3298a45d3e7612364838389310edde60c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","status":"modified","additions":190,"deletions":190,"changes":380,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"016b570a55054e092c4050af6d3de89e9f8451ad","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":4921,"deletions":4921,"changes":9842,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"d854afe843d182b6324cc8a0a12203ca20251050","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","status":"modified","additions":952,"deletions":952,"changes":1904,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"5d300f96c55f2b1f87e9a919b79fb540cd93ea56","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","status":"modified","additions":353,"deletions":353,"changes":706,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"17d30469a0c33e33ef9e8651fc0b1d3875739a27","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FinderCache.java","status":"modified","additions":143,"deletions":143,"changes":286,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FinderCache.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FinderCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FinderCache.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"4caeaa917f0acfb21d0a74eef5db884601580e94","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FinderQuery.java","status":"modified","additions":65,"deletions":65,"changes":130,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FinderQuery.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FinderQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FinderQuery.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a6527f7c91c76763b1754e69e965e0a9fbd73503","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java","status":"modified","additions":309,"deletions":309,"changes":618,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a375341c09660bc88040158af6a6857fb8b499ef","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PreparedQuery.java","status":"modified","additions":110,"deletions":110,"changes":220,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PreparedQuery.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PreparedQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PreparedQuery.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"df0481984bbd5957bc2c5b25d531eacd3c2a5f4b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PreparedQueryCache.java","status":"modified","additions":191,"deletions":191,"changes":382,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PreparedQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PreparedQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PreparedQueryCache.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"de1df6eed7b7667587cb9c26ddb0fa63c9d762e2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","status":"modified","additions":2219,"deletions":2219,"changes":4438,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"2aa7ea90c3e1e832362fda0b6c61617344777911","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryStatistics.java","status":"modified","additions":237,"deletions":237,"changes":474,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryStatistics.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryStatistics.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryStatistics.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"5b5c8e0cf7c38ff351f2a5b5f0524e9e11e52c9c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":3291,"deletions":3291,"changes":6582,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"37354613eba3653b43fc94d656717829e8f8f0c9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","status":"modified","additions":339,"deletions":339,"changes":678,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"22cc0c736135c53610c163baa098d22a3d6ce901","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","status":"modified","additions":388,"deletions":388,"changes":776,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"2ac03497fe2144db0bdb0b31425dd872e5d14db6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","status":"modified","additions":149,"deletions":149,"changes":298,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"b5aa972b4fb87ff1a09254f3aa2ec68300d48be2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","status":"modified","additions":74,"deletions":74,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"55a597610226c591557dba9cd68d6f1f66a83dd2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","status":"modified","additions":75,"deletions":75,"changes":150,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"fa792dae01d7bc3150e80a8453c5b64be88c99a2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","status":"modified","additions":648,"deletions":648,"changes":1296,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"be03e7e3252e6ebf675ba4790d4f76dee5fee9dd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","status":"modified","additions":92,"deletions":92,"changes":184,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a305b59d6e26332ad8faae53fe971f874880d0c6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","status":"modified","additions":326,"deletions":326,"changes":652,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"5f2991981cc80e5c9959c4fe9d4d2362ff69ce89","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","status":"modified","additions":148,"deletions":148,"changes":296,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"28159ed75e61504cb664a820db4fbb8473a7088f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","status":"modified","additions":1664,"deletions":1664,"changes":3328,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"2cd29655ee8bb3f2c404ce82835ceecf12123688","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","status":"modified","additions":115,"deletions":115,"changes":230,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"313833fc527d152fc1c508bdfb1d1723aea19564","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/conf/TestSpecification.java","status":"modified","additions":72,"deletions":72,"changes":144,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/test/java/org/apache/openjpa/conf/TestSpecification.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/test/java/org/apache/openjpa/conf/TestSpecification.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/conf/TestSpecification.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"f60c8ca8fc296ca72a8d49f3f5de3106e4524987","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"ce0958229f1aec56780e61974d3e32f908c1d0dd","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","status":"modified","additions":93,"deletions":93,"changes":186,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"2237cde18e6ccb4fdf2a66b61154985473d41b92","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java","status":"modified","additions":31,"deletions":31,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"eb8f78a3b557ae31d3954fda5bf242b6a71615c0","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java","status":"modified","additions":62,"deletions":62,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"bb57a0f66178f9dcbfd768166aba4aba83a49224","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"3e8c880bcdd7d00d814d2aa6792c16083dc136f8","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","status":"modified","additions":739,"deletions":739,"changes":1478,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"209b58523aa098cb72d3de09d40bf1e8e146e0a9","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","status":"modified","additions":138,"deletions":138,"changes":276,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"e40e160910ef01d40326a0b10f353465a76c7eb5","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","status":"modified","additions":145,"deletions":145,"changes":290,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"f1f5001cf0da8c0c7d9a01cd62bb96df94a7f054","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","status":"modified","additions":358,"deletions":358,"changes":716,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"aa57109b62f5fcfde616c78983d9928b955271b3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","status":"modified","additions":222,"deletions":222,"changes":444,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"77f9d74ead100310ffe8136d3f3039c8b5b5d95f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","status":"modified","additions":202,"deletions":202,"changes":404,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"b9c67ff6daef47f8283e81ae68d4682c458c69ca","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","status":"modified","additions":47,"deletions":47,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"9ece659a36b83abf2776a321fac1b2178f77d51d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","status":"modified","additions":35,"deletions":35,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"e030117c636d7b5c1f19eb3842e5769710dc9c97","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","status":"modified","additions":103,"deletions":103,"changes":206,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"6f3b4e03facbf8a58630a4147c9e9ea6792e37dd","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","status":"modified","additions":773,"deletions":773,"changes":1546,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"468eb1808b8ed6d47a4571935528806ad4bab7b3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","status":"modified","additions":296,"deletions":296,"changes":592,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"8f4f4072b3619e107ecb11ca7349e2bcbc586488","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","status":"modified","additions":51,"deletions":51,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"8b56b79b8303591c5a382c03ddef5abd77797884","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","status":"modified","additions":371,"deletions":371,"changes":742,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"e336f35226ddcb2f0ce6956f63098cc5a540ec4c","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","status":"modified","additions":192,"deletions":192,"changes":384,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"9eebc566c3e3ad02e0a90637e22163f10eda369b","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","status":"modified","additions":167,"deletions":167,"changes":334,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a7a59172fc38321906b570df785e1c5c42a6abc5","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","status":"modified","additions":302,"deletions":302,"changes":604,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"e7c0b5b87519a9155c62ce7446f6e78f6b026052","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Reflectable.java","status":"modified","additions":25,"deletions":25,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Reflectable.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Reflectable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Reflectable.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"96dfd32f5775291b461256dda8a6e040de456d1f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java","status":"modified","additions":61,"deletions":61,"changes":122,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"e5dadba9ad3c167c40956e52b231945d82e484c5","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","status":"modified","additions":416,"deletions":416,"changes":832,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"c001a4cf0bafd1740024602aeaed921d999ab751","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","status":"modified","additions":128,"deletions":128,"changes":256,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"fcea58dd616124f857324a3784039d3b59f9c6fd","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java","status":"modified","additions":63,"deletions":63,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"e06648dc6642844a5e502df682eb7213b41f2abc","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java","status":"modified","additions":109,"deletions":109,"changes":218,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"1df285153bb30953b5a7799b6be28fdd79b236bb","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","status":"modified","additions":152,"deletions":152,"changes":304,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"3b21530ffeb82b4c131a042d4b88c688da26bc08","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","status":"modified","additions":148,"deletions":148,"changes":296,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"49a389f0b97f54634eba55fb5023a18f5c47f72e","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","status":"modified","additions":1115,"deletions":1115,"changes":2230,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"bfb6538f3d8c2517b0663ab7572f2292ed3a82f8","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java","status":"modified","additions":100,"deletions":100,"changes":200,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"6110d8e41c3e69050541117f7e8875b1b8f9e1f1","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","status":"modified","additions":400,"deletions":400,"changes":800,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a39620107e864578a1cdb44e391b902778e5b1ea","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java","status":"modified","additions":179,"deletions":179,"changes":358,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"4f40d52d1443f582cb5c186222e6ed57043d6b7b","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumn.java","status":"modified","additions":54,"deletions":54,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumn.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumn.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"af682fbeb733a71a207594b5c765f63e166fb6aa","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumns.java","status":"modified","additions":39,"deletions":39,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumns.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumns.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumns.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a4c2062c0ff1f2734d41024a68dbf13f4917573c","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementEmbeddedMapping.java","status":"modified","additions":46,"deletions":46,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementEmbeddedMapping.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementEmbeddedMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementEmbeddedMapping.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"9dfb75c97d39d3efca09d6aabfafa01606f364f4","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementStrategy.java","status":"modified","additions":38,"deletions":38,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementStrategy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"8dbf2233247539a53bb698a4e4c04a3bc4c8cf97","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyClassCriteria.java","status":"modified","additions":39,"deletions":39,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyClassCriteria.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyClassCriteria.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyClassCriteria.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"7046272f7a74cb0d4d7054b74a2b1ea2b6c38bcf","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumn.java","status":"modified","additions":54,"deletions":54,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumn.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumn.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"0505c5967fa011c6d963b839ce259a85f9b20701","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumns.java","status":"modified","additions":39,"deletions":39,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumns.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumns.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumns.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"89472aa62ec0d9881eb6f9469e2717a6712659b4","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyEmbeddedMapping.java","status":"modified","additions":45,"deletions":45,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyEmbeddedMapping.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyEmbeddedMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyEmbeddedMapping.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"dfc13a52f052a659d6289067f42942f6b925b775","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyForeignKey.java","status":"modified","additions":46,"deletions":46,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyForeignKey.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyForeignKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyForeignKey.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"20d1709f275fa3c76b490b6f1bd7b31d3ee473d3","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyIndex.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyIndex.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyIndex.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyIndex.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"391b0af45d9c0adb90f687e5a35c3d77bf15d4c5","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumn.java","status":"modified","additions":52,"deletions":52,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumn.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumn.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"8ff0946554d1aaa52033097b0c7fd065e07f1a48","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumns.java","status":"modified","additions":39,"deletions":39,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumns.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumns.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumns.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"05d6fcde0394e991850aff86957ca97dd8d36298","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyNonpolymorphic.java","status":"modified","additions":38,"deletions":38,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyNonpolymorphic.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyNonpolymorphic.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyNonpolymorphic.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"629247b9aff77c6224707c89958ef5b7ab2dc737","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyStrategy.java","status":"modified","additions":38,"deletions":38,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyStrategy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"b7401d43e8f01190208c14e49f73ad378b1ab03d","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XEmbeddedMapping.java","status":"modified","additions":45,"deletions":45,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XEmbeddedMapping.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XEmbeddedMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XEmbeddedMapping.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"b083800e50d1903e8c2ac64fe98e56479854375c","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverride.java","status":"modified","additions":52,"deletions":52,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverride.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverride.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverride.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a439e55c32c88ec5e0ac75a86cfa38a1c8635f20","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverrides.java","status":"modified","additions":37,"deletions":37,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverrides.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverrides.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverrides.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"db8ee9a428f3275ddc1fb258471016c6ca656ab7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestBadJdbcUrl.java","status":"modified","additions":196,"deletions":196,"changes":392,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestBadJdbcUrl.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestBadJdbcUrl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestBadJdbcUrl.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"7e315428ec7a1d6f34010a48ba1b3d2a5e355435","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshaller.java","status":"modified","additions":70,"deletions":70,"changes":140,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshaller.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshaller.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"e8739b1b8e556e93bfecb92913c0ca43e87005b8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshallerEndToEnd.java","status":"modified","additions":171,"deletions":171,"changes":342,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshallerEndToEnd.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshallerEndToEnd.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshallerEndToEnd.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"70a27c401dea8069fd0fcd4117a0a2839e055941","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java","status":"modified","additions":136,"deletions":136,"changes":272,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"364375fe9bd4da5c02c38612927627f6f6bae6b6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestQueryHints.java","status":"modified","additions":168,"deletions":168,"changes":336,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestQueryHints.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestQueryHints.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestQueryHints.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"1bc460fce6cb9ca7c857edc8c8fe12c488db2888","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestSpecificationConfiguration.java","status":"modified","additions":91,"deletions":91,"changes":182,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestSpecificationConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestSpecificationConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestSpecificationConfiguration.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"0b446c0836128120930005157c584cb26f5a2cea","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","status":"modified","additions":609,"deletions":609,"changes":1218,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"c3ab5d217aed21ba58efb48c0555c60f8e5d360b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java","status":"modified","additions":54,"deletions":54,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"4348b23b976d9c8a7f360eb57a57167c8add4f8c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java","status":"modified","additions":44,"deletions":44,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"d9d15442e088098514f94b5ef5341b4cefc8c8df","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementWithMultiplePUs.java","status":"modified","additions":151,"deletions":151,"changes":302,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementWithMultiplePUs.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementWithMultiplePUs.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementWithMultiplePUs.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"44077384fc3daa7e93cb4052d0648cdaf87e143e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java","status":"modified","additions":46,"deletions":46,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"1dd81d1539c1dfc524583f48b273a3eb6b414ca6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java","status":"modified","additions":38,"deletions":38,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"ed60af83394108bd9f2ea9d2d5d700d6c624ee92","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestSimpleUnenhancedQuery.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestSimpleUnenhancedQuery.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestSimpleUnenhancedQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestSimpleUnenhancedQuery.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"36f3949ec4b1728119b9caaee47252435180e149","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","status":"modified","additions":74,"deletions":74,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"866bbc5bee6c06761bd90ff06e72babfc23f3f20","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java","status":"modified","additions":57,"deletions":57,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"1e69bf9170405d7cfe5dcc6cf5bcfdbaf565cc25","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","status":"modified","additions":43,"deletions":43,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"01b3294f53a3e05549e31cc2eb14f66c63943caf","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"116ed5014cb1b3849dc1f84fdbd01b7ae567a5be","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedOneToMany.java","status":"modified","additions":118,"deletions":118,"changes":236,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedOneToMany.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedOneToMany.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedOneToMany.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"638018e5ac44a2effc583b577274faedc43e25dd","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"130d78820ee6cea5e401485d1fcbca1aaef28393","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"287c5e321aa492fe4a9f63e1bf3a9c6c8f107ac9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance2.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance2.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance2.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"33298a5cf356431f08bd4f939007db1f2b045389","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","status":"modified","additions":87,"deletions":87,"changes":174,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"f79a4c9b6e48486661631c90007b1a794cd5cedb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java","status":"modified","additions":34,"deletions":34,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"0b101412e10ad756e28c4daf13e566277a434856","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java","status":"modified","additions":88,"deletions":88,"changes":176,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"03e33912f6de6f6a27ba78fc31a9cd86f2c2b3ca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","status":"modified","additions":122,"deletions":122,"changes":244,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"acfbaa2c3928a3f7646aa6f60d22acb2b42c6c51","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","status":"modified","additions":81,"deletions":81,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"31c009a84689d904afc140ea1f9bb69bf7af8cda","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java","status":"modified","additions":81,"deletions":81,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"d8780d021fbbfe217ff4712a3530da767e9728c9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"ac928a6c7adaf9207f13a4dd18d4cb216a4cdd8e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"1044e0f3c99938d343149dab394caa6080d1362c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"f034ac9ecdc41b73c7312dcfa41c669634e46c03","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedMany.java","status":"modified","additions":69,"deletions":69,"changes":138,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedMany.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedMany.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedMany.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a8bdbcef7fd78109dd7f15c26da2f4cf48158960","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedOne.java","status":"modified","additions":67,"deletions":67,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedOne.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedOne.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedOne.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"027e973a88f738aa871562a7517d5013ede409f7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPObject.java","status":"modified","additions":25,"deletions":25,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPObject.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPObject.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPObject.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"22efc08eed127653ccf7d9f0babf4c140e24a931","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","status":"modified","additions":96,"deletions":96,"changes":192,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"de4cfa30a848eba647d418771a08575506bceac7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"79331c7248bf9c206d7d10f68299054c65a06776","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","status":"modified","additions":31,"deletions":31,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"ef19b8f1ef93b8b12e96c6edee65fcab5c2e1789","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","status":"modified","additions":34,"deletions":34,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"5bca64e0d83fac455829c82d17728c7d79f9c039","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"b44ff2fedb2a7d4cdc7312509682e7c788748b82","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java","status":"modified","additions":32,"deletions":32,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"26f684183541e3b1f98b051f0cd1e291892b2dd5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java","status":"modified","additions":58,"deletions":58,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"d9172f21616f9858b8c256dda7bb474ab54be5ca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java","status":"modified","additions":86,"deletions":86,"changes":172,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"77ed7187289d221aa425477eb377e373002a997d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java","status":"modified","additions":79,"deletions":79,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"0c9f8697b41b87115e18f0e3e912811f2669d46d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","status":"modified","additions":79,"deletions":79,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"36e7328d2d8d100873b8a268e01b1168bf1c1cbe","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","status":"modified","additions":81,"deletions":81,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"7239aace49a18303b4adaa5bcdb79aff82f39258","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","status":"modified","additions":90,"deletions":90,"changes":180,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"7888c89ed91b0bb5857359327b12f619e234650d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityF.java","status":"modified","additions":43,"deletions":43,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityF.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityF.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityF.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"38750bf59d402bb7b830ccffc97511e9a7a1e78c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityG.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityG.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityG.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityG.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"2b24115d765f95ed1c43b45171ec1c5e79c1e9a3","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","status":"modified","additions":211,"deletions":211,"changes":422,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"01cab7f45ec4f508f2aa511549a4ad5b0b26f4a8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/AbstractLobTest.java","status":"modified","additions":286,"deletions":286,"changes":572,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/AbstractLobTest.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/AbstractLobTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/AbstractLobTest.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a546d39478b7fec6d7840911c2e0038552098709","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobEntity.java","status":"modified","additions":58,"deletions":58,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobEntity.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobEntity.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"486f23f1430b174438c8f6afcd7e0f725191a5cc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobTest.java","status":"modified","additions":78,"deletions":78,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobTest.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobTest.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"8cd9dd9a549307a45f53d6cad198bff68f331913","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamWrapper.java","status":"modified","additions":67,"deletions":67,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamWrapper.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"57e983837a2e9da0892947a0459e9e55cd992c4f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/LobEntity.java","status":"modified","additions":37,"deletions":37,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/LobEntity.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/LobEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/LobEntity.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"769b5418b3946911ee424325e091a602cf21da5e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobEntity.java","status":"modified","additions":58,"deletions":58,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobEntity.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobEntity.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"61a9ee6ca4a50ecd7592c85a03ca4cff68d66559","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobTest.java","status":"modified","additions":78,"deletions":78,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobTest.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobTest.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"e77c4bfacffaaae558a995290ebf0734f8ca3b1d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderWrapper.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderWrapper.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"ff3e7a71f7673566c53d9c4ed0b70c6326c91600","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java","status":"modified","additions":445,"deletions":445,"changes":890,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"e5b9204e62c902c39a0262b7fd1f86e4d74f2d81","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java","status":"modified","additions":52,"deletions":52,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"f240d27db0a753ecef0458f3dd56a0579fddf673","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java","status":"modified","additions":54,"deletions":54,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"63dc8813a393366d422650aab0ce1188a5af5fd6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java","status":"modified","additions":76,"deletions":76,"changes":152,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"6fa77b9f1eaa2f5563602aeb4c3d8c6f19cab349","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestDynamicClassRegistration.java","status":"modified","additions":79,"deletions":79,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestDynamicClassRegistration.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestDynamicClassRegistration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestDynamicClassRegistration.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"f71250591c2878f6b02a10c47155f4bcf503f88d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java","status":"modified","additions":51,"deletions":51,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"562ed6a8a38448f1230b85c05ee02c8c9961e04d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java","status":"modified","additions":52,"deletions":52,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"8a17714ecedc2542781768ec80ea8fcb76bd23d5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java","status":"modified","additions":50,"deletions":50,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"0ecf316290b6c9e9dd08f83d16dc5e133896bd48","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"511e32b10d9dde2438dac41c21731553ceabf936","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"710445075eba806c59d80a88d537e917f43fc7b8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"4499cfa0ed296ecd65d3163d531af191d2375f25","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java","status":"modified","additions":57,"deletions":57,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"13bfd29d727cc5c4b537f5c4f2c06fe6af63163d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestAnchorParsing.java","status":"modified","additions":155,"deletions":155,"changes":310,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestAnchorParsing.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestAnchorParsing.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestAnchorParsing.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"3e8ae1e36542abec69c7fdfdf44a4208c23c320a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestEquivalentConfiguration.java","status":"modified","additions":376,"deletions":376,"changes":752,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestEquivalentConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestEquivalentConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestEquivalentConfiguration.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"f6b9a378d1cd0db051afa7bfa5e9567ec445d715","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"6c680f396d953f78380404fb7c53026040fed2a4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java","status":"modified","additions":41,"deletions":41,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"ff573eff5db794e1a128e4f7209978da5c23005b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"8beb7ab736ea24ff0f777abb321cb8a5b19792d2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java","status":"modified","additions":51,"deletions":51,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"08c5920215ae8121adaee83d21602274327d6cdc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java","status":"modified","additions":103,"deletions":103,"changes":206,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"e1c413cf1ca7a42ed395e7f747ca2f6b13e87cca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java","status":"modified","additions":110,"deletions":110,"changes":220,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"6326fb12e05103be11935ee00ac1efd00382db6d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"fe7f17ea3e95b774098448eef593afe8be488e96","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java","status":"modified","additions":78,"deletions":78,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"29ef0d070c99d97ac2707708937f8ecd1bc52111","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java","status":"modified","additions":35,"deletions":35,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"b78fe8d34b60149ceba969d635985fd299593a58","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java","status":"modified","additions":86,"deletions":86,"changes":172,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"d6e520f368fde6001f3501ad8c9d6130b0eed125","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/TestUnwrap.java","status":"modified","additions":68,"deletions":68,"changes":136,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/TestUnwrap.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/TestUnwrap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/TestUnwrap.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"9f39748f856f82b36ec6152fee95f089bb8ed8bf","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/AnnotationTestCase.java","status":"modified","additions":40,"deletions":40,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/AnnotationTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/AnnotationTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/AnnotationTestCase.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"f757ff86a6e1f86f55aa3f6b7173a5059bcb8955","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAdvAnnot.java","status":"modified","additions":133,"deletions":133,"changes":266,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAdvAnnot.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAdvAnnot.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAdvAnnot.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"024f593908da3157525e49ff538b6aa685d020ee","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAnnotationBasics.java","status":"modified","additions":59,"deletions":59,"changes":118,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAnnotationBasics.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAnnotationBasics.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAnnotationBasics.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"41acca647d76dc7bee81b89539bccd93052de9f3","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestDDCallbackMethods.java","status":"modified","additions":265,"deletions":265,"changes":530,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestDDCallbackMethods.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestDDCallbackMethods.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestDDCallbackMethods.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"98b6176f22261466a72ecd7c26e0638e661e34bd","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEJBEmbedded.java","status":"modified","additions":140,"deletions":140,"changes":280,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEJBEmbedded.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEJBEmbedded.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEJBEmbedded.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a373c898c81d2ffbf7bc9b77b72bcca5136ae7af","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddableSuperclass.java","status":"modified","additions":140,"deletions":140,"changes":280,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddableSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddableSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddableSuperclass.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"2f2fd083403c7a6b9e97c2368b6efef062f471e8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddedId.java","status":"modified","additions":264,"deletions":264,"changes":528,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddedId.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddedId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddedId.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"6ee4ae17455a1a8637077e453cd5f638978134ca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityListenerAnnot.java","status":"modified","additions":265,"deletions":265,"changes":530,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityListenerAnnot.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityListenerAnnot.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityListenerAnnot.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"b22458cc6143b5204db1219c6c2e3de0062580d1","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityOrderBy.java","status":"modified","additions":116,"deletions":116,"changes":232,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityOrderBy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityOrderBy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityOrderBy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"0ca620f486359f9370ec7fcf20d94025b51f96bf","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEnumerated.java","status":"modified","additions":115,"deletions":115,"changes":230,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEnumerated.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEnumerated.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEnumerated.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"d8c70b9af7747f39e499c94610b3e0cd52063578","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestFlatInheritance.java","status":"modified","additions":70,"deletions":70,"changes":140,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestFlatInheritance.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestFlatInheritance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestFlatInheritance.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"300e6fbad2264f5e474d8ed30c4aa4cebfb18491","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestGenerators.java","status":"modified","additions":103,"deletions":103,"changes":206,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestGenerators.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestGenerators.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestGenerators.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"0462985119eb9c1b8feb88affb9edb539ee50d44","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestJoinedInheritance.java","status":"modified","additions":81,"deletions":81,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestJoinedInheritance.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestJoinedInheritance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestJoinedInheritance.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"5bad087a25cd38528f6f1e7d2f2124ad01449f2a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestManyToMany.java","status":"modified","additions":123,"deletions":123,"changes":246,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestManyToMany.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestManyToMany.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestManyToMany.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"4f551bfcf01f18d30639d0fae4296b76b8e0c011","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMapKey.java","status":"modified","additions":131,"deletions":131,"changes":262,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMapKey.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMapKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMapKey.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"da99cccd87601bbe32ce39224f3deb0be3ae6ec8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMappedSuperClass.java","status":"modified","additions":174,"deletions":174,"changes":348,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMappedSuperClass.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMappedSuperClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMappedSuperClass.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"13174c1ef0989368bf1cc9918294b0dad57745a8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToMany.java","status":"modified","additions":113,"deletions":113,"changes":226,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToMany.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToMany.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToMany.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"834cca869264f4a3127f2dad70b20a4f4ce58de4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToOne.java","status":"modified","additions":146,"deletions":146,"changes":292,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToOne.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToOne.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToOne.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"e061cdca25f310a0cf013bb33a69138b7eedcefe","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPropertyAccess.java","status":"modified","additions":121,"deletions":121,"changes":242,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPropertyAccess.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"c754b40f20c44e28415b5663f4cb42c1320083fc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestSerializedLobs.java","status":"modified","additions":146,"deletions":146,"changes":292,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestSerializedLobs.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestSerializedLobs.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestSerializedLobs.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"5a680fa5af905185838b58fc88c38e47d613bbfe","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestTablePerClassInheritance.java","status":"modified","additions":108,"deletions":108,"changes":216,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestTablePerClassInheritance.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestTablePerClassInheritance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestTablePerClassInheritance.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"56ed85ff73428d677ff85387afa97db2bbe2b5e7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestVersion.java","status":"modified","additions":240,"deletions":240,"changes":480,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestVersion.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestVersion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestVersion.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"9cbecb9786c2fa711b3bcf838296389c1bb6bf75","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest1.java","status":"modified","additions":311,"deletions":311,"changes":622,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest1.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest1.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"8ef6311a2dee019b77e31557b0f3135c63af960a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest2.java","status":"modified","additions":165,"deletions":165,"changes":330,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest2.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest2.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"8c398b4e04aa979f6c0d947d8fb5f338c0db4282","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest3.java","status":"modified","additions":63,"deletions":63,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest3.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest3.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest3.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a81e004d425a4afef344dd691bbb2b339d386cff","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/CallbackStorage.java","status":"modified","additions":67,"deletions":67,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/CallbackStorage.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/CallbackStorage.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/CallbackStorage.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"14ed9500140971013af596eee67f2cb192d8a8e9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/ContractEmployee.java","status":"modified","additions":64,"deletions":64,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/ContractEmployee.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/ContractEmployee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/ContractEmployee.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"7026713b1ada04fd7bacbf9f12834f351aa2fcbb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DateValidator.java","status":"modified","additions":40,"deletions":40,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DateValidator.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DateValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DateValidator.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"24bc9e9bbd011a778544ba0e9d914f9ba9115139","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DefaultCallbackListener.java","status":"modified","additions":83,"deletions":83,"changes":166,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DefaultCallbackListener.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DefaultCallbackListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DefaultCallbackListener.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"0e46ead850839e783ef043cd417d189b1aced8d5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedOwner.java","status":"modified","additions":67,"deletions":67,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedOwner.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedOwner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedOwner.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"ded0639941433ef2fde6adea577426554e8f74a6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue.java","status":"modified","additions":73,"deletions":73,"changes":146,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"5f408b2884f472aacdd84e60ed5ac1f42bf789d0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue2.java","status":"modified","additions":53,"deletions":53,"changes":106,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue2.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue2.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"0093c448b09e36cce2cc21f04415c64a8c3ce2c9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuper.java","status":"modified","additions":76,"deletions":76,"changes":152,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuper.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuper.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"7109223ca16d0a06d9c646a55765d6289b202a43","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuperSub.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuperSub.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuperSub.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuperSub.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"7ab7564dda1798643a6caa9c2fb04bbafa5c0bd5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdClass.java","status":"modified","additions":79,"deletions":79,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdClass.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdClass.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a182ea322e2784a4be8db1a0ea83827f64ae1845","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdEntity.java","status":"modified","additions":87,"deletions":87,"changes":174,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdEntity.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdEntity.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"3d896513025b897a1f3b94b3baf8d8d45bd64f2f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Employee.java","status":"modified","additions":106,"deletions":106,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Employee.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Employee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Employee.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"7a6fd4547e1020717c9ebbe07f63f03c5754522d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity1.java","status":"modified","additions":117,"deletions":117,"changes":234,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity1.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity1.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"b2a3406c2e2bee92f039d3a4944cd07dabfa5534","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity2.java","status":"modified","additions":95,"deletions":95,"changes":190,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity2.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity2.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"b4f1373c24538ff1768639aa3b6eec37ca22b3f4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat1.java","status":"modified","additions":66,"deletions":66,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat1.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat1.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"5370d5a3d215a85ed924ac49f2da6e17584980c7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat2.java","status":"modified","additions":45,"deletions":45,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat2.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat2.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"9fe8e3a6e5e32c04af5afa5201ae04313289d7db","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/FlightSchedule.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/FlightSchedule.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/FlightSchedule.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/FlightSchedule.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"74d4c7d38fdcca6c215748404dbbb6b1ff24df6b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Generator.java","status":"modified","additions":109,"deletions":109,"changes":218,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Generator.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Generator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Generator.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"b8e3013656cf8ed84a06e193f343ec626cc223f7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/LongNameValidator.java","status":"modified","additions":44,"deletions":44,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/LongNameValidator.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/LongNameValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/LongNameValidator.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"6dcc1844cf8705ac2c6937c5636329b4afe09168","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NameValidator.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NameValidator.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NameValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NameValidator.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"6cc2c14503f468a8c149564890f83c7877de9b83","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NamedEntity.java","status":"modified","additions":26,"deletions":26,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NamedEntity.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NamedEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NamedEntity.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"d09cb344752a4d9eb2db9851d702f2d38c367d1b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/OrderByEntity.java","status":"modified","additions":84,"deletions":84,"changes":168,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/OrderByEntity.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/OrderByEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/OrderByEntity.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"b7193099a5cb05f2c1b81b11d7546d5d5527e64e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Party.java","status":"modified","additions":71,"deletions":71,"changes":142,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Party.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Party.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Party.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"ed38b5acf3e83556513ce7cd9dc341d17ae59757","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Party1.java","status":"modified","additions":85,"deletions":85,"changes":170,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Party1.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Party1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Party1.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"8cd5e9cd4f1f01c985d9fb26458161eb739e330b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PartyId.java","status":"modified","additions":53,"deletions":53,"changes":106,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PartyId.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PartyId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PartyId.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"dcd4e03497cd90a963ab7a07d7ad363b016e8943","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PropertyAccess1.java","status":"modified","additions":64,"deletions":64,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PropertyAccess1.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PropertyAccess1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PropertyAccess1.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"e8c9768e8505b2f46857da9cf44a6c29d6fef3ee","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Schedule.java","status":"modified","additions":101,"deletions":101,"changes":202,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Schedule.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Schedule.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Schedule.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"dc4f12448649b10eab6d0ec1638f6c6c6fce9d50","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Site.java","status":"modified","additions":64,"deletions":64,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Site.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Site.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Site.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"9b9f9940940f57417acdc063eea9809147f4acfc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Site1.java","status":"modified","additions":66,"deletions":66,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Site1.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Site1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Site1.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"c61a5581eaaaabe6ed944d91dc1b719db32b41ee","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Store.java","status":"modified","additions":79,"deletions":79,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Store.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Store.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Store.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"7856c7092ad7cbaa5bac188b9b3b4c0951378335","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Store1.java","status":"modified","additions":63,"deletions":63,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Store1.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Store1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Store1.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"390ea719213f48751f84b6ba4e17e27b4dacd4fb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/StringValidator.java","status":"modified","additions":37,"deletions":37,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/StringValidator.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/StringValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/StringValidator.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"c2d468f3a15ebca093b9ba46fcc0c15d431a7db7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass1.java","status":"modified","additions":63,"deletions":63,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass1.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass1.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"e9ff8e0ecdd7c0cca36ec7e4591683119d1eec72","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass2.java","status":"modified","additions":38,"deletions":38,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass2.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass2.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"dc822df76bb096ef4dffbd536c5dedeb67c05d4a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TxRollbackEntity.java","status":"modified","additions":77,"deletions":77,"changes":154,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TxRollbackEntity.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TxRollbackEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TxRollbackEntity.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"c2b3ea52e0ea94db2797192d51fb6d293a679188","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/CallbackStorage.java","status":"modified","additions":67,"deletions":67,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/CallbackStorage.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/CallbackStorage.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/CallbackStorage.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"91f840332afa5053d99e63ec73a53dad26f26eb5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/ContractEmployee.java","status":"modified","additions":64,"deletions":64,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/ContractEmployee.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/ContractEmployee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/ContractEmployee.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"7e911402fd6bf2711def106b7e2f09be835ae18a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DateValidator.java","status":"modified","additions":40,"deletions":40,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DateValidator.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DateValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DateValidator.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"abacdb1a3612986a17a2dd3f576b3afea328a414","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DefaultCallbackListener.java","status":"modified","additions":85,"deletions":85,"changes":170,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DefaultCallbackListener.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DefaultCallbackListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DefaultCallbackListener.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"c28a2ed9d17b58638dee6d303b4890c5ef289bf0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Employee.java","status":"modified","additions":106,"deletions":106,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Employee.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Employee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Employee.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"c59ca3618bc35f36901c9fd968aa85f427f1df20","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity1.java","status":"modified","additions":117,"deletions":117,"changes":234,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity1.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity1.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"f9f8e156e5f1c747699d7651011c844d5837367c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity2.java","status":"modified","additions":95,"deletions":95,"changes":190,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity2.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity2.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"b165dbb1750d40e24921c2ff31c91b138eacd8e8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener.java","status":"modified","additions":39,"deletions":39,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"55e81e5d5e341a998f7c6796345ee77fe587f149","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener2.java","status":"modified","additions":36,"deletions":36,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener2.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener2.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"8d1a74af0b13cdb9eb761b0317eaf63e939e9687","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/FlightSchedule.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/FlightSchedule.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/FlightSchedule.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/FlightSchedule.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"7127e1e08f2fcf75b1f65a9cb232b6d5beed43ed","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDD.java","status":"modified","additions":23,"deletions":23,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDD.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDD.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"5263cceae28f4d74d3843f0364842b6ed4a1435f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity.java","status":"modified","additions":89,"deletions":89,"changes":178,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"d3f9c840a8960ae21a926e65277a509f248f04ee","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity2.java","status":"modified","additions":105,"deletions":105,"changes":210,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity2.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity2.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"5738e3e6e8023c77318b2f4a4c06b99298fb0581","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntitySub.java","status":"modified","additions":54,"deletions":54,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntitySub.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntitySub.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntitySub.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"c3fcefcbea1ebfc7620e7339a639436e01bc63c1","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LongNameValidator.java","status":"modified","additions":44,"deletions":44,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LongNameValidator.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LongNameValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LongNameValidator.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"5d8185294ef4cf5ea739c0bb4fa41c27fcd4d556","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NameValidator.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NameValidator.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NameValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NameValidator.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"2cc2b47657e17fb19ec8144b5298d523305049e4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NamedEntity.java","status":"modified","additions":26,"deletions":26,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NamedEntity.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NamedEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NamedEntity.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"f5ffbce1bb65688cbbbb127c0a3f0d92775ad972","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Schedule.java","status":"modified","additions":102,"deletions":102,"changes":204,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Schedule.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Schedule.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Schedule.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"894ce58c92605cbd72190e5c62f76321e66ff0df","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/StringValidator.java","status":"modified","additions":37,"deletions":37,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/StringValidator.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/StringValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/StringValidator.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"7f5af1ad9143762663e609549c78a0b038f2d94d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/TxRollbackEntity.java","status":"modified","additions":73,"deletions":73,"changes":146,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/TxRollbackEntity.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/TxRollbackEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/TxRollbackEntity.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"a08c80a0673dec06af79dabb0afd078bed3fa8d1","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/xml/DerivedA.java","status":"modified","additions":34,"deletions":34,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/xml/DerivedA.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/xml/DerivedA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/xml/DerivedA.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"95b3c9c6c61603f79930a53b109702adc518b673","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/xml/DerivedB.java","status":"modified","additions":37,"deletions":37,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/xml/DerivedB.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/xml/DerivedB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/xml/DerivedB.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"},{"sha":"c08ea5bae9f617803873bfe5e985f26e8257cb5b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/xml/EntityA.java","status":"modified","additions":62,"deletions":62,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/xml/EntityA.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/xml/EntityA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/xml/EntityA.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43"}]}

