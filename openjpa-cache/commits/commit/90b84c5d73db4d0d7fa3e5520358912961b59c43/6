{"sha":"90b84c5d73db4d0d7fa3e5520358912961b59c43","node_id":"MDY6Q29tbWl0MjA2MzY0OjkwYjg0YzVkNzNkYjRkMGQ3ZmEzZTU1MjAzNTg5MTI5NjFiNTljNDM=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-22T23:37:24Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-22T23:37:24Z"},"message":"OPENJPA-896. Setting eol-style:native and removing windows eol characters from source files.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@757278 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"acb22a46ce954612c3f359175e18ce97ad6ecf85","url":"https://api.github.com/repos/apache/openjpa/git/trees/acb22a46ce954612c3f359175e18ce97ad6ecf85"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/90b84c5d73db4d0d7fa3e5520358912961b59c43","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/90b84c5d73db4d0d7fa3e5520358912961b59c43","html_url":"https://github.com/apache/openjpa/commit/90b84c5d73db4d0d7fa3e5520358912961b59c43","comments_url":"https://api.github.com/repos/apache/openjpa/commits/90b84c5d73db4d0d7fa3e5520358912961b59c43/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"c3175eea3c3885286898170fae6b487b070f60b5","url":"https://api.github.com/repos/apache/openjpa/commits/c3175eea3c3885286898170fae6b487b070f60b5","html_url":"https://github.com/apache/openjpa/commit/c3175eea3c3885286898170fae6b487b070f60b5"}],"stats":{"total":382166,"additions":191083,"deletions":191083},"files":[{"sha":"9a0b145ce97b78c21c4ff47135865c8c2d802a2c","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerFactory.java","status":"modified","additions":47,"deletions":47,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerFactory.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,47 +1,47 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.kernel.BrokerFactory;\r\n-\r\n-/**\r\n- * Extension to BrokerFactory to allow dynamically add/remove slices.\r\n- * \r\n- * @author Pinaki Poddar\r\n- *\r\n- */\r\n-public interface DistributedBrokerFactory extends BrokerFactory {\r\n-    /**\r\n-     * Adds the given slice with the given properties. This newly added slice\r\n-     * will be configured to brokers constructed by this factory after this\r\n-     * call.\r\n-     * \r\n-     * @param name logical name of the to be added slice. Must be different from\r\n-     * any currently available slices.\r\n-     * @see DistributedConfiguration#getAvailableSliceNames()\r\n-     * \r\n-     * @param properties key-value pair of configuration for the slice to be\r\n-     * added. The keys must have openjpa.slice.&lt;name&gt;.* as prefix.\r\n-     * \r\n-     * @see DistributedConfiguration#addSlice(String, Map)\r\n-     */\r\n-    public Slice addSlice(String name, Map properties);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.kernel.BrokerFactory;\n+\n+/**\n+ * Extension to BrokerFactory to allow dynamically add/remove slices.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public interface DistributedBrokerFactory extends BrokerFactory {\n+    /**\n+     * Adds the given slice with the given properties. This newly added slice\n+     * will be configured to brokers constructed by this factory after this\n+     * call.\n+     * \n+     * @param name logical name of the to be added slice. Must be different from\n+     * any currently available slices.\n+     * @see DistributedConfiguration#getAvailableSliceNames()\n+     * \n+     * @param properties key-value pair of configuration for the slice to be\n+     * added. The keys must have openjpa.slice.&lt;name&gt;.* as prefix.\n+     * \n+     * @see DistributedConfiguration#addSlice(String, Map)\n+     */\n+    public Slice addSlice(String name, Map properties);\n+}"},{"sha":"8549c1d1ae7a5e783bab784c97dbeedea297709e","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java","status":"modified","additions":142,"deletions":142,"changes":284,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,142 +1,142 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.kernel.FinalizingBrokerImpl;\r\n-import org.apache.openjpa.kernel.OpCallbacks;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.QueryImpl;\r\n-import org.apache.openjpa.kernel.StoreQuery;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-\r\n-/**\r\n- * A specialized Broker to associate slice identifiers with the StateManagers as\r\n- * they are persisted in a cascade. This intervention helps the user to define\r\n- * distribution policy only for root instances i.e. the instances that are\r\n- * explicit argument to persist() call. The cascaded instances are assigned the\r\n- * same slice to honor collocation constraint.\r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- */\r\n-@SuppressWarnings(\"serial\")\r\n-public class DistributedBrokerImpl extends FinalizingBrokerImpl \r\n-    implements DistributedBroker {\r\n-\tprivate transient String _rootSlice;\r\n-\tprivate transient DistributedConfiguration _conf;\r\n-\tprivate final ReentrantSliceLock _lock;\r\n-\t\r\n-\tprivate static final Localizer _loc =\r\n-\t\t\tLocalizer.forPackage(DistributedBrokerImpl.class);\r\n-\r\n-\tpublic DistributedBrokerImpl() {\r\n-\t    super();\r\n-\t    _lock = new ReentrantSliceLock();\r\n-\t}\r\n-\t\r\n-    public DistributedConfiguration getConfiguration() {\r\n-    \tif (_conf == null) {\r\n-    \t\t_conf = (DistributedConfiguration)super.getConfiguration();\r\n-    \t}\r\n-        return _conf;\r\n-    }\r\n-    \r\n-    public DistributedStoreManager getDistributedStoreManager() {\r\n-        return (DistributedStoreManager)getStoreManager().getInnermostDelegate();\r\n-    }\r\n-    \r\n-    public Slice addSlice(String name, Map properties) {\r\n-        Slice slice = ((DistributedBrokerFactory)getBrokerFactory()).addSlice(\r\n-            name, properties);\r\n-        getDistributedStoreManager().addSlice(slice);\r\n-        return slice;\r\n-    }\r\n-    \r\n-\t/**\r\n-\t * Assigns slice identifier to the resultant StateManager as initialized by\r\n-\t * the super class implementation. The slice identifier is decided by\r\n-\t * {@link DistributionPolicy} for given <code>pc</code> if it is a root\r\n-\t * instance i.e. the argument of the user application's persist() call. The\r\n-\t * cascaded instances are detected by non-empty status of the current\r\n-\t * operating set. The slice is assigned only if a StateManager has never\r\n-\t * been assigned before.\r\n-\t */\r\n-\t@Override\r\n-\tpublic OpenJPAStateManager persist(Object pc, Object id, boolean explicit,\r\n-\t\t\tOpCallbacks call) {\r\n-\t\tOpenJPAStateManager sm = getStateManager(pc);\r\n-\t\tSliceInfo info = null;\r\n-\t\tboolean replicated = SliceImplHelper.isReplicated(pc, getConfiguration());\r\n-\t\tif (getOperatingSet().isEmpty()\t&& !SliceImplHelper.isSliceAssigned(sm)) {\r\n-\t\t\tinfo = SliceImplHelper.getSlicesByPolicy(pc, getConfiguration(), \r\n-\t\t\t\tthis);\r\n-\t\t\t_rootSlice = info.getSlices()[0]; \r\n-\t\t}\r\n-\t\tsm = super.persist(pc, id, explicit, call);\r\n-\t\tif (!SliceImplHelper.isSliceAssigned(sm)) {\r\n-\t\t\tif (info == null) {\r\n-\t\t\t   info = replicated \r\n-\t\t\t   ? SliceImplHelper.getSlicesByPolicy(pc, getConfiguration(), this) \r\n-\t\t\t   : new SliceInfo(_rootSlice); \r\n-\t\t\t}\r\n-\t\t\tinfo.setInto(sm);\r\n-\t\t}\r\n-\t\treturn sm;\r\n-\t}\r\n-\r\n-\t\r\n-\t@Override\r\n-\tpublic boolean endOperation() {\r\n-\t    try {\r\n-\t        return super.endOperation();\r\n-\t    } catch (Exception ex) {\r\n-\t        \r\n-\t    }\r\n-\t    return true;\r\n-\t}\r\n-\t\r\n-    /**\r\n-     * Create a new query.\r\n-     */\r\n-    protected QueryImpl newQueryImpl(String lang, StoreQuery sq) {\r\n-        return new DistributedQueryImpl(this, lang, sq);\r\n-    }\r\n-    \r\n-\t/**\r\n-\t * Always uses lock irrespective of super's multi-threaded settings.\r\n-\t */\r\n-    @Override\r\n-    public void lock() {\r\n-        _lock.lock();\r\n-    }\r\n-    \r\n-    @Override\r\n-    public void unlock() {\r\n-        _lock.unlock();\r\n-    }\r\n-\t\r\n-\t/**\r\n-\t * A virtual datastore need not be opened.\r\n-\t */\r\n-\t@Override\r\n-\tpublic void beginStore() {\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.kernel.FinalizingBrokerImpl;\n+import org.apache.openjpa.kernel.OpCallbacks;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.QueryImpl;\n+import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+/**\n+ * A specialized Broker to associate slice identifiers with the StateManagers as\n+ * they are persisted in a cascade. This intervention helps the user to define\n+ * distribution policy only for root instances i.e. the instances that are\n+ * explicit argument to persist() call. The cascaded instances are assigned the\n+ * same slice to honor collocation constraint.\n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+@SuppressWarnings(\"serial\")\n+public class DistributedBrokerImpl extends FinalizingBrokerImpl \n+    implements DistributedBroker {\n+\tprivate transient String _rootSlice;\n+\tprivate transient DistributedConfiguration _conf;\n+\tprivate final ReentrantSliceLock _lock;\n+\t\n+\tprivate static final Localizer _loc =\n+\t\t\tLocalizer.forPackage(DistributedBrokerImpl.class);\n+\n+\tpublic DistributedBrokerImpl() {\n+\t    super();\n+\t    _lock = new ReentrantSliceLock();\n+\t}\n+\t\n+    public DistributedConfiguration getConfiguration() {\n+    \tif (_conf == null) {\n+    \t\t_conf = (DistributedConfiguration)super.getConfiguration();\n+    \t}\n+        return _conf;\n+    }\n+    \n+    public DistributedStoreManager getDistributedStoreManager() {\n+        return (DistributedStoreManager)getStoreManager().getInnermostDelegate();\n+    }\n+    \n+    public Slice addSlice(String name, Map properties) {\n+        Slice slice = ((DistributedBrokerFactory)getBrokerFactory()).addSlice(\n+            name, properties);\n+        getDistributedStoreManager().addSlice(slice);\n+        return slice;\n+    }\n+    \n+\t/**\n+\t * Assigns slice identifier to the resultant StateManager as initialized by\n+\t * the super class implementation. The slice identifier is decided by\n+\t * {@link DistributionPolicy} for given <code>pc</code> if it is a root\n+\t * instance i.e. the argument of the user application's persist() call. The\n+\t * cascaded instances are detected by non-empty status of the current\n+\t * operating set. The slice is assigned only if a StateManager has never\n+\t * been assigned before.\n+\t */\n+\t@Override\n+\tpublic OpenJPAStateManager persist(Object pc, Object id, boolean explicit,\n+\t\t\tOpCallbacks call) {\n+\t\tOpenJPAStateManager sm = getStateManager(pc);\n+\t\tSliceInfo info = null;\n+\t\tboolean replicated = SliceImplHelper.isReplicated(pc, getConfiguration());\n+\t\tif (getOperatingSet().isEmpty()\t&& !SliceImplHelper.isSliceAssigned(sm)) {\n+\t\t\tinfo = SliceImplHelper.getSlicesByPolicy(pc, getConfiguration(), \n+\t\t\t\tthis);\n+\t\t\t_rootSlice = info.getSlices()[0]; \n+\t\t}\n+\t\tsm = super.persist(pc, id, explicit, call);\n+\t\tif (!SliceImplHelper.isSliceAssigned(sm)) {\n+\t\t\tif (info == null) {\n+\t\t\t   info = replicated \n+\t\t\t   ? SliceImplHelper.getSlicesByPolicy(pc, getConfiguration(), this) \n+\t\t\t   : new SliceInfo(_rootSlice); \n+\t\t\t}\n+\t\t\tinfo.setInto(sm);\n+\t\t}\n+\t\treturn sm;\n+\t}\n+\n+\t\n+\t@Override\n+\tpublic boolean endOperation() {\n+\t    try {\n+\t        return super.endOperation();\n+\t    } catch (Exception ex) {\n+\t        \n+\t    }\n+\t    return true;\n+\t}\n+\t\n+    /**\n+     * Create a new query.\n+     */\n+    protected QueryImpl newQueryImpl(String lang, StoreQuery sq) {\n+        return new DistributedQueryImpl(this, lang, sq);\n+    }\n+    \n+\t/**\n+\t * Always uses lock irrespective of super's multi-threaded settings.\n+\t */\n+    @Override\n+    public void lock() {\n+        _lock.lock();\n+    }\n+    \n+    @Override\n+    public void unlock() {\n+        _lock.unlock();\n+    }\n+\t\n+\t/**\n+\t * A virtual datastore need not be opened.\n+\t */\n+\t@Override\n+\tpublic void beginStore() {\n+\t}\n+}"},{"sha":"efe2f634ed0ca8db7d8a058960762bb557140582","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedConfiguration.java","status":"modified","additions":127,"deletions":127,"changes":254,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedConfiguration.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,127 +1,127 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-\r\n-/**\r\n- * A configuration for multiple data stores, each referred as <em>slice</em>.\r\n- * This configuration allows each underlying slice be configured with its\r\n- * own specific configuration properties such as JDBC Driver or connection\r\n- * user/password etc. <br>\r\n- * This configuration also extends by adding a {@link DistributionPolicy \r\n- * DistributionPolicy} that governs how new instances be distributed\r\n- * among the slices.\r\n- * \r\n- * @author Pinaki Poddar \r\n- *\r\n- */\r\n-public interface DistributedConfiguration extends OpenJPAConfiguration {\r\n-\t/**\r\n-\t * Gets the active slice identifiers. This list is determined by the\r\n-\t * configuration properties either by explicit listing in \r\n-\t * <code>openjpa.slice.Names</code> property or by scanning \r\n-\t * <code>openjpa.slice.*.*</code> properties.\r\n-\t * <br> \r\n-\t * The ordering of the slice identifiers is determined when they are\r\n-\t * specified explicitly in <code>openjpa.slice.Names</code> property or \r\n-\t * ordered alphabetically when found by scanning the properties.\r\n-\t * <br>\r\n-\t * This list always returns the identifiers that are <em>active</em>, slices\r\n-\t * that can not be connected to are not included in this list.\r\n-\t */\r\n-\tList<String> getActiveSliceNames();\r\n-\t\r\n-\t/**\r\n-\t * Gets the available slice identifiers irrespective of their status.\r\n-\t * @return\r\n-\t */\r\n-    List<String> getAvailableSliceNames();\r\n-\r\n-\t\r\n-\t/**\r\n-\t * Gets the slices of given status.\r\n-\t * @param statuses list of status flags. If null, returns all slices \r\n-\t * irrespective of status.\r\n-\t */\r\n-\tList<Slice> getSlices(Slice.Status...statuses);\r\n-\t\r\n-\t/**\r\n-\t * Gets the Slice for a given name.\r\n-\t * Exception is raised if the given slice is not configured.\r\n-\t */\r\n-\tSlice getSlice(String sliceName);\r\n-\t\r\n-    /**\r\n-     * Gets the policy that governs how new instances will be distributed across\r\n-     * the available slices.\r\n-     */\r\n-    DistributionPolicy getDistributionPolicyInstance();\r\n-    \r\n-    /**\r\n-     * Sets the policy that governs how new instances will be distributed across\r\n-     * the available slices.\r\n-     */\r\n-    void setDistributionPolicyInstance(DistributionPolicy policy);\r\n-\t\r\n-    /**\r\n-     * Gets the policy, as a plugin string, that governs how new instances will \r\n-     * be distributed across the available slices.\r\n-     */\r\n-    String getDistributionPolicy();\r\n-    \r\n-    /**\r\n-     * Sets the policy, from the given plugin string, that governs how new \r\n-     * instances will be distributed across the available slices.\r\n-     */\r\n-    void setDistributionPolicy(String policy);\r\n-\r\n-    /**\r\n-     * Gets the policy that governs how new replicated instances will be \r\n-     * replicated across the available slices.\r\n-     */\r\n-    ReplicationPolicy getReplicationPolicyInstance();\r\n-    \r\n-    /**\r\n-     * Gets the policy, as a plugin string, that governs how new replicated \r\n-     * instances will be replicated across the available slices.\r\n-     */\r\n-    String getReplicationPolicy();\r\n-\t\r\n-    /**\r\n-     * Sets the policy that governs how new replicated instances will be \r\n-     * replicated across the available slices.\r\n-     */\r\n-    void setReplicationPolicyInstance(ReplicationPolicy policy);\r\n-    \r\n-    /**\r\n-     * Sets the policy, from the given plugin string, that governs how new \r\n-     * replicated instances will be replicated across the available slices.\r\n-     */\r\n-    void setReplicationPolicy(String policy);\r\n-\t/**\r\n-\t * Adds a new Slice of the given name and given properties.\r\n-     * The given properties must have keys with prefix openjpa.slice.<name>.*\r\n-     * where <name> is the new slice to be added.\r\n-\t */\r\n-    Slice addSlice(String name, Map properties);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+\n+/**\n+ * A configuration for multiple data stores, each referred as <em>slice</em>.\n+ * This configuration allows each underlying slice be configured with its\n+ * own specific configuration properties such as JDBC Driver or connection\n+ * user/password etc. <br>\n+ * This configuration also extends by adding a {@link DistributionPolicy \n+ * DistributionPolicy} that governs how new instances be distributed\n+ * among the slices.\n+ * \n+ * @author Pinaki Poddar \n+ *\n+ */\n+public interface DistributedConfiguration extends OpenJPAConfiguration {\n+\t/**\n+\t * Gets the active slice identifiers. This list is determined by the\n+\t * configuration properties either by explicit listing in \n+\t * <code>openjpa.slice.Names</code> property or by scanning \n+\t * <code>openjpa.slice.*.*</code> properties.\n+\t * <br> \n+\t * The ordering of the slice identifiers is determined when they are\n+\t * specified explicitly in <code>openjpa.slice.Names</code> property or \n+\t * ordered alphabetically when found by scanning the properties.\n+\t * <br>\n+\t * This list always returns the identifiers that are <em>active</em>, slices\n+\t * that can not be connected to are not included in this list.\n+\t */\n+\tList<String> getActiveSliceNames();\n+\t\n+\t/**\n+\t * Gets the available slice identifiers irrespective of their status.\n+\t * @return\n+\t */\n+    List<String> getAvailableSliceNames();\n+\n+\t\n+\t/**\n+\t * Gets the slices of given status.\n+\t * @param statuses list of status flags. If null, returns all slices \n+\t * irrespective of status.\n+\t */\n+\tList<Slice> getSlices(Slice.Status...statuses);\n+\t\n+\t/**\n+\t * Gets the Slice for a given name.\n+\t * Exception is raised if the given slice is not configured.\n+\t */\n+\tSlice getSlice(String sliceName);\n+\t\n+    /**\n+     * Gets the policy that governs how new instances will be distributed across\n+     * the available slices.\n+     */\n+    DistributionPolicy getDistributionPolicyInstance();\n+    \n+    /**\n+     * Sets the policy that governs how new instances will be distributed across\n+     * the available slices.\n+     */\n+    void setDistributionPolicyInstance(DistributionPolicy policy);\n+\t\n+    /**\n+     * Gets the policy, as a plugin string, that governs how new instances will \n+     * be distributed across the available slices.\n+     */\n+    String getDistributionPolicy();\n+    \n+    /**\n+     * Sets the policy, from the given plugin string, that governs how new \n+     * instances will be distributed across the available slices.\n+     */\n+    void setDistributionPolicy(String policy);\n+\n+    /**\n+     * Gets the policy that governs how new replicated instances will be \n+     * replicated across the available slices.\n+     */\n+    ReplicationPolicy getReplicationPolicyInstance();\n+    \n+    /**\n+     * Gets the policy, as a plugin string, that governs how new replicated \n+     * instances will be replicated across the available slices.\n+     */\n+    String getReplicationPolicy();\n+\t\n+    /**\n+     * Sets the policy that governs how new replicated instances will be \n+     * replicated across the available slices.\n+     */\n+    void setReplicationPolicyInstance(ReplicationPolicy policy);\n+    \n+    /**\n+     * Sets the policy, from the given plugin string, that governs how new \n+     * replicated instances will be replicated across the available slices.\n+     */\n+    void setReplicationPolicy(String policy);\n+\t/**\n+\t * Adds a new Slice of the given name and given properties.\n+     * The given properties must have keys with prefix openjpa.slice.<name>.*\n+     * where <name> is the new slice to be added.\n+\t */\n+    Slice addSlice(String name, Map properties);\n+}"},{"sha":"1a4de97d9ef62effe1436c54e866fab2736b2a86","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedQueryImpl.java","status":"modified","additions":50,"deletions":50,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedQueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedQueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedQueryImpl.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,50 +1,50 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import org.apache.openjpa.kernel.Broker;\r\n-import org.apache.openjpa.kernel.QueryImpl;\r\n-import org.apache.openjpa.kernel.StoreQuery;\r\n-\r\n-/**\r\n- * Extension with slice locking policy.\r\n- * \r\n- * @author Pinaki Poddar\r\n- *\r\n- */\r\n-public class DistributedQueryImpl extends QueryImpl {\r\n-    private final ReentrantSliceLock _lock;\r\n-    public DistributedQueryImpl(Broker broker, String language, StoreQuery storeQuery) {\r\n-        super(broker, language, storeQuery);\r\n-        _lock = new ReentrantSliceLock();\r\n-    }\r\n-    \r\n-    /**\r\n-     * Always uses lock irrespective of super's multi-threaded settings.\r\n-     */\r\n-    @Override\r\n-    public void lock() {\r\n-        _lock.lock();\r\n-    }\r\n-    \r\n-    @Override\r\n-    public void unlock() {\r\n-        _lock.unlock();\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import org.apache.openjpa.kernel.Broker;\n+import org.apache.openjpa.kernel.QueryImpl;\n+import org.apache.openjpa.kernel.StoreQuery;\n+\n+/**\n+ * Extension with slice locking policy.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public class DistributedQueryImpl extends QueryImpl {\n+    private final ReentrantSliceLock _lock;\n+    public DistributedQueryImpl(Broker broker, String language, StoreQuery storeQuery) {\n+        super(broker, language, storeQuery);\n+        _lock = new ReentrantSliceLock();\n+    }\n+    \n+    /**\n+     * Always uses lock irrespective of super's multi-threaded settings.\n+     */\n+    @Override\n+    public void lock() {\n+        _lock.lock();\n+    }\n+    \n+    @Override\n+    public void unlock() {\n+        _lock.unlock();\n+    }\n+}"},{"sha":"0d41b522b1645224268f891b6e09c927b86a1126","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedStoreManager.java","status":"modified","additions":41,"deletions":41,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedStoreManager.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,41 +1,41 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.kernel.StoreManager;\r\n-import org.apache.openjpa.slice.jdbc.SliceStoreManager;\r\n-\r\n-public interface DistributedStoreManager extends StoreManager {\r\n-    /**\r\n-     * Adds the given slice with the given properties. This newly added slice\r\n-     * will participate in the current and subsequent transaction.\r\n-     * \r\n-     * @param name logical name of the to be added slice. Must be different from\r\n-     * any currently available slices.\r\n-     * @see DistributedBroker#addSlice(String, Map)\r\n-     * @see DistributedBrokerFactory#addSlice(String, Map)\r\n-     * \r\n-     * @return the store manager for the newly added slice.\r\n-     * \r\n-     */\r\n-    public SliceStoreManager addSlice(Slice slice);\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.slice.jdbc.SliceStoreManager;\n+\n+public interface DistributedStoreManager extends StoreManager {\n+    /**\n+     * Adds the given slice with the given properties. This newly added slice\n+     * will participate in the current and subsequent transaction.\n+     * \n+     * @param name logical name of the to be added slice. Must be different from\n+     * any currently available slices.\n+     * @see DistributedBroker#addSlice(String, Map)\n+     * @see DistributedBrokerFactory#addSlice(String, Map)\n+     * \n+     * @return the store manager for the newly added slice.\n+     * \n+     */\n+    public SliceStoreManager addSlice(Slice slice);\n+\n+}"},{"sha":"6218bc5dc7fcf62dea8990b63c145ef9fe25e377","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributionPolicy.java","status":"modified","additions":65,"deletions":65,"changes":130,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributionPolicy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributionPolicy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributionPolicy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,65 +1,65 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.List;\r\n-import java.util.Random;\r\n-\r\n-\r\n-/**\r\n- * Policy to select one of the physical databases referred as <em>slice</em>\r\n- * in which a given persistent instance will be stored.\r\n- *  \r\n- * The user application is required to implement this interface. Slice will\r\n- * invoke the single method of this interface to determine the target slice for\r\n- * a newly persistent or a detached instance being merged.\r\n- *  \r\n- * @author Pinaki Poddar \r\n- *\r\n- */\r\n-public interface DistributionPolicy {\r\n-\t/**\r\n-\t * Gets the name of the target slice where the given newly persistent or\r\n-\t * the detached, to-be-merged instance will be stored.\r\n-\t *  \r\n-\t * @param pc The newly persistent or to-be-merged object. \r\n-\t * @param slices list of names of the active slices. The ordering of \r\n-\t * the list is either explicit <code>openjpa.slice.Names</code> property\r\n-\t * or implicit i.e. alphabetic order of available identifiers if \r\n-\t * <code>openjpa.slice.Names</code> is unspecified.  \r\n-\t * @param context the generic persistence context managing the given instance.\r\n-\t * \r\n-\t * @return identifier of the slice. This name must match one of the\r\n-\t * given slice names. \r\n-\t * @see DistributedConfiguration#getActiveSliceNames()\r\n-\t */\r\n-\tString distribute(Object pc, List<String> slices, Object context);\r\n-\t\r\n-\t/**\r\n-\t * Implements a default distribution policy to store the given \r\n-\t * instance to a randomly selected available slice.\r\n-\t *\r\n-\t */\r\n-\tpublic static class Default implements DistributionPolicy {\r\n-\t\tprivate static Random RNG = new Random();\r\n-\t\tpublic String distribute(Object pc, List<String> slices, Object ctx) {\r\n-\t\t\treturn slices.get(RNG.nextInt(slices.size()));\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.List;\n+import java.util.Random;\n+\n+\n+/**\n+ * Policy to select one of the physical databases referred as <em>slice</em>\n+ * in which a given persistent instance will be stored.\n+ *  \n+ * The user application is required to implement this interface. Slice will\n+ * invoke the single method of this interface to determine the target slice for\n+ * a newly persistent or a detached instance being merged.\n+ *  \n+ * @author Pinaki Poddar \n+ *\n+ */\n+public interface DistributionPolicy {\n+\t/**\n+\t * Gets the name of the target slice where the given newly persistent or\n+\t * the detached, to-be-merged instance will be stored.\n+\t *  \n+\t * @param pc The newly persistent or to-be-merged object. \n+\t * @param slices list of names of the active slices. The ordering of \n+\t * the list is either explicit <code>openjpa.slice.Names</code> property\n+\t * or implicit i.e. alphabetic order of available identifiers if \n+\t * <code>openjpa.slice.Names</code> is unspecified.  \n+\t * @param context the generic persistence context managing the given instance.\n+\t * \n+\t * @return identifier of the slice. This name must match one of the\n+\t * given slice names. \n+\t * @see DistributedConfiguration#getActiveSliceNames()\n+\t */\n+\tString distribute(Object pc, List<String> slices, Object context);\n+\t\n+\t/**\n+\t * Implements a default distribution policy to store the given \n+\t * instance to a randomly selected available slice.\n+\t *\n+\t */\n+\tpublic static class Default implements DistributionPolicy {\n+\t\tprivate static Random RNG = new Random();\n+\t\tpublic String distribute(Object pc, List<String> slices, Object ctx) {\n+\t\t\treturn slices.get(RNG.nextInt(slices.size()));\n+\t\t}\n+\t}\n+}"},{"sha":"2b78c89f9d91b60e1032f1fc4ee070dcdf98c1b6","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/ProductDerivation.java","status":"modified","additions":106,"deletions":106,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/ProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/ProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/ProductDerivation.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,106 +1,106 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.Collections;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAProductDerivation;\r\n-import org.apache.openjpa.lib.conf.AbstractProductDerivation;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.PluginValue;\r\n-import org.apache.openjpa.lib.conf.Value;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.slice.jdbc.DistributedJDBCBrokerFactory;\r\n-import org.apache.openjpa.slice.jdbc.DistributedJDBCConfigurationImpl;\r\n-\r\n-/**\r\n- * Derives configuration for Slice.\r\n- * Introduces a specialized BrokerFactory aliased as <code>slice</code>.\r\n- * All Slice specific configuration is prefixed as \r\n- * <code>openjpa.slice.*.*</code>\r\n- * \r\n- * @author Pinaki Poddar \r\n- *\r\n- */\r\n-public class ProductDerivation extends AbstractProductDerivation implements\r\n-\t\tOpenJPAProductDerivation {\r\n-\tprivate static final Localizer _loc = \r\n-\t\tLocalizer.forPackage(ProductDerivation.class);\r\n-    /**\r\n-     * Prefix for all Slice-specific configuration properties. \r\n-     */\r\n-    public static final String PREFIX_SLICE   = \"openjpa.slice\";\r\n-    \r\n-    /**\r\n-     * Hint key <code>openjpa.hint.slice.Target </code> to specify a subset of \r\n-     * slices for query. The value corresponding to the key is comma-separated\r\n-     * list of slice identifiers.\r\n-     *  \r\n-     */\r\n-    public static final String HINT_TARGET  = \"openjpa.hint.slice.Target\";\r\n-    \r\n-\t@SuppressWarnings(\"unchecked\")\r\n-\tpublic void putBrokerFactoryAliases(Map m) {\r\n-\t\tm.put(\"slice\", DistributedJDBCBrokerFactory.class.getName());\r\n-\t}\r\n-\r\n-\tpublic String getConfigurationPrefix() {\r\n-\t\treturn PREFIX_SLICE;\r\n-\t}\r\n-\r\n-\tpublic int getType() {\r\n-\t\treturn TYPE_STORE;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Sets the {@link DistributionPolicy} and {@link ReplicationPolicy} to\r\n-\t * their respective defaults if not set by the user.\r\n-\t */\r\n-    @Override\r\n-    public boolean afterSpecificationSet(Configuration c) {\r\n-        if (!(c instanceof DistributedJDBCConfigurationImpl))\r\n-            return false;\r\n-        DistributedJDBCConfigurationImpl conf = \r\n-        \t(DistributedJDBCConfigurationImpl)c;\r\n-        boolean modified = false;\r\n-        Log log = conf.getConfigurationLog();\r\n-        if (conf.getDistributionPolicyInstance() == null) {\r\n-        \tforceSet(conf.distributionPolicyPlugin,\"random\", log);\r\n-        \tmodified = true;\r\n-        }\r\n-        if (conf.getReplicationPolicyInstance() == null) {\r\n-        \tforceSet(conf.replicationPolicyPlugin, \"all\", log);\r\n-        \tmodified = true;\r\n-        }\r\n-        return modified;\r\n-    }\r\n-    \r\n-    void forceSet(Value v, String forced, Log log) {\r\n-    \tv.setString(forced);\r\n-    \tif (log.isWarnEnabled())\r\n-        \tlog.warn(_loc.get(\"forced-set-config\", v.getProperty(), forced));\r\n-    }\r\n-    \r\n-    public Set<String> getSupportedQueryHints() {\r\n-        return Collections.singleton(HINT_TARGET);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAProductDerivation;\n+import org.apache.openjpa.lib.conf.AbstractProductDerivation;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.lib.conf.Value;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.slice.jdbc.DistributedJDBCBrokerFactory;\n+import org.apache.openjpa.slice.jdbc.DistributedJDBCConfigurationImpl;\n+\n+/**\n+ * Derives configuration for Slice.\n+ * Introduces a specialized BrokerFactory aliased as <code>slice</code>.\n+ * All Slice specific configuration is prefixed as \n+ * <code>openjpa.slice.*.*</code>\n+ * \n+ * @author Pinaki Poddar \n+ *\n+ */\n+public class ProductDerivation extends AbstractProductDerivation implements\n+\t\tOpenJPAProductDerivation {\n+\tprivate static final Localizer _loc = \n+\t\tLocalizer.forPackage(ProductDerivation.class);\n+    /**\n+     * Prefix for all Slice-specific configuration properties. \n+     */\n+    public static final String PREFIX_SLICE   = \"openjpa.slice\";\n+    \n+    /**\n+     * Hint key <code>openjpa.hint.slice.Target </code> to specify a subset of \n+     * slices for query. The value corresponding to the key is comma-separated\n+     * list of slice identifiers.\n+     *  \n+     */\n+    public static final String HINT_TARGET  = \"openjpa.hint.slice.Target\";\n+    \n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic void putBrokerFactoryAliases(Map m) {\n+\t\tm.put(\"slice\", DistributedJDBCBrokerFactory.class.getName());\n+\t}\n+\n+\tpublic String getConfigurationPrefix() {\n+\t\treturn PREFIX_SLICE;\n+\t}\n+\n+\tpublic int getType() {\n+\t\treturn TYPE_STORE;\n+\t}\n+\t\n+\t/**\n+\t * Sets the {@link DistributionPolicy} and {@link ReplicationPolicy} to\n+\t * their respective defaults if not set by the user.\n+\t */\n+    @Override\n+    public boolean afterSpecificationSet(Configuration c) {\n+        if (!(c instanceof DistributedJDBCConfigurationImpl))\n+            return false;\n+        DistributedJDBCConfigurationImpl conf = \n+        \t(DistributedJDBCConfigurationImpl)c;\n+        boolean modified = false;\n+        Log log = conf.getConfigurationLog();\n+        if (conf.getDistributionPolicyInstance() == null) {\n+        \tforceSet(conf.distributionPolicyPlugin,\"random\", log);\n+        \tmodified = true;\n+        }\n+        if (conf.getReplicationPolicyInstance() == null) {\n+        \tforceSet(conf.replicationPolicyPlugin, \"all\", log);\n+        \tmodified = true;\n+        }\n+        return modified;\n+    }\n+    \n+    void forceSet(Value v, String forced, Log log) {\n+    \tv.setString(forced);\n+    \tif (log.isWarnEnabled())\n+        \tlog.warn(_loc.get(\"forced-set-config\", v.getProperty(), forced));\n+    }\n+    \n+    public Set<String> getSupportedQueryHints() {\n+        return Collections.singleton(HINT_TARGET);\n+    }\n+}"},{"sha":"c5334c5aac094d0e59848ab85eb22f051ed9d9ed","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/ReentrantSliceLock.java","status":"modified","additions":57,"deletions":57,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/ReentrantSliceLock.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/ReentrantSliceLock.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/ReentrantSliceLock.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,57 +1,57 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.concurrent.locks.ReentrantLock;\r\n-\r\n-/**\r\n- * A reentrant lock that lets a child to work with the parent's lock.\r\n- * \r\n- * @author Pinaki Poddar\r\n- *\r\n- */\r\n-public class ReentrantSliceLock extends ReentrantLock {\r\n-\r\n-    public ReentrantSliceLock() {\r\n-    }\r\n-\r\n-    public ReentrantSliceLock(boolean fair) {\r\n-        super(fair);\r\n-    }\r\n-    \r\n-    /**\r\n-     * Locks only for parent thread and let the child use parent's lock. \r\n-     */\r\n-    @Override\r\n-    public void lock() {\r\n-        if (Thread.currentThread() instanceof SliceThread) \r\n-            return;\r\n-        super.lock();\r\n-    }\r\n-\r\n-    /**\r\n-     * Unlocks only if parent thread. \r\n-     */\r\n-    @Override\r\n-    public void unlock() {\r\n-        if (Thread.currentThread() instanceof SliceThread) \r\n-            return;\r\n-        super.unlock();\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * A reentrant lock that lets a child to work with the parent's lock.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public class ReentrantSliceLock extends ReentrantLock {\n+\n+    public ReentrantSliceLock() {\n+    }\n+\n+    public ReentrantSliceLock(boolean fair) {\n+        super(fair);\n+    }\n+    \n+    /**\n+     * Locks only for parent thread and let the child use parent's lock. \n+     */\n+    @Override\n+    public void lock() {\n+        if (Thread.currentThread() instanceof SliceThread) \n+            return;\n+        super.lock();\n+    }\n+\n+    /**\n+     * Unlocks only if parent thread. \n+     */\n+    @Override\n+    public void unlock() {\n+        if (Thread.currentThread() instanceof SliceThread) \n+            return;\n+        super.unlock();\n+    }\n+}"},{"sha":"baa8d2aed65c7adf3a86ab295fe4ff116b6b2839","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/ReplicationPolicy.java","status":"modified","additions":64,"deletions":64,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/ReplicationPolicy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/ReplicationPolicy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/ReplicationPolicy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,64 +1,64 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.List;\r\n-\r\n-/**\r\n- * Policy to select one or more of the physical databases referred as \r\n- * <em>slice</em> in which a given persistent instance will be persisted.\r\n- * \r\n- * This interface is invoked for entity types annotated as @Replicated\r\n- *  \r\n- * @author Pinaki Poddar \r\n- * \r\n- * @see DistributionPolicy\r\n- * @see Replicated\r\n- *\r\n- */\r\n-public interface ReplicationPolicy {\r\n-\t/**\r\n-\t * Gets the name of the slices where a given instance will be replicated.\r\n-\t *  \r\n-\t * @param pc The newly persistent or to-be-merged object. \r\n-\t * @param slices list of names of the active slices. The ordering of \r\n-\t * the list is either explicit <code>openjpa.slice.Names</code> property\r\n-\t * or implicit i.e. alphabetic order of available identifiers if \r\n-\t * <code>openjpa.slice.Names</code> is unspecified.  \r\n-\t * @param context generic persistence context managing the given instance.\r\n-\t * \r\n-\t * @return identifier of the slices. This names must match one of the\r\n-\t * given slice names. \r\n-\t *  \r\n-\t * @see DistributedConfiguration#getActiveSliceNames()\r\n-\t */\r\n-\tString[] replicate(Object pc, List<String> slices, Object context);\r\n-\t\r\n-\t/**\r\n-\t * Implements a default replication policy to replicate the given \r\n-\t * instance across all available slices.\r\n-\t *\r\n-\t */\r\n-\tpublic static class Default implements ReplicationPolicy {\r\n-\t\tpublic String[] replicate(Object pc, List<String> slices, \r\n-\t\t\tObject context) {\r\n-\t\t\treturn slices.toArray(new String[slices.size()]);\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.List;\n+\n+/**\n+ * Policy to select one or more of the physical databases referred as \n+ * <em>slice</em> in which a given persistent instance will be persisted.\n+ * \n+ * This interface is invoked for entity types annotated as @Replicated\n+ *  \n+ * @author Pinaki Poddar \n+ * \n+ * @see DistributionPolicy\n+ * @see Replicated\n+ *\n+ */\n+public interface ReplicationPolicy {\n+\t/**\n+\t * Gets the name of the slices where a given instance will be replicated.\n+\t *  \n+\t * @param pc The newly persistent or to-be-merged object. \n+\t * @param slices list of names of the active slices. The ordering of \n+\t * the list is either explicit <code>openjpa.slice.Names</code> property\n+\t * or implicit i.e. alphabetic order of available identifiers if \n+\t * <code>openjpa.slice.Names</code> is unspecified.  \n+\t * @param context generic persistence context managing the given instance.\n+\t * \n+\t * @return identifier of the slices. This names must match one of the\n+\t * given slice names. \n+\t *  \n+\t * @see DistributedConfiguration#getActiveSliceNames()\n+\t */\n+\tString[] replicate(Object pc, List<String> slices, Object context);\n+\t\n+\t/**\n+\t * Implements a default replication policy to replicate the given \n+\t * instance across all available slices.\n+\t *\n+\t */\n+\tpublic static class Default implements ReplicationPolicy {\n+\t\tpublic String[] replicate(Object pc, List<String> slices, \n+\t\t\tObject context) {\n+\t\t\treturn slices.toArray(new String[slices.size()]);\n+\t\t}\n+\t}\n+}"},{"sha":"9587a8656bbe24dd595178cb50686048bfe8afb3","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/Slice.java","status":"modified","additions":99,"deletions":99,"changes":198,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/Slice.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/Slice.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/Slice.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,99 +1,99 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-\r\n-/**\r\n- * Represents a database slice of immutable logical name, a configuration and\r\n- * status.\r\n- * \r\n- * @author Pinaki Poddar \r\n- *\r\n- */\r\n-public class Slice implements Comparable<Slice> {\r\n-    public enum Status {\r\n-        NOT_INITIALIZED, \r\n-        ACTIVE, \r\n-        INACTIVE, // configured but not available\r\n-        EXCLUDED  // configured but not used\r\n-    }; \r\n-    \r\n-    private final String name;\r\n-    private transient final OpenJPAConfiguration conf;\r\n-    private transient Status status;\r\n-    \r\n-    /**\r\n-     * Supply the logical name and configuration.\r\n-     */\r\n-    public Slice(String name, OpenJPAConfiguration conf) {\r\n-        this.name = name;\r\n-        this.conf = conf;\r\n-        this.status = Status.NOT_INITIALIZED;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Gets the immutable logical name.\r\n-     */\r\n-    public String getName() {\r\n-        return name;\r\n-    }\r\n-    \r\n-    public OpenJPAConfiguration getConfiguration() {\r\n-        return conf;\r\n-    }\r\n-    \r\n-    public Status getStatus() {\r\n-        return status;\r\n-    }\r\n-    \r\n-    public void setStatus(Status status) {\r\n-        this.status = status;\r\n-    }\r\n-    \r\n-    public boolean isActive() {\r\n-        return status == Status.ACTIVE;\r\n-    }\r\n-    \r\n-    public String toString() {\r\n-        return name;\r\n-    }\r\n-    \r\n-    public int compareTo(Slice other) {\r\n-        return name.compareTo(other.name);\r\n-    }\r\n-    \r\n-    /**\r\n-     * Equals by name.\r\n-     */\r\n-    @Override\r\n-    public boolean equals(Object other) {\r\n-        if (this == other) return true;\r\n-        if (other == null) return false;\r\n-        if (other instanceof Slice) {\r\n-            return name.equals(((Slice)other).getName());\r\n-        }\r\n-        return false;\r\n-    }\r\n-    \r\n-    @Override\r\n-    public int hashCode() {\r\n-        return name.hashCode();\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+\n+/**\n+ * Represents a database slice of immutable logical name, a configuration and\n+ * status.\n+ * \n+ * @author Pinaki Poddar \n+ *\n+ */\n+public class Slice implements Comparable<Slice> {\n+    public enum Status {\n+        NOT_INITIALIZED, \n+        ACTIVE, \n+        INACTIVE, // configured but not available\n+        EXCLUDED  // configured but not used\n+    }; \n+    \n+    private final String name;\n+    private transient final OpenJPAConfiguration conf;\n+    private transient Status status;\n+    \n+    /**\n+     * Supply the logical name and configuration.\n+     */\n+    public Slice(String name, OpenJPAConfiguration conf) {\n+        this.name = name;\n+        this.conf = conf;\n+        this.status = Status.NOT_INITIALIZED;\n+    }\n+    \n+    /**\n+     * Gets the immutable logical name.\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+    \n+    public OpenJPAConfiguration getConfiguration() {\n+        return conf;\n+    }\n+    \n+    public Status getStatus() {\n+        return status;\n+    }\n+    \n+    public void setStatus(Status status) {\n+        this.status = status;\n+    }\n+    \n+    public boolean isActive() {\n+        return status == Status.ACTIVE;\n+    }\n+    \n+    public String toString() {\n+        return name;\n+    }\n+    \n+    public int compareTo(Slice other) {\n+        return name.compareTo(other.name);\n+    }\n+    \n+    /**\n+     * Equals by name.\n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) return true;\n+        if (other == null) return false;\n+        if (other instanceof Slice) {\n+            return name.equals(((Slice)other).getName());\n+        }\n+        return false;\n+    }\n+    \n+    @Override\n+    public int hashCode() {\n+        return name.hashCode();\n+    }\n+}"},{"sha":"092b1c63162e717757b1f691903c8d0f0202b4ea","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceImplHelper.java","status":"modified","additions":118,"deletions":118,"changes":236,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceImplHelper.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceImplHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceImplHelper.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,118 +1,118 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.List;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * Utility methods to determine the target slices for a persistence capable\r\n- * instance by calling back to user-specified distribution policy.\r\n- * \r\n- * @author Pinaki Poddar\r\n- *\r\n- */\r\n-public class SliceImplHelper {\r\n-\tprivate static final Localizer _loc =\r\n-\t\tLocalizer.forPackage(SliceImplHelper.class);\r\n-\t\r\n-\t/**\r\n-\t * Gets the target slices by calling user-specified \r\n-\t * {@link DistributionPolicy} or {@link ReplicationPolicy} \r\n-\t * depending on whether the given instance is {@link Replicated replicated}.\r\n-\t */\r\n-\tpublic static SliceInfo getSlicesByPolicy(Object pc, \r\n-\t\t\tDistributedConfiguration conf, Object ctx) {\r\n-\t\tList<String> actives = conf.getActiveSliceNames();\r\n-\t\tObject policy = null;\r\n-\t\tString[] targets = null;\r\n-\t\tboolean replicated = isReplicated(pc, conf);\r\n-\t\tif (replicated) {\r\n-\t\t\tpolicy = conf.getReplicationPolicyInstance();\r\n-\t\t\ttargets = ((ReplicationPolicy)policy).replicate(pc, actives, ctx);\r\n-\t\t} else {\r\n-\t\t\tpolicy = conf.getDistributionPolicyInstance();\r\n-\t\t\ttargets = new String[]{((DistributionPolicy)policy).distribute \r\n-\t\t\t\t(pc, actives, ctx)};\r\n-\t\t}\r\n-\t\tassertSlices(targets, pc, conf.getActiveSliceNames(), policy);\r\n-\t\treturn new SliceInfo(replicated, targets);\r\n-\t}\r\n-\t\r\n-\tprivate static void assertSlices(String[] targets, Object pc, \r\n-\t    List<String> actives, Object policy) {\r\n-\t    if (targets == null || targets.length == 0)\r\n-            throw new UserException(_loc.get(\"no-policy-slice\", new Object[] {\r\n-                policy.getClass().getName(), pc, actives}));\r\n-        for (String target : targets) \r\n-            if (!actives.contains(target))\r\n-                throw new UserException(_loc.get(\"bad-policy-slice\", \r\n-                   new Object[] {policy.getClass().getName(), target, pc, \r\n-                    actives}));\r\n-\t}\r\n-\t\r\n-    /**\r\n-     * Gets the target slices for the given StateManager.\r\n-     */\r\n-    public static SliceInfo getSlicesByPolicy(OpenJPAStateManager sm, \r\n-        DistributedConfiguration conf, Object ctx) {\r\n-        return getSlicesByPolicy(sm.getPersistenceCapable(), conf, ctx);\r\n-    }\r\n-    \r\n-    \r\n-\t/**\r\n-\t * Affirms if the given instance be replicated to multiple slices.\r\n-\t */\r\n-\tpublic static boolean isReplicated(Object pc, OpenJPAConfiguration conf) {\r\n-\t\tif (pc == null)\r\n-\t\t\treturn false;\r\n-\t\tClassMetaData meta = conf.getMetaDataRepositoryInstance()\r\n-\t\t\t.getMetaData(pc.getClass(), null, false);\r\n-\t\treturn (meta == null) ? false : meta.isReplicated();\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Affirms if the given instance be replicated to multiple slices.\r\n-\t */\r\n-\tpublic static boolean isReplicated(OpenJPAStateManager sm) {\r\n-\t\tif (sm == null)\r\n-\t\t\treturn false;\r\n-\t\treturn sm.getMetaData().isReplicated();\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Affirms if the given StateManager has an assigned slice.\r\n-\t */\r\n-\tpublic static boolean isSliceAssigned(OpenJPAStateManager sm) {\r\n-\t     return sm != null && sm.getImplData() != null \r\n-\t         && sm.getImplData() instanceof SliceInfo;\r\n-\t}\r\n-\r\n-    /**\r\n-     * Gets the assigned slice information, if any, from the given StateManager.\r\n-     */\r\n-    public static SliceInfo getSliceInfo(OpenJPAStateManager sm) {\r\n-        return isSliceAssigned(sm) ? (SliceInfo) sm.getImplData() : null;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.List;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Utility methods to determine the target slices for a persistence capable\n+ * instance by calling back to user-specified distribution policy.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public class SliceImplHelper {\n+\tprivate static final Localizer _loc =\n+\t\tLocalizer.forPackage(SliceImplHelper.class);\n+\t\n+\t/**\n+\t * Gets the target slices by calling user-specified \n+\t * {@link DistributionPolicy} or {@link ReplicationPolicy} \n+\t * depending on whether the given instance is {@link Replicated replicated}.\n+\t */\n+\tpublic static SliceInfo getSlicesByPolicy(Object pc, \n+\t\t\tDistributedConfiguration conf, Object ctx) {\n+\t\tList<String> actives = conf.getActiveSliceNames();\n+\t\tObject policy = null;\n+\t\tString[] targets = null;\n+\t\tboolean replicated = isReplicated(pc, conf);\n+\t\tif (replicated) {\n+\t\t\tpolicy = conf.getReplicationPolicyInstance();\n+\t\t\ttargets = ((ReplicationPolicy)policy).replicate(pc, actives, ctx);\n+\t\t} else {\n+\t\t\tpolicy = conf.getDistributionPolicyInstance();\n+\t\t\ttargets = new String[]{((DistributionPolicy)policy).distribute \n+\t\t\t\t(pc, actives, ctx)};\n+\t\t}\n+\t\tassertSlices(targets, pc, conf.getActiveSliceNames(), policy);\n+\t\treturn new SliceInfo(replicated, targets);\n+\t}\n+\t\n+\tprivate static void assertSlices(String[] targets, Object pc, \n+\t    List<String> actives, Object policy) {\n+\t    if (targets == null || targets.length == 0)\n+            throw new UserException(_loc.get(\"no-policy-slice\", new Object[] {\n+                policy.getClass().getName(), pc, actives}));\n+        for (String target : targets) \n+            if (!actives.contains(target))\n+                throw new UserException(_loc.get(\"bad-policy-slice\", \n+                   new Object[] {policy.getClass().getName(), target, pc, \n+                    actives}));\n+\t}\n+\t\n+    /**\n+     * Gets the target slices for the given StateManager.\n+     */\n+    public static SliceInfo getSlicesByPolicy(OpenJPAStateManager sm, \n+        DistributedConfiguration conf, Object ctx) {\n+        return getSlicesByPolicy(sm.getPersistenceCapable(), conf, ctx);\n+    }\n+    \n+    \n+\t/**\n+\t * Affirms if the given instance be replicated to multiple slices.\n+\t */\n+\tpublic static boolean isReplicated(Object pc, OpenJPAConfiguration conf) {\n+\t\tif (pc == null)\n+\t\t\treturn false;\n+\t\tClassMetaData meta = conf.getMetaDataRepositoryInstance()\n+\t\t\t.getMetaData(pc.getClass(), null, false);\n+\t\treturn (meta == null) ? false : meta.isReplicated();\n+\t}\n+\n+\t/**\n+\t * Affirms if the given instance be replicated to multiple slices.\n+\t */\n+\tpublic static boolean isReplicated(OpenJPAStateManager sm) {\n+\t\tif (sm == null)\n+\t\t\treturn false;\n+\t\treturn sm.getMetaData().isReplicated();\n+\t}\n+\t\n+\t/**\n+\t * Affirms if the given StateManager has an assigned slice.\n+\t */\n+\tpublic static boolean isSliceAssigned(OpenJPAStateManager sm) {\n+\t     return sm != null && sm.getImplData() != null \n+\t         && sm.getImplData() instanceof SliceInfo;\n+\t}\n+\n+    /**\n+     * Gets the assigned slice information, if any, from the given StateManager.\n+     */\n+    public static SliceInfo getSliceInfo(OpenJPAStateManager sm) {\n+        return isSliceAssigned(sm) ? (SliceInfo) sm.getImplData() : null;\n+    }\n+}"},{"sha":"649df7cbddae6fba8f970c7a8cda1c0ee295015b","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceInfo.java","status":"modified","additions":117,"deletions":117,"changes":234,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceInfo.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceInfo.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,117 +1,117 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.io.Serializable;\r\n-import java.util.List;\r\n-\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.InternalException;\r\n-\r\n-/**\r\n- * Holder of slice names where a persistent instance is stored. This structure\r\n- * is held in StateManagers to track the origin of a persistent instance.\r\n- * \r\n- * @author Pinaki Poddar\r\n- *\r\n- */\r\n-@SuppressWarnings(\"serial\")\r\n-public class SliceInfo implements Serializable {\r\n-\tprivate final boolean  _isReplicated;\r\n-\tprivate String[] _slices;\r\n-\t\r\n-\tprivate static transient Localizer _loc = \r\n-\t\tLocalizer.forPackage(SliceInfo.class);\r\n-\t\r\n-    /**\r\n-     * Generic constructor given one or more slice names. \r\n-     * The replicated flag is set independently.\r\n-     */\r\n-    public SliceInfo(boolean replicated, String[] slices) {\r\n-        super();\r\n-        if (slices == null || slices.length == 0)\r\n-            throw new InternalException();\r\n-        _isReplicated = replicated;\r\n-        _slices = slices;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Generic constructor given one or more slice names. \r\n-     * The replicated flag is set independently.\r\n-     */\r\n-    public SliceInfo(boolean replicated, List<String> slices) {\r\n-        super();\r\n-        if (slices == null || slices.isEmpty())\r\n-            throw new InternalException();\r\n-        _isReplicated = replicated;\r\n-        _slices = slices.toArray(new String[slices.size()]);\r\n-    }\r\n-\t\r\n-\t/**\r\n-\t * Constructor for non-replicated instance that is stored in a single slice. \r\n-\t */\r\n-    public SliceInfo(String slice) {\r\n-\t\tthis(false, new String[]{slice});\r\n-\t}\r\n-\t\r\n-    /**\r\n-     * Constructor for replicated instance that is stored in one or more slices. \r\n-     */\r\n-    public SliceInfo(String[] slices) {\r\n-        this(true, slices);\r\n-    }\r\n-    \r\n-    public SliceInfo(List<String> slices) {\r\n-        this(true, slices);\r\n-    }\r\n-\r\n-    /**\r\n-     * Affirms if this receiver designates replicated instances.\r\n-     * @return\r\n-     */\r\n-\tpublic boolean isReplicated() {\r\n-\t\treturn _isReplicated;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Gets the name of the slice(s) held by this receiver.\r\n-\t */\r\n-\tpublic String[] getSlices() {\r\n-\t\treturn _slices;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Sets this receiver as the given StateManager's internal instance-level \r\n-\t * data. If the given StateManager had existing instance-level data that is\r\n-\t * not a SliceInfo then raise an exception.\r\n-\t */\r\n-\tpublic SliceInfo setInto(OpenJPAStateManager sm) {\r\n-\t\tif (sm == null)\r\n-\t\t\tthrow new NullPointerException();\r\n-\t\tif (SliceImplHelper.isReplicated(sm) != isReplicated())\r\n-\t\t    throw new InternalException();\r\n-\t\tObject previous = sm.setImplData(this, true);\r\n-\t\tif (previous == null || previous instanceof SliceInfo)\r\n-\t\t\treturn (SliceInfo)previous;\r\n-\t\tthrow new InternalException(_loc.get(\"unknown-impl-data\", previous, \r\n-\t\t    previous.getClass().getName(), sm.getPersistenceCapable())\r\n-\t\t    .getMessage());\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.io.Serializable;\n+import java.util.List;\n+\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InternalException;\n+\n+/**\n+ * Holder of slice names where a persistent instance is stored. This structure\n+ * is held in StateManagers to track the origin of a persistent instance.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+@SuppressWarnings(\"serial\")\n+public class SliceInfo implements Serializable {\n+\tprivate final boolean  _isReplicated;\n+\tprivate String[] _slices;\n+\t\n+\tprivate static transient Localizer _loc = \n+\t\tLocalizer.forPackage(SliceInfo.class);\n+\t\n+    /**\n+     * Generic constructor given one or more slice names. \n+     * The replicated flag is set independently.\n+     */\n+    public SliceInfo(boolean replicated, String[] slices) {\n+        super();\n+        if (slices == null || slices.length == 0)\n+            throw new InternalException();\n+        _isReplicated = replicated;\n+        _slices = slices;\n+    }\n+    \n+    /**\n+     * Generic constructor given one or more slice names. \n+     * The replicated flag is set independently.\n+     */\n+    public SliceInfo(boolean replicated, List<String> slices) {\n+        super();\n+        if (slices == null || slices.isEmpty())\n+            throw new InternalException();\n+        _isReplicated = replicated;\n+        _slices = slices.toArray(new String[slices.size()]);\n+    }\n+\t\n+\t/**\n+\t * Constructor for non-replicated instance that is stored in a single slice. \n+\t */\n+    public SliceInfo(String slice) {\n+\t\tthis(false, new String[]{slice});\n+\t}\n+\t\n+    /**\n+     * Constructor for replicated instance that is stored in one or more slices. \n+     */\n+    public SliceInfo(String[] slices) {\n+        this(true, slices);\n+    }\n+    \n+    public SliceInfo(List<String> slices) {\n+        this(true, slices);\n+    }\n+\n+    /**\n+     * Affirms if this receiver designates replicated instances.\n+     * @return\n+     */\n+\tpublic boolean isReplicated() {\n+\t\treturn _isReplicated;\n+\t}\n+\n+\t/**\n+\t * Gets the name of the slice(s) held by this receiver.\n+\t */\n+\tpublic String[] getSlices() {\n+\t\treturn _slices;\n+\t}\n+\t\n+\t/**\n+\t * Sets this receiver as the given StateManager's internal instance-level \n+\t * data. If the given StateManager had existing instance-level data that is\n+\t * not a SliceInfo then raise an exception.\n+\t */\n+\tpublic SliceInfo setInto(OpenJPAStateManager sm) {\n+\t\tif (sm == null)\n+\t\t\tthrow new NullPointerException();\n+\t\tif (SliceImplHelper.isReplicated(sm) != isReplicated())\n+\t\t    throw new InternalException();\n+\t\tObject previous = sm.setImplData(this, true);\n+\t\tif (previous == null || previous instanceof SliceInfo)\n+\t\t\treturn (SliceInfo)previous;\n+\t\tthrow new InternalException(_loc.get(\"unknown-impl-data\", previous, \n+\t\t    previous.getClass().getName(), sm.getPersistenceCapable())\n+\t\t    .getMessage());\n+\t}\n+}"},{"sha":"b494832a65b49b322822ef9fb2294150db6d9f7c","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/SlicePersistence.java","status":"modified","additions":79,"deletions":79,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/SlicePersistence.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/SlicePersistence.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/SlicePersistence.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,79 +1,79 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.Arrays;\r\n-\r\n-import org.apache.openjpa.enhance.PersistenceCapable;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-\r\n-/**\r\n- * A helper to determine the slice identifier of an instance.\r\n- * \r\n- * @author Pinaki Poddar \r\n- *\r\n- */\r\n-public class SlicePersistence {\r\n-    /**\r\n-     * The key for setting the Query hints. The value is comma-separated Slice\r\n-     * names. If the hint is specified then the query is executed only on the\r\n-     * listed slices. \r\n-     */\r\n-    public static final String HINT_TARGET = ProductDerivation.HINT_TARGET;\r\n-    \r\n-\t/**\r\n-\t * Get the slice identifier for the given instance if it is a managed\r\n-\t * instance and has been assigned to a slice.\r\n-\t * If the given instance is replicated across multiple slices then returns\r\n-\t * comma-separated list of slice names.\r\n-\t * \r\n-\t * @return name of the slice, if any. null otherwise.\r\n-\t */\r\n-\tpublic static String getSlice(Object obj) {\r\n-\t\tif (obj == null)\r\n-\t\t\treturn null;\r\n-\t\tPersistenceCapable pc = ImplHelper.toPersistenceCapable(obj, null);\r\n-\t\tif (pc == null)\r\n-\t\t\treturn null;\r\n-\t\tOpenJPAStateManager sm = (OpenJPAStateManager)pc.pcGetStateManager();\r\n-        SliceInfo info = SliceImplHelper.getSliceInfo(sm);\r\n-\t\tif (info == null)\r\n-\t\t\treturn null;\r\n-\t\tString[] names = info.getSlices();\r\n-\t\treturn info.isReplicated() ? Arrays.toString(names) : names[0];\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Affirms if the given instance is replicated, provided the given instance \r\n-\t * is managed.\r\n-     */\r\n-    public static boolean isReplicated(Object obj) {\r\n-        if (obj == null)\r\n-            return false;\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(obj, null);\r\n-        if (pc == null)\r\n-            return false;\r\n-        OpenJPAStateManager sm = (OpenJPAStateManager)pc.pcGetStateManager();\r\n-        SliceInfo info = SliceImplHelper.getSliceInfo(sm);\r\n-        if (info == null)\r\n-            return false;\r\n-        return info.isReplicated();\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.Arrays;\n+\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.util.ImplHelper;\n+\n+/**\n+ * A helper to determine the slice identifier of an instance.\n+ * \n+ * @author Pinaki Poddar \n+ *\n+ */\n+public class SlicePersistence {\n+    /**\n+     * The key for setting the Query hints. The value is comma-separated Slice\n+     * names. If the hint is specified then the query is executed only on the\n+     * listed slices. \n+     */\n+    public static final String HINT_TARGET = ProductDerivation.HINT_TARGET;\n+    \n+\t/**\n+\t * Get the slice identifier for the given instance if it is a managed\n+\t * instance and has been assigned to a slice.\n+\t * If the given instance is replicated across multiple slices then returns\n+\t * comma-separated list of slice names.\n+\t * \n+\t * @return name of the slice, if any. null otherwise.\n+\t */\n+\tpublic static String getSlice(Object obj) {\n+\t\tif (obj == null)\n+\t\t\treturn null;\n+\t\tPersistenceCapable pc = ImplHelper.toPersistenceCapable(obj, null);\n+\t\tif (pc == null)\n+\t\t\treturn null;\n+\t\tOpenJPAStateManager sm = (OpenJPAStateManager)pc.pcGetStateManager();\n+        SliceInfo info = SliceImplHelper.getSliceInfo(sm);\n+\t\tif (info == null)\n+\t\t\treturn null;\n+\t\tString[] names = info.getSlices();\n+\t\treturn info.isReplicated() ? Arrays.toString(names) : names[0];\n+\t}\n+\t\n+\t/**\n+\t * Affirms if the given instance is replicated, provided the given instance \n+\t * is managed.\n+     */\n+    public static boolean isReplicated(Object obj) {\n+        if (obj == null)\n+            return false;\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(obj, null);\n+        if (pc == null)\n+            return false;\n+        OpenJPAStateManager sm = (OpenJPAStateManager)pc.pcGetStateManager();\n+        SliceInfo info = SliceImplHelper.getSliceInfo(sm);\n+        if (info == null)\n+            return false;\n+        return info.isReplicated();\n+    }\n+}"},{"sha":"5878bd9ad73fe3f7b240b5db3f04ba1d9491cb13","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceThread.java","status":"modified","additions":74,"deletions":74,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceThread.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceThread.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceThread.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,74 +1,74 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.concurrent.ExecutorService;\r\n-import java.util.concurrent.SynchronousQueue;\r\n-import java.util.concurrent.ThreadFactory;\r\n-import java.util.concurrent.ThreadPoolExecutor;\r\n-import java.util.concurrent.TimeUnit;\r\n-\r\n-/**\r\n- * A thread to execute operation against each database slice.\r\n- * \r\n- * @author Pinaki Poddar\r\n- *\r\n- */\r\n-public class SliceThread extends Thread {\r\n-    private final Thread _parent;\r\n-\r\n-    public SliceThread(String name, Thread parent, Runnable r) {\r\n-        super(r, name);\r\n-        _parent = parent;\r\n-    }\r\n-    \r\n-    public SliceThread(Thread parent, Runnable r) {\r\n-        super(r);\r\n-        _parent = parent;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Gets the parent thread of this receiver.\r\n-     * \r\n-     */\r\n-    public Thread getParent() {\r\n-        return _parent;\r\n-    }\r\n-    \r\n-    /** \r\n-     * Create a pool of given size.\r\n-     * The thread factory is specialized to create SliceThread which gets\r\n-     * preferential treatment for locking.\r\n-     * \r\n-     */\r\n-\r\n-    public static ExecutorService newPool(int size) {\r\n-        return new ThreadPoolExecutor(size, size, 60L, TimeUnit.SECONDS, \r\n-            new SynchronousQueue<Runnable>(), new SliceThreadFactory());\r\n-    }\r\n-    \r\n-    static class SliceThreadFactory implements ThreadFactory {\r\n-        int n = 0;\r\n-        public Thread newThread(Runnable r) {\r\n-            Thread parent = Thread.currentThread();\r\n-            return new SliceThread(parent.getName()+\"-slice-\"+n++, parent, r);\r\n-        }\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A thread to execute operation against each database slice.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public class SliceThread extends Thread {\n+    private final Thread _parent;\n+\n+    public SliceThread(String name, Thread parent, Runnable r) {\n+        super(r, name);\n+        _parent = parent;\n+    }\n+    \n+    public SliceThread(Thread parent, Runnable r) {\n+        super(r);\n+        _parent = parent;\n+    }\n+    \n+    /**\n+     * Gets the parent thread of this receiver.\n+     * \n+     */\n+    public Thread getParent() {\n+        return _parent;\n+    }\n+    \n+    /** \n+     * Create a pool of given size.\n+     * The thread factory is specialized to create SliceThread which gets\n+     * preferential treatment for locking.\n+     * \n+     */\n+\n+    public static ExecutorService newPool(int size) {\n+        return new ThreadPoolExecutor(size, size, 60L, TimeUnit.SECONDS, \n+            new SynchronousQueue<Runnable>(), new SliceThreadFactory());\n+    }\n+    \n+    static class SliceThreadFactory implements ThreadFactory {\n+        int n = 0;\n+        public Thread newThread(Runnable r) {\n+            Thread parent = Thread.currentThread();\n+            return new SliceThread(parent.getName()+\"-slice-\"+n++, parent, r);\n+        }\n+    }\n+\n+}"},{"sha":"4129f23c88810ace0ea636d2e20a1541bdc25953","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedConnection.java","status":"modified","additions":263,"deletions":263,"changes":526,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedConnection.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedConnection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedConnection.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,263 +1,263 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.jdbc;\r\n-\r\n-import java.sql.CallableStatement;\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.PreparedStatement;\r\n-import java.sql.SQLException;\r\n-import java.sql.SQLWarning;\r\n-import java.sql.Savepoint;\r\n-import java.sql.Statement;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-/**\r\n- * A virtual connection that contains multiple physical connections.\r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- */\r\n-class DistributedConnection implements Connection {\r\n-\tprivate final List<Connection> real;\r\n-\tprivate final Connection master;\r\n-\r\n-\tpublic DistributedConnection(List<Connection> connections) {\r\n-\t\tif (connections == null || connections.isEmpty())\r\n-\t\t\tthrow new NullPointerException();\r\n-\t\treal = connections;\r\n-\t\tmaster = connections.get(0);\r\n-\t}\r\n-\t\r\n-\tpublic boolean contains(Connection c) {\r\n-\t\treturn real.contains(c);\r\n-\t}\r\n-\r\n-\tpublic void clearWarnings() throws SQLException {\r\n-\t\tfor (Connection c : real)\r\n-\t\t\tc.clearWarnings();\r\n-\t}\r\n-\r\n-\tpublic void close() throws SQLException {\r\n-\t\tfor (Connection c : real)\r\n-\t\t\tc.close();\r\n-\t}\r\n-\r\n-\tpublic void commit() throws SQLException {\r\n-\t\tfor (Connection c : real)\r\n-\t\t\tc.commit();\r\n-\t}\r\n-\r\n-\tpublic Statement createStatement() throws SQLException {\r\n-\t\tDistributedStatement ret = new DistributedStatement(this);\r\n-\t\tfor (Connection c : real) {\r\n-\t\t\tret.add(c.createStatement());\r\n-\t\t}\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic Statement createStatement(int arg0, int arg1) throws SQLException {\r\n-\t\tDistributedStatement ret = new DistributedStatement(this);\r\n-\t\tfor (Connection c : real) {\r\n-\t\t\tret.add(c.createStatement(arg0, arg1));\r\n-\t\t}\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic Statement createStatement(int arg0, int arg1, int arg2)\r\n-\t\t\tthrows SQLException {\r\n-\t\tDistributedStatement ret = new DistributedStatement(this);\r\n-\t\tfor (Connection c : real) {\r\n-\t\t\tret.add(c.createStatement(arg0, arg1, arg2));\r\n-\t\t}\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic boolean getAutoCommit() throws SQLException {\r\n-\t\treturn master.getAutoCommit();\r\n-\t}\r\n-\r\n-\tpublic String getCatalog() throws SQLException {\r\n-\t\treturn master.getCatalog();\r\n-\t}\r\n-\r\n-\tpublic int getHoldability() throws SQLException {\r\n-\t\treturn master.getHoldability();\r\n-\t}\r\n-\r\n-\tpublic DatabaseMetaData getMetaData() throws SQLException {\r\n-\t\treturn master.getMetaData();\r\n-\t}\r\n-\r\n-\tpublic int getTransactionIsolation() throws SQLException {\r\n-\t\treturn master.getTransactionIsolation();\r\n-\t}\r\n-\r\n-\tpublic Map<String, Class<?>> getTypeMap() throws SQLException {\r\n-\t\treturn master.getTypeMap();\r\n-\t}\r\n-\r\n-\tpublic SQLWarning getWarnings() throws SQLException {\r\n-\t\treturn master.getWarnings();\r\n-\t}\r\n-\r\n-\tpublic boolean isClosed() throws SQLException {\r\n-\t\tboolean ret = true;\r\n-\t\tfor (Connection c : real) {\r\n-\t\t\tret &= c.isClosed();\r\n-\t\t}\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic boolean isReadOnly() throws SQLException {\r\n-\t\tboolean ret = true;\r\n-\t\tfor (Connection c : real) {\r\n-\t\t\tret &= c.isReadOnly();\r\n-\t\t}\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic String nativeSQL(String arg0) throws SQLException {\r\n-\t\treturn master.nativeSQL(arg0);\r\n-\t}\r\n-\r\n-\tpublic CallableStatement prepareCall(String arg0) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic CallableStatement prepareCall(String arg0, int arg1, int arg2)\r\n-\t\t\tthrows SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic CallableStatement prepareCall(String arg0, int arg1, int arg2,\r\n-\t\t\tint arg3) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic PreparedStatement prepareStatement(String arg0) throws SQLException {\r\n-\t\t// TODO: Big hack\r\n-\t\tif (arg0.startsWith(\"SELECT SEQUENCE_VALUE FROM OPENJPA_SEQUENCE_TABLE\"))\r\n-\t\t\treturn master.prepareStatement(arg0);\r\n-\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\r\n-\t\tfor (Connection c : real) {\r\n-\t\t\tret.add(c.prepareStatement(arg0));\r\n-\t\t}\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic PreparedStatement prepareStatement(String arg0, int arg1)\r\n-\t\t\tthrows SQLException {\r\n-\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\r\n-\t\tfor (Connection c : real) {\r\n-\t\t\tret.add(c.prepareStatement(arg0, arg1));\r\n-\t\t}\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic PreparedStatement prepareStatement(String arg0, int[] arg1)\r\n-\t\t\tthrows SQLException {\r\n-\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\r\n-\t\tfor (Connection c : real) {\r\n-\t\t\tret.add(c.prepareStatement(arg0, arg1));\r\n-\t\t}\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic PreparedStatement prepareStatement(String arg0, String[] arg1)\r\n-\t\t\tthrows SQLException {\r\n-\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\r\n-\t\tfor (Connection c : real) {\r\n-\t\t\tret.add(c.prepareStatement(arg0, arg1));\r\n-\t\t}\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic PreparedStatement prepareStatement(String arg0, int arg1, int arg2)\r\n-\t\t\tthrows SQLException {\r\n-\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\r\n-\t\tfor (Connection c : real) {\r\n-\t\t\tret.add(c.prepareStatement(arg0, arg1, arg2));\r\n-\t\t}\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic PreparedStatement prepareStatement(String arg0, int arg1, int arg2,\r\n-\t\t\tint arg3) throws SQLException {\r\n-\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\r\n-\t\tfor (Connection c : real) {\r\n-\t\t\tret.add(c.prepareStatement(arg0, arg1, arg2));\r\n-\t\t}\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic void releaseSavepoint(Savepoint arg0) throws SQLException {\r\n-\t\tfor (Connection c : real)\r\n-\t\t\tc.releaseSavepoint(arg0);\r\n-\t}\r\n-\r\n-\tpublic void rollback() throws SQLException {\r\n-\t\tfor (Connection c : real)\r\n-\t\t\tc.rollback();\r\n-\t}\r\n-\r\n-\tpublic void rollback(Savepoint arg0) throws SQLException {\r\n-\t\tfor (Connection c : real)\r\n-\t\t\tc.rollback(arg0);\r\n-\t}\r\n-\r\n-\tpublic void setAutoCommit(boolean arg0) throws SQLException {\r\n-\t\tfor (Connection c : real)\r\n-\t\t\tc.setAutoCommit(arg0);\r\n-\t}\r\n-\r\n-\tpublic void setCatalog(String arg0) throws SQLException {\r\n-\t\tfor (Connection c : real)\r\n-\t\t\tc.setCatalog(arg0);\r\n-\t}\r\n-\r\n-\tpublic void setHoldability(int arg0) throws SQLException {\r\n-\t\tfor (Connection c : real)\r\n-\t\t\tc.setHoldability(arg0);\r\n-\t}\r\n-\r\n-\tpublic void setReadOnly(boolean arg0) throws SQLException {\r\n-\t\tfor (Connection c : real)\r\n-\t\t\tc.setReadOnly(arg0);\r\n-\t}\r\n-\r\n-\tpublic Savepoint setSavepoint() throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic Savepoint setSavepoint(String arg0) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void setTransactionIsolation(int arg0) throws SQLException {\r\n-\t\tfor (Connection c : real)\r\n-\t\t\tc.setTransactionIsolation(arg0);\r\n-\t}\r\n-\r\n-\tpublic void setTypeMap(Map<String, Class<?>> arg0) throws SQLException {\r\n-\t\tfor (Connection c : real)\r\n-\t\t\tc.setTypeMap(arg0);\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.jdbc;\n+\n+import java.sql.CallableStatement;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.SQLWarning;\n+import java.sql.Savepoint;\n+import java.sql.Statement;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * A virtual connection that contains multiple physical connections.\n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+class DistributedConnection implements Connection {\n+\tprivate final List<Connection> real;\n+\tprivate final Connection master;\n+\n+\tpublic DistributedConnection(List<Connection> connections) {\n+\t\tif (connections == null || connections.isEmpty())\n+\t\t\tthrow new NullPointerException();\n+\t\treal = connections;\n+\t\tmaster = connections.get(0);\n+\t}\n+\t\n+\tpublic boolean contains(Connection c) {\n+\t\treturn real.contains(c);\n+\t}\n+\n+\tpublic void clearWarnings() throws SQLException {\n+\t\tfor (Connection c : real)\n+\t\t\tc.clearWarnings();\n+\t}\n+\n+\tpublic void close() throws SQLException {\n+\t\tfor (Connection c : real)\n+\t\t\tc.close();\n+\t}\n+\n+\tpublic void commit() throws SQLException {\n+\t\tfor (Connection c : real)\n+\t\t\tc.commit();\n+\t}\n+\n+\tpublic Statement createStatement() throws SQLException {\n+\t\tDistributedStatement ret = new DistributedStatement(this);\n+\t\tfor (Connection c : real) {\n+\t\t\tret.add(c.createStatement());\n+\t\t}\n+\t\treturn ret;\n+\t}\n+\n+\tpublic Statement createStatement(int arg0, int arg1) throws SQLException {\n+\t\tDistributedStatement ret = new DistributedStatement(this);\n+\t\tfor (Connection c : real) {\n+\t\t\tret.add(c.createStatement(arg0, arg1));\n+\t\t}\n+\t\treturn ret;\n+\t}\n+\n+\tpublic Statement createStatement(int arg0, int arg1, int arg2)\n+\t\t\tthrows SQLException {\n+\t\tDistributedStatement ret = new DistributedStatement(this);\n+\t\tfor (Connection c : real) {\n+\t\t\tret.add(c.createStatement(arg0, arg1, arg2));\n+\t\t}\n+\t\treturn ret;\n+\t}\n+\n+\tpublic boolean getAutoCommit() throws SQLException {\n+\t\treturn master.getAutoCommit();\n+\t}\n+\n+\tpublic String getCatalog() throws SQLException {\n+\t\treturn master.getCatalog();\n+\t}\n+\n+\tpublic int getHoldability() throws SQLException {\n+\t\treturn master.getHoldability();\n+\t}\n+\n+\tpublic DatabaseMetaData getMetaData() throws SQLException {\n+\t\treturn master.getMetaData();\n+\t}\n+\n+\tpublic int getTransactionIsolation() throws SQLException {\n+\t\treturn master.getTransactionIsolation();\n+\t}\n+\n+\tpublic Map<String, Class<?>> getTypeMap() throws SQLException {\n+\t\treturn master.getTypeMap();\n+\t}\n+\n+\tpublic SQLWarning getWarnings() throws SQLException {\n+\t\treturn master.getWarnings();\n+\t}\n+\n+\tpublic boolean isClosed() throws SQLException {\n+\t\tboolean ret = true;\n+\t\tfor (Connection c : real) {\n+\t\t\tret &= c.isClosed();\n+\t\t}\n+\t\treturn ret;\n+\t}\n+\n+\tpublic boolean isReadOnly() throws SQLException {\n+\t\tboolean ret = true;\n+\t\tfor (Connection c : real) {\n+\t\t\tret &= c.isReadOnly();\n+\t\t}\n+\t\treturn ret;\n+\t}\n+\n+\tpublic String nativeSQL(String arg0) throws SQLException {\n+\t\treturn master.nativeSQL(arg0);\n+\t}\n+\n+\tpublic CallableStatement prepareCall(String arg0) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic CallableStatement prepareCall(String arg0, int arg1, int arg2)\n+\t\t\tthrows SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic CallableStatement prepareCall(String arg0, int arg1, int arg2,\n+\t\t\tint arg3) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic PreparedStatement prepareStatement(String arg0) throws SQLException {\n+\t\t// TODO: Big hack\n+\t\tif (arg0.startsWith(\"SELECT SEQUENCE_VALUE FROM OPENJPA_SEQUENCE_TABLE\"))\n+\t\t\treturn master.prepareStatement(arg0);\n+\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\n+\t\tfor (Connection c : real) {\n+\t\t\tret.add(c.prepareStatement(arg0));\n+\t\t}\n+\t\treturn ret;\n+\t}\n+\n+\tpublic PreparedStatement prepareStatement(String arg0, int arg1)\n+\t\t\tthrows SQLException {\n+\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\n+\t\tfor (Connection c : real) {\n+\t\t\tret.add(c.prepareStatement(arg0, arg1));\n+\t\t}\n+\t\treturn ret;\n+\t}\n+\n+\tpublic PreparedStatement prepareStatement(String arg0, int[] arg1)\n+\t\t\tthrows SQLException {\n+\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\n+\t\tfor (Connection c : real) {\n+\t\t\tret.add(c.prepareStatement(arg0, arg1));\n+\t\t}\n+\t\treturn ret;\n+\t}\n+\n+\tpublic PreparedStatement prepareStatement(String arg0, String[] arg1)\n+\t\t\tthrows SQLException {\n+\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\n+\t\tfor (Connection c : real) {\n+\t\t\tret.add(c.prepareStatement(arg0, arg1));\n+\t\t}\n+\t\treturn ret;\n+\t}\n+\n+\tpublic PreparedStatement prepareStatement(String arg0, int arg1, int arg2)\n+\t\t\tthrows SQLException {\n+\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\n+\t\tfor (Connection c : real) {\n+\t\t\tret.add(c.prepareStatement(arg0, arg1, arg2));\n+\t\t}\n+\t\treturn ret;\n+\t}\n+\n+\tpublic PreparedStatement prepareStatement(String arg0, int arg1, int arg2,\n+\t\t\tint arg3) throws SQLException {\n+\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\n+\t\tfor (Connection c : real) {\n+\t\t\tret.add(c.prepareStatement(arg0, arg1, arg2));\n+\t\t}\n+\t\treturn ret;\n+\t}\n+\n+\tpublic void releaseSavepoint(Savepoint arg0) throws SQLException {\n+\t\tfor (Connection c : real)\n+\t\t\tc.releaseSavepoint(arg0);\n+\t}\n+\n+\tpublic void rollback() throws SQLException {\n+\t\tfor (Connection c : real)\n+\t\t\tc.rollback();\n+\t}\n+\n+\tpublic void rollback(Savepoint arg0) throws SQLException {\n+\t\tfor (Connection c : real)\n+\t\t\tc.rollback(arg0);\n+\t}\n+\n+\tpublic void setAutoCommit(boolean arg0) throws SQLException {\n+\t\tfor (Connection c : real)\n+\t\t\tc.setAutoCommit(arg0);\n+\t}\n+\n+\tpublic void setCatalog(String arg0) throws SQLException {\n+\t\tfor (Connection c : real)\n+\t\t\tc.setCatalog(arg0);\n+\t}\n+\n+\tpublic void setHoldability(int arg0) throws SQLException {\n+\t\tfor (Connection c : real)\n+\t\t\tc.setHoldability(arg0);\n+\t}\n+\n+\tpublic void setReadOnly(boolean arg0) throws SQLException {\n+\t\tfor (Connection c : real)\n+\t\t\tc.setReadOnly(arg0);\n+\t}\n+\n+\tpublic Savepoint setSavepoint() throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic Savepoint setSavepoint(String arg0) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void setTransactionIsolation(int arg0) throws SQLException {\n+\t\tfor (Connection c : real)\n+\t\t\tc.setTransactionIsolation(arg0);\n+\t}\n+\n+\tpublic void setTypeMap(Map<String, Class<?>> arg0) throws SQLException {\n+\t\tfor (Connection c : real)\n+\t\t\tc.setTypeMap(arg0);\n+\t}\n+}"},{"sha":"06fca99e342fedb609b223ec9fd90d7f13097de6","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedDataSource.java","status":"modified","additions":106,"deletions":106,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedDataSource.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,106 +1,106 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.jdbc;\r\n-\r\n-import java.io.PrintWriter;\r\n-import java.sql.Connection;\r\n-import java.sql.SQLException;\r\n-import java.util.ArrayList;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-\r\n-import javax.sql.DataSource;\r\n-import javax.sql.XADataSource;\r\n-\r\n-import org.apache.openjpa.lib.jdbc.DecoratingDataSource;\r\n-\r\n-/**\r\n- * A virtual datasource that contains many physical datasources.\r\n- * \r\n- * @author Pinaki Poddar \r\n- *\r\n- */\r\n-class DistributedDataSource extends DecoratingDataSource implements\r\n-\t\tIterable<DataSource> {\r\n-\tprivate List<DataSource> real = new ArrayList<DataSource>();\r\n-\tprivate DataSource master;\r\n-\t\r\n-\tpublic DistributedDataSource(List<DataSource> dataSources) {\r\n-\t\tsuper(dataSources.get(0));\r\n-\t\treal = dataSources;\r\n-\t\tmaster = dataSources.get(0);\r\n-\t}\r\n-\t\r\n-\tpublic void addDataSource(DataSource ds) {\r\n-\t    real.add(ds);\r\n-\t}\r\n-\t\r\n-\tConnection getConnection(DataSource ds) throws SQLException {\r\n-\t\tif (ds instanceof DecoratingDataSource)\r\n-\t\t\treturn getConnection(((DecoratingDataSource)ds).getInnermostDelegate());\r\n-\t\tif (ds instanceof XADataSource)\r\n-\t\t\treturn ((XADataSource)ds).getXAConnection().getConnection();\r\n-\t\treturn ds.getConnection();\r\n-\t}\r\n-\t\r\n-\tConnection getConnection(DataSource ds, String user, String pwd) throws SQLException {\r\n-\t\tif (ds instanceof DecoratingDataSource)\r\n-\t\t\treturn getConnection(((DecoratingDataSource)ds).getInnermostDelegate(), user, pwd);\r\n-\t\tif (ds instanceof XADataSource)\r\n-\t\t\treturn ((XADataSource)ds).getXAConnection(user, pwd).getConnection();\r\n-\t\treturn ds.getConnection(user, pwd);\r\n-\t}\r\n-\r\n-\tpublic Iterator<DataSource> iterator() {\r\n-\t\treturn real.iterator();\r\n-\t}\r\n-\r\n-\tpublic Connection getConnection() throws SQLException {\r\n-\t\tList<Connection> c = new ArrayList<Connection>();\r\n-\t\tfor (DataSource ds : real)\r\n-\t\t\tc.add(ds.getConnection());\r\n-\t\treturn new DistributedConnection(c);\r\n-\t}\r\n-\r\n-\tpublic Connection getConnection(String username, String password)\r\n-\t\t\tthrows SQLException {\r\n-\t\tList<Connection> c = new ArrayList<Connection>();\r\n-\t\tfor (DataSource ds : real)\r\n-\t\t\tc.add(ds.getConnection(username, password));\r\n-\t\treturn new DistributedConnection(c);\r\n-\t}\r\n-\r\n-\tpublic PrintWriter getLogWriter() throws SQLException {\r\n-\t\treturn master.getLogWriter();\r\n-\t}\r\n-\r\n-\tpublic int getLoginTimeout() throws SQLException {\r\n-\t\treturn master.getLoginTimeout();\r\n-\t}\r\n-\r\n-\tpublic void setLogWriter(PrintWriter out) throws SQLException {\r\n-\t\tfor (DataSource ds:real)\r\n-\t\t\tds.setLogWriter(out);\r\n-\t}\r\n-\r\n-\tpublic void setLoginTimeout(int seconds) throws SQLException {\r\n-\t\tfor (DataSource ds:real)\r\n-\t\t\tds.setLoginTimeout(seconds);\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.jdbc;\n+\n+import java.io.PrintWriter;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import javax.sql.DataSource;\n+import javax.sql.XADataSource;\n+\n+import org.apache.openjpa.lib.jdbc.DecoratingDataSource;\n+\n+/**\n+ * A virtual datasource that contains many physical datasources.\n+ * \n+ * @author Pinaki Poddar \n+ *\n+ */\n+class DistributedDataSource extends DecoratingDataSource implements\n+\t\tIterable<DataSource> {\n+\tprivate List<DataSource> real = new ArrayList<DataSource>();\n+\tprivate DataSource master;\n+\t\n+\tpublic DistributedDataSource(List<DataSource> dataSources) {\n+\t\tsuper(dataSources.get(0));\n+\t\treal = dataSources;\n+\t\tmaster = dataSources.get(0);\n+\t}\n+\t\n+\tpublic void addDataSource(DataSource ds) {\n+\t    real.add(ds);\n+\t}\n+\t\n+\tConnection getConnection(DataSource ds) throws SQLException {\n+\t\tif (ds instanceof DecoratingDataSource)\n+\t\t\treturn getConnection(((DecoratingDataSource)ds).getInnermostDelegate());\n+\t\tif (ds instanceof XADataSource)\n+\t\t\treturn ((XADataSource)ds).getXAConnection().getConnection();\n+\t\treturn ds.getConnection();\n+\t}\n+\t\n+\tConnection getConnection(DataSource ds, String user, String pwd) throws SQLException {\n+\t\tif (ds instanceof DecoratingDataSource)\n+\t\t\treturn getConnection(((DecoratingDataSource)ds).getInnermostDelegate(), user, pwd);\n+\t\tif (ds instanceof XADataSource)\n+\t\t\treturn ((XADataSource)ds).getXAConnection(user, pwd).getConnection();\n+\t\treturn ds.getConnection(user, pwd);\n+\t}\n+\n+\tpublic Iterator<DataSource> iterator() {\n+\t\treturn real.iterator();\n+\t}\n+\n+\tpublic Connection getConnection() throws SQLException {\n+\t\tList<Connection> c = new ArrayList<Connection>();\n+\t\tfor (DataSource ds : real)\n+\t\t\tc.add(ds.getConnection());\n+\t\treturn new DistributedConnection(c);\n+\t}\n+\n+\tpublic Connection getConnection(String username, String password)\n+\t\t\tthrows SQLException {\n+\t\tList<Connection> c = new ArrayList<Connection>();\n+\t\tfor (DataSource ds : real)\n+\t\t\tc.add(ds.getConnection(username, password));\n+\t\treturn new DistributedConnection(c);\n+\t}\n+\n+\tpublic PrintWriter getLogWriter() throws SQLException {\n+\t\treturn master.getLogWriter();\n+\t}\n+\n+\tpublic int getLoginTimeout() throws SQLException {\n+\t\treturn master.getLoginTimeout();\n+\t}\n+\n+\tpublic void setLogWriter(PrintWriter out) throws SQLException {\n+\t\tfor (DataSource ds:real)\n+\t\t\tds.setLogWriter(out);\n+\t}\n+\n+\tpublic void setLoginTimeout(int seconds) throws SQLException {\n+\t\tfor (DataSource ds:real)\n+\t\t\tds.setLoginTimeout(seconds);\n+\t}\n+}"},{"sha":"7e558a0f9c5990c118b1ee10d6c70480e8309dc4","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCBrokerFactory.java","status":"modified","additions":119,"deletions":119,"changes":238,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCBrokerFactory.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,119 +1,119 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.jdbc;\r\n-\r\n-import java.security.AccessController;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAVersion;\r\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n-import org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory;\r\n-import org.apache.openjpa.kernel.Bootstrap;\r\n-import org.apache.openjpa.kernel.StoreManager;\r\n-import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n-import org.apache.openjpa.lib.util.J2DoPrivHelper;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.slice.DistributedBrokerFactory;\r\n-import org.apache.openjpa.slice.Slice;\r\n-\r\n-/**\r\n- * A factory for distributed JDBC datastores.\r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- */\r\n-@SuppressWarnings(\"serial\")\r\n-public class DistributedJDBCBrokerFactory extends JDBCBrokerFactory \r\n-    implements DistributedBrokerFactory {\r\n-\tprivate static final Localizer _loc = \r\n-\t    Localizer.forPackage(DistributedJDBCBrokerFactory.class);\r\n-\t/**\r\n-\t * Factory method for constructing a factory from properties. Invoked from\r\n-\t * {@link Bootstrap#newBrokerFactory}.\r\n-\t */\r\n-\tpublic static DistributedJDBCBrokerFactory newInstance(\r\n-\t\t\tConfigurationProvider cp) {\r\n-\t\tDistributedJDBCConfigurationImpl conf =\r\n-\t\t\t\tnew DistributedJDBCConfigurationImpl(cp);\r\n-\t\tcp.setInto(conf);\r\n-\t\treturn new DistributedJDBCBrokerFactory(conf);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Factory method for obtaining a possibly-pooled factory from properties.\r\n-\t * Invoked from {@link Bootstrap#getBrokerFactory}.\r\n-\t */\r\n-\tpublic static JDBCBrokerFactory getInstance(ConfigurationProvider cp) {\r\n-\t    Map properties = cp.getProperties();\r\n-\t    Object key = toPoolKey(properties);\r\n-\t\tDistributedJDBCBrokerFactory factory =\r\n-\t\t\t\t(DistributedJDBCBrokerFactory) getPooledFactoryForKey(key);\r\n-\t\tif (factory != null)\r\n-\t\t\treturn factory;\r\n-\r\n-\t\tfactory = newInstance(cp);\r\n-\t\tpool(key, factory);\r\n-\t\treturn factory;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Factory method for constructing a factory from a configuration.\r\n-\t */\r\n-\tpublic static synchronized JDBCBrokerFactory getInstance(\r\n-\t\t\tJDBCConfiguration conf) {\r\n-\t    Map properties = conf.toProperties(false);\r\n-\t    Object key = toPoolKey(properties);\r\n-\t\tDistributedJDBCBrokerFactory factory =\r\n-\t\t\t\t(DistributedJDBCBrokerFactory) getPooledFactoryForKey(key);\r\n-\t\tif (factory != null)\r\n-\t\t\treturn factory;\r\n-\r\n-\t\tfactory = new DistributedJDBCBrokerFactory(\r\n-\t\t        (DistributedJDBCConfiguration) conf);\r\n-\t\tpool(key, factory);\r\n-\t\treturn factory;\r\n-\t}\r\n-\r\n-\tpublic DistributedJDBCBrokerFactory(DistributedJDBCConfiguration conf) {\r\n-\t\tsuper(conf);\r\n-\t}\r\n-\t\r\n-\t@Override\r\n-\tpublic DistributedJDBCConfiguration getConfiguration() {\r\n-\t    return (DistributedJDBCConfiguration)super.getConfiguration();\r\n-\t}\r\n-\t\r\n-\tpublic Slice addSlice(String name, Map properties) {\r\n-\t    Slice slice = getConfiguration().addSlice(name, properties);\r\n-        ClassLoader loader = AccessController.doPrivileged(\r\n-            J2DoPrivHelper.getContextClassLoaderAction());\r\n-\t    synchronizeMappings(loader, (JDBCConfiguration)slice.getConfiguration());\r\n-\t    return slice;\r\n-\t}\r\n-\r\n-\t@Override\r\n-\tprotected DistributedJDBCStoreManager newStoreManager() {\r\n-\t\treturn new DistributedJDBCStoreManager(getConfiguration());\r\n-\t}\r\n-\t\r\n-    @Override\r\n-    protected Object getFactoryInitializationBanner() {\r\n-        return _loc.get(\"factory-init\", OpenJPAVersion.VERSION_NUMBER);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.jdbc;\n+\n+import java.security.AccessController;\n+import java.util.Map;\n+\n+import org.apache.openjpa.conf.OpenJPAVersion;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory;\n+import org.apache.openjpa.kernel.Bootstrap;\n+import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.slice.DistributedBrokerFactory;\n+import org.apache.openjpa.slice.Slice;\n+\n+/**\n+ * A factory for distributed JDBC datastores.\n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+@SuppressWarnings(\"serial\")\n+public class DistributedJDBCBrokerFactory extends JDBCBrokerFactory \n+    implements DistributedBrokerFactory {\n+\tprivate static final Localizer _loc = \n+\t    Localizer.forPackage(DistributedJDBCBrokerFactory.class);\n+\t/**\n+\t * Factory method for constructing a factory from properties. Invoked from\n+\t * {@link Bootstrap#newBrokerFactory}.\n+\t */\n+\tpublic static DistributedJDBCBrokerFactory newInstance(\n+\t\t\tConfigurationProvider cp) {\n+\t\tDistributedJDBCConfigurationImpl conf =\n+\t\t\t\tnew DistributedJDBCConfigurationImpl(cp);\n+\t\tcp.setInto(conf);\n+\t\treturn new DistributedJDBCBrokerFactory(conf);\n+\t}\n+\n+\t/**\n+\t * Factory method for obtaining a possibly-pooled factory from properties.\n+\t * Invoked from {@link Bootstrap#getBrokerFactory}.\n+\t */\n+\tpublic static JDBCBrokerFactory getInstance(ConfigurationProvider cp) {\n+\t    Map properties = cp.getProperties();\n+\t    Object key = toPoolKey(properties);\n+\t\tDistributedJDBCBrokerFactory factory =\n+\t\t\t\t(DistributedJDBCBrokerFactory) getPooledFactoryForKey(key);\n+\t\tif (factory != null)\n+\t\t\treturn factory;\n+\n+\t\tfactory = newInstance(cp);\n+\t\tpool(key, factory);\n+\t\treturn factory;\n+\t}\n+\n+\t/**\n+\t * Factory method for constructing a factory from a configuration.\n+\t */\n+\tpublic static synchronized JDBCBrokerFactory getInstance(\n+\t\t\tJDBCConfiguration conf) {\n+\t    Map properties = conf.toProperties(false);\n+\t    Object key = toPoolKey(properties);\n+\t\tDistributedJDBCBrokerFactory factory =\n+\t\t\t\t(DistributedJDBCBrokerFactory) getPooledFactoryForKey(key);\n+\t\tif (factory != null)\n+\t\t\treturn factory;\n+\n+\t\tfactory = new DistributedJDBCBrokerFactory(\n+\t\t        (DistributedJDBCConfiguration) conf);\n+\t\tpool(key, factory);\n+\t\treturn factory;\n+\t}\n+\n+\tpublic DistributedJDBCBrokerFactory(DistributedJDBCConfiguration conf) {\n+\t\tsuper(conf);\n+\t}\n+\t\n+\t@Override\n+\tpublic DistributedJDBCConfiguration getConfiguration() {\n+\t    return (DistributedJDBCConfiguration)super.getConfiguration();\n+\t}\n+\t\n+\tpublic Slice addSlice(String name, Map properties) {\n+\t    Slice slice = getConfiguration().addSlice(name, properties);\n+        ClassLoader loader = AccessController.doPrivileged(\n+            J2DoPrivHelper.getContextClassLoaderAction());\n+\t    synchronizeMappings(loader, (JDBCConfiguration)slice.getConfiguration());\n+\t    return slice;\n+\t}\n+\n+\t@Override\n+\tprotected DistributedJDBCStoreManager newStoreManager() {\n+\t\treturn new DistributedJDBCStoreManager(getConfiguration());\n+\t}\n+\t\n+    @Override\n+    protected Object getFactoryInitializationBanner() {\n+        return _loc.get(\"factory-init\", OpenJPAVersion.VERSION_NUMBER);\n+    }\n+}"},{"sha":"17621cb6531cfffc8ce8c7cc84c2e9e42c3f13c1","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfiguration.java","status":"modified","additions":39,"deletions":39,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfiguration.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,39 +1,39 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.jdbc;\r\n-\r\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n-import org.apache.openjpa.slice.DistributedConfiguration;\r\n-import org.apache.openjpa.slice.Slice;\r\n-\r\n-/**\r\n- * A distributed configuration that is a ordered collection of\r\n- * JDBCConfigurations.\r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- */\r\n-public interface DistributedJDBCConfiguration extends JDBCConfiguration,\r\n-    DistributedConfiguration {\r\n-    /**\r\n-     * Gets the master slice.\r\n-     */\r\n-    Slice getMaster();\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.jdbc;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.slice.DistributedConfiguration;\n+import org.apache.openjpa.slice.Slice;\n+\n+/**\n+ * A distributed configuration that is a ordered collection of\n+ * JDBCConfigurations.\n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+public interface DistributedJDBCConfiguration extends JDBCConfiguration,\n+    DistributedConfiguration {\n+    /**\n+     * Gets the master slice.\n+     */\n+    Slice getMaster();\n+\n+}"},{"sha":"a24b6bf3b452480bc82fb551ea7dbbbf6204c4ce","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfigurationImpl.java","status":"modified","additions":546,"deletions":546,"changes":1092,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfigurationImpl.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,546 +1,546 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.jdbc;\r\n-\r\n-import java.sql.Connection;\r\n-import java.sql.SQLException;\r\n-import java.util.ArrayList;\r\n-import java.util.Collections;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Properties;\r\n-\r\n-import javax.sql.DataSource;\r\n-import javax.sql.XADataSource;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n-import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\r\n-import org.apache.openjpa.jdbc.schema.DataSourceFactory;\r\n-import org.apache.openjpa.lib.conf.BooleanValue;\r\n-import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n-import org.apache.openjpa.lib.conf.PluginValue;\r\n-import org.apache.openjpa.lib.conf.StringListValue;\r\n-import org.apache.openjpa.lib.conf.StringValue;\r\n-import org.apache.openjpa.lib.jdbc.DecoratingDataSource;\r\n-import org.apache.openjpa.lib.jdbc.DelegatingDataSource;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.log.LogFactory;\r\n-import org.apache.openjpa.lib.log.LogFactoryImpl;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.slice.DistributedBrokerImpl;\r\n-import org.apache.openjpa.slice.DistributionPolicy;\r\n-import org.apache.openjpa.slice.ProductDerivation;\r\n-import org.apache.openjpa.slice.ReplicationPolicy;\r\n-import org.apache.openjpa.slice.Slice;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * Implements a distributed configuration of JDBCStoreManagers.\r\n- * The original configuration properties are analyzed to create a set of\r\n- * Slice specific properties with defaulting rules. \r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- */\r\n-public class DistributedJDBCConfigurationImpl extends JDBCConfigurationImpl\r\n-        implements DistributedJDBCConfiguration {\r\n-\r\n-    private final List<Slice> _slices = new ArrayList<Slice>();\r\n-    private Slice _master;\r\n-    \r\n-    private DistributedDataSource virtualDataSource;\r\n-    \r\n-    protected BooleanValue lenientPlugin;\r\n-    protected StringValue masterPlugin;\r\n-    protected StringListValue namesPlugin;\r\n-    public PluginValue distributionPolicyPlugin;\r\n-    public PluginValue replicationPolicyPlugin;\r\n-    \r\n-    protected Log log;\r\n-    protected String unit;\r\n-    \r\n-    public static final String DOT = \".\";\r\n-    public static final String REGEX_DOT = \"\\\\.\";\r\n-    public static final String PREFIX_SLICE = ProductDerivation.PREFIX_SLICE + \r\n-    \tDOT;\r\n-    public static final String PREFIX_OPENJPA = \"openjpa.\";\r\n-    private static Localizer _loc =\r\n-            Localizer.forPackage(DistributedJDBCConfigurationImpl.class);\r\n-\r\n-    /**\r\n-     * Configure itself as well as underlying slices.\r\n-     * \r\n-     */\r\n-    public DistributedJDBCConfigurationImpl(ConfigurationProvider cp) {\r\n-        super(true, false);\r\n-        Map p = cp.getProperties();\r\n-        log = getConfigurationLog();\r\n-        unit = getPersistenceUnitName(p);\r\n-        setDiagnosticContext(this, unit);\r\n-        \r\n-        brokerPlugin.setString(DistributedBrokerImpl.class.getName());\r\n-        \r\n-        distributionPolicyPlugin = addPlugin(\r\n-            PREFIX_SLICE + \"DistributionPolicy\", true);\r\n-        distributionPolicyPlugin.setAlias(\"random\", \r\n-        \tDistributionPolicy.Default.class.getName());\r\n-        distributionPolicyPlugin.setDefault(\"random\");\r\n-        distributionPolicyPlugin.setDynamic(true);\r\n-        \r\n-        replicationPolicyPlugin = addPlugin(\r\n-            PREFIX_SLICE + \"ReplicationPolicy\", true);\r\n-        replicationPolicyPlugin.setAlias(\"all\", \r\n-            ReplicationPolicy.Default.class.getName());\r\n-        replicationPolicyPlugin.setDefault(\"all\");\r\n-        replicationPolicyPlugin.setDynamic(true);\r\n-        \r\n-        lenientPlugin = addBoolean(PREFIX_SLICE + \"Lenient\");\r\n-        \r\n-        masterPlugin = addString(PREFIX_SLICE + \"Master\");\r\n-        \r\n-        namesPlugin = addStringList(PREFIX_SLICE + \"Names\");\r\n-        \r\n-        setSlices(p);\r\n-    }\r\n-    \r\n-    private String getPersistenceUnitName(Map p) {\r\n-        Object unit = p.get(PREFIX_OPENJPA + id.getProperty());\r\n-        return (unit == null) ? \"?\" : unit.toString();\r\n-    }\r\n-    \r\n-    private void setDiagnosticContext(OpenJPAConfiguration conf, String unit) {\r\n-        LogFactory logFactory = conf.getLogFactory();\r\n-        if (logFactory instanceof LogFactoryImpl) {\r\n-            ((LogFactoryImpl)logFactory).setDiagnosticContext(unit);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Gets the name of the active slices.\r\n-     */\r\n-    public List<String> getActiveSliceNames() {\r\n-        List<String> result = new ArrayList<String>();\r\n-        for (Slice slice : _slices) {\r\n-           if (slice.isActive() && !result.contains(slice.getName()))\r\n-              result.add(slice.getName());\r\n-        }\r\n-        return result;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Gets the name of the available slices.\r\n-     */\r\n-    public List<String> getAvailableSliceNames() {\r\n-        List<String> result = new ArrayList<String>();\r\n-        for (Slice slice:_slices)\r\n-            result.add(slice.getName());\r\n-        return result;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Gets the slices of given status. Null returns all irrespective of status.\r\n-     */\r\n-    public List<Slice> getSlices(Slice.Status...statuses) {\r\n-        if (statuses == null)\r\n-            return Collections.unmodifiableList(_slices);\r\n-        List<Slice> result = new ArrayList<Slice>();\r\n-        for (Slice slice:_slices) {\r\n-            for (Slice.Status status:statuses)\r\n-                if (slice.getStatus().equals(status))\r\n-                    result.add(slice);\r\n-        }\r\n-        return result;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Gets the master slice. \r\n-     */\r\n-    public Slice getMaster() {\r\n-        return _master;\r\n-    }\r\n-\r\n-    public Slice getSlice(String name) {\r\n-        return getSlice(name, false);\r\n-    }\r\n-    \r\n-    /**\r\n-     * Get the configuration for given slice.\r\n-     * \r\n-     * @param mustExist if true an exception if raised if the given slice name\r\n-     * is not an active slice.\r\n-     */\r\n-    public Slice getSlice(String name, boolean mustExist) {\r\n-        for (Slice slice:_slices)\r\n-            if (slice.getName().equals(name))\r\n-                return slice;\r\n-        if (mustExist) {\r\n-            throw new UserException(_loc.get(\"slice-not-found\", name,\r\n-                    getActiveSliceNames()));\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    public DistributionPolicy getDistributionPolicyInstance() {\r\n-        if (distributionPolicyPlugin.get() == null) {\r\n-            distributionPolicyPlugin.instantiate(DistributionPolicy.class,\r\n-                    this, true);\r\n-        }\r\n-        return (DistributionPolicy) distributionPolicyPlugin.get();\r\n-    }\r\n-    \r\n-    public String getDistributionPolicy() {\r\n-        if (distributionPolicyPlugin.get() == null) {\r\n-            distributionPolicyPlugin.instantiate(DistributionPolicy.class,\r\n-                    this, true);\r\n-        }\r\n-        return distributionPolicyPlugin.getString();\r\n-    }\r\n-\r\n-    public void setDistributionPolicyInstance(DistributionPolicy policy) {\r\n-        distributionPolicyPlugin.set(policy);\r\n-    }\r\n-    \r\n-    public void setDistributionPolicy(String policy) {\r\n-        distributionPolicyPlugin.setString(policy);\r\n-    }\r\n-\r\n-    public ReplicationPolicy getReplicationPolicyInstance() {\r\n-        if (replicationPolicyPlugin.get() == null) {\r\n-            replicationPolicyPlugin.instantiate(ReplicationPolicy.class,\r\n-                    this, true);\r\n-        }\r\n-        return (ReplicationPolicy) replicationPolicyPlugin.get();\r\n-    }\r\n-    \r\n-    public String getReplicationPolicy() {\r\n-        if (replicationPolicyPlugin.get() == null) {\r\n-            replicationPolicyPlugin.instantiate(ReplicationPolicy.class,\r\n-                    this, true);\r\n-        }\r\n-        return replicationPolicyPlugin.getString();\r\n-    }\r\n-\r\n-    public void setReplicationPolicyInstance(ReplicationPolicy policy) {\r\n-        replicationPolicyPlugin.set(policy);\r\n-    }\r\n-    \r\n-    public void setReplicationPolicy(String policy) {\r\n-        replicationPolicyPlugin.setString(policy);\r\n-    }\r\n-\r\n-    public DistributedDataSource getConnectionFactory() {\r\n-        if (virtualDataSource == null) {\r\n-            virtualDataSource = createDistributedDataStore();\r\n-            DataSourceFactory.installDBDictionary(\r\n-                getDBDictionaryInstance(), virtualDataSource, this, false);\r\n-        }\r\n-        return virtualDataSource;\r\n-    }\r\n-    \r\n-    public boolean isLenient() {\r\n-        return lenientPlugin.get();\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a virtual DistributedDataSource as a composite of individual\r\n-     * slices as per configuration, optionally ignoring slices that can not be\r\n-     * connected.\r\n-     */\r\n-    private DistributedDataSource createDistributedDataStore() {\r\n-        List<DataSource> dataSources = new ArrayList<DataSource>();\r\n-        boolean isXA = true;\r\n-        for (Slice slice : _slices) {\r\n-            try {\r\n-                DataSource ds = createDataSource(slice);\r\n-                dataSources.add(ds);\r\n-                isXA &= isXACompliant(ds);\r\n-            } catch (Throwable ex) {\r\n-                handleBadConnection(isLenient(), slice, ex);\r\n-            }\r\n-        }\r\n-        if (dataSources.isEmpty())\r\n-            throw new UserException(_loc.get(\"no-slice\"));\r\n-        DistributedDataSource result = new DistributedDataSource(dataSources);\r\n-        return result;\r\n-    }\r\n-    \r\n-    DataSource createDataSource(Slice slice) throws Exception {\r\n-        JDBCConfiguration conf = (JDBCConfiguration)slice.getConfiguration();\r\n-        Log log = conf.getConfigurationLog();\r\n-        String url = getConnectionInfo(conf);\r\n-        if (log.isInfoEnabled())\r\n-            log.info(_loc.get(\"slice-connect\", slice, url));\r\n-        DataSource ds = DataSourceFactory.newDataSource(conf, false);\r\n-        DecoratingDataSource dds = new DecoratingDataSource(ds);\r\n-        ds = DataSourceFactory.installDBDictionary(\r\n-                conf.getDBDictionaryInstance(), dds, conf, false);\r\n-        verifyDataSource(slice, ds, conf);\r\n-        \r\n-        return ds;\r\n-    }\r\n-\r\n-    String getConnectionInfo(OpenJPAConfiguration conf) {\r\n-        String result = conf.getConnectionURL();\r\n-        if (result == null) {\r\n-            result = conf.getConnectionDriverName();\r\n-            String props = conf.getConnectionProperties();\r\n-            if (props != null)\r\n-                result += \"(\" + props + \")\";\r\n-        }\r\n-        return result;\r\n-    }\r\n-\r\n-    boolean isXACompliant(DataSource ds) {\r\n-        if (ds instanceof DelegatingDataSource)\r\n-            return ((DelegatingDataSource) ds).getInnermostDelegate() \r\n-               instanceof XADataSource;\r\n-        return ds instanceof XADataSource;\r\n-    }\r\n-\r\n-    /**\r\n-     * Verify that a connection can be established to the given slice. If\r\n-     * connection can not be established then slice is set to INACTIVE state.\r\n-     */\r\n-    private boolean verifyDataSource(Slice slice, DataSource ds, \r\n-    \t\tJDBCConfiguration conf) {\r\n-        Connection con = null;\r\n-        try {\r\n-            con = ds.getConnection(conf.getConnectionUserName(), \r\n-            \t\tconf.getConnectionPassword());\r\n-            slice.setStatus(Slice.Status.ACTIVE);\r\n-            if (con == null) {\r\n-                slice.setStatus(Slice.Status.INACTIVE);\r\n-                return false;\r\n-            }\r\n-            return true;\r\n-        } catch (SQLException ex) {\r\n-            slice.setStatus(Slice.Status.INACTIVE);\r\n-            return false;\r\n-        } finally {\r\n-            if (con != null)\r\n-                try {\r\n-                    con.close();\r\n-                } catch (SQLException ex) {\r\n-                    // ignore\r\n-                }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Either throw a user exception or add the configuration to the given list,\r\n-     * based on <code>isLenient</code>.\r\n-     */\r\n-    private void handleBadConnection(boolean isLenient, Slice slice,\r\n-            Throwable ex) {\r\n-        OpenJPAConfiguration conf = slice.getConfiguration();\r\n-        String url = conf.getConnectionURL();\r\n-        Log log = getLog(LOG_RUNTIME);\r\n-        if (isLenient) {\r\n-            if (ex != null) {\r\n-                log.warn(_loc.get(\"slice-connect-known-warn\", slice, url, ex\r\n-                        .getCause()));\r\n-            } else {\r\n-                log.warn(_loc.get(\"slice-connect-warn\", slice, url));\r\n-            }\r\n-        } else if (ex != null) {\r\n-            throw new UserException(_loc.get(\"slice-connect-known-error\",\r\n-                    slice, url, ex), ex.getCause());\r\n-        } else {\r\n-            throw new UserException(_loc.get(\"slice-connect-error\", slice, url));\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Create individual slices with configurations from the given properties.\r\n-     */\r\n-    void setSlices(Map original) {\r\n-        List<String> sliceNames = findSlices(original);\r\n-        if (sliceNames.isEmpty()) {\r\n-            throw new UserException(_loc.get(\"slice-none-configured\"));\r\n-        } \r\n-        for (String key : sliceNames) {\r\n-            Slice slice = newSlice(key, original);\r\n-            _slices.add(slice);\r\n-        }\r\n-        setMaster(original);\r\n-    }\r\n-    \r\n-    protected Slice newSlice(String key, Map original) {\r\n-        JDBCConfiguration child = new JDBCConfigurationImpl();\r\n-        child.fromProperties(createSliceProperties(original, key));\r\n-        child.setId(unit+DOT+key);\r\n-        setDiagnosticContext(child, unit+DOT+key);\r\n-        Slice slice = new Slice(key, child);\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(_loc.get(\"slice-configuration\", key, child\r\n-                    .toProperties(false)));\r\n-        return slice;\r\n-    }\r\n-\r\n-    /**\r\n-     * Finds the slices. If <code>openjpa.slice.Names</code> property is \r\n-     * specified then the slices are ordered in the way they are listed. \r\n-     * Otherwise scans all available slices by looking for property of the form\r\n-     * <code>openjpa.slice.XYZ.abc</code> where <code>XYZ</code> is the slice\r\n-     * identifier and <code>abc</code> is any openjpa property name. The slices\r\n-     * are then ordered alphabetically by their identifier.\r\n-     */\r\n-    private List<String> findSlices(Map p) {\r\n-        List<String> sliceNames = new ArrayList<String>();\r\n-        \r\n-        Log log = getConfigurationLog();\r\n-        String key = namesPlugin.getProperty();\r\n-        boolean explicit = p.containsKey(key);\r\n-        if (explicit) {\r\n-            String[] values = p.get(key).toString().split(\"\\\\,\");\r\n-            for (String name:values)\r\n-                if (!sliceNames.contains(name.trim()))\r\n-                    sliceNames.add(name.trim());\r\n-        } else {\r\n-            if (log.isWarnEnabled())\r\n-                log.warn(_loc.get(\"no-slice-names\", key));\r\n-            sliceNames = scanForSliceNames(p);\r\n-            Collections.sort(sliceNames);\r\n-        }\r\n-        if (log.isInfoEnabled()) {\r\n-            log.info(_loc.get(\"slice-available\", sliceNames));\r\n-        }\r\n-        return sliceNames;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Scan the given map for slice-specific property of the form \r\n-     * <code>openjpa.slice.XYZ.abc</code> (while ignoring \r\n-     * <code>openjpa.slice.XYZ</code> as they refer to slice-wide property)\r\n-     * to determine the names of all available slices.\r\n-     */\r\n-    private List<String> scanForSliceNames(Map p) {\r\n-        List<String> sliceNames = new ArrayList<String>();\r\n-        for (Object o : p.keySet()) {\r\n-            String key = o.toString();\r\n-            if (key.startsWith(PREFIX_SLICE) && getPartCount(key) > 3) {\r\n-                String sliceName =\r\n-                    chopTail(chopHead(o.toString(), PREFIX_SLICE), DOT);\r\n-                if (!sliceNames.contains(sliceName))\r\n-                    sliceNames.add(sliceName);\r\n-            }\r\n-        }\r\n-        return sliceNames;\r\n-    }\r\n-\r\n-    private static int getPartCount(String s) {\r\n-        return (s == null) ? 0 : s.split(REGEX_DOT).length;\r\n-    }\r\n-    \r\n-    private static String chopHead(String s, String head) {\r\n-        if (s.startsWith(head))\r\n-            return s.substring(head.length());\r\n-        return s;\r\n-    }\r\n-\r\n-    private static String chopTail(String s, String tail) {\r\n-        int i = s.lastIndexOf(tail);\r\n-        if (i == -1)\r\n-            return s;\r\n-        return s.substring(0, i);\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates given <code>slice</code> specific configuration properties from\r\n-     * given <code>original</code> key-value map. The rules are\r\n-     * <LI> if key begins with <code>\"slice.XXX.\"</code> where\r\n-     * <code>XXX</code> is the given slice name, then replace\r\n-     * <code>\"slice.XXX.</code> with <code>openjpa.</code>.\r\n-     * <LI>if key begins with <code>\"slice.\"</code> but not with\r\n-     * <code>\"slice.XXX.\"</code>, the ignore i.e. any property of other\r\n-     * slices or global slice property e.g.\r\n-     * <code>slice.DistributionPolicy</code>\r\n-     * <code>if key starts with <code>\"openjpa.\"</code> and a corresponding\r\n-     * <code>\"slice.XXX.\"</code> property does not exist, then use this as\r\n-     * default property\r\n-     * <code>property with any other prefix is simply copied\r\n-     *\r\n-     */\r\n-    Map createSliceProperties(Map original, String slice) {\r\n-        Map result = new Properties();\r\n-        String prefix = PREFIX_SLICE + slice + DOT;\r\n-        for (Object o : original.keySet()) {\r\n-            String key = o.toString();\r\n-            if (key.startsWith(prefix)) {\r\n-                String newKey = PREFIX_OPENJPA + key.substring(prefix.length());\r\n-                result.put(newKey, original.get(o));\r\n-            } else if (key.startsWith(PREFIX_SLICE)) {\r\n-                // ignore keys that are in 'slice.' namespace but not this slice\r\n-            } else if (key.startsWith(PREFIX_OPENJPA)) {\r\n-                String newKey = prefix + key.substring(PREFIX_OPENJPA.length());\r\n-                if (!original.containsKey(newKey))\r\n-                    result.put(key, original.get(o));\r\n-            } else { // keys that are neither \"openjpa\" nor \"slice\" namespace\r\n-                result.put(key, original.get(o));\r\n-            }\r\n-        }\r\n-        return result;\r\n-    }\r\n-\r\n-    /**\r\n-     * Determine the master slice.\r\n-     */\r\n-    private void setMaster(Map original) {\r\n-        String key = masterPlugin.getProperty();\r\n-        Object masterSlice = original.get(key);\r\n-        Log log = getConfigurationLog();\r\n-        List<Slice> activeSlices = getSlices(null);\r\n-        if (masterSlice == null) {\r\n-            _master = activeSlices.get(0);\r\n-            if (log.isWarnEnabled())\r\n-                log.warn(_loc.get(\"no-master-slice\", key, _master));\r\n-            return;\r\n-        }\r\n-        for (Slice slice:activeSlices)\r\n-            if (slice.getName().equals(masterSlice))\r\n-                _master = slice;\r\n-        if (_master == null) {\r\n-            _master = activeSlices.get(0);\r\n-        }\r\n-    }\r\n-    \r\n-    public Slice addSlice(String name, Map newProps) {\r\n-        String prefix = PREFIX_SLICE + DOT + name + DOT;\r\n-        for (Object key : newProps.keySet()) {\r\n-            if (!String.class.isInstance(key) \r\n-             && key.toString().startsWith(prefix))\r\n-                throw new UserException(_loc.get(\"slice-add-wrong-key\", key));\r\n-        }\r\n-        Slice slice = getSlice(name);\r\n-        if (slice != null)\r\n-            throw new UserException(_loc.get(\"slice-exists\", name));\r\n-        Map<String,String> original = super.toProperties(true);\r\n-        original.putAll(newProps);\r\n-         slice = newSlice(name, original);\r\n-        _slices.add(slice);\r\n-        try {\r\n-            virtualDataSource.addDataSource(createDataSource(slice));\r\n-        } catch (Exception ex) {\r\n-            handleBadConnection(false, slice, ex);\r\n-            return null;\r\n-        }\r\n-        return slice;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import javax.sql.DataSource;\n+import javax.sql.XADataSource;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.jdbc.schema.DataSourceFactory;\n+import org.apache.openjpa.lib.conf.BooleanValue;\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.lib.conf.StringListValue;\n+import org.apache.openjpa.lib.conf.StringValue;\n+import org.apache.openjpa.lib.jdbc.DecoratingDataSource;\n+import org.apache.openjpa.lib.jdbc.DelegatingDataSource;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.log.LogFactory;\n+import org.apache.openjpa.lib.log.LogFactoryImpl;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.slice.DistributedBrokerImpl;\n+import org.apache.openjpa.slice.DistributionPolicy;\n+import org.apache.openjpa.slice.ProductDerivation;\n+import org.apache.openjpa.slice.ReplicationPolicy;\n+import org.apache.openjpa.slice.Slice;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Implements a distributed configuration of JDBCStoreManagers.\n+ * The original configuration properties are analyzed to create a set of\n+ * Slice specific properties with defaulting rules. \n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+public class DistributedJDBCConfigurationImpl extends JDBCConfigurationImpl\n+        implements DistributedJDBCConfiguration {\n+\n+    private final List<Slice> _slices = new ArrayList<Slice>();\n+    private Slice _master;\n+    \n+    private DistributedDataSource virtualDataSource;\n+    \n+    protected BooleanValue lenientPlugin;\n+    protected StringValue masterPlugin;\n+    protected StringListValue namesPlugin;\n+    public PluginValue distributionPolicyPlugin;\n+    public PluginValue replicationPolicyPlugin;\n+    \n+    protected Log log;\n+    protected String unit;\n+    \n+    public static final String DOT = \".\";\n+    public static final String REGEX_DOT = \"\\\\.\";\n+    public static final String PREFIX_SLICE = ProductDerivation.PREFIX_SLICE + \n+    \tDOT;\n+    public static final String PREFIX_OPENJPA = \"openjpa.\";\n+    private static Localizer _loc =\n+            Localizer.forPackage(DistributedJDBCConfigurationImpl.class);\n+\n+    /**\n+     * Configure itself as well as underlying slices.\n+     * \n+     */\n+    public DistributedJDBCConfigurationImpl(ConfigurationProvider cp) {\n+        super(true, false);\n+        Map p = cp.getProperties();\n+        log = getConfigurationLog();\n+        unit = getPersistenceUnitName(p);\n+        setDiagnosticContext(this, unit);\n+        \n+        brokerPlugin.setString(DistributedBrokerImpl.class.getName());\n+        \n+        distributionPolicyPlugin = addPlugin(\n+            PREFIX_SLICE + \"DistributionPolicy\", true);\n+        distributionPolicyPlugin.setAlias(\"random\", \n+        \tDistributionPolicy.Default.class.getName());\n+        distributionPolicyPlugin.setDefault(\"random\");\n+        distributionPolicyPlugin.setDynamic(true);\n+        \n+        replicationPolicyPlugin = addPlugin(\n+            PREFIX_SLICE + \"ReplicationPolicy\", true);\n+        replicationPolicyPlugin.setAlias(\"all\", \n+            ReplicationPolicy.Default.class.getName());\n+        replicationPolicyPlugin.setDefault(\"all\");\n+        replicationPolicyPlugin.setDynamic(true);\n+        \n+        lenientPlugin = addBoolean(PREFIX_SLICE + \"Lenient\");\n+        \n+        masterPlugin = addString(PREFIX_SLICE + \"Master\");\n+        \n+        namesPlugin = addStringList(PREFIX_SLICE + \"Names\");\n+        \n+        setSlices(p);\n+    }\n+    \n+    private String getPersistenceUnitName(Map p) {\n+        Object unit = p.get(PREFIX_OPENJPA + id.getProperty());\n+        return (unit == null) ? \"?\" : unit.toString();\n+    }\n+    \n+    private void setDiagnosticContext(OpenJPAConfiguration conf, String unit) {\n+        LogFactory logFactory = conf.getLogFactory();\n+        if (logFactory instanceof LogFactoryImpl) {\n+            ((LogFactoryImpl)logFactory).setDiagnosticContext(unit);\n+        }\n+    }\n+\n+    /**\n+     * Gets the name of the active slices.\n+     */\n+    public List<String> getActiveSliceNames() {\n+        List<String> result = new ArrayList<String>();\n+        for (Slice slice : _slices) {\n+           if (slice.isActive() && !result.contains(slice.getName()))\n+              result.add(slice.getName());\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Gets the name of the available slices.\n+     */\n+    public List<String> getAvailableSliceNames() {\n+        List<String> result = new ArrayList<String>();\n+        for (Slice slice:_slices)\n+            result.add(slice.getName());\n+        return result;\n+    }\n+    \n+    /**\n+     * Gets the slices of given status. Null returns all irrespective of status.\n+     */\n+    public List<Slice> getSlices(Slice.Status...statuses) {\n+        if (statuses == null)\n+            return Collections.unmodifiableList(_slices);\n+        List<Slice> result = new ArrayList<Slice>();\n+        for (Slice slice:_slices) {\n+            for (Slice.Status status:statuses)\n+                if (slice.getStatus().equals(status))\n+                    result.add(slice);\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Gets the master slice. \n+     */\n+    public Slice getMaster() {\n+        return _master;\n+    }\n+\n+    public Slice getSlice(String name) {\n+        return getSlice(name, false);\n+    }\n+    \n+    /**\n+     * Get the configuration for given slice.\n+     * \n+     * @param mustExist if true an exception if raised if the given slice name\n+     * is not an active slice.\n+     */\n+    public Slice getSlice(String name, boolean mustExist) {\n+        for (Slice slice:_slices)\n+            if (slice.getName().equals(name))\n+                return slice;\n+        if (mustExist) {\n+            throw new UserException(_loc.get(\"slice-not-found\", name,\n+                    getActiveSliceNames()));\n+        }\n+        return null;\n+    }\n+\n+    public DistributionPolicy getDistributionPolicyInstance() {\n+        if (distributionPolicyPlugin.get() == null) {\n+            distributionPolicyPlugin.instantiate(DistributionPolicy.class,\n+                    this, true);\n+        }\n+        return (DistributionPolicy) distributionPolicyPlugin.get();\n+    }\n+    \n+    public String getDistributionPolicy() {\n+        if (distributionPolicyPlugin.get() == null) {\n+            distributionPolicyPlugin.instantiate(DistributionPolicy.class,\n+                    this, true);\n+        }\n+        return distributionPolicyPlugin.getString();\n+    }\n+\n+    public void setDistributionPolicyInstance(DistributionPolicy policy) {\n+        distributionPolicyPlugin.set(policy);\n+    }\n+    \n+    public void setDistributionPolicy(String policy) {\n+        distributionPolicyPlugin.setString(policy);\n+    }\n+\n+    public ReplicationPolicy getReplicationPolicyInstance() {\n+        if (replicationPolicyPlugin.get() == null) {\n+            replicationPolicyPlugin.instantiate(ReplicationPolicy.class,\n+                    this, true);\n+        }\n+        return (ReplicationPolicy) replicationPolicyPlugin.get();\n+    }\n+    \n+    public String getReplicationPolicy() {\n+        if (replicationPolicyPlugin.get() == null) {\n+            replicationPolicyPlugin.instantiate(ReplicationPolicy.class,\n+                    this, true);\n+        }\n+        return replicationPolicyPlugin.getString();\n+    }\n+\n+    public void setReplicationPolicyInstance(ReplicationPolicy policy) {\n+        replicationPolicyPlugin.set(policy);\n+    }\n+    \n+    public void setReplicationPolicy(String policy) {\n+        replicationPolicyPlugin.setString(policy);\n+    }\n+\n+    public DistributedDataSource getConnectionFactory() {\n+        if (virtualDataSource == null) {\n+            virtualDataSource = createDistributedDataStore();\n+            DataSourceFactory.installDBDictionary(\n+                getDBDictionaryInstance(), virtualDataSource, this, false);\n+        }\n+        return virtualDataSource;\n+    }\n+    \n+    public boolean isLenient() {\n+        return lenientPlugin.get();\n+    }\n+\n+    /**\n+     * Create a virtual DistributedDataSource as a composite of individual\n+     * slices as per configuration, optionally ignoring slices that can not be\n+     * connected.\n+     */\n+    private DistributedDataSource createDistributedDataStore() {\n+        List<DataSource> dataSources = new ArrayList<DataSource>();\n+        boolean isXA = true;\n+        for (Slice slice : _slices) {\n+            try {\n+                DataSource ds = createDataSource(slice);\n+                dataSources.add(ds);\n+                isXA &= isXACompliant(ds);\n+            } catch (Throwable ex) {\n+                handleBadConnection(isLenient(), slice, ex);\n+            }\n+        }\n+        if (dataSources.isEmpty())\n+            throw new UserException(_loc.get(\"no-slice\"));\n+        DistributedDataSource result = new DistributedDataSource(dataSources);\n+        return result;\n+    }\n+    \n+    DataSource createDataSource(Slice slice) throws Exception {\n+        JDBCConfiguration conf = (JDBCConfiguration)slice.getConfiguration();\n+        Log log = conf.getConfigurationLog();\n+        String url = getConnectionInfo(conf);\n+        if (log.isInfoEnabled())\n+            log.info(_loc.get(\"slice-connect\", slice, url));\n+        DataSource ds = DataSourceFactory.newDataSource(conf, false);\n+        DecoratingDataSource dds = new DecoratingDataSource(ds);\n+        ds = DataSourceFactory.installDBDictionary(\n+                conf.getDBDictionaryInstance(), dds, conf, false);\n+        verifyDataSource(slice, ds, conf);\n+        \n+        return ds;\n+    }\n+\n+    String getConnectionInfo(OpenJPAConfiguration conf) {\n+        String result = conf.getConnectionURL();\n+        if (result == null) {\n+            result = conf.getConnectionDriverName();\n+            String props = conf.getConnectionProperties();\n+            if (props != null)\n+                result += \"(\" + props + \")\";\n+        }\n+        return result;\n+    }\n+\n+    boolean isXACompliant(DataSource ds) {\n+        if (ds instanceof DelegatingDataSource)\n+            return ((DelegatingDataSource) ds).getInnermostDelegate() \n+               instanceof XADataSource;\n+        return ds instanceof XADataSource;\n+    }\n+\n+    /**\n+     * Verify that a connection can be established to the given slice. If\n+     * connection can not be established then slice is set to INACTIVE state.\n+     */\n+    private boolean verifyDataSource(Slice slice, DataSource ds, \n+    \t\tJDBCConfiguration conf) {\n+        Connection con = null;\n+        try {\n+            con = ds.getConnection(conf.getConnectionUserName(), \n+            \t\tconf.getConnectionPassword());\n+            slice.setStatus(Slice.Status.ACTIVE);\n+            if (con == null) {\n+                slice.setStatus(Slice.Status.INACTIVE);\n+                return false;\n+            }\n+            return true;\n+        } catch (SQLException ex) {\n+            slice.setStatus(Slice.Status.INACTIVE);\n+            return false;\n+        } finally {\n+            if (con != null)\n+                try {\n+                    con.close();\n+                } catch (SQLException ex) {\n+                    // ignore\n+                }\n+        }\n+    }\n+\n+    /**\n+     * Either throw a user exception or add the configuration to the given list,\n+     * based on <code>isLenient</code>.\n+     */\n+    private void handleBadConnection(boolean isLenient, Slice slice,\n+            Throwable ex) {\n+        OpenJPAConfiguration conf = slice.getConfiguration();\n+        String url = conf.getConnectionURL();\n+        Log log = getLog(LOG_RUNTIME);\n+        if (isLenient) {\n+            if (ex != null) {\n+                log.warn(_loc.get(\"slice-connect-known-warn\", slice, url, ex\n+                        .getCause()));\n+            } else {\n+                log.warn(_loc.get(\"slice-connect-warn\", slice, url));\n+            }\n+        } else if (ex != null) {\n+            throw new UserException(_loc.get(\"slice-connect-known-error\",\n+                    slice, url, ex), ex.getCause());\n+        } else {\n+            throw new UserException(_loc.get(\"slice-connect-error\", slice, url));\n+        }\n+    }\n+\n+    /**\n+     * Create individual slices with configurations from the given properties.\n+     */\n+    void setSlices(Map original) {\n+        List<String> sliceNames = findSlices(original);\n+        if (sliceNames.isEmpty()) {\n+            throw new UserException(_loc.get(\"slice-none-configured\"));\n+        } \n+        for (String key : sliceNames) {\n+            Slice slice = newSlice(key, original);\n+            _slices.add(slice);\n+        }\n+        setMaster(original);\n+    }\n+    \n+    protected Slice newSlice(String key, Map original) {\n+        JDBCConfiguration child = new JDBCConfigurationImpl();\n+        child.fromProperties(createSliceProperties(original, key));\n+        child.setId(unit+DOT+key);\n+        setDiagnosticContext(child, unit+DOT+key);\n+        Slice slice = new Slice(key, child);\n+        if (log.isTraceEnabled())\n+            log.trace(_loc.get(\"slice-configuration\", key, child\n+                    .toProperties(false)));\n+        return slice;\n+    }\n+\n+    /**\n+     * Finds the slices. If <code>openjpa.slice.Names</code> property is \n+     * specified then the slices are ordered in the way they are listed. \n+     * Otherwise scans all available slices by looking for property of the form\n+     * <code>openjpa.slice.XYZ.abc</code> where <code>XYZ</code> is the slice\n+     * identifier and <code>abc</code> is any openjpa property name. The slices\n+     * are then ordered alphabetically by their identifier.\n+     */\n+    private List<String> findSlices(Map p) {\n+        List<String> sliceNames = new ArrayList<String>();\n+        \n+        Log log = getConfigurationLog();\n+        String key = namesPlugin.getProperty();\n+        boolean explicit = p.containsKey(key);\n+        if (explicit) {\n+            String[] values = p.get(key).toString().split(\"\\\\,\");\n+            for (String name:values)\n+                if (!sliceNames.contains(name.trim()))\n+                    sliceNames.add(name.trim());\n+        } else {\n+            if (log.isWarnEnabled())\n+                log.warn(_loc.get(\"no-slice-names\", key));\n+            sliceNames = scanForSliceNames(p);\n+            Collections.sort(sliceNames);\n+        }\n+        if (log.isInfoEnabled()) {\n+            log.info(_loc.get(\"slice-available\", sliceNames));\n+        }\n+        return sliceNames;\n+    }\n+    \n+    /**\n+     * Scan the given map for slice-specific property of the form \n+     * <code>openjpa.slice.XYZ.abc</code> (while ignoring \n+     * <code>openjpa.slice.XYZ</code> as they refer to slice-wide property)\n+     * to determine the names of all available slices.\n+     */\n+    private List<String> scanForSliceNames(Map p) {\n+        List<String> sliceNames = new ArrayList<String>();\n+        for (Object o : p.keySet()) {\n+            String key = o.toString();\n+            if (key.startsWith(PREFIX_SLICE) && getPartCount(key) > 3) {\n+                String sliceName =\n+                    chopTail(chopHead(o.toString(), PREFIX_SLICE), DOT);\n+                if (!sliceNames.contains(sliceName))\n+                    sliceNames.add(sliceName);\n+            }\n+        }\n+        return sliceNames;\n+    }\n+\n+    private static int getPartCount(String s) {\n+        return (s == null) ? 0 : s.split(REGEX_DOT).length;\n+    }\n+    \n+    private static String chopHead(String s, String head) {\n+        if (s.startsWith(head))\n+            return s.substring(head.length());\n+        return s;\n+    }\n+\n+    private static String chopTail(String s, String tail) {\n+        int i = s.lastIndexOf(tail);\n+        if (i == -1)\n+            return s;\n+        return s.substring(0, i);\n+    }\n+\n+    /**\n+     * Creates given <code>slice</code> specific configuration properties from\n+     * given <code>original</code> key-value map. The rules are\n+     * <LI> if key begins with <code>\"slice.XXX.\"</code> where\n+     * <code>XXX</code> is the given slice name, then replace\n+     * <code>\"slice.XXX.</code> with <code>openjpa.</code>.\n+     * <LI>if key begins with <code>\"slice.\"</code> but not with\n+     * <code>\"slice.XXX.\"</code>, the ignore i.e. any property of other\n+     * slices or global slice property e.g.\n+     * <code>slice.DistributionPolicy</code>\n+     * <code>if key starts with <code>\"openjpa.\"</code> and a corresponding\n+     * <code>\"slice.XXX.\"</code> property does not exist, then use this as\n+     * default property\n+     * <code>property with any other prefix is simply copied\n+     *\n+     */\n+    Map createSliceProperties(Map original, String slice) {\n+        Map result = new Properties();\n+        String prefix = PREFIX_SLICE + slice + DOT;\n+        for (Object o : original.keySet()) {\n+            String key = o.toString();\n+            if (key.startsWith(prefix)) {\n+                String newKey = PREFIX_OPENJPA + key.substring(prefix.length());\n+                result.put(newKey, original.get(o));\n+            } else if (key.startsWith(PREFIX_SLICE)) {\n+                // ignore keys that are in 'slice.' namespace but not this slice\n+            } else if (key.startsWith(PREFIX_OPENJPA)) {\n+                String newKey = prefix + key.substring(PREFIX_OPENJPA.length());\n+                if (!original.containsKey(newKey))\n+                    result.put(key, original.get(o));\n+            } else { // keys that are neither \"openjpa\" nor \"slice\" namespace\n+                result.put(key, original.get(o));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Determine the master slice.\n+     */\n+    private void setMaster(Map original) {\n+        String key = masterPlugin.getProperty();\n+        Object masterSlice = original.get(key);\n+        Log log = getConfigurationLog();\n+        List<Slice> activeSlices = getSlices(null);\n+        if (masterSlice == null) {\n+            _master = activeSlices.get(0);\n+            if (log.isWarnEnabled())\n+                log.warn(_loc.get(\"no-master-slice\", key, _master));\n+            return;\n+        }\n+        for (Slice slice:activeSlices)\n+            if (slice.getName().equals(masterSlice))\n+                _master = slice;\n+        if (_master == null) {\n+            _master = activeSlices.get(0);\n+        }\n+    }\n+    \n+    public Slice addSlice(String name, Map newProps) {\n+        String prefix = PREFIX_SLICE + DOT + name + DOT;\n+        for (Object key : newProps.keySet()) {\n+            if (!String.class.isInstance(key) \n+             && key.toString().startsWith(prefix))\n+                throw new UserException(_loc.get(\"slice-add-wrong-key\", key));\n+        }\n+        Slice slice = getSlice(name);\n+        if (slice != null)\n+            throw new UserException(_loc.get(\"slice-exists\", name));\n+        Map<String,String> original = super.toProperties(true);\n+        original.putAll(newProps);\n+         slice = newSlice(name, original);\n+        _slices.add(slice);\n+        try {\n+            virtualDataSource.addDataSource(createDataSource(slice));\n+        } catch (Exception ex) {\n+            handleBadConnection(false, slice, ex);\n+            return null;\n+        }\n+        return slice;\n+    }\n+}"},{"sha":"38794e90b759c7f73b579e49f8b6ae051e974c49","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCStoreManager.java","status":"modified","additions":541,"deletions":541,"changes":1082,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCStoreManager.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,541 +1,541 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.jdbc;\r\n-\r\n-import java.sql.Connection;\r\n-import java.sql.SQLException;\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.BitSet;\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.HashSet;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.concurrent.Callable;\r\n-import java.util.concurrent.ExecutionException;\r\n-import java.util.concurrent.ExecutorService;\r\n-import java.util.concurrent.Executors;\r\n-import java.util.concurrent.Future;\r\n-\r\n-import org.apache.openjpa.enhance.PersistenceCapable;\r\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n-import org.apache.openjpa.jdbc.kernel.ConnectionInfo;\r\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\r\n-import org.apache.openjpa.jdbc.kernel.JDBCStoreManager;\r\n-import org.apache.openjpa.jdbc.sql.Result;\r\n-import org.apache.openjpa.jdbc.sql.ResultSetResult;\r\n-import org.apache.openjpa.kernel.BrokerImpl;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.PCState;\r\n-import org.apache.openjpa.kernel.QueryLanguages;\r\n-import org.apache.openjpa.kernel.Seq;\r\n-import org.apache.openjpa.kernel.StoreContext;\r\n-import org.apache.openjpa.kernel.StoreManager;\r\n-import org.apache.openjpa.kernel.StoreQuery;\r\n-import org.apache.openjpa.kernel.exps.ExpressionParser;\r\n-import org.apache.openjpa.lib.rop.MergedResultObjectProvider;\r\n-import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.slice.DistributedStoreManager;\r\n-import org.apache.openjpa.slice.ProductDerivation;\r\n-import org.apache.openjpa.slice.Slice;\r\n-import org.apache.openjpa.slice.SliceImplHelper;\r\n-import org.apache.openjpa.slice.SliceInfo;\r\n-import org.apache.openjpa.slice.SliceThread;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.StoreException;\r\n-\r\n-/**\r\n- * A Store manager for multiple physical databases referred as <em>slice</em>.\r\n- * This receiver behaves like a Transaction Manager as it implements two-phase\r\n- * commit protocol if all the component slices is XA-complaint. The actions are\r\n- * delegated to the underlying slices. The actions are executed in parallel\r\n- * threads whenever possible such as flushing or query. <br>\r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- */\r\n-class DistributedJDBCStoreManager extends JDBCStoreManager \r\n-    implements DistributedStoreManager {\r\n-    private final List<SliceStoreManager> _slices;\r\n-    private JDBCStoreManager _master;\r\n-    private final DistributedJDBCConfiguration _conf;\r\n-    private static final Localizer _loc =\r\n-            Localizer.forPackage(DistributedJDBCStoreManager.class);\r\n-\r\n-    /**\r\n-     * Constructs a set of child StoreManagers each connected to a physical\r\n-     * DataSource.\r\n-     * \r\n-     * The supplied configuration carries multiple URL for underlying physical\r\n-     * slices. The first slice is referred as <em>master</em> and is used to\r\n-     * get Sequence based entity identifiers.\r\n-     */\r\n-    public DistributedJDBCStoreManager(DistributedJDBCConfiguration conf) {\r\n-        super();\r\n-        _conf = conf;\r\n-        _slices = new ArrayList<SliceStoreManager>();\r\n-        List<String> sliceNames = conf.getActiveSliceNames();\r\n-        for (String name : sliceNames) {\r\n-            SliceStoreManager slice = new SliceStoreManager(conf.getSlice(name));\r\n-            _slices.add(slice);\r\n-            if (slice.getName().equals(_conf.getMaster().getName()))\r\n-                _master = slice;\r\n-        }\r\n-    }\r\n-\r\n-    public DistributedJDBCConfiguration getConfiguration() {\r\n-        return _conf;\r\n-    }\r\n-    \r\n-    public SliceStoreManager getSlice(int i) {\r\n-    \treturn _slices.get(i);\r\n-    }\r\n-    \r\n-    public SliceStoreManager addSlice(Slice slice) {\r\n-        SliceStoreManager result = new SliceStoreManager(slice);\r\n-        result.setContext(getContext(), (JDBCConfiguration)slice.getConfiguration());\r\n-        _slices.add(result);\r\n-        return result;\r\n-    }\r\n-\r\n-    /**\r\n-     * Decides the index of the StoreManager by first looking at the\r\n-     * implementation data. If no implementation data is found, then estimates \r\n-     * targets slices by using additional connection info. If no additional\r\n-     * connection info then calls back to user-defined policy. \r\n-     */\r\n-    protected SliceInfo findSliceNames(OpenJPAStateManager sm, Object edata) {\r\n-        if (SliceImplHelper.isSliceAssigned(sm))\r\n-            return SliceImplHelper.getSliceInfo(sm);\r\n-        SliceInfo result = null;\r\n-        PersistenceCapable pc = sm.getPersistenceCapable();\r\n-        Object ctx = getContext();\r\n-        if (SliceImplHelper.isReplicated(sm)) {\r\n-            result = SliceImplHelper.getSlicesByPolicy(pc, _conf, ctx);\r\n-        } else {\r\n-            String origin = estimateSlice(sm, edata);\r\n-            if (origin == null) {\r\n-                result = SliceImplHelper.getSlicesByPolicy(pc, _conf, ctx);\r\n-            } else {\r\n-                result = new SliceInfo(origin);\r\n-            }\r\n-        }\r\n-        return result;\r\n-    }\r\n-    \r\n-    private void assignSlice(OpenJPAStateManager sm, String hint) {\r\n-        if (SliceImplHelper.isReplicated(sm)) {\r\n-            SliceImplHelper.getSlicesByPolicy(sm, _conf, getContext())\r\n-                .setInto(sm);\r\n-            return;\r\n-        }\r\n-        new SliceInfo(hint).setInto(sm);\r\n-    }\r\n-    \r\n-    /**\r\n-     * The additional edata is used, if possible, to find the StoreManager\r\n-     * managing the given StateManager. If the additional data is unavailable\r\n-     * then return null.\r\n-     * \r\n-     */\r\n-    private String estimateSlice(OpenJPAStateManager sm, Object edata) {\r\n-        if (edata == null || !(edata instanceof ConnectionInfo))\r\n-            return null;\r\n-\r\n-        Result result = ((ConnectionInfo) edata).result;\r\n-        if (result instanceof ResultSetResult) {\r\n-            JDBCStore store = ((ResultSetResult) result).getStore();\r\n-            for (SliceStoreManager slice : _slices) {\r\n-                if (slice == store) {\r\n-                    return slice.getName();\r\n-                }\r\n-            }\r\n-        }\r\n-        return null; \r\n-    }\r\n-\r\n-    /**\r\n-     * Selects child StoreManager(s) where the given instance resides.\r\n-     */\r\n-    private StoreManager selectStore(OpenJPAStateManager sm, Object edata) {\r\n-        String[] targets = findSliceNames(sm, edata).getSlices();\r\n-        for (String target : targets) {\r\n-        \tSliceStoreManager slice = lookup(target);\r\n-        \tif (slice == null)\r\n-        \t\tthrow new InternalException(_loc.get(\"wrong-slice\", target, sm));\r\n-        \treturn slice;\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    public boolean assignField(OpenJPAStateManager sm, int field,\r\n-            boolean preFlush) {\r\n-        return selectStore(sm, null).assignField(sm, field, preFlush);\r\n-    }\r\n-\r\n-    public boolean assignObjectId(OpenJPAStateManager sm, boolean preFlush) {\r\n-        return _master.assignObjectId(sm, preFlush);\r\n-    }\r\n-\r\n-    public void beforeStateChange(OpenJPAStateManager sm, PCState fromState,\r\n-            PCState toState) {\r\n-        _master.beforeStateChange(sm, fromState, toState);\r\n-    }\r\n-\r\n-    public void beginOptimistic() {\r\n-        for (SliceStoreManager slice : _slices)\r\n-            slice.beginOptimistic();\r\n-    }\r\n-\r\n-    public boolean cancelAll() {\r\n-        boolean ret = true;\r\n-        for (SliceStoreManager slice : _slices)\r\n-            ret = slice.cancelAll() & ret;\r\n-        return ret;\r\n-    }\r\n-\r\n-    public int compareVersion(OpenJPAStateManager sm, Object v1, Object v2) {\r\n-        return selectStore(sm, null).compareVersion(sm, v1, v2);\r\n-    }\r\n-\r\n-    public Object copyDataStoreId(Object oid, ClassMetaData meta) {\r\n-        return _master.copyDataStoreId(oid, meta);\r\n-    }\r\n-\r\n-    public ResultObjectProvider executeExtent(ClassMetaData meta,\r\n-            boolean subclasses, FetchConfiguration fetch) {\r\n-        int i = 0;\r\n-        List<SliceStoreManager> targets = getTargets(fetch);\r\n-        ResultObjectProvider[] tmp = new ResultObjectProvider[targets.size()];\r\n-        for (SliceStoreManager slice : targets) {\r\n-            tmp[i++] = slice.executeExtent(meta, subclasses, fetch);\r\n-        }\r\n-        return new MergedResultObjectProvider(tmp);\r\n-    }\r\n-\r\n-    public boolean exists(OpenJPAStateManager sm, Object edata) {\r\n-    \tString origin = null;\r\n-        for (SliceStoreManager slice : _slices) {\r\n-            if (slice.exists(sm, edata)) {\r\n-            \torigin = slice.getName();\r\n-            \tbreak;\r\n-            }\r\n-        }\r\n-        if (origin != null)\r\n-            assignSlice(sm, origin);\r\n-        return origin != null;\r\n-    }\r\n-\r\n-    \r\n-    /**\r\n-     * Flush the given StateManagers after binning them to respective physical\r\n-     * slices.\r\n-     */\r\n-    public Collection flush(Collection sms) {\r\n-        Collection exceptions = new ArrayList();\r\n-        List<Future<Collection>> futures = new ArrayList<Future<Collection>>();\r\n-        Map<String, StateManagerSet> subsets = bin(sms, null);\r\n-        Collection<StateManagerSet> remaining = \r\n-            new ArrayList<StateManagerSet>(subsets.values());\r\n-        ExecutorService threadPool = SliceThread.newPool(_slices.size());\r\n-        for (int i = 0; i < _slices.size(); i++) {\r\n-            SliceStoreManager slice = _slices.get(i);\r\n-            StateManagerSet subset = subsets.get(slice.getName());\r\n-            if (subset.isEmpty())\r\n-                continue;\r\n-            if (subset.containsReplicated()) {\r\n-                Map<OpenJPAStateManager, Object> oldVersions = cacheVersion(\r\n-                    subset.getReplicated());\r\n-            \tcollectException(slice.flush(subset), exceptions);\r\n-                remaining.remove(subset);\r\n-            \trollbackVersion(subset.getReplicated(), oldVersions, remaining);\r\n-            } else {\r\n-            \tfutures.add(threadPool.submit(new Flusher(slice, subset)));\r\n-            }\r\n-        }\r\n-        for (Future<Collection> future : futures) {\r\n-            try {\r\n-            \tcollectException(future.get(), exceptions);\r\n-            } catch (InterruptedException e) {\r\n-                throw new StoreException(e);\r\n-            } catch (ExecutionException e) {\r\n-                throw new StoreException(e.getCause());\r\n-            }\r\n-        }\r\n-        \r\n-\t    return exceptions;\r\n-    }\r\n-    \r\n-    private void collectException(Collection error,  Collection holder) {\r\n-        if (!(error == null || error.isEmpty())) {\r\n-        \tholder.addAll(error);\r\n-        }\r\n-    }\r\n-    \r\n-    /**\r\n-     * Collect the current versions of the given StateManagers.\r\n-     */\r\n-    private Map<OpenJPAStateManager, Object> cacheVersion(\r\n-        List<OpenJPAStateManager> sms) {\r\n-        Map<OpenJPAStateManager, Object> result = \r\n-            new HashMap<OpenJPAStateManager, Object>();\r\n-        for (OpenJPAStateManager sm : sms)\r\n-            result.put(sm, sm.getVersion());\r\n-        return result;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Sets the version of the given StateManagers from the cached versions.\r\n-     * Provided that the StateManager does not appear in the FlusSets of the\r\n-     * remaining.\r\n-     */\r\n-    private void rollbackVersion(List<OpenJPAStateManager> sms, \r\n-        Map<OpenJPAStateManager, Object> oldVersions, \r\n-        Collection<StateManagerSet> reminder) {\r\n-        if (reminder.isEmpty())\r\n-            return;\r\n-        for (OpenJPAStateManager sm : sms) {\r\n-            if (occurs(sm, reminder))\r\n-              sm.setVersion(oldVersions.get(sm));\r\n-        }\r\n-    }\r\n-    \r\n-    boolean occurs(OpenJPAStateManager sm, \r\n-        Collection<StateManagerSet> reminder) {\r\n-        for (StateManagerSet set : reminder)\r\n-            if (set.contains(sm))\r\n-                return true;\r\n-        return false;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Separate the given list of StateManagers in separate lists for each slice \r\n-     * by the associated slice identifier of each StateManager.\r\n-     */\r\n-    private Map<String, StateManagerSet> bin(Collection sms, Object edata) {\r\n-        Map<String, StateManagerSet> subsets =  \r\n-            new HashMap<String, StateManagerSet>();\r\n-        for (SliceStoreManager slice : _slices)\r\n-            subsets.put(slice.getName(), new StateManagerSet());\r\n-        for (Object x : sms) {\r\n-            OpenJPAStateManager sm = (OpenJPAStateManager) x;\r\n-            String[] targets = findSliceNames(sm, edata).getSlices();\r\n-           \tfor (String slice : targets) {\r\n-            \tsubsets.get(slice).add(sm);\r\n-            }\r\n-        }\r\n-        return subsets;\r\n-    }\r\n-\r\n-    public Object getClientConnection() {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public Seq getDataStoreIdSequence(ClassMetaData forClass) {\r\n-        return _master.getDataStoreIdSequence(forClass);\r\n-    }\r\n-\r\n-    public Class getDataStoreIdType(ClassMetaData meta) {\r\n-        return _master.getDataStoreIdType(meta);\r\n-    }\r\n-\r\n-    public Class getManagedType(Object oid) {\r\n-        return _master.getManagedType(oid);\r\n-    }\r\n-\r\n-    public Seq getValueSequence(FieldMetaData forField) {\r\n-        return _master.getValueSequence(forField);\r\n-    }\r\n-\r\n-    public boolean initialize(OpenJPAStateManager sm, PCState state,\r\n-            FetchConfiguration fetch, Object edata) {\r\n-        if (edata instanceof ConnectionInfo) {\r\n-            String origin = estimateSlice(sm, edata);\r\n-            if (origin != null) {\r\n-                if (lookup(origin).initialize(sm, state, fetch, edata)) {\r\n-                    assignSlice(sm, origin);\r\n-                    return true;\r\n-                }\r\n-            }\r\n-        }\r\n-        // not a part of Query result load. Look into the slices till found\r\n-        List<SliceStoreManager> targets = getTargets(fetch);\r\n-        for (SliceStoreManager slice : targets) {\r\n-            if (slice.initialize(sm, state, fetch, edata)) {\r\n-                assignSlice(sm, slice.getName());\r\n-                return true;\r\n-            }\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean load(OpenJPAStateManager sm, BitSet fields,\r\n-            FetchConfiguration fetch, int lockLevel, Object edata) {\r\n-        return selectStore(sm, edata).load(sm, fields, fetch, lockLevel, edata);\r\n-    }\r\n-\r\n-    public Collection loadAll(Collection sms, PCState state, int load,\r\n-            FetchConfiguration fetch, Object edata) {\r\n-        Map<String, StateManagerSet> subsets = bin(sms, edata);\r\n-        Collection result = new ArrayList();\r\n-        for (SliceStoreManager slice : _slices) {\r\n-            StateManagerSet subset = subsets.get(slice.getName());\r\n-            if (subset.isEmpty())\r\n-                continue;\r\n-            Collection tmp = slice.loadAll(subset, state, load, fetch, edata);\r\n-            if (tmp != null && !tmp.isEmpty())\r\n-                result.addAll(tmp);\r\n-        }\r\n-        return result;\r\n-    }\r\n-\r\n-    public Object newDataStoreId(Object oidVal, ClassMetaData meta) {\r\n-        return _master.newDataStoreId(oidVal, meta);\r\n-    }\r\n-\r\n-    public FetchConfiguration newFetchConfiguration() {\r\n-        return _master.newFetchConfiguration();\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct a distributed query to be executed against all the slices.\r\n-     */\r\n-    public StoreQuery newQuery(String language) {\r\n-        ExpressionParser parser = QueryLanguages.parserForLanguage(language);\r\n-        DistributedStoreQuery ret = new DistributedStoreQuery(this, parser);\r\n-        for (SliceStoreManager slice : _slices) {\r\n-            ret.add(slice.newQuery(language));\r\n-        }\r\n-        return ret;\r\n-    }\r\n-\r\n-    /**\r\n-     * Sets the context for this receiver and all its underlying slices.\r\n-     */\r\n-    public void setContext(StoreContext ctx) {\r\n-        super.setContext(ctx);\r\n-        for (SliceStoreManager store : _slices) {\r\n-            store.setContext(ctx, \r\n-                    (JDBCConfiguration)store.getSlice().getConfiguration());\r\n-        }\r\n-    }\r\n-\r\n-    private SliceStoreManager lookup(String name) {\r\n-        for (SliceStoreManager slice : _slices)\r\n-            if (slice.getName().equals(name))\r\n-                return slice;\r\n-        return null;\r\n-    }\r\n-\r\n-    public boolean syncVersion(OpenJPAStateManager sm, Object edata) {\r\n-    \tString[] targets = findSliceNames(sm, edata).getSlices();\r\n-    \tboolean sync = true;\r\n-    \tfor (String replica : targets) {\r\n-    \t\tSliceStoreManager slice = lookup(replica);\r\n-    \t\tsync &= slice.syncVersion(sm, edata);\r\n-    \t}\r\n-    \treturn sync;\r\n-    }\r\n-\r\n-    @Override\r\n-    protected RefCountConnection connectInternal() throws SQLException {\r\n-        List<Connection> list = new ArrayList<Connection>();\r\n-        for (SliceStoreManager slice : _slices)\r\n-            list.add(slice.getConnection());\r\n-        DistributedConnection con = new DistributedConnection(list);\r\n-        return new RefCountConnection(con);\r\n-    }\r\n-    \r\n-    /**\r\n-     * Gets the list of slices mentioned as  \r\n-     * {@link ProductDerivation#HINT_TARGET hint} of the given\r\n-     * {@link FetchConfiguration#getHint(String) fetch configuration}. \r\n-     * \r\n-     * @return all active slices if a) the hint is not specified or b) a null \r\n-     * value or c) a non-String or d) matches no active slice.\r\n-     */\r\n-    List<SliceStoreManager> getTargets(FetchConfiguration fetch) {\r\n-        if (fetch == null)\r\n-            return _slices;\r\n-        Object hint = fetch.getHint(ProductDerivation.HINT_TARGET);\r\n-        if (hint == null || !(hint instanceof String)) \r\n-            return _slices;\r\n-        List<String> targetNames = Arrays.asList(hint.toString().split(\"\\\\,\"));\r\n-        List<SliceStoreManager> targets = new ArrayList<SliceStoreManager>();\r\n-        for (SliceStoreManager slice : _slices) {\r\n-           if (targetNames.contains(slice.getName()))\r\n-              targets.add(slice);\r\n-           }\r\n-          if (targets.isEmpty())\r\n-            return _slices;\r\n-        return targets;\r\n-    }\r\n-    \r\n-    private static class Flusher implements Callable<Collection> {\r\n-        final SliceStoreManager store;\r\n-        final StateManagerSet toFlush;\r\n-\r\n-        Flusher(SliceStoreManager store, StateManagerSet toFlush) {\r\n-            this.store = store;\r\n-            this.toFlush = toFlush;\r\n-        }\r\n-\r\n-        public Collection call() throws Exception {\r\n-        \treturn store.flush(toFlush);\r\n-        }\r\n-    }\r\n-    \r\n-    /**\r\n-     * A specialized, insert-only collection of StateManagers that notes \r\n-     * if any of its member is replicated.\r\n-     *  \r\n-     */\r\n-    private static class StateManagerSet extends HashSet<OpenJPAStateManager> {\r\n-        List<OpenJPAStateManager> replicated;\r\n-        \r\n-        @Override\r\n-        public boolean add(OpenJPAStateManager sm) {\r\n-            boolean isReplicated = sm.getMetaData().isReplicated();\r\n-            if (isReplicated) {\r\n-                if (replicated == null)\r\n-                    replicated = new ArrayList<OpenJPAStateManager>();\r\n-                replicated.add(sm);\r\n-            }\r\n-            return super.add(sm);\r\n-        }\r\n-        \r\n-        @Override\r\n-        public boolean remove(Object sm) {\r\n-            throw new UnsupportedOperationException();\r\n-        }\r\n-        \r\n-        boolean containsReplicated() {\r\n-            return replicated != null && !replicated.isEmpty();\r\n-        }\r\n-        \r\n-        List<OpenJPAStateManager> getReplicated() {\r\n-            return replicated;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.kernel.ConnectionInfo;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.kernel.JDBCStoreManager;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.ResultSetResult;\n+import org.apache.openjpa.kernel.BrokerImpl;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.PCState;\n+import org.apache.openjpa.kernel.QueryLanguages;\n+import org.apache.openjpa.kernel.Seq;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.kernel.exps.ExpressionParser;\n+import org.apache.openjpa.lib.rop.MergedResultObjectProvider;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.slice.DistributedStoreManager;\n+import org.apache.openjpa.slice.ProductDerivation;\n+import org.apache.openjpa.slice.Slice;\n+import org.apache.openjpa.slice.SliceImplHelper;\n+import org.apache.openjpa.slice.SliceInfo;\n+import org.apache.openjpa.slice.SliceThread;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.StoreException;\n+\n+/**\n+ * A Store manager for multiple physical databases referred as <em>slice</em>.\n+ * This receiver behaves like a Transaction Manager as it implements two-phase\n+ * commit protocol if all the component slices is XA-complaint. The actions are\n+ * delegated to the underlying slices. The actions are executed in parallel\n+ * threads whenever possible such as flushing or query. <br>\n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+class DistributedJDBCStoreManager extends JDBCStoreManager \n+    implements DistributedStoreManager {\n+    private final List<SliceStoreManager> _slices;\n+    private JDBCStoreManager _master;\n+    private final DistributedJDBCConfiguration _conf;\n+    private static final Localizer _loc =\n+            Localizer.forPackage(DistributedJDBCStoreManager.class);\n+\n+    /**\n+     * Constructs a set of child StoreManagers each connected to a physical\n+     * DataSource.\n+     * \n+     * The supplied configuration carries multiple URL for underlying physical\n+     * slices. The first slice is referred as <em>master</em> and is used to\n+     * get Sequence based entity identifiers.\n+     */\n+    public DistributedJDBCStoreManager(DistributedJDBCConfiguration conf) {\n+        super();\n+        _conf = conf;\n+        _slices = new ArrayList<SliceStoreManager>();\n+        List<String> sliceNames = conf.getActiveSliceNames();\n+        for (String name : sliceNames) {\n+            SliceStoreManager slice = new SliceStoreManager(conf.getSlice(name));\n+            _slices.add(slice);\n+            if (slice.getName().equals(_conf.getMaster().getName()))\n+                _master = slice;\n+        }\n+    }\n+\n+    public DistributedJDBCConfiguration getConfiguration() {\n+        return _conf;\n+    }\n+    \n+    public SliceStoreManager getSlice(int i) {\n+    \treturn _slices.get(i);\n+    }\n+    \n+    public SliceStoreManager addSlice(Slice slice) {\n+        SliceStoreManager result = new SliceStoreManager(slice);\n+        result.setContext(getContext(), (JDBCConfiguration)slice.getConfiguration());\n+        _slices.add(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Decides the index of the StoreManager by first looking at the\n+     * implementation data. If no implementation data is found, then estimates \n+     * targets slices by using additional connection info. If no additional\n+     * connection info then calls back to user-defined policy. \n+     */\n+    protected SliceInfo findSliceNames(OpenJPAStateManager sm, Object edata) {\n+        if (SliceImplHelper.isSliceAssigned(sm))\n+            return SliceImplHelper.getSliceInfo(sm);\n+        SliceInfo result = null;\n+        PersistenceCapable pc = sm.getPersistenceCapable();\n+        Object ctx = getContext();\n+        if (SliceImplHelper.isReplicated(sm)) {\n+            result = SliceImplHelper.getSlicesByPolicy(pc, _conf, ctx);\n+        } else {\n+            String origin = estimateSlice(sm, edata);\n+            if (origin == null) {\n+                result = SliceImplHelper.getSlicesByPolicy(pc, _conf, ctx);\n+            } else {\n+                result = new SliceInfo(origin);\n+            }\n+        }\n+        return result;\n+    }\n+    \n+    private void assignSlice(OpenJPAStateManager sm, String hint) {\n+        if (SliceImplHelper.isReplicated(sm)) {\n+            SliceImplHelper.getSlicesByPolicy(sm, _conf, getContext())\n+                .setInto(sm);\n+            return;\n+        }\n+        new SliceInfo(hint).setInto(sm);\n+    }\n+    \n+    /**\n+     * The additional edata is used, if possible, to find the StoreManager\n+     * managing the given StateManager. If the additional data is unavailable\n+     * then return null.\n+     * \n+     */\n+    private String estimateSlice(OpenJPAStateManager sm, Object edata) {\n+        if (edata == null || !(edata instanceof ConnectionInfo))\n+            return null;\n+\n+        Result result = ((ConnectionInfo) edata).result;\n+        if (result instanceof ResultSetResult) {\n+            JDBCStore store = ((ResultSetResult) result).getStore();\n+            for (SliceStoreManager slice : _slices) {\n+                if (slice == store) {\n+                    return slice.getName();\n+                }\n+            }\n+        }\n+        return null; \n+    }\n+\n+    /**\n+     * Selects child StoreManager(s) where the given instance resides.\n+     */\n+    private StoreManager selectStore(OpenJPAStateManager sm, Object edata) {\n+        String[] targets = findSliceNames(sm, edata).getSlices();\n+        for (String target : targets) {\n+        \tSliceStoreManager slice = lookup(target);\n+        \tif (slice == null)\n+        \t\tthrow new InternalException(_loc.get(\"wrong-slice\", target, sm));\n+        \treturn slice;\n+        }\n+        return null;\n+    }\n+\n+    public boolean assignField(OpenJPAStateManager sm, int field,\n+            boolean preFlush) {\n+        return selectStore(sm, null).assignField(sm, field, preFlush);\n+    }\n+\n+    public boolean assignObjectId(OpenJPAStateManager sm, boolean preFlush) {\n+        return _master.assignObjectId(sm, preFlush);\n+    }\n+\n+    public void beforeStateChange(OpenJPAStateManager sm, PCState fromState,\n+            PCState toState) {\n+        _master.beforeStateChange(sm, fromState, toState);\n+    }\n+\n+    public void beginOptimistic() {\n+        for (SliceStoreManager slice : _slices)\n+            slice.beginOptimistic();\n+    }\n+\n+    public boolean cancelAll() {\n+        boolean ret = true;\n+        for (SliceStoreManager slice : _slices)\n+            ret = slice.cancelAll() & ret;\n+        return ret;\n+    }\n+\n+    public int compareVersion(OpenJPAStateManager sm, Object v1, Object v2) {\n+        return selectStore(sm, null).compareVersion(sm, v1, v2);\n+    }\n+\n+    public Object copyDataStoreId(Object oid, ClassMetaData meta) {\n+        return _master.copyDataStoreId(oid, meta);\n+    }\n+\n+    public ResultObjectProvider executeExtent(ClassMetaData meta,\n+            boolean subclasses, FetchConfiguration fetch) {\n+        int i = 0;\n+        List<SliceStoreManager> targets = getTargets(fetch);\n+        ResultObjectProvider[] tmp = new ResultObjectProvider[targets.size()];\n+        for (SliceStoreManager slice : targets) {\n+            tmp[i++] = slice.executeExtent(meta, subclasses, fetch);\n+        }\n+        return new MergedResultObjectProvider(tmp);\n+    }\n+\n+    public boolean exists(OpenJPAStateManager sm, Object edata) {\n+    \tString origin = null;\n+        for (SliceStoreManager slice : _slices) {\n+            if (slice.exists(sm, edata)) {\n+            \torigin = slice.getName();\n+            \tbreak;\n+            }\n+        }\n+        if (origin != null)\n+            assignSlice(sm, origin);\n+        return origin != null;\n+    }\n+\n+    \n+    /**\n+     * Flush the given StateManagers after binning them to respective physical\n+     * slices.\n+     */\n+    public Collection flush(Collection sms) {\n+        Collection exceptions = new ArrayList();\n+        List<Future<Collection>> futures = new ArrayList<Future<Collection>>();\n+        Map<String, StateManagerSet> subsets = bin(sms, null);\n+        Collection<StateManagerSet> remaining = \n+            new ArrayList<StateManagerSet>(subsets.values());\n+        ExecutorService threadPool = SliceThread.newPool(_slices.size());\n+        for (int i = 0; i < _slices.size(); i++) {\n+            SliceStoreManager slice = _slices.get(i);\n+            StateManagerSet subset = subsets.get(slice.getName());\n+            if (subset.isEmpty())\n+                continue;\n+            if (subset.containsReplicated()) {\n+                Map<OpenJPAStateManager, Object> oldVersions = cacheVersion(\n+                    subset.getReplicated());\n+            \tcollectException(slice.flush(subset), exceptions);\n+                remaining.remove(subset);\n+            \trollbackVersion(subset.getReplicated(), oldVersions, remaining);\n+            } else {\n+            \tfutures.add(threadPool.submit(new Flusher(slice, subset)));\n+            }\n+        }\n+        for (Future<Collection> future : futures) {\n+            try {\n+            \tcollectException(future.get(), exceptions);\n+            } catch (InterruptedException e) {\n+                throw new StoreException(e);\n+            } catch (ExecutionException e) {\n+                throw new StoreException(e.getCause());\n+            }\n+        }\n+        \n+\t    return exceptions;\n+    }\n+    \n+    private void collectException(Collection error,  Collection holder) {\n+        if (!(error == null || error.isEmpty())) {\n+        \tholder.addAll(error);\n+        }\n+    }\n+    \n+    /**\n+     * Collect the current versions of the given StateManagers.\n+     */\n+    private Map<OpenJPAStateManager, Object> cacheVersion(\n+        List<OpenJPAStateManager> sms) {\n+        Map<OpenJPAStateManager, Object> result = \n+            new HashMap<OpenJPAStateManager, Object>();\n+        for (OpenJPAStateManager sm : sms)\n+            result.put(sm, sm.getVersion());\n+        return result;\n+    }\n+    \n+    /**\n+     * Sets the version of the given StateManagers from the cached versions.\n+     * Provided that the StateManager does not appear in the FlusSets of the\n+     * remaining.\n+     */\n+    private void rollbackVersion(List<OpenJPAStateManager> sms, \n+        Map<OpenJPAStateManager, Object> oldVersions, \n+        Collection<StateManagerSet> reminder) {\n+        if (reminder.isEmpty())\n+            return;\n+        for (OpenJPAStateManager sm : sms) {\n+            if (occurs(sm, reminder))\n+              sm.setVersion(oldVersions.get(sm));\n+        }\n+    }\n+    \n+    boolean occurs(OpenJPAStateManager sm, \n+        Collection<StateManagerSet> reminder) {\n+        for (StateManagerSet set : reminder)\n+            if (set.contains(sm))\n+                return true;\n+        return false;\n+    }\n+    \n+    /**\n+     * Separate the given list of StateManagers in separate lists for each slice \n+     * by the associated slice identifier of each StateManager.\n+     */\n+    private Map<String, StateManagerSet> bin(Collection sms, Object edata) {\n+        Map<String, StateManagerSet> subsets =  \n+            new HashMap<String, StateManagerSet>();\n+        for (SliceStoreManager slice : _slices)\n+            subsets.put(slice.getName(), new StateManagerSet());\n+        for (Object x : sms) {\n+            OpenJPAStateManager sm = (OpenJPAStateManager) x;\n+            String[] targets = findSliceNames(sm, edata).getSlices();\n+           \tfor (String slice : targets) {\n+            \tsubsets.get(slice).add(sm);\n+            }\n+        }\n+        return subsets;\n+    }\n+\n+    public Object getClientConnection() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public Seq getDataStoreIdSequence(ClassMetaData forClass) {\n+        return _master.getDataStoreIdSequence(forClass);\n+    }\n+\n+    public Class getDataStoreIdType(ClassMetaData meta) {\n+        return _master.getDataStoreIdType(meta);\n+    }\n+\n+    public Class getManagedType(Object oid) {\n+        return _master.getManagedType(oid);\n+    }\n+\n+    public Seq getValueSequence(FieldMetaData forField) {\n+        return _master.getValueSequence(forField);\n+    }\n+\n+    public boolean initialize(OpenJPAStateManager sm, PCState state,\n+            FetchConfiguration fetch, Object edata) {\n+        if (edata instanceof ConnectionInfo) {\n+            String origin = estimateSlice(sm, edata);\n+            if (origin != null) {\n+                if (lookup(origin).initialize(sm, state, fetch, edata)) {\n+                    assignSlice(sm, origin);\n+                    return true;\n+                }\n+            }\n+        }\n+        // not a part of Query result load. Look into the slices till found\n+        List<SliceStoreManager> targets = getTargets(fetch);\n+        for (SliceStoreManager slice : targets) {\n+            if (slice.initialize(sm, state, fetch, edata)) {\n+                assignSlice(sm, slice.getName());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean load(OpenJPAStateManager sm, BitSet fields,\n+            FetchConfiguration fetch, int lockLevel, Object edata) {\n+        return selectStore(sm, edata).load(sm, fields, fetch, lockLevel, edata);\n+    }\n+\n+    public Collection loadAll(Collection sms, PCState state, int load,\n+            FetchConfiguration fetch, Object edata) {\n+        Map<String, StateManagerSet> subsets = bin(sms, edata);\n+        Collection result = new ArrayList();\n+        for (SliceStoreManager slice : _slices) {\n+            StateManagerSet subset = subsets.get(slice.getName());\n+            if (subset.isEmpty())\n+                continue;\n+            Collection tmp = slice.loadAll(subset, state, load, fetch, edata);\n+            if (tmp != null && !tmp.isEmpty())\n+                result.addAll(tmp);\n+        }\n+        return result;\n+    }\n+\n+    public Object newDataStoreId(Object oidVal, ClassMetaData meta) {\n+        return _master.newDataStoreId(oidVal, meta);\n+    }\n+\n+    public FetchConfiguration newFetchConfiguration() {\n+        return _master.newFetchConfiguration();\n+    }\n+\n+    /**\n+     * Construct a distributed query to be executed against all the slices.\n+     */\n+    public StoreQuery newQuery(String language) {\n+        ExpressionParser parser = QueryLanguages.parserForLanguage(language);\n+        DistributedStoreQuery ret = new DistributedStoreQuery(this, parser);\n+        for (SliceStoreManager slice : _slices) {\n+            ret.add(slice.newQuery(language));\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Sets the context for this receiver and all its underlying slices.\n+     */\n+    public void setContext(StoreContext ctx) {\n+        super.setContext(ctx);\n+        for (SliceStoreManager store : _slices) {\n+            store.setContext(ctx, \n+                    (JDBCConfiguration)store.getSlice().getConfiguration());\n+        }\n+    }\n+\n+    private SliceStoreManager lookup(String name) {\n+        for (SliceStoreManager slice : _slices)\n+            if (slice.getName().equals(name))\n+                return slice;\n+        return null;\n+    }\n+\n+    public boolean syncVersion(OpenJPAStateManager sm, Object edata) {\n+    \tString[] targets = findSliceNames(sm, edata).getSlices();\n+    \tboolean sync = true;\n+    \tfor (String replica : targets) {\n+    \t\tSliceStoreManager slice = lookup(replica);\n+    \t\tsync &= slice.syncVersion(sm, edata);\n+    \t}\n+    \treturn sync;\n+    }\n+\n+    @Override\n+    protected RefCountConnection connectInternal() throws SQLException {\n+        List<Connection> list = new ArrayList<Connection>();\n+        for (SliceStoreManager slice : _slices)\n+            list.add(slice.getConnection());\n+        DistributedConnection con = new DistributedConnection(list);\n+        return new RefCountConnection(con);\n+    }\n+    \n+    /**\n+     * Gets the list of slices mentioned as  \n+     * {@link ProductDerivation#HINT_TARGET hint} of the given\n+     * {@link FetchConfiguration#getHint(String) fetch configuration}. \n+     * \n+     * @return all active slices if a) the hint is not specified or b) a null \n+     * value or c) a non-String or d) matches no active slice.\n+     */\n+    List<SliceStoreManager> getTargets(FetchConfiguration fetch) {\n+        if (fetch == null)\n+            return _slices;\n+        Object hint = fetch.getHint(ProductDerivation.HINT_TARGET);\n+        if (hint == null || !(hint instanceof String)) \n+            return _slices;\n+        List<String> targetNames = Arrays.asList(hint.toString().split(\"\\\\,\"));\n+        List<SliceStoreManager> targets = new ArrayList<SliceStoreManager>();\n+        for (SliceStoreManager slice : _slices) {\n+           if (targetNames.contains(slice.getName()))\n+              targets.add(slice);\n+           }\n+          if (targets.isEmpty())\n+            return _slices;\n+        return targets;\n+    }\n+    \n+    private static class Flusher implements Callable<Collection> {\n+        final SliceStoreManager store;\n+        final StateManagerSet toFlush;\n+\n+        Flusher(SliceStoreManager store, StateManagerSet toFlush) {\n+            this.store = store;\n+            this.toFlush = toFlush;\n+        }\n+\n+        public Collection call() throws Exception {\n+        \treturn store.flush(toFlush);\n+        }\n+    }\n+    \n+    /**\n+     * A specialized, insert-only collection of StateManagers that notes \n+     * if any of its member is replicated.\n+     *  \n+     */\n+    private static class StateManagerSet extends HashSet<OpenJPAStateManager> {\n+        List<OpenJPAStateManager> replicated;\n+        \n+        @Override\n+        public boolean add(OpenJPAStateManager sm) {\n+            boolean isReplicated = sm.getMetaData().isReplicated();\n+            if (isReplicated) {\n+                if (replicated == null)\n+                    replicated = new ArrayList<OpenJPAStateManager>();\n+                replicated.add(sm);\n+            }\n+            return super.add(sm);\n+        }\n+        \n+        @Override\n+        public boolean remove(Object sm) {\n+            throw new UnsupportedOperationException();\n+        }\n+        \n+        boolean containsReplicated() {\n+            return replicated != null && !replicated.isEmpty();\n+        }\n+        \n+        List<OpenJPAStateManager> getReplicated() {\n+            return replicated;\n+        }\n+    }\n+}"},{"sha":"49776e2ed0fd9c52a317969005f61ca78738b081","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedPreparedStatement.java","status":"modified","additions":247,"deletions":247,"changes":494,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedPreparedStatement.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedPreparedStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedPreparedStatement.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,247 +1,247 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.jdbc;\r\n-\r\n-import java.io.InputStream;\r\n-import java.io.Reader;\r\n-import java.math.BigDecimal;\r\n-import java.net.URL;\r\n-import java.sql.Array;\r\n-import java.sql.Blob;\r\n-import java.sql.Clob;\r\n-import java.sql.Date;\r\n-import java.sql.ParameterMetaData;\r\n-import java.sql.PreparedStatement;\r\n-import java.sql.Ref;\r\n-import java.sql.ResultSet;\r\n-import java.sql.ResultSetMetaData;\r\n-import java.sql.SQLException;\r\n-import java.sql.Time;\r\n-import java.sql.Timestamp;\r\n-import java.util.Calendar;\r\n-\r\n-/**\r\n- * A virtual PreparedStaement that delegates to a set of actual PreparedStatements.\r\n- * \r\n- * @author Pinaki Poddar \r\n- *\r\n- */\r\n-class DistributedPreparedStatement extends DistributedTemplate<PreparedStatement>\r\n-\t\timplements PreparedStatement {\r\n-\r\n-\tDistributedPreparedStatement(DistributedConnection c) {\r\n-\t\tsuper(c);\r\n-\t}\r\n-\r\n-\tpublic void clearParameters() throws SQLException {\r\n-\t\tfor (PreparedStatement s : this)\r\n-\t\t\ts.clearParameters();\r\n-\t}\r\n-\r\n-\tpublic boolean execute() throws SQLException {\r\n-\t\tboolean ret = true;\r\n-\t\tfor (PreparedStatement s : this)\r\n-\t\t\tret = s.execute() & ret;\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic ResultSet executeQuery() throws SQLException {\r\n-\t\tDistributedResultSet mrs = new DistributedResultSet();\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tmrs.add(t.executeQuery());\r\n-\t\treturn mrs;\r\n-\t}\r\n-\r\n-\tpublic int executeUpdate() throws SQLException {\r\n-\t\tint ret = 0;\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tret += t.executeUpdate();\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic ResultSetMetaData getMetaData() throws SQLException {\r\n-\t\treturn master.getMetaData();\r\n-\t}\r\n-\r\n-\tpublic ParameterMetaData getParameterMetaData() throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void setArray(int i, Array x) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setArray(i, x);\r\n-\t}\r\n-\r\n-\tpublic void setAsciiStream(int arg0, InputStream arg1, int arg2)\r\n-\t\t\tthrows SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setAsciiStream(arg0, arg1, arg2);\r\n-\t}\r\n-\r\n-\tpublic void setBigDecimal(int arg0, BigDecimal arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setBigDecimal(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic void setBinaryStream(int arg0, InputStream arg1, int arg2)\r\n-\t\t\tthrows SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setBinaryStream(arg0, arg1, arg2);\r\n-\t}\r\n-\r\n-\tpublic void setBlob(int arg0, Blob arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setBlob(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic void setBoolean(int arg0, boolean arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setBoolean(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic void setByte(int arg0, byte arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setByte(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic void setBytes(int arg0, byte[] arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setBytes(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic void setCharacterStream(int arg0, Reader arg1, int arg2)\r\n-\t\t\tthrows SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setCharacterStream(arg0, arg1, arg2);\r\n-\t}\r\n-\r\n-\tpublic void setClob(int arg0, Clob arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setClob(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic void setDate(int arg0, Date arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setDate(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic void setDate(int arg0, Date arg1, Calendar arg2) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setDate(arg0, arg1, arg2);\r\n-\t}\r\n-\r\n-\tpublic void setDouble(int arg0, double arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setDouble(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic void setFloat(int arg0, float arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setFloat(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic void setInt(int arg0, int arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setInt(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic void setLong(int arg0, long arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setLong(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic void setNull(int arg0, int arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setNull(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic void setNull(int arg0, int arg1, String arg2) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setNull(arg0, arg1, arg2);\r\n-\t}\r\n-\r\n-\tpublic void setObject(int arg0, Object arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setObject(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic void setObject(int arg0, Object arg1, int arg2) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setObject(arg0, arg1, arg2);\r\n-\t}\r\n-\r\n-\tpublic void setObject(int arg0, Object arg1, int arg2, int arg3)\r\n-\t\t\tthrows SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setObject(arg0, arg1, arg2, arg3);\r\n-\t}\r\n-\r\n-\tpublic void setRef(int arg0, Ref arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setRef(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic void setShort(int arg0, short arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setShort(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic void setString(int arg0, String arg1) throws SQLException {\r\n-\t\tfor (PreparedStatement t : this)\r\n-\t\t\tt.setString(arg0, arg1);\r\n-\t}\r\n-\r\n-\t public void setTime(int arg0, Time arg1) throws SQLException {\r\n-\t\t\tfor (PreparedStatement t : this)\r\n-\t\t\t\tt.setTime(arg0, arg1);\r\n-\t }\r\n-\t\r\n-\t public void setTime(int arg0, Time arg1, Calendar arg2) throws\r\n-\t SQLException {\r\n-\t\t\tfor (PreparedStatement t : this)\r\n-\t\t\t\tt.setTime(arg0, arg1, arg2);\r\n-\t }\r\n-\t\r\n-\t public void setTimestamp(int arg0, Timestamp arg1) throws SQLException {\r\n-\t\t\tfor (PreparedStatement t : this)\r\n-\t\t\t\tt.setTimestamp(arg0, arg1);\r\n-\t }\r\n-\t\r\n-\t public void setTimestamp(int arg0, Timestamp arg1, Calendar arg2)\r\n-\t throws SQLException {\r\n-\t\t\tfor (PreparedStatement t : this)\r\n-\t\t\t\tt.setTimestamp(arg0, arg1, arg2);\r\n-\t }\r\n-\t\r\n-\t public void setURL(int arg0, URL arg1) throws SQLException {\r\n-\t\t\tfor (PreparedStatement t : this)\r\n-\t\t\t\tt.setURL(arg0, arg1);\r\n-\t }\r\n-\t\r\n-\t public void setUnicodeStream(int arg0, InputStream arg1, int arg2)\r\n-\t     throws SQLException {\r\n-\t\t\tfor (PreparedStatement t : this)\r\n-\t\t\t\tt.setUnicodeStream(arg0, arg1, arg2);\r\n-\t }\r\n-\t\r\n-\t public void addBatch() throws SQLException {\r\n-\t\tfor (PreparedStatement t:this)\r\n-\t\t    t.addBatch();\r\n-\t }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.jdbc;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.net.URL;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.ParameterMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.Ref;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.util.Calendar;\n+\n+/**\n+ * A virtual PreparedStaement that delegates to a set of actual PreparedStatements.\n+ * \n+ * @author Pinaki Poddar \n+ *\n+ */\n+class DistributedPreparedStatement extends DistributedTemplate<PreparedStatement>\n+\t\timplements PreparedStatement {\n+\n+\tDistributedPreparedStatement(DistributedConnection c) {\n+\t\tsuper(c);\n+\t}\n+\n+\tpublic void clearParameters() throws SQLException {\n+\t\tfor (PreparedStatement s : this)\n+\t\t\ts.clearParameters();\n+\t}\n+\n+\tpublic boolean execute() throws SQLException {\n+\t\tboolean ret = true;\n+\t\tfor (PreparedStatement s : this)\n+\t\t\tret = s.execute() & ret;\n+\t\treturn ret;\n+\t}\n+\n+\tpublic ResultSet executeQuery() throws SQLException {\n+\t\tDistributedResultSet mrs = new DistributedResultSet();\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tmrs.add(t.executeQuery());\n+\t\treturn mrs;\n+\t}\n+\n+\tpublic int executeUpdate() throws SQLException {\n+\t\tint ret = 0;\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tret += t.executeUpdate();\n+\t\treturn ret;\n+\t}\n+\n+\tpublic ResultSetMetaData getMetaData() throws SQLException {\n+\t\treturn master.getMetaData();\n+\t}\n+\n+\tpublic ParameterMetaData getParameterMetaData() throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void setArray(int i, Array x) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setArray(i, x);\n+\t}\n+\n+\tpublic void setAsciiStream(int arg0, InputStream arg1, int arg2)\n+\t\t\tthrows SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setAsciiStream(arg0, arg1, arg2);\n+\t}\n+\n+\tpublic void setBigDecimal(int arg0, BigDecimal arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setBigDecimal(arg0, arg1);\n+\t}\n+\n+\tpublic void setBinaryStream(int arg0, InputStream arg1, int arg2)\n+\t\t\tthrows SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setBinaryStream(arg0, arg1, arg2);\n+\t}\n+\n+\tpublic void setBlob(int arg0, Blob arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setBlob(arg0, arg1);\n+\t}\n+\n+\tpublic void setBoolean(int arg0, boolean arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setBoolean(arg0, arg1);\n+\t}\n+\n+\tpublic void setByte(int arg0, byte arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setByte(arg0, arg1);\n+\t}\n+\n+\tpublic void setBytes(int arg0, byte[] arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setBytes(arg0, arg1);\n+\t}\n+\n+\tpublic void setCharacterStream(int arg0, Reader arg1, int arg2)\n+\t\t\tthrows SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setCharacterStream(arg0, arg1, arg2);\n+\t}\n+\n+\tpublic void setClob(int arg0, Clob arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setClob(arg0, arg1);\n+\t}\n+\n+\tpublic void setDate(int arg0, Date arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setDate(arg0, arg1);\n+\t}\n+\n+\tpublic void setDate(int arg0, Date arg1, Calendar arg2) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setDate(arg0, arg1, arg2);\n+\t}\n+\n+\tpublic void setDouble(int arg0, double arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setDouble(arg0, arg1);\n+\t}\n+\n+\tpublic void setFloat(int arg0, float arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setFloat(arg0, arg1);\n+\t}\n+\n+\tpublic void setInt(int arg0, int arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setInt(arg0, arg1);\n+\t}\n+\n+\tpublic void setLong(int arg0, long arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setLong(arg0, arg1);\n+\t}\n+\n+\tpublic void setNull(int arg0, int arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setNull(arg0, arg1);\n+\t}\n+\n+\tpublic void setNull(int arg0, int arg1, String arg2) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setNull(arg0, arg1, arg2);\n+\t}\n+\n+\tpublic void setObject(int arg0, Object arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setObject(arg0, arg1);\n+\t}\n+\n+\tpublic void setObject(int arg0, Object arg1, int arg2) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setObject(arg0, arg1, arg2);\n+\t}\n+\n+\tpublic void setObject(int arg0, Object arg1, int arg2, int arg3)\n+\t\t\tthrows SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setObject(arg0, arg1, arg2, arg3);\n+\t}\n+\n+\tpublic void setRef(int arg0, Ref arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setRef(arg0, arg1);\n+\t}\n+\n+\tpublic void setShort(int arg0, short arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setShort(arg0, arg1);\n+\t}\n+\n+\tpublic void setString(int arg0, String arg1) throws SQLException {\n+\t\tfor (PreparedStatement t : this)\n+\t\t\tt.setString(arg0, arg1);\n+\t}\n+\n+\t public void setTime(int arg0, Time arg1) throws SQLException {\n+\t\t\tfor (PreparedStatement t : this)\n+\t\t\t\tt.setTime(arg0, arg1);\n+\t }\n+\t\n+\t public void setTime(int arg0, Time arg1, Calendar arg2) throws\n+\t SQLException {\n+\t\t\tfor (PreparedStatement t : this)\n+\t\t\t\tt.setTime(arg0, arg1, arg2);\n+\t }\n+\t\n+\t public void setTimestamp(int arg0, Timestamp arg1) throws SQLException {\n+\t\t\tfor (PreparedStatement t : this)\n+\t\t\t\tt.setTimestamp(arg0, arg1);\n+\t }\n+\t\n+\t public void setTimestamp(int arg0, Timestamp arg1, Calendar arg2)\n+\t throws SQLException {\n+\t\t\tfor (PreparedStatement t : this)\n+\t\t\t\tt.setTimestamp(arg0, arg1, arg2);\n+\t }\n+\t\n+\t public void setURL(int arg0, URL arg1) throws SQLException {\n+\t\t\tfor (PreparedStatement t : this)\n+\t\t\t\tt.setURL(arg0, arg1);\n+\t }\n+\t\n+\t public void setUnicodeStream(int arg0, InputStream arg1, int arg2)\n+\t     throws SQLException {\n+\t\t\tfor (PreparedStatement t : this)\n+\t\t\t\tt.setUnicodeStream(arg0, arg1, arg2);\n+\t }\n+\t\n+\t public void addBatch() throws SQLException {\n+\t\tfor (PreparedStatement t:this)\n+\t\t    t.addBatch();\n+\t }\n+}"},{"sha":"4dc26db5837de231c88211f94ad7fa9822ffc6fa","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedResultSet.java","status":"modified","additions":685,"deletions":685,"changes":1370,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedResultSet.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedResultSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedResultSet.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,685 +1,685 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.jdbc;\r\n-\r\n-import java.io.InputStream;\r\n-import java.io.Reader;\r\n-import java.math.BigDecimal;\r\n-import java.net.URL;\r\n-import java.sql.Array;\r\n-import java.sql.Blob;\r\n-import java.sql.Clob;\r\n-import java.sql.Date;\r\n-import java.sql.Ref;\r\n-import java.sql.ResultSet;\r\n-import java.sql.ResultSetMetaData;\r\n-import java.sql.SQLException;\r\n-import java.sql.SQLWarning;\r\n-import java.sql.Statement;\r\n-import java.sql.Time;\r\n-import java.sql.Timestamp;\r\n-import java.util.Calendar;\r\n-import java.util.LinkedList;\r\n-import java.util.Map;\r\n-\r\n-/**\r\n- * A chain of ResultSet.\r\n- * Assumes added ResultSet are identical in structure and fetches forward.\r\n- * Can not move absolutely or change fetch direction. \r\n- * \r\n- * @author Pinaki Poddar \r\n- *\r\n- */\r\n-class DistributedResultSet implements ResultSet {\r\n-\tprivate LinkedList<ResultSet> comps = new LinkedList<ResultSet>();\r\n-\tprivate ResultSet current;\r\n-\tprivate int cursor = -1;\r\n-\t\r\n-\t/**\r\n-\t * Adds the ResultSet only if it has rows.\r\n-\t */\r\n-\tpublic void add(ResultSet rs) {\r\n-\t\ttry {\r\n-\t\t\tif (rs.first()) {\r\n-\t\t\t\tcomps.add(rs);\r\n-\t\t\t\trs.beforeFirst();\r\n-\t\t\t}\r\n-\t\t} catch (SQLException e) {\r\n-\t\t\t// ignore\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\tpublic boolean absolute(int arg0) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void afterLast() throws SQLException {\r\n-\t\tcurrent = null;\r\n-\t\tcursor  = comps.size();\r\n-\t}\r\n-\r\n-\tpublic void beforeFirst() throws SQLException {\r\n-\t\tcurrent = null;\r\n-\t\tcursor  = -1;\r\n-\t}\r\n-\r\n-\tpublic void cancelRowUpdates() throws SQLException {\r\n-\t\tcurrent.cancelRowUpdates();\r\n-\t}\r\n-\r\n-\tpublic void clearWarnings() throws SQLException {\r\n-\t\tfor (ResultSet rs : comps)\r\n-\t\t\trs.clearWarnings();\r\n-\t}\r\n-\r\n-\tpublic void close() throws SQLException {\r\n-\t\tfor (ResultSet rs : comps)\r\n-\t\t\trs.close();\r\n-\t}\r\n- \r\n-\tpublic void deleteRow() throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic int findColumn(String arg0) throws SQLException {\r\n-\t\treturn current.findColumn(arg0);\r\n-\t}\r\n-\r\n-\tpublic boolean first() throws SQLException {\r\n-\t\tif (comps.isEmpty()) \r\n-\t\t\treturn false;\r\n-\t\tcursor = 0;\r\n-\t\tcurrent = comps.getFirst();\r\n-\t\treturn true;\r\n-\t}\r\n-\r\n-\tpublic Array getArray(int arg0) throws SQLException {\r\n-\t\treturn current.getArray(arg0);\r\n-\t}\r\n-\r\n-\tpublic Array getArray(String arg0) throws SQLException {\r\n-\t\treturn current.getArray(arg0);\r\n-\t}\r\n-\r\n-\tpublic InputStream getAsciiStream(int arg0) throws SQLException {\r\n-\t\treturn current.getAsciiStream(arg0);\r\n-\t}\r\n-\r\n-\tpublic InputStream getAsciiStream(String arg0) throws SQLException {\r\n-\t\treturn current.getAsciiStream(arg0);\r\n-\t}\r\n-\r\n-\tpublic BigDecimal getBigDecimal(int arg0) throws SQLException {\r\n-\t\treturn current.getBigDecimal(arg0);\r\n-\t}\r\n-\r\n-\tpublic BigDecimal getBigDecimal(String arg0) throws SQLException {\r\n-\t\treturn current.getBigDecimal(arg0);\r\n-\t}\r\n-\r\n-\tpublic BigDecimal getBigDecimal(int arg0, int arg1) throws SQLException {\r\n-\t\treturn current.getBigDecimal(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic BigDecimal getBigDecimal(String arg0, int arg1) throws SQLException {\r\n-\t\treturn current.getBigDecimal(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic InputStream getBinaryStream(int arg0) throws SQLException {\r\n-\t\treturn current.getBinaryStream(arg0);\r\n-\t}\r\n-\r\n-\tpublic InputStream getBinaryStream(String arg0) throws SQLException {\r\n-\t\treturn current.getBinaryStream(arg0);\r\n-\t}\r\n-\r\n-\tpublic Blob getBlob(int arg0) throws SQLException {\r\n-\t\treturn current.getBlob(arg0);\r\n-\t}\r\n-\r\n-\tpublic Blob getBlob(String arg0) throws SQLException {\r\n-\t\treturn current.getBlob(arg0);\r\n-\t}\r\n-\r\n-\tpublic boolean getBoolean(int arg0) throws SQLException {\r\n-\t\treturn current.getBoolean(arg0);\r\n-\t}\r\n-\r\n-\tpublic boolean getBoolean(String arg0) throws SQLException {\r\n-\t\treturn current.getBoolean(arg0);\r\n-\t}\r\n-\r\n-\tpublic byte getByte(int arg0) throws SQLException {\r\n-\t\treturn current.getByte(arg0);\r\n-\t}\r\n-\r\n-\tpublic byte getByte(String arg0) throws SQLException {\r\n-\t\treturn current.getByte(arg0);\r\n-\t}\r\n-\r\n-\tpublic byte[] getBytes(int arg0) throws SQLException {\r\n-\t\treturn current.getBytes(arg0);\r\n-\t}\r\n-\r\n-\tpublic byte[] getBytes(String arg0) throws SQLException {\r\n-\t\treturn current.getBytes(arg0);\r\n-\t}\r\n-\r\n-\tpublic Reader getCharacterStream(int arg0) throws SQLException {\r\n-\t\treturn current.getCharacterStream(arg0);\r\n-\t}\r\n-\r\n-\tpublic Reader getCharacterStream(String arg0) throws SQLException {\r\n-\t\treturn current.getCharacterStream(arg0);\r\n-\t}\r\n-\r\n-\tpublic Clob getClob(int arg0) throws SQLException {\r\n-\t\treturn current.getClob(arg0);\r\n-\t}\r\n-\r\n-\tpublic Clob getClob(String arg0) throws SQLException {\r\n-\t\treturn current.getClob(arg0);\r\n-\t}\r\n-\r\n-\tpublic int getConcurrency() throws SQLException {\r\n-\t\treturn current.getConcurrency();\r\n-\t}\r\n-\r\n-\tpublic String getCursorName() throws SQLException {\r\n-\t\treturn current.getCursorName();\r\n-\t}\r\n-\r\n-\tpublic Date getDate(int arg0) throws SQLException {\r\n-\t\treturn current.getDate(arg0);\r\n-\t}\r\n-\r\n-\tpublic Date getDate(String arg0) throws SQLException {\r\n-\t\treturn current.getDate(arg0);\r\n-\t}\r\n-\r\n-\tpublic Date getDate(int arg0, Calendar arg1) throws SQLException {\r\n-\t\treturn current.getDate(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic Date getDate(String arg0, Calendar arg1) throws SQLException {\r\n-\t\treturn current.getDate(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic double getDouble(int arg0) throws SQLException {\r\n-\t\treturn current.getDouble(arg0);\r\n-\t}\r\n-\r\n-\tpublic double getDouble(String arg0) throws SQLException {\r\n-\t\treturn current.getDouble(arg0);\r\n-\t}\r\n-\r\n-\tpublic int getFetchDirection() throws SQLException {\r\n-\t\treturn current.getFetchDirection();\r\n-\t}\r\n-\r\n-\tpublic int getFetchSize() throws SQLException {\r\n-\t\treturn current.getFetchSize();\r\n-\t}\r\n-\r\n-\tpublic float getFloat(int arg0) throws SQLException {\r\n-\t\treturn current.getFloat(arg0);\r\n-\t}\r\n-\r\n-\tpublic float getFloat(String arg0) throws SQLException {\r\n-\t\treturn current.getFloat(arg0);\r\n-\t}\r\n-\r\n-\tpublic int getInt(int arg0) throws SQLException {\r\n-\t\treturn current.getInt(arg0);\r\n-\t}\r\n-\r\n-\tpublic int getInt(String arg0) throws SQLException {\r\n-\t\treturn current.getInt(arg0);\r\n-\t}\r\n-\r\n-\tpublic long getLong(int arg0) throws SQLException {\r\n-\t\treturn current.getLong(arg0);\r\n-\t}\r\n-\r\n-\tpublic long getLong(String arg0) throws SQLException {\r\n-\t\treturn current.getLong(arg0);\r\n-\t}\r\n-\r\n-\tpublic ResultSetMetaData getMetaData() throws SQLException {\r\n-\t\treturn current.getMetaData();\r\n-\t}\r\n-\r\n-\tpublic Object getObject(int arg0) throws SQLException {\r\n-\t\treturn current.getObject(arg0);\r\n-\t}\r\n-\r\n-\tpublic Object getObject(String arg0) throws SQLException {\r\n-\t\treturn current.getObject(arg0);\r\n-\t}\r\n-\r\n-\tpublic Object getObject(int arg0, Map<String, Class<?>> arg1)\r\n-\t\t\tthrows SQLException {\r\n-\t\treturn current.getObject(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic Object getObject(String arg0, Map<String, Class<?>> arg1)\r\n-\t\t\tthrows SQLException {\r\n-\t\treturn current.getObject(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic Ref getRef(int arg0) throws SQLException {\r\n-\t\treturn current.getRef(arg0);\r\n-\t}\r\n-\r\n-\tpublic Ref getRef(String arg0) throws SQLException {\r\n-\t\treturn current.getRef(arg0);\r\n-\t}\r\n-\r\n-\tpublic int getRow() throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic short getShort(int arg0) throws SQLException {\r\n-\t\treturn current.getShort(arg0);\r\n-\t}\r\n-\r\n-\tpublic short getShort(String arg0) throws SQLException {\r\n-\t\treturn current.getShort(arg0);\r\n-\t}\r\n-\r\n-\tpublic Statement getStatement() throws SQLException {\r\n-\t\treturn current.getStatement();\r\n-\t}\r\n-\r\n-\tpublic String getString(int arg0) throws SQLException {\r\n-\t\treturn current.getString(arg0);\r\n-\t}\r\n-\r\n-\tpublic String getString(String arg0) throws SQLException {\r\n-\t\treturn current.getString(arg0);\r\n-\t}\r\n-\r\n-\tpublic Time getTime(int arg0) throws SQLException {\r\n-\t\treturn current.getTime(arg0);\r\n-\t}\r\n-\r\n-\tpublic Time getTime(String arg0) throws SQLException {\r\n-\t\treturn current.getTime(arg0);\r\n-\t}\r\n-\r\n-\tpublic Time getTime(int arg0, Calendar arg1) throws SQLException {\r\n-\t\treturn current.getTime(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic Time getTime(String arg0, Calendar arg1) throws SQLException {\r\n-\t\treturn current.getTime(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic Timestamp getTimestamp(int arg0) throws SQLException {\r\n-\t\treturn current.getTimestamp(arg0);\r\n-\t}\r\n-\r\n-\tpublic Timestamp getTimestamp(String arg0) throws SQLException {\r\n-\t\treturn current.getTimestamp(arg0);\r\n-\t}\r\n-\r\n-\tpublic Timestamp getTimestamp(int arg0, Calendar arg1) throws SQLException {\r\n-\t\treturn current.getTimestamp(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic Timestamp getTimestamp(String arg0, Calendar arg1)\r\n-\t\t\tthrows SQLException {\r\n-\t\treturn current.getTimestamp(arg0, arg1);\r\n-\t}\r\n-\r\n-\tpublic int getType() throws SQLException {\r\n-\t\treturn current.getType();\r\n-\t}\r\n-\r\n-\tpublic URL getURL(int arg0) throws SQLException {\r\n-\t\treturn current.getURL(arg0);\r\n-\t}\r\n-\r\n-\tpublic URL getURL(String arg0) throws SQLException {\r\n-\t\treturn current.getURL(arg0);\r\n-\t}\r\n-\r\n-\tpublic InputStream getUnicodeStream(int arg0) throws SQLException {\r\n-\t\treturn current.getUnicodeStream(arg0);\r\n-\t}\r\n-\r\n-\tpublic InputStream getUnicodeStream(String arg0) throws SQLException {\r\n-\t\treturn current.getUnicodeStream(arg0);\r\n-\t}\r\n-\r\n-\tpublic SQLWarning getWarnings() throws SQLException {\r\n-\t\treturn current.getWarnings();\r\n-\t}\r\n-\r\n-\tpublic void insertRow() throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic boolean isAfterLast() throws SQLException {\r\n-\t\treturn current == null && cursor >= comps.size();\r\n-\t}\r\n-\r\n-\tpublic boolean isBeforeFirst() throws SQLException {\r\n-\t\treturn current == null && cursor < 0;\r\n-\t}\r\n-\r\n-\tpublic boolean isFirst() throws SQLException {\r\n-\t\treturn current != null && current.isFirst() && cursor == 0;\r\n-\t}\r\n-\r\n-\tpublic boolean isLast() throws SQLException {\r\n-\t\treturn current != null && current.isLast() && cursor == comps.size()-1;\r\n-\t}\r\n-\r\n-\tpublic boolean last() throws SQLException {\r\n-\t\tif (comps.isEmpty()) \r\n-\t\t\treturn false;\r\n-\t\tcursor = comps.size()-1;\r\n-\t\tcurrent = comps.getLast();\r\n-\t\treturn current.last();\r\n-\t}\r\n-\r\n-\tpublic void moveToCurrentRow() throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void moveToInsertRow() throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic boolean next() throws SQLException {\r\n-\t\tif (comps.isEmpty())\r\n-\t\t\treturn false;\r\n-\t\tif (current == null) {\r\n-\t\t\tcurrent = comps.getFirst();\r\n-\t\t\tcursor = 0;\r\n-\t\t}\r\n-\t\tif (current.next())\r\n-\t\t\treturn true;\r\n-\t\tcursor++;\r\n-\t\tif (cursor < comps.size()) {\r\n-\t\t\tcurrent = comps.get(cursor);\r\n-\t\t\treturn current.first();\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\tpublic boolean previous() throws SQLException {\r\n-\t\tif (comps.isEmpty())\r\n-\t\t\treturn false;\r\n-\t\tif (current.previous())\r\n-\t\t\treturn true;\r\n-\t\tcursor--;\r\n-\t\tif (cursor >= 0) {\r\n-\t\t\tcurrent = comps.get(cursor);\r\n-\t\t\treturn current.last();\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\tpublic void refreshRow() throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic boolean relative(int arg0) throws SQLException {\r\n-\t\tif (arg0 == 0)\r\n-\t\t\treturn current != null;\r\n-\t\tboolean forward = arg0 > 0;\r\n-\t\tfor (int i = 0; i < arg0; i++) {\r\n-\t\t\tif (forward) {\r\n-\t\t\t\tif (!next()) {\r\n-\t\t\t\t\treturn false;\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\tif (!previous()) {\r\n-\t\t\t\t\treturn false;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\tpublic boolean rowDeleted() throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic boolean rowInserted() throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic boolean rowUpdated() throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void setFetchDirection(int arg0) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void setFetchSize(int arg0) throws SQLException {\r\n-\t\tfor (ResultSet rs : comps)\r\n-\t\t\trs.setFetchSize(arg0);\r\n-\t}\r\n-\r\n-\tpublic void updateArray(int arg0, Array arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateArray(String arg0, Array arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateAsciiStream(int arg0, InputStream arg1, int arg2)\r\n-\t\t\tthrows SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateAsciiStream(String arg0, InputStream arg1, int arg2)\r\n-\t\t\tthrows SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateBigDecimal(int arg0, BigDecimal arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateBigDecimal(String arg0, BigDecimal arg1)\r\n-\t\t\tthrows SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateBinaryStream(int arg0, InputStream arg1, int arg2)\r\n-\t\t\tthrows SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateBinaryStream(String arg0, InputStream arg1, int arg2)\r\n-\t\t\tthrows SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateBlob(int arg0, Blob arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateBlob(String arg0, Blob arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateBoolean(int arg0, boolean arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateBoolean(String arg0, boolean arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateByte(int arg0, byte arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateByte(String arg0, byte arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateBytes(int arg0, byte[] arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateBytes(String arg0, byte[] arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateCharacterStream(int arg0, Reader arg1, int arg2)\r\n-\t\t\tthrows SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateCharacterStream(String arg0, Reader arg1, int arg2)\r\n-\t\t\tthrows SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateClob(int arg0, Clob arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateClob(String arg0, Clob arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateDate(int arg0, Date arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateDate(String arg0, Date arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateDouble(int arg0, double arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateDouble(String arg0, double arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateFloat(int arg0, float arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateFloat(String arg0, float arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateInt(int arg0, int arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateInt(String arg0, int arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateLong(int arg0, long arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateLong(String arg0, long arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateNull(int arg0) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateNull(String arg0) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateObject(int arg0, Object arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateObject(String arg0, Object arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateObject(int arg0, Object arg1, int arg2)\r\n-\t\t\tthrows SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateObject(String arg0, Object arg1, int arg2)\r\n-\t\t\tthrows SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateRef(int arg0, Ref arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateRef(String arg0, Ref arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateRow() throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateShort(int arg0, short arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateShort(String arg0, short arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateString(int arg0, String arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateString(String arg0, String arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateTime(int arg0, Time arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateTime(String arg0, Time arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateTimestamp(int arg0, Timestamp arg1) throws SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic void updateTimestamp(String arg0, Timestamp arg1)\r\n-\t\t\tthrows SQLException {\r\n-\t\tthrow new UnsupportedOperationException();\r\n-\t}\r\n-\r\n-\tpublic boolean wasNull() throws SQLException {\r\n-\t\treturn current.wasNull();\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.jdbc;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.net.URL;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.Ref;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.sql.SQLWarning;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.util.Calendar;\n+import java.util.LinkedList;\n+import java.util.Map;\n+\n+/**\n+ * A chain of ResultSet.\n+ * Assumes added ResultSet are identical in structure and fetches forward.\n+ * Can not move absolutely or change fetch direction. \n+ * \n+ * @author Pinaki Poddar \n+ *\n+ */\n+class DistributedResultSet implements ResultSet {\n+\tprivate LinkedList<ResultSet> comps = new LinkedList<ResultSet>();\n+\tprivate ResultSet current;\n+\tprivate int cursor = -1;\n+\t\n+\t/**\n+\t * Adds the ResultSet only if it has rows.\n+\t */\n+\tpublic void add(ResultSet rs) {\n+\t\ttry {\n+\t\t\tif (rs.first()) {\n+\t\t\t\tcomps.add(rs);\n+\t\t\t\trs.beforeFirst();\n+\t\t\t}\n+\t\t} catch (SQLException e) {\n+\t\t\t// ignore\n+\t\t}\n+\t}\n+\t\n+\tpublic boolean absolute(int arg0) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void afterLast() throws SQLException {\n+\t\tcurrent = null;\n+\t\tcursor  = comps.size();\n+\t}\n+\n+\tpublic void beforeFirst() throws SQLException {\n+\t\tcurrent = null;\n+\t\tcursor  = -1;\n+\t}\n+\n+\tpublic void cancelRowUpdates() throws SQLException {\n+\t\tcurrent.cancelRowUpdates();\n+\t}\n+\n+\tpublic void clearWarnings() throws SQLException {\n+\t\tfor (ResultSet rs : comps)\n+\t\t\trs.clearWarnings();\n+\t}\n+\n+\tpublic void close() throws SQLException {\n+\t\tfor (ResultSet rs : comps)\n+\t\t\trs.close();\n+\t}\n+ \n+\tpublic void deleteRow() throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic int findColumn(String arg0) throws SQLException {\n+\t\treturn current.findColumn(arg0);\n+\t}\n+\n+\tpublic boolean first() throws SQLException {\n+\t\tif (comps.isEmpty()) \n+\t\t\treturn false;\n+\t\tcursor = 0;\n+\t\tcurrent = comps.getFirst();\n+\t\treturn true;\n+\t}\n+\n+\tpublic Array getArray(int arg0) throws SQLException {\n+\t\treturn current.getArray(arg0);\n+\t}\n+\n+\tpublic Array getArray(String arg0) throws SQLException {\n+\t\treturn current.getArray(arg0);\n+\t}\n+\n+\tpublic InputStream getAsciiStream(int arg0) throws SQLException {\n+\t\treturn current.getAsciiStream(arg0);\n+\t}\n+\n+\tpublic InputStream getAsciiStream(String arg0) throws SQLException {\n+\t\treturn current.getAsciiStream(arg0);\n+\t}\n+\n+\tpublic BigDecimal getBigDecimal(int arg0) throws SQLException {\n+\t\treturn current.getBigDecimal(arg0);\n+\t}\n+\n+\tpublic BigDecimal getBigDecimal(String arg0) throws SQLException {\n+\t\treturn current.getBigDecimal(arg0);\n+\t}\n+\n+\tpublic BigDecimal getBigDecimal(int arg0, int arg1) throws SQLException {\n+\t\treturn current.getBigDecimal(arg0, arg1);\n+\t}\n+\n+\tpublic BigDecimal getBigDecimal(String arg0, int arg1) throws SQLException {\n+\t\treturn current.getBigDecimal(arg0, arg1);\n+\t}\n+\n+\tpublic InputStream getBinaryStream(int arg0) throws SQLException {\n+\t\treturn current.getBinaryStream(arg0);\n+\t}\n+\n+\tpublic InputStream getBinaryStream(String arg0) throws SQLException {\n+\t\treturn current.getBinaryStream(arg0);\n+\t}\n+\n+\tpublic Blob getBlob(int arg0) throws SQLException {\n+\t\treturn current.getBlob(arg0);\n+\t}\n+\n+\tpublic Blob getBlob(String arg0) throws SQLException {\n+\t\treturn current.getBlob(arg0);\n+\t}\n+\n+\tpublic boolean getBoolean(int arg0) throws SQLException {\n+\t\treturn current.getBoolean(arg0);\n+\t}\n+\n+\tpublic boolean getBoolean(String arg0) throws SQLException {\n+\t\treturn current.getBoolean(arg0);\n+\t}\n+\n+\tpublic byte getByte(int arg0) throws SQLException {\n+\t\treturn current.getByte(arg0);\n+\t}\n+\n+\tpublic byte getByte(String arg0) throws SQLException {\n+\t\treturn current.getByte(arg0);\n+\t}\n+\n+\tpublic byte[] getBytes(int arg0) throws SQLException {\n+\t\treturn current.getBytes(arg0);\n+\t}\n+\n+\tpublic byte[] getBytes(String arg0) throws SQLException {\n+\t\treturn current.getBytes(arg0);\n+\t}\n+\n+\tpublic Reader getCharacterStream(int arg0) throws SQLException {\n+\t\treturn current.getCharacterStream(arg0);\n+\t}\n+\n+\tpublic Reader getCharacterStream(String arg0) throws SQLException {\n+\t\treturn current.getCharacterStream(arg0);\n+\t}\n+\n+\tpublic Clob getClob(int arg0) throws SQLException {\n+\t\treturn current.getClob(arg0);\n+\t}\n+\n+\tpublic Clob getClob(String arg0) throws SQLException {\n+\t\treturn current.getClob(arg0);\n+\t}\n+\n+\tpublic int getConcurrency() throws SQLException {\n+\t\treturn current.getConcurrency();\n+\t}\n+\n+\tpublic String getCursorName() throws SQLException {\n+\t\treturn current.getCursorName();\n+\t}\n+\n+\tpublic Date getDate(int arg0) throws SQLException {\n+\t\treturn current.getDate(arg0);\n+\t}\n+\n+\tpublic Date getDate(String arg0) throws SQLException {\n+\t\treturn current.getDate(arg0);\n+\t}\n+\n+\tpublic Date getDate(int arg0, Calendar arg1) throws SQLException {\n+\t\treturn current.getDate(arg0, arg1);\n+\t}\n+\n+\tpublic Date getDate(String arg0, Calendar arg1) throws SQLException {\n+\t\treturn current.getDate(arg0, arg1);\n+\t}\n+\n+\tpublic double getDouble(int arg0) throws SQLException {\n+\t\treturn current.getDouble(arg0);\n+\t}\n+\n+\tpublic double getDouble(String arg0) throws SQLException {\n+\t\treturn current.getDouble(arg0);\n+\t}\n+\n+\tpublic int getFetchDirection() throws SQLException {\n+\t\treturn current.getFetchDirection();\n+\t}\n+\n+\tpublic int getFetchSize() throws SQLException {\n+\t\treturn current.getFetchSize();\n+\t}\n+\n+\tpublic float getFloat(int arg0) throws SQLException {\n+\t\treturn current.getFloat(arg0);\n+\t}\n+\n+\tpublic float getFloat(String arg0) throws SQLException {\n+\t\treturn current.getFloat(arg0);\n+\t}\n+\n+\tpublic int getInt(int arg0) throws SQLException {\n+\t\treturn current.getInt(arg0);\n+\t}\n+\n+\tpublic int getInt(String arg0) throws SQLException {\n+\t\treturn current.getInt(arg0);\n+\t}\n+\n+\tpublic long getLong(int arg0) throws SQLException {\n+\t\treturn current.getLong(arg0);\n+\t}\n+\n+\tpublic long getLong(String arg0) throws SQLException {\n+\t\treturn current.getLong(arg0);\n+\t}\n+\n+\tpublic ResultSetMetaData getMetaData() throws SQLException {\n+\t\treturn current.getMetaData();\n+\t}\n+\n+\tpublic Object getObject(int arg0) throws SQLException {\n+\t\treturn current.getObject(arg0);\n+\t}\n+\n+\tpublic Object getObject(String arg0) throws SQLException {\n+\t\treturn current.getObject(arg0);\n+\t}\n+\n+\tpublic Object getObject(int arg0, Map<String, Class<?>> arg1)\n+\t\t\tthrows SQLException {\n+\t\treturn current.getObject(arg0, arg1);\n+\t}\n+\n+\tpublic Object getObject(String arg0, Map<String, Class<?>> arg1)\n+\t\t\tthrows SQLException {\n+\t\treturn current.getObject(arg0, arg1);\n+\t}\n+\n+\tpublic Ref getRef(int arg0) throws SQLException {\n+\t\treturn current.getRef(arg0);\n+\t}\n+\n+\tpublic Ref getRef(String arg0) throws SQLException {\n+\t\treturn current.getRef(arg0);\n+\t}\n+\n+\tpublic int getRow() throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic short getShort(int arg0) throws SQLException {\n+\t\treturn current.getShort(arg0);\n+\t}\n+\n+\tpublic short getShort(String arg0) throws SQLException {\n+\t\treturn current.getShort(arg0);\n+\t}\n+\n+\tpublic Statement getStatement() throws SQLException {\n+\t\treturn current.getStatement();\n+\t}\n+\n+\tpublic String getString(int arg0) throws SQLException {\n+\t\treturn current.getString(arg0);\n+\t}\n+\n+\tpublic String getString(String arg0) throws SQLException {\n+\t\treturn current.getString(arg0);\n+\t}\n+\n+\tpublic Time getTime(int arg0) throws SQLException {\n+\t\treturn current.getTime(arg0);\n+\t}\n+\n+\tpublic Time getTime(String arg0) throws SQLException {\n+\t\treturn current.getTime(arg0);\n+\t}\n+\n+\tpublic Time getTime(int arg0, Calendar arg1) throws SQLException {\n+\t\treturn current.getTime(arg0, arg1);\n+\t}\n+\n+\tpublic Time getTime(String arg0, Calendar arg1) throws SQLException {\n+\t\treturn current.getTime(arg0, arg1);\n+\t}\n+\n+\tpublic Timestamp getTimestamp(int arg0) throws SQLException {\n+\t\treturn current.getTimestamp(arg0);\n+\t}\n+\n+\tpublic Timestamp getTimestamp(String arg0) throws SQLException {\n+\t\treturn current.getTimestamp(arg0);\n+\t}\n+\n+\tpublic Timestamp getTimestamp(int arg0, Calendar arg1) throws SQLException {\n+\t\treturn current.getTimestamp(arg0, arg1);\n+\t}\n+\n+\tpublic Timestamp getTimestamp(String arg0, Calendar arg1)\n+\t\t\tthrows SQLException {\n+\t\treturn current.getTimestamp(arg0, arg1);\n+\t}\n+\n+\tpublic int getType() throws SQLException {\n+\t\treturn current.getType();\n+\t}\n+\n+\tpublic URL getURL(int arg0) throws SQLException {\n+\t\treturn current.getURL(arg0);\n+\t}\n+\n+\tpublic URL getURL(String arg0) throws SQLException {\n+\t\treturn current.getURL(arg0);\n+\t}\n+\n+\tpublic InputStream getUnicodeStream(int arg0) throws SQLException {\n+\t\treturn current.getUnicodeStream(arg0);\n+\t}\n+\n+\tpublic InputStream getUnicodeStream(String arg0) throws SQLException {\n+\t\treturn current.getUnicodeStream(arg0);\n+\t}\n+\n+\tpublic SQLWarning getWarnings() throws SQLException {\n+\t\treturn current.getWarnings();\n+\t}\n+\n+\tpublic void insertRow() throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic boolean isAfterLast() throws SQLException {\n+\t\treturn current == null && cursor >= comps.size();\n+\t}\n+\n+\tpublic boolean isBeforeFirst() throws SQLException {\n+\t\treturn current == null && cursor < 0;\n+\t}\n+\n+\tpublic boolean isFirst() throws SQLException {\n+\t\treturn current != null && current.isFirst() && cursor == 0;\n+\t}\n+\n+\tpublic boolean isLast() throws SQLException {\n+\t\treturn current != null && current.isLast() && cursor == comps.size()-1;\n+\t}\n+\n+\tpublic boolean last() throws SQLException {\n+\t\tif (comps.isEmpty()) \n+\t\t\treturn false;\n+\t\tcursor = comps.size()-1;\n+\t\tcurrent = comps.getLast();\n+\t\treturn current.last();\n+\t}\n+\n+\tpublic void moveToCurrentRow() throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void moveToInsertRow() throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic boolean next() throws SQLException {\n+\t\tif (comps.isEmpty())\n+\t\t\treturn false;\n+\t\tif (current == null) {\n+\t\t\tcurrent = comps.getFirst();\n+\t\t\tcursor = 0;\n+\t\t}\n+\t\tif (current.next())\n+\t\t\treturn true;\n+\t\tcursor++;\n+\t\tif (cursor < comps.size()) {\n+\t\t\tcurrent = comps.get(cursor);\n+\t\t\treturn current.first();\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tpublic boolean previous() throws SQLException {\n+\t\tif (comps.isEmpty())\n+\t\t\treturn false;\n+\t\tif (current.previous())\n+\t\t\treturn true;\n+\t\tcursor--;\n+\t\tif (cursor >= 0) {\n+\t\t\tcurrent = comps.get(cursor);\n+\t\t\treturn current.last();\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tpublic void refreshRow() throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic boolean relative(int arg0) throws SQLException {\n+\t\tif (arg0 == 0)\n+\t\t\treturn current != null;\n+\t\tboolean forward = arg0 > 0;\n+\t\tfor (int i = 0; i < arg0; i++) {\n+\t\t\tif (forward) {\n+\t\t\t\tif (!next()) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (!previous()) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tpublic boolean rowDeleted() throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic boolean rowInserted() throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic boolean rowUpdated() throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void setFetchDirection(int arg0) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void setFetchSize(int arg0) throws SQLException {\n+\t\tfor (ResultSet rs : comps)\n+\t\t\trs.setFetchSize(arg0);\n+\t}\n+\n+\tpublic void updateArray(int arg0, Array arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateArray(String arg0, Array arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateAsciiStream(int arg0, InputStream arg1, int arg2)\n+\t\t\tthrows SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateAsciiStream(String arg0, InputStream arg1, int arg2)\n+\t\t\tthrows SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateBigDecimal(int arg0, BigDecimal arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateBigDecimal(String arg0, BigDecimal arg1)\n+\t\t\tthrows SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateBinaryStream(int arg0, InputStream arg1, int arg2)\n+\t\t\tthrows SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateBinaryStream(String arg0, InputStream arg1, int arg2)\n+\t\t\tthrows SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateBlob(int arg0, Blob arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateBlob(String arg0, Blob arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateBoolean(int arg0, boolean arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateBoolean(String arg0, boolean arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateByte(int arg0, byte arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateByte(String arg0, byte arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateBytes(int arg0, byte[] arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateBytes(String arg0, byte[] arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateCharacterStream(int arg0, Reader arg1, int arg2)\n+\t\t\tthrows SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateCharacterStream(String arg0, Reader arg1, int arg2)\n+\t\t\tthrows SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateClob(int arg0, Clob arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateClob(String arg0, Clob arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateDate(int arg0, Date arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateDate(String arg0, Date arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateDouble(int arg0, double arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateDouble(String arg0, double arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateFloat(int arg0, float arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateFloat(String arg0, float arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateInt(int arg0, int arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateInt(String arg0, int arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateLong(int arg0, long arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateLong(String arg0, long arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateNull(int arg0) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateNull(String arg0) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateObject(int arg0, Object arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateObject(String arg0, Object arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateObject(int arg0, Object arg1, int arg2)\n+\t\t\tthrows SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateObject(String arg0, Object arg1, int arg2)\n+\t\t\tthrows SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateRef(int arg0, Ref arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateRef(String arg0, Ref arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateRow() throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateShort(int arg0, short arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateShort(String arg0, short arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateString(int arg0, String arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateString(String arg0, String arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateTime(int arg0, Time arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateTime(String arg0, Time arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateTimestamp(int arg0, Timestamp arg1) throws SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic void updateTimestamp(String arg0, Timestamp arg1)\n+\t\t\tthrows SQLException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic boolean wasNull() throws SQLException {\n+\t\treturn current.wasNull();\n+\t}\n+}"},{"sha":"6b680a88db5e2063de12cede452b0bf25a709a76","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStatement.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStatement.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStatement.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,33 +1,33 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.jdbc;\r\n-\r\n-import java.sql.Statement;\r\n-\r\n-/**\r\n- * A virtual Statement that delegates to many actual Statements.\r\n- * \r\n- * @author Pinaki Poddar \r\n- *\r\n- */\r\n-class DistributedStatement extends DistributedTemplate<Statement>  {\r\n-\tpublic DistributedStatement(DistributedConnection c) {\r\n-\t\tsuper(c);\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.jdbc;\n+\n+import java.sql.Statement;\n+\n+/**\n+ * A virtual Statement that delegates to many actual Statements.\n+ * \n+ * @author Pinaki Poddar \n+ *\n+ */\n+class DistributedStatement extends DistributedTemplate<Statement>  {\n+\tpublic DistributedStatement(DistributedConnection c) {\n+\t\tsuper(c);\n+\t}\n+}"},{"sha":"02392028f5eb2de643b02c8cd11345ad91b7d34e","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java","status":"modified","additions":297,"deletions":297,"changes":594,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,297 +1,297 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.jdbc;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.concurrent.Callable;\r\n-import java.util.concurrent.ExecutionException;\r\n-import java.util.concurrent.ExecutorService;\r\n-import java.util.concurrent.Future;\r\n-import java.util.concurrent.SynchronousQueue;\r\n-import java.util.concurrent.ThreadFactory;\r\n-import java.util.concurrent.ThreadPoolExecutor;\r\n-import java.util.concurrent.TimeUnit;\r\n-\r\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\r\n-import org.apache.openjpa.jdbc.kernel.JDBCStoreQuery;\r\n-import org.apache.openjpa.kernel.BrokerImpl;\r\n-import org.apache.openjpa.kernel.ExpressionStoreQuery;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.OrderingMergedResultObjectProvider;\r\n-import org.apache.openjpa.kernel.QueryContext;\r\n-import org.apache.openjpa.kernel.QueryImpl;\r\n-import org.apache.openjpa.kernel.StoreManager;\r\n-import org.apache.openjpa.kernel.StoreQuery;\r\n-import org.apache.openjpa.kernel.exps.ExpressionParser;\r\n-import org.apache.openjpa.lib.rop.MergedResultObjectProvider;\r\n-import org.apache.openjpa.lib.rop.RangeResultObjectProvider;\r\n-import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.slice.SliceThread;\r\n-import org.apache.openjpa.util.StoreException;\r\n-\r\n-/**\r\n- * A query for distributed databases.\r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- */\r\n-@SuppressWarnings(\"serial\")\r\n-class DistributedStoreQuery extends JDBCStoreQuery {\r\n-\tprivate List<StoreQuery> _queries = new ArrayList<StoreQuery>();\r\n-\tprivate ExpressionParser _parser;\r\n-\r\n-\tpublic DistributedStoreQuery(JDBCStore store, ExpressionParser parser) {\r\n-\t\tsuper(store, parser);\r\n-\t\t_parser = parser;\r\n-\t}\r\n-\r\n-\tvoid add(StoreQuery q) {\r\n-\t\t_queries.add(q);\r\n-\t}\r\n-\r\n-\tpublic DistributedJDBCStoreManager getDistributedStore() {\r\n-\t\treturn (DistributedJDBCStoreManager) getStore();\r\n-\t}\r\n-\r\n-\tpublic Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\r\n-\t\tboolean parallel = !getContext().getStoreContext().getBroker()\r\n-\t\t\t.getMultithreaded();\r\n-\t\tParallelExecutor ex = new ParallelExecutor(this, meta, subs, _parser, \r\n-\t\t\tctx.getCompilation(), parallel);\r\n-\t\tfor (StoreQuery q : _queries) {\r\n-\t\t\tex.addExecutor(q.newDataStoreExecutor(meta, subs));\r\n-\t\t}\r\n-\t\treturn ex;\r\n-\t}\r\n-\r\n-\tpublic void setContext(QueryContext ctx) {\r\n-\t\tsuper.setContext(ctx);\r\n-\t\tfor (StoreQuery q : _queries)\r\n-\t\t\tq.setContext(ctx);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Executes queries on multiple databases.\r\n-\t * \r\n-\t * @author Pinaki Poddar\r\n-\t * \r\n-\t */\r\n-\tpublic static class ParallelExecutor extends\r\n-\t\t\tExpressionStoreQuery.DataStoreExecutor {\r\n-\t\tprivate List<Executor> executors = new ArrayList<Executor>();\r\n-\t\tprivate DistributedStoreQuery owner = null;\r\n-\r\n-\t\tpublic ParallelExecutor(DistributedStoreQuery dsq, ClassMetaData meta,\r\n-\t\t\t\tboolean subclasses, ExpressionParser parser, Object parsed, \r\n-\t\t\t\tboolean parallel) {\r\n-\t\t\tsuper(dsq, meta, subclasses, parser, parsed);\r\n-\t\t\towner = dsq;\r\n-\t\t}\r\n-\r\n-\t\tpublic void addExecutor(Executor ex) {\r\n-\t\t\texecutors.add(ex);\r\n-\t\t}\r\n-\r\n-\t\t/**\r\n-\t\t * Each child query must be executed with slice context and not the\r\n-\t\t * given query context.\r\n-\t\t */\r\n-\t\tpublic ResultObjectProvider executeQuery(StoreQuery q,\r\n-\t\t\t\tfinal Object[] params, final Range range) {\r\n-\t\t\tList<Future<ResultObjectProvider>> futures = \r\n-\t\t\t\tnew ArrayList<Future<ResultObjectProvider>>();\r\n-\t\t\tfinal List<Executor> usedExecutors = new ArrayList<Executor>();\r\n-\t\t\tfinal List<ResultObjectProvider> rops = \r\n-\t\t\t\tnew ArrayList<ResultObjectProvider>();\r\n-\t\t\tList<SliceStoreManager> targets = findTargets();\r\n-\t\t\tQueryContext ctx = q.getContext();\r\n-\t\t\tboolean isReplicated = containsReplicated(ctx);\r\n-\t\t\tExecutorService threadPool = SliceThread.newPool(owner._queries.size());\r\n-\t\t\tfor (int i = 0; i < owner._queries.size(); i++) {\r\n-\t\t\t\t// if replicated, then execute only on single slice\r\n-\t\t\t\tif (isReplicated && !usedExecutors.isEmpty()) {\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t}\r\n-\t\t\t\tStoreManager sm = owner.getDistributedStore().getSlice(i);\r\n-\t\t\t\tif (!targets.contains(sm))\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\tStoreQuery query = owner._queries.get(i);\r\n-\t\t\t\tExecutor executor = executors.get(i);\r\n-\t\t\t\tif (!targets.contains(sm))\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\tusedExecutors.add(executor);\r\n-\t\t\t\t\tQueryExecutor call = new QueryExecutor();\r\n-\t\t\t\t\tcall.executor = executor;\r\n-\t\t\t\t\tcall.query = query;\r\n-\t\t\t\t\tcall.params = params;\r\n-\t\t\t\t\tcall.range = range;\r\n-\t\t\t\t\tfutures.add(threadPool.submit(call));\r\n-\t\t\t}\r\n-\t\t\tfor (Future<ResultObjectProvider> future : futures) {\r\n-\t\t\t\ttry {\r\n-\t\t\t\t\trops.add(future.get());\r\n-\t\t\t\t} catch (InterruptedException e) {\r\n-\t\t\t\t\tthrow new RuntimeException(e);\r\n-\t\t\t\t} catch (ExecutionException e) {\r\n-\t\t\t\t\tthrow new StoreException(e.getCause());\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tResultObjectProvider[] tmp = rops\r\n-\t\t\t\t\t.toArray(new ResultObjectProvider[rops.size()]);\r\n-\t\t\tResultObjectProvider result = null;\r\n-\t\t\tboolean[] ascending = getAscending(q);\r\n-\t\t\tboolean isAscending = ascending.length > 0;\r\n-\t\t\tboolean isAggregate = ctx.isAggregate();\r\n-\t\t\tboolean hasRange = ctx.getEndRange() != Long.MAX_VALUE;\r\n-\t\t\tif (isAggregate) {\r\n-\t\t\t\tresult = new UniqueResultObjectProvider(tmp, q,\r\n-\t\t\t\t\t\tgetQueryExpressions());\r\n-\t\t\t} else if (isAscending) {\r\n-\t\t\t\tresult = new OrderingMergedResultObjectProvider(tmp, ascending,\r\n-\t\t\t\t\tusedExecutors.toArray(new Executor[usedExecutors.size()]),\r\n-\t\t\t\t\tq, params);\r\n-\t\t\t} else {\r\n-\t\t\t\tresult = new MergedResultObjectProvider(tmp);\r\n-\t\t\t}\r\n-\t\t\tif (hasRange) {\r\n-\t\t\t\tresult = new RangeResultObjectProvider(result, ctx\r\n-\t\t\t\t\t\t.getStartRange(), ctx.getEndRange());\r\n-\t\t\t}\r\n-\t\t\treturn result;\r\n-\t\t}\r\n-\r\n-\t\t/**\r\n-\t\t * Scans metadata to find out if a replicated class is the candidate.\r\n-\t\t */\r\n-\t\tboolean containsReplicated(QueryContext query) {\r\n-\t\t\tClass candidate = query.getCandidateType();\r\n-\t\t\tif (candidate != null) {\r\n-\t\t\t\tClassMetaData meta = query.getStoreContext().getConfiguration()\r\n-\t\t\t\t\t\t.getMetaDataRepositoryInstance().getMetaData(candidate,\r\n-\t\t\t\t\t\t\t\tnull, true);\r\n-\t\t\t\tif (meta != null && meta.isReplicated())\r\n-\t\t\t\t\treturn true;\r\n-\t\t\t}\r\n-\t\t\tClassMetaData[] metas = query.getAccessPathMetaDatas();\r\n-\t\t\tif (metas == null || metas.length < 1)\r\n-\t\t\t\treturn false;\r\n-\t\t\tfor (ClassMetaData type : metas)\r\n-\t\t\t\tif (type.isReplicated())\r\n-\t\t\t\t\treturn true;\r\n-\t\t\treturn false;\r\n-\t\t}\r\n-\r\n-\t\tpublic Number executeDelete(StoreQuery q, Object[] params) {\r\n-\t\t\tIterator<StoreQuery> qs = owner._queries.iterator();\r\n-\t\t\tList<Future<Number>> futures = null;\r\n-\t\t\tint result = 0;\r\n-\t\t\tExecutorService threadPool = SliceThread.newPool(executors.size());\r\n-\t\t\tfor (Executor ex : executors) {\r\n-\t\t\t\tif (futures == null)\r\n-\t\t\t\t\tfutures = new ArrayList<Future<Number>>();\r\n-\t\t\t\tDeleteExecutor call = new DeleteExecutor();\r\n-\t\t\t\tcall.executor = ex;\r\n-\t\t\t\tcall.query = qs.next();\r\n-\t\t\t\tcall.params = params;\r\n-\t\t\t\tfutures.add(threadPool.submit(call));\r\n-\t\t\t}\r\n-\t\t\tfor (Future<Number> future : futures) {\r\n-\t\t\t\ttry {\r\n-\t\t\t\t\tNumber n = future.get();\r\n-\t\t\t\t\tif (n != null)\r\n-\t\t\t\t\t\tresult += n.intValue();\r\n-\t\t\t\t} catch (InterruptedException e) {\r\n-\t\t\t\t\tthrow new RuntimeException(e);\r\n-\t\t\t\t} catch (ExecutionException e) {\r\n-\t\t\t\t\tthrow new StoreException(e.getCause());\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\treturn result;\r\n-\t\t}\r\n-\r\n-\t\tpublic Number executeUpdate(StoreQuery q, Object[] params) {\r\n-\t\t\tIterator<StoreQuery> qs = owner._queries.iterator();\r\n-\t\t\tList<Future<Number>> futures = null;\r\n-\t\t\tint result = 0;\r\n-            ExecutorService threadPool = SliceThread.newPool(executors.size());\r\n-\t\t\tfor (Executor ex : executors) {\r\n-\t\t\t\tif (futures == null)\r\n-\t\t\t\t\tfutures = new ArrayList<Future<Number>>();\r\n-\t\t\t\tUpdateExecutor call = new UpdateExecutor();\r\n-\t\t\t\tcall.executor = ex;\r\n-\t\t\t\tcall.query = qs.next();\r\n-\t\t\t\tcall.params = params;\r\n-\t\t\t\tfutures.add(threadPool.submit(call));\r\n-\t\t\t}\r\n-\t\t\tfor (Future<Number> future : futures) {\r\n-\t\t\t\ttry {\r\n-\t\t\t\t\tNumber n = future.get();\r\n-\t\t\t\t\tresult += (n == null) ? 0 : n.intValue();\r\n-\t\t\t\t} catch (InterruptedException e) {\r\n-\t\t\t\t\tthrow new RuntimeException(e);\r\n-\t\t\t\t} catch (ExecutionException e) {\r\n-\t\t\t\t\tthrow new StoreException(e.getCause());\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\treturn result;\r\n-\t\t}\r\n-\r\n-\t\tList<SliceStoreManager> findTargets() {\r\n-\t\t\tFetchConfiguration fetch = owner.getContext()\r\n-\t\t\t\t\t.getFetchConfiguration();\r\n-\t\t\treturn owner.getDistributedStore().getTargets(fetch);\r\n-\t\t}\r\n-\t\t\r\n-\t}\r\n-\r\n-\tstatic class QueryExecutor implements Callable<ResultObjectProvider> {\r\n-\t\tStoreQuery query;\r\n-\t\tExecutor executor;\r\n-\t\tObject[] params;\r\n-\t\tRange range;\r\n-\r\n-\t\tpublic ResultObjectProvider call() throws Exception {\r\n-\t\t\treturn executor.executeQuery(query, params, range);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic class DeleteExecutor implements Callable<Number> {\r\n-\t\tStoreQuery query;\r\n-\t\tExecutor executor;\r\n-\t\tObject[] params;\r\n-\r\n-\t\tpublic Number call() throws Exception {\r\n-\t\t\treturn executor.executeDelete(query, params);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic class UpdateExecutor implements Callable<Number> {\r\n-\t\tStoreQuery query;\r\n-\t\tExecutor executor;\r\n-\t\tObject[] params;\r\n-\r\n-\t\tpublic Number call() throws Exception {\r\n-\t\t    return executor.executeUpdate(query, params);\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.jdbc;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.kernel.JDBCStoreQuery;\n+import org.apache.openjpa.kernel.BrokerImpl;\n+import org.apache.openjpa.kernel.ExpressionStoreQuery;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.OrderingMergedResultObjectProvider;\n+import org.apache.openjpa.kernel.QueryContext;\n+import org.apache.openjpa.kernel.QueryImpl;\n+import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.kernel.exps.ExpressionParser;\n+import org.apache.openjpa.lib.rop.MergedResultObjectProvider;\n+import org.apache.openjpa.lib.rop.RangeResultObjectProvider;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.slice.SliceThread;\n+import org.apache.openjpa.util.StoreException;\n+\n+/**\n+ * A query for distributed databases.\n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+@SuppressWarnings(\"serial\")\n+class DistributedStoreQuery extends JDBCStoreQuery {\n+\tprivate List<StoreQuery> _queries = new ArrayList<StoreQuery>();\n+\tprivate ExpressionParser _parser;\n+\n+\tpublic DistributedStoreQuery(JDBCStore store, ExpressionParser parser) {\n+\t\tsuper(store, parser);\n+\t\t_parser = parser;\n+\t}\n+\n+\tvoid add(StoreQuery q) {\n+\t\t_queries.add(q);\n+\t}\n+\n+\tpublic DistributedJDBCStoreManager getDistributedStore() {\n+\t\treturn (DistributedJDBCStoreManager) getStore();\n+\t}\n+\n+\tpublic Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\n+\t\tboolean parallel = !getContext().getStoreContext().getBroker()\n+\t\t\t.getMultithreaded();\n+\t\tParallelExecutor ex = new ParallelExecutor(this, meta, subs, _parser, \n+\t\t\tctx.getCompilation(), parallel);\n+\t\tfor (StoreQuery q : _queries) {\n+\t\t\tex.addExecutor(q.newDataStoreExecutor(meta, subs));\n+\t\t}\n+\t\treturn ex;\n+\t}\n+\n+\tpublic void setContext(QueryContext ctx) {\n+\t\tsuper.setContext(ctx);\n+\t\tfor (StoreQuery q : _queries)\n+\t\t\tq.setContext(ctx);\n+\t}\n+\n+\t/**\n+\t * Executes queries on multiple databases.\n+\t * \n+\t * @author Pinaki Poddar\n+\t * \n+\t */\n+\tpublic static class ParallelExecutor extends\n+\t\t\tExpressionStoreQuery.DataStoreExecutor {\n+\t\tprivate List<Executor> executors = new ArrayList<Executor>();\n+\t\tprivate DistributedStoreQuery owner = null;\n+\n+\t\tpublic ParallelExecutor(DistributedStoreQuery dsq, ClassMetaData meta,\n+\t\t\t\tboolean subclasses, ExpressionParser parser, Object parsed, \n+\t\t\t\tboolean parallel) {\n+\t\t\tsuper(dsq, meta, subclasses, parser, parsed);\n+\t\t\towner = dsq;\n+\t\t}\n+\n+\t\tpublic void addExecutor(Executor ex) {\n+\t\t\texecutors.add(ex);\n+\t\t}\n+\n+\t\t/**\n+\t\t * Each child query must be executed with slice context and not the\n+\t\t * given query context.\n+\t\t */\n+\t\tpublic ResultObjectProvider executeQuery(StoreQuery q,\n+\t\t\t\tfinal Object[] params, final Range range) {\n+\t\t\tList<Future<ResultObjectProvider>> futures = \n+\t\t\t\tnew ArrayList<Future<ResultObjectProvider>>();\n+\t\t\tfinal List<Executor> usedExecutors = new ArrayList<Executor>();\n+\t\t\tfinal List<ResultObjectProvider> rops = \n+\t\t\t\tnew ArrayList<ResultObjectProvider>();\n+\t\t\tList<SliceStoreManager> targets = findTargets();\n+\t\t\tQueryContext ctx = q.getContext();\n+\t\t\tboolean isReplicated = containsReplicated(ctx);\n+\t\t\tExecutorService threadPool = SliceThread.newPool(owner._queries.size());\n+\t\t\tfor (int i = 0; i < owner._queries.size(); i++) {\n+\t\t\t\t// if replicated, then execute only on single slice\n+\t\t\t\tif (isReplicated && !usedExecutors.isEmpty()) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tStoreManager sm = owner.getDistributedStore().getSlice(i);\n+\t\t\t\tif (!targets.contains(sm))\n+\t\t\t\t\tcontinue;\n+\t\t\t\tStoreQuery query = owner._queries.get(i);\n+\t\t\t\tExecutor executor = executors.get(i);\n+\t\t\t\tif (!targets.contains(sm))\n+\t\t\t\t\tcontinue;\n+\t\t\t\tusedExecutors.add(executor);\n+\t\t\t\t\tQueryExecutor call = new QueryExecutor();\n+\t\t\t\t\tcall.executor = executor;\n+\t\t\t\t\tcall.query = query;\n+\t\t\t\t\tcall.params = params;\n+\t\t\t\t\tcall.range = range;\n+\t\t\t\t\tfutures.add(threadPool.submit(call));\n+\t\t\t}\n+\t\t\tfor (Future<ResultObjectProvider> future : futures) {\n+\t\t\t\ttry {\n+\t\t\t\t\trops.add(future.get());\n+\t\t\t\t} catch (InterruptedException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t} catch (ExecutionException e) {\n+\t\t\t\t\tthrow new StoreException(e.getCause());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\tResultObjectProvider[] tmp = rops\n+\t\t\t\t\t.toArray(new ResultObjectProvider[rops.size()]);\n+\t\t\tResultObjectProvider result = null;\n+\t\t\tboolean[] ascending = getAscending(q);\n+\t\t\tboolean isAscending = ascending.length > 0;\n+\t\t\tboolean isAggregate = ctx.isAggregate();\n+\t\t\tboolean hasRange = ctx.getEndRange() != Long.MAX_VALUE;\n+\t\t\tif (isAggregate) {\n+\t\t\t\tresult = new UniqueResultObjectProvider(tmp, q,\n+\t\t\t\t\t\tgetQueryExpressions());\n+\t\t\t} else if (isAscending) {\n+\t\t\t\tresult = new OrderingMergedResultObjectProvider(tmp, ascending,\n+\t\t\t\t\tusedExecutors.toArray(new Executor[usedExecutors.size()]),\n+\t\t\t\t\tq, params);\n+\t\t\t} else {\n+\t\t\t\tresult = new MergedResultObjectProvider(tmp);\n+\t\t\t}\n+\t\t\tif (hasRange) {\n+\t\t\t\tresult = new RangeResultObjectProvider(result, ctx\n+\t\t\t\t\t\t.getStartRange(), ctx.getEndRange());\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Scans metadata to find out if a replicated class is the candidate.\n+\t\t */\n+\t\tboolean containsReplicated(QueryContext query) {\n+\t\t\tClass candidate = query.getCandidateType();\n+\t\t\tif (candidate != null) {\n+\t\t\t\tClassMetaData meta = query.getStoreContext().getConfiguration()\n+\t\t\t\t\t\t.getMetaDataRepositoryInstance().getMetaData(candidate,\n+\t\t\t\t\t\t\t\tnull, true);\n+\t\t\t\tif (meta != null && meta.isReplicated())\n+\t\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tClassMetaData[] metas = query.getAccessPathMetaDatas();\n+\t\t\tif (metas == null || metas.length < 1)\n+\t\t\t\treturn false;\n+\t\t\tfor (ClassMetaData type : metas)\n+\t\t\t\tif (type.isReplicated())\n+\t\t\t\t\treturn true;\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tpublic Number executeDelete(StoreQuery q, Object[] params) {\n+\t\t\tIterator<StoreQuery> qs = owner._queries.iterator();\n+\t\t\tList<Future<Number>> futures = null;\n+\t\t\tint result = 0;\n+\t\t\tExecutorService threadPool = SliceThread.newPool(executors.size());\n+\t\t\tfor (Executor ex : executors) {\n+\t\t\t\tif (futures == null)\n+\t\t\t\t\tfutures = new ArrayList<Future<Number>>();\n+\t\t\t\tDeleteExecutor call = new DeleteExecutor();\n+\t\t\t\tcall.executor = ex;\n+\t\t\t\tcall.query = qs.next();\n+\t\t\t\tcall.params = params;\n+\t\t\t\tfutures.add(threadPool.submit(call));\n+\t\t\t}\n+\t\t\tfor (Future<Number> future : futures) {\n+\t\t\t\ttry {\n+\t\t\t\t\tNumber n = future.get();\n+\t\t\t\t\tif (n != null)\n+\t\t\t\t\t\tresult += n.intValue();\n+\t\t\t\t} catch (InterruptedException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t} catch (ExecutionException e) {\n+\t\t\t\t\tthrow new StoreException(e.getCause());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\tpublic Number executeUpdate(StoreQuery q, Object[] params) {\n+\t\t\tIterator<StoreQuery> qs = owner._queries.iterator();\n+\t\t\tList<Future<Number>> futures = null;\n+\t\t\tint result = 0;\n+            ExecutorService threadPool = SliceThread.newPool(executors.size());\n+\t\t\tfor (Executor ex : executors) {\n+\t\t\t\tif (futures == null)\n+\t\t\t\t\tfutures = new ArrayList<Future<Number>>();\n+\t\t\t\tUpdateExecutor call = new UpdateExecutor();\n+\t\t\t\tcall.executor = ex;\n+\t\t\t\tcall.query = qs.next();\n+\t\t\t\tcall.params = params;\n+\t\t\t\tfutures.add(threadPool.submit(call));\n+\t\t\t}\n+\t\t\tfor (Future<Number> future : futures) {\n+\t\t\t\ttry {\n+\t\t\t\t\tNumber n = future.get();\n+\t\t\t\t\tresult += (n == null) ? 0 : n.intValue();\n+\t\t\t\t} catch (InterruptedException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t} catch (ExecutionException e) {\n+\t\t\t\t\tthrow new StoreException(e.getCause());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\tList<SliceStoreManager> findTargets() {\n+\t\t\tFetchConfiguration fetch = owner.getContext()\n+\t\t\t\t\t.getFetchConfiguration();\n+\t\t\treturn owner.getDistributedStore().getTargets(fetch);\n+\t\t}\n+\t\t\n+\t}\n+\n+\tstatic class QueryExecutor implements Callable<ResultObjectProvider> {\n+\t\tStoreQuery query;\n+\t\tExecutor executor;\n+\t\tObject[] params;\n+\t\tRange range;\n+\n+\t\tpublic ResultObjectProvider call() throws Exception {\n+\t\t\treturn executor.executeQuery(query, params, range);\n+\t\t}\n+\t}\n+\n+\tstatic class DeleteExecutor implements Callable<Number> {\n+\t\tStoreQuery query;\n+\t\tExecutor executor;\n+\t\tObject[] params;\n+\n+\t\tpublic Number call() throws Exception {\n+\t\t\treturn executor.executeDelete(query, params);\n+\t\t}\n+\t}\n+\n+\tstatic class UpdateExecutor implements Callable<Number> {\n+\t\tStoreQuery query;\n+\t\tExecutor executor;\n+\t\tObject[] params;\n+\n+\t\tpublic Number call() throws Exception {\n+\t\t    return executor.executeUpdate(query, params);\n+\t\t}\n+\t}\n+}"},{"sha":"3f1b997909fd9c8575a58b9466b371633e64ca2f","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedTemplate.java","status":"modified","additions":273,"deletions":273,"changes":546,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedTemplate.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedTemplate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedTemplate.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,273 +1,273 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.jdbc;\r\n-\r\n-import java.sql.Connection;\r\n-import java.sql.ResultSet;\r\n-import java.sql.SQLException;\r\n-import java.sql.SQLWarning;\r\n-import java.sql.Statement;\r\n-import java.util.ArrayList;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-\r\n-/**\r\n- * A template for multiple Statements being executed by multiple connections.\r\n- * \r\n- * @author Pinaki Poddar \r\n- *\r\n- */\r\n-class DistributedTemplate<T extends Statement> \r\n-\timplements Statement, Iterable<T> {\r\n-\tprotected List<T> stmts = new ArrayList<T>();\r\n-\tprotected final DistributedConnection con;\r\n-\tprotected T master;\r\n-\t\r\n-\tpublic DistributedTemplate(DistributedConnection c) {\r\n-\t\tcon = c;\r\n-\t}\r\n-\t\r\n-\tpublic Iterator<T> iterator() {\r\n-\t\treturn stmts.iterator();\r\n-\t}\r\n-\t\r\n-\tpublic void add(T s) {\r\n-\t\tif (stmts.isEmpty())\r\n-\t\t\tmaster = s;\r\n-\t\ttry {\r\n-\t\t\tif (!con.contains(s.getConnection()))\r\n-\t\t\t\tthrow new IllegalArgumentException(s + \" has different connection\");\r\n-\t\t\tstmts.add(s);\r\n-\t\t} catch (SQLException e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\tpublic void addBatch(String sql) throws SQLException {\r\n-\t\tfor (T s:this)\r\n-\t\t\ts.addBatch(sql);\r\n-\t}\r\n-\r\n-\tpublic void cancel() throws SQLException {\r\n-\t\tfor (T s:this)\r\n-\t\t\ts.cancel();\r\n-\t}\r\n-\r\n-\tpublic void clearBatch() throws SQLException {\r\n-\t\tfor (T s:this)\r\n-\t\t\ts.clearBatch();\r\n-\t}\r\n-\r\n-\tpublic void clearWarnings() throws SQLException {\r\n-\t\tfor (T s:this)\r\n-\t\t\ts.clearWarnings();\r\n-\t}\r\n-\r\n-\tpublic void close() throws SQLException {\r\n-\t\tfor (T s:this)\r\n-\t\t\ts.close();\r\n-\t}\r\n-\r\n-\tpublic boolean execute(String arg0) throws SQLException {\r\n-\t\tboolean ret = true;\r\n-\t\tfor (T s:this)\r\n-\t\t\tret = s.execute(arg0) & ret;\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic boolean execute(String arg0, int arg1) throws SQLException {\r\n-\t\tboolean ret = true;\r\n-\t\tfor (T s:this)\r\n-\t\t\tret = s.execute(arg0, arg1) & ret;\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic boolean execute(String arg0, int[] arg1) throws SQLException {\r\n-\t\tboolean ret = true;\r\n-\t\tfor (T s:this)\r\n-\t\t\tret = s.execute(arg0, arg1) & ret;\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic boolean execute(String arg0, String[] arg1) throws SQLException {\r\n-\t\tboolean ret = true;\r\n-\t\tfor (T s:this)\r\n-\t\t\tret = s.execute(arg0, arg1) & ret;\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic int[] executeBatch() throws SQLException {\r\n-\t\tint[] ret = new int[0];\r\n-\t\tfor (Statement s:this) {\r\n-\t\t\tint[] tmp = s.executeBatch();\r\n-\t\t\tret = new int[ret.length + tmp.length];\r\n-\t\t\tSystem.arraycopy(tmp, 0, ret, ret.length-tmp.length, tmp.length);\r\n-\t\t}\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic ResultSet executeQuery() throws SQLException {\r\n-\t\tDistributedResultSet rs = new DistributedResultSet();\r\n-\t\tfor (T s:this)\r\n-\t\t\trs.add(s.executeQuery(null));\r\n-\t\treturn rs;\r\n-\t}\r\n-\r\n-\tpublic ResultSet executeQuery(String arg0) throws SQLException {\r\n-\t\tDistributedResultSet rs = new DistributedResultSet();\r\n-\t\tfor (T s:this)\r\n-\t\t\trs.add(s.executeQuery(arg0));\r\n-\t\treturn rs;\r\n-\t}\r\n-\r\n-\tpublic int executeUpdate(String arg0) throws SQLException {\r\n-\t\tint ret = 0;\r\n-\t\tfor (T s:this)\r\n-\t\t\tret += s.executeUpdate(arg0);\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic int executeUpdate(String arg0, int arg1) throws SQLException {\r\n-\t\tint ret = 0;\r\n-\t\tfor (T s:this)\r\n-\t\t\tret += s.executeUpdate(arg0, arg1);\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic int executeUpdate(String arg0, int[] arg1) throws SQLException {\r\n-\t\tint ret = 0;\r\n-\t\tfor (T s:this)\r\n-\t\t\tret += s.executeUpdate(arg0, arg1);\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic int executeUpdate(String arg0, String[] arg1) throws SQLException {\r\n-\t\tint ret = 0;\r\n-\t\tfor (T s:this)\r\n-\t\t\tret += s.executeUpdate(arg0, arg1);\r\n-\t\treturn ret;\r\n-\t}\r\n-\r\n-\tpublic Connection getConnection() throws SQLException {\r\n-\t\treturn con;\r\n-\t}\r\n-\r\n-\tpublic int getFetchDirection() throws SQLException {\r\n-\t\treturn master.getFetchDirection();\r\n-\t}\r\n-\r\n-\tpublic int getFetchSize() throws SQLException {\r\n-\t\treturn master.getFetchSize();\r\n-\t}\r\n-\r\n-\tpublic ResultSet getGeneratedKeys() throws SQLException {\r\n-\t\tDistributedResultSet mrs = new DistributedResultSet();\r\n-\t\tfor (T s:this)\r\n-\t\t\tmrs.add(s.getGeneratedKeys());\r\n-\t\treturn mrs;\r\n-\t}\r\n-\r\n-\tpublic int getMaxFieldSize() throws SQLException {\r\n-\t\treturn master.getMaxFieldSize();\r\n-\t}\r\n-\r\n-\tpublic int getMaxRows() throws SQLException {\r\n-\t\treturn master.getMaxRows();\r\n-\t}\r\n-\r\n-\tpublic boolean getMoreResults() throws SQLException {\r\n-\t\tfor (T s:this)\r\n-\t\t\tif (s.getMoreResults())\r\n-\t\t\t\treturn true;\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\tpublic boolean getMoreResults(int arg0) throws SQLException {\r\n-\t\tfor (T s:this)\r\n-\t\t\tif (s.getMoreResults(arg0))\r\n-\t\t\t\treturn true;\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\tpublic int getQueryTimeout() throws SQLException {\r\n-\t\treturn master.getQueryTimeout();\r\n-\t}\r\n-\r\n-\tpublic ResultSet getResultSet() throws SQLException {\r\n-\t\tDistributedResultSet rs = new DistributedResultSet();\r\n-\t\tfor (T s:this)\r\n-\t\t\trs.add(s.getResultSet());\r\n-\t\treturn rs;\r\n-\t}\r\n-\r\n-\tpublic int getResultSetConcurrency() throws SQLException {\r\n-\t\treturn master.getResultSetConcurrency();\r\n-\t}\r\n-\r\n-\tpublic int getResultSetHoldability() throws SQLException {\r\n-\t\treturn master.getResultSetHoldability();\r\n-\t}\r\n-\r\n-\tpublic int getResultSetType() throws SQLException {\r\n-\t\treturn master.getResultSetType();\r\n-\t}\r\n-\r\n-\tpublic int getUpdateCount() throws SQLException {\r\n-\t\treturn master.getUpdateCount();\r\n-\t}\r\n-\r\n-\tpublic SQLWarning getWarnings() throws SQLException {\r\n-\t\treturn master.getWarnings();\r\n-\t}\r\n-\r\n-\tpublic void setCursorName(String name) throws SQLException {\r\n-\t\tfor (T s:this)\r\n-\t\t\ts.setCursorName(name);\r\n-\t}\r\n-\r\n-\tpublic void setEscapeProcessing(boolean flag) throws SQLException {\r\n-\t\tfor (T s:this)\r\n-\t\t\ts.setEscapeProcessing(flag);\r\n-\t}\r\n-\r\n-\tpublic void setFetchDirection(int dir) throws SQLException {\r\n-\t\tfor (T s:this)\r\n-\t\t\ts.setFetchDirection(dir);\r\n-\t}\r\n-\r\n-\tpublic void setFetchSize(int size) throws SQLException {\r\n-\t\tfor (T s:this)\r\n-\t\t\ts.setFetchSize(size);\r\n-\t}\r\n-\r\n-\tpublic void setMaxFieldSize(int size) throws SQLException {\r\n-\t\tfor (T s:this)\r\n-\t\t\ts.setMaxFieldSize(size);\r\n-\t}\r\n-\r\n-\tpublic void setMaxRows(int n) throws SQLException {\r\n-\t\tfor (T s:this)\r\n-\t\t\ts.setMaxRows(n);\r\n-\t}\r\n-\t\r\n-\tpublic void setQueryTimeout(int n) throws SQLException {\r\n-\t\tfor (T s:this)\r\n-\t\t\ts.setQueryTimeout(n);\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLWarning;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * A template for multiple Statements being executed by multiple connections.\n+ * \n+ * @author Pinaki Poddar \n+ *\n+ */\n+class DistributedTemplate<T extends Statement> \n+\timplements Statement, Iterable<T> {\n+\tprotected List<T> stmts = new ArrayList<T>();\n+\tprotected final DistributedConnection con;\n+\tprotected T master;\n+\t\n+\tpublic DistributedTemplate(DistributedConnection c) {\n+\t\tcon = c;\n+\t}\n+\t\n+\tpublic Iterator<T> iterator() {\n+\t\treturn stmts.iterator();\n+\t}\n+\t\n+\tpublic void add(T s) {\n+\t\tif (stmts.isEmpty())\n+\t\t\tmaster = s;\n+\t\ttry {\n+\t\t\tif (!con.contains(s.getConnection()))\n+\t\t\t\tthrow new IllegalArgumentException(s + \" has different connection\");\n+\t\t\tstmts.add(s);\n+\t\t} catch (SQLException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t}\n+\t\n+\tpublic void addBatch(String sql) throws SQLException {\n+\t\tfor (T s:this)\n+\t\t\ts.addBatch(sql);\n+\t}\n+\n+\tpublic void cancel() throws SQLException {\n+\t\tfor (T s:this)\n+\t\t\ts.cancel();\n+\t}\n+\n+\tpublic void clearBatch() throws SQLException {\n+\t\tfor (T s:this)\n+\t\t\ts.clearBatch();\n+\t}\n+\n+\tpublic void clearWarnings() throws SQLException {\n+\t\tfor (T s:this)\n+\t\t\ts.clearWarnings();\n+\t}\n+\n+\tpublic void close() throws SQLException {\n+\t\tfor (T s:this)\n+\t\t\ts.close();\n+\t}\n+\n+\tpublic boolean execute(String arg0) throws SQLException {\n+\t\tboolean ret = true;\n+\t\tfor (T s:this)\n+\t\t\tret = s.execute(arg0) & ret;\n+\t\treturn ret;\n+\t}\n+\n+\tpublic boolean execute(String arg0, int arg1) throws SQLException {\n+\t\tboolean ret = true;\n+\t\tfor (T s:this)\n+\t\t\tret = s.execute(arg0, arg1) & ret;\n+\t\treturn ret;\n+\t}\n+\n+\tpublic boolean execute(String arg0, int[] arg1) throws SQLException {\n+\t\tboolean ret = true;\n+\t\tfor (T s:this)\n+\t\t\tret = s.execute(arg0, arg1) & ret;\n+\t\treturn ret;\n+\t}\n+\n+\tpublic boolean execute(String arg0, String[] arg1) throws SQLException {\n+\t\tboolean ret = true;\n+\t\tfor (T s:this)\n+\t\t\tret = s.execute(arg0, arg1) & ret;\n+\t\treturn ret;\n+\t}\n+\n+\tpublic int[] executeBatch() throws SQLException {\n+\t\tint[] ret = new int[0];\n+\t\tfor (Statement s:this) {\n+\t\t\tint[] tmp = s.executeBatch();\n+\t\t\tret = new int[ret.length + tmp.length];\n+\t\t\tSystem.arraycopy(tmp, 0, ret, ret.length-tmp.length, tmp.length);\n+\t\t}\n+\t\treturn ret;\n+\t}\n+\n+\tpublic ResultSet executeQuery() throws SQLException {\n+\t\tDistributedResultSet rs = new DistributedResultSet();\n+\t\tfor (T s:this)\n+\t\t\trs.add(s.executeQuery(null));\n+\t\treturn rs;\n+\t}\n+\n+\tpublic ResultSet executeQuery(String arg0) throws SQLException {\n+\t\tDistributedResultSet rs = new DistributedResultSet();\n+\t\tfor (T s:this)\n+\t\t\trs.add(s.executeQuery(arg0));\n+\t\treturn rs;\n+\t}\n+\n+\tpublic int executeUpdate(String arg0) throws SQLException {\n+\t\tint ret = 0;\n+\t\tfor (T s:this)\n+\t\t\tret += s.executeUpdate(arg0);\n+\t\treturn ret;\n+\t}\n+\n+\tpublic int executeUpdate(String arg0, int arg1) throws SQLException {\n+\t\tint ret = 0;\n+\t\tfor (T s:this)\n+\t\t\tret += s.executeUpdate(arg0, arg1);\n+\t\treturn ret;\n+\t}\n+\n+\tpublic int executeUpdate(String arg0, int[] arg1) throws SQLException {\n+\t\tint ret = 0;\n+\t\tfor (T s:this)\n+\t\t\tret += s.executeUpdate(arg0, arg1);\n+\t\treturn ret;\n+\t}\n+\n+\tpublic int executeUpdate(String arg0, String[] arg1) throws SQLException {\n+\t\tint ret = 0;\n+\t\tfor (T s:this)\n+\t\t\tret += s.executeUpdate(arg0, arg1);\n+\t\treturn ret;\n+\t}\n+\n+\tpublic Connection getConnection() throws SQLException {\n+\t\treturn con;\n+\t}\n+\n+\tpublic int getFetchDirection() throws SQLException {\n+\t\treturn master.getFetchDirection();\n+\t}\n+\n+\tpublic int getFetchSize() throws SQLException {\n+\t\treturn master.getFetchSize();\n+\t}\n+\n+\tpublic ResultSet getGeneratedKeys() throws SQLException {\n+\t\tDistributedResultSet mrs = new DistributedResultSet();\n+\t\tfor (T s:this)\n+\t\t\tmrs.add(s.getGeneratedKeys());\n+\t\treturn mrs;\n+\t}\n+\n+\tpublic int getMaxFieldSize() throws SQLException {\n+\t\treturn master.getMaxFieldSize();\n+\t}\n+\n+\tpublic int getMaxRows() throws SQLException {\n+\t\treturn master.getMaxRows();\n+\t}\n+\n+\tpublic boolean getMoreResults() throws SQLException {\n+\t\tfor (T s:this)\n+\t\t\tif (s.getMoreResults())\n+\t\t\t\treturn true;\n+\t\treturn false;\n+\t}\n+\n+\tpublic boolean getMoreResults(int arg0) throws SQLException {\n+\t\tfor (T s:this)\n+\t\t\tif (s.getMoreResults(arg0))\n+\t\t\t\treturn true;\n+\t\treturn false;\n+\t}\n+\n+\tpublic int getQueryTimeout() throws SQLException {\n+\t\treturn master.getQueryTimeout();\n+\t}\n+\n+\tpublic ResultSet getResultSet() throws SQLException {\n+\t\tDistributedResultSet rs = new DistributedResultSet();\n+\t\tfor (T s:this)\n+\t\t\trs.add(s.getResultSet());\n+\t\treturn rs;\n+\t}\n+\n+\tpublic int getResultSetConcurrency() throws SQLException {\n+\t\treturn master.getResultSetConcurrency();\n+\t}\n+\n+\tpublic int getResultSetHoldability() throws SQLException {\n+\t\treturn master.getResultSetHoldability();\n+\t}\n+\n+\tpublic int getResultSetType() throws SQLException {\n+\t\treturn master.getResultSetType();\n+\t}\n+\n+\tpublic int getUpdateCount() throws SQLException {\n+\t\treturn master.getUpdateCount();\n+\t}\n+\n+\tpublic SQLWarning getWarnings() throws SQLException {\n+\t\treturn master.getWarnings();\n+\t}\n+\n+\tpublic void setCursorName(String name) throws SQLException {\n+\t\tfor (T s:this)\n+\t\t\ts.setCursorName(name);\n+\t}\n+\n+\tpublic void setEscapeProcessing(boolean flag) throws SQLException {\n+\t\tfor (T s:this)\n+\t\t\ts.setEscapeProcessing(flag);\n+\t}\n+\n+\tpublic void setFetchDirection(int dir) throws SQLException {\n+\t\tfor (T s:this)\n+\t\t\ts.setFetchDirection(dir);\n+\t}\n+\n+\tpublic void setFetchSize(int size) throws SQLException {\n+\t\tfor (T s:this)\n+\t\t\ts.setFetchSize(size);\n+\t}\n+\n+\tpublic void setMaxFieldSize(int size) throws SQLException {\n+\t\tfor (T s:this)\n+\t\t\ts.setMaxFieldSize(size);\n+\t}\n+\n+\tpublic void setMaxRows(int n) throws SQLException {\n+\t\tfor (T s:this)\n+\t\t\ts.setMaxRows(n);\n+\t}\n+\t\n+\tpublic void setQueryTimeout(int n) throws SQLException {\n+\t\tfor (T s:this)\n+\t\t\ts.setQueryTimeout(n);\n+\t}\n+}"},{"sha":"c62aed5a207371e30d2e963a616d1fdebb04b281","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/SliceStoreManager.java","status":"modified","additions":50,"deletions":50,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/SliceStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/SliceStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/SliceStoreManager.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,50 +1,50 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.jdbc;\r\n-\r\n-import org.apache.openjpa.jdbc.kernel.JDBCStoreManager;\r\n-import org.apache.openjpa.slice.Slice;\r\n-\r\n-/**\r\n- * A specialized JDBCStoreManager for a slice.\r\n- * \r\n- * @author Pinaki Poddar \r\n- *\r\n- */\r\n-public class SliceStoreManager extends JDBCStoreManager {\r\n-\tprivate final Slice _slice;\r\n-\t\r\n-\t/**\r\n-\t * Construct with immutable logical name of the slice. \r\n-\t */\r\n-\tpublic SliceStoreManager(Slice slice) {\r\n-\t\t_slice = slice;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Gets the slice for which this receiver is working.\r\n-\t */\r\n-\tpublic Slice getSlice() {\r\n-\t    return _slice;\r\n-\t}\r\n-\t\r\n-\tpublic String getName() {\r\n-\t    return _slice.getName();\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.jdbc;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStoreManager;\n+import org.apache.openjpa.slice.Slice;\n+\n+/**\n+ * A specialized JDBCStoreManager for a slice.\n+ * \n+ * @author Pinaki Poddar \n+ *\n+ */\n+public class SliceStoreManager extends JDBCStoreManager {\n+\tprivate final Slice _slice;\n+\t\n+\t/**\n+\t * Construct with immutable logical name of the slice. \n+\t */\n+\tpublic SliceStoreManager(Slice slice) {\n+\t\t_slice = slice;\n+\t}\n+\t\n+\t/**\n+\t * Gets the slice for which this receiver is working.\n+\t */\n+\tpublic Slice getSlice() {\n+\t    return _slice;\n+\t}\n+\t\n+\tpublic String getName() {\n+\t    return _slice.getName();\n+\t}\n+}"},{"sha":"4b24642e64525ca25416f567f80e8d49eb6b2470","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/UniqueResultObjectProvider.java","status":"modified","additions":173,"deletions":173,"changes":346,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/UniqueResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/UniqueResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/UniqueResultObjectProvider.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,173 +1,173 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.jdbc;\r\n-\r\n-import org.apache.openjpa.kernel.StoreQuery;\r\n-import org.apache.openjpa.kernel.exps.QueryExpressions;\r\n-import org.apache.openjpa.kernel.exps.Value;\r\n-import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.InternalException;\r\n-\r\n-/**\r\n- * Aggregates individual single query results from different databases.\r\n- * \r\n- * @author Pinaki Poddar \r\n- *\r\n- */\r\n-public class UniqueResultObjectProvider implements ResultObjectProvider {\r\n-    private final ResultObjectProvider[] _rops;\r\n-    private final StoreQuery _query;\r\n-    private final QueryExpressions[] _exps;\r\n-    private Object _single;\r\n-    private boolean _opened;\r\n-    \r\n-    private static final String COUNT = \"Count\";\r\n-    private static final String MAX   = \"Max\";\r\n-    private static final String MIN   = \"Min\";\r\n-    private static final String SUM   = \"Sum\";\r\n-    \r\n-    private static final Localizer _loc =\r\n-        Localizer.forPackage(UniqueResultObjectProvider.class);\r\n-    \r\n-    public UniqueResultObjectProvider(ResultObjectProvider[] rops, \r\n-            StoreQuery q, QueryExpressions[] exps) {\r\n-        _rops = rops;\r\n-        _query = q;\r\n-        _exps = exps;\r\n-    }\r\n-    \r\n-    public boolean absolute(int pos) throws Exception {\r\n-        return false;\r\n-    }\r\n-\r\n-    public void close() throws Exception {\r\n-        _opened = false;\r\n-        for (ResultObjectProvider rop:_rops)\r\n-            rop.close();\r\n-    }\r\n-\r\n-    public Object getResultObject() throws Exception {\r\n-        if (!_opened)\r\n-            throw new InternalException(_loc.get(\"not-open\"));\r\n-        return _single;\r\n-    }\r\n-\r\n-    public void handleCheckedException(Exception e) {\r\n-        _rops[0].handleCheckedException(e);\r\n-    }\r\n-\r\n-    public boolean next() throws Exception {\r\n-        if (!_opened) {\r\n-            open();\r\n-        }\r\n-            \r\n-        if (_single != null)\r\n-            return false;\r\n-        \r\n-        Value[] values = _exps[0].projections;\r\n-        Object[] single = new Object[values.length]; \r\n-        for (int i=0; i<values.length; i++) {\r\n-            Value v = values[i];\r\n-            boolean isAggregate = v.isAggregate();\r\n-            String op = v.getClass().getSimpleName();\r\n-            for (ResultObjectProvider rop:_rops) {\r\n-                if (i == 0) \r\n-                \trop.next();\r\n-                Object[] row = (Object[]) rop.getResultObject();\r\n-                if (isAggregate) {\r\n-                    if (COUNT.equals(op)) {\r\n-                        single[i] = count(single[i], row[i]);\r\n-                    } else if (MAX.equals(op)) {\r\n-                        single[i] = max(single[i], row[i]);\r\n-                    } else if (MIN.equals(op)) {\r\n-                        single[i] = min(single[i], row[i]);\r\n-                    } else if (SUM.equals(op)) {\r\n-                        single[i] = sum(single[i], row[i]);\r\n-                    } else {\r\n-                        throw new UnsupportedOperationException\r\n-                            (_loc.get(\"aggregate-unsupported\", op).toString());\r\n-                    }\r\n-                } else {\r\n-                    single[i] = row[i];\r\n-                }\r\n-            }\r\n-        }\r\n-        _single = single;\r\n-        return true;\r\n-    }\r\n-    \r\n-    Object count(Object current, Object other) {\r\n-        if (current == null)\r\n-            return other;\r\n-        if (other == null)\r\n-        \treturn current;\r\n-        return ((Number)current).longValue() + ((Number)other).longValue();\r\n-    }\r\n-    \r\n-    Object max(Object current, Object other) {\r\n-        if (current == null)\r\n-            return other;\r\n-        if (other == null)\r\n-        \treturn current;\r\n-        return Math.max(((Number)current).doubleValue(), \r\n-                ((Number)other).doubleValue());\r\n-    }\r\n-    \r\n-    Object min(Object current, Object other) {\r\n-        if (current == null)\r\n-            return other;\r\n-        if (other == null)\r\n-        \treturn current;\r\n-        return Math.min(((Number)current).doubleValue(), \r\n-                ((Number)other).doubleValue());\r\n-    }\r\n-    \r\n-    Object sum(Object current, Object other) {\r\n-        if (current == null)\r\n-            return other;\r\n-        if (other == null)\r\n-        \treturn current;\r\n-        return (((Number)current).doubleValue() +\r\n-                ((Number)other).doubleValue());\r\n-    }\r\n-\r\n-\r\n-\r\n-    public void open() throws Exception {\r\n-        for (ResultObjectProvider rop:_rops)\r\n-            rop.open();\r\n-        _opened = true;\r\n-    }\r\n-\r\n-    public void reset() throws Exception {\r\n-        _single = null;\r\n-        for (ResultObjectProvider rop : _rops) {\r\n-            rop.reset();\r\n-        }\r\n-    }\r\n-\r\n-    public int size() throws Exception {\r\n-        return 1;\r\n-    }\r\n-\r\n-    public boolean supportsRandomAccess() {\r\n-         return false;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.jdbc;\n+\n+import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.kernel.exps.QueryExpressions;\n+import org.apache.openjpa.kernel.exps.Value;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InternalException;\n+\n+/**\n+ * Aggregates individual single query results from different databases.\n+ * \n+ * @author Pinaki Poddar \n+ *\n+ */\n+public class UniqueResultObjectProvider implements ResultObjectProvider {\n+    private final ResultObjectProvider[] _rops;\n+    private final StoreQuery _query;\n+    private final QueryExpressions[] _exps;\n+    private Object _single;\n+    private boolean _opened;\n+    \n+    private static final String COUNT = \"Count\";\n+    private static final String MAX   = \"Max\";\n+    private static final String MIN   = \"Min\";\n+    private static final String SUM   = \"Sum\";\n+    \n+    private static final Localizer _loc =\n+        Localizer.forPackage(UniqueResultObjectProvider.class);\n+    \n+    public UniqueResultObjectProvider(ResultObjectProvider[] rops, \n+            StoreQuery q, QueryExpressions[] exps) {\n+        _rops = rops;\n+        _query = q;\n+        _exps = exps;\n+    }\n+    \n+    public boolean absolute(int pos) throws Exception {\n+        return false;\n+    }\n+\n+    public void close() throws Exception {\n+        _opened = false;\n+        for (ResultObjectProvider rop:_rops)\n+            rop.close();\n+    }\n+\n+    public Object getResultObject() throws Exception {\n+        if (!_opened)\n+            throw new InternalException(_loc.get(\"not-open\"));\n+        return _single;\n+    }\n+\n+    public void handleCheckedException(Exception e) {\n+        _rops[0].handleCheckedException(e);\n+    }\n+\n+    public boolean next() throws Exception {\n+        if (!_opened) {\n+            open();\n+        }\n+            \n+        if (_single != null)\n+            return false;\n+        \n+        Value[] values = _exps[0].projections;\n+        Object[] single = new Object[values.length]; \n+        for (int i=0; i<values.length; i++) {\n+            Value v = values[i];\n+            boolean isAggregate = v.isAggregate();\n+            String op = v.getClass().getSimpleName();\n+            for (ResultObjectProvider rop:_rops) {\n+                if (i == 0) \n+                \trop.next();\n+                Object[] row = (Object[]) rop.getResultObject();\n+                if (isAggregate) {\n+                    if (COUNT.equals(op)) {\n+                        single[i] = count(single[i], row[i]);\n+                    } else if (MAX.equals(op)) {\n+                        single[i] = max(single[i], row[i]);\n+                    } else if (MIN.equals(op)) {\n+                        single[i] = min(single[i], row[i]);\n+                    } else if (SUM.equals(op)) {\n+                        single[i] = sum(single[i], row[i]);\n+                    } else {\n+                        throw new UnsupportedOperationException\n+                            (_loc.get(\"aggregate-unsupported\", op).toString());\n+                    }\n+                } else {\n+                    single[i] = row[i];\n+                }\n+            }\n+        }\n+        _single = single;\n+        return true;\n+    }\n+    \n+    Object count(Object current, Object other) {\n+        if (current == null)\n+            return other;\n+        if (other == null)\n+        \treturn current;\n+        return ((Number)current).longValue() + ((Number)other).longValue();\n+    }\n+    \n+    Object max(Object current, Object other) {\n+        if (current == null)\n+            return other;\n+        if (other == null)\n+        \treturn current;\n+        return Math.max(((Number)current).doubleValue(), \n+                ((Number)other).doubleValue());\n+    }\n+    \n+    Object min(Object current, Object other) {\n+        if (current == null)\n+            return other;\n+        if (other == null)\n+        \treturn current;\n+        return Math.min(((Number)current).doubleValue(), \n+                ((Number)other).doubleValue());\n+    }\n+    \n+    Object sum(Object current, Object other) {\n+        if (current == null)\n+            return other;\n+        if (other == null)\n+        \treturn current;\n+        return (((Number)current).doubleValue() +\n+                ((Number)other).doubleValue());\n+    }\n+\n+\n+\n+    public void open() throws Exception {\n+        for (ResultObjectProvider rop:_rops)\n+            rop.open();\n+        _opened = true;\n+    }\n+\n+    public void reset() throws Exception {\n+        _single = null;\n+        for (ResultObjectProvider rop : _rops) {\n+            rop.reset();\n+        }\n+    }\n+\n+    public int size() throws Exception {\n+        return 1;\n+    }\n+\n+    public boolean supportsRandomAccess() {\n+         return false;\n+    }\n+}"},{"sha":"ea53e663a7981567627e9bf125bcce989cfd0a1f","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/Address.java","status":"modified","additions":93,"deletions":93,"changes":186,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/Address.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/Address.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/Address.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,93 +1,93 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import javax.persistence.*;\r\n-\r\n-@Entity\r\n-public class Address {\r\n-    @Id\r\n-    @GeneratedValue\r\n-    private long id;\r\n-\r\n-    private String city;\r\n-    private int zip;\r\n-    \r\n-    @OneToOne\r\n-    private Country country;\r\n-\r\n-    @OneToOne(mappedBy = \"address\")\r\n-    Person owner;\r\n-\r\n-    @Version\r\n-    private long version;\r\n-\r\n-    public long getVersion() {\r\n-        return version;\r\n-    }\r\n-\r\n-    public Address() {\r\n-        this(\"?\", 0);\r\n-    }\r\n-\r\n-    public Address(String city, int zip) {\r\n-        setCity(city);\r\n-        setZip(zip);\r\n-    }\r\n-\r\n-    public String getCity() {\r\n-        return city;\r\n-    }\r\n-\r\n-    public void setCity(String city) {\r\n-        this.city = city;\r\n-    }\r\n-\r\n-    public int getZip() {\r\n-        return zip;\r\n-    }\r\n-\r\n-    public void setZip(int zip) {\r\n-        this.zip = zip;\r\n-    }\r\n-\r\n-    public Person getOwner() {\r\n-        return owner;\r\n-    }\r\n-\r\n-    public void setOwner(Person owner) {\r\n-        this.owner = owner;\r\n-    }\r\n-\r\n-    public long getId() {\r\n-        return id;\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return city;\r\n-    }\r\n-\r\n-\tpublic Country getCountry() {\r\n-\t\treturn country;\r\n-\t}\r\n-\r\n-\tpublic void setCountry(Country country) {\r\n-\t\tthis.country = country;\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import javax.persistence.*;\n+\n+@Entity\n+public class Address {\n+    @Id\n+    @GeneratedValue\n+    private long id;\n+\n+    private String city;\n+    private int zip;\n+    \n+    @OneToOne\n+    private Country country;\n+\n+    @OneToOne(mappedBy = \"address\")\n+    Person owner;\n+\n+    @Version\n+    private long version;\n+\n+    public long getVersion() {\n+        return version;\n+    }\n+\n+    public Address() {\n+        this(\"?\", 0);\n+    }\n+\n+    public Address(String city, int zip) {\n+        setCity(city);\n+        setZip(zip);\n+    }\n+\n+    public String getCity() {\n+        return city;\n+    }\n+\n+    public void setCity(String city) {\n+        this.city = city;\n+    }\n+\n+    public int getZip() {\n+        return zip;\n+    }\n+\n+    public void setZip(int zip) {\n+        this.zip = zip;\n+    }\n+\n+    public Person getOwner() {\n+        return owner;\n+    }\n+\n+    public void setOwner(Person owner) {\n+        this.owner = owner;\n+    }\n+\n+    public long getId() {\n+        return id;\n+    }\n+\n+    public String toString() {\n+        return city;\n+    }\n+\n+\tpublic Country getCountry() {\n+\t\treturn country;\n+\t}\n+\n+\tpublic void setCountry(Country country) {\n+\t\tthis.country = country;\n+\t}\n+}"},{"sha":"3c161cda0efa910269fec61cd34ce9702432a840","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/Country.java","status":"modified","additions":65,"deletions":65,"changes":130,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/Country.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/Country.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/Country.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,65 +1,65 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.Id;\r\n-import javax.persistence.Version;\r\n-\r\n-import org.apache.openjpa.persistence.Replicated;\r\n-\r\n-/**\r\n- * A persistence entity to be replicated across multiple databases. A\r\n- * non-replicated entity can refer to a replicated entity.\r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- */\r\n-@Entity\r\n-@Replicated\r\n-public class Country {\r\n-    @Id\r\n-    private String name;\r\n-\r\n-    private long population;\r\n-\r\n-    @Version\r\n-    private int version;\r\n-\r\n-    public String getName() {\r\n-        return name;\r\n-    }\r\n-\r\n-    public void setName(String name) {\r\n-        this.name = name;\r\n-    }\r\n-\r\n-    public long getPopulation() {\r\n-        return population;\r\n-    }\r\n-\r\n-    public void setPopulation(long population) {\r\n-        this.population = population;\r\n-    }\r\n-\r\n-    public int getVersion() {\r\n-        return version;\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.Version;\n+\n+import org.apache.openjpa.persistence.Replicated;\n+\n+/**\n+ * A persistence entity to be replicated across multiple databases. A\n+ * non-replicated entity can refer to a replicated entity.\n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+@Entity\n+@Replicated\n+public class Country {\n+    @Id\n+    private String name;\n+\n+    private long population;\n+\n+    @Version\n+    private int version;\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public long getPopulation() {\n+        return population;\n+    }\n+\n+    public void setPopulation(long population) {\n+        this.population = population;\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+}"},{"sha":"818e624b8f4a5b0e8051b02eff380129f344909d","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/PObject.java","status":"modified","additions":48,"deletions":48,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/PObject.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/PObject.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/PObject.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,48 +1,48 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.Id;\r\n-\r\n-@Entity\r\n-public class PObject {\r\n-\t@Id\r\n-\tprivate long id;\r\n-\t\r\n-\tprivate int value;\r\n-\t\r\n-\tprivate static long idCounter = System.currentTimeMillis();\r\n-\t\r\n-\tpublic PObject() {\r\n-\t\tid = ++idCounter;\r\n-\t}\r\n-\t\r\n-\tpublic long getId() {\r\n-\t\treturn id;\r\n-\t}\r\n-\t\r\n-\tpublic int getValue() {\r\n-\t\treturn value;\r\n-\t}\r\n-\t\r\n-\tpublic void setValue(int i) {\r\n-\t\tvalue = i;\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class PObject {\n+\t@Id\n+\tprivate long id;\n+\t\n+\tprivate int value;\n+\t\n+\tprivate static long idCounter = System.currentTimeMillis();\n+\t\n+\tpublic PObject() {\n+\t\tid = ++idCounter;\n+\t}\n+\t\n+\tpublic long getId() {\n+\t\treturn id;\n+\t}\n+\t\n+\tpublic int getValue() {\n+\t\treturn value;\n+\t}\n+\t\n+\tpublic void setValue(int i) {\n+\t\tvalue = i;\n+\t}\n+}"},{"sha":"53dc4a9f0511f41f7f97b9425327e9ee79b472d0","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/PersistenceTestCase.java","status":"modified","additions":241,"deletions":241,"changes":482,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/PersistenceTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/PersistenceTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/PersistenceTestCase.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,241 +1,241 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.lang.reflect.Modifier;\r\n-import java.util.ArrayList;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.HashMap;\r\n-import javax.persistence.EntityManager;\r\n-import javax.persistence.EntityManagerFactory;\r\n-import javax.persistence.Persistence;\r\n-\r\n-import junit.framework.TestCase;\r\n-import junit.framework.TestResult;\r\n-import org.apache.openjpa.kernel.AbstractBrokerFactory;\r\n-import org.apache.openjpa.kernel.Broker;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\r\n-import org.apache.openjpa.persistence.JPAFacadeHelper;\r\n-\r\n-/**\r\n- * Base test class providing persistence utilities.\r\n- */\r\n-public abstract class PersistenceTestCase\r\n-    extends TestCase {\r\n-\r\n-    /**\r\n-     * Marker object you an pass to {@link #setUp} to indicate that the\r\n-     * database tables should be cleared.\r\n-     */\r\n-    protected static final Object CLEAR_TABLES = new Object();\r\n-\r\n-    /**\r\n-     * The {@link TestResult} instance for the current test run.\r\n-     */\r\n-    protected TestResult testResult;\r\n-\r\n-    /**\r\n-     * Create an entity manager factory. Put {@link #CLEAR_TABLES} in\r\n-     * this list to tell the test framework to delete all table contents\r\n-     * before running the tests.\r\n-     *\r\n-     * @param props list of persistent types used in testing and/or\r\n-     * configuration values in the form key,value,key,value...\r\n-     */\r\n-    protected OpenJPAEntityManagerFactorySPI createEMF(Object... props) {\r\n-        return createNamedEMF(getPersistenceUnitName(), props);\r\n-    }\r\n-\r\n-    /**\r\n-     * The name of the persistence unit that this test class should use\r\n-     * by default. This defaults to \"test\".\r\n-     */\r\n-    protected String getPersistenceUnitName() {\r\n-        return \"test\";\r\n-    }\r\n-\r\n-    /**\r\n-     * Create an entity manager factory for persistence unit <code>pu</code>.\r\n-     * Put {@link #CLEAR_TABLES} in\r\n-     * this list to tell the test framework to delete all table contents\r\n-     * before running the tests.\r\n-     *\r\n-     * @param props list of persistent types used in testing and/or\r\n-     * configuration values in the form key,value,key,value...\r\n-     */\r\n-    protected OpenJPAEntityManagerFactorySPI createNamedEMF(String pu,\r\n-        Object... props) {\r\n-        Map map = new HashMap(System.getProperties());\r\n-        List<Class> types = new ArrayList<Class>();\r\n-        boolean prop = false;\r\n-        for (int i = 0; i < props.length; i++) {\r\n-            if (prop) {\r\n-                map.put(props[i - 1], props[i]);\r\n-                prop = false;\r\n-            } else if (props[i] == CLEAR_TABLES) {\r\n-                map.put(\"openjpa.jdbc.SynchronizeMappings\",\r\n-                    \"buildSchema(ForeignKeys=true,\" \r\n-                    + \"SchemaAction='add,deleteTableContents')\");\r\n-            } else if (props[i] instanceof Class)\r\n-                types.add((Class) props[i]);\r\n-            else if (props[i] != null)\r\n-                prop = true;\r\n-        }\r\n-\r\n-        if (!types.isEmpty()) {\r\n-            StringBuffer buf = new StringBuffer();\r\n-            for (Class c : types) {\r\n-                if (buf.length() > 0)\r\n-                    buf.append(\";\");\r\n-                buf.append(c.getName());\r\n-            }\r\n-            map.put(\"openjpa.MetaDataFactory\",\r\n-                \"jpa(Types=\" + buf.toString() + \")\");\r\n-        }\r\n-\r\n-        return (OpenJPAEntityManagerFactorySPI) Persistence.\r\n-            createEntityManagerFactory(pu, map);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void run(TestResult testResult) {\r\n-        this.testResult = testResult;\r\n-        super.run(testResult);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void tearDown() throws Exception {\r\n-        try {\r\n-            super.tearDown();\r\n-        } catch (Exception e) {\r\n-            // if a test failed, swallow any exceptions that happen\r\n-            // during tear-down, as these just mask the original problem.\r\n-            if (testResult.wasSuccessful())\r\n-                throw e;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Safely close the given factory.\r\n-     */\r\n-    protected boolean closeEMF(EntityManagerFactory emf) {\r\n-        if (emf == null || !emf.isOpen())\r\n-            return false;\r\n-        \r\n-        closeAllOpenEMs(emf);\r\n-        emf.close();\r\n-        return !emf.isOpen();\r\n-    }\r\n-\r\n-    /**\r\n-     * Closes all open entity managers after first rolling back any open transactions\r\n-     */\r\n-    protected void closeAllOpenEMs(EntityManagerFactory emf) {\r\n-        if (emf == null || !emf.isOpen())\r\n-            return;\r\n-\r\n-        for (Iterator iter = ((AbstractBrokerFactory) JPAFacadeHelper\r\n-            .toBrokerFactory(emf)).getOpenBrokers().iterator();\r\n-            iter.hasNext(); ) {\r\n-            Broker b = (Broker) iter.next();\r\n-            if (b != null && !b.isClosed()) {\r\n-                EntityManager em = JPAFacadeHelper.toEntityManager(b);\r\n-                if (em.getTransaction().isActive())\r\n-                    em.getTransaction().rollback();\r\n-                em.close();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Delete all instances of the given types using bulk delete queries,\r\n-     * but do not close any open entity managers.\r\n-     */\r\n-    protected void clear(EntityManagerFactory emf, Class... types) {\r\n-        if (emf == null || types.length == 0)\r\n-            return;\r\n-\r\n-        List<ClassMetaData> metas = new ArrayList<ClassMetaData>(types.length);\r\n-        for (Class c : types) {\r\n-            ClassMetaData meta = JPAFacadeHelper.getMetaData(emf, c);\r\n-            if (meta != null)\r\n-                metas.add(meta);\r\n-        }\r\n-        clear(emf, false, metas.toArray(new ClassMetaData[metas.size()]));\r\n-    }\r\n-\r\n-    /**\r\n-     * Delete all instances of the persistent types registered with the given\r\n-     * factory using bulk delete queries, after first closing all open entity\r\n-     * managers (and rolling back any open transactions).\r\n-     */\r\n-    protected void clear(EntityManagerFactory emf) {\r\n-        if (emf == null)\r\n-            return;\r\n-        clear(emf, true, ((OpenJPAEntityManagerFactorySPI) emf).getConfiguration().\r\n-            getMetaDataRepositoryInstance().getMetaDatas());\r\n-    }\r\n-\r\n-    /**\r\n-     * Delete all instances of the given types using bulk delete queries.\r\n-     * @param closeEMs TODO\r\n-     */\r\n-    private void clear(EntityManagerFactory emf, boolean closeEMs, ClassMetaData... types) {\r\n-        if (emf == null || types.length == 0)\r\n-            return;\r\n-        \r\n-        // prevent deadlock by closing the open entity managers \r\n-        // and rolling back any open transactions \r\n-        // before issuing delete statements on a new entity manager.\r\n-        if (closeEMs)\r\n-            closeAllOpenEMs(emf);\r\n-\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        for (ClassMetaData meta : types) {\r\n-            if (!meta.isMapped() || meta.isEmbeddedOnly() \r\n-                || Modifier.isAbstract(meta.getDescribedType().getModifiers()))\r\n-                continue;\r\n-//            em.createQuery(\"DELETE FROM \" + meta.getTypeAlias() + \" o\").\r\n-//                executeUpdate();\r\n-        }\r\n-        em.getTransaction().commit();\r\n-        em.close();\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the entity name for the given type.   \r\n-     */\r\n-    protected String entityName(EntityManagerFactory emf, Class c) {\r\n-        ClassMetaData meta = JPAFacadeHelper.getMetaData(emf, c);\r\n-        return (meta == null) ? null : meta.getTypeAlias();\r\n-    }\r\n-\r\n-    public static void assertNotEquals(Object o1, Object o2) {\r\n-        if (o1 == o2)\r\n-            fail(\"expected args to be different; were the same instance.\");\r\n-        else if (o1 == null || o2 == null)\r\n-            return;\r\n-        else if (o1.equals(o2))\r\n-            fail(\"expected args to be different; compared equal.\");\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.HashMap;\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Persistence;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestResult;\n+import org.apache.openjpa.kernel.AbstractBrokerFactory;\n+import org.apache.openjpa.kernel.Broker;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+import org.apache.openjpa.persistence.JPAFacadeHelper;\n+\n+/**\n+ * Base test class providing persistence utilities.\n+ */\n+public abstract class PersistenceTestCase\n+    extends TestCase {\n+\n+    /**\n+     * Marker object you an pass to {@link #setUp} to indicate that the\n+     * database tables should be cleared.\n+     */\n+    protected static final Object CLEAR_TABLES = new Object();\n+\n+    /**\n+     * The {@link TestResult} instance for the current test run.\n+     */\n+    protected TestResult testResult;\n+\n+    /**\n+     * Create an entity manager factory. Put {@link #CLEAR_TABLES} in\n+     * this list to tell the test framework to delete all table contents\n+     * before running the tests.\n+     *\n+     * @param props list of persistent types used in testing and/or\n+     * configuration values in the form key,value,key,value...\n+     */\n+    protected OpenJPAEntityManagerFactorySPI createEMF(Object... props) {\n+        return createNamedEMF(getPersistenceUnitName(), props);\n+    }\n+\n+    /**\n+     * The name of the persistence unit that this test class should use\n+     * by default. This defaults to \"test\".\n+     */\n+    protected String getPersistenceUnitName() {\n+        return \"test\";\n+    }\n+\n+    /**\n+     * Create an entity manager factory for persistence unit <code>pu</code>.\n+     * Put {@link #CLEAR_TABLES} in\n+     * this list to tell the test framework to delete all table contents\n+     * before running the tests.\n+     *\n+     * @param props list of persistent types used in testing and/or\n+     * configuration values in the form key,value,key,value...\n+     */\n+    protected OpenJPAEntityManagerFactorySPI createNamedEMF(String pu,\n+        Object... props) {\n+        Map map = new HashMap(System.getProperties());\n+        List<Class> types = new ArrayList<Class>();\n+        boolean prop = false;\n+        for (int i = 0; i < props.length; i++) {\n+            if (prop) {\n+                map.put(props[i - 1], props[i]);\n+                prop = false;\n+            } else if (props[i] == CLEAR_TABLES) {\n+                map.put(\"openjpa.jdbc.SynchronizeMappings\",\n+                    \"buildSchema(ForeignKeys=true,\" \n+                    + \"SchemaAction='add,deleteTableContents')\");\n+            } else if (props[i] instanceof Class)\n+                types.add((Class) props[i]);\n+            else if (props[i] != null)\n+                prop = true;\n+        }\n+\n+        if (!types.isEmpty()) {\n+            StringBuffer buf = new StringBuffer();\n+            for (Class c : types) {\n+                if (buf.length() > 0)\n+                    buf.append(\";\");\n+                buf.append(c.getName());\n+            }\n+            map.put(\"openjpa.MetaDataFactory\",\n+                \"jpa(Types=\" + buf.toString() + \")\");\n+        }\n+\n+        return (OpenJPAEntityManagerFactorySPI) Persistence.\n+            createEntityManagerFactory(pu, map);\n+    }\n+\n+    @Override\n+    public void run(TestResult testResult) {\n+        this.testResult = testResult;\n+        super.run(testResult);\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        try {\n+            super.tearDown();\n+        } catch (Exception e) {\n+            // if a test failed, swallow any exceptions that happen\n+            // during tear-down, as these just mask the original problem.\n+            if (testResult.wasSuccessful())\n+                throw e;\n+        }\n+    }\n+\n+    /**\n+     * Safely close the given factory.\n+     */\n+    protected boolean closeEMF(EntityManagerFactory emf) {\n+        if (emf == null || !emf.isOpen())\n+            return false;\n+        \n+        closeAllOpenEMs(emf);\n+        emf.close();\n+        return !emf.isOpen();\n+    }\n+\n+    /**\n+     * Closes all open entity managers after first rolling back any open transactions\n+     */\n+    protected void closeAllOpenEMs(EntityManagerFactory emf) {\n+        if (emf == null || !emf.isOpen())\n+            return;\n+\n+        for (Iterator iter = ((AbstractBrokerFactory) JPAFacadeHelper\n+            .toBrokerFactory(emf)).getOpenBrokers().iterator();\n+            iter.hasNext(); ) {\n+            Broker b = (Broker) iter.next();\n+            if (b != null && !b.isClosed()) {\n+                EntityManager em = JPAFacadeHelper.toEntityManager(b);\n+                if (em.getTransaction().isActive())\n+                    em.getTransaction().rollback();\n+                em.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Delete all instances of the given types using bulk delete queries,\n+     * but do not close any open entity managers.\n+     */\n+    protected void clear(EntityManagerFactory emf, Class... types) {\n+        if (emf == null || types.length == 0)\n+            return;\n+\n+        List<ClassMetaData> metas = new ArrayList<ClassMetaData>(types.length);\n+        for (Class c : types) {\n+            ClassMetaData meta = JPAFacadeHelper.getMetaData(emf, c);\n+            if (meta != null)\n+                metas.add(meta);\n+        }\n+        clear(emf, false, metas.toArray(new ClassMetaData[metas.size()]));\n+    }\n+\n+    /**\n+     * Delete all instances of the persistent types registered with the given\n+     * factory using bulk delete queries, after first closing all open entity\n+     * managers (and rolling back any open transactions).\n+     */\n+    protected void clear(EntityManagerFactory emf) {\n+        if (emf == null)\n+            return;\n+        clear(emf, true, ((OpenJPAEntityManagerFactorySPI) emf).getConfiguration().\n+            getMetaDataRepositoryInstance().getMetaDatas());\n+    }\n+\n+    /**\n+     * Delete all instances of the given types using bulk delete queries.\n+     * @param closeEMs TODO\n+     */\n+    private void clear(EntityManagerFactory emf, boolean closeEMs, ClassMetaData... types) {\n+        if (emf == null || types.length == 0)\n+            return;\n+        \n+        // prevent deadlock by closing the open entity managers \n+        // and rolling back any open transactions \n+        // before issuing delete statements on a new entity manager.\n+        if (closeEMs)\n+            closeAllOpenEMs(emf);\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        for (ClassMetaData meta : types) {\n+            if (!meta.isMapped() || meta.isEmbeddedOnly() \n+                || Modifier.isAbstract(meta.getDescribedType().getModifiers()))\n+                continue;\n+//            em.createQuery(\"DELETE FROM \" + meta.getTypeAlias() + \" o\").\n+//                executeUpdate();\n+        }\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    /**\n+     * Return the entity name for the given type.   \n+     */\n+    protected String entityName(EntityManagerFactory emf, Class c) {\n+        ClassMetaData meta = JPAFacadeHelper.getMetaData(emf, c);\n+        return (meta == null) ? null : meta.getTypeAlias();\n+    }\n+\n+    public static void assertNotEquals(Object o1, Object o2) {\n+        if (o1 == o2)\n+            fail(\"expected args to be different; were the same instance.\");\n+        else if (o1 == null || o2 == null)\n+            return;\n+        else if (o1.equals(o2))\n+            fail(\"expected args to be different; compared equal.\");\n+    }\n+}"},{"sha":"8a06c08d4d75a36dbd37c89b9cfb442250910fe0","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/Person.java","status":"modified","additions":73,"deletions":73,"changes":146,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/Person.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/Person.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/Person.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,73 +1,73 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import javax.persistence.*;\r\n-\r\n-@Entity\r\n-public class Person {\r\n-\t@Id\r\n-\t@GeneratedValue\r\n-\tprivate long id;\r\n-\r\n-\tprivate String name;\r\n-\t\r\n-\t@Version\r\n-\tprivate long version;\r\n-\r\n-\t@OneToOne(cascade=CascadeType.ALL)\r\n-\tprivate Address address;\r\n-\r\n-\tpublic Person() {\r\n-\t\tthis(\"?\");\r\n-\t}\r\n-\t\r\n-\tpublic Person(String name) {\r\n-\t\tsetName(name);\r\n-\t}\r\n-\t\r\n-\tpublic String getName() {\r\n-\t\treturn name;\r\n-\t}\r\n-\r\n-\tpublic void setName(String name) {\r\n-\t\tthis.name = name;\r\n-\t}\r\n-\r\n-\tpublic Address getAddress() {\r\n-\t\treturn address;\r\n-\t}\r\n-\r\n-\tpublic void setAddress(Address address) {\r\n-\t\tthis.address = address;\r\n-\t\taddress.setOwner(this);\r\n-\t}\r\n-\r\n-\tpublic long getId() {\r\n-\t\treturn id;\r\n-\t}\r\n-\t\r\n-\tpublic String toString() {\r\n-\t\treturn name;\r\n-\t}\r\n-\r\n-    public long getVersion() {\r\n-        return version;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import javax.persistence.*;\n+\n+@Entity\n+public class Person {\n+\t@Id\n+\t@GeneratedValue\n+\tprivate long id;\n+\n+\tprivate String name;\n+\t\n+\t@Version\n+\tprivate long version;\n+\n+\t@OneToOne(cascade=CascadeType.ALL)\n+\tprivate Address address;\n+\n+\tpublic Person() {\n+\t\tthis(\"?\");\n+\t}\n+\t\n+\tpublic Person(String name) {\n+\t\tsetName(name);\n+\t}\n+\t\n+\tpublic String getName() {\n+\t\treturn name;\n+\t}\n+\n+\tpublic void setName(String name) {\n+\t\tthis.name = name;\n+\t}\n+\n+\tpublic Address getAddress() {\n+\t\treturn address;\n+\t}\n+\n+\tpublic void setAddress(Address address) {\n+\t\tthis.address = address;\n+\t\taddress.setOwner(this);\n+\t}\n+\n+\tpublic long getId() {\n+\t\treturn id;\n+\t}\n+\t\n+\tpublic String toString() {\n+\t\treturn name;\n+\t}\n+\n+    public long getVersion() {\n+        return version;\n+    }\n+}"},{"sha":"b89d8587d39d3fd92384d8c3f897b12cba8fd398","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/ReplicatedChild.java","status":"modified","additions":52,"deletions":52,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/ReplicatedChild.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/ReplicatedChild.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/ReplicatedChild.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,52 +1,52 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.Id;\r\n-import javax.persistence.ManyToOne;\r\n-\r\n-import org.apache.openjpa.persistence.Replicated;\r\n-\r\n-@Entity\r\n-@Replicated\r\n-public class ReplicatedChild {\r\n-    @Id \r\n-    private String name;\r\n-    \r\n-    @ManyToOne\r\n-    private ReplicatedParent parent;\r\n-\r\n-    public String getName() {\r\n-        return name;\r\n-    }\r\n-    \r\n-    public void setName(String name) {\r\n-        this.name = name;\r\n-    }\r\n-    \r\n-    public ReplicatedParent getParent() {\r\n-        return parent;\r\n-    }\r\n-    \r\n-    void setParent(ReplicatedParent parent) {\r\n-        this.parent = parent;\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToOne;\n+\n+import org.apache.openjpa.persistence.Replicated;\n+\n+@Entity\n+@Replicated\n+public class ReplicatedChild {\n+    @Id \n+    private String name;\n+    \n+    @ManyToOne\n+    private ReplicatedParent parent;\n+\n+    public String getName() {\n+        return name;\n+    }\n+    \n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+    \n+    public ReplicatedParent getParent() {\n+        return parent;\n+    }\n+    \n+    void setParent(ReplicatedParent parent) {\n+        this.parent = parent;\n+    }\n+\n+}"},{"sha":"42d88a19d8d37e47bce8d4531136cc7a2a1cfe7e","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/ReplicatedParent.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/ReplicatedParent.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/ReplicatedParent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/ReplicatedParent.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,55 +1,55 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.HashSet;\r\n-import java.util.Set;\r\n-\r\n-import javax.persistence.*;\r\n-\r\n-import org.apache.openjpa.persistence.Replicated;\r\n-\r\n-@Entity\r\n-@Replicated\r\n-public class ReplicatedParent {\r\n-    @Id \r\n-    private String name;\r\n-    \r\n-    @OneToMany(mappedBy=\"parent\", cascade=CascadeType.ALL)\r\n-    private Set<ReplicatedChild> children;\r\n-    \r\n-    public String getName() {\r\n-        return name;\r\n-    }\r\n-    \r\n-    public void setName(String name) {\r\n-        this.name = name;\r\n-    }\r\n-    \r\n-    public Set<ReplicatedChild> getChildren() {\r\n-        return children;\r\n-    }\r\n-    \r\n-    public void addChild(ReplicatedChild child) {\r\n-        if (children == null)\r\n-            children = new HashSet<ReplicatedChild>();\r\n-        children.add(child);\r\n-        child.setParent(this);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.*;\n+\n+import org.apache.openjpa.persistence.Replicated;\n+\n+@Entity\n+@Replicated\n+public class ReplicatedParent {\n+    @Id \n+    private String name;\n+    \n+    @OneToMany(mappedBy=\"parent\", cascade=CascadeType.ALL)\n+    private Set<ReplicatedChild> children;\n+    \n+    public String getName() {\n+        return name;\n+    }\n+    \n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+    \n+    public Set<ReplicatedChild> getChildren() {\n+        return children;\n+    }\n+    \n+    public void addChild(ReplicatedChild child) {\n+        if (children == null)\n+            children = new HashSet<ReplicatedChild>();\n+        children.add(child);\n+        child.setParent(this);\n+    }\n+}"},{"sha":"7f895e26b9a0f53e7613816caaec1a4f8214f7b2","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/SingleEMFTestCase.java","status":"modified","additions":76,"deletions":76,"changes":152,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/SingleEMFTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/SingleEMFTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/SingleEMFTestCase.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,76 +1,76 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n-import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\r\n-\r\n-public abstract class SingleEMFTestCase\r\n-    extends PersistenceTestCase {\r\n-\r\n-    protected OpenJPAEntityManagerFactorySPI emf;\r\n-\r\n-    /**\r\n-     * Call {@link #setUp(Object...)} with no arguments so that the emf\r\n-     * set-up happens even if <code>setUp()</code> is not called from the\r\n-     * subclass.\r\n-     */\r\n-    public void setUp() throws Exception {\r\n-        setUp(new Object[0]);\r\n-    }\r\n-\r\n-    /**\r\n-     * Initialize entity manager factory. Put {@link #CLEAR_TABLES} in\r\n-     * this list to tell the test framework to delete all table contents\r\n-     * before running the tests.\r\n-     *\r\n-     * @param props list of persistent types used in testing and/or \r\n-     * configuration values in the form key,value,key,value...\r\n-     */\r\n-    protected void setUp(Object... props) {\r\n-        emf = createEMF(props);\r\n-    }\r\n-\r\n-    /**\r\n-     * Closes the entity manager factory.\r\n-     */\r\n-    public void tearDown() throws Exception {\r\n-        super.tearDown();\r\n-\r\n-        if (emf == null)\r\n-            return;\r\n-\r\n-        try {\r\n-            clear(emf);\r\n-        } catch (Exception e) {\r\n-            // if a test failed, swallow any exceptions that happen\r\n-            // during tear-down, as these just mask the original problem.\r\n-            if (testResult.wasSuccessful())\r\n-                throw e;\r\n-        } finally {\r\n-            closeEMF(emf);\r\n-        }\r\n-    }\r\n-    \r\n-    protected ClassMapping getMapping(String name) {\r\n-        return (ClassMapping) emf.getConfiguration()\r\n-                .getMetaDataRepositoryInstance().getMetaData(name,\r\n-                        getClass().getClassLoader(), true);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+\n+public abstract class SingleEMFTestCase\n+    extends PersistenceTestCase {\n+\n+    protected OpenJPAEntityManagerFactorySPI emf;\n+\n+    /**\n+     * Call {@link #setUp(Object...)} with no arguments so that the emf\n+     * set-up happens even if <code>setUp()</code> is not called from the\n+     * subclass.\n+     */\n+    public void setUp() throws Exception {\n+        setUp(new Object[0]);\n+    }\n+\n+    /**\n+     * Initialize entity manager factory. Put {@link #CLEAR_TABLES} in\n+     * this list to tell the test framework to delete all table contents\n+     * before running the tests.\n+     *\n+     * @param props list of persistent types used in testing and/or \n+     * configuration values in the form key,value,key,value...\n+     */\n+    protected void setUp(Object... props) {\n+        emf = createEMF(props);\n+    }\n+\n+    /**\n+     * Closes the entity manager factory.\n+     */\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+\n+        if (emf == null)\n+            return;\n+\n+        try {\n+            clear(emf);\n+        } catch (Exception e) {\n+            // if a test failed, swallow any exceptions that happen\n+            // during tear-down, as these just mask the original problem.\n+            if (testResult.wasSuccessful())\n+                throw e;\n+        } finally {\n+            closeEMF(emf);\n+        }\n+    }\n+    \n+    protected ClassMapping getMapping(String name) {\n+        return (ClassMapping) emf.getConfiguration()\n+                .getMetaDataRepositoryInstance().getMetaData(name,\n+                        getClass().getClassLoader(), true);\n+    }\n+}"},{"sha":"a70dd3b4d04dc473c4db3221ea59b7dda1032b4a","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/SliceTestCase.java","status":"modified","additions":41,"deletions":41,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/SliceTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/SliceTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/SliceTestCase.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,41 +1,41 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import javax.persistence.EntityManager;\r\n-\r\n-import org.apache.openjpa.slice.jdbc.DistributedJDBCConfiguration;\r\n-\r\n-public abstract class SliceTestCase extends SingleEMFTestCase {\r\n-    protected void setUp(Object... props) {\r\n-        super.setUp(props);\r\n-        assertTrue(emf.getClass() + \" is not a slice configuration. Check\" +\r\n-            \" that BrokerFactory for the persistence unit is set to slice\",\r\n-             emf.getConfiguration() instanceof DistributedJDBCConfiguration);\r\n-        \r\n-    }\r\n-    \r\n-    int count(Class<?> type) {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        String query = \"SELECT COUNT(p) FROM \" + type.getSimpleName() + \" p\";\r\n-        Number number = (Number) em.createQuery(query).getSingleResult();\r\n-        return number.intValue();\r\n-    }\r\n-    \r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import javax.persistence.EntityManager;\n+\n+import org.apache.openjpa.slice.jdbc.DistributedJDBCConfiguration;\n+\n+public abstract class SliceTestCase extends SingleEMFTestCase {\n+    protected void setUp(Object... props) {\n+        super.setUp(props);\n+        assertTrue(emf.getClass() + \" is not a slice configuration. Check\" +\n+            \" that BrokerFactory for the persistence unit is set to slice\",\n+             emf.getConfiguration() instanceof DistributedJDBCConfiguration);\n+        \n+    }\n+    \n+    int count(Class<?> type) {\n+        EntityManager em = emf.createEntityManager();\n+        String query = \"SELECT COUNT(p) FROM \" + type.getSimpleName() + \" p\";\n+        Number number = (Number) em.createQuery(query).getSingleResult();\n+        return number.intValue();\n+    }\n+    \n+}"},{"sha":"0204648d03675bab41b58f8b111a2f5ebc027f35","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/TestBasic.java","status":"modified","additions":348,"deletions":348,"changes":696,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestBasic.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestBasic.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestBasic.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,348 +1,348 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import javax.persistence.EntityManager;\r\n-import javax.persistence.Query;\r\n-\r\n-import org.apache.openjpa.persistence.OpenJPAEntityManager;\r\n-\r\n-/**\r\n- * Tests basic create, read, update and delete operations.\r\n- * \r\n- * @author Pinaki Poddar \r\n- *\r\n- */\r\n-public class TestBasic extends SliceTestCase {\r\n-    /**\r\n-     * Specify persistence unit name as System property <code>-Dunit</code> or\r\n-     * use the default value as <code>\"slice\"</code>.\r\n-     */\r\n-    protected String getPersistenceUnitName() {\r\n-        return System.getProperty(\"unit\",\"slice\");\r\n-    }\r\n-\r\n-\r\n-    public void setUp() throws Exception {\r\n-        super.setUp(PObject.class, Person.class, Address.class, Country.class, \r\n-        \tCLEAR_TABLES);\r\n-    }\r\n-\r\n-    /**\r\n-     * Persist N independent objects.\r\n-     */\r\n-    List<PObject> createIndependentObjects(int N) {\r\n-        List<PObject> pcs = new ArrayList<PObject>();\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        for (int i = 0; i < N; i++) {\r\n-            PObject pc = new PObject();\r\n-            pcs.add(pc);\r\n-            em.persist(pc);\r\n-            pc.setValue(10+i);\r\n-        }\r\n-        em.getTransaction().commit();\r\n-        em.clear();\r\n-        return pcs;\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a single object.\r\n-     */\r\n-    PObject createIndependentObject() {\r\n-        return createIndependentObjects(1).get(0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Delete a single object by EntityManager.remove()\r\n-     */\r\n-    public void testDelete() {\r\n-        int N = 10;\r\n-        createIndependentObjects(N);\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        int before = count(PObject.class);\r\n-        List all = em.createQuery(\"SELECT p FROM PObject p\").getResultList();\r\n-        assertFalse(all.isEmpty());\r\n-        em.remove(all.get(0));\r\n-        em.getTransaction().commit();\r\n-\r\n-        int after = count(PObject.class);\r\n-        assertEquals(before - 1, after);\r\n-    }\r\n-\r\n-    /**\r\n-     * Delete in bulk by query.\r\n-     */\r\n-    public void testBulkDelete() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        int c = count(PObject.class);\r\n-        int d = em.createQuery(\"DELETE FROM PObject p\").executeUpdate();\r\n-        assertEquals(c, d);\r\n-        em.getTransaction().commit();\r\n-        c = count(PObject.class);\r\n-        assertEquals(0, c);\r\n-\r\n-    }\r\n-\r\n-    /**\r\n-     * Store and find the same object.\r\n-     */\r\n-    public void testFind() {\r\n-        PObject pc = createIndependentObject();\r\n-        int value = pc.getValue();\r\n-\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        PObject pc2 = em.find(PObject.class, pc.getId());\r\n-        assertNotNull(pc2);\r\n-        assertNotEquals(pc, pc2);\r\n-        assertEquals(pc.getId(), pc2.getId());\r\n-        assertEquals(value, pc2.getValue());\r\n-    }\r\n-    \r\n-    /**\r\n-     * Store and find the same object via reference.\r\n-     */\r\n-    public void testReference() {\r\n-        PObject pc = createIndependentObject();\r\n-        int value = pc.getValue();\r\n-\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        PObject ref = em.getReference(PObject.class, pc.getId());\r\n-        assertNotNull(ref);\r\n-        assertNotEquals(pc, ref);\r\n-        assertEquals(ref.getId(), pc.getId());\r\n-        pc.setValue(value+1);\r\n-        em.merge(pc);\r\n-        em.getTransaction().commit();\r\n-        em.clear();\r\n-        \r\n-        em.getTransaction().begin();\r\n-        PObject pc3 = em.find(PObject.class, pc.getId());\r\n-        assertEquals(value+1, pc3.getValue());\r\n-        em.getTransaction().commit();\r\n-        \r\n-    }\r\n-\r\n-\r\n-    public void testPersistIndependentObjects() {\r\n-        int before = count(PObject.class);\r\n-        EntityManager em = emf.createEntityManager();\r\n-        int N = 2;\r\n-        em.getTransaction().begin();\r\n-        for (int i = 0; i < N; i++)\r\n-            em.persist(new PObject());\r\n-        em.getTransaction().commit();\r\n-        em.clear();\r\n-        int after = count(PObject.class);\r\n-        assertEquals(before + N, after);\r\n-    }\r\n-\r\n-    public void testPersistConnectedObjectGraph() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        Person p1 = new Person(\"A\");\r\n-        Person p2 = new Person(\"B\");\r\n-        Person p3 = new Person(\"C\");\r\n-        Address a1 = new Address(\"Rome\", 12345);\r\n-        Address a2 = new Address(\"San Francisco\", 23456);\r\n-        Address a3 = new Address(\"New York\", 34567);\r\n-        Country c1 = em.find(Country.class, \"Italy\");\r\n-        if (c1 == null) {\r\n-        \tc1 = new Country();\r\n-        \tc1.setName(\"Italy\");\r\n-        \tem.persist(c1);\r\n-        }\r\n-    \ta1.setCountry(c1);\r\n-        p1.setAddress(a1);\r\n-        p2.setAddress(a2);\r\n-        p3.setAddress(a3);\r\n-\r\n-        em.persist(p1);\r\n-        em.persist(p2);\r\n-        em.persist(p3);\r\n-        em.getTransaction().commit();\r\n-\r\n-        em.clear();\r\n-\r\n-        em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        List<Person> persons =\r\n-                em.createQuery(\"SELECT p FROM Person p WHERE p.name=?1\")\r\n-                        .setParameter(1, \"A\").getResultList();\r\n-        List<Address> addresses =\r\n-                em.createQuery(\"SELECT a FROM Address a\").getResultList();\r\n-        for (Address pc : addresses) {\r\n-            assertNotNull(pc.getCity());\r\n-            assertNotNull(pc.getOwner().getName());\r\n-        }\r\n-        for (Person pc : persons) {\r\n-            assertNotNull(pc.getName());\r\n-            assertNotNull(pc.getAddress().getCity());\r\n-        }\r\n-        em.getTransaction().rollback();\r\n-    }\r\n-\r\n-    /**\r\n-     * Merge only works if the distribution policy assigns the correct slice\r\n-     * from which the instance was fetched.\r\n-     */\r\n-    public void testMerge() {\r\n-        PObject pc = createIndependentObjects(1).get(0);\r\n-        int value = pc.getValue();\r\n-        pc.setValue(value + 1);\r\n-        assertNotNull(pc);\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        PObject pc2 = em.merge(pc);\r\n-        em.getTransaction().commit();\r\n-        em.clear();\r\n-\r\n-        assertNotNull(pc2);\r\n-        assertNotEquals(pc, pc2);\r\n-        assertEquals(pc.getId(), pc2.getId());\r\n-        assertEquals(value + 1, pc2.getValue());\r\n-    }\r\n-    \r\n-    public void testPersistReplicatedObjects() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        String[] names = {\"USA\", \"India\", \"China\"};\r\n-        for (String name : names) {\r\n-        \tCountry country = new Country();\r\n-        \tcountry.setName(name);\r\n-        \tem.persist(country);\r\n-        }\r\n-        em.getTransaction().commit();\r\n-        assertEquals(names.length, count(Country.class));\r\n-        \r\n-        em.getTransaction().begin();\r\n-        Country india = em.find(Country.class, \"India\");\r\n-        assertNotNull(india);\r\n-        assertEquals(\"India\", india.getName());\r\n-        assertTrue(SlicePersistence.isReplicated(india));\r\n-        assertTrue(SlicePersistence.getSlice(india).indexOf(\"One\") != -1);\r\n-        assertTrue(SlicePersistence.getSlice(india).indexOf(\"Two\") != -1);\r\n-    }\r\n-    \r\n-    /**\r\n-     * Disable this test temporarily as we undergo changes in internal slice \r\n-     * information structure.\r\n-     */\r\n-    public void testUpdateReplicatedObjects() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        String[] names = {\"USA\", \"India\", \"China\"};\r\n-        long[] population = {300,1200,1400};\r\n-        for (int i = 0; i < names.length; i++) {\r\n-        \tCountry country = new Country();\r\n-        \tcountry.setName(names[i]);\r\n-        \tcountry.setPopulation(population[i]);\r\n-        \tem.persist(country);\r\n-        }\r\n-        em.getTransaction().commit();\r\n-        em.clear();\r\n-        \r\n-        assertEquals(names.length, count(Country.class));\r\n-        Country india = em.find(Country.class, \"India\");\r\n-\r\n-        assertNotNull(india);\r\n-        assertEquals(\"India\", india.getName());\r\n-        india.setPopulation(1201);\r\n-        em.getTransaction().begin();\r\n-        em.merge(india);\r\n-        em.getTransaction().commit();\r\n-        \r\n-        String[] hints = new String[] {\"One\", \"Two\"};\r\n-        String jpql = \"select c from Country c where c.name=:name\";\r\n-        em.getTransaction().begin();\r\n-        for (String hint : hints) {\r\n-            em.clear();\r\n-            Query query = em.createQuery(jpql).setParameter(\"name\", \"India\");\r\n-            query.setHint(ProductDerivation.HINT_TARGET, hint);\r\n-            india = (Country)query.getSingleResult();\r\n-            assertEquals(india.getPopulation(), 1201);\r\n-            assertTrue(SlicePersistence.isReplicated(india));\r\n-            assertTrue(SlicePersistence.getSlice(india).indexOf(\"One\") != -1);\r\n-            assertTrue(SlicePersistence.getSlice(india).indexOf(\"Two\") != -1);\r\n-        }\r\n-        em.getTransaction().rollback();\r\n-    }\r\n-    \r\n-    public void testQuerySingleObject() {\r\n-    \tPObject pc = createIndependentObject();\r\n-    \tlong pid = pc.getId();\r\n-        int value = pc.getValue();\r\n-\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        String jpql = \"select p from PObject p where p.id=:id\";\r\n-        PObject pc2 = (PObject)em.createQuery(jpql).setParameter(\"id\", pid)\r\n-        \t\t\t.getSingleResult();\r\n-        assertNotNull(pc2);\r\n-        assertNotEquals(pc, pc2);\r\n-        assertEquals(pc.getId(), pc2.getId());\r\n-        assertEquals(value, pc2.getValue());\r\n-    }\r\n-    \r\n-    public void testDynamicSlice() {\r\n-        DistributedConfiguration conf = (DistributedConfiguration)emf.getConfiguration();\r\n-        conf.setDistributionPolicyInstance(new DistributionPolicy() {\r\n-            public String distribute(Object pc, List<String> slices, Object context) {\r\n-                if (PObject.class.isInstance(pc)) {\r\n-                    PObject o = (PObject)pc;\r\n-                    if (o.getValue() > 50) {\r\n-                        DistributedBroker broker = (DistributedBroker)context;\r\n-                        Map newProps = new HashMap();\r\n-                        newProps.put(\"openjpa.slice.newslice.ConnectionURL\", \"jdbc:derby:target/database/newslice;create=true\");\r\n-                        newProps.put(\"openjpa.slice.newslice.ConnectionDriverName\", \"org.apache.derby.jdbc.EmbeddedDriver\");\r\n-                        broker.addSlice(\"newslice\", newProps);\r\n-                        return \"newslice\";\r\n-                    } else {\r\n-                        return slices.get(o.getValue()%slices.size());\r\n-                    }\r\n-                }\r\n-                return null;\r\n-            }\r\n-        \r\n-        });\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        PObject pc1 = new PObject(); pc1.setValue(25);\r\n-        PObject pc2 = new PObject(); pc2.setValue(55);\r\n-        em.persist(pc1);\r\n-        em.persist(pc2);\r\n-        em.getTransaction().commit();\r\n-        Object newId = em.getObjectId(pc2);\r\n-        em.clear();\r\n-        \r\n-        PObject newP = em.find(PObject.class, newId);\r\n-        assertNotNull(newP);\r\n-        assertEquals(\"newslice\", SlicePersistence.getSlice(newP));\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.Query;\n+\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\n+\n+/**\n+ * Tests basic create, read, update and delete operations.\n+ * \n+ * @author Pinaki Poddar \n+ *\n+ */\n+public class TestBasic extends SliceTestCase {\n+    /**\n+     * Specify persistence unit name as System property <code>-Dunit</code> or\n+     * use the default value as <code>\"slice\"</code>.\n+     */\n+    protected String getPersistenceUnitName() {\n+        return System.getProperty(\"unit\",\"slice\");\n+    }\n+\n+\n+    public void setUp() throws Exception {\n+        super.setUp(PObject.class, Person.class, Address.class, Country.class, \n+        \tCLEAR_TABLES);\n+    }\n+\n+    /**\n+     * Persist N independent objects.\n+     */\n+    List<PObject> createIndependentObjects(int N) {\n+        List<PObject> pcs = new ArrayList<PObject>();\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        for (int i = 0; i < N; i++) {\n+            PObject pc = new PObject();\n+            pcs.add(pc);\n+            em.persist(pc);\n+            pc.setValue(10+i);\n+        }\n+        em.getTransaction().commit();\n+        em.clear();\n+        return pcs;\n+    }\n+\n+    /**\n+     * Create a single object.\n+     */\n+    PObject createIndependentObject() {\n+        return createIndependentObjects(1).get(0);\n+    }\n+\n+    /**\n+     * Delete a single object by EntityManager.remove()\n+     */\n+    public void testDelete() {\n+        int N = 10;\n+        createIndependentObjects(N);\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        int before = count(PObject.class);\n+        List all = em.createQuery(\"SELECT p FROM PObject p\").getResultList();\n+        assertFalse(all.isEmpty());\n+        em.remove(all.get(0));\n+        em.getTransaction().commit();\n+\n+        int after = count(PObject.class);\n+        assertEquals(before - 1, after);\n+    }\n+\n+    /**\n+     * Delete in bulk by query.\n+     */\n+    public void testBulkDelete() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        int c = count(PObject.class);\n+        int d = em.createQuery(\"DELETE FROM PObject p\").executeUpdate();\n+        assertEquals(c, d);\n+        em.getTransaction().commit();\n+        c = count(PObject.class);\n+        assertEquals(0, c);\n+\n+    }\n+\n+    /**\n+     * Store and find the same object.\n+     */\n+    public void testFind() {\n+        PObject pc = createIndependentObject();\n+        int value = pc.getValue();\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        PObject pc2 = em.find(PObject.class, pc.getId());\n+        assertNotNull(pc2);\n+        assertNotEquals(pc, pc2);\n+        assertEquals(pc.getId(), pc2.getId());\n+        assertEquals(value, pc2.getValue());\n+    }\n+    \n+    /**\n+     * Store and find the same object via reference.\n+     */\n+    public void testReference() {\n+        PObject pc = createIndependentObject();\n+        int value = pc.getValue();\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        PObject ref = em.getReference(PObject.class, pc.getId());\n+        assertNotNull(ref);\n+        assertNotEquals(pc, ref);\n+        assertEquals(ref.getId(), pc.getId());\n+        pc.setValue(value+1);\n+        em.merge(pc);\n+        em.getTransaction().commit();\n+        em.clear();\n+        \n+        em.getTransaction().begin();\n+        PObject pc3 = em.find(PObject.class, pc.getId());\n+        assertEquals(value+1, pc3.getValue());\n+        em.getTransaction().commit();\n+        \n+    }\n+\n+\n+    public void testPersistIndependentObjects() {\n+        int before = count(PObject.class);\n+        EntityManager em = emf.createEntityManager();\n+        int N = 2;\n+        em.getTransaction().begin();\n+        for (int i = 0; i < N; i++)\n+            em.persist(new PObject());\n+        em.getTransaction().commit();\n+        em.clear();\n+        int after = count(PObject.class);\n+        assertEquals(before + N, after);\n+    }\n+\n+    public void testPersistConnectedObjectGraph() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        Person p1 = new Person(\"A\");\n+        Person p2 = new Person(\"B\");\n+        Person p3 = new Person(\"C\");\n+        Address a1 = new Address(\"Rome\", 12345);\n+        Address a2 = new Address(\"San Francisco\", 23456);\n+        Address a3 = new Address(\"New York\", 34567);\n+        Country c1 = em.find(Country.class, \"Italy\");\n+        if (c1 == null) {\n+        \tc1 = new Country();\n+        \tc1.setName(\"Italy\");\n+        \tem.persist(c1);\n+        }\n+    \ta1.setCountry(c1);\n+        p1.setAddress(a1);\n+        p2.setAddress(a2);\n+        p3.setAddress(a3);\n+\n+        em.persist(p1);\n+        em.persist(p2);\n+        em.persist(p3);\n+        em.getTransaction().commit();\n+\n+        em.clear();\n+\n+        em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        List<Person> persons =\n+                em.createQuery(\"SELECT p FROM Person p WHERE p.name=?1\")\n+                        .setParameter(1, \"A\").getResultList();\n+        List<Address> addresses =\n+                em.createQuery(\"SELECT a FROM Address a\").getResultList();\n+        for (Address pc : addresses) {\n+            assertNotNull(pc.getCity());\n+            assertNotNull(pc.getOwner().getName());\n+        }\n+        for (Person pc : persons) {\n+            assertNotNull(pc.getName());\n+            assertNotNull(pc.getAddress().getCity());\n+        }\n+        em.getTransaction().rollback();\n+    }\n+\n+    /**\n+     * Merge only works if the distribution policy assigns the correct slice\n+     * from which the instance was fetched.\n+     */\n+    public void testMerge() {\n+        PObject pc = createIndependentObjects(1).get(0);\n+        int value = pc.getValue();\n+        pc.setValue(value + 1);\n+        assertNotNull(pc);\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        PObject pc2 = em.merge(pc);\n+        em.getTransaction().commit();\n+        em.clear();\n+\n+        assertNotNull(pc2);\n+        assertNotEquals(pc, pc2);\n+        assertEquals(pc.getId(), pc2.getId());\n+        assertEquals(value + 1, pc2.getValue());\n+    }\n+    \n+    public void testPersistReplicatedObjects() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        String[] names = {\"USA\", \"India\", \"China\"};\n+        for (String name : names) {\n+        \tCountry country = new Country();\n+        \tcountry.setName(name);\n+        \tem.persist(country);\n+        }\n+        em.getTransaction().commit();\n+        assertEquals(names.length, count(Country.class));\n+        \n+        em.getTransaction().begin();\n+        Country india = em.find(Country.class, \"India\");\n+        assertNotNull(india);\n+        assertEquals(\"India\", india.getName());\n+        assertTrue(SlicePersistence.isReplicated(india));\n+        assertTrue(SlicePersistence.getSlice(india).indexOf(\"One\") != -1);\n+        assertTrue(SlicePersistence.getSlice(india).indexOf(\"Two\") != -1);\n+    }\n+    \n+    /**\n+     * Disable this test temporarily as we undergo changes in internal slice \n+     * information structure.\n+     */\n+    public void testUpdateReplicatedObjects() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        String[] names = {\"USA\", \"India\", \"China\"};\n+        long[] population = {300,1200,1400};\n+        for (int i = 0; i < names.length; i++) {\n+        \tCountry country = new Country();\n+        \tcountry.setName(names[i]);\n+        \tcountry.setPopulation(population[i]);\n+        \tem.persist(country);\n+        }\n+        em.getTransaction().commit();\n+        em.clear();\n+        \n+        assertEquals(names.length, count(Country.class));\n+        Country india = em.find(Country.class, \"India\");\n+\n+        assertNotNull(india);\n+        assertEquals(\"India\", india.getName());\n+        india.setPopulation(1201);\n+        em.getTransaction().begin();\n+        em.merge(india);\n+        em.getTransaction().commit();\n+        \n+        String[] hints = new String[] {\"One\", \"Two\"};\n+        String jpql = \"select c from Country c where c.name=:name\";\n+        em.getTransaction().begin();\n+        for (String hint : hints) {\n+            em.clear();\n+            Query query = em.createQuery(jpql).setParameter(\"name\", \"India\");\n+            query.setHint(ProductDerivation.HINT_TARGET, hint);\n+            india = (Country)query.getSingleResult();\n+            assertEquals(india.getPopulation(), 1201);\n+            assertTrue(SlicePersistence.isReplicated(india));\n+            assertTrue(SlicePersistence.getSlice(india).indexOf(\"One\") != -1);\n+            assertTrue(SlicePersistence.getSlice(india).indexOf(\"Two\") != -1);\n+        }\n+        em.getTransaction().rollback();\n+    }\n+    \n+    public void testQuerySingleObject() {\n+    \tPObject pc = createIndependentObject();\n+    \tlong pid = pc.getId();\n+        int value = pc.getValue();\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        String jpql = \"select p from PObject p where p.id=:id\";\n+        PObject pc2 = (PObject)em.createQuery(jpql).setParameter(\"id\", pid)\n+        \t\t\t.getSingleResult();\n+        assertNotNull(pc2);\n+        assertNotEquals(pc, pc2);\n+        assertEquals(pc.getId(), pc2.getId());\n+        assertEquals(value, pc2.getValue());\n+    }\n+    \n+    public void testDynamicSlice() {\n+        DistributedConfiguration conf = (DistributedConfiguration)emf.getConfiguration();\n+        conf.setDistributionPolicyInstance(new DistributionPolicy() {\n+            public String distribute(Object pc, List<String> slices, Object context) {\n+                if (PObject.class.isInstance(pc)) {\n+                    PObject o = (PObject)pc;\n+                    if (o.getValue() > 50) {\n+                        DistributedBroker broker = (DistributedBroker)context;\n+                        Map newProps = new HashMap();\n+                        newProps.put(\"openjpa.slice.newslice.ConnectionURL\", \"jdbc:derby:target/database/newslice;create=true\");\n+                        newProps.put(\"openjpa.slice.newslice.ConnectionDriverName\", \"org.apache.derby.jdbc.EmbeddedDriver\");\n+                        broker.addSlice(\"newslice\", newProps);\n+                        return \"newslice\";\n+                    } else {\n+                        return slices.get(o.getValue()%slices.size());\n+                    }\n+                }\n+                return null;\n+            }\n+        \n+        });\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        PObject pc1 = new PObject(); pc1.setValue(25);\n+        PObject pc2 = new PObject(); pc2.setValue(55);\n+        em.persist(pc1);\n+        em.persist(pc2);\n+        em.getTransaction().commit();\n+        Object newId = em.getObjectId(pc2);\n+        em.clear();\n+        \n+        PObject newP = em.find(PObject.class, newId);\n+        assertNotNull(newP);\n+        assertEquals(\"newslice\", SlicePersistence.getSlice(newP));\n+    }\n+\n+}"},{"sha":"5458efcc7b509b27a9e320fa857ae84ddfd5a8c3","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/TestConfiguration.java","status":"modified","additions":84,"deletions":84,"changes":168,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestConfiguration.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,84 +1,84 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.kernel.Broker;\r\n-import org.apache.openjpa.kernel.BrokerFactory;\r\n-import org.apache.openjpa.persistence.EntityManagerFactoryImpl;\r\n-import org.apache.openjpa.slice.jdbc.DistributedJDBCBrokerFactory;\r\n-import org.apache.openjpa.slice.jdbc.DistributedJDBCConfiguration;\r\n-\r\n-/**\r\n- * Tests user-level configuration is set on per-slice basis.\r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- */\r\n-public class TestConfiguration extends SliceTestCase {\r\n-    protected String getPersistenceUnitName() {\r\n-        return \"per-slice\";\r\n-    }\r\n-\r\n-    public void testConfig() {\r\n-        assertTrue(emf.getConfiguration() instanceof DistributedConfiguration);\r\n-        DistributedJDBCConfiguration conf =\r\n-                (DistributedJDBCConfiguration) emf.getConfiguration();\r\n-        List<String> slices = conf.getAvailableSliceNames();\r\n-        assertTrue(slices.size() > 1);\r\n-        assertTrue(slices.contains(\"One\"));\r\n-        assertTrue(slices.contains(\"Two\"));\r\n-        assertTrue(slices.contains(\"Three\"));\r\n-        BrokerFactory bf = ((EntityManagerFactoryImpl) emf).getBrokerFactory();\r\n-        Broker broker = bf.newBroker();\r\n-        assertEquals(DistributedJDBCBrokerFactory.class, bf.getClass());\r\n-        assertEquals(DistributedBrokerImpl.class, broker.getClass());\r\n-        assertNotNull(conf.getDistributionPolicyInstance());\r\n-\r\n-        emf.createEntityManager();\r\n-\r\n-        slices = conf.getActiveSliceNames();\r\n-        assertTrue(slices.size() > 1);\r\n-        assertTrue(slices.contains(\"One\"));\r\n-        assertTrue(slices.contains(\"Two\"));\r\n-        assertFalse(slices.contains(\"Three\"));\r\n-    }\r\n-    \r\n-    public void testDynamicConfiguration() {\r\n-        DistributedJDBCConfiguration conf =\r\n-            (DistributedJDBCConfiguration) emf.getConfiguration();\r\n-        List<String> slices = conf.getAvailableSliceNames();\r\n-        assertTrue(slices.contains(\"One\"));\r\n-        assertTrue(slices.contains(\"Two\"));\r\n-        assertTrue(slices.contains(\"Three\"));\r\n-        BrokerFactory bf = ((EntityManagerFactoryImpl) emf).getBrokerFactory();\r\n-        DistributedBroker broker = (DistributedBroker)bf.newBroker();\r\n-        Map newProps = new HashMap();\r\n-        newProps.put(\"openjpa.slice.newslice.ConnectionURL\", \"jdbc:derby:target/database/newslice;create=true\");\r\n-        newProps.put(\"openjpa.slice.newslice.ConnectionDriverName\", \"org.apache.derby.jdbc.EmbeddedDriver\");\r\n-        broker.addSlice(\"newslice\", newProps);\r\n-        \r\n-        assertTrue(conf.getActiveSliceNames().contains(\"newslice\"));\r\n-        \r\n-        \r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.openjpa.kernel.Broker;\n+import org.apache.openjpa.kernel.BrokerFactory;\n+import org.apache.openjpa.persistence.EntityManagerFactoryImpl;\n+import org.apache.openjpa.slice.jdbc.DistributedJDBCBrokerFactory;\n+import org.apache.openjpa.slice.jdbc.DistributedJDBCConfiguration;\n+\n+/**\n+ * Tests user-level configuration is set on per-slice basis.\n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+public class TestConfiguration extends SliceTestCase {\n+    protected String getPersistenceUnitName() {\n+        return \"per-slice\";\n+    }\n+\n+    public void testConfig() {\n+        assertTrue(emf.getConfiguration() instanceof DistributedConfiguration);\n+        DistributedJDBCConfiguration conf =\n+                (DistributedJDBCConfiguration) emf.getConfiguration();\n+        List<String> slices = conf.getAvailableSliceNames();\n+        assertTrue(slices.size() > 1);\n+        assertTrue(slices.contains(\"One\"));\n+        assertTrue(slices.contains(\"Two\"));\n+        assertTrue(slices.contains(\"Three\"));\n+        BrokerFactory bf = ((EntityManagerFactoryImpl) emf).getBrokerFactory();\n+        Broker broker = bf.newBroker();\n+        assertEquals(DistributedJDBCBrokerFactory.class, bf.getClass());\n+        assertEquals(DistributedBrokerImpl.class, broker.getClass());\n+        assertNotNull(conf.getDistributionPolicyInstance());\n+\n+        emf.createEntityManager();\n+\n+        slices = conf.getActiveSliceNames();\n+        assertTrue(slices.size() > 1);\n+        assertTrue(slices.contains(\"One\"));\n+        assertTrue(slices.contains(\"Two\"));\n+        assertFalse(slices.contains(\"Three\"));\n+    }\n+    \n+    public void testDynamicConfiguration() {\n+        DistributedJDBCConfiguration conf =\n+            (DistributedJDBCConfiguration) emf.getConfiguration();\n+        List<String> slices = conf.getAvailableSliceNames();\n+        assertTrue(slices.contains(\"One\"));\n+        assertTrue(slices.contains(\"Two\"));\n+        assertTrue(slices.contains(\"Three\"));\n+        BrokerFactory bf = ((EntityManagerFactoryImpl) emf).getBrokerFactory();\n+        DistributedBroker broker = (DistributedBroker)bf.newBroker();\n+        Map newProps = new HashMap();\n+        newProps.put(\"openjpa.slice.newslice.ConnectionURL\", \"jdbc:derby:target/database/newslice;create=true\");\n+        newProps.put(\"openjpa.slice.newslice.ConnectionDriverName\", \"org.apache.derby.jdbc.EmbeddedDriver\");\n+        broker.addSlice(\"newslice\", newProps);\n+        \n+        assertTrue(conf.getActiveSliceNames().contains(\"newslice\"));\n+        \n+        \n+    }\n+}"},{"sha":"e7695c68c2808a87796a608bc0845bdbf2aec84e","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQuery.java","status":"modified","additions":233,"deletions":233,"changes":466,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQuery.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQuery.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,233 +1,233 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.List;\r\n-\r\n-import javax.persistence.EntityManager;\r\n-import javax.persistence.Query;\r\n-\r\n-/**\r\n- * Tests query ordering.\r\n- * \r\n- * @author Pinaki Poddar \r\n- *\r\n- */\r\n-public class TestQuery extends SliceTestCase {\r\n-\r\n-    private int POBJECT_COUNT = 25;\r\n-    private int VALUE_MIN = 100;\r\n-    private int VALUE_MAX = VALUE_MIN + POBJECT_COUNT - 1;\r\n-    \r\n-    protected String getPersistenceUnitName() {\r\n-        return \"ordering\";\r\n-    }\r\n-\r\n-    public void setUp() throws Exception {\r\n-        super.setUp(PObject.class, Person.class, Address.class, Country.class, \r\n-        \t\tCLEAR_TABLES);\r\n-        int count = count(PObject.class);\r\n-        if (count == 0) {\r\n-            create(POBJECT_COUNT);\r\n-        }\r\n-    }\r\n-    \r\n-    void create(int N) {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        for (int i=0;i<POBJECT_COUNT;i++) {\r\n-            PObject pc = new PObject();\r\n-            pc.setValue(VALUE_MIN + i);\r\n-            em.persist(pc);\r\n-            String slice = SlicePersistence.getSlice(pc);\r\n-            String expected = (pc.getValue()%2 == 0) ? \"Even\" : \"Odd\";\r\n-            assertEquals(expected, slice);\r\n-        }\r\n-        Person p1 = new Person();\r\n-        Person p2 = new Person();\r\n-        Address a1 = new Address();\r\n-        Address a2 = new Address();\r\n-        p1.setName(\"Even\");\r\n-        p2.setName(\"Odd\");\r\n-        a1.setCity(\"San Francisco\");\r\n-        a2.setCity(\"Rome\");\r\n-        p1.setAddress(a1);\r\n-        p2.setAddress(a2);\r\n-        em.persist(p1);\r\n-        em.persist(p2);\r\n-        assertEquals(\"Even\", SlicePersistence.getSlice(p1));\r\n-        assertEquals(\"Odd\", SlicePersistence.getSlice(p2));\r\n-        \r\n-        em.getTransaction().commit();\r\n-    }\r\n-    \r\n-    public void testOrderedQueryResultWhenOrderableItemSelected() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        Query query = em.createQuery(\"SELECT p.value,p FROM PObject p ORDER BY p.value ASC\");\r\n-        List result = query.getResultList();\r\n-        assertValidResult(result);\r\n-        Integer old = Integer.MIN_VALUE;\r\n-        for (Object row : result) {\r\n-            Object[] line = (Object[])row;\r\n-            int value = ((Integer)line[0]).intValue();\r\n-            PObject pc = (PObject)line[1];\r\n-            assertTrue(value >= old);\r\n-            old = value;\r\n-            assertEquals(value, pc.getValue());\r\n-        }\r\n-        em.getTransaction().rollback();\r\n-    }\r\n-    \r\n-    public void testOrderedQueryResultWhenOrderableItemNotSelected() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        Query query = em.createQuery(\"SELECT p FROM PObject p ORDER BY p.value ASC\");\r\n-        List<PObject> result = query.getResultList();\r\n-        assertValidResult(result);\r\n-        Integer old = Integer.MIN_VALUE;\r\n-        for (PObject pc : result) {\r\n-            int value = pc.getValue();\r\n-            assertTrue(value >= old);\r\n-            old = value;\r\n-        }\r\n-        em.getTransaction().rollback();\r\n-    }\r\n-    \r\n-    public void testOrderedQueryResultWhenNavigatedOrderableItemNotSelected() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        Query query = em.createQuery(\"SELECT p FROM Person p JOIN p.address a ORDER BY a.zip ASC, a.city DESC\");\r\n-        List<Person> result = query.getResultList();\r\n-        assertValidResult(result);\r\n-        Integer oldZip = Integer.MIN_VALUE;\r\n-        String oldCity = null;\r\n-        for (Person pc : result) {\r\n-            int zip = pc.getAddress().getZip();\r\n-            String city = pc.getAddress().getCity();\r\n-            assertTrue(zip >= oldZip);\r\n-            assertTrue(oldCity == null || oldCity.compareTo(city) >= 0);\r\n-            oldZip = zip;\r\n-            oldCity = city;\r\n-        }\r\n-        em.getTransaction().rollback();\r\n-    }\r\n-    \r\n-    public void testAggregateQuery() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        Object count = em.createQuery(\"SELECT COUNT(p) FROM PObject p\").getSingleResult();\r\n-        Object max   = em.createQuery(\"SELECT MAX(p.value) FROM PObject p\").getSingleResult();\r\n-        Object min   = em.createQuery(\"SELECT MIN(p.value) FROM PObject p\").getSingleResult();\r\n-        Object sum   = em.createQuery(\"SELECT SUM(p.value) FROM PObject p\").getSingleResult();\r\n-        Object minmax   = em.createQuery(\"SELECT MIN(p.value),MAX(p.value) FROM PObject p\").getSingleResult();\r\n-        Object min1 = ((Object[])minmax)[0];\r\n-        Object max1 = ((Object[])minmax)[1];\r\n-        em.getTransaction().rollback();\r\n-        \r\n-        assertEquals(POBJECT_COUNT, ((Number)count).intValue());\r\n-        assertEquals(VALUE_MAX, ((Number)max).intValue());\r\n-        assertEquals(VALUE_MIN, ((Number)min).intValue());\r\n-        assertEquals((VALUE_MIN+VALUE_MAX)*POBJECT_COUNT, 2*((Number)sum).intValue());\r\n-        assertEquals(min, min1);\r\n-        assertEquals(max, max1);\r\n-    }\r\n-    \r\n-    public void testAggregateQueryWithMissingValueFromSlice() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        Object max   = em.createQuery(\"SELECT MAX(p.value) FROM PObject p WHERE MOD(p.value,2)=0\").getSingleResult();\r\n-        em.getTransaction().rollback();\r\n-        \r\n-        assertEquals(VALUE_MAX, ((Number)max).intValue());\r\n-    }\r\n-\r\n-    public void testSetMaxResult() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        int limit = 3;\r\n-        em.getTransaction().begin();\r\n-        List<PObject> result = em.createQuery(\"SELECT p FROM PObject p ORDER BY p.value ASC\")\r\n-            .setMaxResults(limit).getResultList();\r\n-        assertValidResult(result);\r\n-        Integer old = Integer.MIN_VALUE;\r\n-        for (PObject pc : result) {\r\n-            int value = pc.getValue();\r\n-            assertTrue(value >= old);\r\n-            old = value;\r\n-        }\r\n-        assertEquals(limit, result.size());\r\n-        em.getTransaction().rollback();\r\n-    }\r\n-    \r\n-    public void testHint() {\r\n-        List<String> targets = new ArrayList<String>();\r\n-        targets.add(\"Even\");\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        Query query = em.createQuery(\"SELECT p FROM PObject p\");\r\n-        query.setHint(ProductDerivation.HINT_TARGET, \"Even\");\r\n-        List result = query.getResultList();\r\n-        for (Object pc : result) {\r\n-            String slice = SlicePersistence.getSlice(pc);\r\n-            assertTrue(targets.contains(slice));\r\n-        }\r\n-        em.getTransaction().rollback();\r\n-    }\r\n-    \r\n-    public void testInMemoryOrderBy() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        Query query = em.createQuery(\"SELECT p FROM PObject p ORDER BY p.value\");\r\n-        List result = query.getResultList();\r\n-        em.getTransaction().rollback();\r\n-    }\r\n-    \r\n-    public void testQueryParameter() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        Query query = em.createQuery(\"SELECT p FROM PObject p WHERE p.value > :v\")\r\n-        \t.setParameter(\"v\", 200);\r\n-        List result = query.getResultList();\r\n-        em.getTransaction().rollback();\r\n-    }\r\n-    \r\n-    public void testQueryParameterEntity() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        Address a = (Address)em.createQuery(\"select a from Address a where a.city = :city\")\r\n-        \t.setParameter(\"city\", \"Rome\").getSingleResult();\r\n-        assertNotNull(a);\r\n-        assertEquals(\"Odd\", SlicePersistence.getSlice(a));\r\n-        Query query = em.createQuery(\"SELECT p FROM Person p WHERE p.address = :a\")\r\n-        \t.setParameter(\"a\", a);\r\n-        List<Person> result = query.getResultList();\r\n-        assertEquals(1, result.size());\r\n-        Person p = result.get(0);\r\n-        assertEquals(\"Odd\", SlicePersistence.getSlice(p));\r\n-        assertEquals(\"Rome\", p.getAddress().getCity());\r\n-        em.getTransaction().rollback();\r\n-    }\r\n-    \r\n-    void assertValidResult(List result) {\r\n-        assertNotNull(result);\r\n-        assertFalse(result.isEmpty());\r\n-        assertTrue(result.size() > 1);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.Query;\n+\n+/**\n+ * Tests query ordering.\n+ * \n+ * @author Pinaki Poddar \n+ *\n+ */\n+public class TestQuery extends SliceTestCase {\n+\n+    private int POBJECT_COUNT = 25;\n+    private int VALUE_MIN = 100;\n+    private int VALUE_MAX = VALUE_MIN + POBJECT_COUNT - 1;\n+    \n+    protected String getPersistenceUnitName() {\n+        return \"ordering\";\n+    }\n+\n+    public void setUp() throws Exception {\n+        super.setUp(PObject.class, Person.class, Address.class, Country.class, \n+        \t\tCLEAR_TABLES);\n+        int count = count(PObject.class);\n+        if (count == 0) {\n+            create(POBJECT_COUNT);\n+        }\n+    }\n+    \n+    void create(int N) {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        for (int i=0;i<POBJECT_COUNT;i++) {\n+            PObject pc = new PObject();\n+            pc.setValue(VALUE_MIN + i);\n+            em.persist(pc);\n+            String slice = SlicePersistence.getSlice(pc);\n+            String expected = (pc.getValue()%2 == 0) ? \"Even\" : \"Odd\";\n+            assertEquals(expected, slice);\n+        }\n+        Person p1 = new Person();\n+        Person p2 = new Person();\n+        Address a1 = new Address();\n+        Address a2 = new Address();\n+        p1.setName(\"Even\");\n+        p2.setName(\"Odd\");\n+        a1.setCity(\"San Francisco\");\n+        a2.setCity(\"Rome\");\n+        p1.setAddress(a1);\n+        p2.setAddress(a2);\n+        em.persist(p1);\n+        em.persist(p2);\n+        assertEquals(\"Even\", SlicePersistence.getSlice(p1));\n+        assertEquals(\"Odd\", SlicePersistence.getSlice(p2));\n+        \n+        em.getTransaction().commit();\n+    }\n+    \n+    public void testOrderedQueryResultWhenOrderableItemSelected() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        Query query = em.createQuery(\"SELECT p.value,p FROM PObject p ORDER BY p.value ASC\");\n+        List result = query.getResultList();\n+        assertValidResult(result);\n+        Integer old = Integer.MIN_VALUE;\n+        for (Object row : result) {\n+            Object[] line = (Object[])row;\n+            int value = ((Integer)line[0]).intValue();\n+            PObject pc = (PObject)line[1];\n+            assertTrue(value >= old);\n+            old = value;\n+            assertEquals(value, pc.getValue());\n+        }\n+        em.getTransaction().rollback();\n+    }\n+    \n+    public void testOrderedQueryResultWhenOrderableItemNotSelected() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        Query query = em.createQuery(\"SELECT p FROM PObject p ORDER BY p.value ASC\");\n+        List<PObject> result = query.getResultList();\n+        assertValidResult(result);\n+        Integer old = Integer.MIN_VALUE;\n+        for (PObject pc : result) {\n+            int value = pc.getValue();\n+            assertTrue(value >= old);\n+            old = value;\n+        }\n+        em.getTransaction().rollback();\n+    }\n+    \n+    public void testOrderedQueryResultWhenNavigatedOrderableItemNotSelected() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        Query query = em.createQuery(\"SELECT p FROM Person p JOIN p.address a ORDER BY a.zip ASC, a.city DESC\");\n+        List<Person> result = query.getResultList();\n+        assertValidResult(result);\n+        Integer oldZip = Integer.MIN_VALUE;\n+        String oldCity = null;\n+        for (Person pc : result) {\n+            int zip = pc.getAddress().getZip();\n+            String city = pc.getAddress().getCity();\n+            assertTrue(zip >= oldZip);\n+            assertTrue(oldCity == null || oldCity.compareTo(city) >= 0);\n+            oldZip = zip;\n+            oldCity = city;\n+        }\n+        em.getTransaction().rollback();\n+    }\n+    \n+    public void testAggregateQuery() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        Object count = em.createQuery(\"SELECT COUNT(p) FROM PObject p\").getSingleResult();\n+        Object max   = em.createQuery(\"SELECT MAX(p.value) FROM PObject p\").getSingleResult();\n+        Object min   = em.createQuery(\"SELECT MIN(p.value) FROM PObject p\").getSingleResult();\n+        Object sum   = em.createQuery(\"SELECT SUM(p.value) FROM PObject p\").getSingleResult();\n+        Object minmax   = em.createQuery(\"SELECT MIN(p.value),MAX(p.value) FROM PObject p\").getSingleResult();\n+        Object min1 = ((Object[])minmax)[0];\n+        Object max1 = ((Object[])minmax)[1];\n+        em.getTransaction().rollback();\n+        \n+        assertEquals(POBJECT_COUNT, ((Number)count).intValue());\n+        assertEquals(VALUE_MAX, ((Number)max).intValue());\n+        assertEquals(VALUE_MIN, ((Number)min).intValue());\n+        assertEquals((VALUE_MIN+VALUE_MAX)*POBJECT_COUNT, 2*((Number)sum).intValue());\n+        assertEquals(min, min1);\n+        assertEquals(max, max1);\n+    }\n+    \n+    public void testAggregateQueryWithMissingValueFromSlice() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        Object max   = em.createQuery(\"SELECT MAX(p.value) FROM PObject p WHERE MOD(p.value,2)=0\").getSingleResult();\n+        em.getTransaction().rollback();\n+        \n+        assertEquals(VALUE_MAX, ((Number)max).intValue());\n+    }\n+\n+    public void testSetMaxResult() {\n+        EntityManager em = emf.createEntityManager();\n+        int limit = 3;\n+        em.getTransaction().begin();\n+        List<PObject> result = em.createQuery(\"SELECT p FROM PObject p ORDER BY p.value ASC\")\n+            .setMaxResults(limit).getResultList();\n+        assertValidResult(result);\n+        Integer old = Integer.MIN_VALUE;\n+        for (PObject pc : result) {\n+            int value = pc.getValue();\n+            assertTrue(value >= old);\n+            old = value;\n+        }\n+        assertEquals(limit, result.size());\n+        em.getTransaction().rollback();\n+    }\n+    \n+    public void testHint() {\n+        List<String> targets = new ArrayList<String>();\n+        targets.add(\"Even\");\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        Query query = em.createQuery(\"SELECT p FROM PObject p\");\n+        query.setHint(ProductDerivation.HINT_TARGET, \"Even\");\n+        List result = query.getResultList();\n+        for (Object pc : result) {\n+            String slice = SlicePersistence.getSlice(pc);\n+            assertTrue(targets.contains(slice));\n+        }\n+        em.getTransaction().rollback();\n+    }\n+    \n+    public void testInMemoryOrderBy() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        Query query = em.createQuery(\"SELECT p FROM PObject p ORDER BY p.value\");\n+        List result = query.getResultList();\n+        em.getTransaction().rollback();\n+    }\n+    \n+    public void testQueryParameter() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        Query query = em.createQuery(\"SELECT p FROM PObject p WHERE p.value > :v\")\n+        \t.setParameter(\"v\", 200);\n+        List result = query.getResultList();\n+        em.getTransaction().rollback();\n+    }\n+    \n+    public void testQueryParameterEntity() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        Address a = (Address)em.createQuery(\"select a from Address a where a.city = :city\")\n+        \t.setParameter(\"city\", \"Rome\").getSingleResult();\n+        assertNotNull(a);\n+        assertEquals(\"Odd\", SlicePersistence.getSlice(a));\n+        Query query = em.createQuery(\"SELECT p FROM Person p WHERE p.address = :a\")\n+        \t.setParameter(\"a\", a);\n+        List<Person> result = query.getResultList();\n+        assertEquals(1, result.size());\n+        Person p = result.get(0);\n+        assertEquals(\"Odd\", SlicePersistence.getSlice(p));\n+        assertEquals(\"Rome\", p.getAddress().getCity());\n+        em.getTransaction().rollback();\n+    }\n+    \n+    void assertValidResult(List result) {\n+        assertNotNull(result);\n+        assertFalse(result.isEmpty());\n+        assertTrue(result.size() > 1);\n+    }\n+}"},{"sha":"3cf768d8b4b94357ab10d9f4daf1cfbd706efadb","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQueryMultiThreaded.java","status":"modified","additions":321,"deletions":321,"changes":642,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQueryMultiThreaded.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQueryMultiThreaded.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQueryMultiThreaded.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,321 +1,321 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.io.PrintWriter;\r\n-import java.io.StringWriter;\r\n-import java.util.ArrayList;\r\n-import java.util.List;\r\n-import java.util.concurrent.Callable;\r\n-import java.util.concurrent.ExecutionException;\r\n-import java.util.concurrent.ExecutorService;\r\n-import java.util.concurrent.Future;\r\n-import java.util.concurrent.SynchronousQueue;\r\n-import java.util.concurrent.ThreadFactory;\r\n-import java.util.concurrent.ThreadPoolExecutor;\r\n-import java.util.concurrent.TimeUnit;\r\n-import java.util.concurrent.TimeoutException;\r\n-\r\n-import javax.persistence.EntityManager;\r\n-import javax.persistence.Query;\r\n-\r\n-/**\r\n- * Tests when multiple user threads enter the same EntityManager and executes \r\n- * query. \r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- */\r\n-public class TestQueryMultiThreaded extends SliceTestCase {\r\n-\r\n-\tprivate int POBJECT_COUNT = 25;\r\n-\tprivate int VALUE_MIN = 100;\r\n-\tprivate int VALUE_MAX = VALUE_MIN + POBJECT_COUNT - 1;\r\n-\tprivate static int THREADS = 5;\r\n-\tprivate ExecutorService group; \r\n-\tprivate Future[] futures;\r\n-\r\n-\tprotected String getPersistenceUnitName() {\r\n-\t\treturn \"ordering\";\r\n-\t}\r\n-\r\n-\tpublic void setUp() throws Exception {\r\n-\t\tsuper.setUp(PObject.class, Person.class, Address.class, Country.class,\r\n-\t\t\t\tCLEAR_TABLES, \"openjpa.Multithreaded\", \"true\");\r\n-\t\tint count = count(PObject.class);\r\n-\t\tif (count == 0) {\r\n-\t\t\tcreate(POBJECT_COUNT);\r\n-\t\t}\r\n-\t\tgroup = new ThreadPoolExecutor(THREADS, THREADS,\r\n-                60, TimeUnit.SECONDS,\r\n-                new SynchronousQueue<Runnable>(), new ThreadFactory() {\r\n-\t\t\t\t\tpublic Thread newThread(Runnable r) {\r\n-\t\t\t\t\t\treturn new Thread(r);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\t});\r\n-\t\tfutures = new Future[THREADS];\r\n-\t}\r\n-\t\r\n-\tpublic void tearDown()  throws Exception {\r\n-\t\tgroup.shutdown();\r\n-\t}\r\n-\r\n-\tvoid create(int N) {\r\n-\t\tEntityManager em = emf.createEntityManager();\r\n-\t\tem.getTransaction().begin();\r\n-\t\tfor (int i = 0; i < POBJECT_COUNT; i++) {\r\n-\t\t\tPObject pc = new PObject();\r\n-\t\t\tpc.setValue(VALUE_MIN + i);\r\n-\t\t\tem.persist(pc);\r\n-\t\t\tString slice = SlicePersistence.getSlice(pc);\r\n-\t\t\tString expected = (pc.getValue() % 2 == 0) ? \"Even\" : \"Odd\";\r\n-\t\t\tassertEquals(expected, slice);\r\n-\t\t}\r\n-\t\tPerson p1 = new Person();\r\n-\t\tPerson p2 = new Person();\r\n-\t\tAddress a1 = new Address();\r\n-\t\tAddress a2 = new Address();\r\n-\t\tp1.setName(\"Even\");\r\n-\t\tp2.setName(\"Odd\");\r\n-\t\ta1.setCity(\"San Francisco\");\r\n-\t\ta2.setCity(\"Rome\");\r\n-\t\tp1.setAddress(a1);\r\n-\t\tp2.setAddress(a2);\r\n-\t\tem.persist(p1);\r\n-\t\tem.persist(p2);\r\n-\t\tassertEquals(\"Even\", SlicePersistence.getSlice(p1));\r\n-\t\tassertEquals(\"Odd\", SlicePersistence.getSlice(p2));\r\n-\r\n-\t\tem.getTransaction().commit();\r\n-\t}\r\n-\t\r\n-\tpublic void testQueryResultIsOrderedAcrossSlice() {\r\n-\t\tfinal EntityManager em = emf.createEntityManager();\r\n-\t\tem.getTransaction().begin();\r\n-\t\tfinal Query query = em\r\n-\t\t\t.createQuery(\"SELECT p.value,p FROM PObject p ORDER BY p.value ASC\");\r\n-\t\tfor (int i = 0; i < THREADS; i++) {\r\n-\t\t\tfutures[i] = group.submit(new Callable<Object>() {\r\n-\t\t\t\tpublic Object call() {\r\n-\t\t\t\t\tList result = query.getResultList();\r\n-\t\t\t\t\tInteger old = Integer.MIN_VALUE;\r\n-\t\t\t\t\tfor (Object row : result) {\r\n-\t\t\t\t\t\tObject[] line = (Object[]) row;\r\n-\t\t\t\t\t\tint value = ((Integer) line[0]).intValue();\r\n-\t\t\t\t\t\tPObject pc = (PObject) line[1];\r\n-\t\t\t\t\t\tassertTrue(value >= old);\r\n-\t\t\t\t\t\told = value;\r\n-\t\t\t\t\t\tassertEquals(value, pc.getValue());\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\treturn null;\r\n-\t\t\t\t}\r\n-\t\t\t});\r\n-\t\t}\r\n-\t\t\r\n-\t\twaitForTermination();\r\n-\t\tem.getTransaction().rollback();\r\n-\t}\r\n-\r\n-\tpublic void testAggregateQuery() {\r\n-\t\tfinal EntityManager em = emf.createEntityManager();\r\n-\t\tem.getTransaction().begin();\r\n-\t\tfinal Query countQ = em.createQuery(\"SELECT COUNT(p) FROM PObject p\");\r\n-\t\tfinal Query maxQ = em.createQuery(\"SELECT MAX(p.value) FROM PObject p\");\r\n-\t\tfinal Query minQ = em.createQuery(\"SELECT MIN(p.value) FROM PObject p\");\r\n-\t\tfinal Query sumQ = em.createQuery(\"SELECT SUM(p.value) FROM PObject p\");\r\n-\t\tfinal Query minmaxQ = em.createQuery(\"SELECT MIN(p.value),MAX(p.value) FROM PObject p\");\r\n-\t\tfor (int i = 0; i < THREADS; i++) {\r\n-\t\t\tfutures[i] = group.submit(new Callable<Object>() {\r\n-\t\t\t\tpublic Object call() {\r\n-\t\t\t\t\tObject count = countQ.getSingleResult();\r\n-\t\t\t\t\tObject max = maxQ.getSingleResult();\r\n-\t\t\t\t\tObject min = minQ.getSingleResult();\r\n-\t\t\t\t\tObject sum = sumQ.getSingleResult();\r\n-\t\t\t\t\tObject minmax = minmaxQ.getSingleResult();\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tObject min1 = ((Object[]) minmax)[0];\r\n-\t\t\t\t\tObject max1 = ((Object[]) minmax)[1];\r\n-\r\n-\r\n-\t\t\t\t\tassertEquals(POBJECT_COUNT, ((Number) count).intValue());\r\n-\t\t\t\t\tassertEquals(VALUE_MAX, ((Number) max).intValue());\r\n-\t\t\t\t\tassertEquals(VALUE_MIN, ((Number) min).intValue());\r\n-\t\t\t\t\tassertEquals((VALUE_MIN + VALUE_MAX) * POBJECT_COUNT,\r\n-\t\t\t\t\t\t\t2 * ((Number) sum).intValue());\r\n-\t\t\t\t\tassertEquals(min, min1);\r\n-\t\t\t\t\tassertEquals(max, max1);\r\n-\t\t\t\t\treturn null;\r\n-\t\t\t\t}\r\n-\t\t\t});\r\n-\t\t}\r\n-\t\twaitForTermination();\r\n-\t\tem.getTransaction().rollback();\r\n-\t}\r\n-\r\n-\tpublic void testAggregateQueryWithMissingValueFromSlice() {\r\n-\t\tfinal EntityManager em = emf.createEntityManager();\r\n-\t\tem.getTransaction().begin();\r\n-\t\tfinal Query maxQ = em.createQuery(\"SELECT MAX(p.value) FROM PObject p WHERE MOD(p.value,2)=0\");\r\n-\t\tfor (int i = 0; i < THREADS; i++) {\r\n-\t\t\tfutures[i] = group.submit(new Callable<Object>() {\r\n-\t\t\t\tpublic Object call() {\r\n-\t\t\t\t\tObject max = maxQ.getSingleResult();\r\n-\t\t\t\t\tassertEquals(VALUE_MAX, ((Number) max).intValue());\r\n-\t\t\t\t\treturn null;\r\n-\t\t\t\t}\r\n-\t\t\t});\r\n-\t\t}\r\n-\t\twaitForTermination();\r\n-\t\tem.getTransaction().rollback();\r\n-\t}\r\n-\r\n-\tpublic void testSetMaxResult() {\r\n-\t\tfinal EntityManager em = emf.createEntityManager();\r\n-\t\tfinal int limit = 3;\r\n-\t\tem.getTransaction().begin();\r\n-\t\tfinal Query q = em.createQuery(\"SELECT p.value,p FROM PObject p ORDER BY p.value ASC\");\r\n-\t\tfor (int i = 0; i < THREADS; i++) {\r\n-\t\t\tfutures[i] = group.submit(new Callable<Object>() {\r\n-\t\t\t\tpublic Object call() {\r\n-\t\t\t\t\tList result = q.setMaxResults(limit).getResultList();\r\n-\t\t\t\t\tint i = 0;\r\n-\t\t\t\t\tfor (Object row : result) {\r\n-\t\t\t\t\t\tObject[] line = (Object[]) row;\r\n-\t\t\t\t\t\tint value = ((Integer) line[0]).intValue();\r\n-\t\t\t\t\t\tPObject pc = (PObject) line[1];\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tassertEquals(limit, result.size());\r\n-\t\t\t\t\treturn null;\r\n-\t\t\t\t}\r\n-\r\n-\t\t\t});\r\n-\t\t}\r\n-\t\twaitForTermination();\r\n-\t\tem.getTransaction().rollback();\r\n-\t}\r\n-\r\n-\tpublic void testHint() {\r\n-\t\tfinal List<String> targets = new ArrayList<String>();\r\n-\t\ttargets.add(\"Even\");\r\n-\t\tfinal EntityManager em = emf.createEntityManager();\r\n-\t\tem.getTransaction().begin();\r\n-\t\tfinal Query query = em.createQuery(\"SELECT p FROM PObject p\");\r\n-\t\tfor (int i = 0; i < THREADS; i++) {\r\n-\t\t\tfutures[i] = group.submit(new Callable<Object>() {\r\n-\r\n-\t\t\t\tpublic Object call() {\r\n-\t\t\t\t\tquery.setHint(ProductDerivation.HINT_TARGET, \"Even\");\r\n-\t\t\t\t\tList result = query.getResultList();\r\n-\t\t\t\t\tfor (Object pc : result) {\r\n-\t\t\t\t\t\tString slice = SlicePersistence.getSlice(pc);\r\n-\t\t\t\t\t\tassertTrue(targets.contains(slice));\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\treturn null;\r\n-\t\t\t\t}\r\n-\r\n-\t\t\t});\r\n-\t\t}\r\n-\t\twaitForTermination();\r\n-\t\tem.getTransaction().rollback();\r\n-\t}\r\n-\r\n-\tpublic void testInMemoryOrderBy() {\r\n-\t\tfinal EntityManager em = emf.createEntityManager();\r\n-\t\tem.getTransaction().begin();\r\n-\t\tfinal Query query = em.createQuery(\"SELECT p FROM PObject p ORDER BY p.value\");\r\n-\t\tfor (int i = 0; i < THREADS; i++) {\r\n-\t\t\tfutures[i] = group.submit(new Callable<Object>() {\r\n-\t\t\t\tpublic Object call() {\r\n-\t\t\t\t\tList result = query.getResultList();\r\n-\t\t\t\t\treturn null;\r\n-\t\t\t\t}\r\n-\t\t\t});\r\n-\t\t}\r\n-\t\twaitForTermination();\r\n-\t\tem.getTransaction().rollback();\r\n-\t}\r\n-\r\n-\tpublic void testQueryParameter() {\r\n-\t\tfinal EntityManager em = emf.createEntityManager();\r\n-\t\tem.getTransaction().begin();\r\n-\t\tfinal Query query = em.createQuery(\"SELECT p FROM PObject p WHERE p.value > :v\");\r\n-\t\tfor (int i = 0; i < THREADS; i++) {\r\n-\t\t\tfutures[i] = group.submit(new Callable<Object>() {\r\n-\t\t\t\tpublic Object call() {\r\n-\t\t\t\t\tquery.setParameter(\"v\", 200);\r\n-\t\t\t\t\tList result = query.getResultList();\r\n-\t\t\t\t\treturn null;\r\n-\t\t\t\t}\r\n-\r\n-\t\t\t});\r\n-\t\t}\r\n-\t\twaitForTermination();\r\n-\t\tem.getTransaction().rollback();\r\n-\t}\r\n-\r\n-\tpublic void testQueryParameterEntity() {\r\n-\t\tfinal EntityManager em = emf.createEntityManager();\r\n-\t\tem.getTransaction().begin();\r\n-\t\tfinal Query addressQ = em.createQuery(\"select a from Address a where a.city = :city\");\r\n-\t\t\t\t\t\t\t\t \r\n-\t\tfinal Query personQ = em.createQuery(\"SELECT p FROM Person p WHERE p.address = :a\");\r\n-\t\tfor (int i = 0; i < THREADS; i++) {\r\n-\t\t\tfutures[i] = group.submit(new Callable<Object>() {\r\n-\t\t\t\tpublic Object call() {\r\n-\t\t\t\t\tAddress a = (Address) addressQ.setParameter(\"city\", \"Rome\")\r\n-\t\t\t\t\t\t.getSingleResult();\r\n-\t\t\t\t\tassertNotNull(a);\r\n-\t\t\t\t\tassertEquals(\"Odd\", SlicePersistence.getSlice(a));\r\n-\t\t\t\t\tList<Person> result = personQ.setParameter(\"a\", a).getResultList();\r\n-\t\t\t\t\tassertEquals(1, result.size());\r\n-\t\t\t\t\tPerson p = result.get(0);\r\n-\t\t\t\t\tassertEquals(\"Odd\", SlicePersistence.getSlice(p));\r\n-\t\t\t\t\tassertEquals(\"Rome\", p.getAddress().getCity());\r\n-\t\t\t\t\treturn null;\r\n-\t\t\t\t}\r\n-\r\n-\t\t\t});\r\n-\t\t}\r\n-\t\twaitForTermination();\r\n-\t\tem.getTransaction().rollback();\r\n-\t}\r\n-\r\n-\tvoid waitForTermination() {\r\n-\t\ttry {\r\n-\t\t\tfor (Future f : futures)\r\n-\t\t\t\ttry {\r\n-\t\t\t\t\tf.get(60, TimeUnit.SECONDS);\r\n-\t\t\t\t} catch (TimeoutException te) {\r\n-\t\t\t\t    fail(\"Failed \" + te + \"\\r\\n\" + getStackDump(te));\r\n-\t\t\t\t} catch (ExecutionException e) {\r\n-\t\t\t\t\tfail(\"Failed \" + \"\\r\\n\" + getStackDump(e.getCause()));\r\n-\t\t\t\t}\r\n-\t\t} catch (InterruptedException e) {\r\n-\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\tString getStackDump(Throwable t) {\r\n-        StringWriter writer = new StringWriter();\r\n-        t.printStackTrace(new PrintWriter(writer));\r\n-        return writer.toString();\r\n-\t}\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.Query;\n+\n+/**\n+ * Tests when multiple user threads enter the same EntityManager and executes \n+ * query. \n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+public class TestQueryMultiThreaded extends SliceTestCase {\n+\n+\tprivate int POBJECT_COUNT = 25;\n+\tprivate int VALUE_MIN = 100;\n+\tprivate int VALUE_MAX = VALUE_MIN + POBJECT_COUNT - 1;\n+\tprivate static int THREADS = 5;\n+\tprivate ExecutorService group; \n+\tprivate Future[] futures;\n+\n+\tprotected String getPersistenceUnitName() {\n+\t\treturn \"ordering\";\n+\t}\n+\n+\tpublic void setUp() throws Exception {\n+\t\tsuper.setUp(PObject.class, Person.class, Address.class, Country.class,\n+\t\t\t\tCLEAR_TABLES, \"openjpa.Multithreaded\", \"true\");\n+\t\tint count = count(PObject.class);\n+\t\tif (count == 0) {\n+\t\t\tcreate(POBJECT_COUNT);\n+\t\t}\n+\t\tgroup = new ThreadPoolExecutor(THREADS, THREADS,\n+                60, TimeUnit.SECONDS,\n+                new SynchronousQueue<Runnable>(), new ThreadFactory() {\n+\t\t\t\t\tpublic Thread newThread(Runnable r) {\n+\t\t\t\t\t\treturn new Thread(r);\n+\t\t\t\t\t}\n+\t\t\t\t\n+\t\t\t\t});\n+\t\tfutures = new Future[THREADS];\n+\t}\n+\t\n+\tpublic void tearDown()  throws Exception {\n+\t\tgroup.shutdown();\n+\t}\n+\n+\tvoid create(int N) {\n+\t\tEntityManager em = emf.createEntityManager();\n+\t\tem.getTransaction().begin();\n+\t\tfor (int i = 0; i < POBJECT_COUNT; i++) {\n+\t\t\tPObject pc = new PObject();\n+\t\t\tpc.setValue(VALUE_MIN + i);\n+\t\t\tem.persist(pc);\n+\t\t\tString slice = SlicePersistence.getSlice(pc);\n+\t\t\tString expected = (pc.getValue() % 2 == 0) ? \"Even\" : \"Odd\";\n+\t\t\tassertEquals(expected, slice);\n+\t\t}\n+\t\tPerson p1 = new Person();\n+\t\tPerson p2 = new Person();\n+\t\tAddress a1 = new Address();\n+\t\tAddress a2 = new Address();\n+\t\tp1.setName(\"Even\");\n+\t\tp2.setName(\"Odd\");\n+\t\ta1.setCity(\"San Francisco\");\n+\t\ta2.setCity(\"Rome\");\n+\t\tp1.setAddress(a1);\n+\t\tp2.setAddress(a2);\n+\t\tem.persist(p1);\n+\t\tem.persist(p2);\n+\t\tassertEquals(\"Even\", SlicePersistence.getSlice(p1));\n+\t\tassertEquals(\"Odd\", SlicePersistence.getSlice(p2));\n+\n+\t\tem.getTransaction().commit();\n+\t}\n+\t\n+\tpublic void testQueryResultIsOrderedAcrossSlice() {\n+\t\tfinal EntityManager em = emf.createEntityManager();\n+\t\tem.getTransaction().begin();\n+\t\tfinal Query query = em\n+\t\t\t.createQuery(\"SELECT p.value,p FROM PObject p ORDER BY p.value ASC\");\n+\t\tfor (int i = 0; i < THREADS; i++) {\n+\t\t\tfutures[i] = group.submit(new Callable<Object>() {\n+\t\t\t\tpublic Object call() {\n+\t\t\t\t\tList result = query.getResultList();\n+\t\t\t\t\tInteger old = Integer.MIN_VALUE;\n+\t\t\t\t\tfor (Object row : result) {\n+\t\t\t\t\t\tObject[] line = (Object[]) row;\n+\t\t\t\t\t\tint value = ((Integer) line[0]).intValue();\n+\t\t\t\t\t\tPObject pc = (PObject) line[1];\n+\t\t\t\t\t\tassertTrue(value >= old);\n+\t\t\t\t\t\told = value;\n+\t\t\t\t\t\tassertEquals(value, pc.getValue());\n+\t\t\t\t\t}\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\t\n+\t\twaitForTermination();\n+\t\tem.getTransaction().rollback();\n+\t}\n+\n+\tpublic void testAggregateQuery() {\n+\t\tfinal EntityManager em = emf.createEntityManager();\n+\t\tem.getTransaction().begin();\n+\t\tfinal Query countQ = em.createQuery(\"SELECT COUNT(p) FROM PObject p\");\n+\t\tfinal Query maxQ = em.createQuery(\"SELECT MAX(p.value) FROM PObject p\");\n+\t\tfinal Query minQ = em.createQuery(\"SELECT MIN(p.value) FROM PObject p\");\n+\t\tfinal Query sumQ = em.createQuery(\"SELECT SUM(p.value) FROM PObject p\");\n+\t\tfinal Query minmaxQ = em.createQuery(\"SELECT MIN(p.value),MAX(p.value) FROM PObject p\");\n+\t\tfor (int i = 0; i < THREADS; i++) {\n+\t\t\tfutures[i] = group.submit(new Callable<Object>() {\n+\t\t\t\tpublic Object call() {\n+\t\t\t\t\tObject count = countQ.getSingleResult();\n+\t\t\t\t\tObject max = maxQ.getSingleResult();\n+\t\t\t\t\tObject min = minQ.getSingleResult();\n+\t\t\t\t\tObject sum = sumQ.getSingleResult();\n+\t\t\t\t\tObject minmax = minmaxQ.getSingleResult();\n+\t\t\t\t\t\n+\t\t\t\t\tObject min1 = ((Object[]) minmax)[0];\n+\t\t\t\t\tObject max1 = ((Object[]) minmax)[1];\n+\n+\n+\t\t\t\t\tassertEquals(POBJECT_COUNT, ((Number) count).intValue());\n+\t\t\t\t\tassertEquals(VALUE_MAX, ((Number) max).intValue());\n+\t\t\t\t\tassertEquals(VALUE_MIN, ((Number) min).intValue());\n+\t\t\t\t\tassertEquals((VALUE_MIN + VALUE_MAX) * POBJECT_COUNT,\n+\t\t\t\t\t\t\t2 * ((Number) sum).intValue());\n+\t\t\t\t\tassertEquals(min, min1);\n+\t\t\t\t\tassertEquals(max, max1);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\twaitForTermination();\n+\t\tem.getTransaction().rollback();\n+\t}\n+\n+\tpublic void testAggregateQueryWithMissingValueFromSlice() {\n+\t\tfinal EntityManager em = emf.createEntityManager();\n+\t\tem.getTransaction().begin();\n+\t\tfinal Query maxQ = em.createQuery(\"SELECT MAX(p.value) FROM PObject p WHERE MOD(p.value,2)=0\");\n+\t\tfor (int i = 0; i < THREADS; i++) {\n+\t\t\tfutures[i] = group.submit(new Callable<Object>() {\n+\t\t\t\tpublic Object call() {\n+\t\t\t\t\tObject max = maxQ.getSingleResult();\n+\t\t\t\t\tassertEquals(VALUE_MAX, ((Number) max).intValue());\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\twaitForTermination();\n+\t\tem.getTransaction().rollback();\n+\t}\n+\n+\tpublic void testSetMaxResult() {\n+\t\tfinal EntityManager em = emf.createEntityManager();\n+\t\tfinal int limit = 3;\n+\t\tem.getTransaction().begin();\n+\t\tfinal Query q = em.createQuery(\"SELECT p.value,p FROM PObject p ORDER BY p.value ASC\");\n+\t\tfor (int i = 0; i < THREADS; i++) {\n+\t\t\tfutures[i] = group.submit(new Callable<Object>() {\n+\t\t\t\tpublic Object call() {\n+\t\t\t\t\tList result = q.setMaxResults(limit).getResultList();\n+\t\t\t\t\tint i = 0;\n+\t\t\t\t\tfor (Object row : result) {\n+\t\t\t\t\t\tObject[] line = (Object[]) row;\n+\t\t\t\t\t\tint value = ((Integer) line[0]).intValue();\n+\t\t\t\t\t\tPObject pc = (PObject) line[1];\n+\t\t\t\t\t}\n+\t\t\t\t\tassertEquals(limit, result.size());\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t});\n+\t\t}\n+\t\twaitForTermination();\n+\t\tem.getTransaction().rollback();\n+\t}\n+\n+\tpublic void testHint() {\n+\t\tfinal List<String> targets = new ArrayList<String>();\n+\t\ttargets.add(\"Even\");\n+\t\tfinal EntityManager em = emf.createEntityManager();\n+\t\tem.getTransaction().begin();\n+\t\tfinal Query query = em.createQuery(\"SELECT p FROM PObject p\");\n+\t\tfor (int i = 0; i < THREADS; i++) {\n+\t\t\tfutures[i] = group.submit(new Callable<Object>() {\n+\n+\t\t\t\tpublic Object call() {\n+\t\t\t\t\tquery.setHint(ProductDerivation.HINT_TARGET, \"Even\");\n+\t\t\t\t\tList result = query.getResultList();\n+\t\t\t\t\tfor (Object pc : result) {\n+\t\t\t\t\t\tString slice = SlicePersistence.getSlice(pc);\n+\t\t\t\t\t\tassertTrue(targets.contains(slice));\n+\t\t\t\t\t}\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t});\n+\t\t}\n+\t\twaitForTermination();\n+\t\tem.getTransaction().rollback();\n+\t}\n+\n+\tpublic void testInMemoryOrderBy() {\n+\t\tfinal EntityManager em = emf.createEntityManager();\n+\t\tem.getTransaction().begin();\n+\t\tfinal Query query = em.createQuery(\"SELECT p FROM PObject p ORDER BY p.value\");\n+\t\tfor (int i = 0; i < THREADS; i++) {\n+\t\t\tfutures[i] = group.submit(new Callable<Object>() {\n+\t\t\t\tpublic Object call() {\n+\t\t\t\t\tList result = query.getResultList();\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\twaitForTermination();\n+\t\tem.getTransaction().rollback();\n+\t}\n+\n+\tpublic void testQueryParameter() {\n+\t\tfinal EntityManager em = emf.createEntityManager();\n+\t\tem.getTransaction().begin();\n+\t\tfinal Query query = em.createQuery(\"SELECT p FROM PObject p WHERE p.value > :v\");\n+\t\tfor (int i = 0; i < THREADS; i++) {\n+\t\t\tfutures[i] = group.submit(new Callable<Object>() {\n+\t\t\t\tpublic Object call() {\n+\t\t\t\t\tquery.setParameter(\"v\", 200);\n+\t\t\t\t\tList result = query.getResultList();\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t});\n+\t\t}\n+\t\twaitForTermination();\n+\t\tem.getTransaction().rollback();\n+\t}\n+\n+\tpublic void testQueryParameterEntity() {\n+\t\tfinal EntityManager em = emf.createEntityManager();\n+\t\tem.getTransaction().begin();\n+\t\tfinal Query addressQ = em.createQuery(\"select a from Address a where a.city = :city\");\n+\t\t\t\t\t\t\t\t \n+\t\tfinal Query personQ = em.createQuery(\"SELECT p FROM Person p WHERE p.address = :a\");\n+\t\tfor (int i = 0; i < THREADS; i++) {\n+\t\t\tfutures[i] = group.submit(new Callable<Object>() {\n+\t\t\t\tpublic Object call() {\n+\t\t\t\t\tAddress a = (Address) addressQ.setParameter(\"city\", \"Rome\")\n+\t\t\t\t\t\t.getSingleResult();\n+\t\t\t\t\tassertNotNull(a);\n+\t\t\t\t\tassertEquals(\"Odd\", SlicePersistence.getSlice(a));\n+\t\t\t\t\tList<Person> result = personQ.setParameter(\"a\", a).getResultList();\n+\t\t\t\t\tassertEquals(1, result.size());\n+\t\t\t\t\tPerson p = result.get(0);\n+\t\t\t\t\tassertEquals(\"Odd\", SlicePersistence.getSlice(p));\n+\t\t\t\t\tassertEquals(\"Rome\", p.getAddress().getCity());\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t});\n+\t\t}\n+\t\twaitForTermination();\n+\t\tem.getTransaction().rollback();\n+\t}\n+\n+\tvoid waitForTermination() {\n+\t\ttry {\n+\t\t\tfor (Future f : futures)\n+\t\t\t\ttry {\n+\t\t\t\t\tf.get(60, TimeUnit.SECONDS);\n+\t\t\t\t} catch (TimeoutException te) {\n+\t\t\t\t    fail(\"Failed \" + te + \"\\r\\n\" + getStackDump(te));\n+\t\t\t\t} catch (ExecutionException e) {\n+\t\t\t\t\tfail(\"Failed \" + \"\\r\\n\" + getStackDump(e.getCause()));\n+\t\t\t\t}\n+\t\t} catch (InterruptedException e) {\n+\n+\t\t}\n+\t}\n+\t\n+\tString getStackDump(Throwable t) {\n+        StringWriter writer = new StringWriter();\n+        t.printStackTrace(new PrintWriter(writer));\n+        return writer.toString();\n+\t}\n+\n+}"},{"sha":"1f9ed4fe03c4b89b9d6cb464158cc34d0b468cc1","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/TestReplication.java","status":"modified","additions":118,"deletions":118,"changes":236,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestReplication.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestReplication.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestReplication.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,118 +1,118 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import java.util.Set;\r\n-\r\n-import javax.persistence.EntityManager;\r\n-\r\n-/**\r\n- * Tests that parent-child relation both @Repliated are stored in all replicated\r\n- * slices.\r\n- * \r\n- * <A HREF=\"https://issues.apache.org/jira/browse/OPENJPA-981\">OPENJPA-981</A>\r\n- * \r\n- * @author Pinaki Poddar\r\n- *\r\n- */\r\n-public class TestReplication extends SingleEMFTestCase {\r\n-    private static int CHILD_COUNT = 3;\r\n-\r\n-    public void setUp() {\r\n-        super.setUp(CLEAR_TABLES);\r\n-        createData();\r\n-    }\r\n-\r\n-    protected String getPersistenceUnitName() {\r\n-        return \"replication\";\r\n-    }\r\n-    \r\n-    void createData() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        ReplicatedParent parent = new ReplicatedParent();\r\n-        parent.setName(\"parent\");\r\n-        for (int i = 0; i < CHILD_COUNT; i++) {\r\n-            ReplicatedChild child = new ReplicatedChild();\r\n-            child.setName(\"child-\" + i);\r\n-            parent.addChild(child);\r\n-        }\r\n-        em.persist(parent);\r\n-        em.getTransaction().commit();\r\n-        em.clear();\r\n-    }\r\n-    \r\n-    public void testPersistInReplicatedSlices() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-\r\n-        String jpql = \"select p from ReplicatedParent p where p.name=:name\";\r\n-        ReplicatedParent pOne = (ReplicatedParent) em.createQuery(jpql)\r\n-            .setParameter(\"name\", \"parent\")\r\n-            .setHint(SlicePersistence.HINT_TARGET, \"One\")\r\n-            .getSingleResult();\r\n-        assertNotNull(pOne);\r\n-\r\n-        assertEquals(\"[One, Two]\", SlicePersistence.getSlice(pOne));\r\n-\r\n-        ReplicatedParent pTwo = (ReplicatedParent) em.createQuery(jpql)\r\n-            .setParameter(\"name\", \"parent\")\r\n-            .setHint(SlicePersistence.HINT_TARGET, \"Two\")\r\n-            .getSingleResult();\r\n-        assertNotNull(pTwo);\r\n-        assertEquals(\"[One, Two]\", SlicePersistence.getSlice(pTwo));\r\n-\r\n-        jpql = \"select p from ReplicatedChild p where p.name=:name\";\r\n-        ReplicatedChild cOne = (ReplicatedChild) em.createQuery(jpql)\r\n-            .setParameter(\"name\", \"child-0\")\r\n-            .setHint(SlicePersistence.HINT_TARGET, \"One\")\r\n-            .getSingleResult();\r\n-        assertNotNull(cOne);\r\n-        ReplicatedChild cTwo = (ReplicatedChild) em.createQuery(jpql)\r\n-            .setParameter(\"name\", \"child-0\")\r\n-            .setHint(SlicePersistence.HINT_TARGET, \"Two\")\r\n-            .getSingleResult();\r\n-        assertNotNull(cTwo);\r\n-    }\r\n-    \r\n-    public void testQuery() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        String jpql = \"select p from ReplicatedParent p where p.name=:name\";\r\n-        ReplicatedParent parent = (ReplicatedParent) em.createQuery(jpql)\r\n-            .setParameter(\"name\", \"parent\")\r\n-            .setHint(SlicePersistence.HINT_TARGET, \"One\")\r\n-            .getSingleResult();\r\n-        assertNotNull(parent);\r\n-        Set<ReplicatedChild> children = parent.getChildren();\r\n-        assertNotNull(children);\r\n-        assertEquals(CHILD_COUNT, children.size());\r\n-    }\r\n-    \r\n-    public void testAggregateQuery() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        String jpql = \"select count(p) from ReplicatedParent p\";\r\n-        long pCount = (Long) em.createQuery(jpql).getSingleResult();\r\n-        assertEquals(1, pCount);\r\n-        \r\n-        jpql = \"select count(p) from ReplicatedChild p\";\r\n-        long cCount = (Long) em.createQuery(jpql).getSingleResult();\r\n-        assertEquals(CHILD_COUNT, cCount);\r\n-    }\r\n-    \r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import java.util.Set;\n+\n+import javax.persistence.EntityManager;\n+\n+/**\n+ * Tests that parent-child relation both @Repliated are stored in all replicated\n+ * slices.\n+ * \n+ * <A HREF=\"https://issues.apache.org/jira/browse/OPENJPA-981\">OPENJPA-981</A>\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public class TestReplication extends SingleEMFTestCase {\n+    private static int CHILD_COUNT = 3;\n+\n+    public void setUp() {\n+        super.setUp(CLEAR_TABLES);\n+        createData();\n+    }\n+\n+    protected String getPersistenceUnitName() {\n+        return \"replication\";\n+    }\n+    \n+    void createData() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ReplicatedParent parent = new ReplicatedParent();\n+        parent.setName(\"parent\");\n+        for (int i = 0; i < CHILD_COUNT; i++) {\n+            ReplicatedChild child = new ReplicatedChild();\n+            child.setName(\"child-\" + i);\n+            parent.addChild(child);\n+        }\n+        em.persist(parent);\n+        em.getTransaction().commit();\n+        em.clear();\n+    }\n+    \n+    public void testPersistInReplicatedSlices() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+\n+        String jpql = \"select p from ReplicatedParent p where p.name=:name\";\n+        ReplicatedParent pOne = (ReplicatedParent) em.createQuery(jpql)\n+            .setParameter(\"name\", \"parent\")\n+            .setHint(SlicePersistence.HINT_TARGET, \"One\")\n+            .getSingleResult();\n+        assertNotNull(pOne);\n+\n+        assertEquals(\"[One, Two]\", SlicePersistence.getSlice(pOne));\n+\n+        ReplicatedParent pTwo = (ReplicatedParent) em.createQuery(jpql)\n+            .setParameter(\"name\", \"parent\")\n+            .setHint(SlicePersistence.HINT_TARGET, \"Two\")\n+            .getSingleResult();\n+        assertNotNull(pTwo);\n+        assertEquals(\"[One, Two]\", SlicePersistence.getSlice(pTwo));\n+\n+        jpql = \"select p from ReplicatedChild p where p.name=:name\";\n+        ReplicatedChild cOne = (ReplicatedChild) em.createQuery(jpql)\n+            .setParameter(\"name\", \"child-0\")\n+            .setHint(SlicePersistence.HINT_TARGET, \"One\")\n+            .getSingleResult();\n+        assertNotNull(cOne);\n+        ReplicatedChild cTwo = (ReplicatedChild) em.createQuery(jpql)\n+            .setParameter(\"name\", \"child-0\")\n+            .setHint(SlicePersistence.HINT_TARGET, \"Two\")\n+            .getSingleResult();\n+        assertNotNull(cTwo);\n+    }\n+    \n+    public void testQuery() {\n+        EntityManager em = emf.createEntityManager();\n+        String jpql = \"select p from ReplicatedParent p where p.name=:name\";\n+        ReplicatedParent parent = (ReplicatedParent) em.createQuery(jpql)\n+            .setParameter(\"name\", \"parent\")\n+            .setHint(SlicePersistence.HINT_TARGET, \"One\")\n+            .getSingleResult();\n+        assertNotNull(parent);\n+        Set<ReplicatedChild> children = parent.getChildren();\n+        assertNotNull(children);\n+        assertEquals(CHILD_COUNT, children.size());\n+    }\n+    \n+    public void testAggregateQuery() {\n+        EntityManager em = emf.createEntityManager();\n+        String jpql = \"select count(p) from ReplicatedParent p\";\n+        long pCount = (Long) em.createQuery(jpql).getSingleResult();\n+        assertEquals(1, pCount);\n+        \n+        jpql = \"select count(p) from ReplicatedChild p\";\n+        long cCount = (Long) em.createQuery(jpql).getSingleResult();\n+        assertEquals(CHILD_COUNT, cCount);\n+    }\n+    \n+}"},{"sha":"8b047b61cdb532f5303276b2587ffb06ae5afa68","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/TestXA.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestXA.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestXA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestXA.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,56 +1,56 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice;\r\n-\r\n-import javax.persistence.*;\r\n-\r\n-public class TestXA extends SliceTestCase {\r\n-    public void setUp() throws Exception {\r\n-        super.setUp(PObject.class, Person.class, Address.class, CLEAR_TABLES);\r\n-    }\r\n-    public void testEmptyCommit() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        em.getTransaction().commit();\r\n-    }\r\n-    public void testEmptyRollback() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        em.getTransaction().rollback();\r\n-    }\r\n-    \r\n-\tpublic void testPersistIndependentObjects() {\r\n-\t\tEntityManager em = emf.createEntityManager();\r\n-        int before = count(PObject.class);\r\n-\t\tint N = 2;\r\n-\t\tem.getTransaction().begin();\r\n-\t\tfor (int i=0; i<N; i++)\r\n-\t\t\tem.persist(new PObject());\r\n-\t\tem.getTransaction().commit();\r\n-\t\tem.clear();\r\n-\t\tint after = count(PObject.class);\r\n-\t\tassertEquals(before+N, after);\r\n-\t}\r\n-\t\r\n-    protected String getPersistenceUnitName() {\r\n-        return \"XA\";\r\n-    }\r\n-    \r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice;\n+\n+import javax.persistence.*;\n+\n+public class TestXA extends SliceTestCase {\n+    public void setUp() throws Exception {\n+        super.setUp(PObject.class, Person.class, Address.class, CLEAR_TABLES);\n+    }\n+    public void testEmptyCommit() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        em.getTransaction().commit();\n+    }\n+    public void testEmptyRollback() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        em.getTransaction().rollback();\n+    }\n+    \n+\tpublic void testPersistIndependentObjects() {\n+\t\tEntityManager em = emf.createEntityManager();\n+        int before = count(PObject.class);\n+\t\tint N = 2;\n+\t\tem.getTransaction().begin();\n+\t\tfor (int i=0; i<N; i++)\n+\t\t\tem.persist(new PObject());\n+\t\tem.getTransaction().commit();\n+\t\tem.clear();\n+\t\tint after = count(PObject.class);\n+\t\tassertEquals(before+N, after);\n+\t}\n+\t\n+    protected String getPersistenceUnitName() {\n+        return \"XA\";\n+    }\n+    \n+\n+}"},{"sha":"2cbc74b3eb9bc43cf088172f1ad1acd2c86efc05","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/policy/EvenOddDistributionPolicy.java","status":"modified","additions":41,"deletions":41,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/policy/EvenOddDistributionPolicy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/policy/EvenOddDistributionPolicy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/policy/EvenOddDistributionPolicy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,41 +1,41 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.policy;\r\n-\r\n-import java.util.List;\r\n-\r\n-import org.apache.openjpa.slice.DistributionPolicy;\r\n-\r\n-import org.apache.openjpa.slice.*;\r\n-\r\n-public class EvenOddDistributionPolicy implements DistributionPolicy {\r\n-    public String distribute(Object pc, List<String> slices, Object context) {\r\n-        if (pc instanceof PObject) {\r\n-            int v = ((PObject)pc).getValue();\r\n-            return (v%2 == 0) ? \"Even\" : \"Odd\";\r\n-        }\r\n-        if (pc instanceof Person) {\r\n-        \tString name = ((Person)pc).getName();\r\n-        \tchar firstChar = Character.toLowerCase(name.charAt(0));\r\n-        \treturn (firstChar >= 'a' && firstChar <='m') ? \"Even\" : \"Odd\";\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.policy;\n+\n+import java.util.List;\n+\n+import org.apache.openjpa.slice.DistributionPolicy;\n+\n+import org.apache.openjpa.slice.*;\n+\n+public class EvenOddDistributionPolicy implements DistributionPolicy {\n+    public String distribute(Object pc, List<String> slices, Object context) {\n+        if (pc instanceof PObject) {\n+            int v = ((PObject)pc).getValue();\n+            return (v%2 == 0) ? \"Even\" : \"Odd\";\n+        }\n+        if (pc instanceof Person) {\n+        \tString name = ((Person)pc).getName();\n+        \tchar firstChar = Character.toLowerCase(name.charAt(0));\n+        \treturn (firstChar >= 'a' && firstChar <='m') ? \"Even\" : \"Odd\";\n+        }\n+        return null;\n+    }\n+\n+}"},{"sha":"fe7a54ed26a6663d3d9b6ccf5d3ed9394b7c2950","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/policy/UserDistributionPolicy.java","status":"modified","additions":78,"deletions":78,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/policy/UserDistributionPolicy.java","raw_url":"https://github.com/apache/openjpa/raw/90b84c5d73db4d0d7fa3e5520358912961b59c43/openjpa-slice/src/test/java/org/apache/openjpa/slice/policy/UserDistributionPolicy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/policy/UserDistributionPolicy.java?ref=90b84c5d73db4d0d7fa3e5520358912961b59c43","patch":"@@ -1,78 +1,78 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.policy;\r\n-\r\n-import java.util.List;\r\n-\r\n-import org.apache.openjpa.slice.DistributionPolicy;\r\n-\r\n-import org.apache.openjpa.slice.PObject;\r\n-import org.apache.openjpa.slice.Person;\r\n-\r\n-\r\n-/**\r\n- * Exemplar {@link DistributionPolicy} that maintains closure and distributes\r\n- * based on attributes of the given instance. \r\n- * \r\n- * @author Pinaki Poddar \r\n- *\r\n- */\r\n-public class UserDistributionPolicy implements DistributionPolicy {\r\n-\r\n-\t/**\r\n-\t * Distribute the given instance.\r\n-\t * Assumes that two configured slices are named as <em>One</em> and \r\n-\t * <em>Two</em>.<br>\r\n-\t * The policy is only implemented for PObject and Person i.e. two of three \r\n-\t * known classes. No policy is implemented for Address because Address is\r\n-\t * persisted always by cascade and hence Slice should assign automatically\r\n-\t * the same slice as its owner Person. \r\n-\t * \r\n-\t */\r\n-\tpublic String distribute(Object pc, List<String> slices, Object context) {\r\n-\t\tassertValidSlices(slices);\r\n-\t\tif (pc instanceof PObject)\r\n-\t\t\treturn distribute((PObject)pc);\r\n-\t\tif (pc instanceof Person) {\r\n-\t\t\treturn distribute((Person)pc);\r\n-\t\t}\r\n-\t\tthrow new RuntimeException(\"No policy for \" + pc.getClass());\r\n-\t}\r\n-\t\r\n-\tvoid assertValidSlices(List<String> slices) {\r\n-\t\tif (slices.contains(\"One\") && slices.contains(\"Two\"))\r\n-\t\t\treturn;\r\n-\t\tthrow new RuntimeException(\"This policy assumes two slices named \" +\r\n-\t\t\t\t\"One and Two. But configured slices are \" + slices); \r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Distribute PObject based on odd-even value of its id.\r\n-\t */\r\n-\tString distribute(PObject pc) {\r\n-\t\treturn (pc.getId()%2 == 0) ? \"One\" : \"Two\";\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Distribute Person based on first character of its name.\r\n-\t */\r\n-\tString distribute(Person pc) {\r\n-\t\treturn (pc.getName().startsWith(\"A\")) ? \"One\" : \"Two\";\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.policy;\n+\n+import java.util.List;\n+\n+import org.apache.openjpa.slice.DistributionPolicy;\n+\n+import org.apache.openjpa.slice.PObject;\n+import org.apache.openjpa.slice.Person;\n+\n+\n+/**\n+ * Exemplar {@link DistributionPolicy} that maintains closure and distributes\n+ * based on attributes of the given instance. \n+ * \n+ * @author Pinaki Poddar \n+ *\n+ */\n+public class UserDistributionPolicy implements DistributionPolicy {\n+\n+\t/**\n+\t * Distribute the given instance.\n+\t * Assumes that two configured slices are named as <em>One</em> and \n+\t * <em>Two</em>.<br>\n+\t * The policy is only implemented for PObject and Person i.e. two of three \n+\t * known classes. No policy is implemented for Address because Address is\n+\t * persisted always by cascade and hence Slice should assign automatically\n+\t * the same slice as its owner Person. \n+\t * \n+\t */\n+\tpublic String distribute(Object pc, List<String> slices, Object context) {\n+\t\tassertValidSlices(slices);\n+\t\tif (pc instanceof PObject)\n+\t\t\treturn distribute((PObject)pc);\n+\t\tif (pc instanceof Person) {\n+\t\t\treturn distribute((Person)pc);\n+\t\t}\n+\t\tthrow new RuntimeException(\"No policy for \" + pc.getClass());\n+\t}\n+\t\n+\tvoid assertValidSlices(List<String> slices) {\n+\t\tif (slices.contains(\"One\") && slices.contains(\"Two\"))\n+\t\t\treturn;\n+\t\tthrow new RuntimeException(\"This policy assumes two slices named \" +\n+\t\t\t\t\"One and Two. But configured slices are \" + slices); \n+\t}\n+\t\n+\t/**\n+\t * Distribute PObject based on odd-even value of its id.\n+\t */\n+\tString distribute(PObject pc) {\n+\t\treturn (pc.getId()%2 == 0) ? \"One\" : \"Two\";\n+\t}\n+\t\n+\t/**\n+\t * Distribute Person based on first character of its name.\n+\t */\n+\tString distribute(Person pc) {\n+\t\treturn (pc.getName().startsWith(\"A\")) ? \"One\" : \"Two\";\n+\t}\n+}"}]}

