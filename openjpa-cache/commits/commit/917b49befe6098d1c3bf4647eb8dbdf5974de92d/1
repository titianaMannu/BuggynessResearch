{"sha":"917b49befe6098d1c3bf4647eb8dbdf5974de92d","node_id":"MDY6Q29tbWl0MjA2MzY0OjkxN2I0OWJlZmU2MDk4ZDFjM2JmNDY0N2ViOGRiZGY1OTc0ZGU5MmQ=","commit":{"author":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2009-08-23T17:47:06Z"},"committer":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2009-08-23T17:47:06Z"},"message":"OPENJPA-1261 JPQL query result shape for multi-selections including multi-select-new-constructor\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@806993 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"bc4c1d063ce7b3e96c097f2234308156671db27f","url":"https://api.github.com/repos/apache/openjpa/git/trees/bc4c1d063ce7b3e96c097f2234308156671db27f"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/917b49befe6098d1c3bf4647eb8dbdf5974de92d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/917b49befe6098d1c3bf4647eb8dbdf5974de92d","html_url":"https://github.com/apache/openjpa/commit/917b49befe6098d1c3bf4647eb8dbdf5974de92d","comments_url":"https://api.github.com/repos/apache/openjpa/commits/917b49befe6098d1c3bf4647eb8dbdf5974de92d/comments","author":null,"committer":null,"parents":[{"sha":"7c8454767ef4a36d5a57d048ced52322dab996df","url":"https://api.github.com/repos/apache/openjpa/commits/7c8454767ef4a36d5a57d048ced52322dab996df","html_url":"https://github.com/apache/openjpa/commit/7c8454767ef4a36d5a57d048ced52322dab996df"}],"stats":{"total":340,"additions":292,"deletions":48},"files":[{"sha":"286221bc666d969172ed8788af597e795b3eb604","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedSQLStoreQuery.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/917b49befe6098d1c3bf4647eb8dbdf5974de92d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedSQLStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/917b49befe6098d1c3bf4647eb8dbdf5974de92d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedSQLStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedSQLStoreQuery.java?ref=917b49befe6098d1c3bf4647eb8dbdf5974de92d","patch":"@@ -89,7 +89,7 @@ public PreparedSQLExecutor(PreparedSQLStoreQuery q, ClassMetaData candidate) {\n             return _query.getPreparedQuery().getQueryExpressions();\n         }\n         \n-        public Class[] getProjectionTypes() {\n+        public Class[] getProjectionTypes(StoreQuery q) {\n             return _query.getPreparedQuery().getProjectionTypes();\n         }\n "},{"sha":"eaa068ead8f9ab135e4744d5b818e54e8b1e2da5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","status":"modified","additions":127,"deletions":46,"changes":173,"blob_url":"https://github.com/apache/openjpa/blob/917b49befe6098d1c3bf4647eb8dbdf5974de92d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/917b49befe6098d1c3bf4647eb8dbdf5974de92d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java?ref=917b49befe6098d1c3bf4647eb8dbdf5974de92d","patch":"@@ -22,10 +22,12 @@\n import java.io.Serializable;\n import java.lang.reflect.Field;\n import java.math.BigDecimal;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.LinkedHashSet;\n+import java.util.List;\n import java.util.Set;\n import java.util.Stack;\n import java.util.TreeSet;\n@@ -35,8 +37,10 @@\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.kernel.BrokerFactory;\n import org.apache.openjpa.kernel.ExpressionStoreQuery;\n+import org.apache.openjpa.kernel.FillStrategy;\n import org.apache.openjpa.kernel.QueryContext;\n import org.apache.openjpa.kernel.QueryOperations;\n+import org.apache.openjpa.kernel.ResultShape;\n import org.apache.openjpa.kernel.StoreContext;\n import org.apache.openjpa.kernel.exps.AbstractExpressionBuilder;\n import org.apache.openjpa.kernel.exps.Context;\n@@ -344,12 +348,14 @@ private Expression assignSubselectProjection(JPQLNode node,\n         return null;\n     }\n \n+    /**\n+     * Assign projections for NEW contructor in selection list.\n+     *     Example:  SELECT NEW Person(p.name) FROM Person p WHERE ...\n+     */\n     private Expression assignProjections(JPQLNode parametersNode,\n-        QueryExpressions exps) {\n+        QueryExpressions exps, List<Value> projections,\n+        List<String> projectionClauses, List<String> projectionAliases) {\n         int count = parametersNode.getChildCount();\n-        exps.projections = new Value[count];\n-        exps.projectionClauses = new String[count];\n-        exps.projectionAliases = new String[count];\n \n         Expression exp = null;\n         for (int i = 0; i < count; i++) {\n@@ -358,19 +364,96 @@ private Expression assignProjections(JPQLNode parametersNode,\n             JPQLNode aliasNode = parent.children.length > 1 ? right(parent)\n                 : null; \n             Value proj = getValue(node);\n-            String alias = aliasNode == null ? nextAlias()\n-                 : aliasNode.text;\n+            String alias = aliasNode != null ? aliasNode.text :\n+                projectionClause(node.id == JJTSCALAREXPRESSION ?\n+                        firstChild(node) : node);\n             if (aliasNode != null)\n                 proj.setAlias(alias);\n-            exps.projections[i] = proj;\n-            exps.projectionClauses[i] = aliasNode != null ? alias :\n-                projectionClause(node.id == JJTSCALAREXPRESSION ?\n-                    firstChild(node) : node);\n-            exps.projectionAliases[i] = alias;\n+            projections.add(proj);\n+            projectionClauses.add(alias);\n+            projectionAliases.add(alias);\n         }\n         return exp;\n     }\n \n+    private void evalProjectionsResultShape(JPQLNode selectionsNode,\n+        QueryExpressions exps,\n+        List<Value> projections,\n+        List<String> projectionClauses,\n+        List<String> projectionAliases) {\n+        int count = selectionsNode.getChildCount();\n+        Class<?> resultClass = null;\n+        ResultShape<?> resultShape = null;\n+        if (count > 1) {\n+            // muti-selection\n+            resultClass = Object[].class;\n+            resultShape = new ResultShape(resultClass, new FillStrategy.Array<Object[]>(Object[].class));\n+        }\n+\n+        for (int i = 0; i < count; i++) {\n+            JPQLNode parent = selectionsNode.getChild(i);\n+            JPQLNode node = firstChild(parent);\n+            if (node.id == JJTCONSTRUCTOR) {\n+                // build up the fully-qualified result class name by\n+                // appending together the components of the children\n+                String resultClassName = assemble(left(node));\n+                Class<?> constructor = resolver.classForName(resultClassName, null);\n+                if (constructor == null) {\n+                    // try resolve it again using simple name\n+                    int n = left(node).getChildCount();\n+                    String baseName = left(node).getChild(n-1).text;\n+                    constructor = resolver.classForName(baseName, null);\n+                }\n+                if (constructor == null)\n+                    throw parseException(EX_USER, \"no-constructor\",\n+                            new Object[]{ resultClassName }, null);\n+\n+                List<Value> terms = new ArrayList<Value>();\n+                List<String> aliases = new ArrayList<String>();\n+                List<String> clauses = new ArrayList<String>();\n+                // now assign the arguments to the select clause as the projections\n+                assignProjections(right(node), exps, terms, aliases, clauses);\n+                FillStrategy fill = new FillStrategy.NewInstance(constructor);\n+                ResultShape<?> cons = new ResultShape(constructor, fill);\n+                for (Value val : terms) {\n+                    Class<?> type = val.getType();\n+                    cons.nest(new ResultShape(type, new FillStrategy.Assign(), type.isPrimitive()));\n+                }\n+                if (count == 1) {\n+                    resultClass = constructor;\n+                    resultShape = cons;\n+                }\n+                else\n+                    resultShape.nest(cons);\n+                projections.addAll(terms);\n+                projectionAliases.addAll(aliases);\n+                projectionClauses.addAll(clauses);\n+\n+            } else {\n+                JPQLNode aliasNode = parent.children.length > 1 ? right(parent)\n+                        : null; \n+                Value proj = getValue(node);\n+                String alias = aliasNode != null ? aliasNode.text :\n+                    projectionClause(node.id == JJTSCALAREXPRESSION ?\n+                            firstChild(node) : node);\n+                if (aliasNode != null)\n+                    proj.setAlias(alias);\n+                projections.add(proj);\n+                projectionClauses.add(alias);\n+                projectionAliases.add(alias);\n+                Class<?> type = proj.getType();\n+                ResultShape<?> projShape = new ResultShape(type, new FillStrategy.Assign(), type.isPrimitive());\n+\n+                if (count == 1)\n+                    resultShape = projShape;\n+                else\n+                    resultShape.nest(projShape);\n+            }\n+        }\n+        exps.shape = resultShape;\n+        exps.resultClass = resultClass;\n+    }\n+\n     private String projectionClause(JPQLNode node) {\n         switch (node.id) {\n         case JJTTYPE:\n@@ -470,45 +553,43 @@ private Expression evalSelectClause(QueryExpressions exps) {\n         else\n             exps.distinct = QueryExpressions.DISTINCT_FALSE;\n \n-        JPQLNode constructor = selectNode.findChildByID(JJTCONSTRUCTOR, true);\n-        if (constructor != null) {\n-            // build up the fully-qualified result class name by\n-            // appending together the components of the children\n-            String resultClassName = assemble(left(constructor));\n-            exps.resultClass = resolver.classForName(resultClassName, null);\n-\n-            // now assign the arguments to the select clause as the projections\n-            return assignProjections(right(constructor), exps);\n-        } else {\n-            // handle SELECT clauses\n-            JPQLNode expNode = selectNode.\n-                findChildByID(JJTSELECTEXPRESSIONS, true);\n-            if (expNode == null)\n-                return null;\n+        // handle SELECT clauses\n+        JPQLNode expNode = selectNode.\n+        findChildByID(JJTSELECTEXPRESSIONS, true);\n+        if (expNode == null) {\n+            return null;\n+        }\n \n-            int selectCount = expNode.getChildCount();\n-            JPQLNode selectChild = firstChild(expNode);\n+        int selectCount = expNode.getChildCount();\n+        JPQLNode selectChild = firstChild(expNode);\n \n-            if (selectClause.parent.id == JJTSUBSELECT) {\n-                exps.distinct &= ~QueryExpressions.DISTINCT_AUTO;\n-                return assignSubselectProjection(onlyChild(selectChild), exps);\n-            }\n-            // if we are selecting just one thing and that thing is the\n-            // schema's alias, then do not treat it as a projection\n-            if (selectCount == 1 && selectChild != null &&\n-                selectChild.getChildCount() == 1 &&\n-                onlyChild(selectChild) != null) {\n-                JPQLNode child = onlyChild(selectChild);\n-                if (child.id == JJTSCALAREXPRESSION)\n-                    child = onlyChild(child);\n-                if (assertSchemaAlias().\n-                    equalsIgnoreCase(child.text)) \n-                    return null;\n-            } \n-            // JPQL does not filter relational joins for projections\n+        if (selectClause.parent.id == JJTSUBSELECT) {\n             exps.distinct &= ~QueryExpressions.DISTINCT_AUTO;\n-            return assignProjections(expNode, exps);\n+            return assignSubselectProjection(onlyChild(selectChild), exps);\n         }\n+        // if we are selecting just one thing and that thing is the\n+        // schema's alias, then do not treat it as a projection\n+        if (selectCount == 1 && selectChild != null &&\n+            selectChild.getChildCount() == 1 &&\n+            onlyChild(selectChild) != null) {\n+            JPQLNode child = onlyChild(selectChild);\n+            if (child.id == JJTSCALAREXPRESSION)\n+                child = onlyChild(child);\n+            if (assertSchemaAlias().equalsIgnoreCase(child.text)) {\n+                return null;\n+            }\n+        } \n+        // JPQL does not filter relational joins for projections\n+        exps.distinct &= ~QueryExpressions.DISTINCT_AUTO;\n+        exps.projections = new Value[selectCount];\n+        List<Value> projections = new ArrayList<Value>();\n+        List<String> aliases = new ArrayList<String>();\n+        List<String> clauses = new ArrayList<String>();\n+        evalProjectionsResultShape(expNode, exps, projections, aliases, clauses);\n+        exps.projections = projections.toArray(new Value[projections.size()]);\n+        exps.projectionAliases = aliases.toArray(new String[aliases.size()]);\n+        exps.projectionClauses = clauses.toArray(new String[clauses.size()]);\n+        return null;\n     }\n \n     private String assertSchemaAlias() {"},{"sha":"0522e74ba5e795942aef805cc88a1d884600a42c","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/jpql/localizer.properties","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/917b49befe6098d1c3bf4647eb8dbdf5974de92d/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/jpql/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/917b49befe6098d1c3bf4647eb8dbdf5974de92d/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/jpql/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/jpql/localizer.properties?ref=917b49befe6098d1c3bf4647eb8dbdf5974de92d","patch":"@@ -82,4 +82,4 @@ bad-predicate: JPQL query does not support conditional expression over \\\n     embeddable class. JPQL string: \"{0}\". \n cant-bulk-update-embeddable: Bulk update of embeddable field is not allowed: \\\n     \"{0}\".\n- \n\\ No newline at end of file\n+no-constructor: NEW constructor operation could not resolve class named \"{0}\"."},{"sha":"1c9cffb34509f29275c96521a541e7db3abc3a9f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/results/TestJPQLMultiSelectTypedResults.java","status":"added","additions":163,"deletions":0,"changes":163,"blob_url":"https://github.com/apache/openjpa/blob/917b49befe6098d1c3bf4647eb8dbdf5974de92d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/results/TestJPQLMultiSelectTypedResults.java","raw_url":"https://github.com/apache/openjpa/raw/917b49befe6098d1c3bf4647eb8dbdf5974de92d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/results/TestJPQLMultiSelectTypedResults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/results/TestJPQLMultiSelectTypedResults.java?ref=917b49befe6098d1c3bf4647eb8dbdf5974de92d","patch":"@@ -0,0 +1,163 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.openjpa.persistence.query.results;\r\n+\r\n+import java.text.DateFormat;\r\n+import java.text.ParseException;\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+\r\n+import javax.persistence.EntityManager;\r\n+import javax.persistence.Query;\r\n+\r\n+import org.apache.openjpa.persistence.criteria.Person;\r\n+import org.apache.openjpa.persistence.criteria.results.Bar;\r\n+import org.apache.openjpa.persistence.criteria.results.Foo;\r\n+import org.apache.openjpa.persistence.criteria.results.FooBar;\r\n+import org.apache.openjpa.persistence.criteria.results.Item;\r\n+import org.apache.openjpa.persistence.criteria.results.Order;\r\n+import org.apache.openjpa.persistence.criteria.results.Producer;\r\n+import org.apache.openjpa.persistence.criteria.results.Shop;\r\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n+\r\n+public class TestJPQLMultiSelectTypedResults extends SingleEMFTestCase {\r\n+\r\n+    private static final int N_ORDERS = 15;\r\n+    private static final int N_ITEMS_PER_ORDER = 3;\r\n+\r\n+    // use short data format\r\n+    private static final String[] ORDER_DATES =\r\n+        { \"3/12/2008 1:00 PM\", \"10/01/2008 1:51 AM\", \"12/12/2008 10:01 AM\", \"5/21/2009 3:23 PM\" };\r\n+\r\n+    DateFormat df = DateFormat.getInstance(); // uses SHORT dateformat by default\r\n+\r\n+    public void setUp() throws Exception {\r\n+        setUp(CLEAR_TABLES, Order.class, Item.class, Shop.class, Producer.class,\r\n+              Person.class, Foo.class, Bar.class,\r\n+             \"openjpa.DynamicEnhancerAgent\", \"false\");\r\n+        populate();\r\n+    }\r\n+\r\n+    public void populate() throws ParseException {\r\n+        EntityManager em = emf.createEntityManager();\r\n+        em.getTransaction().begin();\r\n+        Shop s = new Shop();\r\n+        Order order;\r\n+        Item item;\r\n+        Producer p;\r\n+\r\n+        s.setId(1);\r\n+        s.setName(\"eBay.com\");\r\n+        s.setOrders(new HashSet<Order>());\r\n+\r\n+        for (int i = 1; i <= N_ORDERS; i++) {\r\n+            order = new Order();\r\n+            order.setId(i);\r\n+            order.setDate(df.parse(ORDER_DATES[i % ORDER_DATES.length]));\r\n+            order.setFilled(i % 2 == 0 ? true : false);\r\n+            order.setShop(s);\r\n+            order.setItems(new HashSet<Item>());\r\n+            s.getOrders().add(order);\r\n+            for (int j = 1; j <= N_ITEMS_PER_ORDER; j++) {\r\n+                item = new Item();\r\n+                item.setOrder(order);\r\n+                order.getItems().add(item);\r\n+                p = new Producer();\r\n+                p.setName(\"filler\");\r\n+                p.setItem(item);\r\n+                item.setProduct(p);\r\n+            }\r\n+        }\r\n+        em.persist(s);\r\n+        Person person = new Person(\"Test Result Shape\");\r\n+        em.persist(person);\r\n+        \r\n+        Foo foo = new Foo(100L, \"Test Foo\");\r\n+        Bar bar = new Bar(200L, \"Test Bar\");\r\n+        foo.setBar(bar);\r\n+        em.persist(foo);\r\n+        em.persist(bar);\r\n+        em.getTransaction().commit();\r\n+        em.close();\r\n+    }\r\n+\r\n+    public void tearDown() throws Exception {\r\n+        super.tearDown();\r\n+    }\r\n+\r\n+    public void testMultipleConstructor() {\r\n+        String query = \"SELECT NEW Foo(f.fid,f.fint), b, NEW FooBar(f.fid, b.bid) \" +\r\n+                    \"from Foo f JOIN f.bar b WHERE f.bar=b\";\r\n+        EntityManager em = emf.createEntityManager();\r\n+        Query jpqlQuery = em.createQuery(query);\r\n+        List<Object[]> result = jpqlQuery.getResultList();\r\n+\r\n+        assertFalse(result.isEmpty());\r\n+        for (Object[] row : result) {\r\n+            assertEquals(3, row.length);\r\n+            assertTrue(\"0-th element \" + row[0].getClass() + \" is not Foo\", row[0] instanceof Foo);\r\n+            assertTrue(\"1-st element \" + row[1].getClass() + \" is not Bar\", row[1] instanceof Bar);\r\n+            assertTrue(\"2-nd element \" + row[2].getClass() + \" is not FooBar\", row[2] instanceof FooBar);\r\n+        }\r\n+        \r\n+    }\r\n+    public void testMultipleConstructorMixWithMultiSelect() {\r\n+        String query = \"SELECT NEW Person(p.name), p.id, NEW Person(p.name), p.name FROM Person p ORDER BY p.name\";\r\n+        EntityManager em = emf.createEntityManager();\r\n+        Query jpqlQuery = em.createQuery(query);\r\n+        List<Object[]> result = jpqlQuery.getResultList();\r\n+        assertTrue(!result.isEmpty());\r\n+        for (Object[] row : result) {\r\n+            assertEquals(4, row.length);\r\n+            \r\n+            assertEquals(Person.class,  row[0].getClass());\r\n+            assertEquals(Integer.class, row[1].getClass());\r\n+            assertEquals(Person.class,  row[2].getClass());\r\n+            assertEquals(String.class,  row[3].getClass());\r\n+            \r\n+            assertEquals(((Person)row[0]).getName(), ((Person)row[2]).getName());\r\n+            assertEquals(((Person)row[0]).getName(), row[3]);\r\n+        }\r\n+    }\r\n+    /**\r\n+     * Testcase to verify that selecting multiple results in a variety of ways returns the same results. Results are\r\n+     * returned via a normal Object [] (JPQL).\r\n+     * \r\n+     * @throws Exception\r\n+     */\r\n+    public void testMultiSelect() throws Exception {\r\n+        // get results from traditional JPQL\r\n+        EntityManager em = emf.createEntityManager();\r\n+        Query jpqlQuery =\r\n+            em.createQuery(\"SELECT o, p from Order o JOIN o.items i JOIN i.producer p WHERE o.filled = true\");\r\n+        // don't suppress warnings.\r\n+        List<Object[]> jpqlResults = jpqlQuery.getResultList();\r\n+\r\n+        assertEquals(N_ORDERS / 2 * N_ITEMS_PER_ORDER, jpqlResults.size());\r\n+\r\n+        for (Object[] os : jpqlResults) {\r\n+            assertEquals(2, os.length);\r\n+            assertTrue(os[0] instanceof Order);\r\n+            assertTrue(os[1] instanceof Producer);\r\n+        }\r\n+\r\n+        em.close();\r\n+    }\r\n+}\r"}]}

