{"sha":"94efd58dd9e258e2de7436c767f179e136c49dfe","node_id":"MDY6Q29tbWl0MjA2MzY0Ojk0ZWZkNThkZDllMjU4ZTJkZTc0MzZjNzY3ZjE3OWUxMzZjNDlkZmU=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-12-23T20:08:39Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-12-23T20:08:39Z"},"message":"OPENJPA-845: Evaluate ordering value for PCPath to support ORDER BY slice queries that involves ordering terms not included in projection items and hence requires in-memory ordering from multiple slices.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@729084 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"2cf6d787dce4dc83357ba32938caa8676627becf","url":"https://api.github.com/repos/apache/openjpa/git/trees/2cf6d787dce4dc83357ba32938caa8676627becf"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/94efd58dd9e258e2de7436c767f179e136c49dfe","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/94efd58dd9e258e2de7436c767f179e136c49dfe","html_url":"https://github.com/apache/openjpa/commit/94efd58dd9e258e2de7436c767f179e136c49dfe","comments_url":"https://api.github.com/repos/apache/openjpa/commits/94efd58dd9e258e2de7436c767f179e136c49dfe/comments","author":null,"committer":null,"parents":[{"sha":"3f90c7eaa8b1c262ce752f3ebdc3a4336b0c8781","url":"https://api.github.com/repos/apache/openjpa/commits/3f90c7eaa8b1c262ce752f3ebdc3a4336b0c8781","html_url":"https://github.com/apache/openjpa/commit/3f90c7eaa8b1c262ce752f3ebdc3a4336b0c8781"}],"stats":{"total":101,"additions":92,"deletions":9},"files":[{"sha":"238d90c0c0b232c31c28eea01f629462dadb9b2d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","status":"modified","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/94efd58dd9e258e2de7436c767f179e136c49dfe/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","raw_url":"https://github.com/apache/openjpa/raw/94efd58dd9e258e2de7436c767f179e136c49dfe/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java?ref=94efd58dd9e258e2de7436c767f179e136c49dfe","patch":"@@ -36,13 +36,17 @@\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.Broker;\n import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.StoreContext;\n import org.apache.openjpa.kernel.exps.CandidatePath;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.meta.XMLMetaData;\n+import org.apache.openjpa.util.ImplHelper;\n import org.apache.openjpa.util.UserException;\n \n /**\n@@ -556,6 +560,45 @@ private static boolean isJoinedField(FieldMapping src, boolean key,\n                 return false;\n         return true;\n     }\n+    \n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        if (_actions == null)\n+            return candidate;\n+\n+        Action action;\n+        OpenJPAStateManager sm;\n+        Broker tmpBroker;\n+        for (Iterator itr = _actions.iterator(); itr.hasNext();) {\n+            action = (Action)itr.next();\n+            sm = null;\n+            tmpBroker = null;\n+            if (ImplHelper.isManageable(candidate))\n+                sm = (OpenJPAStateManager) (ImplHelper.toPersistenceCapable(\n+                    candidate, ctx.getConfiguration())).\n+                    pcGetStateManager();\n+            if (sm == null) {\n+                tmpBroker = ctx.getBroker();\n+                tmpBroker.transactional(candidate, false, null);\n+                sm = tmpBroker.getStateManager(candidate);\n+            }\n+            if (action.op != Action.GET && action.op != Action.GET_OUTER)\n+                continue;\n+            try {\n+                candidate = sm.fetchField(((FieldMapping)action.data).getIndex(), \n+                    true);\n+            } catch (ClassCastException cce) {\n+                throw new RuntimeException(action.data + \" not a field path\");\n+            } finally {\n+                // transactional does not clear the state, which is\n+                // important since tmpCandidate might be also managed by\n+                // another broker if it's a proxied non-pc instance\n+                if (tmpBroker != null)\n+                    tmpBroker.nontransactional(sm.getManagedInstance(), null);\n+            }\n+        }\n+        return candidate;\n+    }\n \n     /**\n      * Expression state."},{"sha":"fc9c7368b5b2e8c7c156787fc68708bcc328552e","filename":"openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQuery.java","status":"modified","additions":49,"deletions":9,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/94efd58dd9e258e2de7436c767f179e136c49dfe/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQuery.java","raw_url":"https://github.com/apache/openjpa/raw/94efd58dd9e258e2de7436c767f179e136c49dfe/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/test/java/org/apache/openjpa/slice/TestQuery.java?ref=94efd58dd9e258e2de7436c767f179e136c49dfe","patch":"@@ -78,11 +78,12 @@ void create(int N) {\n         em.getTransaction().commit();\r\n     }\r\n     \r\n-    public void testQueryResultIsOrderedAcrossSlice() {\r\n+    public void testOrderedQueryResultWhenOrderableItemSelected() {\r\n         EntityManager em = emf.createEntityManager();\r\n         em.getTransaction().begin();\r\n         Query query = em.createQuery(\"SELECT p.value,p FROM PObject p ORDER BY p.value ASC\");\r\n         List result = query.getResultList();\r\n+        assertValidResult(result);\r\n         Integer old = Integer.MIN_VALUE;\r\n         for (Object row : result) {\r\n             Object[] line = (Object[])row;\r\n@@ -95,6 +96,40 @@ public void testQueryResultIsOrderedAcrossSlice() {\n         em.getTransaction().rollback();\r\n     }\r\n     \r\n+    public void testOrderedQueryResultWhenOrderableItemNotSelected() {\r\n+        EntityManager em = emf.createEntityManager();\r\n+        em.getTransaction().begin();\r\n+        Query query = em.createQuery(\"SELECT p FROM PObject p ORDER BY p.value ASC\");\r\n+        List<PObject> result = query.getResultList();\r\n+        assertValidResult(result);\r\n+        Integer old = Integer.MIN_VALUE;\r\n+        for (PObject pc : result) {\r\n+            int value = pc.getValue();\r\n+            assertTrue(value >= old);\r\n+            old = value;\r\n+        }\r\n+        em.getTransaction().rollback();\r\n+    }\r\n+    \r\n+    public void testOrderedQueryResultWhenNavigatedOrderableItemNotSelected() {\r\n+        EntityManager em = emf.createEntityManager();\r\n+        em.getTransaction().begin();\r\n+        Query query = em.createQuery(\"SELECT p FROM Person p JOIN p.address a ORDER BY a.zip ASC, a.city DESC\");\r\n+        List<Person> result = query.getResultList();\r\n+        assertValidResult(result);\r\n+        Integer oldZip = Integer.MIN_VALUE;\r\n+        String oldCity = null;\r\n+        for (Person pc : result) {\r\n+            int zip = pc.getAddress().getZip();\r\n+            String city = pc.getAddress().getCity();\r\n+            assertTrue(zip >= oldZip);\r\n+            assertTrue(oldCity == null || oldCity.compareTo(city) >= 0);\r\n+            oldZip = zip;\r\n+            oldCity = city;\r\n+        }\r\n+        em.getTransaction().rollback();\r\n+    }\r\n+    \r\n     public void testAggregateQuery() {\r\n         EntityManager em = emf.createEntityManager();\r\n         em.getTransaction().begin();\r\n@@ -128,15 +163,14 @@ public void testSetMaxResult() {\n         EntityManager em = emf.createEntityManager();\r\n         int limit = 3;\r\n         em.getTransaction().begin();\r\n-        List result = em.createQuery(\"SELECT p.value,p FROM PObject p ORDER BY p.value ASC\")\r\n+        List<PObject> result = em.createQuery(\"SELECT p FROM PObject p ORDER BY p.value ASC\")\r\n             .setMaxResults(limit).getResultList();\r\n-        int i = 0;\r\n-        for (Object row : result) {\r\n-            Object[] line = (Object[])row;\r\n-            int value = ((Integer)line[0]).intValue();\r\n-            PObject pc = (PObject)line[1];\r\n-            System.err.println(++i + \".\" + SlicePersistence.getSlice(pc) + \":\" \r\n-                    + pc.getId() + \",\" + pc.getValue());\r\n+        assertValidResult(result);\r\n+        Integer old = Integer.MIN_VALUE;\r\n+        for (PObject pc : result) {\r\n+            int value = pc.getValue();\r\n+            assertTrue(value >= old);\r\n+            old = value;\r\n         }\r\n         assertEquals(limit, result.size());\r\n         em.getTransaction().rollback();\r\n@@ -190,4 +224,10 @@ public void testQueryParameterEntity() {\n         assertEquals(\"Rome\", p.getAddress().getCity());\r\n         em.getTransaction().rollback();\r\n     }\r\n+    \r\n+    void assertValidResult(List result) {\r\n+        assertNotNull(result);\r\n+        assertFalse(result.isEmpty());\r\n+        assertTrue(result.size() > 1);\r\n+    }\r\n }\r"}]}

