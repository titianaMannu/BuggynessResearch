{"sha":"976508eed24aed7dfdbb9b4894cb3bdc6f938e8e","node_id":"MDY6Q29tbWl0MjA2MzY0Ojk3NjUwOGVlZDI0YWVkN2RmZGJiOWI0ODk0Y2IzYmRjNmY5MzhlOGU=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2010-03-17T23:15:34Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2010-03-17T23:15:34Z"},"message":"Raise correct exceptions\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@924551 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"dc3b1fd80bbf2b9f59675adb45a527b844758d4b","url":"https://api.github.com/repos/apache/openjpa/git/trees/dc3b1fd80bbf2b9f59675adb45a527b844758d4b"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/976508eed24aed7dfdbb9b4894cb3bdc6f938e8e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/976508eed24aed7dfdbb9b4894cb3bdc6f938e8e","html_url":"https://github.com/apache/openjpa/commit/976508eed24aed7dfdbb9b4894cb3bdc6f938e8e","comments_url":"https://api.github.com/repos/apache/openjpa/commits/976508eed24aed7dfdbb9b4894cb3bdc6f938e8e/comments","author":null,"committer":null,"parents":[{"sha":"63079316a001a44538183c03e657f7da5324d7c0","url":"https://api.github.com/repos/apache/openjpa/commits/63079316a001a44538183c03e657f7da5324d7c0","html_url":"https://github.com/apache/openjpa/commit/63079316a001a44538183c03e657f7da5324d7c0"}],"stats":{"total":448,"additions":195,"deletions":253},"files":[{"sha":"260f3e2813375267e2b569dce136bd0c47e20c8b","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestPessimisticLocks.java","status":"modified","additions":195,"deletions":253,"changes":448,"blob_url":"https://github.com/apache/openjpa/blob/976508eed24aed7dfdbb9b4894cb3bdc6f938e8e/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestPessimisticLocks.java","raw_url":"https://github.com/apache/openjpa/raw/976508eed24aed7dfdbb9b4894cb3bdc6f938e8e/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestPessimisticLocks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestPessimisticLocks.java?ref=976508eed24aed7dfdbb9b4894cb3bdc6f938e8e","patch":"@@ -27,79 +27,58 @@\n import javax.persistence.PessimisticLockException;\n import javax.persistence.Query;\n import javax.persistence.QueryTimeoutException;\n+import javax.persistence.TypedQuery;\n+\n+import junit.framework.AssertionFailedError;\n \n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.persistence.LockTimeoutException;\n import org.apache.openjpa.persistence.test.SQLListenerTestCase;\n+import org.apache.openjpa.util.OpenJPAException;\n \n /**\n- * Test Pessimistic Lock and exception behavior against EntityManager and Query interface methods.\n+ * Test Pessimistic Lock and exception behavior against EntityManager and Query\n+ * interface methods.\n  */\n public class TestPessimisticLocks extends SQLListenerTestCase {\n \n     private DBDictionary dict = null;\n \n     public void setUp() {\n-        setUp(Employee.class, Department.class, \"openjpa.LockManager\", \"mixed\");\n-        setSupportedDatabases(\n-                org.apache.openjpa.jdbc.sql.DerbyDictionary.class,\n-//                org.apache.openjpa.jdbc.sql.OracleDictionary.class,\n-                org.apache.openjpa.jdbc.sql.DB2Dictionary.class);\n-        if (isTestsDisabled()) {\n-            return;\n-        }\n-\n-        String empTable = getMapping(Employee.class).getTable().getFullName();\n-        String deptTable = getMapping(Department.class).getTable().getFullName();\n-\n-        dict= ((JDBCConfiguration)emf.getConfiguration()).getDBDictionaryInstance();\n+        setUp(CLEAR_TABLES, Employee.class, Department.class, \"openjpa.LockManager\", \"mixed\");\n \n         EntityManager em = null;\n-        try {\n-            em = emf.createEntityManager();\n-            em.getTransaction().begin();\n-\n-            em.createQuery(\"delete from \" + empTable).executeUpdate();\n-            em.createQuery(\"delete from \" + deptTable).executeUpdate();\n-\n-            em.getTransaction().commit();\n-\n-            Employee e1, e2;\n-            Department d1, d2;\n-            d1 = new Department();\n-            d1.setId(10);\n-            d1.setName(\"D10\");\n-\n-            e1 = new Employee();\n-            e1.setId(1);\n-            e1.setDepartment(d1);\n-            e1.setFirstName(\"first.1\");\n-            e1.setLastName(\"last.1\");\n-\n-            d2 = new Department();\n-            d2.setId(20);\n-            d2.setName(\"D20\");\n-\n-            e2 = new Employee();\n-            e2.setId(2);\n-            e2.setDepartment(d2);\n-            e2.setFirstName(\"first.2\");\n-            e2.setLastName(\"last.2\");\n-\n-            em.getTransaction().begin();\n-            em.persist(d1);\n-            em.persist(d2);\n-            em.persist(e1);\n-            em.persist(e2);\n-            em.getTransaction().commit();\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        } finally {\n-            if (em != null && em.isOpen()) {\n-                em.close();\n-            }\n-        }\n+        em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+\n+        Employee e1, e2;\n+        Department d1, d2;\n+        d1 = new Department();\n+        d1.setId(10);\n+        d1.setName(\"D10\");\n+\n+        e1 = new Employee();\n+        e1.setId(1);\n+        e1.setDepartment(d1);\n+        e1.setFirstName(\"first.1\");\n+        e1.setLastName(\"last.1\");\n+\n+        d2 = new Department();\n+        d2.setId(20);\n+        d2.setName(\"D20\");\n+\n+        e2 = new Employee();\n+        e2.setId(2);\n+        e2.setDepartment(d2);\n+        e2.setFirstName(\"first.2\");\n+        e2.setLastName(\"last.2\");\n+\n+        em.persist(d1);\n+        em.persist(d2);\n+        em.persist(e1);\n+        em.persist(e2);\n+        em.getTransaction().commit();\n     }\n \n     /*\n@@ -108,79 +87,62 @@ public void setUp() {\n     public void testFindAfterQueryWithPessimisticLocks() {\n         EntityManager em1 = emf.createEntityManager();\n         EntityManager em2 = emf.createEntityManager();\n+        em1.getTransaction().begin();\n+        TypedQuery<Employee> query = em1.createQuery(\"select e from Employee e where e.id < 10\", Employee.class)\n+                .setFirstResult(1);\n+        // Lock all selected Employees, skip the first one, i.e should lock\n+        // Employee(2)\n+        query.setLockMode(LockModeType.PESSIMISTIC_READ);\n+        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        List<Employee> employees = query.getResultList();\n+        assertEquals(\"Expected 1 element with emplyee id=2\", employees.size(), 1);\n+        assertTrue(\"Test Employee first name = 'first.2'\", employees.get(0).getFirstName().equals(\"first.1\")\n+                || employees.get(0).getFirstName().equals(\"first.2\"));\n+\n+        em2.getTransaction().begin();\n+        Map<String, Object> hints = new HashMap<String, Object>();\n+        hints.put(\"javax.persistence.lock.timeout\", 2000);\n+        // find Employee(2) with a lock, should block and expected a\n+        // PessimisticLockException\n         try {\n-            em1.getTransaction().begin();\n-            Query query = em1.createQuery(\n-                    \"select e from Employee e where e.id < 10\").setFirstResult(1);\n-            // Lock all selected Employees, skip the first one, i.e should lock Employee(2)\n-            query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-            query.setHint(\"javax.persistence.query.timeout\", 2000);\n-            List<Employee> q = query.getResultList();\n-            assertEquals(\"Expected 1 element with emplyee id=2\", q.size(), 1);\n-            assertTrue(\"Test Employee first name = 'first.2'\", q.get(0).getFirstName().equals(\"first.1\")\n-                    || q.get(0).getFirstName().equals(\"first.2\"));\n-\n-            em2.getTransaction().begin();\n-            Map<String,Object> map = new HashMap<String,Object>();\n-            map.put(\"javax.persistence.lock.timeout\", 2000);\n-            // find Employee(2) with a lock, should block and expected a PessimisticLockException\n-            em2.find(Employee.class, 2, LockModeType.PESSIMISTIC_READ, map);\n+            em2.find(Employee.class, 2, LockModeType.PESSIMISTIC_READ, hints);\n             fail(\"Unexcpected find succeeded. Should throw a PessimisticLockException.\");\n-        } catch (LockTimeoutException e) {            \n-            // TODO: DB2: This is the current unexpected exception due to OPENJPA-991.\n-            // Remove this when the problem is fixed\n-            System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage() + \" Failed \" \n-                    + e.getFailedObject());\n-        } catch (PessimisticLockException e) {\n-            // TODO: This is the expected exception but will be fixed under OPENJPA-991\n-//            System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage());\n-        } catch (Exception ex) {\n-            fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+        } catch (Throwable e) {\n+            assertError(e, LockTimeoutException.class);\n         } finally {\n-            if( em1.getTransaction().isActive())\n+            if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n-            if( em2.getTransaction().isActive())\n+            if (em2.getTransaction().isActive())\n                 em2.getTransaction().rollback();\n         }\n \n+        em1.getTransaction().begin();\n+        TypedQuery<Department> query2 = em1.createQuery(\"select e.department from Employee e where e.id < 10\",\n+                Department.class).setFirstResult(1);\n+        // Lock all selected Departments, skip the first one, i.e should\n+        // lock Department(20)\n+        query.setLockMode(LockModeType.PESSIMISTIC_READ);\n+        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        List<Department> depts = query2.getResultList();\n+        assertEquals(\"Expected 1 element with department id=20\", depts.size(), 1);\n+        assertTrue(\"Test department name = 'D20'\", depts.get(0).getName().equals(\"D10\")\n+                || depts.get(0).getName().equals(\"D20\"));\n+\n+        em2.getTransaction().begin();\n+        Map<String, Object> map = new HashMap<String, Object>();\n+        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        // find Employee(2) with a lock, no block since only department was\n+        // locked\n         try {\n-            em1.getTransaction().begin();\n-            Query query = em1.createQuery(\n-                    \"select e.department from Employee e where e.id < 10\").setFirstResult(1);\n-            // Lock all selected Departments, skip the first one, i.e should lock Department(20)\n-            query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-            query.setHint(\"javax.persistence.query.timeout\", 2000);\n-            List<Department> q = query.getResultList();\n-            assertEquals(\"Expected 1 element with department id=20\", q.size(), 1);\n-            assertTrue(\"Test department name = 'D20'\", q.get(0).getName().equals(\"D10\")\n-                    || q.get(0).getName().equals(\"D20\"));\n-\n-            em2.getTransaction().begin();\n-            Map<String,Object> map = new HashMap<String,Object>();\n-            map.put(\"javax.persistence.lock.timeout\", 2000);\n-            // find Employee(2) with a lock, no block since only department was locked\n             Employee emp = em2.find(Employee.class, 1, LockModeType.PESSIMISTIC_READ, map);\n             assertNotNull(\"Query locks department only, therefore should find Employee.\", emp);\n             assertEquals(\"Test Employee first name = 'first.1'\", emp.getFirstName(), \"first.1\");\n-        } catch (QueryTimeoutException e) {            \n-            // TODO: DB2: This is the current unexpected exception due to OPENJPA-991.\n-            // Remove this when the problem is fixed\n-//            System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage());\n-            if( !(dict instanceof org.apache.openjpa.jdbc.sql.DB2Dictionary)) {\n-                fail(\"Caught unexpected \" + e.getClass().getName() + \":\" + e.getMessage());\n-            }\n-        } catch (PessimisticLockException e) {\n-            // TODO: This is the expected exception but will be fixed under OPENJPA-991\n-//            System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage());\n-            if( !(dict instanceof org.apache.openjpa.jdbc.sql.DB2Dictionary)) {\n-                fail(\"Caught unexpected \" + e.getClass().getName() + \":\" + e.getMessage());\n-            }\n         } catch (Exception ex) {\n             fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n         } finally {\n-            if( em1.getTransaction().isActive())\n+            if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n-            if( em2.getTransaction().isActive())\n+            if (em2.getTransaction().isActive())\n                 em2.getTransaction().rollback();\n         }\n         em1.close();\n@@ -195,75 +157,57 @@ public void testFindAfterQueryOrderByWithPessimisticLocks() {\n         EntityManager em2 = emf.createEntityManager();\n         try {\n             em1.getTransaction().begin();\n-            Query query = em1.createQuery(\n-                    \"select e from Employee e where e.id < 10 order by e.id\").setFirstResult(1);\n-            // Lock all selected Employees, skip the first one, i.e should lock Employee(2)\n+            Query query = em1.createQuery(\"select e from Employee e where e.id < 10 order by e.id\").setFirstResult(1);\n+            // Lock all selected Employees, skip the first one, i.e should lock\n+            // Employee(2)\n             query.setLockMode(LockModeType.PESSIMISTIC_READ);\n             query.setHint(\"javax.persistence.query.timeout\", 2000);\n             List<Employee> q = query.getResultList();\n             assertEquals(\"Expected 1 element with emplyee id=2\", q.size(), 1);\n             assertEquals(\"Test Employee first name = 'first.2'\", q.get(0).getFirstName(), \"first.2\");\n \n             em2.getTransaction().begin();\n-            Map<String,Object> map = new HashMap<String,Object>();\n+            Map<String, Object> map = new HashMap<String, Object>();\n             map.put(\"javax.persistence.lock.timeout\", 2000);\n-            // find Employee(2) with a lock, should block and expected a PessimisticLockException\n+            // find Employee(2) with a lock, should block and expected a\n+            // PessimisticLockException\n             em2.find(Employee.class, 2, LockModeType.PESSIMISTIC_READ, map);\n             fail(\"Unexcpected find succeeded. Should throw a PessimisticLockException.\");\n-        } catch (LockTimeoutException e) {            \n-            // TODO: DB2: This is the current unexpected exception due to OPENJPA-991.\n-            // Remove this when the problem is fixed\n-            System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage() + \" Failed \" + \n-                    e.getFailedObject());\n-        } catch (PessimisticLockException e) {\n-            // TODO: This is the expected exception but will be fixed under OPENJPA-991\n-//            System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage());\n-        } catch (Exception ex) {\n-            fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+        } catch (LockTimeoutException e) {\n+            assertError(e, LockTimeoutException.class);\n         } finally {\n-            if( em1.getTransaction().isActive())\n+            if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n-            if( em2.getTransaction().isActive())\n+            if (em2.getTransaction().isActive())\n                 em2.getTransaction().rollback();\n         }\n \n+        em1.getTransaction().begin();\n+        Query query = em1.createQuery(\"select e.department from Employee e where e.id < 10 order by e.department.id\")\n+                .setFirstResult(1);\n+        // Lock all selected Departments, skip the first one, i.e should\n+        // lock Department(20)\n+        query.setLockMode(LockModeType.PESSIMISTIC_READ);\n+        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        List<Department> q = query.getResultList();\n+        assertEquals(\"Expected 1 element with department id=20\", q.size(), 1);\n+        assertEquals(\"Test department name = 'D20'\", q.get(0).getName(), \"D20\");\n+\n+        em2.getTransaction().begin();\n+        Map<String, Object> map = new HashMap<String, Object>();\n+        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        // find Employee(2) with a lock, no block since only department was\n+        // locked\n         try {\n-            em1.getTransaction().begin();\n-            Query query = em1.createQuery(\n-                    \"select e.department from Employee e where e.id < 10 order by e.department.id\").setFirstResult(1);\n-            // Lock all selected Departments, skip the first one, i.e should lock Department(20)\n-            query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-            query.setHint(\"javax.persistence.query.timeout\", 2000);\n-            List<Department> q = query.getResultList();\n-            assertEquals(\"Expected 1 element with department id=20\", q.size(), 1);\n-            assertEquals(\"Test department name = 'D20'\", q.get(0).getName(), \"D20\");\n-\n-            em2.getTransaction().begin();\n-            Map<String,Object> map = new HashMap<String,Object>();\n-            map.put(\"javax.persistence.lock.timeout\", 2000);\n-            // find Employee(2) with a lock, no block since only department was locked\n             Employee emp = em2.find(Employee.class, 1, LockModeType.PESSIMISTIC_READ, map);\n             assertNotNull(\"Query locks department only, therefore should find Employee.\", emp);\n             assertEquals(\"Test Employee first name = 'first.1'\", emp.getFirstName(), \"first.1\");\n-        } catch (QueryTimeoutException e) {            \n-            // TODO: DB2: This is the current unexpected exception due to OPENJPA-991.\n-            // Remove this when the problem is fixed\n-//          System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage());\n-            if( !(dict instanceof org.apache.openjpa.jdbc.sql.DB2Dictionary)) {\n-                fail(\"Caught unexpected \" + e.getClass().getName() + \":\" + e.getMessage());\n-            }\n-        } catch (PessimisticLockException e) {\n-            // TODO: This is the expected exception but will be fixed under OPENJPA-991\n-//          System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage());\n-            if( !(dict instanceof org.apache.openjpa.jdbc.sql.DB2Dictionary)) {\n-                fail(\"Caught unexpected \" + e.getClass().getName() + \":\" + e.getMessage());\n-            }\n         } catch (Exception ex) {\n             fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n         } finally {\n-            if( em1.getTransaction().isActive())\n+            if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n-            if( em2.getTransaction().isActive())\n+            if (em2.getTransaction().isActive())\n                 em2.getTransaction().rollback();\n         }\n         em1.close();\n@@ -278,71 +222,52 @@ public void testQueryAfterFindWithPessimisticLocks() {\n         EntityManager em2 = emf.createEntityManager();\n         try {\n             em2.getTransaction().begin();\n-            Map<String,Object> map = new HashMap<String,Object>();\n+            Map<String, Object> map = new HashMap<String, Object>();\n             map.put(\"javax.persistence.lock.timeout\", 2000);\n             // Lock Emplyee(1), no department should be locked\n             em2.find(Employee.class, 1, LockModeType.PESSIMISTIC_READ, map);\n \n             em1.getTransaction().begin();\n-            Query query = em1.createQuery(\n-                    \"select e.department from Employee e where e.id < 10\").setFirstResult(1);\n+            Query query = em1.createQuery(\"select e.department from Employee e where e.id < 10\").setFirstResult(1);\n             query.setLockMode(LockModeType.PESSIMISTIC_READ);\n             query.setHint(\"javax.persistence.query.timeout\", 2000);\n-            // Lock all selected Department but skip the first, i.e. lock Department(20), should query successfully.\n+            // Lock all selected Department but skip the first, i.e. lock\n+            // Department(20), should query successfully.\n             List<Department> q = query.getResultList();\n             assertEquals(\"Expected 1 element with department id=20\", q.size(), 1);\n             assertTrue(\"Test department name = 'D20'\", q.get(0).getName().equals(\"D10\")\n                     || q.get(0).getName().equals(\"D20\"));\n-        } catch (QueryTimeoutException e) {            \n-            // TODO: DB2: This is the current unexpected exception due to OPENJPA-991.\n-            // Remove this when the problem is fixed\n-//          System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage());\n-            if( !(dict instanceof org.apache.openjpa.jdbc.sql.DB2Dictionary)) {\n-                fail(\"Caught unexpected \" + e.getClass().getName() + \":\" + e.getMessage());\n-            }\n-        } catch (PessimisticLockException e) {\n-            // TODO: This is the expected exception but will be fixed under OPENJPA-991\n-//          System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage());\n-            if( !(dict instanceof org.apache.openjpa.jdbc.sql.DB2Dictionary)) {\n-                fail(\"Caught unexpected \" + e.getClass().getName() + \":\" + e.getMessage());\n-            }\n         } catch (Exception ex) {\n             fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n         } finally {\n-            if( em1.getTransaction().isActive())\n+            if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n             if (em2.getTransaction().isActive())\n                 em2.getTransaction().rollback();\n         }\n-        \n-        try {\n-            em2.getTransaction().begin();\n \n-            Map<String,Object> map = new HashMap<String,Object>();\n-            map.put(\"javax.persistence.lock.timeout\", 2000);\n-            // Lock Emplyee(2), no department should be locked\n-            em2.find(Employee.class, 2, LockModeType.PESSIMISTIC_READ, map);\n+        em2.getTransaction().begin();\n \n-            em1.getTransaction().begin();\n-            Query query = em1.createQuery(\n-                    \"select e from Employee e where e.id < 10\").setFirstResult(1);\n-            // Lock all selected Employees, skip the first one, i.e should lock Employee(2)\n-            query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-            query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        Map<String, Object> map = new HashMap<String, Object>();\n+        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        // Lock Emplyee(2), no department should be locked\n+        em2.find(Employee.class, 2, LockModeType.PESSIMISTIC_READ, map);\n+\n+        em1.getTransaction().begin();\n+        Query query = em1.createQuery(\"select e from Employee e where e.id < 10\").setFirstResult(1);\n+        // Lock all selected Employees, skip the first one, i.e should lock\n+        // Employee(2)\n+        query.setLockMode(LockModeType.PESSIMISTIC_READ);\n+        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        try {\n             List<Employee> q = query.getResultList();\n             fail(\"Unexcpected find succeeded. Should throw a QueryLockException.\");\n-        } catch (QueryTimeoutException e) {            \n-            // This is the expected exception.\n-//            System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage());\n-        } catch (PessimisticLockException e) {\n-            // TODO: This is the expected exception but will be fixed under OPENJPA-991\n-//            System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage());\n-        } catch (Exception ex) {\n-            fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+        } catch (Exception e) {\n+            assertError(e, QueryTimeoutException.class);\n         } finally {\n-            if( em1.getTransaction().isActive())\n+            if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n-            if( em2.getTransaction().isActive())\n+            if (em2.getTransaction().isActive())\n                 em2.getTransaction().rollback();\n         }\n         em1.close();\n@@ -355,75 +280,92 @@ public void testQueryAfterFindWithPessimisticLocks() {\n     public void testQueryOrderByAfterFindWithPessimisticLocks() {\n         EntityManager em1 = emf.createEntityManager();\n         EntityManager em2 = emf.createEntityManager();\n+        em2.getTransaction().begin();\n+        Map<String, Object> map = new HashMap<String, Object>();\n+        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        // Lock Emplyee(1), no department should be locked\n+        em2.find(Employee.class, 1, LockModeType.PESSIMISTIC_READ, map);\n+\n+        em1.getTransaction().begin();\n+        Query query = em1.createQuery(\"select e.department from Employee e where e.id < 10 order by e.department.id\")\n+                .setFirstResult(1);\n+        query.setLockMode(LockModeType.PESSIMISTIC_READ);\n+        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        // Lock all selected Department but skip the first, i.e. lock\n+        // Department(20), should query successfully.\n         try {\n-            em2.getTransaction().begin();\n-            Map<String,Object> map = new HashMap<String,Object>();\n-            map.put(\"javax.persistence.lock.timeout\", 2000);\n-            // Lock Emplyee(1), no department should be locked\n-            em2.find(Employee.class, 1, LockModeType.PESSIMISTIC_READ, map);\n-\n-            em1.getTransaction().begin();\n-            Query query = em1.createQuery(\n-                    \"select e.department from Employee e where e.id < 10 order by e.department.id\").setFirstResult(1);\n-            query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-            query.setHint(\"javax.persistence.query.timeout\", 2000);\n-            // Lock all selected Department but skip the first, i.e. lock Department(20), should query successfully.\n             List<Department> q = query.getResultList();\n             assertEquals(\"Expected 1 element with department id=20\", q.size(), 1);\n             assertEquals(\"Test department name = 'D20'\", q.get(0).getName(), \"D20\");\n-        } catch (QueryTimeoutException e) {            \n-            // TODO: DB2: This is the current unexpected exception due to OPENJPA-991.\n-            // Remove this when the problem is fixed\n-//          System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage());\n-            if( !(dict instanceof org.apache.openjpa.jdbc.sql.DB2Dictionary)) {\n-                fail(\"Caught unexpected \" + e.getClass().getName() + \":\" + e.getMessage());\n-            }\n-        } catch (PessimisticLockException e) {\n-            // TODO: This is the expected exception but will be fixed under OPENJPA-991\n-//          System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage());\n-            if( !(dict instanceof org.apache.openjpa.jdbc.sql.DB2Dictionary)) {\n-                fail(\"Caught unexpected \" + e.getClass().getName() + \":\" + e.getMessage());\n-            }\n         } catch (Exception ex) {\n             fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n         } finally {\n-            if( em1.getTransaction().isActive())\n+            if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n             if (em2.getTransaction().isActive())\n                 em2.getTransaction().rollback();\n         }\n-        \n-        try {\n-            em2.getTransaction().begin();\n \n-            Map<String,Object> map = new HashMap<String,Object>();\n-            map.put(\"javax.persistence.lock.timeout\", 2000);\n-            // Lock Emplyee(2), no department should be locked\n-            em2.find(Employee.class, 2, LockModeType.PESSIMISTIC_READ, map);\n+        em2.getTransaction().begin();\n \n-            em1.getTransaction().begin();\n-            Query query = em1.createQuery(\n-                    \"select e from Employee e where e.id < 10 order by e.department.id\").setFirstResult(1);\n-            // Lock all selected Employees, skip the first one, i.e should lock Employee(2)\n-            query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-            query.setHint(\"javax.persistence.query.timeout\", 2000);\n-            List<Employee> q = query.getResultList();\n+        map.clear();\n+        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        // Lock Emplyee(2), no department should be locked\n+        em2.find(Employee.class, 2, LockModeType.PESSIMISTIC_READ, map);\n+\n+        em1.getTransaction().begin();\n+        query = em1.createQuery(\"select e from Employee e where e.id < 10 order by e.department.id\")\n+                .setFirstResult(1);\n+        // Lock all selected Employees, skip the first one, i.e should lock\n+        // Employee(2)\n+        query.setLockMode(LockModeType.PESSIMISTIC_READ);\n+        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        try {\n+            List<?> q = query.getResultList();\n             fail(\"Unexcpected find succeeded. Should throw a QueryLockException.\");\n-        } catch (QueryTimeoutException e) {            \n-            // This is the expected exception.\n-//            System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage());\n-        } catch (PessimisticLockException e) {\n-            // TODO: This is the expected exception but will be fixed under OPENJPA-991\n-//            System.out.println(\"Caught \" + e.getClass().getName() + \":\" + e.getMessage());\n-        } catch (Exception ex) {\n-            fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+        } catch (Exception e) {\n+            assertError(e, QueryTimeoutException.class);\n         } finally {\n-            if( em1.getTransaction().isActive())\n+            if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n-            if( em2.getTransaction().isActive())\n+            if (em2.getTransaction().isActive())\n                 em2.getTransaction().rollback();\n         }\n         em1.close();\n         em2.close();\n     }\n+\n+    /**\n+     * Assert that an exception of proper type has been thrown. Also checks that\n+     * that the exception has populated the failed object.\n+     * \n+     * @param actual\n+     *            exception being thrown\n+     * @param expeceted\n+     *            type of the exception\n+     */\n+    void assertError(Throwable actual, Class<? extends Throwable> expected) {\n+        if (!expected.isAssignableFrom(actual.getClass())) {\n+            actual.printStackTrace();\n+            throw new AssertionFailedError(actual.getClass().getName() + \" was raised but expected \"\n+                    + expected.getName());\n+        }\n+        Object failed = getFailedObject(actual);\n+        assertNotNull(\"Failed object is null\", failed);\n+        assertNotEquals(\"null\", failed);\n+    }\n+\n+    Object getFailedObject(Throwable e) {\n+        if (e instanceof LockTimeoutException) {\n+            return ((LockTimeoutException) e).getObject();\n+        }\n+        if (e instanceof QueryTimeoutException) {\n+            return ((QueryTimeoutException) e).getQuery();\n+        }\n+        if (e instanceof OpenJPAException) {\n+            return ((OpenJPAException) e).getFailedObject();\n+        }\n+        return null;\n+    }\n+\n }"}]}

