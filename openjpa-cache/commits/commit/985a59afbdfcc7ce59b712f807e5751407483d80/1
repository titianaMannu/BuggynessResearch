{"sha":"985a59afbdfcc7ce59b712f807e5751407483d80","node_id":"MDY6Q29tbWl0MjA2MzY0Ojk4NWE1OWFmYmRmY2M3Y2U1OWI3MTJmODA3ZTU3NTE0MDc0ODNkODA=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2011-04-07T21:28:32Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2011-04-07T21:28:32Z"},"message":"OPENJPA-1975: Move default schema name code to its own method.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@1090025 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a43eea7beaaf9ebf32f3a69c373e860139e4dfb8","url":"https://api.github.com/repos/apache/openjpa/git/trees/a43eea7beaaf9ebf32f3a69c373e860139e4dfb8"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/985a59afbdfcc7ce59b712f807e5751407483d80","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/985a59afbdfcc7ce59b712f807e5751407483d80","html_url":"https://github.com/apache/openjpa/commit/985a59afbdfcc7ce59b712f807e5751407483d80","comments_url":"https://api.github.com/repos/apache/openjpa/commits/985a59afbdfcc7ce59b712f807e5751407483d80/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"2d232cf4c0f6aaa33dc911610ee098cab0320dbb","url":"https://api.github.com/repos/apache/openjpa/commits/2d232cf4c0f6aaa33dc911610ee098cab0320dbb","html_url":"https://github.com/apache/openjpa/commit/2d232cf4c0f6aaa33dc911610ee098cab0320dbb"}],"stats":{"total":305,"additions":284,"deletions":21},"files":[{"sha":"92b0e23164d7e74b8543c0ff3d28f510b2805545","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","status":"modified","additions":77,"deletions":20,"changes":97,"blob_url":"https://github.com/apache/openjpa/blob/985a59afbdfcc7ce59b712f807e5751407483d80/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/985a59afbdfcc7ce59b712f807e5751407483d80/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java?ref=985a59afbdfcc7ce59b712f807e5751407483d80","patch":"@@ -34,6 +34,8 @@\n import java.util.Date;\n import java.util.StringTokenizer;\n \n+import javax.sql.DataSource;\n+\n import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n@@ -268,26 +270,6 @@ public void connectedConfiguration(Connection conn) throws SQLException {\n         super.connectedConfiguration(conn);\n \n         DatabaseMetaData metaData = conn.getMetaData();\n-        Statement stmnt = null;\t\n-        ResultSet rs =null;\n-        try {\n-            String str = \"SELECT CURRENT SCHEMA FROM \" + SYSDUMMY;\n-            stmnt = conn.createStatement();\n-            rs = stmnt.executeQuery(str);\n-            if (rs.next()) {\n-                String currSchema = rs.getString(1);\n-                if (currSchema != null)\n-                    setDefaultSchemaName(currSchema.trim());\n-            }\n-        } catch (SQLException e) {\n-            if (log.isTraceEnabled())\n-                log.trace(_loc.get(\"can_not_get_current_schema\", e.getMessage()));\n-        } finally {\n-            if (rs != null)\n-                rs.close();\n-            if (stmnt != null)\n-                stmnt.close();\n-        }\n \n         String driverName = metaData.getDriverName();\n         if (driverName != null && driverName.startsWith(\"IBM DB2\"))\n@@ -1115,4 +1097,79 @@ public int getDB2MajorVersion() {\n     public int getDB2MinorVersion() {\n         return min;\n     }\n+    \n+    public String getDefaultSchemaName()  {\n+        if (defaultSchemaName == null) {\n+            Connection conn = null;\n+            Statement stmnt = null;\n+            ResultSet rs = null;\n+            try {\n+                String str = \"SELECT CURRENT SCHEMA FROM \" + SYSDUMMY;\n+                conn = getConnection(); \n+                stmnt = conn.createStatement();\n+                rs = stmnt.executeQuery(str);\n+                if (rs.next()) {\n+                    String currSchema = rs.getString(1);\n+                    if (currSchema != null) {\n+                        setDefaultSchemaName(currSchema.trim());\n+                    }\n+                }\n+            } catch (SQLException e) {\n+                if (log.isTraceEnabled()) {\n+                    log.trace(_loc.get(\"can_not_get_current_schema\", e.getMessage()));\n+                }\n+            } finally {\n+                if (rs != null) {\n+                    try {\n+                        rs.close();\n+                    } catch (SQLException se) {\n+                        // ignore\n+                    }\n+                }\n+\n+                if (stmnt != null) {\n+                    try {\n+                        stmnt.close();\n+                    } catch (SQLException se) {\n+                        // ignore\n+                    }\n+                }\n+                if (conn != null) { \n+                    try { \n+                        conn.close(); \n+                    }\n+                    catch(SQLException se) { \n+                        // ignore\n+                    }\n+                }\n+            }\n+        }\n+        return defaultSchemaName;\n+    }\n+\n+    /**\n+     * Obtain a connection from the configuration. Tries to use the jta-data-source first but falls back on the\n+     * non-jta-data-source if no jta-data-source has been defined.\n+     * \n+     * In practice this method is only called by getDefaultSchemaName which in turn is only used by the schema tool.\n+     * \n+     * @throws SQLException If neither datasource is available.\n+     * @return A connection which may be used to obtain the default schema name. Callers do not need to check for null. \n+     */\n+    private Connection getConnection() throws SQLException {\n+        // try to obtain a connection from the primary datasource \n+        DataSource ds = conf.getDataSource(null);\n+        \n+        if(ds == null) {\n+            // use datasource 2 if available\n+            ds = conf.getDataSource2(null);\n+        }\n+        \n+        if (ds != null) {\n+            return ds.getConnection();\n+        }\n+        \n+        // throw\n+        throw new SQLException(\"Unable to obtain a datasource\");\n+    }\n }"},{"sha":"a15bee3ec790b123bb3007a40f23681c8a8f5622","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/985a59afbdfcc7ce59b712f807e5751407483d80/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/985a59afbdfcc7ce59b712f807e5751407483d80/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java?ref=985a59afbdfcc7ce59b712f807e5751407483d80","patch":"@@ -373,7 +373,7 @@\n     public String nameConcatenator = \"_\";\n     public String delimitedCase = SCHEMA_CASE_PRESERVE;\n     public String catalogSeparator = \".\";\n-    private String defaultSchemaName = null;\n+    protected String defaultSchemaName = null;\n     private String conversionKey = null;\n        \n     // Naming utility and naming rules"},{"sha":"f509d35003cd8d934d07f6407cdb1fd0a1a095a9","filename":"openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/sql/TestDB2Dictionary.java","status":"added","additions":206,"deletions":0,"changes":206,"blob_url":"https://github.com/apache/openjpa/blob/985a59afbdfcc7ce59b712f807e5751407483d80/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/sql/TestDB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/985a59afbdfcc7ce59b712f807e5751407483d80/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/sql/TestDB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/sql/TestDB2Dictionary.java?ref=985a59afbdfcc7ce59b712f807e5751407483d80","patch":"@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.Statement;\n+\n+import javax.sql.DataSource;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.jmock.Expectations;\n+import org.jmock.integration.junit3.MockObjectTestCase;\n+\n+public class TestDB2Dictionary extends MockObjectTestCase {\n+    final JDBCConfiguration mockConfiguration = mock(JDBCConfiguration.class);\n+    final Statement mockStatement = mock(Statement.class);\n+    final Connection mockConnection = mock(Connection.class);\n+    final ResultSet mockRS = mock(ResultSet.class);\n+    final DataSource mockDS = mock(DataSource.class);\n+\n+    final StoreContext sc = null;\n+    final String schema = \"abcd\";\n+    \n+    /*\n+     * When DS1 is non null we should get a connection and use it to obtain the schema name. \n+     */\n+    public void testGetDefaultSchemaNameDS1() throws Exception {\n+        // Expected method calls on the mock objects above. If any of these are\n+        // do not occur, or if any other methods are invoked on the mock objects\n+        // an exception will be thrown and the test will fail.\n+        checking(new Expectations() {\n+            {\n+                // Wiring, make sure the appropriate mocks are created.                \n+                oneOf(mockConfiguration).getDataSource(with(equal(sc)));\n+                will(returnValue(mockDS));\n+\n+                oneOf(mockDS).getConnection();\n+                will(returnValue(mockConnection));\n+\n+                oneOf(mockConnection).createStatement();\n+                will(returnValue(mockStatement));\n+\n+                oneOf(mockStatement).executeQuery(with(any(String.class)));\n+                will(returnValue(mockRS));\n+\n+                // expect one call to rs.next() - needs to return true.\n+                oneOf(mockRS).next();\n+                will(returnValue(true));\n+\n+                // return our schema name\n+                oneOf(mockRS).getString(1);\n+                will(returnValue(schema));\n+\n+                // cleanup\n+                oneOf(mockConnection).close();\n+                oneOf(mockRS).close();\n+                oneOf(mockStatement).close();\n+\n+                allowing(mockConfiguration);\n+            }\n+        });\n+\n+        DBDictionary dict = new DB2Dictionary();\n+        dict.setConfiguration(mockConfiguration);\n+        assertNotNull(dict);\n+        assertEquals(schema, dict.getDefaultSchemaName());\n+    }\n+    \n+    /*\n+     * When ds1 is null, fallback to ds2 \n+     */\n+    public void testGetDefaultSchemaNameDS2() throws Exception {\n+        // Expected method calls on the mock objects above. If any of these are\n+        // do not occur, or if any other methods are invoked on the mock objects\n+        // an exception will be thrown and the test will fail.\n+        checking(new Expectations() {\n+            {\n+                // Wiring, make sure the appropriate mocks are created.                \n+                oneOf(mockConfiguration).getDataSource(with(equal(sc)));\n+                will(returnValue(null));\n+                \n+                oneOf(mockConfiguration).getDataSource2(with(equal(sc)));\n+                will(returnValue(mockDS));\n+\n+                oneOf(mockDS).getConnection();\n+                will(returnValue(mockConnection));\n+\n+                oneOf(mockConnection).createStatement();\n+                will(returnValue(mockStatement));\n+\n+                oneOf(mockStatement).executeQuery(with(any(String.class)));\n+                will(returnValue(mockRS));\n+\n+                // expect one call to rs.next() - needs to return true.\n+                oneOf(mockRS).next();\n+                will(returnValue(true));\n+\n+                // return our schema name\n+                oneOf(mockRS).getString(1);\n+                will(returnValue(schema));\n+\n+                // cleanup\n+                oneOf(mockConnection).close();\n+                oneOf(mockRS).close();\n+                oneOf(mockStatement).close();\n+\n+                allowing(mockConfiguration);\n+            }\n+        });\n+\n+        DBDictionary dict = new DB2Dictionary();\n+        dict.setConfiguration(mockConfiguration);\n+        assertNotNull(dict);\n+        assertEquals(schema, dict.getDefaultSchemaName());\n+    }    \n+    \n+    /*\n+     * When ds1 is null, fallback to ds2 \n+     */\n+    public void testGetDefaultSchemaNameNoDS() throws Exception {\n+        // Expected method calls on the mock objects above. If any of these are\n+        // do not occur, or if any other methods are invoked on the mock objects\n+        // an exception will be thrown and the test will fail.\n+        checking(new Expectations() {\n+            {\n+                // both datasources are null for this test.\n+                oneOf(mockConfiguration).getDataSource(with(equal(sc)));\n+                will(returnValue(null));\n+                \n+                oneOf(mockConfiguration).getDataSource2(with(equal(sc)));\n+                will(returnValue(null));\n+\n+                allowing(mockConfiguration);\n+            }\n+        });\n+\n+        DBDictionary dict = new DB2Dictionary();\n+        dict.setConfiguration(mockConfiguration);\n+        assertNotNull(dict);\n+        assertEquals(null, dict.getDefaultSchemaName());\n+    }\n+    \n+    /*\n+     * TestWhitespace trim \n+     */\n+    public void testGetDefaultSchemaNameTrimmed() throws Exception {\n+        final String schema2 = \"abcd     \";\n+        // Expected method calls on the mock objects above. If any of these are\n+        // do not occur, or if any other methods are invoked on the mock objects\n+        // an exception will be thrown and the test will fail.\n+        checking(new Expectations() {\n+            {\n+                // Wiring, make sure the appropriate mocks are created.                \n+                oneOf(mockConfiguration).getDataSource(with(equal(sc)));\n+                will(returnValue(mockDS));\n+\n+                oneOf(mockDS).getConnection();\n+                will(returnValue(mockConnection));\n+\n+                oneOf(mockConnection).createStatement();\n+                will(returnValue(mockStatement));\n+\n+                oneOf(mockStatement).executeQuery(with(any(String.class)));\n+                will(returnValue(mockRS));\n+\n+                // expect one call to rs.next() - needs to return true.\n+                oneOf(mockRS).next();\n+                will(returnValue(true));\n+\n+                // return our schema name\n+                oneOf(mockRS).getString(1);\n+                will(returnValue(schema2));\n+\n+                // cleanup\n+                oneOf(mockConnection).close();\n+                oneOf(mockRS).close();\n+                oneOf(mockStatement).close();\n+\n+                allowing(mockConfiguration);\n+            }\n+        });\n+\n+        DBDictionary dict = new DB2Dictionary();\n+        dict.setConfiguration(mockConfiguration);\n+        assertNotNull(dict);\n+        assertEquals(schema2.trim(), dict.getDefaultSchemaName());\n+    }\n+}"}]}

