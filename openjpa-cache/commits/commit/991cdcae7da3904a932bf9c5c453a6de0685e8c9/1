{"sha":"991cdcae7da3904a932bf9c5c453a6de0685e8c9","node_id":"MDY6Q29tbWl0MjA2MzY0Ojk5MWNkY2FlN2RhMzkwNGE5MzJiZjljNWM0NTNhNmRlMDY4NWU4Yzk=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-08-28T18:25:08Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-08-28T18:25:08Z"},"message":"OPENJPA-1271: \nEnable CacheStoreMode and CacheRetrieveMode properties to be set for an EntityManager.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@808981 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"823b81001f1c8457c30f77f89e3ca41b79acfb70","url":"https://api.github.com/repos/apache/openjpa/git/trees/823b81001f1c8457c30f77f89e3ca41b79acfb70"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/991cdcae7da3904a932bf9c5c453a6de0685e8c9","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/991cdcae7da3904a932bf9c5c453a6de0685e8c9","html_url":"https://github.com/apache/openjpa/commit/991cdcae7da3904a932bf9c5c453a6de0685e8c9","comments_url":"https://api.github.com/repos/apache/openjpa/commits/991cdcae7da3904a932bf9c5c453a6de0685e8c9/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"78e93abb515193f3b1abd00ee9074186527fb110","url":"https://api.github.com/repos/apache/openjpa/commits/78e93abb515193f3b1abd00ee9074186527fb110","html_url":"https://github.com/apache/openjpa/commit/78e93abb515193f3b1abd00ee9074186527fb110"}],"stats":{"total":1400,"additions":1059,"deletions":341},"files":[{"sha":"5c462d3de733fb7417f25def1c94a9c552a882af","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","status":"modified","additions":184,"deletions":179,"changes":363,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -30,6 +30,8 @@\n import java.util.Map.Entry;\n \n import org.apache.openjpa.enhance.PCDataGenerator;\n+import org.apache.openjpa.kernel.DataCacheRetrieveMode;\n+import org.apache.openjpa.kernel.DataCacheStoreMode;\n import org.apache.openjpa.kernel.DelegatingStoreManager;\n import org.apache.openjpa.kernel.FetchConfiguration;\n import org.apache.openjpa.kernel.LockLevels;\n@@ -54,9 +56,9 @@\n     extends DelegatingStoreManager {\n \n     // all the state managers changed in this transaction\n-    private Collection _inserts = null; // statemanagers\n-    private Map _updates = null; // statemanager -> fmd set\n-    private Collection _deletes = null; // statemanagers\n+    private Collection<OpenJPAStateManager> _inserts = null;\n+    private Map<OpenJPAStateManager, BitSet> _updates = null;\n+    private Collection<OpenJPAStateManager> _deletes = null;\n \n     // the owning context\n     private StoreContext _ctx = null;\n@@ -130,127 +132,125 @@ private void evictTypes(Collection classes) {\n      * Update all caches with the committed inserts, updates, and deletes.\n      */\n     private void updateCaches() {\n-        // map each data cache to the modifications we need to perform\n-        Map modMap = null;\n-        Modifications mods;\n-        OpenJPAStateManager sm;\n-        DataCachePCData data;\n-        DataCache cache;\n-\n-        // create pc datas for inserts\n-        if (_ctx.getPopulateDataCache() && _inserts != null) {\n-            for (Iterator itr = _inserts.iterator(); itr.hasNext();) {\n-                sm = (OpenJPAStateManager) itr.next();\n-                cache = sm.getMetaData().getDataCache();\n-                if (cache == null)\n-                    continue;\n-\n-                if (modMap == null)\n-                    modMap = new HashMap();\n-                mods = getModifications(modMap, cache);\n-                data = newPCData(sm);\n-                data.store(sm);\n-                mods.additions.add(new PCDataHolder(data, sm));\n-            }\n-        }\n-\n-        // update pcdatas for updates\n-        Map.Entry entry;\n-        if (_updates != null) {\n-            BitSet fields;\n-            for (Iterator itr = _updates.entrySet().iterator();\n-                itr.hasNext();) {\n-                entry = (Map.Entry) itr.next();\n-                sm = (OpenJPAStateManager) entry.getKey();\n-                fields = (BitSet) entry.getValue();\n-\n-                cache = sm.getMetaData().getDataCache();\n-                if (cache == null)\n-                    continue;\n-\n-                // it's ok not to clone the object that we get from the cache,\n-                // since we're inside the commit() method, so any modifications\n-                // to the underlying cache are valid. If the commit had not\n-                // already succeeded, then we'd want to clone the retrieved\n-                // object.\n-                if (modMap == null)\n-                    modMap = new HashMap();\n-                data = cache.get(sm.getObjectId());\n-                mods = getModifications(modMap, cache);\n-\n-                // data should always be non-null, since the object is\n-                // dirty, but maybe it got dropped from the cache in the\n-                // interim\n-                if (data == null) {\n+        if(_ctx.getCacheStoreMode() != DataCacheStoreMode.BYPASS ) { \n+            // map each data cache to the modifications we need to perform\n+            Map modMap = null;\n+            Modifications mods;\n+            DataCachePCData data;\n+            DataCache cache;\n+\n+            // create pc datas for inserts\n+            if (_ctx.getPopulateDataCache() && _inserts != null) {\n+                for(OpenJPAStateManager sm : _inserts) {\n+                    cache = sm.getMetaData().getDataCache();\n+                    if (cache == null)\n+                        continue;\n+\n+                    if (modMap == null)\n+                        modMap = new HashMap();\n+                    mods = getModifications(modMap, cache);\n                     data = newPCData(sm);\n                     data.store(sm);\n-                    mods.newUpdates.add(new PCDataHolder(data, sm));\n-                } else {\n-                    data.store(sm, fields);\n-                    mods.existingUpdates.add(new PCDataHolder(data, sm));\n+                    mods.additions.add(new PCDataHolder(data, sm));\n                 }\n             }\n-        }\n \n-        // remove pcdatas for deletes\n-        if (_deletes != null) {\n-            for (Iterator itr = _deletes.iterator(); itr.hasNext();) {\n-                sm = (OpenJPAStateManager) itr.next();\n-                cache = sm.getMetaData().getDataCache();\n-                if (cache == null)\n-                    continue;\n+            // update pcdatas for updates\n+            if (_updates != null) {\n+                BitSet fields;\n+                OpenJPAStateManager sm;\n+                for(Map.Entry<OpenJPAStateManager, BitSet> entry : _updates.entrySet()) { \n+                    sm = entry.getKey();\n+                    fields = entry.getValue();\n+\n+                    cache = sm.getMetaData().getDataCache();\n+                    if (cache == null) {\n+                        continue;\n+                    }\n+\n+                    // it's ok not to clone the object that we get from the cache,\n+                    // since we're inside the commit() method, so any modifications\n+                    // to the underlying cache are valid. If the commit had not\n+                    // already succeeded, then we'd want to clone the retrieved\n+                    // object.\n+                    if (modMap == null)\n+                        modMap = new HashMap();\n+                    data = cache.get(sm.getObjectId());\n+                    mods = getModifications(modMap, cache);\n+\n+                    // data should always be non-null, since the object is\n+                    // dirty, but maybe it got dropped from the cache in the\n+                    // interim\n+                    if (data == null) {\n+                        data = newPCData(sm);\n+                        data.store(sm);\n+                        mods.newUpdates.add(new PCDataHolder(data, sm));\n+                    } else {\n+                        data.store(sm, fields);\n+                        mods.existingUpdates.add(new PCDataHolder(data, sm));\n+                    }\n+                }\n+            }\n \n-                if (modMap == null)\n-                    modMap = new HashMap();\n-                mods = getModifications(modMap, cache);\n-                mods.deletes.add(sm.getObjectId());\n+            // remove pcdatas for deletes\n+            if (_deletes != null) {\n+                for(OpenJPAStateManager sm : _deletes) { \n+                    cache = sm.getMetaData().getDataCache();\n+                    if (cache == null)\n+                        continue;\n+\n+                    if (modMap == null)\n+                        modMap = new HashMap();\n+                    mods = getModifications(modMap, cache);\n+                    mods.deletes.add(sm.getObjectId());\n+                }\n             }\n-        }\n \n-        // notify the caches of the changes\n-        if (modMap != null) {\n-            for (Iterator itr = modMap.entrySet().iterator(); itr.hasNext();) {\n-                entry = (Map.Entry) itr.next();\n-                cache = (DataCache) entry.getKey();\n-                mods = (Modifications) entry.getValue();\n-\n-                // make sure we're not caching old versions\n-                cache.writeLock();\n-                try {\n-                    transformToVersionSafePCDatas(cache, mods.additions);\n-                    transformToVersionSafePCDatas(cache, mods.newUpdates);\n-                    transformToVersionSafePCDatas(cache, mods.existingUpdates);\n-                    cache.commit(mods.additions, mods.newUpdates,\n-                        mods.existingUpdates, mods.deletes);\n-                } finally {\n-                    cache.writeUnlock();\n+            // notify the caches of the changes\n+            if (modMap != null) {\n+                for (Iterator itr = modMap.entrySet().iterator(); itr.hasNext();) {\n+                    Map.Entry entry = (Map.Entry) itr.next();\n+                    cache = (DataCache) entry.getKey();\n+                    mods = (Modifications) entry.getValue();\n+\n+                    // make sure we're not caching old versions\n+                    cache.writeLock();\n+                    try {\n+                        transformToVersionSafePCDatas(cache, mods.additions);\n+                        transformToVersionSafePCDatas(cache, mods.newUpdates);\n+                        transformToVersionSafePCDatas(cache, mods.existingUpdates);\n+                        cache.commit(mods.additions, mods.newUpdates,\n+                            mods.existingUpdates, mods.deletes);\n+                    } finally {\n+                        cache.writeUnlock();\n+                    }\n                 }\n             }\n-        }\n \n-        // if we were in largeTransaction mode, then we have recorded\n-        // the classes of updated/deleted objects and these now need to be\n-        // evicted\n-        if (_ctx.isTrackChangesByType()) {\n-            evictTypes(_ctx.getDeletedTypes());\n-            evictTypes(_ctx.getUpdatedTypes());\n-        }\n+            // if we were in largeTransaction mode, then we have recorded\n+            // the classes of updated/deleted objects and these now need to be\n+            // evicted\n+            if (_ctx.isTrackChangesByType()) {\n+                evictTypes(_ctx.getDeletedTypes());\n+                evictTypes(_ctx.getUpdatedTypes());\n+            }\n \n-        // and notify the query cache.  notify in one batch to reduce synch\n-        QueryCache queryCache = _ctx.getConfiguration().\n+            // and notify the query cache.  notify in one batch to reduce synch\n+            QueryCache queryCache = _ctx.getConfiguration().\n             getDataCacheManagerInstance().getSystemQueryCache();\n-        if (queryCache != null) {\n-            Collection pers = _ctx.getPersistedTypes();\n-            Collection del = _ctx.getDeletedTypes();\n-            Collection up = _ctx.getUpdatedTypes();\n-            int size = pers.size() + del.size() + up.size();\n-            if (size > 0) {\n-                Collection types = new ArrayList(size);\n-                types.addAll(pers);\n-                types.addAll(del);\n-                types.addAll(up);\n-                queryCache.onTypesChanged(new TypesChangedEvent(this, types));\n-            }\n+            if (queryCache != null) {\n+                Collection pers = _ctx.getPersistedTypes();\n+                Collection del = _ctx.getDeletedTypes();\n+                Collection up = _ctx.getUpdatedTypes();\n+                int size = pers.size() + del.size() + up.size();\n+                if (size > 0) {\n+                    Collection types = new ArrayList(size);\n+                    types.addAll(pers);\n+                    types.addAll(del);\n+                    types.addAll(up);\n+                    queryCache.onTypesChanged(new TypesChangedEvent(this, types));\n+                }\n+            } \n         }\n     }\n \n@@ -333,52 +333,74 @@ public boolean syncVersion(OpenJPAStateManager sm, Object edata) {\n         return super.syncVersion(sm, edata);\n     }\n \n-    public boolean initialize(OpenJPAStateManager sm, PCState state,\n-        FetchConfiguration fetch, Object edata) {\n+    public boolean initialize(OpenJPAStateManager sm, PCState state, FetchConfiguration fetch, Object edata) {\n+        boolean rval; \n         DataCache cache = sm.getMetaData().getDataCache();\n-        if (cache == null || sm.isEmbedded())\n-            return super.initialize(sm, state, fetch, edata);\n-\n-        DataCachePCData data = cache.get(sm.getObjectId());\n-        if (data != null && !isLocking(fetch)) {\n-            //### the 'data.type' access here probably needs to be\n-            //### addressed for bug 511\n-            sm.initialize(data.getType(), state);\n-            data.load(sm, fetch, edata);\n-            return true;\n+        if (cache == null || sm.isEmbedded() || _ctx.getCacheRetrieveMode() == DataCacheRetrieveMode.BYPASS\n+            || _ctx.getCacheStoreMode() == DataCacheStoreMode.REFRESH) {\n+            // save the return value and return later in case we need to update the cache)\n+            rval = super.initialize(sm, state, fetch, edata);\n         }\n \n-        // initialize from store manager\n-        if (!super.initialize(sm, state, fetch, edata))\n-            return false;\n-        if (!_ctx.getPopulateDataCache())\n-            return true;\n+        else {\n+            DataCachePCData data = cache.get(sm.getObjectId());\n+            if (data != null && !isLocking(fetch)) {                \n+                //### the 'data.type' access here probably needs to be\n+                //### addressed for bug 511\n+                sm.initialize(data.getType(), state);\n+                data.load(sm, fetch, edata);\n+                return true;\n+            }\n \n+            // initialize from store manager\n+            if (!super.initialize(sm, state, fetch, edata)) {\n+                return false;\n+            }\n+            rval = true; // same as rval = super.initialize(...)\n+        }\n+\n+        // update the cache if configured appropriately. \n+        if (_ctx.getCacheStoreMode() == DataCacheStoreMode.REFRESH && _ctx.getPopulateDataCache()) {\n+            cacheStateManager(cache, sm);\n+        }\n+        return rval;\n+    }\n+    \n+    private void cacheStateManager(DataCache cache, OpenJPAStateManager sm) {\n+        if(sm.isFlushed()) { \n+            return;\n+        }\n         // make sure that we're not trying to cache an old version\n         cache.writeLock();\n         try {\n-            data = cache.get(sm.getObjectId());\n-            if (data != null && compareVersion(sm, sm.getVersion(),\n-                data.getVersion()) == VERSION_EARLIER)\n-                return true;\n+            DataCachePCData data = cache.get(sm.getObjectId());\n+            if (data != null && compareVersion(sm, sm.getVersion(), data.getVersion()) == VERSION_EARLIER) {\n+                return;\n+            }\n \n             // cache newly loaded info. It is safe to cache data frorm\n             // initialize() because this method is only called upon\n             // initial load of the data.\n-            if (data == null)\n+            boolean isNew = data == null;\n+            if (isNew) {\n                 data = newPCData(sm);\n+            }\n             data.store(sm);\n-            cache.put(data);\n+            if(isNew) { \n+                cache.put(data);\n+            }\n+            else {\n+                cache.update(data);\n+            }\n         } finally {\n             cache.writeUnlock();\n         }\n-        return true;\n     }\n \n     public boolean load(OpenJPAStateManager sm, BitSet fields,\n         FetchConfiguration fetch, int lockLevel, Object edata) {\n         DataCache cache = sm.getMetaData().getDataCache();\n-        if (cache == null || sm.isEmbedded())\n+        if (cache == null || sm.isEmbedded() || _ctx.getCacheRetrieveMode() == DataCacheRetrieveMode.BYPASS)\n             return super.load(sm, fields, fetch, lockLevel, edata);\n \n         DataCachePCData data = cache.get(sm.getObjectId());\n@@ -392,33 +414,11 @@ public boolean load(OpenJPAStateManager sm, BitSet fields,\n         // so that if the store manager decides to modify it it won't affect us\n         if (!super.load(sm, (BitSet) fields.clone(), fetch, lockLevel, edata))\n             return false;\n-        if (!_ctx.getPopulateDataCache())\n-            return true;\n-        // Do not load changes into cache if the instance has been flushed\n-        if (sm.isFlushed())\n-            return true;\n-\n-        // make sure that we're not trying to cache an old version\n-        cache.writeLock();\n-        try {\n-            data = cache.get(sm.getObjectId());\n-            if (data != null && compareVersion(sm, sm.getVersion(),\n-                data.getVersion()) == VERSION_EARLIER)\n-                return true;\n-\n-            // cache newly loaded info\n-            boolean isNew = data == null;\n-            if (isNew)\n-                data = newPCData(sm);\n-            data.store(sm, fields);\n-            if (isNew)\n-                cache.put(data);\n-            else\n-                cache.update(data);\n-        } finally {\n-            cache.writeUnlock();\n+        if (_ctx.getPopulateDataCache()) {\n+            cacheStateManager(cache, sm);\n         }\n         return true;\n+\n     }\n \n     public Collection loadAll(Collection sms, PCState state, int load,\n@@ -430,7 +430,7 @@ public Collection loadAll(Collection sms, PCState state, int load,\n     \t       return super.loadAll(sms, state, load, fetch, edata);\n     \t}\n \n-        Map unloaded = null;\n+        Map<OpenJPAStateManager, BitSet> unloaded = null;\n         List smList = null;\n         Map caches = new HashMap();\n         OpenJPAStateManager sm;\n@@ -509,12 +509,12 @@ public Collection loadAll(Collection sms, PCState state, int load,\n             return failed;\n \n         // for each loaded instance, merge loaded state into cached data\n-        Map.Entry entry;\n+\n         boolean isNew;\n-        for (Iterator itr = unloaded.entrySet().iterator(); itr.hasNext();) {\n-            entry = (Map.Entry) itr.next();\n-            sm = (OpenJPAStateManager) entry.getKey();\n-            fields = (BitSet) entry.getValue();\n+\n+        for(Map.Entry<OpenJPAStateManager, BitSet> entry : unloaded.entrySet()) { \n+            sm = entry.getKey();\n+            fields = entry.getValue();\n \n             cache = sm.getMetaData().getDataCache();\n             if (cache == null || sm.isEmbedded() || (failed != null\n@@ -550,10 +550,10 @@ public Collection loadAll(Collection sms, PCState state, int load,\n     /**\n      * Helper method to add an unloaded instance to the given map.\n      */\n-    private static Map addUnloaded(OpenJPAStateManager sm, BitSet fields,\n-        Map unloaded) {\n+    private static Map<OpenJPAStateManager, BitSet> addUnloaded(OpenJPAStateManager sm, BitSet fields,\n+        Map<OpenJPAStateManager, BitSet> unloaded) {\n         if (unloaded == null)\n-            unloaded = new HashMap();\n+            unloaded = new HashMap<OpenJPAStateManager, BitSet>();\n         unloaded.put(sm, fields);\n         return unloaded;\n     }\n@@ -580,24 +580,29 @@ public Collection flush(Collection states) {\n             sm = (OpenJPAStateManager) itr.next();\n \n             if (sm.getPCState() == PCState.PNEW && !sm.isFlushed()) {\n-                if (_inserts == null)\n-                    _inserts = new ArrayList();\n+                if (_inserts == null) {\n+                    _inserts = new ArrayList<OpenJPAStateManager>();\n+                }\n                 _inserts.add(sm);\n \n                 // may have been re-persisted\n-                if (_deletes != null)\n-                    _deletes.remove(sm);\n+                if (_deletes != null) {\n+                    _deletes.remove(sm); \n+                }\n             } else if (_inserts != null \n                 && (sm.getPCState() == PCState.PNEWDELETED \n-                || sm.getPCState() == PCState.PNEWFLUSHEDDELETED))\n+                || sm.getPCState() == PCState.PNEWFLUSHEDDELETED)) {\n                 _inserts.remove(sm);\n+            }\n             else if (sm.getPCState() == PCState.PDIRTY) {\n-                if (_updates == null)\n-                    _updates = new HashMap();\n+                if (_updates == null) {\n+                    _updates = new HashMap<OpenJPAStateManager, BitSet>();\n+                }\n                 _updates.put(sm, sm.getDirty());\n             } else if (sm.getPCState() == PCState.PDELETED) {\n-                if (_deletes == null)\n-                    _deletes = new HashSet();\n+                if (_deletes == null) {\n+                    _deletes = new HashSet<OpenJPAStateManager>();\n+                }\n                 _deletes.add(sm);\n             }\n         }"},{"sha":"33989c7acc923cea5fc5e9df3d8f1ec8b0294617","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -38,6 +38,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.Stack;\n import java.util.TreeSet;\n import java.util.concurrent.locks.ReentrantLock;\n \n@@ -229,6 +230,12 @@\n     private boolean _cachePreparedQuery = true;\n     private boolean _cacheFinderQuery = true;\n     \n+    private DataCacheStoreMode _cacheStoreMode; \n+    private DataCacheRetrieveMode _cacheRetrieveMode;\n+    \n+    // Store and Retrieve mode may be suspended for a given operation. Stack may be overkill here.\n+    private Stack<DataCacheStoreMode> _cacheStoreModeStack = new Stack<DataCacheStoreMode>();\n+    private Stack<DataCacheRetrieveMode> _cacheRetrieveModeStack = new Stack<DataCacheRetrieveMode>();\n \n     // Map of properties whose values have been changed\n //    private Map<String, String> _changedProperties =\n@@ -4894,4 +4901,40 @@ public void setCacheFinderQuery(boolean flag) {\n             unlock();\n         }\n     }\n+\n+    @Override\n+    public DataCacheRetrieveMode getCacheRetrieveMode() {\n+        return _cacheRetrieveMode;\n+    }\n+\n+    @Override\n+    public DataCacheStoreMode getCacheStoreMode() {\n+        return _cacheStoreMode;\n+    }\n+\n+    @Override\n+    public void setCacheRetrieveMode(DataCacheRetrieveMode mode) {\n+        _cacheRetrieveMode = mode;\n+    }\n+\n+    @Override\n+    public void setCacheStoreMode(DataCacheStoreMode mode) {\n+        _cacheStoreMode = mode;\n+    }\n+    \n+    public void popCacheRetrieveMode() { \n+        _cacheRetrieveMode = _cacheRetrieveModeStack.pop();\n+    }\n+    \n+    public void popCacheStoreMode() { \n+        _cacheStoreMode = _cacheStoreModeStack.pop();\n+    }\n+    \n+    public void pushCacheRetrieveMode() { \n+        _cacheRetrieveModeStack.push(_cacheRetrieveMode);\n+    }\n+    \n+    public void pushCacheStoreMode() { \n+        _cacheStoreModeStack.push(_cacheStoreMode);\n+    }\n }"},{"sha":"0a4cea35c695937b6479fdb0363c261828d4ff9f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DataCacheRetrieveMode.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DataCacheRetrieveMode.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DataCacheRetrieveMode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DataCacheRetrieveMode.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+/**\n+ * DataCache Retrieve Modes.\n+ */\n+public enum DataCacheRetrieveMode {\n+    /**\n+     *  Retrieve objects from the DataCache if a DataCache is enabled. \n+     */\n+    USE,\n+    /**\n+     * Ignore the DataCache and fetch data directly from the database. \n+     */\n+    BYPASS,\n+}"},{"sha":"d12a139739b1f48a72c60bef2798156a78026077","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DataCacheStoreMode.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DataCacheStoreMode.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DataCacheStoreMode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DataCacheStoreMode.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+/**\n+ * DataCache Store modes\n+ */\n+public enum DataCacheStoreMode {\n+\n+    /**\n+     * Store updates, inserts and deletes in the DataCache. The DataCache will\n+     * not be refreshed when data is read from the database.\n+     */\n+    USE,\n+    /**\n+     * Write updates, inserts and deletes directly to the database. The\n+     * DataCache will not be aware of these changes and may need to be\n+     * refreshed.\n+     */\n+    BYPASS,\n+    /**\n+     * Store updates, inserts and deletes in the DataCache. Entities which are\n+     * read from the database will be refreshed in the DataCache.\n+     */\n+    REFRESH\n+}"},{"sha":"5aa480d1949bf0c93c8264be5efbfcefdafe3c3d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","status":"modified","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -1411,4 +1411,39 @@ public void setCachePreparedQuery(boolean flag) {\n         _broker.setCachePreparedQuery(flag);\n     }\n \n+    @Override\n+    public DataCacheRetrieveMode getCacheRetrieveMode() {\n+        return _broker.getCacheRetrieveMode();\n+    }\n+\n+    @Override\n+    public DataCacheStoreMode getCacheStoreMode() {\n+        return _broker.getCacheStoreMode();\n+    }\n+\n+    @Override\n+    public void setCacheRetrieveMode(DataCacheRetrieveMode mode) {\n+        _broker.setCacheRetrieveMode(mode);\n+    }\n+\n+    @Override\n+    public void setCacheStoreMode(DataCacheStoreMode mode) {\n+        _broker.setCacheStoreMode(mode);\n+    }\n+    \n+    public void popCacheRetrieveMode() { \n+        _broker.popCacheRetrieveMode();\n+    }\n+    \n+    public void popCacheStoreMode() { \n+        _broker.popCacheStoreMode();\n+    }\n+    \n+    public void pushCacheRetrieveMode() { \n+        _broker.pushCacheRetrieveMode();\n+    }\n+    \n+    public void pushCacheStoreMode() { \n+        _broker.pushCacheStoreMode();\n+    }\n }"},{"sha":"70863e4dab633025cc8cf05d03f5240e2f67bf7d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","status":"modified","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -458,4 +458,61 @@ public void transactionalAll(Collection objs, boolean updateVersion,\n \t * Releases the internal lock.\n \t */\n \tpublic void unlock ();\n+\n+    /**\n+     * Return the current DataCacheStoreMode for this context. The\n+     * DataCacheStoreMode controls when entities are added / updated in the\n+     * DataCache.\n+     * \n+     * @return DataCacheStore mode in use\n+     * @since 2.0.0\n+     */\n+\tpublic DataCacheStoreMode getCacheStoreMode();\n+\t\n+\t/**\n+\t * Set DataCacheStoreMode\n+\t * @param mode The new DataCacheStoreMode\n+\t * @since 2.0.0\n+\t */\n+\tpublic void setCacheStoreMode(DataCacheStoreMode mode);\n+\n+    /**\n+     * Return the current DataCacheRetrieveMode (controls whether objects will\n+     * be loaded from the DataCache or direct from the database).\n+     * \n+     * @return DataCacheRetrieveMode in use.\n+     * @since 2.0.0\n+     */\n+\tpublic DataCacheRetrieveMode getCacheRetrieveMode();\n+\t\n+\t/**\n+\t * Set DataCacheRetrieveMode\n+\t * @param mode new mode for obtaining data from the cache\n+\t * @since 2.0.0\n+\t */\n+\tpublic void setCacheRetrieveMode(DataCacheRetrieveMode mode);\n+\n+\t/**\n+\t * Pop the DataCacheRetrieveMode stack\n+\t * @since 2.0.0\n+\t */\n+    public void popCacheRetrieveMode();\n+    \n+    /**\n+     * Pop the DataCacheStoreMode stack.\n+     * @since 2.0.0\n+     */\n+    public void popCacheStoreMode() ;\n+    \n+    /**\n+     * Push the current DataCacheRetrieveMode onto a saved stack. \n+     * @since 2.0.0     \n+     */\n+    public void pushCacheRetrieveMode() ;\n+\n+    /**\n+     * Push the current DataCacheStoreMode onto a saved stack.\n+     * @since 2.0.0 \n+     */\n+    public void pushCacheStoreMode();\n }"},{"sha":"07c7b7ff6f72223b986aa78cb7e5ca958517c141","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/AbstractCacheModeTestCase.java","status":"added","additions":396,"deletions":0,"changes":396,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/AbstractCacheModeTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/AbstractCacheModeTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/AbstractCacheModeTestCase.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -0,0 +1,396 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.cache.jpa;\n+\n+import java.util.List;\n+\n+import javax.persistence.Cache;\n+import javax.persistence.CacheRetrieveMode;\n+import javax.persistence.CacheStoreMode;\n+import javax.persistence.EntityManager;\n+\n+import org.apache.openjpa.lib.jdbc.AbstractJDBCListener;\n+import org.apache.openjpa.lib.jdbc.JDBCEvent;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.CacheEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.CacheableEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.NegatedCachableEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.NegatedUncacheableEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.UncacheableEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.UnspecifiedEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.XmlCacheableEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.XmlUncacheableEntity;\n+\n+public abstract class AbstractCacheModeTestCase extends AbstractCacheTestCase {\n+    public abstract OpenJPAEntityManagerFactorySPI getEntityManagerFactory();\n+\n+    public abstract List<String> getSql();\n+\n+    protected abstract Class<?>[] getExpectedNotInCache();\n+\n+    protected abstract Class<?>[] getExpectedInCache();\n+\n+    // =======================================================================\n+    // Asserts\n+    // =======================================================================\n+    /**\n+     * Assert whether the cache contains the expected results.\n+     * \n+     * @param cache\n+     *            The JPA Cache to verify\n+     * @param expectCacheables\n+     *            Whether entities with @Cacheable(true) should be in the cache\n+     *            (almost always true)\n+     * @param expectUncacheables\n+     *            Whether entities with @Cacheable(false) should be in the cache\n+     *            (almost always false)\n+     * @param expectUnspecified\n+     *            Whether entities with no @Cacheable annotation should be in\n+     *            the cache (varies per config).\n+     */\n+    protected void assertCacheContents(Cache cache, boolean expectCacheables, boolean expectUncacheables,\n+        boolean expectUnspecified) {\n+        assertCacheables(cache, expectCacheables);\n+        assertUncacheables(cache, expectUncacheables);\n+        assertUnspecified(cache, expectUnspecified);\n+    }\n+\n+    /**\n+     * Assert whether the cacheable types are in the cache. This method exits on\n+     * the first cache 'miss'.\n+     * \n+     * @param cache\n+     *            JPA Cache to verify\n+     * @param expected\n+     *            If true the cacheable types should be in the cache, if false\n+     *            they should not be.\n+     */\n+    protected void assertCacheables(Cache cache, boolean expected) {\n+        assertCached(cache, CacheableEntity.class, 1, expected);\n+        assertCached(cache, NegatedUncacheableEntity.class, 1, expected);\n+        assertCached(cache, XmlCacheableEntity.class, 1, expected);\n+    }\n+\n+    /**\n+     * Assert whether the uncacheable types are in the cache. This method exits\n+     * on the first cache 'miss'.\n+     * \n+     * @param cache\n+     *            JPA Cache to verify\n+     * @param expected\n+     *            If true the uncacheable types should be in the cache, if false\n+     *            they should not be.\n+     */\n+    protected void assertUncacheables(Cache cache, boolean expected) {\n+        assertCached(cache, UncacheableEntity.class, 1, expected);\n+        assertCached(cache, XmlUncacheableEntity.class, 1, expected);\n+        assertCached(cache, NegatedCachableEntity.class, 1, expected);\n+    }\n+\n+    /**\n+     * Assert whether the unspecified types are in the cache. This method exits\n+     * on the first cache 'miss'.\n+     * \n+     * @param cache\n+     *            JPA Cache to verify\n+     * @param expected\n+     *            If true the unspecified types should be in the cache, if false\n+     *            they should not be.\n+     */\n+    protected void assertUnspecified(Cache cache, boolean expected) {\n+        assertCached(cache, UnspecifiedEntity.class, 1, expected);\n+    }\n+\n+    /**\n+     * Assert that no sql is executed when running the supplied Action.\n+     * \n+     * @param act\n+     *            Action to execute.\n+     */\n+    public void assertNoSql(Action act) {\n+        assertSqlInc(act, 0);\n+    }\n+\n+    /**\n+     * Assert that <literal>expectedSqls</literal> SQL statements are executed\n+     * when running <literal>act</literal>\n+     * \n+     * @param act\n+     *            Action to run.\n+     * @param expectedSqls\n+     *            Number of SQL statements that should be executed.\n+     */\n+    public void assertSqlInc(Action act, int expectedSqls) {\n+        int before = getSql().size();\n+        act.run();\n+        assertEquals(before + expectedSqls, getSql().size());\n+    }\n+\n+    // =======================================================================\n+    // Utility classes\n+    // =======================================================================\n+    /**\n+     * Basic 'runnable' interface used to run a set of commands, then analyze\n+     * the number of SQL statements that result.\n+     */\n+    public interface Action {\n+        public void run();\n+    }\n+\n+    /**\n+     * Simple JDBCListener which stores the executed sql in a List. The List is\n+     * provided by the getSql() method so that subclasses may use separate\n+     * lists.\n+     * \n+     * @author mikedd\n+     * \n+     */\n+    public class Listener extends AbstractJDBCListener {\n+        @Override\n+        public void beforeExecuteStatement(JDBCEvent event) {\n+            if (event.getSQL() != null && getSql() != null) {\n+                getSql().add(event.getSQL());\n+            }\n+        }\n+    }\n+\n+    // =======================================================================\n+    // Test utilities\n+    // =======================================================================\n+    public boolean getCacheEnabled() {\n+        return true;\n+    }\n+\n+    // =======================================================================\n+    // Common test methods.\n+    // =======================================================================\n+    /**\n+     * Ensure that each call the em.find generates an SQL statement when\n+     * CacheRetrieveMode.BYPASS is used.\n+     */\n+    public void testReadModeByass() {\n+        assertSqlInc(new Action() {\n+            public void run() {\n+                EntityManager em = getEntityManagerFactory().createEntityManager();\n+                em.setProperty(RETRIEVE_MODE_PROP, CacheRetrieveMode.BYPASS);\n+                for (Class<?> cls : persistentTypes) {\n+                    em.find(cls, 1);\n+                }\n+                em.close();\n+            }\n+        }, persistentTypes.length);\n+    }\n+\n+    /**\n+     * <p>\n+     * Ensure that each entity in getExpectedInCache():\n+     * <ul>\n+     * <li>is in the cache</li>\n+     * <li>does not go to the database for a find operation</li>\n+     * <li>is not null</li>\n+     * </ul>\n+     * </p>\n+     * <p>\n+     * and\n+     * </p>\n+     * <p>\n+     * Ensure that each entity in getExpectedNotInCache() :\n+     * <ul>\n+     * <li>is not in the cache</li>\n+     * <li>results in a single SQL statement when em.find() is called</li>\n+     * <li>is not null</li>\n+     * </ul>\n+     * </p>\n+     * \n+     */\n+    public void testRetrieveModeUse() {\n+        assertNoSql(new Action() {\n+            public void run() {\n+                EntityManager em = getEntityManagerFactory().createEntityManager();\n+                em.setProperty(RETRIEVE_MODE_PROP, CacheRetrieveMode.USE);\n+                for (Class<?> cls : getExpectedInCache()) {\n+                    assertCached(getEntityManagerFactory().getCache(), cls, 1, true);\n+                    assertNotNull(em.find(cls, 1));\n+                }\n+                em.close();\n+            }\n+        });\n+        assertSqlInc(new Action() {\n+            public void run() {\n+                EntityManager em = getEntityManagerFactory().createEntityManager();\n+                em.setProperty(RETRIEVE_MODE_PROP, CacheRetrieveMode.USE);\n+                for (Class<?> cls : getExpectedNotInCache()) {\n+                    assertCached(getEntityManagerFactory().getCache(), cls, 1, false);\n+                    assertNotNull(em.find(cls, 1));\n+                }\n+                em.close();\n+            }\n+        }, getExpectedNotInCache().length);\n+    }\n+\n+    public void updateAndFind(Class<? extends CacheEntity> classToUpdate, int idToUpdate,\n+            Class<? extends CacheEntity> classToFind, int idToFind,\n+            CacheStoreMode storeMode, CacheRetrieveMode retrieveMode) {\n+        EntityManager em = getEntityManagerFactory().createEntityManager();\n+\n+        if (storeMode != null) {\n+            em.setProperty(STORE_MODE_PROP, storeMode);\n+        }\n+        if (retrieveMode != null) {\n+            em.setProperty(RETRIEVE_MODE_PROP, retrieveMode);\n+        }\n+\n+        em.getTransaction().begin();\n+        CacheEntity ce1 = em.find(classToUpdate, idToUpdate);\n+        CacheEntity ce2 = em.find(classToFind, idToFind);\n+        assertNotNull(ce1);\n+        assertNotNull(ce2);\n+        ce1.setName(ce1.getName() + \"UPD\");\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    /**\n+     * <p>\n+     * Test logic to validate different CacheStoreModes. It should behave\n+     * identically for all shared-cache-modes except NONE which never caches\n+     * anything.\n+     * </p>\n+     * <p>\n+     * This method only tests setting the store mode on the EntityManager\n+     * itself.\n+     * </p>\n+     * <p>\n+     * The first transaction updates CacheableEntity::1 with CacheStoreMode\n+     * tran1StoreMode, calls find for CacheableEntity::1 and\n+     * XmlCacheableEntity::1. This will never trigger a cache refresh since the\n+     * data is up to date - but it could trigger additional SQL\n+     * </p>\n+     * <p>\n+     * The second transaction updates XmlCacheableEntity::1 with CacheStoreMode\n+     * tran2StoreMode, calls find for CacheableEntity::1 and\n+     * XmlCacheableEntity::1. In this case if tran2StoreMode ==\n+     * CacheStoreMode.REFRESH we may update the cache with the state of\n+     * CacheableEntity::1.\n+     * </p>\n+     * \n+     * @param tran1StoreMode\n+     *            CacheStoreMode to use in transaction 1.\n+     * @param tran2StoreMode\n+     *            cacheStoreMode to use in transaction 2.\n+     * @param cacheUpdatedForTran1\n+     *            Whether the cache will contain an updated version of\n+     *            CacheableEntity::1\n+     * @param cacheUpdatedForTran2\n+     *            Whether the cache will contain an updated version of\n+     *            XmlCacheableEntity::1\n+     * @param version\n+     *            Expected starting version of for both entities\n+     */\n+    public void entityManagerStoreModeTest(CacheStoreMode tran1StoreMode, CacheStoreMode tran2StoreMode,\n+        boolean cacheUpdatedForTran1, boolean cacheUpdatedForTran2, int version) {\n+        updateAndFind(CacheableEntity.class, 1, XmlCacheableEntity.class, 1, tran1StoreMode, null);\n+        updateAndFind(XmlCacheableEntity.class, 1, CacheableEntity.class, 1, tran2StoreMode, null);\n+\n+        // get entities from the cache and ensure their versions are as\n+        // expected.\n+        EntityManager em = getEntityManagerFactory().createEntityManager();\n+        em = getEntityManagerFactory().createEntityManager();\n+        CacheableEntity ceFromEM = em.find(CacheableEntity.class, 1);\n+        XmlCacheableEntity xceFromEM = em.find(XmlCacheableEntity.class, 1);\n+        em.close();\n+        assertEquals(cacheUpdatedForTran1 ? version + 1 : version, ceFromEM.getVersion());\n+        assertEquals(cacheUpdatedForTran2 ? version + 1 : version, xceFromEM.getVersion());\n+\n+        // get the data from the database. Version should always have been\n+        // updated in this case.\n+        em = getEntityManagerFactory().createEntityManager();\n+        em.setProperty(RETRIEVE_MODE_PROP, CacheRetrieveMode.BYPASS);\n+        CacheableEntity ceFromDB =\n+            (CacheableEntity) em.createNativeQuery(\"Select * from CacheableEntity where id = 1\", CacheableEntity.class)\n+                .getSingleResult();\n+\n+        XmlCacheableEntity xceFromDB =\n+            (XmlCacheableEntity) em.createNativeQuery(\"Select * from XmlCacheableEntity where id = 1\",\n+                XmlCacheableEntity.class).getSingleResult();\n+\n+        assertEquals(version + 1, ceFromDB.getVersion());\n+        assertEquals(version + 1, xceFromDB.getVersion());\n+        em.close();\n+    }\n+\n+    /**\n+     * Execute the defaultStoreModeTest with\n+     */\n+    public void testStoreModeUseBypass() throws Exception {\n+        if (getCacheEnabled()) {\n+            entityManagerStoreModeTest(CacheStoreMode.USE, CacheStoreMode.BYPASS, true, false, 1);\n+        }\n+    }\n+\n+    public void testStoreModeUseUse() {\n+        if (getCacheEnabled()) {\n+            entityManagerStoreModeTest(CacheStoreMode.USE, CacheStoreMode.USE, true, true, 1);\n+        }\n+    }\n+\n+    public void testStoreModeUseRefresh() {\n+        if (getCacheEnabled()) {\n+            entityManagerStoreModeTest(CacheStoreMode.USE, CacheStoreMode.REFRESH, true, true, 1);\n+        }\n+    }\n+\n+    public void entityManagerStoreModeTest() {\n+        if (getCacheEnabled()) {\n+            entityManagerStoreModeTest(CacheStoreMode.BYPASS, CacheStoreMode.BYPASS, false, false, 1);\n+        }\n+    }\n+\n+    public void testStoreModeBypassUse() {\n+        if (getCacheEnabled()) {\n+            entityManagerStoreModeTest(CacheStoreMode.BYPASS, CacheStoreMode.USE, false, true, 1);\n+        }\n+    }\n+\n+    public void testStoreModeBypassRefresh() {\n+        if (getCacheEnabled()) {\n+            // REFRESH picks up the changes from the database, even though the\n+            // first update was done with BYPASS\n+            entityManagerStoreModeTest(CacheStoreMode.BYPASS, CacheStoreMode.REFRESH, true, true, 1);\n+        }\n+    }\n+\n+    public void testStoreModeRefreshUse() {\n+        if (getCacheEnabled()) {\n+            entityManagerStoreModeTest(CacheStoreMode.REFRESH, CacheStoreMode.USE, true, true, 1);\n+        }\n+    }\n+\n+    public void testStoreModeRefreshBypass() {\n+        if (getCacheEnabled()) {\n+            entityManagerStoreModeTest(CacheStoreMode.REFRESH, CacheStoreMode.BYPASS, true, false, 1);\n+        }\n+    }\n+\n+    public void testStoreModeRefreshRefresh() {\n+        if (getCacheEnabled()) {\n+            entityManagerStoreModeTest(CacheStoreMode.REFRESH, CacheStoreMode.REFRESH, true, true, 1);\n+        }\n+    }\n+}"},{"sha":"b7aecf88e5c33a6733638f2b62bb4eabceeaab0e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/AbstractJPACacheTestCase.java","status":"removed","additions":0,"deletions":155,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/78e93abb515193f3b1abd00ee9074186527fb110/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/AbstractJPACacheTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/78e93abb515193f3b1abd00ee9074186527fb110/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/AbstractJPACacheTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/AbstractJPACacheTestCase.java?ref=78e93abb515193f3b1abd00ee9074186527fb110","patch":"@@ -1,155 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.persistence.cache.jpa;\n-\n-import java.lang.reflect.Modifier;\n-\n-import javax.persistence.Cache;\n-import javax.persistence.EntityManager;\n-\n-import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n-import org.apache.openjpa.persistence.OpenJPAPersistence;\n-import org.apache.openjpa.persistence.cache.jpa.featureSelection.CacheEntity;\n-import org.apache.openjpa.persistence.cache.jpa.featureSelection.CacheableEntity;\n-import org.apache.openjpa.persistence.cache.jpa.featureSelection.NegatedCachableEntity;\n-import org.apache.openjpa.persistence.cache.jpa.featureSelection.NegatedUncacheableEntity;\n-import org.apache.openjpa.persistence.cache.jpa.featureSelection.UncacheableEntity;\n-import org.apache.openjpa.persistence.cache.jpa.featureSelection.UnspecifiedEntity;\n-import org.apache.openjpa.persistence.cache.jpa.featureSelection.XmlCacheableEntity;\n-import org.apache.openjpa.persistence.cache.jpa.featureSelection.XmlUncacheableEntity;\n-import org.apache.openjpa.persistence.test.AbstractPersistenceTestCase;\n-\n-public abstract class AbstractJPACacheTestCase extends AbstractPersistenceTestCase {\n-    public abstract OpenJPAEntityManagerFactorySPI getEntityManagerFactory();\n-\n-    private static Class<?>[] persistentTypes =\n-        { CacheableEntity.class, UncacheableEntity.class, UnspecifiedEntity.class, \n-            NegatedCachableEntity.class, NegatedUncacheableEntity.class, XmlCacheableEntity.class,\n-            XmlUncacheableEntity.class };\n-\n-    public void populate() throws IllegalAccessException, InstantiationException {\n-        EntityManager em = getEntityManagerFactory().createEntityManager();\n-        em.getTransaction().begin();\n-        for (Class<?> clss : persistentTypes) {\n-            if (!Modifier.isAbstract(clss.getModifiers())) {\n-                CacheEntity ce = (CacheEntity) clss.newInstance();\n-                ce.setId(1);\n-                em.persist(ce);\n-            }\n-        }\n-        em.getTransaction().commit();\n-        em.close();\n-    }\n-\n-    public OpenJPAEntityManagerFactorySPI createEntityManagerFactory(String puName) {\n-        OpenJPAEntityManagerFactorySPI emf =\n-            (OpenJPAEntityManagerFactorySPI) OpenJPAPersistence.createEntityManagerFactory(puName,\n-                \"META-INF/caching-persistence.xml\", getPropertiesMap(\"openjpa.DataCache\", \"true\",\n-                    \"openjpa.RemoteCommitProvider\", \"sjvm\", persistentTypes));\n-        return emf;\n-    }\n-\n-    @Override\n-    public void setUp() throws Exception {\n-        super.setUp();\n-        // populate once per test method in case we add more methods\n-        cleanDatabase();\n-        populate();\n-    }\n-\n-    public void cleanDatabase() throws Exception {\n-        EntityManager em = getEntityManagerFactory().createEntityManager();\n-        em.getTransaction().begin();\n-        for (Class<?> clss : persistentTypes) {\n-            if (!Modifier.isAbstract(clss.getModifiers())) {\n-                em.createQuery(\"Delete from \" + clss.getSimpleName()).executeUpdate();\n-            }\n-        }\n-        em.getTransaction().commit();\n-        em.close();\n-    }\n-\n-    /**\n-     * Assert whether the cache contains the expected results.\n-     * \n-     * @param cache\n-     *            The JPA Cache to verify\n-     * @param expectCacheables\n-     *            Whether entities with @Cacheable(true) should be in the cache\n-     *            (almost always true)\n-     * @param expectUncacheables\n-     *            Whether entities with @Cacheable(false) should be in the cache\n-     *            (almost always false)\n-     * @param expectUnspecified\n-     *            Whether entities with no @Cacheable annotation should be in\n-     *            the cache (varies per config).\n-     */\n-    protected void assertCacheContents(Cache cache, boolean expectCacheables, boolean expectUncacheables,\n-        boolean expectUnspecified) {\n-        assertCacheables(cache, expectCacheables);\n-        assertUncacheables(cache, expectUncacheables);\n-        assertUnspecified(cache, expectUnspecified);\n-    }\n-\n-    /**\n-     * Assert whether the cacheable types are in the cache. This method exits on\n-     * the first cache 'miss'.\n-     * \n-     * @param cache\n-     *            JPA Cache to verify\n-     * @param expected\n-     *            If true the cacheable types should be in the cache, if false\n-     *            they should not be.\n-     */\n-    protected void assertCacheables(Cache cache, boolean expected) {\n-        assertCached(cache, CacheableEntity.class, 1, expected);\n-        assertCached(cache, NegatedUncacheableEntity.class, 1, expected);\n-        assertCached(cache, XmlCacheableEntity.class, 1, expected);\n-    }\n-\n-    /**\n-     * Assert whether the uncacheable types are in the cache. This method exits\n-     * on the first cache 'miss'.\n-     * \n-     * @param cache\n-     *            JPA Cache to verify\n-     * @param expected\n-     *            If true the uncacheable types should be in the cache, if false\n-     *            they should not be.\n-     */\n-    protected void assertUncacheables(Cache cache, boolean expected) {\n-        assertCached(cache, UncacheableEntity.class, 1, expected);\n-        assertCached(cache, XmlUncacheableEntity.class, 1, expected);\n-        assertCached(cache, NegatedCachableEntity.class, 1, expected);\n-    }\n-\n-    /**\n-     * Assert whether the unspecified types are in the cache. This method exits\n-     * on the first cache 'miss'.\n-     * \n-     * @param cache\n-     *            JPA Cache to verify\n-     * @param expected\n-     *            If true the unspecified types should be in the cache, if false\n-     *            they should not be.\n-     */\n-    protected void assertUnspecified(Cache cache, boolean expected) {\n-        assertCached(cache, UnspecifiedEntity.class, 1, expected);\n-    }\n-}"},{"sha":"ff97cb8805d3cb08af6ae16b60a949feeb19867c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeAll.java","status":"modified","additions":32,"deletions":1,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeAll.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeAll.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeAll.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -18,14 +18,24 @@\n  */\n package org.apache.openjpa.persistence.cache.jpa;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n import javax.persistence.Cache;\n+import javax.persistence.CacheStoreMode;\n \n+import org.apache.openjpa.lib.jdbc.JDBCListener;\n import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n \n-public class TestCacheModeAll extends AbstractJPACacheTestCase {\n+public class TestCacheModeAll extends AbstractCacheModeTestCase {\n \n     private static OpenJPAEntityManagerFactorySPI emf = null;\n     private static Cache cache = null;\n+    private static List<String> sql = new ArrayList<String>();\n+    private static JDBCListener listener;\n+    \n+    private static Class<?>[] expectedInCache = persistentTypes;\n+    private static Class<?>[] expectedNotInCache = {};\n \n     @Override\n     public OpenJPAEntityManagerFactorySPI getEntityManagerFactory() {\n@@ -38,6 +48,17 @@ public OpenJPAEntityManagerFactorySPI getEntityManagerFactory() {\n         return emf;\n     }\n \n+    public JDBCListener getListener() {\n+        if (listener == null) {\n+            listener = new Listener();\n+        }\n+        return listener;\n+    }\n+    \n+    public List<String> getSql() { \n+        return sql;\n+    }\n+    \n     public void testCacheables() {\n         assertCacheables(cache, true);\n     }\n@@ -49,4 +70,14 @@ public void testUncacheables() {\n     public void testUnspecified() {\n         assertUnspecified(cache, true);\n     }\n+\n+    @Override\n+    protected Class<?>[] getExpectedInCache() {\n+        return expectedInCache;\n+    }\n+\n+    @Override\n+    protected Class<?>[] getExpectedNotInCache() {\n+        return expectedNotInCache;\n+    }\n }"},{"sha":"015c99baeb4af85b5bf8db73a3f18d4719939d30","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeDisableSelective.java","status":"modified","additions":40,"deletions":1,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeDisableSelective.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeDisableSelective.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeDisableSelective.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -18,14 +18,32 @@\n  */\n package org.apache.openjpa.persistence.cache.jpa;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n import javax.persistence.Cache;\n+import javax.persistence.CacheStoreMode;\n \n+import org.apache.openjpa.lib.jdbc.JDBCListener;\n import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.CacheableEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.NegatedUncacheableEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.UncacheableEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.UnspecifiedEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.XmlCacheableEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.XmlUncacheableEntity;\n \n-public class TestCacheModeDisableSelective extends AbstractJPACacheTestCase {\n+public class TestCacheModeDisableSelective extends AbstractCacheModeTestCase {\n \n     private static OpenJPAEntityManagerFactorySPI emf = null;\n     private static Cache cache = null;\n+    private static List<String> sql = new ArrayList<String>();\n+    private static JDBCListener listener;\n+    \n+    private static Class<?>[] expectedInCache =\n+        { CacheableEntity.class, XmlCacheableEntity.class, NegatedUncacheableEntity.class, UnspecifiedEntity.class, };\n+    private static Class<?>[] expectedNotInCache =\n+        { UncacheableEntity.class, XmlUncacheableEntity.class, };\n \n     @Override\n     public OpenJPAEntityManagerFactorySPI getEntityManagerFactory() {\n@@ -38,6 +56,17 @@ public OpenJPAEntityManagerFactorySPI getEntityManagerFactory() {\n         return emf;\n     }\n \n+    public JDBCListener getListener() {\n+        if (listener == null) {\n+            listener = new Listener();\n+        }\n+        return listener;\n+    }\n+\n+    public List<String> getSql() {\n+        return sql;\n+    }\n+\n     public void testCacheables() {\n         assertCacheables(cache, true);\n     }\n@@ -49,4 +78,14 @@ public void testUncacheables() {\n     public void testUnspecified() {\n         assertUnspecified(cache, true);\n     }\n+    \n+    @Override\n+    protected Class<?>[] getExpectedInCache() {\n+        return expectedInCache;\n+    }\n+\n+    @Override\n+    protected Class<?>[] getExpectedNotInCache() {\n+        return expectedNotInCache;\n+    }\n }"},{"sha":"2ed9effe5a6f8397563be1d8175ee51a561a4227","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeEnableSelective.java","status":"modified","additions":44,"deletions":2,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeEnableSelective.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeEnableSelective.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeEnableSelective.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -18,14 +18,31 @@\n  */\n package org.apache.openjpa.persistence.cache.jpa;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n import javax.persistence.Cache;\n \n+import org.apache.openjpa.lib.jdbc.JDBCListener;\n import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.CacheableEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.NegatedUncacheableEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.UncacheableEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.UnspecifiedEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.XmlCacheableEntity;\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.XmlUncacheableEntity;\n \n-public class TestCacheModeEnableSelective extends AbstractJPACacheTestCase {\n+public class TestCacheModeEnableSelective extends AbstractCacheModeTestCase {\n \n     private static OpenJPAEntityManagerFactorySPI emf = null;\n     private static Cache cache = null;\n+    private static List<String> sql = new ArrayList<String>();\n+    private static JDBCListener listener;\n+\n+    private static Class<?>[] expectedInCache =\n+        { CacheableEntity.class, XmlCacheableEntity.class, NegatedUncacheableEntity.class, };\n+    private static Class<?>[] expectedNotInCache =\n+        { UncacheableEntity.class, XmlUncacheableEntity.class, UnspecifiedEntity.class, };\n \n     @Override\n     public OpenJPAEntityManagerFactorySPI getEntityManagerFactory() {\n@@ -38,6 +55,31 @@ public OpenJPAEntityManagerFactorySPI getEntityManagerFactory() {\n         return emf;\n     }\n \n+    public JDBCListener getListener() {\n+        if (listener == null) {\n+            listener = new Listener();\n+        }\n+        return listener;\n+    }\n+\n+    public List<String> getSql() {\n+        return sql;\n+    }\n+\n+    @Override\n+    protected Class<?>[] getExpectedInCache() {\n+        return expectedInCache;\n+    }\n+\n+    @Override\n+    protected Class<?>[] getExpectedNotInCache() {\n+        return expectedNotInCache;\n+    }\n+    \n+    // =======================================================================\n+    // Tests\n+    // =======================================================================\n+    \n     public void testCacheables() {\n         assertCacheables(cache, true);\n     }\n@@ -49,5 +91,5 @@ public void testUncacheables() {\n     public void testUnspecified() {\n         assertUnspecified(cache, false);\n     }\n-    \n+\n }"},{"sha":"7aee383c440bb0b1aa3633e24dd32d3bf342d6fb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeNone.java","status":"modified","additions":38,"deletions":1,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeNone.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeNone.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestCacheModeNone.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -18,14 +18,24 @@\n  */\n package org.apache.openjpa.persistence.cache.jpa;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n import javax.persistence.Cache;\n \n+import org.apache.openjpa.lib.jdbc.JDBCListener;\n import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+import org.apache.openjpa.persistence.StoreCache;\n \n-public class TestCacheModeNone extends AbstractJPACacheTestCase {\n+public class TestCacheModeNone extends AbstractCacheModeTestCase {\n \n     private static OpenJPAEntityManagerFactorySPI emf = null;\n     private static Cache cache = null;\n+    private static List<String> sql = new ArrayList<String>();\n+    private static JDBCListener listener;\n+    \n+    private static Class<?>[] expectedInCache = {}; \n+    private static Class<?>[] expectedNotInCache = persistentTypes;\n \n     @Override\n     public OpenJPAEntityManagerFactorySPI getEntityManagerFactory() {\n@@ -38,6 +48,22 @@ public OpenJPAEntityManagerFactorySPI getEntityManagerFactory() {\n         return emf;\n     }\n \n+    public JDBCListener getListener() {\n+        if (listener == null) {\n+            listener = new Listener();\n+        }\n+        return listener;\n+    }\n+\n+    public List<String> getSql() {\n+        return sql;\n+    }\n+    \n+    @Override\n+    public boolean getCacheEnabled() {\n+        return false;\n+    }\n+\n     public void testCacheables() {\n         assertCacheables(cache, false);\n     }\n@@ -49,4 +75,15 @@ public void testUncacheables() {\n     public void testUnspecified() {\n         assertUnspecified(cache, false);\n     }\n+    \n+    @Override\n+    protected Class<?>[] getExpectedInCache() {\n+        return expectedInCache;\n+    }\n+\n+    @Override\n+    protected Class<?>[] getExpectedNotInCache() {\n+        return expectedNotInCache;\n+    }\n+\n }"},{"sha":"5c68b856a29eb1f951866360a1f59027984f338c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/CacheEntity.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/CacheEntity.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/CacheEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/CacheEntity.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -21,4 +21,6 @@\n public interface CacheEntity {\n \n     public void setId(int id);\n+    public void setName(String name);\n+    public String getName();\n }"},{"sha":"507e7446497010f14a2c208329e6b67bd102f0b7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/CacheableEntity.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/CacheableEntity.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/CacheableEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/CacheableEntity.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -31,6 +31,8 @@\n \n     @Version\n     private int version;\n+    \n+    private String name; \n \n     public int getId() {\n         return id;\n@@ -47,4 +49,12 @@ public int getVersion() {\n     public void setVersion(int version) {\n         this.version = version;\n     }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n }"},{"sha":"41d005005821084e0251ab8e712141cbcae404f3","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/NegatedCachableEntity.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/NegatedCachableEntity.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/NegatedCachableEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/NegatedCachableEntity.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -33,6 +33,16 @@\n \n     @Version\n     private int version;\n+    \n+    private String name;\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n \n     public int getId() {\n         return id;"},{"sha":"954750583741372406f3531f3f9173a4c165e722","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/NegatedUncacheableEntity.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/NegatedUncacheableEntity.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/NegatedUncacheableEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/NegatedUncacheableEntity.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -34,6 +34,16 @@\n     @Version\n     private int version;\n \n+    private String name;\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n     public int getId() {\n         return id;\n     }"},{"sha":"8d9bdd92903c012fed05ff6f0d39cb6ddb037ed4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/UncacheableEntity.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/UncacheableEntity.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/UncacheableEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/UncacheableEntity.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -31,6 +31,16 @@\n \n     @Version\n     private int version;\n+    \n+    private String name;\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n \n     public int getId() {\n         return id;"},{"sha":"3d4e796bc57631701f2f44589e317756ef350d69","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/UnspecifiedEntity.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/UnspecifiedEntity.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/UnspecifiedEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/UnspecifiedEntity.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -29,6 +29,16 @@\n \n     @Version\n     private int version;\n+    \n+    private String name;\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n \n     public int getId() {\n         return id;"},{"sha":"c8db48df3423a6d7df1b3f4d3daadca89c145a07","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/XmlCacheableEntity.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/XmlCacheableEntity.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/XmlCacheableEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/XmlCacheableEntity.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -32,6 +32,8 @@\n \n     @Version\n     private int version;\n+    \n+    private String name;\n \n     public int getId() {\n         return id;\n@@ -48,4 +50,12 @@ public int getVersion() {\n     public void setVersion(int version) {\n         this.version = version;\n     }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n }"},{"sha":"c8d1da6a0570748215b8ce7be0930d82f5c7850e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/XmlUncacheableEntity.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/XmlUncacheableEntity.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/XmlUncacheableEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/featureSelection/XmlUncacheableEntity.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -33,6 +33,16 @@\n     @Version\n     private int version;\n \n+    private String name;\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n     public int getId() {\n         return id;\n     }"},{"sha":"ff21202e6d047dd5135c5696b67d92e938462f36","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","status":"modified","additions":43,"deletions":2,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/991cdcae7da3904a932bf9c5c453a6de0685e8c9/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java?ref=991cdcae7da3904a932bf9c5c453a6de0685e8c9","patch":"@@ -38,6 +38,8 @@\n import java.util.Map;\n import java.util.Set;\n \n+import javax.persistence.CacheRetrieveMode;\n+import javax.persistence.CacheStoreMode;\n import javax.persistence.EntityManager;\n import javax.persistence.FlushModeType;\n import javax.persistence.LockModeType;\n@@ -57,6 +59,8 @@\n import org.apache.openjpa.enhance.Reflection;\n import org.apache.openjpa.kernel.AbstractBrokerFactory;\n import org.apache.openjpa.kernel.Broker;\n+import org.apache.openjpa.kernel.DataCacheRetrieveMode;\n+import org.apache.openjpa.kernel.DataCacheStoreMode;\n import org.apache.openjpa.kernel.DelegatingBroker;\n import org.apache.openjpa.kernel.FetchConfiguration;\n import org.apache.openjpa.kernel.FindCallbacks;\n@@ -105,6 +109,9 @@\n     private Map<FetchConfiguration,FetchPlan> _plans = new IdentityHashMap<FetchConfiguration,FetchPlan>(1);\n \n     private RuntimeExceptionTranslator _ret = PersistenceExceptions.getRollbackTranslator(this);\n+    \n+    protected final String RETRIEVE_MODE_PROP = \"javax.persistence.cache.retrieveMode\";\n+    protected final String STORE_MODE_PROP = \"javax.persistence.cache.storeMode\";\n \n     public EntityManagerImpl() {\n         // for Externalizable\n@@ -482,9 +489,9 @@ public void setLifecycleListenerCallbackMode(int callbackMode) {\n     public <T> T find(Class<T> cls, Object oid, LockModeType mode,\n         Map<String, Object> properties) {\n         assertNotCloseInvoked();\n-        if (mode != null && mode != LockModeType.NONE)\n+        if (mode != null && mode != LockModeType.NONE) {\n             _broker.assertActiveTransaction();\n-\n+        }\n         processLockProperties(pushFetchPlan(), mode, properties);\n         try {\n             oid = _broker.newObjectId(cls, oid);\n@@ -1638,4 +1645,38 @@ String getPropertyName(String s) {\n         int dot = s.lastIndexOf('.');\n         return dot == -1 ? s : s.substring(dot+1);\n     }\n+    \n+    public void setRetrieveMode(CacheRetrieveMode retrieveMode) { \n+        _broker.setCacheRetrieveMode(toDataCacheRetrieveMode(retrieveMode));\n+    }\n+\n+    public CacheRetrieveMode getRetrieveMode() { \n+        return fromDataCacheRetrieveMode(_broker.getCacheRetrieveMode());\n+    }\n+    \n+    public void setStoreMode(CacheStoreMode storeMode) { \n+        _broker.setCacheStoreMode(toDataCacheStoreMode(storeMode));\n+    }\n+    \n+    public CacheStoreMode getStoreMode() { \n+        return fromDataCacheStoreMode(_broker.getCacheStoreMode());\n+    }\n+    \n+    private final DataCacheRetrieveMode toDataCacheRetrieveMode(CacheRetrieveMode mode ) {\n+        // relies on the CacheRetrieveMode enums being nearly identical \n+        return DataCacheRetrieveMode.valueOf(mode.toString());\n+    }\n+    \n+    private final DataCacheStoreMode toDataCacheStoreMode(CacheStoreMode mode ) {\n+        // relies on the CacheStoreMode enums being nearly identical \n+        return DataCacheStoreMode.valueOf(mode.toString());\n+    }\n+    \n+    private final CacheRetrieveMode fromDataCacheRetrieveMode(DataCacheRetrieveMode mode) { \n+        return CacheRetrieveMode.valueOf(mode.toString());\n+    }\n+    \n+    private final CacheStoreMode fromDataCacheStoreMode(DataCacheStoreMode mode) { \n+        return CacheStoreMode.valueOf(mode.toString());\n+    }\n }"}]}

